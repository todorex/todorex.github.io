<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="DDD,">





  <link rel="alternate" href="/atom.xml" title="rex note" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="引：读完《实现领域驱动设计》，对于实践还是有些模糊，那就再通过《领域驱动设计——洞见系列》加加餐！">
<meta name="keywords" content="DDD">
<meta property="og:type" content="article">
<meta property="og:title" content="《领域驱动设计——洞见》">
<meta property="og:url" content="http://bestlixiang.site/2020/11/17/读书笔记/领域驱动设计——洞见/index.html">
<meta property="og:site_name" content="rex note">
<meta property="og:description" content="引：读完《实现领域驱动设计》，对于实践还是有些模糊，那就再通过《领域驱动设计——洞见系列》加加餐！">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://static001.infoq.cn/resource/image/fa/5d/fa3131fdcf3f5241442ecd9e8b00105d.png">
<meta property="og:image" content="https://static001.infoq.cn/resource/image/57/4d/576a56f06a82ca80a7ccafd0e537df4d.png">
<meta property="og:image" content="https://static001.infoq.cn/resource/image/16/f1/161e6eb5d57c46af94d5947928b9f2f1.png">
<meta property="og:image" content="http://insights.thoughtworkers.org/wp-content/uploads/2017/07/layers.png">
<meta property="og:image" content="https://static001.infoq.cn/resource/image/e0/c0/e086a4aa43a176a855f32102753567c0.png">
<meta property="og:image" content="https://static001.infoq.cn/resource/image/e7/6d/e77532693b03492dd321c94723046a6d.jpg">
<meta property="og:image" content="https://insights.thoughtworks.cn/wp-content/uploads/2019/06/6.-DDD%E5%AE%9E%E7%8E%B0%E8%BD%AF%E4%BB%B622%E5%86%99%E6%93%8D%E4%BD%9C22%E7%9A%843%E7%A7%8D%E5%9C%BA%E6%99%AF.png">
<meta property="og:image" content="https://insights.thoughtworks.cn/wp-content/uploads/2019/06/7.-CQRS%E6%9E%B6%E6%9E%84.png">
<meta property="og:image" content="https://insights.thoughtworks.cn/wp-content/uploads/2019/06/8.-DDD%E8%AF%BB%E6%93%8D%E4%BD%9C%E7%9A%843%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.png">
<meta property="og:image" content="https://insights.thoughtworks.cn/wp-content/uploads/2019/08/6.png">
<meta property="og:image" content="https://insights.thoughtworks.cn/wp-content/uploads/2019/05/1-Tech-Debt-Landscape.png">
<meta property="og:updated_time" content="2020-11-17T15:59:26.020Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《领域驱动设计——洞见》">
<meta name="twitter:description" content="引：读完《实现领域驱动设计》，对于实践还是有些模糊，那就再通过《领域驱动设计——洞见系列》加加餐！">
<meta name="twitter:image" content="https://static001.infoq.cn/resource/image/fa/5d/fa3131fdcf3f5241442ecd9e8b00105d.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://bestlixiang.site/2020/11/17/读书笔记/领域驱动设计——洞见/">





  <title> 《领域驱动设计——洞见》 | rex note </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">rex note</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">雨过，云过</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://bestlixiang.site/2020/11/17/读书笔记/领域驱动设计——洞见/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rex">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/me.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rex note">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                《领域驱动设计——洞见》
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-17T23:58:28+08:00">
                2020-11-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">本文总阅读量
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>引：读完《实现领域驱动设计》，对于实践还是有些模糊，那就再通过《领域驱动设计——洞见系列》加加餐！<a id="more"></a></p>
<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><h2 id="DDD战略篇：架构设计的影响力"><a href="#DDD战略篇：架构设计的影响力" class="headerlink" title="DDD战略篇：架构设计的影响力"></a>DDD战略篇：架构设计的影响力</h2><p>系统健壮（能适应各种不确定性） 》 稳定 </p>
<p>软件设计共识：通过<strong>组件化</strong>完成<strong>关注点分离</strong>从而<strong>降低局部复杂度</strong> </p>
<p>软件架构设计的实质：让系统能够更快得响应外接业务的变化，并且使得系统能够持续演进</p>
<p>面向业务变化的架构：要求首先理解业务的核心问题，即由针对性的进行关注点分离来找到相对内聚的业务活动形成子问题域</p>
<p>打造架构响应力的方法：DDD通过下面两个方法（模式）解决：</p>
<ol>
<li>让团队中各个角色（从业务到开发测试）都能够采用<strong>统一的架构语言</strong>，从而避免组件划分过程中的边界错误</li>
<li><strong>让业务架构和系统架构形成绑定关系</strong>，从而建立针对业务变化的高响应力架构。（业务架构（描述功能）和系统(技术)架构的区别）</li>
</ol>
<h2 id="DDD战术篇：领域模型的应用"><a href="#DDD战术篇：领域模型的应用" class="headerlink" title="DDD战术篇：领域模型的应用"></a>DDD战术篇：领域模型的应用</h2><p>DDD构建的元模型元素脑图（可以想象的）提供了一个元模型体系，通过这个元模型我们会对战略建模过程冲识别出来的问题子域进行抽象，而通过抽象来知道最后的落地实现。</p>
<p><strong>业务对象的抽象：</strong> 通过对业务问题的子域划分，我们找到了一些关键的<strong>业务对象</strong>，在开始抽象前一个必须的步骤就是<strong>讲故事</strong>！故事是关于这个子域的<strong>业务问题</strong>或者<strong>提供的业务能力</strong>的故事。<strong>故事必须有清晰的业务场景和业务对象之间的交互</strong>。只有当我们能够讲清楚业务场景的时候，才应该开始抽象的的步骤。对于一个业务对象，常见的抽象可以是“实体（Entity）”和“值对象（Value Object）”。这两个抽象方式在定义上的区别是。实体需要给予一个唯一标识，值对象不需要。当更常用的区别是<strong>实体应该使用有一个连续的生命周期。然后在生命周期保持实体状态的一致性。</strong> 所以会发现实体的成本会很大，值对象的成本会低一些，所以会优先考虑值对象建模。</p>
<p><strong>聚合的封装：</strong> 聚合可以让我们把多个实体和值对象的业务封装封装起来。识别聚合是认知潜在核心业务规则的过程。而定义出来的聚合是在大家共识基础上对核心业务规则的封装。</p>
<p><strong>领域服务的定义：</strong> 例子（转账、订单消息通知）</p>
<p><strong>Repositories的使用：</strong> 更多的是粗颗粒度的对象。在DDD这个方法里可以认为映射对象是我们的聚合。然后针对聚合里的实体创建出对应的DAO（可能和ORM框架有关）。这里要注意：不是有一个查询就一定又一个repo与之对应，未尝不可以让服务直接对数据存储实现。记住我们抽象的目标是让建模更加简单，抽象的过程中应该保持灵活。</p>
<p><strong>界限上下文的意义：</strong> DDD通过对子问题域的划分依据进行了对业务能力的分解。而界限上下文在解决方案域中完成了进一步分解。我们不能认为子问题域和界限上下文有严格的一对一的关系，但大多数情况下一个子问题域会被设计成一个或多个界限上下文。我们的重点在区分子问题域和解决方案域。这是落地DDD最困难的地方，也是判断一个架构师能力进阶的分水岭。</p>
<p><strong>战略上要藐视敌人，战术上要重视敌人</strong>。</p>
<p>业务需求是我们的朋友，<strong>战略上要重视朋友，战术上要简化建模</strong></p>
<h2 id="DDD实战篇：分层架构的代码结构"><a href="#DDD实战篇：分层架构的代码结构" class="headerlink" title="DDD实战篇：分层架构的代码结构"></a>DDD实战篇：分层架构的代码结构</h2><p>领域驱动设计DDD，提出了从业务设计到代码实现一致性的要求，不再对分析模型和实现模型进行区分。</p>
<p>在整个DDD的建模过程中，我们更多的是关注核心领域模型的建立，我们认为<strong>完成业务需求</strong>就是在领域模型上的一些列操作（应用）。这些包括了对核心实体状态的改变、领域事件的存储，领域服务的调用等。</p>
<p><strong>分层架构：</strong></p>
<p>Service Layer -&gt; Domain -&gt; Repositories</p>
<p>当我们谈论代码结构的时候，针对的是一个经过DDD建模后的子问题域，这是明确的组件化边界。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">domain</span><br><span class="line">gateways</span><br><span class="line">interface</span><br><span class="line">repositores</span><br><span class="line">services</span><br></pre></td></tr></table></figure>
<p>领域模型一定要可测试，测试的核心原则是让用例尽量测试业务需求而不是实现方式本身。满足业务需求是我们的目标，实现方式可能有多种。不要让持续重构的代码影响到测试用例。</p>
<p>DDD从更高的视角，TDD从更低的视角。</p>
<p>我们反对前期设计的大而全，但是我们认可前期对核心领域模型的分析和设计，这样能够帮助我们更快的响应后续业务的业务变化（即核心模型之上的应用），以为核心的模型变化的频率较外部应用会低很多。如果核心领域模型变化剧烈，那么可能我们业务发生了根本性的变化，需要建立新的模型。</p>
<h2 id="DDD的终极大招——By-Experience"><a href="#DDD的终极大招——By-Experience" class="headerlink" title="DDD的终极大招——By Experience"></a>DDD的终极大招——By Experience</h2><p>架构设计的最后终极大招还是By Exprience——考经验吃饭。从战略角度的subdomain（子问题域的分化）到战术建模层面的Entity和VO的选择，最终的决策很可能不是完全理性，经验这个感性的东西发挥这很大的作用。</p>
<h1 id="通用语言、领域、界限上下文"><a href="#通用语言、领域、界限上下文" class="headerlink" title="通用语言、领域、界限上下文"></a>通用语言、领域、界限上下文</h1><h2 id="如何说好一门通用语言"><a href="#如何说好一门通用语言" class="headerlink" title="如何说好一门通用语言"></a>如何说好一门通用语言</h2><p>在DDD中，通用语言是以界限上下文为边界的。如果一个产品或者项目有个多个界限上下文，我们就需要为每个界限上细问定义通用语言。界限上下文提供了一个语义边界，来保持通用语言和领域概念的意义对应关系。</p>
<p>通过添加约束消除通用语言的歧义。在构建通用语言时，有两个额外的约束条件：子域和界限上下文。</p>
<p><strong>在DDD中，软件的核心是其为客户解决领域相关的问题的能力。</strong></p>
<p>为了分解问题域的复杂度，问题域又会被拆解为多个子域，每个子域都要明确待解决的业务问题和业务流程，以及通过解决业务问题为企业带来了什么样的业务价值。</p>
<p>对于通用语言而言，<strong>子域</strong>解释了通用语言和现实业务活动的关系；<strong>界限上下文</strong>提供了一个语义边界，来保持通用语言和领域模型的一一对应关系；<strong>上下文映射</strong>则提供了不同界限上下文中的通用语言的转换关系。</p>
<h2 id="当Subdomain遇见Bound-Context"><a href="#当Subdomain遇见Bound-Context" class="headerlink" title="当Subdomain遇见Bound Context"></a>当Subdomain遇见Bound Context</h2><p>《领域驱动设计精粹》</p>
<p><strong>区分问题和解决方案是一个老大难问题</strong></p>
<p>区分SubDomain的重要性，比如淘宝专注解决吸引消费者，京东专注解决物流速度。</p>
<p>雷布斯：不要用战术上的勤奋掩盖战略上的懒惰</p>
<p><strong>Subdomain和Bound Context的对应关系</strong></p>
<p>一对多的映射可能是最优的选择。</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="从三明治到六边形"><a href="#从三明治到六边形" class="headerlink" title="从三明治到六边形"></a>从三明治到六边形</h2><p>现实世界的软件开发时复杂的，复杂性并不体现在具体的技术栈上。软件真正复杂的部分往往在是业务本身。</p>
<p>三明治：展现层、应用层（服务层）、数据访问层</p>
<p>六边形（端口和适配器）：内部是业务的核心，即DDD中强调的领域模型；外部则是类似RestFul API、SOAP、AMQP、数据库、内存、文件系统、以及自动化测试</p>
<h2 id="端口和适配器架构——DDD好帮手"><a href="#端口和适配器架构——DDD好帮手" class="headerlink" title="端口和适配器架构——DDD好帮手"></a>端口和适配器架构——DDD好帮手</h2><p>如何快速获取经验？无非是多练，但是练了要讨论和总结</p>
<p><strong>架构的定义：</strong> 应用应能<strong>平等</strong>地被用户、其他程序、自动化测试或脚本<strong>驱动</strong>，也可以<strong>独立</strong>于其最终的运行时设备和数据进行<strong>开发和测试</strong>。</p>
<p>端口和适配器架构由端口和适配器组成，端口是指应用的入口和出口（入口可以理解为usecase，出口可以理解为Repository吧）。而适配器分为两种，主适配器（Driving Adapter）代表用户如何使用应用，即接受用户输入；次适配器（Driven Adapter）实现应用功能的出口端口，向外部工具执行操作。</p>
<p><img src="https://static001.infoq.cn/resource/image/fa/5d/fa3131fdcf3f5241442ecd9e8b00105d.png" alt="img"></p>
<p><img src="https://static001.infoq.cn/resource/image/57/4d/576a56f06a82ca80a7ccafd0e537df4d.png" alt="img"></p>
<p>端口和适配器的优势是突出了分层不是重点，技术实现隔离才是关键</p>
<p><img src="https://static001.infoq.cn/resource/image/16/f1/161e6eb5d57c46af94d5947928b9f2f1.png" alt="img"></p>
<h1 id="领域事件"><a href="#领域事件" class="headerlink" title="领域事件"></a>领域事件</h1><h2 id="识别领域事件"><a href="#识别领域事件" class="headerlink" title="识别领域事件"></a>识别领域事件</h2><p><strong>领域事件</strong>是用特定方式（已发生的事态）表达发生在问题域中的重要事情，是领域通用语言的一部分。</p>
<p>在DDD建模过程中，以领域事件为线索逐步得到领域模型已经成为了主流的时间，即：<strong>事件风暴</strong>。</p>
<p>事件风暴是以更专注的方式发现与提取领域事件，并将以领域事件为中心的概念模型组件演化成以聚合为中心的领域模型。</p>
<p>不同场景产生领域事件的方式不一样</p>
<h2 id="在微服务中使用领域事件"><a href="#在微服务中使用领域事件" class="headerlink" title="在微服务中使用领域事件"></a>在微服务中使用领域事件</h2><p>在DDD中有一条原则：一个业务用例对应一个事务，一个事务对应一个聚合根，也即在一次事务中，只能对一个聚合根进行操作。但是对于一个用例操作两个聚合根的时候就容易违背上面的原则。通过引入领域事件，我们可以很好解决上诉问题。总的来说，领域事件给我们带来了以下好处：</p>
<ul>
<li>解耦微服务（界限上下文）</li>
<li>帮助我们深入理解领域模型</li>
<li>提供审计和报告的数据来源</li>
<li>迈向事件溯源ES和CQRS等</li>
</ul>
<p><strong>事件风暴</strong>是一项团队活动，旨在通过领域事件识别出聚合根，进而划分微服务的界限上下文。在活动中，团队先通过头脑风暴罗列出领域中所有的领域事件，整合之后形成最终的领域事件集合。然后对于每一个事件，标注出导致该事件的命令（Command），在然后为每个事件标注出命令发起方的角色，命令可以是用户发起，也可以是第三方调用或者定时器触发等。最后对事件进行分类整理出聚合根以及界限上下文。</p>
<p><strong>发布领域事件</strong></p>
<p>在使用领域事件时，我们通常采用”发布-订阅“的方式来集成不同的模块或系统。在单个微服务的内部，我们可以使领域事件来集成不同的功能组件。</p>
<p>通常，领域事件产生与领域对象中，或者更准确的说是产出与聚合根中，在具体编码实现时，有多种方式可用于发布领域事件，一种直接的方式是在聚合根中直接调用发布事件的service对象。另一种方式是使用EventPublisher的静态方法来发布领域事件。还有一种是采用在聚合根中临时保存领域事件。在Repository发布事件，并及时清楚events集合。还有一种是在聚合根方法中直接返回领域事件</p>
<p><strong>业务操作和时间发布的原子性</strong></p>
<p>虽然在不同的聚合根之间我们采用了基于领域事件的最终一致性，我是在业务操作和事件发布之间我们依然采用强一致性。我们可以使用本地事件表来保证。当然最重要的还是将事件的消费方创建为幂等的。</p>
<h2 id="事件驱动是什么？"><a href="#事件驱动是什么？" class="headerlink" title="事件驱动是什么？"></a>事件驱动是什么？</h2><p>在领域内有变化发生时，发送事件消息来通知其他系统。时间通知的一个关键点是源系统并不关心外部系统的响应。通常它根本不期待任何结果，及时有也是间接的。发送事件的逻辑流与响应该事件的逻辑流之间会有显著的而格力。</p>
<p><strong>事件不需要包含太多数据</strong>，通常只有一些ID信息和一个指向发送方、可供查询更多信息的链接。接收方知道他已经变化，并且接受到关于变化的最少信息，随后向发送方发出请求，已决定下一步该做什么。</p>
<p><strong>CQRS</strong> 命令查询职责分离是指读取和写入分别拥有单独的数据结构。和事件没有关系</p>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="DDD-amp-MicroServices"><a href="#DDD-amp-MicroServices" class="headerlink" title="DDD &amp; MicroServices"></a>DDD &amp; MicroServices</h2><p>Microservices（微服务架构）和DDD（领域驱动设计）是时下最炙手可热的两个技术词汇。它们之间的关系是什么呢？</p>
<p>DDD是Eric Evans于2003年出版的书名，同时也是这个架构设计方法名的起源。DDD的想法是让我们的软件实现和一个演进的架构模型保持一致，而这个演进的模型来自于我们的业务需求。</p>
<p>每个人能够认知的复杂度都是有限的，在面对高复杂度的时候我们会做<strong>关注点分离</strong>，这是一个最基本的哲学原则。显然在针对复杂业务场景进行建模时，我们也会应用此原则。这个时候去<strong>分离关注点</strong>一般可以从两个维度出发：</p>
<ul>
<li>技术维度分离，类似MVC这样的分层思想是我们广泛接受的。</li>
<li>业务维度分离，根据不同的业态划分系统，比如按售前、销售、售后划分。</li>
</ul>
<p>从本质上作为一种<strong>架构设计方法</strong>的DDD和作为一种<strong>架构风格</strong>的Microservices都是为着追求高响应力目标而从业务视角去分离复杂度的手段。</p>
<p><strong>为了解释清楚这个问题让我们极简化架构设计为以下三个层面工作</strong>：</p>
<ul>
<li>业务架构：根据业务需求设计业务模块及交互关系。</li>
<li>系统架构：根据业务需求设计系统和子系统的模块。</li>
<li>技术架构：根据业务需求决定采用的技术及框架。</li>
</ul>
<p><img src="http://insights.thoughtworkers.org/wp-content/uploads/2017/07/layers.png" alt="img"></p>
<p><strong>DDD的核心诉求就是能够让业务架构和系统架构形成绑定关系，从而当我们去响应业务变化调整业务架构时，系统架构的改变是随之自发的。</strong></p>
<p>这个变化的结果有两个：</p>
<ul>
<li>业务架构的梳理和系统架构的梳理是同步渐进的，其结果是划分出的业务上下文和系统模块结构是绑定的。</li>
<li>技术架构是解耦的，可以根据划分出来的业务上下文的系统架构选择最合适的实现技术。</li>
</ul>
<p><strong>值得一提的是采用DDD这种架构设计方法并不一定就产生Mircoservices这种架构风格</strong>，往往会推荐用大颗粒度的服务来包含业务分析过程中发现的不确定点，以避免拆分后变化过度频繁带来的双向修改成本。</p>
<p><strong>DDD成功运用的基础就是创造让业务和系统这两种不同认知模型逐步统一的环境。</strong></p>
<p><strong>成功的DDD方法运用是贯穿系统的整个生命周期的，这个过程中业务和技术的协作是持续发生的。</strong></p>
<h2 id="服务拆分与架构演进"><a href="#服务拆分与架构演进" class="headerlink" title="服务拆分与架构演进"></a>服务拆分与架构演进</h2><p>企业想要实施微服务架构，经常问到的第一个问题是，怎么拆？如何从单体到服务化的结构？第二个问题是拆完后业务变了增加了怎么办？另外，我们想要改变的系统往往已经成功上线，并有着活跃的用户。那么对其拆分还需要考虑现有的系统运行，如何以安全最快最低成本的方式拆分也是在这个过程中需要回答的问题。</p>
<p>架构演进路上，我们遇到的主要挑战如下：</p>
<ul>
<li><p>如何拆？即如何正确理解业务，将单体结构拆分为服务化架构？</p>
<p>首先需要将客户、体验设计师、业务分析师、技术人员集结在一起对业务需求进行沟通，随后对其进行领域划分，确定限界上下文 (Boundary Context)，也称<strong>战略建模</strong>。</p>
<p><img src="https://static001.infoq.cn/resource/image/e0/c0/e086a4aa43a176a855f32102753567c0.png" alt="img"></p>
<p>一个业务领域或子域是一个企业中的业务范围以及在其中进行的活动，核心子域指业务成功的主要促成因素，是企业的核心竞争力；通用子域不是核心，但被整个业务系统所使用；支撑子域不是核心，不被整个系统使用，该能力可从外部购买。<strong>一个业务领域和子域可以包括多个业务能力，一个业务能力对应一个服务。领域的边界即限界上下文，也是服务的边界，它封装了一系列的领域模型</strong>。</p>
<p>一个业务流程代表了企业的一个业务领域，<strong>业务流程所涉及的数据或角色或是通用子域，或是支撑子域，由其在企业的核心竞争力的角色所决定</strong>。比如企业有统一身份认证，决策不同部门负责不同的流程任务，那么身份认证子域并不产生业务价值，不是业务成功的促成因素，但是所有流程的入口，因而为通用子域，可为单独服务；<strong>而部门负责的业务则为核心子域</strong>。</p>
<p><strong>“旧的不变，新的创建，一步切换，旧的再见”</strong></p>
<p>通过识别内部的被拆模块，对其增加接口层，将旧的引用改为新接口调用；随后将接口封装为 API，并将对接口的引用改为本地 API 调用；最后将新服务部署为新进程，调用改为真正的服务 API 调用。</p>
<p><strong>在拆分步骤上我们更多的推荐数据库先行，通过重复schema 同步数据，对数据库的读写操作分别进行迁移。如下图所示：</strong></p>
<p><img src="https://static001.infoq.cn/resource/image/e7/6d/e77532693b03492dd321c94723046a6d.jpg" alt="img"></p>
</li>
</ul>
<ul>
<li><p>拆完后业务变了增加了怎么办？即在业务需求不断发展变化的前提下，如何持续快速地演进？</p>
<p>客户的业务是在变化的，我们对业务的认知也是逐渐的过程，所以 Martin Fowler 在他的文章中提出，系统的初期建议以单体结构开始，随业务发展决定其是否被拆分或合并。那么这也意味着这样构建的服务在它的生命周期中必然会持续被拆分或合并。那么为了实现这样一个目标，使系统拥有快速的响应力，也要求这样的拆分必然是高效的低成本的。</p>
<p>因此，服务的设计需要满足如下的原则：</p>
<ul>
<li><strong>服务要有明确的业务边界，以单体开始并不意味着没有边界。 服务要有边界，即使以单体开始也要定义单体时期的边界</strong>。</li>
<li>服务要有明确清晰的契约设计，即对外提供的业务能力。（提供各种版本）</li>
<li>服务内部要保持高度模块化，才能够容易的被拆分。</li>
<li>可测试。</li>
</ul>
</li>
<li><p>如何安全地持续地拆？即如何在不影响当下系统运行状态的前提下，持续安全地演进？</p>
<p>一场架构层次的重构，在这样的路上同样需要：</p>
<ul>
<li>坏味道驱动，架构的坏味道是代码坏味道在更高层次的展现，也就意味着架构的混乱程度同样反映了该系统代码层的质量问题。</li>
<li>安全小步的重构。</li>
<li>有足够的测试进行保护 - 契约测试。</li>
<li>持续验证演进的方向。</li>
</ul>
</li>
<li><p>如何保证拆对了？</p>
<p>拆分不能没有目标，尤其在具有风险的架构层次拆分更需谨慎。</p>
<p>其实要回答这个问题，还是要回到拆分之初：为什么而拆？，可能是因为政治原因、业务发展需要，系统集成驱动</p>
</li>
<li><p>拆完了怎么保证不被破坏？</p>
</li>
</ul>
<p>最后，<strong>勿忘初心、且行且演进</strong></p>
<h2 id="微服务案例回顾"><a href="#微服务案例回顾" class="headerlink" title="微服务案例回顾"></a>微服务案例回顾</h2><p>架构的关键在于构造合理的封装抽象。</p>
<p>在<strong>分布式系统</strong>中我们关注组件、组件间的通信以及伴随的工程实践。<strong>微服务</strong>在企业应用的上下文中就<strong>技术约束和业务价值间达成了更好的平衡</strong>。</p>
<p>服务的设计不只聚焦于当下需求，更需要考虑价值定位和产品愿景。</p>
<p>如今我们对服务的定义已经超越了技术组件，领先的组织已经在尝试将design thinking, business operating model应用到微服务设计中。<strong>业务逻辑</strong></p>
<p><strong>服务间的集成应该依赖封装好的显示接口，而不是数据库这种实现细节</strong>。我们应该在兼顾数据一致性的情况下，为每个微服务分配独立的db schema甚至db instance。</p>
<p><strong>Technologies come and go, Principles stay forever。</strong></p>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="开发者的第0个迭代"><a href="#开发者的第0个迭代" class="headerlink" title="开发者的第0个迭代"></a>开发者的第0个迭代</h2><ol>
<li><p>从写好Readme开始</p>
<ul>
<li>项目简介：用一两句话简单描述该项目实现的业务功能</li>
<li>技术选型：列出项目技术栈、包括语言和中间件等</li>
<li>本地构建：列出本地开发过程中所用到的工具命令</li>
<li>领域模型：核心领域模型概念，比如电商系统来说有Order、Product等</li>
<li>测试策略：自动化测试如何分类，哪些必须写测试，哪些没有必要写测试</li>
<li>技术架构：技术架构图</li>
<li>部署架构：部署架构图</li>
<li>外部依赖：项目运行时所依赖的外部集成方，比如订单系统会依赖会员系统</li>
<li>环境信息：各个环境的访问方式，数据库连接等</li>
<li>编码实践：统一的编码实践，比如一次处理原则、分页封装等</li>
<li>FAQ：开发过程中常见问题的解答</li>
</ul>
</li>
<li><p>一键式本地构建</p>
<ul>
<li>生成IDE工程：idea.sh，生成IntelliJ工程问题并自动打开InteliJ</li>
<li>本地运行：run.sh，本地启动项目，自动 启动本地数据库，监听调试端口5005</li>
<li>本地构建：local-build.sh，有本地构建成功才能提交代码</li>
</ul>
</li>
<li><p>目录结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gradle</span><br><span class="line">src</span><br><span class="line">idea.sh</span><br><span class="line">local-build.sh</span><br><span class="line">run.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于业务分包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">order</span><br><span class="line">  model</span><br><span class="line">common</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动化测试分类</p>
<ul>
<li>单元测试：核心的领域模型，包括领域对象、Factory类、领域服务类</li>
<li>组件测试（集成测试）：不适合写单元测试但是又必须测试的类，如Repository</li>
<li>API测试：模拟客户端测试各种API接口，需要启动程序</li>
</ul>
</li>
<li><p>日志处理</p>
<ul>
<li>在日志中加入请求标识，便于链路追踪，如logback的MDC功能</li>
<li>集中式日志管理，在多节点部署的场景下，各个节点的日志是分散的，为此可以引入ELK、Graylog之类的工具将日志统一输出到ElasticSearch中</li>
</ul>
</li>
<li><p>异常处理</p>
<ul>
<li>向客户端提供格式统一的异常返回</li>
<li>异常信息中应该包含足够多的上下文信息，最好是结构化的数据以便与客户端解析</li>
<li>不同类型的异常应该包含唯一标识，以便客户端精确识别</li>
<li>异常处理通常有两种方式，一种是层级式，即每种具体的异常都对应了一个异常类，这个类最终继承自某个父类；另一种是单一式，即整个程序中只有一个异常类，再以一个字段拿来区分不同的异常场景。</li>
</ul>
</li>
<li><p>后台任务与分布式锁</p>
</li>
<li><p>统一代码风格</p>
<ul>
<li>客户端的请求数据类统一使用相同后缀，比如Command</li>
<li>返回给客户端的数据统一使用相同后缀，比如Representation</li>
<li>统一对请求处理的流程框架，比如采用传统的3层架构或者DDD战术模式</li>
<li>提供一直的异常返回</li>
<li>提供统一的分页结构类</li>
<li>明确测试分类以及统一的测试基础类</li>
</ul>
</li>
<li><p>静态代码检查</p>
</li>
<li><p>健康检查</p>
</li>
<li><p>API文档 swagger</p>
</li>
<li><p>数据库迁移 ddl文件</p>
</li>
<li><p>多环境构建</p>
<ul>
<li>local</li>
<li>ci</li>
<li>dev</li>
<li>qa</li>
<li>uat</li>
<li>prod</li>
<li>cors 跨域</li>
</ul>
</li>
</ol>
<h2 id="领域驱动设计（DDD）编码实践"><a href="#领域驱动设计（DDD）编码实践" class="headerlink" title="领域驱动设计（DDD）编码实践"></a>领域驱动设计（DDD）编码实践</h2><p>战略设计更偏向于软件架构，战术设计更偏向于编码实践</p>
<p><strong>实现业务的三种常见方式</strong></p>
<ol>
<li><p>基于”Service + 贫血模型”的实现</p>
<p>特点：存在一个贫血的领域对象，业务逻辑通过一个Service类实现，然后通过setter方法更新领域对象、最后通过DAO保存到数据库中 （业务逻辑泄漏）</p>
</li>
<li><p>基于事务脚本的实现</p>
<p>领域对象都没有存在的必要，但是增加了更多的DAO方法，此时DAO不再是对持久化的封装，而且也会包含业务逻辑</p>
</li>
<li><p>基于领域对象的实现</p>
</li>
</ol>
<p><strong>基于业务的分包</strong></p>
<p>业务分包即通过软件锁实现的业务功能进行模块划分，而不是从技术角度划分（比如划分出service和infrastructure）。在战术实践中，所采用的原则逃离不了“内聚性”和“职责分离”等基本原则。</p>
<p>在DDD中，聚合根是主要业务逻辑的承载体，也是内聚性原则的典型代表，因此通常的做法便是基于聚合根进行顶层包的划分。比如电商项目的两个聚合根对象Order和Product。</p>
<p><strong>领域模型的门面——应用服务</strong></p>
<p>在DDD实践中，自然应该采用自顶向下的实现方式。ApplicationService实现遵循一个很简单的原则，即一个业务用例对应ApplicaitonSerivce上一个业务方法。<strong>在应用服务上实现事务</strong>。</p>
<p>Application需要遵循以下原则：</p>
<ul>
<li>业务方法与业务用例一一对应</li>
<li>也无法方法与事务一一对应：每一个业务方法均构成独立的事务边界</li>
<li>本身不应该包含业务逻辑</li>
<li>与UI和通信协议无关</li>
</ul>
<p><strong>业务的载体——聚合根</strong></p>
<p>除了内聚性和一致性，聚合根还有以下特征：</p>
<ol>
<li>聚合根的实现应该与框架无关</li>
<li>聚合根之间的应用通过ID完成，一次业务用例只会更新一个聚合根，所以在聚合根去引用其他聚合根的整合没有任何好处</li>
<li>聚合根内部的所有变更都必须通过聚合根改成，为了保证聚合根的一致性，同时避免聚合根内部逻辑向外泄露。</li>
<li>如果一个事务要更新多个聚合根，要考虑引用消息机制和事件驱动架构，异步更新其他聚合根</li>
<li>聚合根不应该引用基础设施</li>
<li>外接不应该只有聚合根内部的数据结构</li>
<li>尽量使用小聚合</li>
</ol>
<p><strong>实体vs值对象</strong></p>
<p>实体：ID唯一，具有变化的生命周期</p>
<p>值对象：值是不可变的</p>
<p><strong>聚合根的家——资源库</strong></p>
<p>在所有对象对象中，只有聚合根才配得上拥有Repository，而DAO没有这种约束</p>
<p>有的DDD实践者，任务一个纯粹的Repository值应该包含这两个方法（Save和ByID）</p>
<p><strong>创生之柱——工厂</strong></p>
<p>创建聚合根通常通过设计模式的工厂模式完成</p>
<p>聚合根的创建可简单可复杂，有时可能直接调用构造函数即可，而有时却存在一个复杂的构造流程，比如需要调用其他系统获取数据，通过来说，Factory有两种实现方式：</p>
<ol>
<li>直接在聚合根中实现Factory方法，常用于简单创建过程</li>
<li>独立的Factory类，用于一定复杂度的创建过程，或者创建逻辑不适合放在聚合根上（比如IDGenerator）</li>
</ol>
<p><strong>必要的妥协——领域服务</strong></p>
<p>DomainService用来处理聚合根不能处理的业务方法，越少越好。</p>
<p><strong>Command对象</strong></p>
<p>从技术上将，Command对象是一种类型的DTO对象，在controller中所接受写操作都需要通过Command进行包装，在Command比较简单（比如只有一两个字段）的情况下Controller可以将Command解开，将其中的数据直接传给ApplicationService、而在Command中数据字段比较多的时候，可以将Command对象直接传递给ApplicationService。<strong>具体怎么传只是一个编码习惯上的选择</strong>。</p>
<p><strong>写操作</strong></p>
<ol>
<li>通过聚合根完成业务请求</li>
<li>通过Factory完成聚合根的创建</li>
<li>通过DomainService完成业务请求</li>
</ol>
<p><img src="https://insights.thoughtworks.cn/wp-content/uploads/2019/06/6.-DDD%E5%AE%9E%E7%8E%B0%E8%BD%AF%E4%BB%B622%E5%86%99%E6%93%8D%E4%BD%9C22%E7%9A%843%E7%A7%8D%E5%9C%BA%E6%99%AF.png" alt="DDD实现软件&quot;写操作&quot;的3种场景"></p>
<p>创建聚合根通过Factory完成，业务逻辑优先在聚合根边界内完成，聚合根中不合适放置的业务逻辑才考虑放在DomainService中。</p>
<p><strong>读操作</strong></p>
<p>在DDD的写操作中，我们需要严格按照应用服务-&gt;聚合根-&gt;资源库的接口进行编码，而在读操作往往采用下面的方式：</p>
<ol>
<li><p>基于领域模型的读操作</p>
<p>优点：直接使用Repository读取数据即可</p>
<p>缺点：读操作完全束缚与聚合根的边界划分，繁琐低效；基于不同的查询条件返回数据，导致Repository处理太多查询逻辑，偏离Repository应该承担的责任</p>
</li>
<li><p>基于数据模型的读操作</p>
<p>绕开资源库和聚合，直接从数据库中读取客户端所需要的数据，此时写操作和读操作共享的只是数据库。通过一个专门的XXRepresentationService直接从数据库中读取数据。（用这种吧）</p>
</li>
<li><p>CQRS</p>
<p>与“基于数据模型的读操作”不同的是，在CRQS中写操作和读操作使用不同的数据库，数据从写模型数据库同步到读模型数据库，<strong>通常通过领域事件的形式同步变更信息</strong>。</p>
<p><img src="https://insights.thoughtworks.cn/wp-content/uploads/2019/06/7.-CQRS%E6%9E%B6%E6%9E%84.png" alt="CQRS架构"></p>
<p>这样依赖，读操作便可以根据自身所需独立设计数据结构，而不用受写模型数据结构的牵制。</p>
<p><img src="https://insights.thoughtworks.cn/wp-content/uploads/2019/06/8.-DDD%E8%AF%BB%E6%93%8D%E4%BD%9C%E7%9A%843%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.png" alt="DDD读操作的3种实现方式"></p>
</li>
</ol>
<p>无论哪种读操作，都需要遵循一个原则：领域模型中的对象不能直接返回给客户端。</p>
<p>在读操作汇总，我们通过Represention进行展现数据的统一</p>
<h2 id="事件驱动架构（EDA）编码实践"><a href="#事件驱动架构（EDA）编码实践" class="headerlink" title="事件驱动架构（EDA）编码实践"></a>事件驱动架构（EDA）编码实践</h2><h3 id="领域事件的建模"><a href="#领域事件的建模" class="headerlink" title="领域事件的建模"></a>领域事件的建模</h3><p>领域事件是DDD中的一个概念，表示的是在一个领域中所发生的一次对业务有价值的事情，落到技术层面就是在一个业务实体对象(通常来说是聚合根)的状态发生了变化之后需要发出一个领域事件。</p>
<p><strong>创建领域事件</strong></p>
<p>在建模领域事件时，首先需要记录事件的一些通用信息，比如唯一标识ID和创建时间等</p>
<p>在DDD场景下，领域事件一般随着聚合根状态的更新而产生，另外，在事件的消费方，有时我们希望监听发生在某个聚合根下的所有事件，为此笔者建议为每一个聚合根对象创建相应的事件基类，其中包含聚合根的ID，比如对于订单(Order)类</p>
<p>在创建领域事件时，需要注意2点：</p>
<ul>
<li>领域事件本身应该是不变的(Immutable)；</li>
<li>领域事件应该携带与事件发生时相关的上下文数据信息，但是并不是整个聚合根的状态数据</li>
</ul>
<p><strong>发布领域事件</strong></p>
<p>发布领域事件有多种方式，比如可以在应用服务(ApplicationService)中发布，也可以在资源库(Repository)中发布，还可以引入事件表的方式。</p>
<p>当前，一种比较受推崇的方式是引入事件表，其流程大致如下：</p>
<ol>
<li>在更新业务表的同时，将领域事件一并保存到数据库的事件表中，此时业务表和事件表在同一个本地事务中，即保证了原子性，又保证了效率。</li>
<li>在后台开启一个任务，将事件表中的事件发布到消息队列中，发送成功之后删除掉事件。</li>
</ol>
<p>在事件表场景下，一种常见的做法是将领域事件保存到聚合根中，然后在Repository保存聚合根的时候，将事件保存到事件表中。这种方式对于所有的Repository/聚合根都采用的方式处理，因此可以创建对应的抽象基类。</p>
<p><strong>消费领域事件</strong></p>
<p>在事件消费时，除了完成基本的消费逻辑外，我们需要重点关注以下两点：</p>
<ol>
<li>消费方的幂等性</li>
<li>消费方有可能进一步产生事件</li>
</ol>
<p>对于“消费方的幂等性”，在上文中我们讲到事件的发送机制保证的是“至少一次投递”，为了能够正确地处理重复消息，要求消费方是幂等的，即多次消费事件与单次消费该事件的效果相同。为此，<strong>在消费方创建一个事件记录表，用于记录已经消费过的事件，在处理事件时，首先检查该事件是否已经被消费过，如果是则不做任何消费处理。</strong></p>
<p>在消费领域事件的过程中，程序需要更新业务表、事件记录表以及事件发送表，这3个操作过程属于同一个本地事务。</p>
<p><strong>事件驱动架构的3种风格</strong></p>
<ol>
<li><p>事件通知</p>
<p>\1. 发布方发布事件<br>\2. 消费方接收事件并处理<br>\3. 消费方调用发布方的API以获取事件相关数据<br>\4. 消费方更新自身状态</p>
</li>
<li><p>事件携带状态转移(Event-Carried State Transfer)</p>
</li>
<li><p>事件溯源</p>
</li>
</ol>
<p>对于发布方来说，作为一种数据提供者的“自我修养”，事件应该包含足够多的上下文数据，而对于消费方来讲，可以根据自身的实际情况确定具体采用哪种风格。在同一个系统中，同时采用2种风格是可以接受的。比如，对于基于事件的CQRS而言，可以采用“事件通知”，此时的事件只是一个“触发器”，一个聚合下的所有事件所触发的结果是一样的，即都是告知消费方需要从源系统中同步数据，（因此此时的消费方可以对聚合下的所有事件一并处理，而不用为每一种事件单独开发处理逻辑。）？？？</p>
<h3 id="实例项目"><a href="#实例项目" class="headerlink" title="实例项目"></a>实例项目</h3><p>该电商系统包含3个微服务，分别是：<br>- 订单(Order)服务：用于用户下单<br>- 产品(Product)服务：用于管理/展示产品信息<br>- 库存(Inventory)服务：用于管理产品对应的库存</p>
<p>整个系统中涉及到的领域事件如下：</p>
<p><img src="https://insights.thoughtworks.cn/wp-content/uploads/2019/08/6.png" alt="img"></p>
<p>其中：</p>
<ul>
<li>Order服务自己消费了自己产生的所有<code>OrderEvent</code>用于CQRS同步读写模型；</li>
<li>Inventory服务消费了Order服务的<code>OrderCreatedEvent</code>事件，用于在下单之后即时扣减库存；</li>
<li>Inventory服务消费了Product服务的<code>ProductCreatedEvent</code>和<code>ProductNameChangedEvent</code>事件，用于同步产品信息；</li>
<li>Product服务消费了Inventory服务的<code>InventoryChangedEvent</code>用于更新产品库存。</li>
</ul>
<h2 id="简单可用的CQRS编码实践"><a href="#简单可用的CQRS编码实践" class="headerlink" title="简单可用的CQRS编码实践"></a>简单可用的CQRS编码实践</h2><p>软件模型中存在读模型和写模型之分，CQRS便为此而生</p>
<p>20多年前，Bertrand Meyer在他的《Object-Oriented Software Construction》一书中提出了CQS（Command Query Seperation，命令查询分离）的概念，指出：</p>
<p>Every method should either be a command that performs an action, or a query that returns data to the caller, but never both. (一个<strong>方法</strong>要么作为一个“命令”执行一个操作，要么作为一次“查询”向调用方返回数据，但两者不能共存。）这里的“命令”可以理解为更新软件状态的写操作，Martin Fowler将此称为“Modifier”；而“查询”即为读操作，是无副作用的。</p>
<p>后来，Greg Young在此基础上提出了CQRS（Command Query Resposibility Segregation，命令查询职责分离），<strong>将CQS的概念从方法层面提升到了模型层面</strong>，即“命令”和“查询”分别使用不同的对象模型来表示。</p>
<p>采用CQRS的驱动力除了从CQS那里继承来的好处之外，还旨在解决软件中日益复杂的查询问题，比如有时我们希望从不同的维度查询数据，或者需要将各种数据进行组合后返回给调用方。此时，将查询逻辑与业务逻辑糅合在一起会使软件迅速腐化，诸如逻辑混乱、可读性变差以及可扩展性降低等等一些列问题。</p>
<p>对于Command侧，主要的讲究是将业务用例建模成对应的Command对象，然后在对Command的处理流程中应用核心的业务逻辑，其中最重要的是领域模型的建模。下面着重介绍Query侧的编码实践。</p>
<p><strong>CQRS究其本意只是要求“读写模型的分离”，并未要求使用Event Sourcing</strong>；再者，Event Sourcing会极大地增加软件的复杂度，而本文追求的是“简单可用的CQRS”</p>
<p><strong>另外需要指出的是，读写模型的分离并不一定意味着数据存储的分离</strong>，不过在实际应用中，数据存储分离是一种常见的CQRS实践模式，在这种模式中，写模型的数据会同步到读模型数据存储中，同步过程通常通过消息机制完成，在DDD场景下，消息通常承载的是领域事件（Domain Event）。</p>
<p><strong>查询模型的数据来源</strong></p>
<p>所读数据的来源形式大致分为以下几种：</p>
<ul>
<li>所读数据来源于同一个进程空间的单个实体（后文简称“<strong>单进程单实体</strong>”），这里的进程空间指某个单体应用或者单个微服务；</li>
<li>所读数据来源于同一个进程空间中的多个实体（后文简称“<strong>单进程跨实体</strong>”）；</li>
<li>所读数据来源于不同进程空间中的多个实体（后文简称“<strong>跨进程跨实体</strong>”）。</li>
</ul>
<p><strong>读写模型的分离形式</strong></p>
<p>CQRS中的读写分离存在2个层次，<strong>一层是代码中的模型是否需要分离</strong>，<strong>另一层是数据存储是否需要分离</strong>，总结下来有以下几种：</p>
<ul>
<li><strong>共享存储/共享模型：</strong>读写模型共享数据存储（即同一个数据库），同时也共享代码模型，数查询据通过模型转换后返回给调用方，事实上这不能算CQRS，但是对于很多中小型项目而言已经足够；</li>
<li><strong>共享存储/分离模型：</strong>共享数据存储，代码中分别建立写模型和读模型，读模型通过最适合于查询的方式进行建模；</li>
<li><strong>分离存储/分离模型：</strong>数据存储和代码模型都是分离的，这种方式通常用于需要聚合查询多个子系统的情况，比如微服务系统。</li>
</ul>
<p>将以上“查询模型的数据来源”与“读写模型的分离形式”相组合，我们可以得到以下不同的CQRS模式及其适用范围，有以下几种常见做法：</p>
<ul>
<li><strong>单进程单实体 + 共享存储/共享模型</strong></li>
<li><strong>单进程单实体 + 共享存储/分离模型</strong></li>
<li><strong>单进程跨实体 + 共享存储/分离模型</strong></li>
<li><strong>单进程跨实体 + 分离存储/分离模型</strong></li>
<li><strong>跨进程跨实体 + 分离存储/分离模型</strong></li>
</ul>
<p>可以为查询单独起一个服务，通过接受领域事件来构建读模型</p>
<p>不管在架构层面还是编码层面，采用CQRS的都会增加程序的复杂度和代码量，不过，这种复杂性可以在很大程度上被其所带来的“条理性”所抵消，“有条理的多”恰恰是为了简单。</p>
<h2 id="用DDD实现打卡系统"><a href="#用DDD实现打卡系统" class="headerlink" title="用DDD实现打卡系统"></a>用DDD实现打卡系统</h2><p>可以参考</p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><h2 id="DDD该如何学"><a href="#DDD该如何学" class="headerlink" title="DDD该如何学"></a>DDD该如何学</h2><ol>
<li>《领域驱动设计》</li>
<li>《企业应用架构》</li>
<li>《实现领域驱动设计》</li>
<li>《领域驱动设计模式、原理与实践》</li>
<li>《领域驱动设计精粹》</li>
</ol>
<p>相信我，光学习理论是没有用的，你必须将其应用于实践，在自己的真实项目里演练DDD，最后通过By Experience 实践来出真知。</p>
<h2 id="领域驱动设计（DDD）实现之路"><a href="#领域驱动设计（DDD）实现之路" class="headerlink" title="领域驱动设计（DDD）实现之路"></a>领域驱动设计（DDD）实现之路</h2><p>一个软件系统是否真正可用是通过它所提供的业务价值体现出来的，因此，与其每天钻在哪些永远也学不完的技术中，何不将我们的关注点向软件系统所提供的业务价值方向思考。这也是DDD所试图解决的问题。</p>
<p><strong>DDD有战略设计和战术设计之分</strong>。<strong>战略设计</strong>主要从高层<strong>俯视</strong>我们的软件系统，帮助我们精准地划分领域以及处理各个领域之间的关系；而<strong>战术设计</strong>则从技术实现的层面教会我们如何具体得实施DDD。</p>
<p><strong>战略设计</strong></p>
<ol>
<li>领域/子域</li>
<li>通用语言</li>
<li>界限上下文（概念边界）</li>
<li>架构风格（使用六边形架构（端口和适配器的组合）：抽象不应该依赖于细节，细节应该依赖于抽象）</li>
</ol>
<p><strong>战术设计</strong></p>
<p>战术设计将战略设计进行具体化和细节化</p>
<ol>
<li><p>实体</p>
<p>实体表示哪些具有生命周期并且会在生命周期中发生改变的东西，通过唯一标识来判断相等。</p>
</li>
<li><p>值对象</p>
<p>起描述性作用并且可以相互替换的概念，通过数据的值来判断相等。</p>
</li>
<li><p>聚合</p>
<p>一个聚合可以包含多个实体和值对象，聚合所包含的对象具有密不可分的联系。聚合是持久化的基本单位，他和资源库就有一一对应的关系。聚合之间的引用应该通过ID。使用聚合的首要原则为在一次事务中，最多只能更改一个聚合的状态。如果一次业务操作涉及到了对多个聚合状态的更改，应该采用发布领域事件的方式通知响应的绝活，此时数据的一致性从事务一致性变成了最终一致性。</p>
</li>
<li><p>领域服务</p>
<p>当无法把概念放在实体或值对象的时候，就可以放在领域服务上了</p>
</li>
<li><p>资源库</p>
<p>资源库用于保存和获取对象。我们要区分Repository和DAO。所有实体都有对应的DAO，只有聚合才有资源库。有两种实现方式：基于集合、基于持久化。</p>
</li>
<li><p>领域事件</p>
<p>为了<strong>使用聚合的首要原则为在一次事务中，最多只能更改一个聚合的状态</strong>问题，我们通过领域事件来保持最终一致性。领域事件的命名为“名词+动词过去分词”格式，表示先前发生过的一件事。同时领域事件还可用于CQRS软件系统中的写模型和读模型之间的数据同步。再进一步是形成Event Sourcing</p>
</li>
</ol>
<h2 id="从四色建模法到界限纸笔建模法"><a href="#从四色建模法到界限纸笔建模法" class="headerlink" title="从四色建模法到界限纸笔建模法"></a>从四色建模法到界限纸笔建模法</h2><h3 id="四色建模法"><a href="#四色建模法" class="headerlink" title="四色建模法"></a>四色建模法</h3><ol>
<li><p>寻找要追溯的事件</p>
<p>谁，在什么时候，干了什么</p>
</li>
<li><p>识别”时标对象”</p>
<p>按照时间发展的先后顺序，用红色表示起到“追溯单据”作用的“时标”概念</p>
</li>
<li><p>寻找时标对象周围的“人、地、物”，也标上红色</p>
</li>
<li><p>在3图里添加表示<strong>角色</strong>的黄色</p>
</li>
<li><p>在4图中添加表示<strong>描述</strong>的蓝色（一般给时标对象）对应了值对象</p>
</li>
</ol>
<h3 id="界限纸笔建模法"><a href="#界限纸笔建模法" class="headerlink" title="界限纸笔建模法"></a>界限纸笔建模法</h3><p>利用四色建模法可以按照时间发展的先后顺序，识别出起到“追溯单据”作用的时标概念。这种识别方法直达业务核心数据，简便有效。</p>
<p>此外，界限纸笔建魔法可以继续进行以下三项建模工作：</p>
<ol>
<li>划分界限上下文、避免模型发展成“大泥球架构”</li>
<li>强调“聚合根”的概念，更好保证数据的完整性</li>
<li>寻找“恰好够用”的概念，避免过度设计，降低所建模型的复杂性</li>
</ol>
<p>流程：</p>
<ol>
<li>根据”追溯单据”的价值识别核心领域</li>
<li>确定核心领域之间的领域关系</li>
<li>用纸和笔画表格并写实例</li>
<li>确认”聚合根”</li>
<li>以”人以群分”的原则抽取新的聚集</li>
</ol>
<p>3个优势：</p>
<ol>
<li>划分核心领域有助于”分为治之”：一旦确定核心领域，界限上下文也就确定了，不同的界限上下文之间通过”翻译器（反腐层）”来彼此工程并屏蔽干扰。</li>
<li>“聚合根”有助于数据完整性：每个界限上下文都有一个“聚合根”的概念，外界对其下属概念的访问都必须通过它来进行，这样既方便定位职责，也有助于数据的完整性。</li>
<li>用“纸和笔”画恰好够用的概念有助于避免过度设计。</li>
</ol>
<h2 id="可视化架构设计——C4介绍"><a href="#可视化架构设计——C4介绍" class="headerlink" title="可视化架构设计——C4介绍"></a>可视化架构设计——C4介绍</h2><p>当我们看待真实世界的“架构图”时候，也是要不停的缩放，在每一个层次可以忽略一些细节才能表达好当前抽象层次的信息，所以架构也有四个抽象层次：</p>
<p>系统System Context、容器Container、组件Component、代码Code</p>
<p>图元素：关系-线；元素-方块和角色；关系的表述-线上的文字、元素的描述-方块里的文字，虚线框</p>
<h2 id="架构可视化入门到抽象坏味道"><a href="#架构可视化入门到抽象坏味道" class="headerlink" title="架构可视化入门到抽象坏味道"></a>架构可视化入门到抽象坏味道</h2><p>从C4图中如果有下面几个迹象就表示我们有可视化的坏味道</p>
<ol>
<li>一张图上过分密码的线：合成更大的元素</li>
<li>一张图上太过多的元素（方块）：合成各大的元素</li>
<li>一张图上太少的元素，比如角色特别少</li>
<li>每个图上文字表达不契合，有的太泛泛，有的太细节：通过制定主体，限制文字的抽象层次</li>
<li>无限制的画更多张图，基本上也失去了使用图形化表达的意义：只画重要的图，剩下的交流的时候再画</li>
</ol>
<h2 id="技术债治理的四条原则"><a href="#技术债治理的四条原则" class="headerlink" title="技术债治理的四条原则"></a>技术债治理的四条原则</h2><p><strong>技术债</strong> 用来描述理想中的解决方案和当前解决方案中间的差距所隐含的潜在成本。</p>
<p>这种隐喻和金融债务非常类似，这也是这个隐喻的高明之处：为了解决短期的资金压力，获得短期收益，个人或企业向银行或他人借款，从而产生债务，这种债务需要付出的额外代价是利息。</p>
<p>如果把技术债的产生也看做一种投资，那么获得的短期收益可能是快速上线带来的商业利益，比如新的功能吸引了更多的付费用户，解决了短期之内的资金缺口问题；赶在竞争对手之前上线了杀手级应用，并快速地抢占了市场。</p>
<p>不可否认，技术债的存在的确有很多积极的意义，但是我们经常会过度关注积极的因素，而忽略了技术债长期存在所导致的“利息”问题。</p>
<p><strong>技术负载全景图</strong></p>
<p><img src="https://insights.thoughtworks.cn/wp-content/uploads/2019/05/1-Tech-Debt-Landscape.png" alt="img"></p>
<p>这个全景图从两个方向来分析技术债对于软件的影响：<strong>可维护性（Maintainability）</strong>、<strong>可演进性（Evolvability）</strong>，同时结合问题的可见性（Visibility）分析技术债对于软件开发过程的影响。</p>
<p>这里的可维护性（Maintainability）主要指的是狭义上的代码问题，即代码本身可读性如何、是否容易被他人所理解、是否有明显的代码坏味道、是否容易扩展和增强。</p>
<p>其中可演进性（Evolvability）指的是系统适应变化的能力。</p>
<p><strong>技术债治理的困境</strong></p>
<ol>
<li><p>团队对于技术改进缺少战略思考</p>
<p>没有让改进方向和业务的战略方向保持一致</p>
</li>
<li><p>代码可维护性问题很难说服客户买单</p>
<p>代码级别的技术债的影响和收益难以衡量</p>
</li>
<li><p>效果不明显，客户信心不足</p>
<p>没有解决实质性问题，比如领域模型设计是否合理</p>
</li>
</ol>
<p><strong>技术债治理的四条原则</strong></p>
<ol>
<li>核心领域由于其他子域</li>
<li>可演进性优于可维护性</li>
<li>明确清晰的责任定义由于松散无序的任务分配</li>
<li>主动预防由于被动响应<ul>
<li>对于代码可维护性方面，很多比较成熟的静态代码扫描工具都可以自动识别这类问题，同时需要和团队一起自定义扫描规则，并把检查代码扫描报告作为代码审查的一部分，逐步形成一种正向的反馈机制。</li>
<li>可演进性：低耦合</li>
</ul>
</li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/DDD/" rel="tag"># DDD</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/11/06/读书笔记/实现领域驱动设计/" rel="next" title="《实现领域驱动设计》读书笔记">
                <i class="fa fa-chevron-left"></i> 《实现领域驱动设计》读书笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/12/03/读书笔记/微服务架构设计模式/" rel="prev" title="《微服务架构模式》">
                《微服务架构模式》 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8yOTUyOC82MDk2"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/uploads/me.jpeg" alt="rex">
          <p class="site-author-name" itemprop="name">rex</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">172</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">88</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/todorex" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/todorex" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/163825403" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/yun-guo-17" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#综述"><span class="nav-number">1.</span> <span class="nav-text">综述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DDD战略篇：架构设计的影响力"><span class="nav-number">1.1.</span> <span class="nav-text">DDD战略篇：架构设计的影响力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DDD战术篇：领域模型的应用"><span class="nav-number">1.2.</span> <span class="nav-text">DDD战术篇：领域模型的应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DDD实战篇：分层架构的代码结构"><span class="nav-number">1.3.</span> <span class="nav-text">DDD实战篇：分层架构的代码结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DDD的终极大招——By-Experience"><span class="nav-number">1.4.</span> <span class="nav-text">DDD的终极大招——By Experience</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#通用语言、领域、界限上下文"><span class="nav-number">2.</span> <span class="nav-text">通用语言、领域、界限上下文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何说好一门通用语言"><span class="nav-number">2.1.</span> <span class="nav-text">如何说好一门通用语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#当Subdomain遇见Bound-Context"><span class="nav-number">2.2.</span> <span class="nav-text">当Subdomain遇见Bound Context</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#架构"><span class="nav-number">3.</span> <span class="nav-text">架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#从三明治到六边形"><span class="nav-number">3.1.</span> <span class="nav-text">从三明治到六边形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#端口和适配器架构——DDD好帮手"><span class="nav-number">3.2.</span> <span class="nav-text">端口和适配器架构——DDD好帮手</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#领域事件"><span class="nav-number">4.</span> <span class="nav-text">领域事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#识别领域事件"><span class="nav-number">4.1.</span> <span class="nav-text">识别领域事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在微服务中使用领域事件"><span class="nav-number">4.2.</span> <span class="nav-text">在微服务中使用领域事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件驱动是什么？"><span class="nav-number">4.3.</span> <span class="nav-text">事件驱动是什么？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#微服务"><span class="nav-number">5.</span> <span class="nav-text">微服务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DDD-amp-MicroServices"><span class="nav-number">5.1.</span> <span class="nav-text">DDD &amp; MicroServices</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务拆分与架构演进"><span class="nav-number">5.2.</span> <span class="nav-text">服务拆分与架构演进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#微服务案例回顾"><span class="nav-number">5.3.</span> <span class="nav-text">微服务案例回顾</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#案例"><span class="nav-number">6.</span> <span class="nav-text">案例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#开发者的第0个迭代"><span class="nav-number">6.1.</span> <span class="nav-text">开发者的第0个迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#领域驱动设计（DDD）编码实践"><span class="nav-number">6.2.</span> <span class="nav-text">领域驱动设计（DDD）编码实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件驱动架构（EDA）编码实践"><span class="nav-number">6.3.</span> <span class="nav-text">事件驱动架构（EDA）编码实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#领域事件的建模"><span class="nav-number">6.3.1.</span> <span class="nav-text">领域事件的建模</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例项目"><span class="nav-number">6.3.2.</span> <span class="nav-text">实例项目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单可用的CQRS编码实践"><span class="nav-number">6.4.</span> <span class="nav-text">简单可用的CQRS编码实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用DDD实现打卡系统"><span class="nav-number">6.5.</span> <span class="nav-text">用DDD实现打卡系统</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#扩展阅读"><span class="nav-number">7.</span> <span class="nav-text">扩展阅读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DDD该如何学"><span class="nav-number">7.1.</span> <span class="nav-text">DDD该如何学</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#领域驱动设计（DDD）实现之路"><span class="nav-number">7.2.</span> <span class="nav-text">领域驱动设计（DDD）实现之路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从四色建模法到界限纸笔建模法"><span class="nav-number">7.3.</span> <span class="nav-text">从四色建模法到界限纸笔建模法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#四色建模法"><span class="nav-number">7.3.1.</span> <span class="nav-text">四色建模法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#界限纸笔建模法"><span class="nav-number">7.3.2.</span> <span class="nav-text">界限纸笔建模法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可视化架构设计——C4介绍"><span class="nav-number">7.4.</span> <span class="nav-text">可视化架构设计——C4介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#架构可视化入门到抽象坏味道"><span class="nav-number">7.5.</span> <span class="nav-text">架构可视化入门到抽象坏味道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#技术债治理的四条原则"><span class="nav-number">7.6.</span> <span class="nav-text">技术债治理的四条原则</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rex</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  

  

</body>
</html>
