<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rex note</title>
  <subtitle>雨过，云过</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bestlixiang.site/"/>
  <updated>2017-07-16T07:30:41.000Z</updated>
  <id>http://bestlixiang.site/</id>
  
  <author>
    <name>rex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Github Pages+Hexo SEO引擎优化</title>
    <link href="http://bestlixiang.site/2017/07/16/Github-Pages-Hexo-SEO%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://bestlixiang.site/2017/07/16/Github-Pages-Hexo-SEO引擎优化/</id>
    <published>2017-07-16T07:28:51.000Z</published>
    <updated>2017-07-16T07:30:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：写的博客自然想让人看到，<strong>但是但是</strong>自己为了想独立管理（冠冕堂皇）选择了GIthub Pages+Hexo来搭建自己的博客，结果发现自己的博客在百度，谷歌都无法搜到，那时候我才知道自己缺少了SEO。<a id="more"></a></p>
<h2 id="百度优化"><a href="#百度优化" class="headerlink" title="百度优化"></a>百度优化</h2><p><a href="http://zhanzhang.baidu.com/" target="_blank" rel="external">登录百度站长</a></p>
<p>在里面我们可以发现各种向百度提交的方法，这一切都是为了让百度的爬虫更好的爬取我们的网页。</p>
<ul>
<li><p>通过baidumapsite.xml自动提交</p>
<p>这里推荐一个博文：<a href="http://www.jianshu.com/p/0d54a590b81a" target="_blank" rel="external">Hexo NexT 主题SEO优化指南</a></p>
</li>
<li><p>通过主动提交</p>
<p>这里推荐一个自动化工具：<a href="http://hui-wang.info/2016/10/23/Hexo%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%99%BE%E5%BA%A6%E4%B8%BB%E5%8A%A8%E6%8F%90%E4%BA%A4%E9%93%BE%E6%8E%A5/" target="_blank" rel="external">exo插件之百度主动提交链接</a></p>
</li>
</ul>
<h2 id="谷歌优化"><a href="#谷歌优化" class="headerlink" title="谷歌优化"></a>谷歌优化</h2><p><a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="external">登录谷歌站长</a></p>
<ul>
<li><p>通过map.site自动提交</p>
<p>  这里面推荐一个博文：<a href="http://www.jianshu.com/p/9c2d6db2f855" target="_blank" rel="external">生成sitemap站点地图</a></p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自己在谷歌配置是成功的，但是在百度并没有成功，可能是因为<strong>gihub真的把百度给干了</strong>。自己还是等开学转到自己的服务器上吧。慢慢<strong>SEO</strong>！！！！</p>
<p>PS:Hexo博客的搭建的可以参考这一篇</p>
<p><a href="http://www.jianshu.com/p/a2fe56d11c4f" target="_blank" rel="external">搭建Hexo博客中碰到的坑</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：写的博客自然想让人看到，&lt;strong&gt;但是但是&lt;/strong&gt;自己为了想独立管理（冠冕堂皇）选择了GIthub Pages+Hexo来搭建自己的博客，结果发现自己的博客在百度，谷歌都无法搜到，那时候我才知道自己缺少了SEO。
    
    </summary>
    
      <category term="工具" scheme="http://bestlixiang.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hexo" scheme="http://bestlixiang.site/tags/hexo/"/>
    
      <category term="seo" scheme="http://bestlixiang.site/tags/seo/"/>
    
  </entry>
  
  <entry>
    <title>新系统开发环境的一系列配置</title>
    <link href="http://bestlixiang.site/2017/07/15/%E6%96%B0%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%85%8D%E7%BD%AE/"/>
    <id>http://bestlixiang.site/2017/07/15/新系统开发环境的一系列配置/</id>
    <published>2017-07-15T13:35:54.000Z</published>
    <updated>2017-07-15T13:37:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：总是不可避免的重装系统，人的脑子不可能那么好记住所有的操作，既然不想自己自己用博客记下所有操作，那么就把别人的博客（自己踩过）记录下来，以后备用。<a id="more"></a></p>
<h2 id="window篇"><a href="#window篇" class="headerlink" title="window篇"></a>window篇</h2><ol>
<li>JDK——java开发者起步</li>
</ol>
<p><a href="http://www.jianshu.com/p/ac13e424e950" target="_blank" rel="external">JDK的安装与环境变量的配置</a></p>
<ol>
<li>Node——前端好基友</li>
</ol>
<p><a href="http://www.jianshu.com/p/03a76b2e7e00" target="_blank" rel="external">Node.js安装及环境配置之Windows篇</a></p>
<ol>
<li>Sublime3——轻量级编辑器</li>
</ol>
<p><a href="http://www.jianshu.com/p/0e12a06c4578" target="_blank" rel="external">Sublime Text3安装与插件配置</a></p>
<ol>
<li>git——分布式版本控制工具</li>
</ol>
<p><a href="http://www.jianshu.com/p/dc90b9aac18c" target="_blank" rel="external">Git安装教程</a></p>
<ol>
<li>Idea——java开发利器</li>
</ol>
<p><a href="http://idea.lanyus.com/" target="_blank" rel="external">IntelliJ IDEA注册码</a></p>
<ol>
<li>Maven——项目依赖管理利器</li>
</ol>
<p><a href="http://www.jianshu.com/p/26fa41427a55" target="_blank" rel="external">Maven Windows10安装</a></p>
<h2 id="Mac篇"><a href="#Mac篇" class="headerlink" title="Mac篇"></a>Mac篇</h2><p>待写</p>
<h2 id="Ubuntu篇"><a href="#Ubuntu篇" class="headerlink" title="Ubuntu篇"></a>Ubuntu篇</h2><p>待写</p>
<h2 id="双系统"><a href="#双系统" class="headerlink" title="双系统"></a>双系统</h2><p><a href="http://www.jianshu.com/p/16b36b912b02" target="_blank" rel="external">Win10和Ubuntu16.04双系统安装详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：总是不可避免的重装系统，人的脑子不可能那么好记住所有的操作，既然不想自己自己用博客记下所有操作，那么就把别人的博客（自己踩过）记录下来，以后备用。
    
    </summary>
    
      <category term="生活" scheme="http://bestlixiang.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="系统" scheme="http://bestlixiang.site/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>浅尝Apache Camel</title>
    <link href="http://bestlixiang.site/2017/07/15/%E6%B5%85%E5%B0%9DApache-Camel/"/>
    <id>http://bestlixiang.site/2017/07/15/浅尝Apache-Camel/</id>
    <published>2017-07-15T01:38:42.000Z</published>
    <updated>2017-07-15T01:40:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：最近项目有一个需求就是定时将一台服务器的文件传到另一个服务器，一开始想的竟然想的是用http去下载，后来在万老师的指点下，采取用ftp服务器（源文件所在地）与ftp客户端（源文件去向）的形式来处理，自己小试了一下，还不错！<a id="more"></a></p>
<h2 id="Apache-Camel简介"><a href="#Apache-Camel简介" class="headerlink" title="Apache Camel简介"></a>Apache Camel简介</h2><p>Apache Camel是Apache基金会下的一个开源项目,它是一个基于规则路由和处理的引擎，提供企业集成模式的Java对象的实现，通过应用程序接口 或称为陈述式的Java领域特定语言(DSL)来配置路由和处理的规则。其核心的思想就是从一个from源头得到数据,通过processor处理,再发到一个to目的的。</p>
<p>这个from和to可以是我们在项目集成中经常碰到的类型:一个FTP文件夹中的文件,一个MQ的queue（jms）,一个HTTP request/response,一个webservice等等.</p>
<h2 id="Apache-Camel架构"><a href="#Apache-Camel架构" class="headerlink" title="Apache Camel架构"></a>Apache Camel架构</h2><p><img src="http://o6plzvjf2.bkt.clouddn.com/camel.png" alt="架构图"></p>
<p>其实理解起来很简单：始端》（过滤器+路由处理器）》终端</p>
<h2 id="Apache-Camel核心概念"><a href="#Apache-Camel核心概念" class="headerlink" title="Apache Camel核心概念"></a>Apache Camel核心概念</h2><ol>
<li><p>endpoint,所谓的endpoint,就是一种可以接收或发送数据的组件。可以支持多种协议，如jms,http,file等。</p>
</li>
<li><p>processor,它是用来处理具体业务逻辑的组件。</p>
</li>
<li><p>route,用来路由，指示数据从哪里来到哪里去，中间用哪个processor处理。</p>
</li>
<li><p>exchange,processor之间用exchange对象来传送数据，有点像jms,通俗一点就像上学时传的小纸条,所以：exchange对象就是processor，endpoint所有camel组件之间传送数据的小纸条:)。</p>
</li>
<li><p>filter，用来确定哪些东西可以传递，哪些东西不可以传递。 </p>
</li>
</ol>
<h2 id="Apache-Camel例子（以ftp为例）"><a href="#Apache-Camel例子（以ftp为例）" class="headerlink" title="Apache Camel例子（以ftp为例）"></a>Apache Camel例子（以ftp为例）</h2><p>老师指导的例子，是结合Springboot的，放在github上了。<br><a href="https://github.com/todorex/ApacheCamel" target="_blank" rel="external">ApacheCamleDemo</a></p>
<p>里面包括了动态路由和单路由的例子，稍微结合Springboot就可以理解并改成自己的代码。</p>
<h2 id="什么时候用Apache-Camel"><a href="#什么时候用Apache-Camel" class="headerlink" title="什么时候用Apache Camel"></a>什么时候用Apache Camel</h2><p>参考网上的说法：camel就是企业信息集成框架，它提供了很多简单好用而又强大的组件，用户可以根据场景来选择不同的EIP（企业集成模式）来实现自己的需求，以响应快速变化的业务。可以把它当成企业信息总线（ESB）的轻量级实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：最近项目有一个需求就是定时将一台服务器的文件传到另一个服务器，一开始想的竟然想的是用http去下载，后来在万老师的指点下，采取用ftp服务器（源文件所在地）与ftp客户端（源文件去向）的形式来处理，自己小试了一下，还不错！
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Springboot" scheme="http://bestlixiang.site/tags/Springboot/"/>
    
      <category term="ApacheCamel" scheme="http://bestlixiang.site/tags/ApacheCamel/"/>
    
  </entry>
  
  <entry>
    <title>java ftp 上传下载的坑 </title>
    <link href="http://bestlixiang.site/2017/07/15/java-ftp-%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%9D%91/"/>
    <id>http://bestlixiang.site/2017/07/15/java-ftp-上传下载的坑/</id>
    <published>2017-07-15T01:04:43.000Z</published>
    <updated>2017-07-15T04:41:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：还是项目需要，要定时执行一个文件下载业务，一开始方向有点错，但是还好纠正过来了，采用ftp下载，但是ftp下载也有各种坑！<a id="more"></a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>jar包：commons-net</p>
<h2 id="ftp上传"><a href="#ftp上传" class="headerlink" title="ftp上传"></a>ftp上传</h2><p>程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">uploadFile</span><span class="params">(</span></span></div><div class="line">	String url,//服务器主机号</div><div class="line">	<span class="keyword">int</span> port,//服务器端口</div><div class="line">	String username,//用户名</div><div class="line">	String password,//密码</div><div class="line">	String path, //上传路径Mar</div><div class="line">	String filename,//上传为服务器上的文件名</div><div class="line">	InputStream //input本地上传的文件流</div><div class="line">) &#123;</div><div class="line">	<span class="keyword">boolean</span> success = <span class="keyword">false</span>;</div><div class="line">	FTPClient ftp = <span class="keyword">new</span> FTPClient();</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">int</span> reply;MarkDown</div><div class="line">		ftp.connect(url, port);<span class="comment">//连接FTP服务器</span></div><div class="line">		<span class="comment">//如果采用默认端口，可以使用ftp.connect(url)的方式直接连接FTP服务器</span></div><div class="line">		ftp.login(username, password);<span class="comment">//登录</span></div><div class="line">		reply = ftp.getReplyCode();</div><div class="line">		<span class="keyword">if</span> (!FTPReply.isPositiveCompletion(reply)) &#123;</div><div class="line">			ftp.disconnect();</div><div class="line">			<span class="keyword">return</span> success;</div><div class="line">		&#125;</div><div class="line">		ftp.changeWorkingDirectory(path);</div><div class="line">		ftp.storeFile(filename, input);</div><div class="line">		input.close();</div><div class="line">		ftp.logout();</div><div class="line">		success = <span class="keyword">true</span>;</div><div class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		<span class="keyword">if</span> (ftp.isConnected()) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				ftp.disconnect();</div><div class="line">			&#125; <span class="keyword">catch</span> (IOException ioe) &#123;</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> success;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">File file = new File(&quot;/var/test.txt&quot;);</div><div class="line">InputStream is = new FileInputStream(file);</div><div class="line">uploadFile(&quot;127.0.0.1&quot;,21,&quot;test&quot;,&quot;123456&quot;,&quot;/var/data/test&quot;,&quot;testdemo.txt&quot;,is);</div></pre></td></tr></table></figure></p>
<h2 id="ftp下载"><a href="#ftp下载" class="headerlink" title="ftp下载"></a>ftp下载</h2><p>程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">downFile</span><span class="params">(</span></span></div><div class="line">String url, //FTP服务器hostname</div><div class="line"><span class="keyword">int</span> port,//FTP服务器端口</div><div class="line">String username, //FTP登录账号</div><div class="line">String password, //FTP登录密码</div><div class="line">String remotePath,//FTP服务器上的相对路径</div><div class="line">String fileName,//要下载文件关键字</div><div class="line">String localPath//下载后保存到本地的路径</div><div class="line"></div><div class="line">)  &#123;</div><div class="line">	FTPClient ftpClient = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">boolean</span> success = <span class="keyword">false</span>;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		ftpClient = <span class="keyword">new</span> FTPClient();</div><div class="line">		ftpClient.connect(url, port);<span class="comment">// 连接FTP服务器</span></div><div class="line">		ftpClient.login(username, password);<span class="comment">// 登陆FTP服务器</span></div><div class="line">		ftpClient.setControlEncoding(<span class="string">"gb2312"</span>); <span class="comment">// 中文支持</span></div><div class="line">		ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);<span class="comment">//设置文件格式</span></div><div class="line">		ftpClient.enterLocalPassiveMode();</div><div class="line">		logger.info(ftpClient.getReplyCode());</div><div class="line">		<span class="keyword">if</span> (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) &#123;</div><div class="line">			logger.warn(<span class="string">"未连接到FTP，用户名或密码错误。"</span>);</div><div class="line">			ftpClient.disconnect();</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			logger.info(<span class="string">"FTP连接成功。"</span>);</div><div class="line">		&#125;</div><div class="line">		ftpClient.changeWorkingDirectory(remotePath);</div><div class="line">		FTPFile[] fs = ftpClient.listFiles();</div><div class="line">		File file = <span class="keyword">new</span> File(localPath);</div><div class="line">		<span class="keyword">if</span>(!file.exists())&#123;</div><div class="line">			file.mkdirs();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(FTPFile ff:fs)&#123;</div><div class="line">		<span class="keyword">if</span>(ff.getName().contains(fileName))&#123;</div><div class="line">			File localFile = <span class="keyword">new</span> File(localPath+<span class="string">"/"</span>+ff.getName());</div><div class="line">			<span class="keyword">if</span> (localFile.exists())&#123;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">		OutputStream os = <span class="keyword">new</span> FileOutputStream(localFile);</div><div class="line">		<span class="keyword">long</span> time1 = System.currentTimeMillis();</div><div class="line">		<span class="keyword">boolean</span> b = ftpClient.retrieveFile(<span class="keyword">new</span> String(ff.getName().getBytes(<span class="string">"gb2312"</span>),<span class="string">"ISO8859-1"</span>), os);      </div><div class="line">		os.flush();</div><div class="line">		os.close();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		ftpClient.logout();</div><div class="line">		success = <span class="keyword">true</span>;</div><div class="line">	&#125; <span class="keyword">catch</span> (SocketException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">		logger.warn(<span class="string">"FTP的IP地址可能错误，请正确配置。"</span>);</div><div class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">		logger.warn(<span class="string">"FTP的端口错误,请正确配置。"</span>);</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		<span class="keyword">if</span> (ftpClient.isConnected()) &#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			ftpClient.disconnect();</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException ioe) &#123;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> success;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">downFile(&quot;127.0.0.1&quot;,21,&quot;test&quot;,&quot;123456&quot;,&quot;、var/data/test&quot;,&quot;demo&quot;,&quot;/var/alldata&quot;);</div></pre></td></tr></table></figure></p>
<h2 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h2><ol>
<li><p>客户端接受的编码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ftpClient.setControlEncoding(&quot;gb2312&quot;); // 中文支持</div></pre></td></tr></table></figure>
<p> 如果服务器上的文件名有中文，一定要加上这一句，具体编码要根据服务器的编码。</p>
</li>
<li><p>客户端接受的文件类型</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);//设置文件格式</div></pre></td></tr></table></figure>
<p> 文件类型要根据下载的文件格式来定</p>
</li>
<li><p>服务器端口设置</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ftpClient.enterLocalPassiveMode();</div></pre></td></tr></table></figure>
<p> 调用FTPClient.enterLocalPassiveMode();这个方法的意思就是每次数据连接之前，ftp client告诉ftp server开通一个端口来传输数据，防止在新端口对外部不通，因为ftp server可能每次开启不同的端口来传输数据，但是在linux上，由于安全限制，可能某些端口没有开启，所以就出现阻塞。</p>
</li>
<li><p>最大的坑（下载出0kb的文件：实质就是retrieveFile方法执行失败）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ftpClient.retrieveFile(new String(ff.getName().getBytes(&quot;gb2312&quot;),&quot;ISO8859-1&quot;), os)</div></pre></td></tr></table></figure>
<p> 一定要给文件名换编码，让它识别中文，具体编码也是根据实际情况而定。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ftp客户端的速度也是要根据网速来的，可能比一般http快，但是面对网速慢的情况也是无可奈何！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：还是项目需要，要定时执行一个文件下载业务，一开始方向有点错，但是还好纠正过来了，采用ftp下载，但是ftp下载也有各种坑！
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="ftp" scheme="http://bestlixiang.site/tags/ftp/"/>
    
  </entry>
  
  <entry>
    <title>js原型和原型链</title>
    <link href="http://bestlixiang.site/2017/07/13/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://bestlixiang.site/2017/07/13/js原型和原型链/</id>
    <published>2017-07-13T00:26:14.000Z</published>
    <updated>2017-07-13T00:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：刚刚说了闭包，那就不放过js的另一大难点了——js原型以及原型链。<a id="more"></a></p>
<h2 id="谈谈"><a href="#谈谈" class="headerlink" title="谈谈"></a>谈谈</h2><p>神图镇楼：<br><img src="http://o6plzvjf2.bkt.clouddn.com/prototype.jpg" alt="原型链图"><br>自己写了好几遍内容，但是自己发现还是不能系统的理解，自己也写不了多好，看来要到自己安心写前端的时候，再来补上了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.jianshu.com/p/dee9f8b14771" target="_blank" rel="external">最详尽的 JS 原型与原型链终极详解（一）</a></li>
<li><a href="http://www.jianshu.com/p/652991a67186" target="_blank" rel="external">最详尽的 JS 原型与原型链终极详解（二）</a></li>
<li><a href="http://www.jianshu.com/p/a4e1e7b6f4f8" target="_blank" rel="external">最详尽的 JS 原型与原型链终极详解（三）</a></li>
</ol>
<p>个人感觉上面的文章还不错，可能还缺了继承那块的讲解，等自己再来的时候一起补上吧！！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：刚刚说了闭包，那就不放过js的另一大难点了——js原型以及原型链。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="javascript" scheme="http://bestlixiang.site/tags/javascript/"/>
    
      <category term="原型" scheme="http://bestlixiang.site/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>浅谈js闭包</title>
    <link href="http://bestlixiang.site/2017/07/12/%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85/"/>
    <id>http://bestlixiang.site/2017/07/12/浅谈js闭包/</id>
    <published>2017-07-12T01:21:01.000Z</published>
    <updated>2017-07-15T01:08:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：最近项目前端用了angular2，里面使用的TypeScript,其实很多和Java挺像的，学起来还是挺快的。但是里面的很多变量的原理都是根据闭包来实现的，那就好好了解一下闭包。<a id="more"></a></p>
<h2 id="闭包定义"><a href="#闭包定义" class="headerlink" title="闭包定义"></a>闭包定义</h2><p>根据Mozilla开发者文档定义：</p>
<p>闭包是指向独立变量的“函数”,用通俗的话说就是会“记住”它创建时的环境。</p>
<h2 id="闭包涉及的主要概念"><a href="#闭包涉及的主要概念" class="headerlink" title="闭包涉及的主要概念"></a>闭包涉及的主要概念</h2><ol>
<li>作用域链</li>
</ol>
<p>作用域链是函数在定义的时候创建的,用于寻找使用到的变量的值的一个索引。它内部的规则是,把函数自身的本地变量放在最前面,把自身的父级函数中的变量放在其次,把再高一级函数中的变量放在更后面,以此类推直至全局对象为止.当函数中需要查询一个变量的值的时候,js解释器会去作用域链去查找,从最前面的本地变量中先找,如果没有找到对应的变量,则到下一级的链上找,一旦找到了变量,则不再继续.如果找到最后也没找到需要的变量,则解释器返回undefined.</p>
<ol>
<li>内存回收机制</li>
</ol>
<p>一个函数在执行开始的时候,会给其中定义的变量划分内存空间保存,以备后面的语句所用,等到函数执行完毕返回了,这些变量就被认为是无用的了.对应的内存空间也就被回收了.下次再执行此函数的时候,所有的变量又回到最初的状态,重新赋值使用.但是如果这个函数内部又嵌套了另一个函数,而这个函数是有可能在外部被调用到的.并且这个内部函数又使用了外部函数的某些变量的话.这种内存回收机制就会出现问题.如果在外部函数返回后,又直接调用了内部函数,那么内部函数就无法读取到他所需要的外部函数中变量的值了.所以js解释器在遇到函数定义的时候,会自动把函数和他可能使用的变量(包括本地变量和父级和祖先级函数的变量(自由变量))一起保存起来.也就是构建一个闭包,这些变量将不会被内存回收器所回收,只有当内部的函数不可能被调用以后(例如被删除了,或者没有了指针),才会销毁这个闭包,而没有任何一个闭包引用的变量才会被下一次内存回收启动时所回收.</p>
<h2 id="闭包现象"><a href="#闭包现象" class="headerlink" title="闭包现象"></a>闭包现象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var results = [];</div><div class="line">for (var i = 0; i &lt;3; i++) &#123;</div><div class="line">results[i] = function() &#123;</div><div class="line">console.log(i);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">results[0](); //3</div><div class="line">results[1](); //3</div><div class="line">results[2](); //3</div></pre></td></tr></table></figure>
<p>解析：其实这里return出来的是一个function（我们可以理解为他是一个字符串，还没有执行），等到我们去执行他的时候，只保存了他上一级的作用域链里面的i的索引,那个时候i已经是3了。</p>
<h2 id="闭包解决"><a href="#闭包解决" class="headerlink" title="闭包解决"></a>闭包解决</h2><p>让内部函数在循环创建的时候立即执行,并且捕捉当前的索引值,然后记录在自己的一个本地变量里.然后利用返回函数的方法,重写内部函数,让下一次调用的时候,返回本地变量的值,改进后的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var results = [];</div><div class="line">for (var i = 0; i &lt;3; i++) &#123;</div><div class="line">results[i] = (function(j) &#123;</div><div class="line">return function()&#123;</div><div class="line">console.log(j);</div><div class="line">&#125;</div><div class="line">&#125;)(i);</div><div class="line">&#125;</div><div class="line">results[0](); //0</div><div class="line">results[1](); //1</div><div class="line">results[2](); //2</div></pre></td></tr></table></figure></p>
<p>我们发现通过立即执行表达式就可以解决闭包的现象得到我们想要得到的现象。</p>
<h2 id="闭包应用"><a href="#闭包应用" class="headerlink" title="闭包应用"></a>闭包应用</h2><h3 id="闭包与静态变量"><a href="#闭包与静态变量" class="headerlink" title="闭包与静态变量"></a>闭包与静态变量</h3><p>前面就说TypeScript与Java很像，所以类中的静态变量也是有的。</p>
<p>TypeScript代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Counter &#123;</div><div class="line">private static COUNTER = 0;</div><div class="line">constructor() &#123;&#125;</div><div class="line">private changeBy(val) &#123;</div><div class="line">Counter.COUNTER +=val;</div><div class="line">&#125;</div><div class="line">public increment() &#123;</div><div class="line">this.changeBy(1);</div><div class="line">&#125;</div><div class="line">public decrement() &#123;</div><div class="line">this.changeBy(-1);</div><div class="line">&#125;</div><div class="line">public value() &#123;</div><div class="line">return Counter.COUNTER;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译之后的js代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var Counter = (function () &#123;</div><div class="line">function Counter() &#123;</div><div class="line">&#125;</div><div class="line">Counter.prototype.changeBy = function (val) &#123;</div><div class="line">Counter.COUNTER += val;</div><div class="line">&#125;;</div><div class="line">Counter.prototype.increment = function () &#123;</div><div class="line">this.changeBy(1);</div><div class="line">&#125;;</div><div class="line">Counter.prototype.decrement = function () &#123;</div><div class="line">this.changeBy(-1);</div><div class="line">&#125;;</div><div class="line">Counter.prototype.value = function () &#123;</div><div class="line">return Counter.COUNTER;</div><div class="line">&#125;;</div><div class="line">Counter.COUNTER = 0;</div><div class="line">return Counter;</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<p>从js代码可以看书静态变量COUNTER是属于Counter类的，并不属于对象原型。所有Counter实例都共享Counter的同一个闭包上下文环境（COUNTER）。所以COUNTER会表现像单例一样。</p>
<h3 id="闭包和私有成员"><a href="#闭包和私有成员" class="headerlink" title="闭包和私有成员"></a>闭包和私有成员</h3><p>TypeScript由于性能原因并没有使用闭包来模拟私有变量，他使用过编译检查机制来形成私有变量的特性。但是我们可以使用闭包来实现私有变量。</p>
<p>js代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function makeCounter() &#123;</div><div class="line">var COUNTERR = 0;</div><div class="line">function Counter() &#123;</div><div class="line">&#125;</div><div class="line">function changeBy(val) &#123;</div><div class="line">COUNTER += val;</div><div class="line">&#125;;</div><div class="line">Counter.prototype.increment = function () &#123;</div><div class="line">this.changeBy(1);</div><div class="line">&#125;;</div><div class="line">Counter.prototype.decrement = function () &#123;</div><div class="line">this.changeBy(-1);</div><div class="line">&#125;;</div><div class="line">Counter.prototype.value = function () &#123;</div><div class="line">return COUNTER;</div><div class="line">&#125;;</div><div class="line">return new Counter();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出，每一个新的makeCounter实例都拥有自己的上下文环境，其他实例访问不了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习这么久的js发现，其实闭包真的无处不在，需要好好学习，好好总结，如有不对，也希望大家能够指出。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>链接：<a href="http://blog.csdn.net/u011411356/article/details/50208433" target="_blank" rel="external">js中闭包原理谈和原型及例子</a></p>
<p>书籍：Learning TypeScript中文版</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：最近项目前端用了angular2，里面使用的TypeScript,其实很多和Java挺像的，学起来还是挺快的。但是里面的很多变量的原理都是根据闭包来实现的，那就好好了解一下闭包。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="javascript" scheme="http://bestlixiang.site/tags/javascript/"/>
    
      <category term="闭包" scheme="http://bestlixiang.site/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Java日志那些事</title>
    <link href="http://bestlixiang.site/2017/07/12/Java%E6%97%A5%E5%BF%97%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://bestlixiang.site/2017/07/12/Java日志那些事/</id>
    <published>2017-07-12T01:14:19.000Z</published>
    <updated>2017-07-12T01:16:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：一直都知道日志文件很重要，可以记录一些相关信息，但是可能是程序需要调试的内容太少，也或者是项目太小，所以看看控制台的信息就够了，但是这次接触的项目越来越大，控制台额信息越来越多，经常会看不到自己想要看到的信息时，这个时候使用日志就发现十分得有必要了！<a id="more"></a></p>
<h2 id="日志的好处"><a href="#日志的好处" class="headerlink" title="日志的好处"></a>日志的好处</h2><ol>
<li>方便调试(如上)</li>
<li>方便发现系统运行中的错误</li>
<li>存储业务数据，便于日后分析</li>
</ol>
<h2 id="日志实现方式"><a href="#日志实现方式" class="headerlink" title="日志实现方式"></a>日志实现方式</h2><ol>
<li>自己实现类通过io存储到文件中</li>
<li>使用log4j将日志输入到控制台，文本文件，一集数据库中。</li>
<li>使用jdk自带的logging.jar包中方法（同一作者还有lognback）</li>
<li>使用slfj，它提供了上述两种方法的接口。</li>
</ol>
<h2 id="日志的输出-以log4j为例"><a href="#日志的输出-以log4j为例" class="headerlink" title="日志的输出(以log4j为例)"></a>日志的输出(以log4j为例)</h2><ol>
<li>输入到控制台</li>
</ol>
<p>运行程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class LoggerTest &#123;</div><div class="line">public static Logger logger1 = Logger.getLogger(LoggerTest.class);</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">logger1.trace(&quot;我是logger1，trace&quot;);</div><div class="line">logger1.debug(&quot;我是logger1，debug&quot;);</div><div class="line">logger1.info(&quot;我是logger1，info&quot;);</div><div class="line">logger1.warn(&quot;我是logger1，warn&quot;);</div><div class="line">logger1.error(&quot;我是logger1，error&quot;);</div><div class="line">logger1.fatal(&quot;我是logger1，fatal&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">### 设置级别和目的地(这里多个目的地) ###</div><div class="line">log4j.rootLogger = DEBUG,CONSOLE</div><div class="line">### 这里的com.todorex是包，也就是在这个包记录日志时，是只记录debug及以上级别的日志</div><div class="line">log4j.logger.com.todorex=DEBUG</div><div class="line">### 输出到控制台 ###</div><div class="line">log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppender</div><div class="line">log4j.appender.CONSOLE.Target = System.out</div><div class="line">log4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.CONSOLE.layout.ConversionPattern =  %d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</div></pre></td></tr></table></figure></p>
<p>控制台输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">11:35:09,969 DEBUG LoggerTest:12 [main:0]- 我是logger1，debug</div><div class="line">11:35:09,972  INFO LoggerTest:13 [main:3]- 我是logger1，info</div><div class="line">11:35:09,972  WARN LoggerTest:14 [main:3]- 我是logger1，warn</div><div class="line">11:35:09,972 ERROR LoggerTest:15 [main:3]- 我是logger1，error</div><div class="line">11:35:09,972 FATAL LoggerTest:16 [main:3]- 我是logger1，fatal</div></pre></td></tr></table></figure></p>
<ol>
<li>输入到日志文件<br>运行程序同上；<br>配置文件如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">### 设置级别和目的地(这里可以多个目的地) ###</div><div class="line">log4j.rootLogger = trace,demoLog</div><div class="line">log4j.logger.com.todorex=DEBUG</div><div class="line"></div><div class="line">### 输出到控制台 ###</div><div class="line">log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppender</div><div class="line">log4j.appender.CONSOLE.Target = System.out</div><div class="line">log4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.CONSOLE.layout.ConversionPattern =  %d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L [%t:%r]- %m%n</div><div class="line"></div><div class="line">### 输出到日志文件（文件目录一定要是绝对路径且存在） ###</div><div class="line">log4j.appender.demoLog = org.apache.log4j.DailyRollingFileAppender</div><div class="line">log4j.appender.demoLog.File =/var/alldata/mylog.log</div><div class="line">log4j.appender.demoLog.Append = true</div><div class="line">## 只输出DEBUG级别以上的日志</div><div class="line">log4j.appender.demoLog.Threshold = DEBUG</div><div class="line">#&apos;.&apos;yyyy-MM-dd: 每天产生一个新的文件</div><div class="line">log4j.appender.demoLog.DatePattern = &apos;.&apos;yyyy-MM-dd</div><div class="line">log4j.appender.demoLog.layout = org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.demoLog.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%t:%r] - [%p] [%c&#123;1&#125;:%L] [%M] %m%n</div></pre></td></tr></table></figure>
</li>
</ol>
<p>文件内容同控制台输出，但是却比控制台清楚得多，不会被乱七八糟的信息给遮盖。</p>
<ol>
<li>输入到数据库</li>
</ol>
<p>运行程序:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class LoggerTest &#123;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">Logger logger = Logger.getLogger(LoggerTest.class);</div><div class="line">logger.info(&quot;good&quot;);</div><div class="line">logger.debug(&quot;success&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">log4j.rootLogger=trace,CONSOLE,demoLog</div><div class="line"># com.todorex包下面所有的日志输出的级别设为DEBUG</div><div class="line">log4j.logger.com.todorex=DEBUG</div><div class="line"># 数据库输出</div><div class="line">log4j.appender.demoLog=org.apache.log4j.jdbc.JDBCAppender</div><div class="line">log4j.appender.demoLog.driver=com.mysql.jdbc.Driver</div><div class="line">log4j.appender.demoLog.URL=jdbc:mysql://127.0.0.1:3306/test</div><div class="line">log4j.appender.demoLog.user=root</div><div class="line">log4j.appender.demoLog.password=root</div><div class="line"># 在数据库对应的位置建一个对应的log表</div><div class="line">log4j.appender.demoLog.sql=insert into log(level,category,thread,time,location,note) values(&apos;%p&apos;,&apos;%c&apos;,&apos;%t&apos;,&apos;%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;&apos;,&apos;%l&apos;,&apos;%m&apos;)</div></pre></td></tr></table></figure></p>
<p>数据库的具体内容就不贴出来了，和普通看到的一样。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实日志用几次就知道它的好了，自己也是在慢慢学习！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：一直都知道日志文件很重要，可以记录一些相关信息，但是可能是程序需要调试的内容太少，也或者是项目太小，所以看看控制台的信息就够了，但是这次接触的项目越来越大，控制台额信息越来越多，经常会看不到自己想要看到的信息时，这个时候使用日志就发现十分得有必要了！
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="日志" scheme="http://bestlixiang.site/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>jpa实体映射关系</title>
    <link href="http://bestlixiang.site/2017/06/15/jpa%E5%AE%9E%E4%BD%93%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://bestlixiang.site/2017/06/15/jpa实体映射关系/</id>
    <published>2017-06-15T00:47:03.000Z</published>
    <updated>2017-06-15T00:51:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：其实距离自己上次写数据库操作已经1个多月了，之前接触的就是Hibernate，这次接触jpa，就把几种对应关系理清。<a id="more"></a></p>
<h1 id="映射策略"><a href="#映射策略" class="headerlink" title="映射策略"></a>映射策略</h1><p>注：这次举的例子都是User和Car的</p>
<h2 id="外键关联"><a href="#外键关联" class="headerlink" title="外键关联"></a>外键关联</h2><p>简介：两个表的关系定义在其中一个表中</p>
<h3 id="OneToOne"><a href="#OneToOne" class="headerlink" title="@OneToOne"></a>@OneToOne</h3><p>方法一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@OneToOne(cascade=CascadeType.ALL, fetch=FetchType.EAGER)</div><div class="line">@JoinColumn(name = &quot;user_id&quot;)</div><div class="line">private Car car;</div></pre></td></tr></table></figure></p>
<p>通过在Car表中加入一个外键，实现两者关系。<br>方法二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@OneToOne(cascade = CascadeType.ALL,fetch = FetchType.EAGER,mappedBy = &quot;Car&quot;)</div><div class="line">private User user;</div></pre></td></tr></table></figure></p>
<p>通过在Car类中用MappedBy声明让User进行维护。</p>
<h3 id="OneToMany"><a href="#OneToMany" class="headerlink" title="@OneToMany"></a>@OneToMany</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)</div><div class="line">@JoinColumn(name = &quot;user_id&quot;)</div><div class="line">private Set&lt;Car&gt; cars;</div></pre></td></tr></table></figure>
<p>通过在Car表中加入一个外键，实现一对多关系。</p>
<h3 id="ManyToMany"><a href="#ManyToMany" class="headerlink" title="@ManyToMany"></a>@ManyToMany</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)</div><div class="line">private Set&lt;Car&gt; cars;</div></pre></td></tr></table></figure>
<p>这个是采用默认的表关联</p>
<h2 id="表关联"><a href="#表关联" class="headerlink" title="表关联"></a>表关联</h2><p>简介：两个表的关系通过一张中间表来来关联</p>
<h3 id="OneToMany-1"><a href="#OneToMany-1" class="headerlink" title="@OneToMany"></a>@OneToMany</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)</div><div class="line">@JoinTable(name = &quot;user_car&quot;,</div><div class="line">joinColumns=&#123;@JoinColumn(name = &quot;user_id&quot;)&#125;,</div><div class="line">inverseJoinColumns = &#123;@JoinColumn(name = &quot;car_id&quot;)&#125;)</div><div class="line">private Set&lt;Car&gt; cars;</div></pre></td></tr></table></figure>
<p>通过JoinTable来确定一张中间表，joinColumns里面放父表的属性，inverseJoinColumns放子表的属性</p>
<h3 id="ManyToMany-1"><a href="#ManyToMany-1" class="headerlink" title="@ManyToMany"></a>@ManyToMany</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@ManyToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)</div><div class="line">@JoinTable(name = &quot;user_car&quot;,</div><div class="line">joinColumns=&#123;@JoinColumn(name = &quot;user_id&quot;)&#125;,</div><div class="line">inverseJoinColumns = &#123;@JoinColumn(name = &quot;car_id&quot;)&#125;)</div><div class="line">private Set&lt;Car&gt; cars;</div></pre></td></tr></table></figure>
<p>解释如@OneToMany</p>
<h2 id="一些属性"><a href="#一些属性" class="headerlink" title="一些属性"></a>一些属性</h2><h3 id="cascade属性"><a href="#cascade属性" class="headerlink" title="cascade属性"></a>cascade属性</h3><ol>
<li>CascadeType.PERSIST：级联新建</li>
<li>CascadeType.REMOVE：级联删除</li>
<li>CascadeType.REFRESH：级联刷新</li>
<li>CascadeType.MERGE：级联更新</li>
<li>CascadeType.ALL：包括上面四项</li>
</ol>
<h3 id="fetch属性"><a href="#fetch属性" class="headerlink" title="fetch属性"></a>fetch属性</h3><ol>
<li>FetchType.EAGER：相当于禁用懒加载，推荐开发使用</li>
<li>FetchType.LAZY：懒加载，默认值，推荐部署使用</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>父表是提供主键的，子表是利用父表的主键来设置外键的，维护方是Owner，被维护方是Owned。提示自己一个傻逼的问题，插入数据要先往两张表中插入数据，在往中间表插入数据，不然会报错~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：其实距离自己上次写数据库操作已经1个多月了，之前接触的就是Hibernate，这次接触jpa，就把几种对应关系理清。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="sping" scheme="http://bestlixiang.site/tags/sping/"/>
    
      <category term="jpa" scheme="http://bestlixiang.site/tags/jpa/"/>
    
  </entry>
  
  <entry>
    <title>springboot项目调试angular2</title>
    <link href="http://bestlixiang.site/2017/06/01/springboot%E9%A1%B9%E7%9B%AE%E8%B0%83%E8%AF%95angular2/"/>
    <id>http://bestlixiang.site/2017/06/01/springboot项目调试angular2/</id>
    <published>2017-06-01T01:43:33.000Z</published>
    <updated>2017-06-01T01:45:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在接触 springboot和angular2的前后端项目的时候，我发现自己会先把angular2的项目编译好之后放在springboot的resource目录下的static文件夹下运行，虽然这样可以，但是对于前端来调试代码实在不方便。在百度网上的<a href="http://note.youdao.com/" target="_blank" rel="external">方法</a>之后可以采用如下代理的方式。<a id="more"></a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>angular2启动的服务默认为<a href="http://localhost:4200" target="_blank" rel="external">http://localhost:4200</a></li>
<li>springboot启动的服务默认为<a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a></li>
</ol>
<p>如果我们直接设置angular2访问的路径为<a href="http://localhost:8080就会出现跨域访问的问题。请求不到数据。" target="_blank" rel="external">http://localhost:8080就会出现跨域访问的问题。请求不到数据。</a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>在angular2项目的根目录下面新建一个proxy.config.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;/api&quot;: &#123;</div><div class="line">&quot;target&quot;: &quot;http://localhost:8081&quot;,</div><div class="line">&quot;secure&quot;: false</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在启动项目的时候采用下面的命令</p>
<p>ng serve –proxy-config proxy.config.json</p>
<p>通过这样的代理访问就能能够实现跨域访问请求数据。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的方法方便了开发调试，不错，终于要开始写代码了！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在接触 springboot和angular2的前后端项目的时候，我发现自己会先把angular2的项目编译好之后放在springboot的resource目录下的static文件夹下运行，虽然这样可以，但是对于前端来调试代码实在不方便。在百度网上的&lt;a href=&quot;http://note.youdao.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;方法&lt;/a&gt;之后可以采用如下代理的方式。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="springboot" scheme="http://bestlixiang.site/tags/springboot/"/>
    
      <category term="angular2" scheme="http://bestlixiang.site/tags/angular2/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity+JWT保驾SpringBoot(未完)</title>
    <link href="http://bestlixiang.site/2017/05/24/SpringSecurity-JWT%E4%BF%9D%E9%A9%BESpringBoot-%E6%9C%AA%E5%AE%8C/"/>
    <id>http://bestlixiang.site/2017/05/24/SpringSecurity-JWT保驾SpringBoot-未完/</id>
    <published>2017-05-24T15:55:33.000Z</published>
    <updated>2017-05-24T15:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在万老师的指引下，开始接触到了安全板块，SpringSecurity+JWT绝对能够让人欣喜<a id="more"></a></p>
<h2 id="JWT介绍"><a href="#JWT介绍" class="headerlink" title="JWT介绍"></a>JWT介绍</h2><p>关于JWT说实话是最近才听到的，然后慢慢开始了解，这里简单记下一篇<a href="http://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="external">博文</a>。这篇博文在做过简单的应用之后发现还是不怎么全的 ，等自己再深入了解之后，再来补全。</p>
<h2 id="SpringSecurity整合JWT"><a href="#SpringSecurity整合JWT" class="headerlink" title="SpringSecurity整合JWT"></a>SpringSecurity整合JWT</h2><p>看了几个SpringSecurity的应用，发现应该是大同小异，自己也找到一篇虽然结构不太好，但大部分内容都讲到的<a href="https://segmentfault.com/a/1190000009231329" target="_blank" rel="external">博文</a>。也是日后能够总结得好一点，再来补全。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一定要再来！！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在万老师的指引下，开始接触到了安全板块，SpringSecurity+JWT绝对能够让人欣喜
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JWT" scheme="http://bestlixiang.site/tags/JWT/"/>
    
      <category term="SpringSecurity" scheme="http://bestlixiang.site/tags/SpringSecurity/"/>
    
      <category term="SpringBoot" scheme="http://bestlixiang.site/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Angular2入门</title>
    <link href="http://bestlixiang.site/2017/05/24/Angular2%E5%85%A5%E9%97%A8/"/>
    <id>http://bestlixiang.site/2017/05/24/Angular2入门/</id>
    <published>2017-05-24T12:22:59.000Z</published>
    <updated>2017-05-24T12:34:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：由于老师暑假的项目前端代码需要用到Angular2，作为一个后端开发者也是需要了解一丢丢的。<a id="more"></a></p>
<h2 id="Angular简介"><a href="#Angular简介" class="headerlink" title="Angular简介"></a>Angular简介</h2><p>在经过简单的了解与使用之后，感觉 到Angular2的强大与伟大，配的上说是一个优秀的前端框架。Angular2实现了前端一直提倡的组件化开发还解决了大部分项目路由混乱的问题。它还有具有MVC分层架构和依赖注入等一系列优秀的特性。现在贴上Angular2的一张架构图：<br><img src="http://o6plzvjf2.bkt.clouddn.com/angular_overview.png" alt="Angular2架构图"><br>上图描述了Angular2中8大主要构造块的关系，他们具体的理解，可以参考这篇<a href="http://www.cnblogs.com/1wen/p/5466620.html" target="_blank" rel="external">博文</a>。如果还有什么不理解，那我们可以相信实践见真知。</p>
<h2 id="Angular起步"><a href="#Angular起步" class="headerlink" title="Angular起步"></a>Angular起步</h2><p>在这次学习中，我终于理解了前辈们所说的入门一门技术就好的方法就是去看官方文档了，<a href="https://angular.cn/docs/ts/latest/" target="_blank" rel="external">Angular2的官网文档</a>里面有中文版的，相信大家一定很开心吧。当然没有中文版也是要看的，比较都是最基础的入门，不要惧怕英文。</p>
<p>在这次按照官方文档的教程（英雄编辑器）出现了两个问题，这里也说明一下：</p>
<ol>
<li><p>angular-in-memory-web-apia模块不存在</p>
</li>
</ol>
<p>解决方法：通过命令行安装  </p>
<pre><code>npm i angular-in-memory-web-api
</code></pre><ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">create(name: string): Promise&lt;Hero&gt; &#123;</div><div class="line">return this.http</div><div class="line">.post(this.heroesUrl, JSON.stringify(&#123;name: name&#125;), this.headers)</div><div class="line">.toPromise()</div><div class="line">.then(res =&gt; res.json().data as Hero)</div><div class="line">.catch(this.handleError);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里的post方法中的第三个参数应该是this.headers,而不是像官方文档中的那样。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果遇到不懂得问候多看看文档吧，相信自己可以的，然后就是实践见真知了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：由于老师暑假的项目前端代码需要用到Angular2，作为一个后端开发者也是需要了解一丢丢的。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="http://bestlixiang.site/tags/JavaScript/"/>
    
      <category term="Angular2" scheme="http://bestlixiang.site/tags/Angular2/"/>
    
  </entry>
  
  <entry>
    <title>简谈entity，model，domain</title>
    <link href="http://bestlixiang.site/2017/05/23/%E7%AE%80%E8%B0%88entity%EF%BC%8Cmodel%EF%BC%8Cdomain/"/>
    <id>http://bestlixiang.site/2017/05/23/简谈entity，model，domain/</id>
    <published>2017-05-23T05:58:35.000Z</published>
    <updated>2017-05-23T06:00:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：前两天听到关于entity和domain包的区别，好像之前自己也没有在意过，今天看看网上的信息总结一下。<a id="more"></a></p>
<h2 id="entity（实体）"><a href="#entity（实体）" class="headerlink" title="entity（实体）"></a>entity（实体）</h2><p>这好像是最常用的package命名了，package的类一般都是和数据库的表对应的。一个实体，一张表，其字段的类型也是对应的。</p>
<h2 id="model（模型）"><a href="#model（模型）" class="headerlink" title="model（模型）"></a>model（模型）</h2><p>最初接触到它的时候是Struts的模型驱动，用于接受和显示前台的数据对象。我们要根据实际情况来确定模型的类。</p>
<h2 id="domain（域）"><a href="#domain（域）" class="headerlink" title="domain（域）"></a>domain（域）</h2><p>说实话，这个包名用得不怎么多，在网上显示它在国外的网站用的比较多，它主要是用于存储一个业务对象（模块对象）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正确命名包名，有助于后续代码的维护，以及后来开发者的维护，最重要的是能衔接行业的规范。慢慢来！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前两天听到关于entity和domain包的区别，好像之前自己也没有在意过，今天看看网上的信息总结一下。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="web" scheme="http://bestlixiang.site/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>命令行运行hadoop程序</title>
    <link href="http://bestlixiang.site/2017/05/20/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8Chadoop%E7%A8%8B%E5%BA%8F/"/>
    <id>http://bestlixiang.site/2017/05/20/命令行运行hadoop程序/</id>
    <published>2017-05-20T05:37:33.000Z</published>
    <updated>2017-05-20T05:45:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：自己最近心态有点崩，毕竟很迷茫，趁现在比较空 ，也就微微看看hadoop。在运行《Hadoop权威指南》的时候，遇到了按照书上命令行无法运行的问题。<a id="more"></a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="https://drops.azureedge.net/drops/files/acc_558828/cM02q?rscd=inline%3B%20filename%3Dimage%252Fpng&amp;rsct=image%2Fpng&amp;se=2017-05-20T05%3A30%3A20Z&amp;sig=cRQBz%2FO6TM7UcO0YFpb8lkodVaMOOQkgOBI1uFeGYK8%3D&amp;sp=r&amp;sr=b&amp;st=2017-05-20T04%3A30%3A20Z&amp;sv=2013-08-15" alt="问题"></p>
<p>大家都知道刚开始入门，就遇到问题了就必然是十分难受的，那么我们现在可以解决。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>编辑 ~/.bash_profile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export HADOOP_HOME=/usr/local/hadoop</div><div class="line">export CLASSPATH=$($HADOOP_HOME/bin/hadoop classpath):$CLASSPATH</div></pre></td></tr></table></figure></p>
<p>使其生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.bash_profile</div></pre></td></tr></table></figure></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ol>
<li><p>编译主类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac MaxTemperature.java</div></pre></td></tr></table></figure>
</li>
<li><p>把.class 文件打包成 jar，才能在 Hadoop 中运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jar -cvf MaxTemperature.jar ./MaxTemperature*.class</div></pre></td></tr></table></figure>
</li>
<li><p>创建input文件夹的数据，就可以运行了(每次运行时，output文件夹都应该不存在)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hadoop MaxTemperature input/ncdc/sample.txt output</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然我自己还不知道书上的命令行为什么不能用，但是还是希望慢慢可以弄懂吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：自己最近心态有点崩，毕竟很迷茫，趁现在比较空 ，也就微微看看hadoop。在运行《Hadoop权威指南》的时候，遇到了按照书上命令行无法运行的问题。
    
    </summary>
    
      <category term="大数据" scheme="http://bestlixiang.site/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hadoop" scheme="http://bestlixiang.site/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="http://bestlixiang.site/2017/05/17/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://bestlixiang.site/2017/05/17/贪心算法/</id>
    <published>2017-05-17T14:41:13.000Z</published>
    <updated>2017-05-23T06:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：上次看到过钟华老师的一个基于贪心算法的毕业设计，一直很好奇，今天终于能看看它了，只是知其然，不知所以然。<a id="more"></a></p>
<h2 id="贪心算法总说"><a href="#贪心算法总说" class="headerlink" title="贪心算法总说"></a>贪心算法总说</h2><p>贪心算法在每一步都会做出看起来是最佳的选择，也就是说会做出局部最优的选择，希望以此能够得到最优解。</p>
<h2 id="活动选择问题"><a href="#活动选择问题" class="headerlink" title="活动选择问题"></a>活动选择问题</h2><h3 id="贪心选择"><a href="#贪心选择" class="headerlink" title="贪心选择"></a>贪心选择</h3><p>我们要选择这样一个活动，选出它之后身下的资源能够被尽量多的其他任务所用，即选择最早结束的活动。</p>
<h3 id="递归贪心算法"><a href="#递归贪心算法" class="headerlink" title="递归贪心算法"></a>递归贪心算法</h3><p>算法思路：用两个数组s和f表示活动的开始和结束时间。下表k是我们要求解的子问题，以及问题规模n，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class ActivitySelector &#123;</div><div class="line">public int[] s = new int[]&#123;1,3,0,5,3,5,6,8,8,2,12&#125;;</div><div class="line">public int[] f = new int[]&#123;4,5,6,7,9,9,10,11,12,14,16&#125;;</div><div class="line">public List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</div><div class="line">public void recursiveActivitySelector(int[] s, int[] f,int k,int n)&#123;</div><div class="line">if(list.size()==0)&#123;</div><div class="line">list.add(1);</div><div class="line">&#125;</div><div class="line">int m = k+1;</div><div class="line">while (m&lt;n &amp;&amp; s[m]&lt;f[k])&#123;</div><div class="line">m = m+1;</div><div class="line">&#125;</div><div class="line">if(m&lt;n)&#123;</div><div class="line">list.add(m+1);</div><div class="line">recursiveActivitySelector(s, f, m, n);</div><div class="line">&#125; else &#123;</div><div class="line">return ;</div><div class="line">&#125;		</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">ActivitySelector activitySelector = new ActivitySelector();</div><div class="line"></div><div class="line">activitySelector.recursiveActivitySelector(activitySelector.s, activitySelector.f, 0, activitySelector.f.length);</div><div class="line">for (Integer i : activitySelector.list) &#123;</div><div class="line">System.out.println(i);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="迭代贪心算法"><a href="#迭代贪心算法" class="headerlink" title="迭代贪心算法"></a>迭代贪心算法</h3><p>这个过程是假设输入活动的结束时间是已经排好序的，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class GreedyActivitySelector &#123;</div><div class="line">public int[] s = new int[]&#123;1,3,0,5,3,5,6,8,8,2,12&#125;;</div><div class="line">public int[] f = new int[]&#123;4,5,6,7,9,9,10,11,12,14,16&#125;;</div><div class="line">public List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</div><div class="line">public void greedActivitySelector(int[] s,int[] f)&#123;</div><div class="line">int n = s.length;</div><div class="line">list.add(1);</div><div class="line">int k = 1;</div><div class="line">for (int m = 1; m &lt; n; m++) &#123;</div><div class="line">if(s[m]&gt;=f[k])&#123;</div><div class="line">list.add(k);</div><div class="line">k = m;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">ActivitySelector activitySelector = new ActivitySelector();</div><div class="line"></div><div class="line">activitySelector.recursiveActivitySelector(activitySelector.s, activitySelector.f, 0, activitySelector.f.length);</div><div class="line">for (Integer i : activitySelector.list) &#123;</div><div class="line">System.out.println(i);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="贪心算法原理"><a href="#贪心算法原理" class="headerlink" title="贪心算法原理"></a>贪心算法原理</h2><p>设计贪心算法的过程</p>
<ol>
<li>确定问题的最优子结构</li>
<li>设计一个递归算法</li>
<li>证明一个贪心选择，则只剩下一个子问题</li>
<li>证明贪心选择总是安全的</li>
<li>设计一个递归算法实现贪心策略</li>
<li>将递归算法转换为迭代算法</li>
</ol>
<p>证明一个贪心算法是否能求解一个最优化问题？具有下面性质就ok？</p>
<ol>
<li>贪心选择性质</li>
</ol>
<p>我们可以通过做出局部最优选择来构造全局最优解</p>
<ol>
<li>最优子结构</li>
</ol>
<p>如果一个问题的最优解包含子问题的最优解</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一步一步慢慢贪心，和做人是一样的，但是总的来说还是要考虑全局的！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：上次看到过钟华老师的一个基于贪心算法的毕业设计，一直很好奇，今天终于能看看它了，只是知其然，不知所以然。
    
    </summary>
    
      <category term="算法" scheme="http://bestlixiang.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="算法导论" scheme="http://bestlixiang.site/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://bestlixiang.site/2017/05/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://bestlixiang.site/2017/05/17/动态规划/</id>
    <published>2017-05-17T11:52:35.000Z</published>
    <updated>2017-05-17T11:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：慢慢就步入了算法导论的高级设计与分析技术模块，先来看看动态规划。ps:快毕业的心情org。<a id="more"></a></p>
<h2 id="动态规划总说"><a href="#动态规划总说" class="headerlink" title="动态规划总说"></a>动态规划总说</h2><p>动态规划虽然与分治方法相似，但是它能够解决子问题重叠的情况，这样就提高了效率。它通常是用来求解最优化的问题。求得是<strong>一个</strong>最优解。一般按如下4个步骤来设计一个动态规划算法。</p>
<ol>
<li>刻画一个最优解的结构特征</li>
<li>递归地定义最优解的值</li>
<li>计算最优解的值，通常采用自底向上的方法</li>
<li>利用计算出的信息构造出一个最优解</li>
</ol>
<h2 id="钢条切割"><a href="#钢条切割" class="headerlink" title="钢条切割"></a>钢条切割</h2><p>先看以前常用的分治方法即自顶向下方法,代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class CutRod &#123;</div><div class="line">//a[i]表示长度为i的钢条利润是多少</div><div class="line">public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;</div><div class="line">//自顶向下递归设计</div><div class="line">public int cutRod(int[] a,int n) &#123;</div><div class="line">if(n == 0)&#123;</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line">int q = 0;</div><div class="line">for (int i = 0; i&lt;n; i++)&#123;</div><div class="line">q = max(q,a[i]+cutRod(a,n-1-i));</div><div class="line">&#125;</div><div class="line">return q;</div><div class="line">&#125;</div><div class="line">//求最大值函数</div><div class="line">public int max(int a, int b)&#123;</div><div class="line">if(a&gt;b)&#123;</div><div class="line">return a;</div><div class="line">&#125; else &#123;</div><div class="line">return b;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">CutRod cut = new CutRod(); </div><div class="line">int lost = cut.cutRod(cut.a,10);</div><div class="line">System.out.println(lost);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>问题：反复地用相同的参数值对自身进行递归调用，造成了运行时间为n的指数函数。</p>
<p>为了解决这个问题，我们可以采用动态规划方法求解最优钢条切割问题。</p>
<ol>
<li><p>采用带备忘的自顶向下法<br>核心是利用一个数组存储已经求解过的最优解，避免了重复的计算，具体的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class MemoizedCutRod &#123;</div><div class="line">//a[i]表示长度为i的钢条利润是多少</div><div class="line">public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;</div><div class="line">//带备忘的自顶向下函数</div><div class="line">public int memoizedCutRod(int[] a,int n)&#123;</div><div class="line">//创建一个备忘的数组存储一个之前计算过的最优解</div><div class="line">int[] r = new int[n];</div><div class="line">//初始化数组</div><div class="line">for (int i : r) &#123;</div><div class="line">i = 0;</div><div class="line">&#125;</div><div class="line">//借助辅助函数计算</div><div class="line">return memoizedCutRodAux(a, n, r);</div><div class="line">&#125;</div><div class="line">//带备忘的自顶向下法辅助函数</div><div class="line">public int memoizedCutRodAux(int[] a,int n,int[] r) &#123;</div><div class="line">//定义利润</div><div class="line">int q = 0;</div><div class="line">if(n == 0)&#123;</div><div class="line">return 0;</div><div class="line">&#125; </div><div class="line">//判断原先是否已经计算过，若计算过就不用再计算</div><div class="line">if(r[n-1] &gt;0)&#123;</div><div class="line">return r[n-1]; </div><div class="line">&#125;else &#123;</div><div class="line">for (int i = 0; i&lt;n; i++)&#123;</div><div class="line">q = max(q,a[i]+memoizedCutRodAux(a, n-1-i, r));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">r[n-1] = q;</div><div class="line">return q;</div><div class="line">&#125;</div><div class="line">//求最大值函数</div><div class="line">public int max(int a, int b)&#123;</div><div class="line">if(a&gt;b)&#123;</div><div class="line">return a;</div><div class="line">&#125; else &#123;</div><div class="line">return b;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MemoizedCutRod cut = new MemoizedCutRod();</div><div class="line">int lost = cut.memoizedCutRod(cut.a, 10);</div><div class="line">System.out.println(lost);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>采用由底向上的方法<br>核心是从小算到大算出每一个长度的最优解，然后返回想要的长度的最优解。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class BottomUpTopCutRod &#123;</div><div class="line">//a[i]表示长度为i的钢条利润是多少</div><div class="line">public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;</div><div class="line">public int bottomUpTopCutRod(int[] a, int n)&#123;</div><div class="line">int[] r = new int[n+1];</div><div class="line">//长度为0的时候，收益为0</div><div class="line">r[0] = 0;</div><div class="line">int q = 0;</div><div class="line">for(int i = 0; i&lt;n; i++)&#123;</div><div class="line">for(int j = 0; j&lt;=i; j++)&#123;</div><div class="line">q = max(q,a[j]+r[i-j]);</div><div class="line">&#125;</div><div class="line">r[i+1] = q;</div><div class="line">&#125;</div><div class="line">return r[n];</div><div class="line">&#125;</div><div class="line">//求最大值函数</div><div class="line">public int max(int a, int b)&#123;</div><div class="line">if(a&gt;b)&#123;</div><div class="line">return a;</div><div class="line">&#125; else &#123;</div><div class="line">return b;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">BottomUpTopCutRod cut = new BottomUpTopCutRod();</div><div class="line">int lost = cut.bottomUpTopCutRod(cut.a, 10);</div><div class="line">System.out.println(lost);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>优势：实现了运行时间复杂度n*n</p>
<h2 id="动态规划原理"><a href="#动态规划原理" class="headerlink" title="动态规划原理"></a>动态规划原理</h2><p>适用应用动态规划方法求解的最优化问题应该具备的两个要素：最优子结构和子问题重叠</p>
<h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>如果一个问题的最优解包含其子问题的最优解，我们就称这个问题具有最优子结构性质。例如：无权最短路径。</p>
<h3 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h3><p>如果递归算法反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质。例如钢条切割。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>慢慢懂一点小算法思想。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：慢慢就步入了算法导论的高级设计与分析技术模块，先来看看动态规划。ps:快毕业的心情org。
    
    </summary>
    
      <category term="算法" scheme="http://bestlixiang.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="算法导论" scheme="http://bestlixiang.site/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>观《驴得水》呻吟</title>
    <link href="http://bestlixiang.site/2017/05/11/%E8%A7%82%E3%80%8A%E9%A9%B4%E5%BE%97%E6%B0%B4%E3%80%8B%E5%91%BB%E5%90%9F/"/>
    <id>http://bestlixiang.site/2017/05/11/观《驴得水》呻吟/</id>
    <published>2017-05-11T07:48:01.000Z</published>
    <updated>2017-05-17T07:50:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：其实当身边同学都在打游戏的时候，我却不能静下心来了，内心仍然是浮躁，既然不能改论文，所以自己就找电影看吧。自认为自己是一个不懂得享受的人，所以在大脑思索良久之后，决定观看好久之前评价还不错的电影《驴得水》。<a id="more"></a></p>
<h2 id="总说"><a href="#总说" class="headerlink" title="总说"></a>总说</h2><p>我不知道该以什么角度来评价这部电影，但这部电影给我感受是深刻，至少在灵魂上还是有一定的冲击，感觉作者与导演把每个角色想要表达的思想基本上都表达出来了，下面我也将按这些角色把在我身上能够体会到的思想说一下，至少在我心里，这是一部好电影。</p>
<h2 id="角色思想"><a href="#角色思想" class="headerlink" title="角色思想"></a>角色思想</h2><h3 id="校长"><a href="#校长" class="headerlink" title="校长"></a>校长</h3><p>这个一个有抱负的校长，但是却又特别的自私，为了达成自己的抱负，他选择了屈服，虽然在某些片段来说，他有一点想反抗，如他不能忍受裴魁山去骂张一曼，但是那一点反抗却是那么无力，到最后他选择了屈服，屈服到了让自己的女儿去做牺牲。<br>关于这个角色我不想做太多评价，他总说以大局为重，或许在生活中很多人都会这么做，自私到可以牺牲掉很多。</p>
<h3 id="裴魁山"><a href="#裴魁山" class="headerlink" title="裴魁山"></a>裴魁山</h3><p>这个角色应该就是现在很多人所说的腹黑吧，自己得不到，就宁愿把他毁掉，他从不介意张一曼的出身愿意娶她，到指着他的鼻子骂，这个转变让很多人心凉，追不到还能做朋友么，他的回答告诉我们，他不搞她已经是最好的结果了。爱一个可以随时为她着想，恨一个人希望所有人都恨他。</p>
<h3 id="铜匠"><a href="#铜匠" class="headerlink" title="铜匠"></a>铜匠</h3><p>也许他后面变得很坏，但是我从头到尾都认为他是这部剧最可怜的人，他原来是一个单纯至极的人，命运使然他加入到了一个骗子集团吧，因为单纯才会认为张一曼会喜欢他吧，因为单纯所以期望太高，这导致在张一曼骂他牲口之后开始最强烈的抱负。但是有一点他这个觉得传递了不好的概念，有知识不是为了更好的抱负，而是应该为了更好的帮助别人，虽然他的行为可以理解，但是却不提倡，从他到最后还是想去美国学习，可以看出他还是很想学习的，想脱离文盲这个行列。</p>
<h3 id="张一曼"><a href="#张一曼" class="headerlink" title="张一曼"></a>张一曼</h3><p>这是一个不畏世俗的眼光，勇敢追求自由的女子，也不能说是道德败坏吧，虽然和有妇之夫搞一起不太好，但是他自己也有自己的原则，就像他一开始不愿意将她和铜匠的事情说出来一样，他有自己一定的原则。但是在校长的屈服下，也造就了他的悲剧，最后开枪自杀了。</p>
<h3 id="周铁男"><a href="#周铁男" class="headerlink" title="周铁男"></a>周铁男</h3><p>这个角色也是反映了一部分人，他喜欢孙佳，但是一直没有说出来，也算单纯耿直的人，平时脾气挺冲，在别人要动孙佳的时候也立马站了出来，可惜在擦过枪子的之后，他选择了屈服，他慢慢开始收敛自己，只是为了能够活下去，他甚至可以认忍受孙佳去嫁给铜匠，所以说，所谓的爱在现实的生与死之间是那么的不堪。</p>
<h3 id="孙佳"><a href="#孙佳" class="headerlink" title="孙佳"></a>孙佳</h3><p>这个人或许是这部剧中完全没有污点的人吧，应该也是导演想表达的正面形象，他是唯一一个把驴得水当做人看的人，也是第一个想揭发整个阴谋的人，面对这一切，她说过去的都让他过去的话，那么只能越来越错，不能让错误一直延续下去。莫名戳中内心。</p>
<h3 id="特派员"><a href="#特派员" class="headerlink" title="特派员"></a>特派员</h3><p>一个目不识丁，却假装英国留学回来的官员，所谓的民间教育家的评选，不过是教育部敛财的名头，从被骗到一起骗说明政府的腐败与强势，从十万到三万，我们看到了心凉。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要人物各有各的责任，他们都反应了这个世界上的一部分人，所以感受很深，点评不当之处，也希望大家担待。好吧，呻吟到此结束。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：其实当身边同学都在打游戏的时候，我却不能静下心来了，内心仍然是浮躁，既然不能改论文，所以自己就找电影看吧。自认为自己是一个不懂得享受的人，所以在大脑思索良久之后，决定观看好久之前评价还不错的电影《驴得水》。
    
    </summary>
    
      <category term="生活" scheme="http://bestlixiang.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="电影" scheme="http://bestlixiang.site/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>选择算法</title>
    <link href="http://bestlixiang.site/2017/05/10/%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/"/>
    <id>http://bestlixiang.site/2017/05/10/选择算法/</id>
    <published>2017-05-10T14:18:10.000Z</published>
    <updated>2017-05-10T14:19:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：300000是不是一个小目标，不知道为了目的还是目的，只想好好努力，功利也好，安慰也罢！<a id="more"></a></p>
<h2 id="期望为线性时间的选择算法"><a href="#期望为线性时间的选择算法" class="headerlink" title="期望为线性时间的选择算法"></a>期望为线性时间的选择算法</h2><p>算法思想：</p>
<ol>
<li>检查数组是否只有一个数，如是，只好返回该数</li>
<li>采用随机分割将数组氛围a[p..q-1]和a[q+1..r]并返回主元q</li>
<li>检查如果该主元就是我们要找的数，就返回</li>
<li>判断前半部分的个数，如果要找的顺序大于前面的个数，就递归调用后面的数组，否则递归调用前面的数组</li>
</ol>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">public class Randomized_select &#123;</div><div class="line">public int randomized_select(int[] a,int p, int r,int i)&#123;</div><div class="line">//如果分割到只剩一个元素了，那么就是这个了</div><div class="line">if(p == r)&#123;</div><div class="line">return a[p];</div><div class="line">&#125;</div><div class="line">//随机分割</div><div class="line">int q = randompartition(a, p, r);</div><div class="line">//确定q是第几小的数</div><div class="line">int k = q-p+1;</div><div class="line">if(k == i) &#123;</div><div class="line">return a[q];</div><div class="line">&#125;</div><div class="line">else if(k&lt;i)&#123;</div><div class="line">//递归调用后半部分的数</div><div class="line">return randomized_select(a, q+1, r, i-k);</div><div class="line">&#125; else &#123;</div><div class="line">//递归调用前半部分的数</div><div class="line">return randomized_select(a, p, q-1, i);</div><div class="line">&#125;		</div><div class="line">&#125;</div><div class="line">//分割函数</div><div class="line">public int partition(int[] a,int p,int r)&#123;</div><div class="line">int x = a[r];</div><div class="line">int i = -1;</div><div class="line">int temp = 0;</div><div class="line">for (int j = 0; j &lt; a.length-1; j++) &#123;</div><div class="line">if(a[j]&lt;x)&#123;</div><div class="line">i=i+1;</div><div class="line">temp = a[i];</div><div class="line">a[i] = a[j];</div><div class="line">a[j] = temp;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">temp = a[i+1];</div><div class="line">a[i+1] = x;</div><div class="line">a[r] = temp;</div><div class="line">return i+1;</div><div class="line">&#125;</div><div class="line">//随机分割　</div><div class="line">public int randompartition(int[] a,int p,int r)&#123;</div><div class="line">int temp = 0;</div><div class="line">Random random = new Random();</div><div class="line">int i = random.nextInt(r);</div><div class="line">temp = a[i];</div><div class="line">a[i] = a[r];</div><div class="line">a[r] = temp;</div><div class="line">return partition(a, p, r);</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">int[] a = new int[]&#123;3,2,9,0,7,5,4,8,6,1&#125;;</div><div class="line">Randomized_select select = new Randomized_select();</div><div class="line">int num = select.randomized_select(a, 0, a.length-1, 10);</div><div class="line">System.out.println(num);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>算法分析：期望时间复杂度是线性的O(n),但是最坏的时间复杂度是O(n*n)</p>
<h2 id="最坏情况为线性时间的选择算法"><a href="#最坏情况为线性时间的选择算法" class="headerlink" title="最坏情况为线性时间的选择算法"></a>最坏情况为线性时间的选择算法</h2><p>算法思想：</p>
<ol>
<li>将输入数组的n个元素划分为n/5组，每组5个元素，且至多只有一组由剩下的nmod5个元素组成。</li>
<li>寻找每一个组的中位数：首先对每组元素进行插入排序，然后确定每组的中位数。</li>
<li>对第2部的中位数数组利用递归调用前面的random_select()求取中位数x</li>
<li>利用修改的partition(),按中位数x进行划分，得到比x小的数有k个</li>
<li>如果i=k则返回x。如果i<k,则在低区递归调用select找出第i小元素，如果i>k，则在高区递归查找第i-k小的元素</k,则在低区递归调用select找出第i小元素，如果i></li>
</ol>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">package select;</div><div class="line"></div><div class="line">public class GoodSelect &#123;</div><div class="line">//插入排序</div><div class="line">public void insertsort(int[] a,int p, int r)</div><div class="line">&#123;</div><div class="line">for (int i=p+1;i&lt;=r;i++) &#123;</div><div class="line">int temp = 0;</div><div class="line">//*从后往前插*</div><div class="line">for(int j = i;j&gt;p &amp;&amp; a[j]&lt;a[j-1];j--)&#123;</div><div class="line">temp = a[j];</div><div class="line">a[j] = a[j-1];</div><div class="line">a[j-1] = temp;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//对数组A[]分组，每组5个元素，分别进行插入排序,返回中位数数组</div><div class="line">public int[] partInsertSort(int[] a,int p,int r)  &#123;</div><div class="line">int i = 0;</div><div class="line">int[] b;</div><div class="line">if((r-p+1)%5==0)&#123;</div><div class="line">b = new int[(r-p+1)/5];</div><div class="line">&#125; else &#123;</div><div class="line">b = new int[(r-p+1)/5+1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">int Length = r-p+1;</div><div class="line">if (Length &lt;= 5)     //元素个数少于5个</div><div class="line">&#123;  </div><div class="line">insertsort(a,p,r);</div><div class="line">b[0]=a[p+(Length-1)/2];</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">for (i=0;i&lt;Length/5;i++)</div><div class="line">&#123;</div><div class="line">insertsort(a,p+i*5,p+i*5+4);</div><div class="line"></div><div class="line">b[i]=a[i*5+2];     //B[i] 存储各组中位数</div><div class="line">&#125;</div><div class="line">if ( Length%5 != 0 )</div><div class="line">&#123;</div><div class="line">insertsort(a,Length-1-(Length-1)%5,Length-1);</div><div class="line">b[i]=a[Length-1-Length%5/2];  //B[i] 存储最后一组中位数</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return b;           //  返回分组的个数</div><div class="line"></div><div class="line">&#125;</div><div class="line">//调用random_select算法，选出中位数数组的中位数</div><div class="line">public int selectmid(int[] a)&#123;</div><div class="line">Randomized_select randomized_select = new Randomized_select();</div><div class="line">int num = randomized_select.randomized_select(a, 0, a.length-1, (a.length+1)/2);</div><div class="line">return num;		</div><div class="line">&#125;</div><div class="line">//安装精心挑选的中位数来分割数组</div><div class="line">public int partition(int[] a,int p,int r,int x)&#123;</div><div class="line">int j = p-1;</div><div class="line">int i = 0;</div><div class="line">int temp =0;</div><div class="line">int addr = 0;//记录最佳中位数的位置</div><div class="line">for(i = p; i&lt;r+1; i++)&#123;</div><div class="line">if(a[i]&lt;=x)&#123;</div><div class="line">j+=1;</div><div class="line">temp = a[j];</div><div class="line">a[j] = a[i];</div><div class="line">a[i] = temp;				</div><div class="line">&#125;</div><div class="line">if(a[i] == x)&#123;</div><div class="line">addr = i;</div><div class="line">&#125;		</div><div class="line">&#125;</div><div class="line">temp = a[j];</div><div class="line">a[j] = a[addr];</div><div class="line">a[addr] = temp;	</div><div class="line">return j;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public int goodselect(int[] a,int p,int r,int i)&#123;</div><div class="line">//如果分割到只剩一个元素了，那么就是这个了</div><div class="line">if(p == r)&#123;</div><div class="line">return a[p];</div><div class="line">&#125;</div><div class="line">int [] b = partInsertSort(a, p, r);</div><div class="line">int x = selectmid(b);</div><div class="line">int q = partition(a, p, r, x);</div><div class="line">//确定q是第几小的数</div><div class="line">int k = q-p+1;</div><div class="line">if(k == i) &#123;</div><div class="line">return a[q];</div><div class="line">&#125;</div><div class="line">else if(k&lt;i)&#123;</div><div class="line">//递归调用后半部分的数</div><div class="line">return goodselect(a, q+1, r, i-k);</div><div class="line">&#125; else &#123;</div><div class="line">//递归调用前半部分的数</div><div class="line">return goodselect(a, p, q-1, i);</div><div class="line">&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">int[] a = new int[]&#123;2,1,4,6,5,8,9,7,11,13,12,15,16&#125;;</div><div class="line">GoodSelect select = new GoodSelect();</div><div class="line">int num  = select.goodselect(a, 0, a.length-1, 13);</div><div class="line">System.out.println(num);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>算法总结：毕竟是三个人发明的算法，真是好牛逼的，厉害，实现了最坏时间还是线性的。具体分析请参考算法导论原书。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第二个算法真的花了自己好长的时间来调试，还是说明自己的编码能力差劲，要好好努力，慢慢提高，加油！</p>
<p>ps：有一种体会，学算法是为了创造，大多数人只要把优秀的源码包里的算法理解了就好，并加以使用就好！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：300000是不是一个小目标，不知道为了目的还是目的，只想好好努力，功利也好，安慰也罢！
    
    </summary>
    
      <category term="算法" scheme="http://bestlixiang.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法导论" scheme="http://bestlixiang.site/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>“线性时间排序（未完，待续）”</title>
    <link href="http://bestlixiang.site/2017/05/10/%E2%80%9C%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%8C%E5%BE%85%E7%BB%AD%EF%BC%89%E2%80%9D/"/>
    <id>http://bestlixiang.site/2017/05/10/“线性时间排序（未完，待续）”/</id>
    <published>2017-05-10T02:11:16.000Z</published>
    <updated>2017-05-10T02:13:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：排序慢慢来，今天要接触到线性时间排序了：计数排序，基数排序，桶排序。<a id="more"></a></p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>前提条件：知道输入数组的最大值。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public int[] countingsort(int[] a,int k)&#123;</div><div class="line">//初始化临时数组,k为数组的最大值</div><div class="line">int[] c = new int[k+1];</div><div class="line">for(int i=0; i&lt;=k; i++) &#123;</div><div class="line">c[i]=0;</div><div class="line">&#125;</div><div class="line">//获得等于i的元素个数</div><div class="line">for(int i= 0; i&lt;a.length-1;i++) &#123;</div><div class="line">c[a[i]] = c[a[i]]+1;</div><div class="line">&#125;</div><div class="line">//获得小于等于i的元素个数(隐含了递归调用)</div><div class="line">for(int i = 1; i&lt;=k; i++) &#123;</div><div class="line">c[i] = c[i] +c[i-1];</div><div class="line">&#125;</div><div class="line">//按顺序分到输出数组</div><div class="line">int[] b = new int[a.length];</div><div class="line">for(int i = a.length-1; i&gt;=0; i--) &#123;</div><div class="line">b[c[a[i]]] = a[i];</div><div class="line">c[a[i]] = c[a[i]]-1;</div><div class="line">&#125;</div><div class="line">return b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优劣：实现了线性时间，但是空间损失惨重，像是叫你排序这三个数：1，3，1000000000000，马上高低立见。</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>IBM创始人发明，利用进制数的位进行从低到高比较。其中会将原来的数转化为r进制数，使时间复杂度变为线性。<br>写一下伪代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">redix-sort(A,d)</div><div class="line">for i = 1 to d</div><div class="line">use a stable sort to sort array A on digit i</div></pre></td></tr></table></figure></p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序假设数据服从均匀分布，讲一个区间分成若干个桶，先将数据放到桶中分开排序再合并。<br>伪代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">bucket-sort(A)</div><div class="line">n = A.length</div><div class="line">let B[0.. n-1] be a new array</div><div class="line">for i = 0 to n - 1</div><div class="line">make  B[i] an empty list</div><div class="line">for i = 1 to n </div><div class="line">insert A[i] into list B[nA[i]]</div><div class="line">for i = 0 to n - 1</div><div class="line">sort list B[i] with insertion sort</div><div class="line">concatenete the lists B[0],B[1].. B[n-1] together in order</div></pre></td></tr></table></figure></p>
<p>它的期望时间为线形。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其中对于基数排序和桶排序理解得不是很好，需要加深理解，写出具体实现代码，未完，待续…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：排序慢慢来，今天要接触到线性时间排序了：计数排序，基数排序，桶排序。
    
    </summary>
    
      <category term="算法" scheme="http://bestlixiang.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="线性时间排序" scheme="http://bestlixiang.site/tags/%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F/"/>
    
      <category term="算法导论" scheme="http://bestlixiang.site/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://bestlixiang.site/2017/05/10/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://bestlixiang.site/2017/05/10/堆排序/</id>
    <published>2017-05-10T01:32:17.000Z</published>
    <updated>2017-05-10T01:37:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：真的是烦，连个hadoop集群环境都搭不好，发现一个人学还是很困难的，想想还是一个人看算法会简单些，所以来看看了，今天看堆排序！<a id="more"></a></p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>堆排序是原址运算，后来由于Java的原因我用了变址，但是算法的思想还是没有变得的.堆分为大顶堆，小顶堆，我们下面以大顶堆为例。</p>
<h3 id="维护堆"><a href="#维护堆" class="headerlink" title="维护堆"></a>维护堆</h3><p>我们需要一个函数在任何情况下子节点要比根节点小。<br>函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">//取父节点</div><div class="line">public int parent(int i)&#123;</div><div class="line"> return (int)Math.ceil(i/2)-1;</div><div class="line">&#125;</div><div class="line">//取左子树</div><div class="line">public int left(int i)&#123;</div><div class="line">	if(i == 0)&#123;</div><div class="line">		return i+1;</div><div class="line">	&#125; else&#123;</div><div class="line">		return 2*i+1;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//取右子树</div><div class="line">public int right(int i)&#123;</div><div class="line">	if(i == 0)&#123;</div><div class="line">		return i+2;</div><div class="line">	&#125; else&#123;</div><div class="line">		return 2*i+2;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//维护大顶堆</div><div class="line">public int[] max_heapify(int[] a,int i)&#123;</div><div class="line">	int l = left(i);</div><div class="line">	int r = right(i);</div><div class="line">	int largest = 0;</div><div class="line">	int temp = 0;</div><div class="line">	if(l&gt;=a.length &amp;&amp; r&gt;=a.length)&#123;</div><div class="line">		return a;</div><div class="line">	&#125;</div><div class="line">	if(l&lt;a.length &amp;&amp; a[l]&gt;a[i])&#123;</div><div class="line">		largest = l;</div><div class="line">	&#125; else&#123;</div><div class="line">		largest = i;</div><div class="line">	&#125;</div><div class="line">	if(r&lt;a.length &amp;&amp; a[r]&gt;a[largest])&#123;</div><div class="line">		largest = r;</div><div class="line">	&#125;</div><div class="line">	if(largest!=i) &#123;</div><div class="line">		temp = a[i];</div><div class="line">		a[i] = a[largest];</div><div class="line">		a[largest] = temp;</div><div class="line">		max_heapify(a, largest);</div><div class="line">	&#125;</div><div class="line">	return a;		</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>在对数组遍历建立二叉树的时候，我们容易得出Math.floor(n/2)到n都是叶节点，其余是根节点，所以我们在建堆得时候冲根节点不断往前维护就好。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//建大堆</div><div class="line">public int[] bulid_max_heap(int[] a)&#123;</div><div class="line">	heap_size = a.length;</div><div class="line">	for(int i = (int)Math.floor(a.length/2)-1; i&gt;=0; i--)&#123;</div><div class="line">		max_heapify(a, i);</div><div class="line">	&#125;</div><div class="line">	return a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h3><p>思想：先取出顶，再维护，再取顶，再维护，知道最后<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//堆排序算法</div><div class="line">public int[] heapsort(int[] a) &#123;</div><div class="line">	int[] b = new int[a.length];//无奈之举，java没有size这个属性，或者用list也可以</div><div class="line">	bulid_max_heap(a);</div><div class="line">	for(int i = a.length-1; i&gt;=1; i--)&#123;</div><div class="line">		b[i] = a[0];</div><div class="line">		a[0] = a[i];</div><div class="line">		a[i] = 0;//使最后一个元素不参与排序</div><div class="line">		max_heapify(a, 0);</div><div class="line">	&#125;</div><div class="line">	b[0] = a[0];</div><div class="line">	return b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>算法时间复杂度：<strong>nlgn</strong></p>
<h3 id="重要应用——优先队列"><a href="#重要应用——优先队列" class="headerlink" title="重要应用——优先队列"></a>重要应用——优先队列</h3><p>优先队列应用于共享计算机的系统的作业调度，最大优先队列记录将要执行的各个作业以及它们之间的相对优先级，在任何时候都可以调用insert把一个新作业加入到队列中来。<br>讲一下最大优先序列的几个操作。</p>
<h4 id="maximum获取最大值"><a href="#maximum获取最大值" class="headerlink" title="maximum获取最大值"></a>maximum获取最大值</h4><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">	//获取最大值</div><div class="line">public int maximum(int[] a)&#123;</div><div class="line">	return a[1];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="去掉并返回数组中的最大键值得元素"><a href="#去掉并返回数组中的最大键值得元素" class="headerlink" title="去掉并返回数组中的最大键值得元素"></a>去掉并返回数组中的最大键值得元素</h4><p>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//去掉并返回数组中具有最大键值得元素</div><div class="line">public int extract_max(int[] a)&#123;</div><div class="line">	if(a.length&lt;1)&#123;</div><div class="line">		System.out.println(&quot;heap underflow&quot;);</div><div class="line">	&#125;</div><div class="line">	int max = a[0];</div><div class="line">	a[0] = a[a.length];</div><div class="line">	max_heapify(a, 0);</div><div class="line">	return max;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>加油呀加油！堆排序还是强大的，期待运用！ </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：真的是烦，连个hadoop集群环境都搭不好，发现一个人学还是很困难的，想想还是一个人看算法会简单些，所以来看看了，今天看堆排序！
    
    </summary>
    
      <category term="算法" scheme="http://bestlixiang.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法导论" scheme="http://bestlixiang.site/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>nginx反向代理与负载均衡</title>
    <link href="http://bestlixiang.site/2017/05/06/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://bestlixiang.site/2017/05/06/nginx反向代理与负载均衡/</id>
    <published>2017-05-06T14:45:44.000Z</published>
    <updated>2017-05-06T15:09:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：慢慢做项目的过程中，也就接触到了负载均衡，谈到负载均衡就会接触到反向代理服务器，这里介绍一下nginx。<a id="more"></a></p>
<h2 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h2><h3 id="nginx简介"><a href="#nginx简介" class="headerlink" title="nginx简介"></a>nginx简介</h3><p>nginx是一个使用c语言开发的高性能的http服务器及反向代理服务器，是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。<br>感觉棒棒哒。</p>
<h3 id="nginx应用场景"><a href="#nginx应用场景" class="headerlink" title="nginx应用场景"></a>nginx应用场景</h3><ol>
<li>http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。</li>
<li>虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。</li>
<li>反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。</li>
</ol>
<h3 id="nginx安装启动配置"><a href="#nginx安装启动配置" class="headerlink" title="nginx安装启动配置"></a>nginx安装启动配置</h3><ol>
<li>安装：<br>nginx一般安装在linux下</li>
<li>启动： <code>在sbin目录下执行: ./nginx</code> 如果访问不到，可能就是linux防火墙没有开启8080端口的访问——关闭：<code>在sbin目录下执行: ./nginx -s stop</code>——刷新配置：<code>在sbin目录下执行: ./nginx -s reload</code></li>
<li>配置虚拟主机：在nginx.conf文件中添加一个Service节点，修改端口号就可以<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">	listen       81;</div><div class="line">	server_name  localhost;</div><div class="line"></div><div class="line">	#charset koi8-r;</div><div class="line"></div><div class="line">	#access_log  logs/host.access.log  main;</div><div class="line"></div><div class="line">	location / &#123;</div><div class="line">	root   html81;</div><div class="line">	index  index.html index.htm;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="nginx反向代理-1"><a href="#nginx反向代理-1" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h2><p>反向代理服务器是引用在服务端。决定哪台服务器提供服务。<br>用一张图来理解：<br><img src="http://o6plzvjf2.bkt.clouddn.com/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" alt="反向代理"></p>
<h2 id="nginx负载均衡"><a href="#nginx负载均衡" class="headerlink" title="nginx负载均衡"></a>nginx负载均衡</h2><p>并发量大的时候自然会用到负载均衡，其实每台服务器的内容都是一样的，多台机器服务自然减轻了单台服务器的压力。在nginx中其实配置很简单，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">upstream tomcats&#123;</div><div class="line">	server 192.168.142.128:8080 weight=2;</div><div class="line">	server 192.168.142.128:8081;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server&#123; </div><div class="line">	listen     80;</div><div class="line">	server_name  tomcat.taobao.com;</div><div class="line"></div><div class="line">	#charset koi8-r;</div><div class="line"></div><div class="line">	#access_log  logs/host.access.log  main;</div><div class="line">	location / &#123;</div><div class="line">	proxy_pass http://tomcats;</div><div class="line">	index  index.html index.htm;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只需要在upstream的server后面添加一个weight即可代表权重。权重越高，分配请求的数量就越多。默认权重是1。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实很多东西没有自己想象的那么难，好好努力，每天积累！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：慢慢做项目的过程中，也就接触到了负载均衡，谈到负载均衡就会接触到反向代理服务器，这里介绍一下nginx。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="nginx" scheme="http://bestlixiang.site/tags/nginx/"/>
    
      <category term="负载均衡" scheme="http://bestlixiang.site/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
</feed>
