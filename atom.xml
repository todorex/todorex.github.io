<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rex note</title>
  <subtitle>雨过，云过</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bestlixiang.site/"/>
  <updated>2018-05-20T06:59:29.325Z</updated>
  <id>http://bestlixiang.site/</id>
  
  <author>
    <name>rex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP协议</title>
    <link href="http://bestlixiang.site/2018/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://bestlixiang.site/2018/05/20/计算机网络/HTTP协议/</id>
    <published>2018-05-20T06:55:48.000Z</published>
    <updated>2018-05-20T06:59:29.325Z</updated>
    
    <content type="html"><![CDATA[<p>引：作为Web开发人员，可能你最需要深入学习的就是<strong>HTTP协议</strong>了吧！<a id="more"></a></p>
<h1 id="HTTP认识"><a href="#HTTP认识" class="headerlink" title="HTTP认识"></a>HTTP认识</h1><p><strong>HTTP协议</strong>是Hyper Text TransferProtocol（超文本传输协议）的缩写,<br>它是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）的应用层协议。它工作于客户端-服务端架构之上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<h1 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h1><ol>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li>
<li>HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。HTTP 1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。</li>
<li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
</ol>
<p><strong>PS：</strong> HTTP协议是无状态的和Connection: keep-alive的区别：</p>
<ul>
<li><p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。<br>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</p>
</li>
<li><p>从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。<br>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p>
</li>
</ul>
<h1 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h1><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了<strong>请求/响应模型</strong>。客户端向服务器发送一个<strong>请求报文</strong>，服务器将返回一个<strong>响应报文</strong>。</p>
<p>以下是 HTTP 请求步骤：</p>
<ol>
<li>客户端连接到Web服务器：<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如：<a href="http://www.todorex.com。" target="_blank" rel="external">http://www.todorex.com。</a></li>
<li>发送HTTP请求：<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文。</li>
<li>服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。</li>
<li>释放连接TCP连接：<br>若请求报文首部的connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求。</li>
<li>客户端浏览器解析HTML内容<br>客户端浏览器首先解析响应报文，然后客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</li>
</ol>
<h1 id="HTTP报文之请求报文"><a href="#HTTP报文之请求报文" class="headerlink" title="HTTP报文之请求报文"></a>HTTP报文之请求报文</h1><p>请求报文由请求行(请求方法、URL、协议版本)、请求头部、空行(回车+换行)和请求数据(主体)四个部分组成。如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/httpRequest.png" alt="httpRequest"></p>
<p>它的例子如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/httpRequestDemo.png" alt="httpReponseDemo"></p>
<h2 id="请求报文之URL"><a href="#请求报文之URL" class="headerlink" title="请求报文之URL"></a>请求报文之URL</h2><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URI包含了用于查找某个资源的足够的信息。</p>
<p>统一资源定位符（Uniform Resource Locator, URL）是互联网上用来标识某一处资源的地点，所以可见URL是URI的子集。以下面这个URL为例，介绍下普通URL的各部分组成：</p>
<blockquote>
<p><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name" target="_blank" rel="external">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></p>
</blockquote>
<p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p>
<ol>
<li>协议部分：该URL的协议部分为“http:”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符。</li>
<li>域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用。在建立TCP连接的时候用的就是IP地址，我们可以用域名是因为有了DNS域名解析。</li>
<li>端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口，HTTP默认的端口号为80，HTTPS的端口号为443。</li>
<li>虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”。</li>
<li>文件名部分：从域名后的最后一个“/”开始到“?”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名，一般为index.html。</li>
<li>锚部分：从“#”开始到最后，都是锚部分(HTML的节点)。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分。</li>
<li>参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li>
</ol>
<h2 id="请求报文之请求方法"><a href="#请求报文之请求方法" class="headerlink" title="请求报文之请求方法"></a>请求报文之请求方法</h2><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了六种请求方法：OPTIONS, PUT, DELETE, TRACE，CONNECT和PATCH 方法。</p>
<p>这八种方法(动作)表明了请求的URL指定的资源的操作方式，分别如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>操作方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td><strong>请求</strong>指定的页面信息，并返回实体主体</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的<strong>建立</strong>和/或已有资源的<strong>修改</strong></td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据<strong>取代</strong>指定的文档的内容</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器<strong>删除</strong>指定的页面</td>
</tr>
<tr>
<td>CONNECT</td>
<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>允许客户端查看服务器的性能</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断</td>
</tr>
<tr>
<td>PATCH</td>
<td>用来将<strong>局部修改</strong>应用于某一资源</td>
</tr>
</tbody>
</table>
<p><strong>PS：</strong> GET和POST的区别：</p>
<ul>
<li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中。</li>
<li>GET提交的数据大小有限制，最多只能有1024字节（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。</li>
<li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</li>
</ul>
<h2 id="请求报文之通用首部"><a href="#请求报文之通用首部" class="headerlink" title="请求报文之通用首部"></a>请求报文之通用首部</h2><p>常见的通用首部如下：</p>
<ol>
<li>Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝；在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样。Pargma只有一个用法， 例如： Pragma: no-cache<br>注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control</li>
<li>Cache-Control：指定请求和响应遵循的缓存机制。缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程）。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public(可以被任何缓存所缓存)、private(内容只缓存到私有缓存中)、no-cache(所有内容都不会被缓存)、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage。</li>
<li>Connection：之前已经说过，主要是控制TCP连接是否在请求完马上端开。</li>
<li>Date：表示消息发送的时间。</li>
</ol>
<h2 id="请求报文之请求首部"><a href="#请求报文之请求首部" class="headerlink" title="请求报文之请求首部"></a>请求报文之请求首部</h2><p>常见的请求首部如下：</p>
<ol>
<li>If-Modified-Since：把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。</li>
<li>If-None-Match：If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag。</li>
<li>Accept：浏览器端可以接受的MIME类型。例如：Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档，如果服务器无法返回text/html类型的数据，服务器应该返回一个406错误(non acceptable)。通配符 * 代表任意类型，例如 Accept: */* 代表浏览器可以处理所有类型，(一般浏览器发给服务器都是发这个)。</li>
<li>Accept-Encoding：浏览器申明自己可接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）;Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。例如： Accept-Encoding: gzip, deflate。如果请求消息中没有设置这个域，服务器假定客户端对各种内容编码都可以接受。</li>
<li>Accept-Language：浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；例如：Accept-Language: en-us。如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。</li>
<li>Accept-Charset：浏览器可接受的字符集。如果在请求消息中没有设置这个域，缺省表示任何字符集都可以接受。</li>
<li>User-Agent：告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本</li>
<li>Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。</li>
<li>Host：（发送请求时，该头域是必需的）主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。</li>
<li>Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。</li>
<li>Range：可以请求实体的一个或者多个子范围。</li>
<li>Cookie：最重要的请求头之一, 将cookie的值发送给HTTP服务器。</li>
</ol>
<h2 id="请求报文之实体首部"><a href="#请求报文之实体首部" class="headerlink" title="请求报文之实体首部"></a>请求报文之实体首部</h2><p>常见的实体首部如下：</p>
<ol>
<li>Content-Type：说明了实体主体内对象的媒体类型。</li>
<li>Content-Length：表示请求消息正文的长度。</li>
<li>Content-Range：用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-length。</li>
<li>Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。只有在解码之后才可以得到Content-Type头指定的内容类型。</li>
<li>Content-Language：WEB服务器告诉浏览器自己响应的对象所用的自然语言。</li>
</ol>
<h2 id="请求报文之其他首部"><a href="#请求报文之其他首部" class="headerlink" title="请求报文之其他首部"></a>请求报文之其他首部</h2><ol>
<li>P3P：用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题。</li>
</ol>
<h1 id="HTTP报文之响应报文"><a href="#HTTP报文之响应报文" class="headerlink" title="HTTP报文之响应报文"></a>HTTP报文之响应报文</h1><p>响应报文由状态行(协议版本、状态码、消息状态)、响应头部、空行(回车+换行)和响应数据(主体)四个部分组成。如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/httpResponse.png" alt="httpResponse"></p>
<p>它的例子如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/httpReponseDemo.png" alt="httpReponseDemo"></p>
<p>响应报文的通用首部和实体首部以及其他首部都和请求报文差不多，我们主要讲解响应首部。</p>
<h2 id="响应报文之响应首部"><a href="#响应报文之响应首部" class="headerlink" title="响应报文之响应首部"></a>响应报文之响应首部</h2><ol>
<li>Allow：服务器支持哪些请求方法</li>
<li>Expires：指明应该在什么时候认为文档已经过期，从而不再缓存它，重新从服务器获取，会更新缓存。过期之前使用本地缓存。HTTP1.1的客户端和缓存会将非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以将Expires实体报头域，设置为0。</li>
<li>Set-Cookie：非常重要的header, 用于把cookie发送到客户端浏览器，每一个写入cookie都会生成一个Set-Cookie。</li>
<li>Last-Modified：用于指示资源的最后修改日期和时间。Last-Modified也可用setDateHeader方法来设置。</li>
<li>Server：指明HTTP服务器用来处理请求的软件信息。</li>
<li>Location：用于重定向一个新的位置，包含新的URL地址。表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。Location响应报头域常用在更换域名的时候。</li>
<li>WWW-Authenticate：该响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。</li>
</ol>
<h2 id="HTTP之状态码"><a href="#HTTP之状态码" class="headerlink" title="HTTP之状态码"></a>HTTP之状态码</h2><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx</td>
<td>指示信息–表示请求已接收，继续处理</td>
</tr>
<tr>
<td>2xx</td>
<td>成功–表示请求已被成功接收、理解、接受</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向–要完成请求必须进行更进一步的操作</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端错误–请求有语法错误或请求无法实现</td>
</tr>
<tr>
<td>5xx</td>
<td>服务器端错误–服务器未能实现合法的请求</td>
</tr>
</tbody>
</table>
<p>常用的状态码如下：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>200 OK</td>
<td>客户端请求成功</td>
</tr>
<tr>
<td>400 Bad Request</td>
<td>客户端请求有语法错误，不能被服务器所理解</td>
</tr>
<tr>
<td>401 Unauthorized</td>
<td>请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</td>
</tr>
<tr>
<td>403 Forbidden</td>
<td>服务器收到请求，但是拒绝提供服务</td>
</tr>
<tr>
<td>404 Not Found</td>
<td>请求资源不存在，eg：输入了错误的URL</td>
</tr>
<tr>
<td>500 Internal Server Error</td>
<td>服务器发生不可预期的错误</td>
</tr>
<tr>
<td>503 Server Unavailable</td>
<td>服务器当前不能处理客户端的请求，一段时间后可能恢复正常</td>
</tr>
</tbody>
</table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《图解HTTP》</li>
<li><a href="https://www.jianshu.com/p/80e25cb1d81a" target="_blank" rel="external">关于HTTP协议，一篇就够了</a></li>
<li><a href="https://www.cnblogs.com/EricaMIN1987_IT/p/3837436.html" target="_blank" rel="external">HTTP协议详解</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：作为Web开发人员，可能你最需要深入学习的就是&lt;strong&gt;HTTP协议&lt;/strong&gt;了吧！
    
    </summary>
    
      <category term="计算机网络" scheme="http://bestlixiang.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="http://bestlixiang.site/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议</title>
    <link href="http://bestlixiang.site/2018/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://bestlixiang.site/2018/05/18/计算机网络/TCP协议/</id>
    <published>2018-05-18T06:58:34.000Z</published>
    <updated>2018-05-18T07:31:18.419Z</updated>
    
    <content type="html"><![CDATA[<p>引：TCP作为传输层的一大协议，虽然没有UDP简单，但是胜在可靠。<a id="more"></a></p>
<h1 id="TCP认识"><a href="#TCP认识" class="headerlink" title="TCP认识"></a>TCP认识</h1><p><strong>TCP(传输控制协议)</strong> 是一种面向连接、可靠的、基于字节流的传输层协议。TCP在传送数据之前会先相互发送一些预备报文段协商一些参数，比如序号等等，TCP将用户数据打包成报文段，发送数据后启动一个定时器，另一端对收到的数据进行确认，对失序的数据重新排序，丢弃重复数据，TCP提供端到端的流量控制，并计算和验证一个强制性的端到端校验和。</p>
<h1 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h1><ol>
<li>TCP是面向连接的，通信前需要建立连接，通信结束需要释放连接。</li>
<li>TCP提供可靠交付服务，可靠指的是：TCP发送的数据无重复、无丢失、无错误、与发送端顺序一致。</li>
<li>TCP是面向字节流的，面向字节流指的是：TCP以字节为单位。虽然传输的过程中数据被划分成一个个数据报，但这只是为了方便传输，接收端最终接受到的数据将与发送端的数据一模一样。</li>
<li>TCP提供全双工通信，全双工通信指的是：TCP的两端既可以作为发送端，也可以作为接收端。</li>
<li>一条TCP连接的两端只能有两个端点，TCP只能提供点到点的通信，而UDP可以任意方式的通信。</li>
</ol>
<h1 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h1><p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/tcp.png" alt="tcp"></p>
<ol>
<li>16位端口号:包含源端口和目的端口，客户端通常使用系统自动选择的临时端口号，而服务器则使用自主定义端口号.</li>
<li>32位序号:一次TCP通信过程中一个传输方向上的字节流的每个字节的编号，例如:A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机值ISN，那么在该传输方向上，后续的TCP报文段中序号值将被系统设置为ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移。</li>
<li>32位的确认号: 用作对另外一方发送来的TCP报文段的响应，其值是收到的TCP报文段的序号值加1。</li>
<li>4位头部长度: 标识TCP头部有多少个32bit(4字节)，最大60字节.</li>
<li>6位标志位:<ul>
<li>URG:表示紧急指针是否有效.</li>
<li>ACK:表示确认号是否有效，我们称携带ACK标志的TCP报文段为确认报文段.</li>
<li>PSH:提示接收端应用程序应该立即从TCP接收缓冲区中读走数据,为接收数据腾出空间.</li>
<li>RST:表示要求对方重新建立连接(复位报文段)</li>
<li>SYN:表示请求建立一个连接(同步报文段);</li>
<li>FIN:表示通知对方本端要关闭连接了(结束报文段);</li>
</ul>
</li>
<li>16位窗口大小:TCP流量的一个控制手段,,它告知是对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度.</li>
<li>16位校验和:由发送端填充，接收端对TCP报文段执行CRC算法（循环冗余码检验，与UDP一样），检验TCP头部在传输过程中是否损坏，不仅包括TCP头部，也包括数据部分。</li>
<li>16位紧急指针:是一个正的偏移量.它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号.</li>
<li>选项字段，上述字段都是每个TCP头部必须要有的，而选项字段是可选的，且长度可变，最长40字节。 最常用的选项字段为MMS：最大报文长度。</li>
</ol>
<h1 id="TCP连接建立-三次握手"><a href="#TCP连接建立-三次握手" class="headerlink" title="TCP连接建立(三次握手)"></a>TCP连接建立(三次握手)</h1><p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/tcpBuild.png" alt="tcpBuild"></p>
<p>TCP协议中，主动发起请求的一端称为<strong>客户端</strong>，被动连接的一端称为<strong>服务端</strong>。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据。</p>
<ol>
<li><strong>握手前</strong>：服务器和客户端都为CLOSED状态，在通信开始前，双方都得创建各自的传输控制块（TCB）。服务器创建完TCB后遍进入LISTEN状态，此时准备接收客户端发来的连接请求。</li>
<li><strong>第一次握手</strong>：客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，(表示该报文段为连接请求报文) seq=x(x为本次TCP通信的字节流的初始序号)。请求发送后，客户端便进入SYN-SENT状态。</li>
<li><strong>第二次握手</strong> ：服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，(表示该报文段为连接同意的应答报文) seq=y，(表示服务端作为发送者时，发送字节流的初始序号) ack=x+1(表示服务端希望下一个数据报发送序号从x+1开始的字节)。<br>该应答发送完成后便进入SYN-RCVD状态。</li>
<li><strong>第三次握手</strong> ：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。<br>该报文段的头部为：ACK=1，seq=x+1，ack=y+1。<br>客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！</li>
</ol>
<p><strong>PS：为什么连接建立需要三次握手，而不是两次握手？</strong></p>
<p>防止失效的连接请求报文段被服务端接收，从而产生错误，失效的连接请求指的是：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是失效的。</p>
<p>若建立连接只需两次握手，服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，此时，如果那个失效的连接请求抵达了服务端，但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。</p>
<h1 id="TCP连接释放-四次握手"><a href="#TCP连接释放-四次握手" class="headerlink" title="TCP连接释放(四次握手)"></a>TCP连接释放(四次握手)</h1><p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/tcpRelease.png" alt="tcpRelease"><br><strong>TCP连接发送数据</strong>是双向的，因此在四次挥手中，前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一方向的连接。</p>
<ol>
<li><strong>第一次握手</strong> ：若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：FIN=1，(表示该报文段是一个连接释放请求) seq=u(u-1是A向B发送的最后一个字节的序号)。此时，A将进入FIN-WAIT-1状态。</li>
<li><strong>第二次握手</strong> ：B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含： ACK=1，(表示应答) seq=v (v-1是B向A发送的最后一个字节的序号)，ack=u+1(表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节)。A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。<strong>第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。</strong></li>
<li><strong>第三次握手</strong> ：当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。</li>
<li><strong>第四次握手</strong> ：A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL(报文最大生存时间)时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。</li>
</ol>
<h1 id="TCP的可靠传输"><a href="#TCP的可靠传输" class="headerlink" title="TCP的可靠传输"></a>TCP的可靠传输</h1><p>TCP采用了校验和、连接管理、序列号、确认应答，重发控制、滑动窗口协议（连续ARQ协议、流控制、拥塞控制）等机制来保证它的可靠性。</p>
<h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><p>TCP和UDP校验和的方式一致，可以参照另一篇博客——<a href="http://todorex.com/2018/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP%E5%8D%8F%E8%AE%AE/" target="_blank" rel="external">UDP协议</a></p>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>其实就是利用建立连接时的三次握手来提高可靠性。</p>
<h2 id="通过序列号与确认应答"><a href="#通过序列号与确认应答" class="headerlink" title="通过序列号与确认应答"></a>通过序列号与确认应答</h2><p>在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个收到消息的通知，这个消息叫做<strong>确认应答(ACK)</strong>，比如客户端发送[数据(1-1000)]，那么服务端将会回应[确认应答(下一个数1001)]。在一定时间内没有等到确认应答，发送端会认为数据已经丢失，并进行重发。</p>
<h2 id="滑动窗口协议-连续ARQ协议"><a href="#滑动窗口协议-连续ARQ协议" class="headerlink" title="滑动窗口协议(连续ARQ协议)"></a>滑动窗口协议(连续ARQ协议)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>先简单说说ARQ(Automatic Repeat reQuest)协议(自动重传请求协议)： 当请求失败时它会自动重传，直到请求被正确接收为止。这种机制保证了每个分组都能被正确接收。</p>
<p>再看连续ARQ协议：在ARQ协议发送者每次只能发送一个分组，在应答到来前必须等待。而连续ARQ协议的发送者拥有一个发送窗口，发送者可以在没有得到应答的情况下连续发送窗口中的分组。</p>
<h3 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h3><p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/sendWindow.png" alt="sendWindow"></p>
<p>发送窗口的大小由接收窗口的剩余大小决定。接收者会把当前接收窗口的剩余大小写入应答TCP报文段的头部，发送者收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小。发送窗口的大小是不断变化的。</p>
<p>发送窗口(p1-p3)由三个指针构成：</p>
<ul>
<li>p1：p1指向发送窗口的后沿，它后面的字节表示已经发送且已收到应答。</li>
<li>p2：p2指向尚未发送的第一个字节。<br>p1-p2间的字节表示已经发送，但还没收到确认应答。这部分的字节仍需保留，因为可能还要超时重发。<br>p2-p3间的字节表示可以发送，但还没有发送的字节。</li>
<li>p3：p3指向发送窗口的前沿，它前面的字节尚未发送，且不允许发送。</li>
</ul>
<p>发送者每收到一个应答，后沿就可以向前移动指定的字节。此时若窗口大小仍然没变，前沿也可以向前移动指定字节。<br>当p2和前沿重合时，发送者必须等待确认应答。</p>
<h3 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h3><p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/receiverWindow.png" alt="receiverWindow"></p>
<p>接收者收到的字节会存入接收窗口，接收者会对已经正确接收的有序字节进行累计确认，发送完确认应答后，接收窗口就可以向前移动指定字节。<br>如果某些字节并未按序收到，接收者<strong>只会</strong>确认最后一个有序的字节，从而乱序的字节就会被重新发送。</p>
<h2 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>让发送端根据接收端的实际接收能力控制发送的数据量。</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>防止接收端在高负荷的情况下接收数据，因为这个时候如果接收端会将本应该接收的数据丢弃，就又会触发重发机制，从而导致网络流量的无端浪费。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>接收端主动向发送端主机通知自己可以接受数据的大小，于是发送端会发送不超过这个限度的数据。这个大小限度就是接收窗口大小，所以流控制就是利用滑动窗口协议实现的。</p>
<h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><p>当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。为了避免此类问题的发生，发送端主机会时不时发送一个叫做窗口探测的数据段，此数据段仅含一个以获取最新窗口的大小信息。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><h3 id="拥塞控制和流控制的区别？"><a href="#拥塞控制和流控制的区别？" class="headerlink" title="拥塞控制和流控制的区别？"></a>拥塞控制和流控制的区别？</h3><ol>
<li>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况</li>
<li>流控制：流控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收</li>
</ol>
<h3 id="拥塞情况"><a href="#拥塞情况" class="headerlink" title="拥塞情况"></a>拥塞情况</h3><p>观察拥塞的方式有两种：一是超时，二是连续接收到3个重复ACK。</p>
<p><strong>PS：为什么是3个连续的ACK</strong>：由于我们不知道一个重复的ACK是由一个丢失的报文引起的，还是由于仅仅出现了几个报文段的重新排序引起的，因此我们等待少量的重复的ACK到来。因为若只是一些报文段的重新排序引起的，一般在重新排序报文段完成并产生一个新的ACK之前只可能产生1-2个重复的ACK。</p>
<h3 id="拥塞的不同处理方式"><a href="#拥塞的不同处理方式" class="headerlink" title="拥塞的不同处理方式"></a>拥塞的不同处理方式</h3><p>对于由于超时重传认为的拥塞，我们一般是重传报文段，然后进入<strong>慢启动算法</strong>(下方)；对于由于接收到3个重复的ACK认为的拥塞，我们一般是<strong>立即重传报文段</strong>，然后进入<strong>拥塞避免算法</strong>(下方)。这样处理的原因是因为当因为定时器超时，此时网络中可能已经很拥塞，数据确认的ACK已经无法发送回来，因此我们立即减少注入网络中的数据，使用慢启动拥塞窗口减小为1；而对于收到,3个重复的ACK说明还有其他的报文段到达了目的地(因为接收方只有在收到失序的报文段时才会产生重复的ACK而且还有重复的ACK发送回来)，也即收发两端还有数据的流动，因此我们不必使用慢启动突然减少注入网络的数据。</p>
<h3 id="慢启动算法-和-拥塞避免算法"><a href="#慢启动算法-和-拥塞避免算法" class="headerlink" title="慢启动算法 和 拥塞避免算法"></a>慢启动算法 和 拥塞避免算法</h3><p>发送方维护一个发送窗口，发送窗口的大小取决于网络的拥塞情况(拥塞窗口)，发送窗口是动态变化的。<br>发送方还维护一个慢启动阈值。</p>
<ul>
<li>发送窗口 &lt; 慢启动阈值：使用慢启动算法(指数级)</li>
<li>发送窗口 &gt; 慢启动阈值：使用拥塞避免算法(线性加一)</li>
<li>发送窗口 = 慢启动阈值：使用慢开始算法或拥塞避免算法</li>
</ul>
<p>算法的具体过程：</p>
<ol>
<li>通信开始时，使用慢启动算法，发送方的发送窗口设为1，并发送第一个分组M1；</li>
<li>接收方收到M1后，返回确认应答，此时发送方发送窗口扩大两倍，并发送M2、M3；（即，发送方每次收到确认应答后，都将发送窗口设为当前值的两倍）</li>
<li>若发送窗口&gt;慢启动阈值，则使用拥塞避免算法，每次收到确认应答后都将发送窗口+1；</li>
<li>若发送方出现了超时重传，则表明网络出现拥塞，此时：<ol>
<li>慢启动阈值设为当前发送窗口的一半；</li>
<li>发送窗口设为1；</li>
<li>启用拥塞避免算法；</li>
</ol>
</li>
</ol>
<p>PS：发送超时重传时，发送窗口有可能已经超过了慢开始门限，也有可能还没超过；此时不管何种情况，都一律启用拥塞避免算法，并执行上述三步操作！</p>
<p><strong>慢开始算法的作用</strong>：慢开始算法将发送窗口从小扩大，而且按指数级扩大，从而避免一开始就往网络中注入过多的分组从而导致拥塞；它将窗口慢慢扩大的过程其实也在探测网络拥塞情况的过程，当发现出现拥塞时，及时降低发送速度，从而减缓网络拥塞。</p>
<p><strong>拥塞避免算法的作用</strong>：拥塞避免算法使发送窗口以线性方式增长，而非指数级增长，从而使网络更加不容易发生拥塞。</p>
<h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p>当因收到三个及三个以上的重复ACK时，使用如下拥塞控制方法：</p>
<ol>
<li>收到3个重复的ACK，将慢启动阈值设为当前拥塞窗口大小的一半</li>
<li>此时立即重传丢失的报文不用等到定时器超时(超时重传)，此为快重传。</li>
<li>此后开始执行拥塞避免而不是慢启动，此为快恢复。</li>
</ol>
<h1 id="TCP的应用"><a href="#TCP的应用" class="headerlink" title="TCP的应用"></a>TCP的应用</h1><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用。常见的使用UDP协议的应用如下：</p>
<ul>
<li>HTTP(超文本传输协议)</li>
<li>FTP(文件传输协议)</li>
<li>POP、SMTP(邮件传输协议)</li>
<li>Telnet、Telnet(远程连接协议)</li>
<li>QQ文件传输</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/u010425776/article/details/55006347?locationNum=2&amp;fps=1" target="_blank" rel="external">计算机网络传输层知识点全覆盖</a></li>
<li><a href="https://blog.csdn.net/whoamiyang/article/details/50890801" target="_blank" rel="external">TCP协议详解—学习笔记</a></li>
<li><a href="https://blog.csdn.net/corcplusplusorjava/article/details/46954433" target="_blank" rel="external">TCP协议</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：TCP作为传输层的一大协议，虽然没有UDP简单，但是胜在可靠。
    
    </summary>
    
      <category term="计算机网络" scheme="http://bestlixiang.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="http://bestlixiang.site/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>UDP协议</title>
    <link href="http://bestlixiang.site/2018/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://bestlixiang.site/2018/05/17/计算机网络/UDP协议/</id>
    <published>2018-05-17T07:03:18.000Z</published>
    <updated>2018-05-17T07:09:07.421Z</updated>
    
    <content type="html"><![CDATA[<p>引：UDP作为传输层的一大协议，虽然没有TCP可靠，但是却胜在简单。<a id="more"></a></p>
<h1 id="UDP认识"><a href="#UDP认识" class="headerlink" title="UDP认识"></a>UDP认识</h1><p><strong>UDP(用户数据报协议)</strong> 是一种简单的面向数据报、无连接、传输层协议，并且保留了信息边界。UDP不提供错误校正，不保证有序，无法去重复，没有流量控制和拥塞控制，不能保证数据一定到达目的地，但是可以通过校验和提供错误侦测。UDP提供的的是不可靠传输，<strong>因此要有应用层来提供这些功能</strong>。</p>
<h1 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h1><ol>
<li>UDP只在IP数据报服务的基础上增加了少量的功能：利用端口号是实现分用、对整个报文的差错检测。</li>
<li>UDP是无连接的，通信前不需要建立连接，通信结束也无需释放连接。</li>
<li>UDP是不可靠的 它是<strong>尽力而为</strong>交付，不能确保每一个数据报都送达。</li>
<li>UDP是<strong>面向报文</strong>的，面向报文就是指：UDP数据传输的单位是报文，且不会对数据作任何拆分和拼接 操作。在发送端，应用程序给传输层的UDP什么样的数据，UDP不会对数据进行切分，只增加一个UDP头并交给网络层。在接收端，UDP收到网络层的数据报后，去除IP数据报头部后遍交给应用层，不会作任何拼接操作。</li>
<li>相比于TCP，UDP没有拥塞控制，UDP始终以恒定的速率发送数据，并不会根据网络拥塞情况对发送速率作调整。这种方式有利有弊。弊端：网络拥塞时有些报文可能会丢失，因此UDP不可靠。优点：有些使用场景允许报文丢失，如：直播、语音通话，但对实时性要求很高，此时UDP还是很有用武之地的。</li>
<li>UDP支持一对一、一对多、多对多、多对一通信；而TCP只支持一对一通信。</li>
<li>UDP首部开销小，只有8字节。而TCP头部至少由20字节，相比于TCP要高效很多。</li>
</ol>
<h1 id="UDP数据包首部"><a href="#UDP数据包首部" class="headerlink" title="UDP数据包首部"></a>UDP数据包首部</h1><p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/udp.png" alt="udp"></p>
<h2 id="UDP数据包首部解析"><a href="#UDP数据包首部解析" class="headerlink" title="UDP数据包首部解析"></a>UDP数据包首部解析</h2><ol>
<li>16位源端口号：发送端应用程序使用的端口号，用于区分数据报来自哪个进程，多路复用一个传输层（复用：在发送端，多个应用进程公用一个传输层）。</li>
<li>16位目的端口号：数据送往接收端哪个应用程序，利用端口号实现多路分用（分用：在接收端，传输层会根据端口号将数据分派给不同的应用进程）。</li>
<li>16位UDP长度：UDP数据报首部和UDP数据报数据部分总字节数，最小值为8字节(仅有首部)，最大值为65535字节。</li>
<li>16位UDP检验和：UDP的校验和是可选的，TCP是必需的。UDP的校验和覆盖首部及数据部分。在下一节。</li>
<li>数据：要发送的数据，可以为空(0字节)。</li>
</ol>
<h2 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h2><p>UDP校验和的内容超出了UDP数据报文本身的范围，实际上，它的值是通过计算UDP数据报及一个伪包头而得到的。校验和的计算方法与通用的一样，都是累加求和。<br>它的校验和的检验范围如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/checksum.png" alt="checksum"></p>
<p>伪首部并非UDP数据报中实际的有效成分。伪首部是一个虚拟的数据结构，其中的信息是从数据报所在IP分组头的分组头中提取的，既不向下传送也不向上递交，而仅仅是为计算校验和。这样的校验和，既校验了UDP用户数据的源端口号和目的端口号以及UDP用户数据报的数据部分，又检验了IP数据报的源IP地址和目的IP<br>地址。<strong>伪报头保证UDP数据单元到达正确的目的地址</strong>。</p>
<p>校验方式：</p>
<ol>
<li><p>《TCP/IP 详解》卷一 第一版中如下计算检验和字段的值：</p>
<ul>
<li>发送方计算UDP检验和：<br>首先把检验和字段置为0，把上图中,各部分数据(包括UDP伪首部及填充字段)按每16bit进行二进制反码求和(若最高位产生进位就加到最低位上去)，所求结果就是16bitUDP检验和字段的值。</li>
<li>接收方计算UDP检验和：<br>对收到的UDP数据报(加上了UDP首部和填充字节)按每16bit进行二进制反码求和(若最高位产生进位就加到最低位上去)，若结果为全1，则UDP数据报在传输过程中没有出现差错，否则数据报有差错。</li>
</ul>
</li>
<li>《TCP/IP 详解》卷一 第二版中如下计算检验和字段的值：<ul>
<li>发送方计算UDP检验和：<br>首先把检验和字段置为0，把上图中,各部分数据(包括UDP伪首部及填充字段)按每16bit进行二进制反码求和(若最高位产生进位就加到最低位上去)，最后结果再按位取反，所得结果就是16bitUDP检验和字段的值。</li>
<li>接收方计算UDP检验和：<br>对收到的UDP数据报(加上了UDP首部和填充字节)按每16bit进行二进制反码求和(若最高位产生进位就加到最低位上去)，再按位取反，若结果为全0，则UDP数据报在传输过程中没有出现差错，否则数据报有差错。<strong>因为检验和的值从不为0xFFFF</strong></li>
</ul>
</li>
</ol>
<h1 id="UDP服务器三类地址绑定"><a href="#UDP服务器三类地址绑定" class="headerlink" title="UDP服务器三类地址绑定"></a>UDP服务器三类地址绑定</h1><table>
<thead>
<tr>
<th>本地地址</th>
<th>远端地址</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>LocalIP:Lport</td>
<td>ForeignIP:Fport</td>
<td>只限于一个客户</td>
</tr>
<tr>
<td>LocalIP:Lport</td>
<td>*:*</td>
<td>只限于一个本地IP和端口的数据包</td>
</tr>
<tr>
<td>*:port</td>
<td>*:*</td>
<td>接收发送到Lport的所有数据包</td>
</tr>
</tbody>
</table>
<ol>
<li>第一行中服务器限定了只从本地Local这个IP地址的Lport端口接收数据报，而且只接收来自IP为Foreign且端口为Fport发来的数据。</li>
<li>第二行中服务器限定了只从本地LocalIP这个IP地址的Lport端口接收数据报，但可以接收任何主机发送的数据。</li>
<li>第三行中服务器只限定了接收数据的端口号，因此任何一个本地接口IP都可以接收它，而且数据可以来自任何主机发送的数据。</li>
</ol>
<h1 id="UDP的应用"><a href="#UDP的应用" class="headerlink" title="UDP的应用"></a>UDP的应用</h1><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。常见的使用UDP协议的应用如下：</p>
<ul>
<li>QQ语言和视频</li>
<li>DNS(域名服务器)</li>
<li>NFS(网络文件系统)</li>
<li>TFTP(普通文件传输协议)</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/CorCplusplusorjava/article/details/47164875" target="_blank" rel="external">UDP协议</a></li>
<li><a href="https://blog.csdn.net/sinat_30270011/article/details/51980160" target="_blank" rel="external">UDP协议的应用</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：UDP作为传输层的一大协议，虽然没有TCP可靠，但是却胜在简单。
    
    </summary>
    
      <category term="计算机网络" scheme="http://bestlixiang.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="UDP" scheme="http://bestlixiang.site/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务</title>
    <link href="http://bestlixiang.site/2018/05/11/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <id>http://bestlixiang.site/2018/05/11/数据库/数据库事务/</id>
    <published>2018-05-11T07:10:33.000Z</published>
    <updated>2018-05-11T07:17:04.678Z</updated>
    
    <content type="html"><![CDATA[<p>引：数据库事务在数据库操作中是十分重要的，因为它要么全部执行，要么全部执行，这样才能保证数据库的数据的完整性与一致性。<a id="more"></a></p>
<h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><p>构成单一逻辑工作单元的操作集合。</p>
<p>事务是访问并可能更新各种数据项的一个程序执行单元，事务通常用形如begin transaction 和 end transaction来界定，事务由它们之间执行的全体操作组成。</p>
<p><strong>举个例子</strong>：将钱从一个账户转到另一个账户就是一个事务，该事务包括分别对两个账户的更新。</p>
<h1 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h1><ol>
<li>原子性（Atomicity）：事务是一个不可分割的操作，要么全都正确执行，要么全都不执行。</li>
<li>一致性（Consistency）：事务开始前和事务结束后，数据库的完整性约束没有被破坏。比如上面转账例子中，两个账户的总金额就是完整性约束，因为他们的总金额是不变的。但是在并发事务中，一致性很容易被破坏，需要我们特别注意。</li>
<li>隔离性（Isolation）：事务的执行是相互独立的，它们不会相互干扰，一个事务不会看到另一个正在运行过程中的事务的数据。</li>
<li>持久性（Durability）：事务结束后，事务的结果必须是永久保存的。即使数据库发生崩溃，在数据库恢复后事务提交的结果仍然不会丢失。</li>
</ol>
<p>确保隔离性有可能对系统性能造成较大的不利影响，由于这个原因，一些应用在隔离性上采取一些妥协。</p>
<h1 id="事务的分类"><a href="#事务的分类" class="headerlink" title="事务的分类"></a>事务的分类</h1><ol>
<li>扁平事务(Flat Transactions)：它是实际生产环境中最常用、最简单的事务类型。在扁平事务中，所有操作都处于同一层次，其由begin transaction开始，commit或rollback结束，其间的操作是原子的，要么都执行，要么都回滚，因此扁平事务是应用程序称为原子操作的的基本组成模块。但是发生错误时都需要回滚到事务的起始位置，无法回滚部分操作，所以回滚开销太大。</li>
<li>带有保存点的扁平事务(Flat Transactions with Savepoints)： 除了支持扁平事务支持的操作外，允许在事务执行过程中回滚同一事务中较早的一个状态。这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销太大，保存点用来通知事务系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。</li>
<li>链事务(Chained Transactions)：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务，提交事务操作和开始下一个事务操作 将合并为一个原子操作，这意味着下一个事务将看到上一个事务的结果，就好像一个事务中进行的一样。和带有保存点的扁平事务不同的是，带有保存点的扁平事务能回滚到任意正确的保存点，而链事务中的回滚仅限当前事务，即只能恢复到最近的一个保存点。</li>
<li><p>嵌套事务(Nested Transactions)：由一个顶层事务(top-level transaction)控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务。嵌套事务是由若干事务组成的一棵树，子树既可以是嵌套事务也可以是扁平事务，处在叶节点的事务是扁平事务，但是每个事务从根到叶节点的距离可以说是不同的。子事务既可以提交也可以回滚。但是它的提交操作并不马上生效。除非其父事务已经提交。树中的任意事务回滚会引起它的所有子事务一同回滚，故子事务仅保留ACI特性而不具有D特性。</p>
</li>
<li><p>分布式事务(Distributed Transactions)：通常是一个分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。</p>
</li>
</ol>
<h1 id="数据库并发访问会出现的问题"><a href="#数据库并发访问会出现的问题" class="headerlink" title="数据库并发访问会出现的问题"></a>数据库并发访问会出现的问题</h1><h2 id="读问题"><a href="#读问题" class="headerlink" title="读问题"></a>读问题</h2><ol>
<li>脏读：A事务读取B事务尚未提交的更改数据，并在这个数据的基础上进行操作，这时候如果事务B回滚，那么A事务读到的数据是不被承认的。</li>
<li>虚度（不可重复读）：A事务读取了B事务已经提交的<strong>更改数据</strong>。假如A在取款事务的过程中，B往该账户转账100，A两次读取的余额发生不一致。防止读到更改数据，需要对操作的数据添加行级锁。</li>
<li>幻读：A事务读取B事务提交的<strong>新增数据</strong>。例如银行系统在同一个事务中两次统计存款账户的总金额，在两次统计中，刚好新增了一个存款账户，存入了100，这时候两次统计的总金额不一致。 防止读到新增数据，需要对操作的数据添加表级锁。</li>
</ol>
<h2 id="更新问题"><a href="#更新问题" class="headerlink" title="更新问题"></a>更新问题</h2><ol>
<li>第一类丢失更新：A事务撤销时，把已经提交的B事务的更新数据覆盖了。</li>
<li>第二类丢失更新：A事务覆盖B事务已经提交的数据，造成B事务所做的操作丢失。</li>
</ol>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>为了解决上述问题，数据库通过多种<strong>并发控制机制</strong>（常用的有两阶段封锁和快照隔离）解决并发访问的问题。但是直接使用并发控制机制是很复杂的，数据库给用户提供了不同的<strong>事务隔离级别</strong>，只要设置了事务隔离级别，数据库就会分析事务中的sql语句然后自动选择合适的并发控制机制。</p>
<p>四种隔离级别如下：</p>
<ol>
<li>可串行化(SERIALIZABLE)：保证可串行化调度，不允许出现任何问题。</li>
<li>可重复读(REPEATABLE READ) ：只允许读取已提交的数据，而且在一个事务两次读取一个数据项期间，其他事务不能更新该数，单不要求该事务与其他事务可串行化。</li>
<li>已提交读(READ COMMITTED)：只允许读取已提交的数据，但不要求可重复读。</li>
<li>未提交读(READ UNCOMMITTED)：允许读取未提交的数据，这是SQL允许的最低一致性级别。</li>
</ol>
<p>不同的隔离级别对并发问题的解决情况如下图：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>虚读</th>
<th>幻读</th>
<th>第一列丢值更新</th>
<th>第二类丢失更新</th>
</tr>
</thead>
<tbody>
<tr>
<td>可串行化(SERIALIZABLE)</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
<tr>
<td>可重复读(REPEATABLE READ)</td>
<td>不允许</td>
<td>不允许</td>
<td>允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
<tr>
<td>已提交读(READ COMMITTED)</td>
<td>不允许</td>
<td>允许</td>
<td>允许</td>
<td>不允许</td>
<td>允许</td>
</tr>
<tr>
<td>未提交读(READ UNCOMMITTED)</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
<td>不允许</td>
<td>允许</td>
</tr>
</tbody>
</table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《数据库系统概念》</li>
<li><a href="https://blog.csdn.net/u010425776/article/details/60968283" target="_blank" rel="external">数据库事务详解</a></li>
<li><a href="https://blog.csdn.net/starlh35/article/details/76445267" target="_blank" rel="external">数据库并发事务存在的问题（脏读、不可重复读、幻读等）</a></li>
<li><a href="http://ihenu.iteye.com/blog/2276576" target="_blank" rel="external">数据库的事务与并发控制</a></li>
<li><a href="http://blog.itpub.net/26736162/viewspace-2144050" target="_blank" rel="external">MySQL中事务的分类</a></li>
<li><a href="https://www.cnblogs.com/wajika/p/6680200.html" target="_blank" rel="external">数据库隔离级别及其实现原理</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：数据库事务在数据库操作中是十分重要的，因为它要么全部执行，要么全部执行，这样才能保证数据库的数据的完整性与一致性。
    
    </summary>
    
      <category term="数据库" scheme="http://bestlixiang.site/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://bestlixiang.site/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库范式</title>
    <link href="http://bestlixiang.site/2018/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/05/10/数据库/数据库范式/</id>
    <published>2018-05-10T13:13:04.000Z</published>
    <updated>2018-05-10T13:13:22.509Z</updated>
    
    <content type="html"><![CDATA[<p>引：设计好数据库的表的前提就是要满足更高级别数据库的范式，当然级别不是越高越好，但是至少不差！<a id="more"></a></p>
<h1 id="数据库范式的优缺点"><a href="#数据库范式的优缺点" class="headerlink" title="数据库范式的优缺点"></a>数据库范式的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>减少数据冗余</li>
<li>消除异常（插入异常，更新异常，删除异常）</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>查询时要联结多个表，增加了查询的复杂度</li>
<li>查询时需要联结多个表，降低了数据库查询性能</li>
</ol>
<h1 id="什么是范式-NF-Normal-Form"><a href="#什么是范式-NF-Normal-Form" class="headerlink" title="什么是范式(NF Normal Form)"></a>什么是范式(NF Normal Form)</h1><p><strong>范式</strong>是一张数据表的表结构所符合的某种<strong>设计标准</strong>，满足高等级的范式的先决条件是满足低等级范式。</p>
<h1 id="五大范式"><a href="#五大范式" class="headerlink" title="五大范式"></a>五大范式</h1><p>以下范式的基本概念可以参照我的另一篇博文：<a href="http://todorex.com/2018/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" target="_blank" rel="external">关系型数据库的基础概念</a>；具体案例可以参照这篇博文：<a href="http://www.cnblogs.com/CareySon/archive/2010/02/16/1668803.html" target="_blank" rel="external">数据库范式那些事</a></p>
<h2 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h2><ol>
<li>如果一个关系模式R的所有属性都是<strong>不可分</strong>的基本数据项，则R∈1NF</li>
<li>第一范式就是每一个属性都不可再分。不符合第一范式则“不能”称为关系数据库，因为你可以一张表搞定所有，而不用产生关系。</li>
</ol>
<h2 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h2><ol>
<li>若关系模式R∈1NF，并且每一个非主属性都<strong>完全函数</strong>依赖于R的码，则R∈2NF</li>
<li>表中的属性必须完全依赖于全部主键，而不是部分主键。所以只有一个主键的表如果符合第一范式，那一定是第二范式</li>
<li>减少数据容冗余和减少更新异常</li>
</ol>
<h2 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h2><ol>
<li>若关系模式R∈2NF，并且每一个非主属性对于码都<strong>不存在传递函数依赖</strong>，则R∈3NF</li>
<li>消除了非主属性对于码的传递函数依赖</li>
<li>减少数据容冗余和减少常插入异常，更新异常，删除异常</li>
</ol>
<h2 id="巴斯-科德范式（BCNF）"><a href="#巴斯-科德范式（BCNF）" class="headerlink" title="巴斯-科德范式（BCNF）"></a>巴斯-科德范式（BCNF）</h2><ol>
<li>若关系模式R∈3NF，并且每一个主属性对于码都<strong>不存在部分与传递函数依赖</strong>，则R∈BCNF</li>
<li>消除主属性对于码的部分与传递函数依赖，BCNF是在第三范式的基础上的一种特殊情况，既每个表中只有一个候选键。</li>
<li>减少插入异常，更新异常与删除异常</li>
</ol>
<h2 id="第四范式（4NF）"><a href="#第四范式（4NF）" class="headerlink" title="第四范式（4NF）"></a>第四范式（4NF）</h2><ol>
<li>若关系模式R∈1NF，并且只允许的非平凡多值依赖是函数依赖，不允许存在其他非平凡且非函数依赖的多值依赖，则R∈4NF。</li>
<li>平凡的多值依赖属于第四范式</li>
<li>减少数据容冗余和减少常插入异常，更新异常，删除异常</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>数据库设计应用的范式不是越高越好，要看实际情况而定。第三范式已经很大程度上减少了数据冗余，并且减少了造成插入异常，更新异常，和删除异常了。大多数情况应用到第三范式已经足够，在一定情况下第二范式也是可以的。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.zhihu.com/question/24696366" target="_blank" rel="external">解释一下关系数据库的第一第二第三范式</a></li>
<li><a href="http://www.cnblogs.com/CareySon/archive/2010/02/16/1668803.html" target="_blank" rel="external">数据库范式那些事</a></li>
<li><a href="https://blog.csdn.net/legendaryhaha/article/details/80032808" target="_blank" rel="external">数据库中的范式和多值依赖</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：设计好数据库的表的前提就是要满足更高级别数据库的范式，当然级别不是越高越好，但是至少不差！
    
    </summary>
    
      <category term="数据库" scheme="http://bestlixiang.site/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://bestlixiang.site/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>关系型数据库的基础概念</title>
    <link href="http://bestlixiang.site/2018/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://bestlixiang.site/2018/05/10/数据库/关系型数据库的基础概念/</id>
    <published>2018-05-10T12:51:51.000Z</published>
    <updated>2018-05-10T12:52:55.746Z</updated>
    
    <content type="html"><![CDATA[<p>引：在学习或者设计关系型数据库之前，我们都需要先学习关系型数据库的基础概念。<a id="more"></a></p>
<h1 id="数据库关系模型"><a href="#数据库关系模型" class="headerlink" title="数据库关系模型"></a>数据库关系模型</h1><h2 id="数据库结构"><a href="#数据库结构" class="headerlink" title="数据库结构"></a>数据库结构</h2><ol>
<li>关系数据库由<strong>表</strong>的集合构成，每个表有唯一的名字。</li>
<li>在关系模型的术语中，<strong>关系</strong>用来指代表，<strong>元组</strong>用来指代行 ，<strong>属性</strong>用来指代表中的列，<strong>关系实例</strong>用来指代一个关系的特定实例。</li>
<li>对于关系的每个属性，都存在一个允许取值的集合，称为该属性的<strong>域</strong>。</li>
<li>如果<strong>域</strong>中的元素被看做是不可再分的单元，则域是<strong>原子的</strong>。</li>
</ol>
<h2 id="数据库模式"><a href="#数据库模式" class="headerlink" title="数据库模式"></a>数据库模式</h2><ol>
<li><strong>数据库模式</strong>是数据库的逻辑设计，<strong>数据库实例</strong>是给定时刻数据库数据的一个快照。</li>
<li><strong>关系</strong>对应于程序设计语言中变量的定义，<strong>关系模式</strong>对应于程序设计语言中类型的定义，<strong>关系实例</strong>对应于程序设计语言中变量的值。</li>
<li><strong>关系模式</strong>由属性序列及各属性对应的域组成。</li>
</ol>
<h2 id="码"><a href="#码" class="headerlink" title="码"></a>码</h2><ol>
<li><strong>超码</strong>是一个或多个属性的<strong>集合</strong>，这些属性的集合可以使我们在一个关系中唯一地表示一个元组。</li>
<li>如果K是一个超码，那么K的任意超集也是超码，他们的任意真子集都不能称为超码，这样最小的超码称为<strong>候选码</strong>(码),候选码中任何一个属性称为主属性，其它为非主属性。</li>
<li><strong>主码</strong>代表被数据库设计者用来在一个关系汇总区分不同元组的候选码，主码应该选择那些值从不或极少变化的属性。</li>
<li>一个关系模式(r1)可能在它的属性中包含另一个关系模式(r2)的主码，那么这个属性在r1上称做参照r2的<strong>外码</strong>。关系r1被称为外码依赖的<strong>参照关系</strong>，r2被称为外码的<strong>被参照关系</strong>。</li>
</ol>
<h1 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h1><p>若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y<strong>函数依赖</strong>于X，写作 X → Y。</p>
<ol>
<li><p>完全函数依赖</p>
<p> 在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X → Y 不成立，那么我们称 Y 对于 X 完全函数依赖，记作 X F→ Y。（那个F应该写在箭头的正上方）</p>
</li>
<li><p>部分函数依赖</p>
<p> 假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 X  P→ Y。（那个P应该写在箭头的正上方）</p>
</li>
<li><p>传递函数依赖</p>
<p> 在 Y 不包含于 X，且 X 不函数依赖于 Y这个前提下，假如 Z 函数依赖于 Y，且 Y 函数依赖于 X ，那么我们就称 Z 传递函数依赖于 X ，记作 X T→ Z。（那个T应该写在箭头的正上方）</p>
</li>
</ol>
<h1 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h1><p>若在一张表中，在属性集X, Y, 和Z是U的子集，并且Z=U-X-Y，当且仅当表中的记录上当X，Z确定时，属性Y有一组值，这组值仅仅决定于属性X值而与属性Z值无关，<strong>多值依赖</strong>X-&gt;-&gt;Y成立。如果把上面的一组改为一个，那么多值依赖就变成了函数依赖。当然一个值组成的组也是组，所以说，函数依赖是多值依赖的特殊情况。</p>
<ol>
<li><p>平凡的多值依赖</p>
<p> 若X-&gt;-&gt;Y，而Z等于空集，则称X-&gt;-&gt;Y为平凡的多值依赖，属性集合中分为两个真子集，每一个X对应一组Y的取值</p>
</li>
<li><p>非平凡的多值依赖</p>
<p> 若X-&gt;-&gt;Y，而Z不等于空集，则称X-&gt;-&gt;Y为非平凡的多值依赖</p>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《数据库系统概念》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在学习或者设计关系型数据库之前，我们都需要先学习关系型数据库的基础概念。
    
    </summary>
    
      <category term="数据库" scheme="http://bestlixiang.site/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://bestlixiang.site/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL必知必会</title>
    <link href="http://bestlixiang.site/2018/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    <id>http://bestlixiang.site/2018/05/07/数据库/MySQL必知必会/</id>
    <published>2018-05-07T07:46:56.000Z</published>
    <updated>2018-05-07T11:29:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>引:虽然用了这么久的数据库，但是有时候使用起来难免会去查怎么使用，这样下去也不是办法，所以自己就在这里以Mysql为例总结一下经常用到的地方。 <a id="more"></a></p>
<h1 id="基本注意点"><a href="#基本注意点" class="headerlink" title="基本注意点"></a>基本注意点</h1><ol>
<li>SQL关键字使用大写，所有列和表名使用小写</li>
<li>SQL语句由子句构成，一个子句通常由一个关键字和一个数据组成，子句的顺序一般为:<blockquote>
<p>SELECT 数据 FROM 数据 WHERE 数据 GROUP BY 数据 HAVING 数据 ORDER BY 数据 LIMIT 数据</p>
</blockquote>
</li>
<li>通配符搜索的处理一般要比其他搜索所花时间长，不要过度使用通配符，如果要，就应该将通配符放在搜索集合小的搜索上</li>
<li>多数DBMS使 +或||来实现拼接，MYSQL则使 Concat函数来实现</li>
<li>数据库列般称为列，计算字段一般称为字段</li>
<li>MySQL使用的日期格式必须是yyyy-mm-dd</li>
<li>WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤</li>
<li>子查询最常见的使用是在WHERE子句的IN操作符后</li>
<li>在删除或更新表之前先SELECT出来，防止删错</li>
<li>利用外键约束，防止删除与其他表相关联的行</li>
</ol>
<h1 id="MySQL基本使用"><a href="#MySQL基本使用" class="headerlink" title="MySQL基本使用"></a>MySQL基本使用</h1><ol>
<li>MySQL帮助<blockquote>
<p>相关命令 -h/–help</p>
</blockquote>
</li>
<li>MySQL服务启动和关闭<blockquote>
<p>mysql.server start/stop</p>
</blockquote>
</li>
<li><p>MySQL连接</p>
<blockquote>
<p>mysql -u 用户名 -p 密码 -h 主机名 -P 端口  </p>
</blockquote>
<p> （默认用户名为使用者名，主机名默认为localhost，端口默认为3306）    </p>
</li>
<li>退出命令行<blockquote>
<p>quit/exit</p>
</blockquote>
</li>
<li>显示所有数据库<blockquote>
<p>SHOW DATABASES</p>
</blockquote>
</li>
<li>使用数据库<blockquote>
<p>USE 数据库名</p>
</blockquote>
</li>
<li>显示某库下所有的表<blockquote>
<p>SHOW TABLES</p>
</blockquote>
</li>
<li>显示某表下面的列<blockquote>
<p>SHOW COLUMNS FROM 表名 / DISCRIBE 表名</p>
</blockquote>
</li>
<li>显示服务器的状态信息<blockquote>
<p>SHOW STATUS</p>
</blockquote>
</li>
<li>显示创建特定数据库或表的MySQL语句<blockquote>
<p>SHOW CREATE DATABASE 数据库名 / TABLE 表名</p>
</blockquote>
</li>
</ol>
<h1 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h1><ol>
<li><p>用户管理</p>
<blockquote>
<p>USE mysql</p>
<p>SELECT user FROM user</p>
<p>CREATE USER rex IDENTIFIED BY ‘密码’  //创建用户账号</p>
<p>RENAME USER rex TO rex1  // 修改用户名</p>
<p>DROP USER rex  // 删除用户账号</p>
<p>SHOW GRANTS FOR rex  // 显示rex的权限，USAGE ON <em>.</em>表示没有权限</p>
<p>GRANT SELECT ON 数据库/表.* TO rex // 给rex对数据库/表的读权限</p>
<p>REVOKE SELECT ON 数据库/表.* TO rex // 撤销rex对数据库/表的读权限</p>
</blockquote>
</li>
<li><p>更改密码</p>
<blockquote>
<p>SET PASSWORD FOR rex = Password ‘新密码’</p>
<p>SET PASSWORD = Password ‘新密码’  // 修改当前用户的密码</p>
</blockquote>
</li>
</ol>
<h1 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h1><ol>
<li>数据库备份<ul>
<li>使用mysqldump</li>
<li>使用mysqlhotcopy</li>
<li>使用BACKUP TABLE或SELECT INTO OUTFILE</li>
</ul>
</li>
<li><p>维护数据库</p>
<blockquote>
<p>ANALYZE/CHECK TABLE 表名 // 检查表键是否正确</p>
<p>OPTIMIZE TABLE 表名 // 回收所用空间  </p>
</blockquote>
</li>
<li>查看日志文件<ul>
<li>错误日志：通常为/data/hostname.err，可通过–log-error修改文件</li>
<li>查询日志：通常为/data/hostname.log，可通过–log修改文件   </li>
<li>二进制文件：通常为/data/hostname-bin</li>
<li>缓慢查询日志：通常为/data/hostname-slow.log，可通过hostname-slow- queries修改文件  </li>
</ul>
</li>
</ol>
<h1 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h1><ol>
<li>创建表<blockquote>
<p>CREATE IF NOT EXISTS TABLE 表名(id int NOT NULL AUTO_INCREMENT          ,…, PRIMARY KEY(id)) ENGINE=InnoDB</p>
</blockquote>
</li>
<li><p>更新表</p>
<blockquote>
<p>ALTER TABLE 表名 ADD 类型 // 增加列</p>
<p>ALTER TABLE  表1 ADD CONSTRAINT fk<em>表1</em>表2 FOREIGN KEY(表2id)  REFERENCES  表2(表2id)</p>
</blockquote>
</li>
<li><p>删除表</p>
<blockquote>
<p>DROP TABLE 表名</p>
</blockquote>
</li>
<li>重命名表<blockquote>
<p>RENAME TABLE 表名1 TO 表名2</p>
</blockquote>
</li>
</ol>
<h1 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h1><h2 id="基本查询数据"><a href="#基本查询数据" class="headerlink" title="基本查询数据"></a>基本查询数据</h2><ol>
<li>检索单个列<blockquote>
<p>SELECT prod_name FROM product</p>
</blockquote>
</li>
<li>检索多个列<blockquote>
<p>SELECT prod_id, prod_name FROM product</p>
</blockquote>
</li>
<li>检索所有列<blockquote>
<p>SELECT * FROM product</p>
</blockquote>
</li>
<li>检索不同的行<blockquote>
<p>SELECT DISTINCT vend_id FROM product</p>
</blockquote>
</li>
<li><p>限制结果的行数为前5条/第二个5条</p>
<blockquote>
<p>SELECT * FROM product LIMIT 5 / LIMIT 5(开始位置，第一行其实第0    行),5(要检索的行数)</p>
<p>SELECT * FROM product LIMIT 5 (偏移量) OFFSET 5 (开始位置)      </p>
</blockquote>
</li>
</ol>
<h2 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h2><ol>
<li>按一个列排序<blockquote>
<p>SELECT prod_name FROM product ORDER BY prod_name</p>
</blockquote>
</li>
<li>按多个列排序(先按prod_price排序，如果相同，则比较prod_name)<blockquote>
<p>SELECT prod_id, prod_price, prod_name FROM product ORDER BY prod_price, prod_name</p>
</blockquote>
</li>
<li>指定排序方向(默认升序ASC，降序DESC)<blockquote>
<p>SELECT prod_id, prod_price, prod_name FROM product ORDER BY prod_price DESC</p>
</blockquote>
</li>
</ol>
<h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><ol>
<li>WHERE子句过滤<blockquote>
<p>SELECT prod_name, prod_price FROM product WHERE prod_price =<br> 2.50</p>
</blockquote>
</li>
<li><p>WHERE子句操作符</p>
<p>操作符 | 说明<br>—|—<br>= | 等于<br>&lt;&gt; | 不等于<br>!= | 不等于<br>&lt; | 小于<br>&lt;= | 小于等于<br>> | 大于<br>>= | 大于等于<br>BETWEEN… AND | 在指定的两个值之间(mysql包括两端)<br>NOT BETWEEN… AND | 不在指定的两个值之间(mysql不包括两端)      </p>
</li>
<li>空值检查(需要注意null和没有值得区别)<blockquote>
<p>SELECT prod_name FROM products WHERE prod_price IS NULL</p>
</blockquote>
</li>
<li>数据过滤操作符<br> 操作符 | 说明<br> —|—<br> AND | 且（优先级比OR高）<br> OR | 或<br> IN | 在指定范围内，如WHERE id IN  (1002 1003)<br> NOT IN | 不在指定范围内</li>
<li>数据过滤通配符(利用LIKE操作符)<br> 操作符 | 说明<br> —|—<br> % | 表示任意字符出现的任意次数<br> _ | 表示单个字符</li>
<li>用正则表达式进行搜索(正则表达式的使用自行搜索)<blockquote>
<p>SELECT * FROM product WHERE prod_name REGEXP ‘.000’ OR<br> prod_name REGEXP ‘1000|2000’ OR prod_name REGEXP ‘[123]  Ton’</p>
</blockquote>
</li>
</ol>
<h2 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h2><p>计算字符是运行时在SELECT语句内创建的。</p>
<ol>
<li>拼接字段(Concat函数)<blockquote>
<p>SELECT Concat(vend_name,’(‘,vend_country,’)’) FROM vendors</p>
</blockquote>
</li>
<li>使用别名(列名，表名都可以使用，使用关键字AS，也可省略)<blockquote>
<p>SELECT Concat(RTrim(vend_name),’(‘, RTrim(vend_country),’)’)  AS vend_title FROM vendors</p>
</blockquote>
</li>
<li>执行算术计算(加减乘除)<blockquote>
<p>SELECT quantity*item_price AS expanded_price FROM orderitems</p>
</blockquote>
</li>
</ol>
<h2 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h2><ol>
<li>文本处理函数<br>函数 | 说明<br>—|—<br>Left() | 返回串左边的字符<br>Right() | 返回串右边的字符<br>Length() | 返回串的长度<br>Locate() | 找出一个串的子串<br>Lower() | 将串转化为小写<br>Upper() | 将串转化为大写<br>LRrim() | 去掉串左边的空格<br>RTrim() | 去掉串右边的空格<br>Trim() | 去掉串两边的空格<br>SubString() | 返回子串的字符  </li>
<li><p>日期和时间处理函数<br> 函数 | 说明<br> —|—<br> AddDate() | 增加一个日期(天、周等)<br> AddTime() | 增加一个时间(时、分等)<br> CurDate() | 返回当前的日期<br> CurTime() | 返回当前的时间<br> Date() | 返回日期时间的日期部分<br> DateDiff() | 计算两个日期之差<br> Date_Format() | 返回一个格式化的日期或时间串<br> Day() | 返回一个日期的天数部分，类推年月日，时分秒<br> Now() | 返回当前日期和时间  </p>
</li>
<li><p>数值处理函数<br> 函数 | 说明<br> —|—<br> Abs() | 返回一个数的绝对值<br> Cos() | 返回一个角度的余弦，类推正弦<br> Exp() | 返回一个数的指数值<br> Mod() | 返回除数操作的余数<br> Rand() | 返回一个随机数<br> Sqrt() | 返回一个数的平方根</p>
</li>
</ol>
<h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><ol>
<li><p>聚集函数</p>
<p> 函数 | 说明<br> —|—<br> AVG() | 返回某列的平均值<br> COUNT() | 返回某列的行数<br> MAX() | 返回某列的最大值<br> MIN() | 返回某列的最小值<br> SUM() | 返回某列的总和</p>
</li>
</ol>
<h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><ol>
<li>创建分组(先分组后聚集)<blockquote>
<p>SELECT vend_id  COUNT(*) AS num_prods FROM product GROUP BY vend_id</p>
</blockquote>
</li>
<li>过滤分组<blockquote>
<p>SELECT cust_id  COUNT(<em>) AS orders FROM order GROUP BY cust_id HAVING COUNT(</em>)&gt;=2</p>
</blockquote>
</li>
</ol>
<h2 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h2><ol>
<li>利用子查询进行过滤(找出买TNT2的顾客信息)<blockquote>
<p>SELECT cust_name, cust_contact FROM customers WHERE cust_id IN  (SELECT cust_id FROM order WHERE order_num IN (SELECT order_num FROM orderitem WHERE prod_id=’TNT2’))</p>
</blockquote>
</li>
<li>使用计算字段使用子查询(显示顾客的信息和订单量)<blockquote>
<p>SELECT cust_name, cust_state, (SELECT COUNT (*)  FROM order WHERE order.cust_id = customer.cust_id)  AS orders FROM customer</p>
</blockquote>
</li>
</ol>
<h2 id="联结表查询"><a href="#联结表查询" class="headerlink" title="联结表查询"></a>联结表查询</h2><ol>
<li>联结查询(没有WHERE子句会产生笛卡尔积)<blockquote>
<p>SELECT vend_name, prod_name FROM vendor, product, WHERE vendor.vend_id = product.vend_id</p>
</blockquote>
</li>
<li>内部联结(等值联结，首选)<blockquote>
<p>SELECT vend_name, prod_name FROM vendor INNER JOIN product ON vendor.vend_id = product.vend_id</p>
</blockquote>
</li>
<li>多表联结<blockquote>
<p>SELECT vend_name, prod_name, quantity FROM vendor, product, orderitem WHERE product.vend_id = vendor.vend_id AND orderitem.prod_id = product.prod_id</p>
</blockquote>
</li>
<li>自联结(一般联结查询要比子查询快)<blockquote>
<p>ELECT p1.prod_id, p1.prod_name FROM product p1, product p2 WHERE<br> p1.vend_id = p2.vend_id AND p2.prod_id = ‘DTNTR’</p>
</blockquote>
</li>
<li>自然联结(排除一个列多次出现，使每个列只返回一次; 大部分内部联结都是自然联结)</li>
<li>外部联结(联结包括了那些在相关表没有关联行的行，左外联结(左边的所有行必出现)，右外联结(右边的所有行必出现))<blockquote>
<p>SELECT vend_name, prod_name FROM vendor LEFT OUTER JOIN product ON vendor.vend_id = product.vend_id</p>
</blockquote>
</li>
</ol>
<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><ol>
<li>创建组合查询(大部分使用WHERE子句更快，但是对于多个表使用UNION可能更简单，重复行会被自动取消，如果不取消，使用UNION ALL)<blockquote>
<p>SELECT vend_id, prod_id, prod_price FROM product WHERE prod_price &lt;=5 UNION SELECT vend_id, prod_id, prod_price FROM product WHERE vend_id IN  (1001, 1002)</p>
</blockquote>
</li>
</ol>
<h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><ol>
<li>插入一行数据(如果是完整的行，可以不写列名，但是要注意值的顺序)<blockquote>
<p>INSERT INTO customer(列名) VALUES(类名对应的值)        </p>
</blockquote>
</li>
<li>插入多个行<blockquote>
<p>INSERT INTO customer(列名) VALUES(类名对应的值),VALUES(类名对应的值)</p>
</blockquote>
</li>
<li>插入检索出的数据<blockquote>
<p>INSERT INTO customer(列名) SELECT (列名) FROM  表名</p>
</blockquote>
</li>
</ol>
<h1 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h1><ol>
<li>更新表中特定的列(一定不要忘了WHERE子句)<blockquote>
<p>UPDATE customer SET 列名 = 值  WHERE 子句</p>
</blockquote>
</li>
<li>更新多列<blockquote>
<p>UPDATE customer SET 列名 = 值,列名 = 值 WHERE 子句</p>
</blockquote>
</li>
</ol>
<h1 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h1><ol>
<li>删除特定的行<blockquote>
<p>DELETE FROM 表 WHERE 子句   </p>
</blockquote>
</li>
</ol>
<h1 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h1><ol>
<li>创建视图<blockquote>
<p>CREATE VIEW 视图名 AS SELECT 语句</p>
</blockquote>
</li>
<li>查看创建视图的语句<blockquote>
<p>SHOW CREATE VIEW 视图名</p>
</blockquote>
</li>
<li>删除视图<blockquote>
<p>DROP VIEW 视图名</p>
</blockquote>
</li>
<li>更新视图（先删除原视图，再创建新视图）</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《MySQL必知必会》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引:虽然用了这么久的数据库，但是有时候使用起来难免会去查怎么使用，这样下去也不是办法，所以自己就在这里以Mysql为例总结一下经常用到的地方。
    
    </summary>
    
      <category term="数据库" scheme="http://bestlixiang.site/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://bestlixiang.site/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://bestlixiang.site/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>HelloWorld_Shiro Activity</title>
    <link href="http://bestlixiang.site/2018/05/03/HelloWorld/HelloWorld-Shiro-Activity/"/>
    <id>http://bestlixiang.site/2018/05/03/HelloWorld/HelloWorld-Shiro-Activity/</id>
    <published>2018-05-03T06:08:03.000Z</published>
    <updated>2018-05-03T06:09:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：记得去年暑假要弄工作流Activity没有弄出来，这次刚好看到了一个基于Shiro和Activity的考勤项目，就想写一下了！<a id="more"></a></p>
<h1 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h1><ol>
<li>前端模板引擎：Velocity（不做重点讲解，它的页面主要使用的BootStrap的Admin开源框架）</li>
<li>后台：SSM框架</li>
<li>任务调度框架：Quartz</li>
<li>工作流引擎：Activity</li>
<li>权限控制框架：Shiro</li>
</ol>
<h1 id="项目功能"><a href="#项目功能" class="headerlink" title="项目功能"></a>项目功能</h1><ol>
<li>利用Shiro实现登录模块并实现权限控制</li>
<li>实现查看出勤记录</li>
<li>利用Quartz实现定时任务，每天凌晨扫描没有打卡记录的员工并记录</li>
<li>利用Activity实现补签流程</li>
</ol>
<h1 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h1><p><a href="https://github.com/todorex/Shiro_Activity_WorkAttendance" target="_blank" rel="external">HelloWorld_Shiro Activity 之 WorkAttendance考勤项目</a></p>
<h1 id="重点源码说明"><a href="#重点源码说明" class="headerlink" title="重点源码说明"></a>重点源码说明</h1><h2 id="利用Shiro实现登录与权限控制"><a href="#利用Shiro实现登录与权限控制" class="headerlink" title="利用Shiro实现登录与权限控制"></a>利用Shiro实现登录与权限控制</h2><p>我们这里主要利用了Shiro来进行登录验证，我们可以先看看Shiro架构，如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/helloworld/jpg/shiro.jpg" alt="shiro"></p>
<ol>
<li>Subject主要是存储了访问信息</li>
<li>SecurityManager是Shiro的核心，他主要用于协调Shiro内部各种安全组件</li>
<li>Realm用于连接Shiro和客户系统的用户数据的桥梁。一旦Shiro真正需要访问各种安全相关的数据（比如使用用户账户来做用户身份验证以及权限验证）时，他总是通过调用系统配置的各种Realm来读取数据，可以对比为SpringSecurity的Provider。</li>
</ol>
<p>Shrio配置文件主要是WorkAttendance/src/main/resources/spring-shiro.xml，在配置文件中，我们除了配置Realm和SecurityManager，还要配置一个ShiroFilter过滤链，这个过滤链主要配置要拦截或者忽略的路径，可以对比为SpringSecurity的配置类WebSecurityConfigurerAdapter。当然我们也可以使用注解来实现路径权限控制，如: <em>@RequiresPermissions(“attend:attendList”)</em></p>
<p>我们看看登录源代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LoginController的验证登录的方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">checkLogin</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> UnsupportedEncodingException, NoSuchAlgorithmException </span>&#123;</div><div class="line">    String username = request.getParameter(<span class="string">"username"</span>);</div><div class="line">    String pwd = request.getParameter(<span class="string">"password"</span>);</div><div class="line">    <span class="comment">// 组装成Token给Realm使用</span></div><div class="line">    UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username,pwd);</div><div class="line">    <span class="comment">// 等到登录访问信息</span></div><div class="line">    Subject subject = SecurityUtils.getSubject();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 进入Realm进行认证</span></div><div class="line">        subject.login(token);</div><div class="line">        <span class="comment">// 设置session过期时间</span></div><div class="line">        SecurityUtils.getSubject().getSession().setTimeout(<span class="number">1800000</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"login_fail"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">"login_succ"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 自定义的Realm</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserService userService;</div><div class="line"></div><div class="line"><span class="comment">//    授权</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</div><div class="line">        <span class="comment">// PrincipalCollection,可以理解身份上下文</span></div><div class="line">        String username = (String) principalCollection.getPrimaryPrincipal();</div><div class="line">        User user = userService.findUserByUserName(username);</div><div class="line">        SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</div><div class="line">        <span class="keyword">for</span>(Role role :user.getRoleList())&#123;</div><div class="line">            authorizationInfo.addRole(role.getRole());</div><div class="line">            <span class="keyword">for</span>(Permission permission :role.getPermissionList())&#123;</div><div class="line">                authorizationInfo.addStringPermission(permission.getPermission());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> authorizationInfo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//    登入验证</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        <span class="comment">// UsernamePasswordToken封装了用户名和密码</span></div><div class="line">        UsernamePasswordToken usernamePasswordToke = (UsernamePasswordToken)authenticationToken;</div><div class="line">        String username =  usernamePasswordToke.getUsername();</div><div class="line">        User user = userService.findUserByUserName(username);</div><div class="line">        <span class="keyword">if</span>(user==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 会使用自定义的账号密码校验器进行验证，并返回AuthenticationInfo</span></div><div class="line">            AuthenticationInfo info = <span class="keyword">new</span> SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), getName());</div><div class="line">            SecurityUtils.getSubject().getSession().setAttribute(<span class="string">"userInfo"</span>,user);</div><div class="line">            <span class="keyword">return</span> info;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 自定义的密码验证器，配置文件中配置</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCredentialsMatcher</span> <span class="keyword">extends</span> <span class="title">SimpleCredentialsMatcher</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doCredentialsMatch</span><span class="params">(AuthenticationToken authenticationToken, AuthenticationInfo authenticationInfo)</span> </span>&#123;</div><div class="line">        <span class="comment">// 对比用户登入的数据与数据库查询出来的信息</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) authenticationToken;</div><div class="line">            <span class="comment">// 用户登录的密码</span></div><div class="line">            String password = String.valueOf(usernamePasswordToken.getPassword());</div><div class="line">            Object tokenCredentials = MD5Utils.encryptPassword(password);</div><div class="line">            <span class="comment">// getCredentials()和equals都是SimpleCredentialsMatcher自带的方法</span></div><div class="line">            Object acountCredentials = getCredentials(authenticationInfo);</div><div class="line">            <span class="keyword">return</span> equals(tokenCredentials,acountCredentials);</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="利用Quartz实现定时任务"><a href="#利用Quartz实现定时任务" class="headerlink" title="利用Quartz实现定时任务"></a>利用Quartz实现定时任务</h2><p>它的核心元素关系图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/helloworld/jpg/quartz.jpg" alt="quartz"></p>
<p>它的配置文件在WorkAttendance/src/main/resources/spring-job.xml，我们也主要就是配置SchedulerFactory，Trigger和Job。里面关于cronExpression可以使用<a href="http://cron.qqe2.com/" target="_blank" rel="external">在线Cron表达式生成器</a>来确定或者书写。</p>
<p>我们看看定时任务的源代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 其实很简单，因为我们在配置文件中以及配置好要触发的类和方法了</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttendCheckTask</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> AttendService attendService;</div><div class="line">    <span class="comment">// JobMethod</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkAttend</span><span class="params">()</span> </span>&#123;</div><div class="line">        attendService.checkAttend();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="利用Activity实现补签流程"><a href="#利用Activity实现补签流程" class="headerlink" title="利用Activity实现补签流程"></a>利用Activity实现补签流程</h2><p>它的配置文件主要在WorkAttendance/src/main/resources/spring-activity.xml，我们主要就是配置processEngineFactory，processEngineConfiguration（会设置自动建表23张以及要部署的流程资源）以及各个服务类。</p>
<p>关于流程资源我们可以利用IDEA的<strong>actiBPM插件</strong>去画这个流程图，需要注意的是设置好各个ID，因为我们后面需要用到它。</p>
<p>接下来我们看看它的核心代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 开始流程并提交任务</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startReAttendFlow</span><span class="params">(ReAttend reAttend)</span> </span>&#123;</div><div class="line">    <span class="comment">// 从公司组织架构中，查询到此人上级领导人用户名</span></div><div class="line">    <span class="comment">// 这里手动设置</span></div><div class="line">    reAttend.setCurrentHandler(<span class="string">"rex666"</span>);</div><div class="line">    reAttend.setStatus(RE_ATTEND_STATUS_ONGOING);</div><div class="line">    <span class="comment">// 插入数据库补签表(ID自增)</span></div><div class="line">    reAttendMapper.insertSelective(reAttend);</div><div class="line">    <span class="comment">// 将一些需要的参数放入流程中传递，即Variables</span></div><div class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line">    map.put(RE_ATTEND_SIGN, reAttend);</div><div class="line">    <span class="comment">// 后面需要根据流程中的变量名来获取</span></div><div class="line">    map.put(NEXT_HANDLER, reAttend.getCurrentHandler());</div><div class="line">    <span class="comment">// 获得流程实例</span></div><div class="line">    ProcessInstance instance = runtimeService.startProcessInstanceByKey(RE_ATTEND_FLOW_ID, map);</div><div class="line">    <span class="comment">// 获得任务</span></div><div class="line">    Task task = taskService.createTaskQuery().processInstanceId(instance.getId()).singleResult();</div><div class="line">    <span class="comment">// 提交用户补签任务</span></div><div class="line">    taskService.complete(task.getId(), map);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 当前处理人获得需要处理的任务</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;ReAttend&gt; <span class="title">listTasks</span><span class="params">(String userName)</span> </span>&#123;</div><div class="line">    <span class="comment">//转换成页面实体 需要返回的对象</span></div><div class="line">    List&lt;ReAttend&gt; reAttendList = <span class="keyword">new</span> ArrayList&lt;ReAttend&gt;();</div><div class="line">    List&lt;Task&gt; taskList = taskService.createTaskQuery().processVariableValueEquals(userName).list();</div><div class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(taskList)) &#123;</div><div class="line">        <span class="keyword">for</span> (Task task : taskList) &#123;</div><div class="line">            Map&lt;String, Object&gt; variable = taskService.getVariables(task.getId());</div><div class="line">            ReAttend reAttend = (ReAttend) variable.get(RE_ATTEND_SIGN);</div><div class="line">            reAttend.setTaskId(task.getId());</div><div class="line">            reAttendList.add(reAttend);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> reAttendList;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 3.当前处理人处理任务</span></div><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">approve</span><span class="params">(ReAttend reAttend)</span> </span>&#123;</div><div class="line">    <span class="comment">// 需要处理的任务</span></div><div class="line">    Task task = taskService.createTaskQuery().taskId(reAttend.getTaskId()).singleResult();</div><div class="line">    <span class="comment">// 如果同意</span></div><div class="line">    <span class="keyword">if</span> ((<span class="string">""</span> + RE_ATTEND_STATUS_PSSS).equals(reAttend.getApproveFlag())) &#123;</div><div class="line">        Attend attend = <span class="keyword">new</span> Attend();</div><div class="line">        attend.setId(reAttend.getAttendId());</div><div class="line">        attend.setAttendStatus(ATTEND_STATUS_NORMAL);</div><div class="line">        <span class="comment">// 将出勤数据的状态从异常变为正常</span></div><div class="line">        attendMapper.updateByPrimaryKeySelective(attend);</div><div class="line">        <span class="comment">// 审批通过，修改补签数据状态</span></div><div class="line">        reAttend.setStatus(RE_ATTEND_STATUS_PSSS);</div><div class="line">        reAttendMapper.updateByPrimaryKeySelective(reAttend);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="string">""</span> + RE_ATTEND_STATUS_REFUSE.toString()).equals(reAttend.getApproveFlag())) &#123;</div><div class="line">        reAttend.setStatus(RE_ATTEND_STATUS_REFUSE);</div><div class="line">        reAttendMapper.updateByPrimaryKeySelective(reAttend);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 完成任务</span></div><div class="line">    taskService.complete(task.getId());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这个项目关于前端页面前端模板引擎Velocity，SSM架构，Mybatis自动生成插件以及分页方法，这里都不再多说，项目的注释应该算是很全了，认真看就行。</p>
<h1 id="参考与致谢"><a href="#参考与致谢" class="headerlink" title="参考与致谢"></a>参考与致谢</h1><ol>
<li><a href="http://coder520.com/courses/17" target="_blank" rel="external">SSM实战-码码员工考勤系统</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：记得去年暑假要弄工作流Activity没有弄出来，这次刚好看到了一个基于Shiro和Activity的考勤项目，就想写一下了！
    
    </summary>
    
      <category term="HelloWorld" scheme="http://bestlixiang.site/categories/HelloWorld/"/>
    
    
      <category term="SSM" scheme="http://bestlixiang.site/tags/SSM/"/>
    
      <category term="Shiro" scheme="http://bestlixiang.site/tags/Shiro/"/>
    
      <category term="Activity" scheme="http://bestlixiang.site/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>HelloWorld_SpringBoot Angular</title>
    <link href="http://bestlixiang.site/2018/04/25/HelloWorld/HelloWorld-SpringBoot-Angular/"/>
    <id>http://bestlixiang.site/2018/04/25/HelloWorld/HelloWorld-SpringBoot-Angular/</id>
    <published>2018-04-25T11:31:14.000Z</published>
    <updated>2018-04-25T11:32:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：前段时间写了个前后台不分离的<a href="http://todorex.com/2018/04/17/HelloWorld/HelloWorld-SSMLogin/" target="_blank" rel="external">SSMLogin</a>，大家可能会觉得前后台不分离太low，所以这次我们使用SpringBoot+Angular搭建了一个利用Token来进行身份验证的前后台分离登录Demo项目。<a id="more"></a></p>
<h1 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h1><p><a href="https://github.com/todorex/SpringBoot_Angular_HeroesLogin/" target="_blank" rel="external">SpringBoot+Angular</a></p>
<h1 id="Angular前端"><a href="#Angular前端" class="headerlink" title="Angular前端"></a>Angular前端</h1><p>本文前端基于Angular官方样例Tour of Heroes，请先到<a href="https://angular.io/tutorial" target="_blank" rel="external">官网下载</a>，也可以拷贝自己的项目源码（不过最好还是一步步来，先去官网下载源码），这次前端不是主要讲解的地方，所以官网源码部分就不说了，自己去看。我只说增加的核心部分。</p>
<h2 id="login组件"><a href="#login组件" class="headerlink" title="login组件"></a>login组件</h2><p>下面是登录的ts代码：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> LoginComponent <span class="keyword">implements</span> OnInit &#123;</div><div class="line">  <span class="comment">// 用来接收后台的数据</span></div><div class="line">  model: <span class="built_in">any</span> = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="comment">//注入依赖对象</span></div><div class="line">  <span class="keyword">constructor</span>(<span class="params"></span></div><div class="line">    <span class="keyword">private</span> router: Router,</div><div class="line">    <span class="keyword">private</span> authenticationService: AuthenticationService,</div><div class="line">  ) &#123; &#125;</div><div class="line"></div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="comment">// 重置登录状态</span></div><div class="line">    <span class="keyword">this</span>.authenticationService.logout();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  login() &#123;</div><div class="line">    <span class="comment">// 利用authenticationService获取对象</span></div><div class="line">    <span class="keyword">this</span>.authenticationService.login(<span class="keyword">this</span>.model.username, <span class="keyword">this</span>.model.password).subscribe(</div><div class="line">      <span class="function"><span class="params">result</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span> (result) &#123;</div><div class="line">          <span class="comment">// 登录成功，调制路由</span></div><div class="line">          <span class="keyword">this</span>.router.navigate([<span class="string">'dashboard'</span>]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">this</span>.log(<span class="string">'Username or Password is incorrect'</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="AuthenticationService服务"><a href="#AuthenticationService服务" class="headerlink" title="AuthenticationService服务"></a>AuthenticationService服务</h2><p>看看它的代码：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// http头，使用json传递数据</span></div><div class="line"><span class="keyword">const</span> httpOptions = &#123;</div><div class="line">  headers: <span class="keyword">new</span> HttpHeaders(&#123;<span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>&#125;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@Injectable</span>()</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> AuthenticationService &#123;</div><div class="line">  <span class="comment">// 认证的url</span></div><div class="line">  <span class="keyword">private</span> url: <span class="built_in">string</span> = <span class="string">`<span class="subst">$&#123;environment.apiURL&#125;</span>/auth`</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>) &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  login(username: <span class="built_in">string</span>, password: <span class="built_in">string</span>): Observable&lt;<span class="built_in">boolean</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.post&lt;<span class="built_in">any</span>&gt;(<span class="keyword">this</span>.url,<span class="built_in">JSON</span>.stringify(&#123;username: username, password: password&#125;),httpOptions).pipe(</div><div class="line">      tap(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</div><div class="line">        <span class="comment">// 获得token认证</span></div><div class="line">        <span class="keyword">let</span> token = response.token;</div><div class="line">        <span class="keyword">if</span> (token) &#123;</div><div class="line">          <span class="comment">// 存储token到浏览器localStorage中，以后每次都带着它去请求数据</span></div><div class="line">          localStorage.setItem(<span class="string">'currentUser'</span>,token);</div><div class="line">        &#125;</div><div class="line">      &#125;),</div><div class="line">      catchError(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.error(err);</div><div class="line">        <span class="keyword">return</span> of (<span class="literal">false</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">      )</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 从localStorage获得token</span></div><div class="line">  getToken(): <span class="built_in">String</span> &#123;</div><div class="line">    <span class="keyword">return</span> localStorage.getItem(<span class="string">'currentUser'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  logout(): <span class="built_in">void</span> &#123;</div><div class="line">    <span class="comment">// 清空token，那么没有Token也就不能刷新页面了</span></div><div class="line">    localStorage.removeItem(<span class="string">'currentUser'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  isLoggedIn(): <span class="built_in">boolean</span> &#123;</div><div class="line">    <span class="keyword">var</span> token: <span class="built_in">String</span> = <span class="keyword">this</span>.getToken();</div><div class="line">    <span class="keyword">return</span> token &amp;&amp; token.length &gt; <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="AuthenticationInterceptor拦截器"><a href="#AuthenticationInterceptor拦截器" class="headerlink" title="AuthenticationInterceptor拦截器"></a>AuthenticationInterceptor拦截器</h1><p>有了这个拦截器，以后所有的请求都过经过这里，看看它的代码：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Injectable</span>()</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> AuthenticationInterceptor <span class="keyword">implements</span> HttpInterceptor &#123;</div><div class="line"></div><div class="line">  <span class="comment">// next 相当于Java Filter 的chain</span></div><div class="line">  intercept(req: HttpRequest&lt;<span class="built_in">any</span>&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;<span class="built_in">any</span>&gt;&gt; &#123;</div><div class="line">    <span class="keyword">const</span> idToken = localStorage.getItem(<span class="string">'currentUser'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (idToken) &#123;</div><div class="line">      <span class="comment">// 将原来的请求加上token包装成新的请求发送</span></div><div class="line">      <span class="keyword">const</span> cloned = req.clone(&#123;</div><div class="line">        headers: req.headers.set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + idToken)</div><div class="line">      &#125;);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> next.handle(cloned);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> next.handle(req);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="CanActivateAuthGuard保卫"><a href="#CanActivateAuthGuard保卫" class="headerlink" title="CanActivateAuthGuard保卫"></a>CanActivateAuthGuard保卫</h2><p>有了CanActivateAuthGuard就能够防止未登录用户访问其他页面，看看它的代码：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Injectable</span>()</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> CanActivateAuthGuard <span class="keyword">implements</span> CanActivate &#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(<span class="params"></span></div><div class="line">    <span class="keyword">public</span> router: Router,</div><div class="line">    <span class="keyword">private</span> authService: AuthenticationService</div><div class="line">  ) &#123;&#125;</div><div class="line"></div><div class="line">  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.authService.isLoggedIn()) &#123;</div><div class="line">      <span class="comment">// 可以通过</span></div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 不能通过，跳转到登录页面</span></div><div class="line">    <span class="keyword">this</span>.router.navigate([<span class="string">'/login'</span>]);</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Springboot后台"><a href="#Springboot后台" class="headerlink" title="Springboot后台"></a>Springboot后台</h1><p>我们首先要对SpringBoot的项目结构有个熟悉的认识，如果不知道的可以先稍微了解一下他，他太棒了。这次开发也是上帝模式。</p>
<h2 id="SpringSecurity权限控制"><a href="#SpringSecurity权限控制" class="headerlink" title="SpringSecurity权限控制"></a>SpringSecurity权限控制</h2><p>首先我们要对前台的请求进行认证，利用配置文件设置一些值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># 控制跨域访问</div><div class="line">cors:</div><div class="line">  allowedOrigins: &quot;*&quot;</div><div class="line">  allowedMethods: GET,POST,DELETE,PUT,OPTIONS</div><div class="line">  allowedHeaders: Origin,X-Requested-With,Content-Type,Accept,Accept-Encoding,Accept-Language,Host,Referer,Connection,User-Agent,Authorization</div><div class="line"></div><div class="line"># token配置</div><div class="line">jwt:</div><div class="line">  header: Authorization</div><div class="line">  secret: mySecret</div><div class="line">  expiration: 7200</div><div class="line">  issuer: IATA</div><div class="line">  authenticationPath: /auth</div></pre></td></tr></table></figure></p>
<h3 id="SpringSecurity配置类"><a href="#SpringSecurity配置类" class="headerlink" title="SpringSecurity配置类"></a>SpringSecurity配置类</h3><p>在com.todorex.config.WebSecurityConfig类中，在这个类中，我们主要是配置认证路径、跨域访问以及过滤器等设置。</p>
<h3 id="SpringSecurity自定义过滤器"><a href="#SpringSecurity自定义过滤器" class="headerlink" title="SpringSecurity自定义过滤器"></a>SpringSecurity自定义过滤器</h3><p>在com.todorex.config.AuthenticationTokenFilter类中，主要是验证token，但不重新计算token。</p>
<h3 id="token生成方法"><a href="#token生成方法" class="headerlink" title="token生成方法"></a>token生成方法</h3><p>在com.todorex.util.JwtTokenUtil类中，主要有生成token以及验证token的方法。</p>
<h2 id="Contoller"><a href="#Contoller" class="headerlink" title="Contoller"></a>Contoller</h2><p>主要是控制处理URL，其中比较重要的就是com.todorex.controller.AuthenticationController类，它是用来进行权限认证的，我们看看它的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(produces = MediaType.APPLICATION_JSON_VALUE)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationController</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</div><div class="line"></div><div class="line">    <span class="comment">// 请求路径(/auth)</span></div><div class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"$&#123;jwt.authenticationPath&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> AuthenticationResponse <span class="title">login</span><span class="params">(@RequestBody AuthenticationRequest request)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        <span class="comment">// 对包装过后的UsernamePasswordAuthenticationToken精心再包装成Authentication</span></div><div class="line">        <span class="keyword">final</span> Authentication authentication = authenticationManager.authenticate(<span class="keyword">new</span> UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword()));</div><div class="line">        <span class="comment">// 将该认证添加到上下文中（避免多次验证）</span></div><div class="line">        <span class="comment">// SecurityContextHolder用于存储安全上下文（security context）的信息</span></div><div class="line">        SecurityContextHolder.getContext().setAuthentication(authentication);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">final</span> UserDetails userDetails = userDetailsService.loadUserByUsername(request.getUsername());</div><div class="line">        <span class="comment">// 实际应用中，生成token时可能会用到更多的参数</span></div><div class="line">        <span class="keyword">final</span> String token = jwtTokenUtil.generate(userDetails.getUsername());</div><div class="line">        <span class="comment">// 返回Token</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AuthenticationResponse(token);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其他都是普通的Controller，但是对于URL的设计我们需要注意，我们主要是用Restful风格的URL，这种风格是怎么样的呢？我们可以参考下面的博文：<a href="https://blog.csdn.net/chenxiaochan/article/details/73716617" target="_blank" rel="external">【Restful】三分钟彻底了解Restful最佳实践</a>。</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>主要是处理业务的，这里我们需要注意的这个类：com.todorex.service.UserDetailsServiceImpl，我们需要实现UserDetailsService接口，因为SpringSecurity方法会用到，看看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserRepository userRepository;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</div><div class="line">        User user = userRepository.findByUsername(s);</div><div class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(String.format(<span class="string">"No user found with username '%s'."</span>, s));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> create(user);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 包装成SpringSecurity需要的User</div><div class="line">     * <span class="doctag">@param</span> user</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> org.springframework.security.core.userdetails.<span class="function">User <span class="title">create</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> org.springframework.security.core.userdetails.User(user.getUsername(), user.getPassword(), mapToGrantedAuthorities(user.getAuthorities()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 包装权限</div><div class="line">     * <span class="doctag">@param</span> authorities</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;GrantedAuthority&gt; <span class="title">mapToGrantedAuthorities</span><span class="params">(List&lt;Authority&gt; authorities)</span> </span>&#123;</div><div class="line">        <span class="comment">// Java8语法</span></div><div class="line">        <span class="keyword">return</span> authorities.stream()</div><div class="line">                .map(authority -&gt; <span class="keyword">new</span> SimpleGrantedAuthority(authority.getName().name()))</div><div class="line">                .collect(Collectors.toList());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h2><p>这里我们使用的JPA，它内部实现是Hibernate，我们只要先定义Entity再定义Dao类就可以了。</p>
<h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>Entity定义之后可以根据实体自动建表（可在配置文件中配置），如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># jpa配置</div><div class="line">  jpa:</div><div class="line">    database: MYSQL</div><div class="line">    show-sql: true</div><div class="line">    hibernate:</div><div class="line">    # 表不存在就自动建表</div><div class="line">      ddl-auto: create</div></pre></td></tr></table></figure></p>
<h3 id="Dao-1"><a href="#Dao-1" class="headerlink" title="Dao"></a>Dao</h3><p>Dao接口只要继承JpaRepository<t, id="">就会有很多内置方法，如果要自己写SQL也可以参照com.todorex.HeroRepository的写法。</t,></p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>我们可以先定义总的接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootTestAbstract</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后每个要测试的类继承他就可以了，避免了重复配置，IDEA还有很多技巧，自己可以去baidu、google，这里也举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTest</span> <span class="keyword">extends</span> <span class="title">SpringBootTestAbstract</span></span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    ApplicationContext applicationContext;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    DataSourceProperties dataSourceProperties;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// 获取配置的数据源</span></div><div class="line">        DataSource dataSource = applicationContext.getBean(DataSource.class);</div><div class="line">        <span class="comment">// 查看配置数据源信息</span></div><div class="line">        System.out.println(dataSource);</div><div class="line">        System.out.println(dataSource.getClass().getName());</div><div class="line">        System.out.println(dataSourceProperties);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>SpringBoot默认使用logback作为日志框架，我们可以做如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 日志配置</div><div class="line">logging:</div><div class="line">  level:</div><div class="line">    # 配置包以及输出等级</div><div class="line">    com.todorex: debug</div><div class="line">  pattern:</div><div class="line">    console: &quot;%d - %msg%n&quot;</div><div class="line">  path: /var/localLog/</div><div class="line">  file: /var/localLog/springbootdemo.log</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://blog.51cto.com/7308310/2072364" target="_blank" rel="external">Angular 5集成Spring Boot,Spring Security,JWT和CORS</a></li>
<li><a href="https://angular.io/tutorial" target="_blank" rel="external">Angular_Heroes教程</a></li>
<li><a href="http://todorex.com/2018/04/25/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98SpringSecurity-%E4%B8%80-%E8%AF%B7%E6%B1%82%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/" target="_blank" rel="external">揭秘SpringSecurity(一)_请求认证过程</a></li>
<li><a href="http://todorex.com/2018/04/21/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98SpringBoot-%E4%B8%80-SpringBoot%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/" target="_blank" rel="external">揭秘SpringBoot(一)_SpringBoot运行原理</a></li>
<li><a href="https://blog.csdn.net/chenxiaochan/article/details/73716617" target="_blank" rel="external">【Restful】三分钟彻底了解Restful最佳实践</a></li>
<li><a href="https://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="external">什么是 JWT – JSON WEB TOKEN</a></li>
<li><a href="https://blog.csdn.net/cabbges/article/details/53378516" target="_blank" rel="external">ajax 跨域 CROS</a></li>
<li><a href="https://blog.csdn.net/inke88/article/details/75007649" target="_blank" rel="external">Spring Boot 日志配置(超详细)</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前段时间写了个前后台不分离的&lt;a href=&quot;http://todorex.com/2018/04/17/HelloWorld/HelloWorld-SSMLogin/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SSMLogin&lt;/a&gt;，大家可能会觉得前后台不分离太low，所以这次我们使用SpringBoot+Angular搭建了一个利用Token来进行身份验证的前后台分离登录Demo项目。
    
    </summary>
    
      <category term="HelloWorld" scheme="http://bestlixiang.site/categories/HelloWorld/"/>
    
    
      <category term="SpringBoot" scheme="http://bestlixiang.site/tags/SpringBoot/"/>
    
      <category term="SpringSecurity" scheme="http://bestlixiang.site/tags/SpringSecurity/"/>
    
      <category term="JWT" scheme="http://bestlixiang.site/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>揭秘SpringSecurity(一)_请求认证过程</title>
    <link href="http://bestlixiang.site/2018/04/25/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98SpringSecurity-%E4%B8%80-%E8%AF%B7%E6%B1%82%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/"/>
    <id>http://bestlixiang.site/2018/04/25/深入SSM/揭秘SpringSecurity-一-请求认证过程/</id>
    <published>2018-04-25T07:39:06.000Z</published>
    <updated>2018-04-25T11:41:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：有了Spring作为基础，Spring家族的很多框架都显得那么棒，尤其是Springboot的出现，简化了配置，家族框架就显得更棒了，我们这次分析一下其中的SpringSecurity，我们会由请求认证过程，来分析其中的各个组件！<a id="more"></a></p>
<h1 id="一次认证过程"><a href="#一次认证过程" class="headerlink" title="一次认证过程"></a>一次认证过程</h1><p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/springSecurity.png" alt="SpringSecurity"></p>
<p>大家可以找到一个工程，这里也可以看看我的<a href="https://github.com/todorex/SpringBoot_Angular_HeroesLogin" target="_blank" rel="external">SpringBoot+Angular工程</a>debug验证我画的流程图。</p>
<h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>在最开始debug的过程中我们会发现pring Security使用了springSecurityFillterChian作为了安全过滤的入口，我只介绍几个比较常用的过滤器。</p>
<h3 id="SecurityContextPersistenceFilter"><a href="#SecurityContextPersistenceFilter" class="headerlink" title="SecurityContextPersistenceFilter"></a>SecurityContextPersistenceFilter</h3><p>两个主要职责：</p>
<ol>
<li>请求来临时，创建SecurityContext安全上下文信息</li>
<li>请求结束时清空SecurityContextHolder（可获得当前操作的用户是谁，该用户是否已经被认证，他拥有哪些角色权限等信息）。</li>
</ol>
<p>我们看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityContextPersistenceFilter</span> <span class="keyword">extends</span> <span class="title">GenericFilterBean</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String FILTER_APPLIED = <span class="string">"__spring_security_scpf_applied"</span>;</div><div class="line">    <span class="comment">// 安全上下文存储的仓库</span></div><div class="line">    <span class="keyword">private</span> SecurityContextRepository repo;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityContextPersistenceFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// HttpSessionSecurityContextRepository是SecurityContextRepository接口的一个实现类</span></div><div class="line">        <span class="comment">// 使用HttpSession来存储SecurityContext</span></div><div class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> HttpSessionSecurityContextRepository());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">        HttpServletRequest request = (HttpServletRequest)req;</div><div class="line">        HttpServletResponse response = (HttpServletResponse)res;</div><div class="line">        <span class="keyword">if</span>(request.getAttribute(<span class="string">"__spring_security_scpf_applied"</span>) != <span class="keyword">null</span>) &#123;</div><div class="line">            chain.doFilter(request, response);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">boolean</span> debug = <span class="keyword">this</span>.logger.isDebugEnabled();</div><div class="line">            request.setAttribute(<span class="string">"__spring_security_scpf_applied"</span>, Boolean.TRUE);</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.forceEagerSessionCreation) &#123;</div><div class="line">                HttpSession session = request.getSession();</div><div class="line">                <span class="keyword">if</span>(debug &amp;&amp; session.isNew()) &#123;</div><div class="line">                    <span class="keyword">this</span>.logger.debug(<span class="string">"Eagerly created session: "</span> + session.getId());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 包装request，response</span></div><div class="line">            HttpRequestResponseHolder holder = <span class="keyword">new</span> HttpRequestResponseHolder(request, response);</div><div class="line">            <span class="comment">// 从Session中获取安全上下文信息</span></div><div class="line">            SecurityContext contextBeforeChainExecution = <span class="keyword">this</span>.repo.loadContext(holder);</div><div class="line">            <span class="keyword">boolean</span> var13 = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                var13 = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">// 请求开始时，设置安全上下文信息，这样就避免了用户直接从Session中获取安全上下文信息</span></div><div class="line">                SecurityContextHolder.setContext(contextBeforeChainExecution);</div><div class="line">                chain.doFilter(holder.getRequest(), holder.getResponse());</div><div class="line">                var13 = <span class="keyword">false</span>;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">if</span>(var13) &#123;</div><div class="line">                    SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext();\</div><div class="line">                    <span class="comment">//请求结束后，清空安全上下文信息</span></div><div class="line">                    SecurityContextHolder.clearContext();</div><div class="line">                    <span class="keyword">this</span>.repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());</div><div class="line">                    request.removeAttribute(<span class="string">"__spring_security_scpf_applied"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="UsernamePasswordAuthenticationFilter"><a href="#UsernamePasswordAuthenticationFilter" class="headerlink" title="UsernamePasswordAuthenticationFilter"></a>UsernamePasswordAuthenticationFilter</h2><p>这个可能是我们遇见最多的过滤器了，一个最直观的业务场景便是允许用户在表单中输入用户名和密码进行登录，而这背后用到的就是UsernamePasswordAuthenticationFilter。这个过滤器也可以见证我们之前画的时序图，我们看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.postOnly &amp;&amp; !request.getMethod().equals(<span class="string">"POST"</span>)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(<span class="string">"Authentication method not supported: "</span> + request.getMethod());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 获取用户名，密码</span></div><div class="line">            String username = <span class="keyword">this</span>.obtainUsername(request);</div><div class="line">            String password = <span class="keyword">this</span>.obtainPassword(request);</div><div class="line">            <span class="keyword">if</span>(username == <span class="keyword">null</span>) &#123;</div><div class="line">                username = <span class="string">""</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(password == <span class="keyword">null</span>) &#123;</div><div class="line">                password = <span class="string">""</span>;</div><div class="line">            &#125;</div><div class="line">            username = username.trim();</div><div class="line">            <span class="comment">// 生成Authentication，下面会介绍</span></div><div class="line">            UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(username, password);</div><div class="line">            <span class="keyword">this</span>.setDetails(request, authRequest);</div><div class="line">            <span class="comment">// 讲Authentication交给AuthenticationManager认证</span></div><div class="line">            <span class="keyword">return</span>  <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="自定义Filter"><a href="#自定义Filter" class="headerlink" title="自定义Filter"></a>自定义Filter</h3><p>当自带的Filter不能满足你的要求时（例如我们要先对token进行认证），我们可以自定义过滤器，只要继承各种Filter接口，并实现其中方法即可。</p>
<h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p>先看他的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authentication</span> <span class="keyword">extends</span> <span class="title">Principal</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="comment">// 权限信息列表</span></div><div class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</div><div class="line">    <span class="comment">// 密码信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全</span></div><div class="line">    <span class="function">Object <span class="title">getCredentials</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 细节信息，它记录了访问者的ip地址和sessionId的值。</span></div><div class="line">    <span class="function">Object <span class="title">getDetails</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 最重要的身份信息，大部分情况下返回的是UserDetails接口的实现类</span></div><div class="line">    <span class="function">Object <span class="title">getPrincipal</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 是否已认证</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAuthenticated</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> var1)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从它的源码可以知道它拥有的权限信息列表，密码，用户细节信息，用户身份信息，认证信息。</p>
<p>它有很多实现类，比如流程图中的<strong>UsernamePasswordAuthenticationToken</strong>，以及AnonymousAuthenticationToken等。</p>
<h2 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h2><p>先看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationManager</span> </span>&#123;</div><div class="line">    <span class="comment">// 主要是认证传进来的Authentication</span></div><div class="line">    <span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication var1)</span> <span class="keyword">throws</span> AuthenticationException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它最有用的实现类就是流程图中的ProviderManager，我们可以看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderManager</span> <span class="keyword">implements</span> <span class="title">AuthenticationManager</span>, <span class="title">MessageSourceAware</span>, <span class="title">InitializingBean</span> </span>&#123;</div><div class="line">    <span class="comment">// 维护一个AuthenticationProvider列表</span></div><div class="line">    <span class="keyword">private</span> List&lt;AuthenticationProvider&gt; providers;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> eraseCredentialsAfterAuthentication;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</div><div class="line">        AuthenticationException lastException = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 要从新返回的Authentication</span></div><div class="line">        Authentication result = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 遍历AuthenticationProvider列表</span></div><div class="line">        Iterator var6 = <span class="keyword">this</span>.getProviders().iterator();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(var6.hasNext()) &#123;</div><div class="line">            AuthenticationProvider provider = (AuthenticationProvider)var6.next();</div><div class="line">            <span class="keyword">if</span>(provider.supports(toTest)) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// 对传进来的authentication进行认证</span></div><div class="line">                    result = provider.authenticate(authentication);</div><div class="line">                    <span class="keyword">if</span>(result != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">// 将属性复制给result</span></div><div class="line">                        <span class="keyword">this</span>.copyDetails(authentication, result);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (AccountStatusException var11) &#123;</div><div class="line">                    ...</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(result == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 如果列表里的Provider都不支持该authentication，则到父类查找</span></div><div class="line">                result = <span class="keyword">this</span>.parent.authenticate(authentication);</div><div class="line">            &#125; <span class="keyword">catch</span> (ProviderNotFoundException var9) &#123;</div><div class="line">                ;</div><div class="line">            &#125; <span class="keyword">catch</span> (AuthenticationException var10) &#123;</div><div class="line">                lastException = var10;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(result != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.eraseCredentialsAfterAuthentication &amp;&amp; result <span class="keyword">instanceof</span> CredentialsContainer) &#123;</div><div class="line">                <span class="comment">// 擦除密码信息</span></div><div class="line">                ((CredentialsContainer)result).eraseCredentials();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">this</span>.eventPublisher.publishAuthenticationSuccess(result);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="AuthenticationProvider"><a href="#AuthenticationProvider" class="headerlink" title="AuthenticationProvider"></a>AuthenticationProvider</h2><p>看看它的源码先：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationProvider</span> </span>&#123;</div><div class="line">    <span class="comment">// 认证</span></div><div class="line">    <span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication var1)</span> <span class="keyword">throws</span> AuthenticationException</span>;</div><div class="line">    <span class="comment">// 判断是否支持传进来的Authentication</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们接着看看它最常用的一个实现DaoAuthenticationProvider。也看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoAuthenticationProvider</span> <span class="keyword">extends</span> <span class="title">AbstractUserDetailsAuthenticationProvider</span> </span>&#123;</div><div class="line">    <span class="comment">// 密码加密器</span></div><div class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</div><div class="line">    <span class="comment">// 加载用户的UserDetailsService</span></div><div class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(authentication.getCredentials() == <span class="keyword">null</span>) &#123;</div><div class="line">            ...</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 验证密码</span></div><div class="line">            String presentedPassword = authentication.getCredentials().toString();</div><div class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 最核心的方法</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title">retrieveUser</span><span class="params">(String username, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        <span class="keyword">this</span>.prepareTimingAttackProtection();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 获得UserDetails</span></div><div class="line">            UserDetails loadedUser = <span class="keyword">this</span>.getUserDetailsService().loadUserByUsername(username);</div><div class="line">            <span class="keyword">if</span>(loadedUser == <span class="keyword">null</span>) &#123;</div><div class="line">                ...</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> loadedUser;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (UsernameNotFoundException var4) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h2><p>先看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetailsService</span> </span>&#123;</div><div class="line">    <span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String var1)</span> <span class="keyword">throws</span> UsernameNotFoundException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个接口的实现类有JdbcDaoImpl（负责从数据库加载用户）等，当然我们也可以自己实现这个接口。只要实现loadUserByUsername方法即可。</p>
<p>再看看<strong>UserDetails</strong>是个什么东西？</p>
<p>看看它源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="comment">// 权限属性</span></div><div class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</div><div class="line">    <span class="comment">// 密码属性</span></div><div class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 用户名属性</span></div><div class="line">    <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 账户是否过期</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 账户是否被锁</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 密码是否过期</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 是否启用</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它代表了最详细的用户信息，这个接口涵盖了一些必要的用户信息字段，具体的实现类对它进行了扩展。这里我们普通的User类也可以实现这个接口。</p>
<h1 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h1><p>通过我们上面对核心组件的解读再结合流程流就应该可以理解SpringSecurity的请求认证过程。但是不可能我们对所有的路径都需要认证，或者说它总要提供一个东西让我们配置它的细节，那就是WebSecurityConfigurerAdapter接口，它主要使用了适配器模式。我们主要看看我们需要覆盖它的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfigurerAdapter</span> <span class="keyword">implements</span> <span class="title">WebSecurityConfigurer</span>&lt;<span class="title">WebSecurity</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 配置AuthenticationManagerBuilder</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">this</span>.disableLocalConfigureAuthenticationBldr = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 配置WebSecurity</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 配置HttpSecurity</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ((HttpSecurity)((HttpSecurity)((AuthorizedUrl)http.authorizeRequests().anyRequest()).authenticated().and()).formLogin().and()).httpBasic();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="配置AuthenticationManagerBuilder"><a href="#配置AuthenticationManagerBuilder" class="headerlink" title="配置AuthenticationManagerBuilder"></a>配置AuthenticationManagerBuilder</h2><p>我们可以看看它的使用案例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        auth</div><div class="line">            .inMemoryAuthentication()</div><div class="line">            .withUser(<span class="string">"admin"</span>).password(<span class="string">"admin"</span>).roles(<span class="string">"USER"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>想要在WebSecurityConfigurerAdapter中进行认证相关的配置，可以使用configure(AuthenticationManagerBuilder auth)暴露一个AuthenticationManager的建造器：AuthenticationManagerBuilder 。如上所示，我们便完成了内存中用户的配置，也可以在这里讲自己定义的UserDetailService注入。</p>
<h2 id="配置WebSecurity"><a href="#配置WebSecurity" class="headerlink" title="配置WebSecurity"></a>配置WebSecurity</h2><p>我们可以看看它的使用案例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        http</div><div class="line">            <span class="comment">// 配置路径拦截，表明路径访问所对应的权限，角色，认证信息。</span></div><div class="line">            .authorizeRequests()</div><div class="line">                .antMatchers(<span class="string">"/resources/**"</span>, <span class="string">"/signup"</span>, <span class="string">"/about"</span>).permitAll()</div><div class="line">                .antMatchers(<span class="string">"/admin/**"</span>).hasRole(<span class="string">"ADMIN"</span>)</div><div class="line">                .antMatchers(<span class="string">"/db/**"</span>).access(<span class="string">"hasRole('ADMIN') and hasRole('DBA')"</span>)</div><div class="line">                .anyRequest().authenticated()</div><div class="line">                .and()</div><div class="line">            <span class="comment">// 配置表单认证</span></div><div class="line">            .formLogin()</div><div class="line">                .usernameParameter(<span class="string">"username"</span>)</div><div class="line">                .passwordParameter(<span class="string">"password"</span>)</div><div class="line">                .failureForwardUrl(<span class="string">"/login?error"</span>)</div><div class="line">                .loginPage(<span class="string">"/login"</span>)</div><div class="line">                .permitAll()</div><div class="line">                .and()</div><div class="line">            <span class="comment">// 配置注销</span></div><div class="line">            .logout()</div><div class="line">                .logoutUrl(<span class="string">"/logout"</span>)</div><div class="line">                .logoutSuccessUrl(<span class="string">"/index"</span>)</div><div class="line">                .permitAll()</div><div class="line">                .and()</div><div class="line">            <span class="comment">// 配置basic登录</span></div><div class="line">            .httpBasic()</div><div class="line">                .disable();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法里的各项配置分别代表了http请求相关的安全配置，这些配置项无一例外的返回了Configurer类，而所有的http相关配置可以通过查看HttpSecurity的主要方法得知。</p>
<h2 id="WebSecurityBuilder"><a href="#WebSecurityBuilder" class="headerlink" title="WebSecurityBuilder"></a>WebSecurityBuilder</h2><p>我们可以看看它的使用案例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        web</div><div class="line">            .ignoring()</div><div class="line">            .antMatchers(<span class="string">"/resources/**"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个配置中并不会出现太多的配置信息。</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="http://ov0zuistv.bkt.clouddn.com/spring%20security%20architecture.png" alt="image"></p>
<p>将这个架构图结合流程图我们会可以大致总结出核心组件之间的关系，有利于我们我们更好的理解SpringSecurity的架构以及请求认证过程。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnkirito.moe/2017/09/19/spring-security-1/" target="_blank" rel="external">Spring Security(一)–Architecture Overview</a></li>
<li><a href="https://blog.csdn.net/dandandeshangni/article/details/78959131" target="_blank" rel="external">Spring Security源码分析一：Spring Security认证过程</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：有了Spring作为基础，Spring家族的很多框架都显得那么棒，尤其是Springboot的出现，简化了配置，家族框架就显得更棒了，我们这次分析一下其中的SpringSecurity，我们会由请求认证过程，来分析其中的各个组件！
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="SpringSecurity" scheme="http://bestlixiang.site/tags/SpringSecurity/"/>
    
  </entry>
  
  <entry>
    <title>揭秘SpringBoot(一)_SpringBoot运行原理</title>
    <link href="http://bestlixiang.site/2018/04/21/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98SpringBoot-%E4%B8%80-SpringBoot%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://bestlixiang.site/2018/04/21/深入SSM/揭秘SpringBoot-一-SpringBoot运行原理/</id>
    <published>2018-04-21T05:11:48.000Z</published>
    <updated>2018-04-21T05:12:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：可能你早已开始使用SpringBoot，但是你却不知道SpringBoot是个什么东西，他又是怎么运行的，这里给你答案！<a id="more"></a></p>
<h1 id="SpringBoot是什么"><a href="#SpringBoot是什么" class="headerlink" title="SpringBoot是什么"></a>SpringBoot是什么</h1><p>用过Spring的人都知道，你肯定需要些很多很多的XML来用配置复杂的依赖关系，你肯定厌倦了。这个时候SpringBoot出现了，<br><strong>SpringBoot</strong>是由Pivotal团队提供的全新框架，其<strong>设计目的是用来简化新Spring应用的初始搭建以及开发过程</strong>。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置（想想肯定会很开心）。</p>
<h2 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h2><p><strong>习惯优于配置</strong></p>
<h2 id="SpringBoot与Spring-Framework的区别"><a href="#SpringBoot与Spring-Framework的区别" class="headerlink" title="SpringBoot与Spring Framework的区别"></a>SpringBoot与Spring Framework的区别</h2><p>做个下面的<strong>比喻</strong>：</p>
<p><strong>SpringFramework</strong> 就像一个大型电子器件生产公司，它生产的电子器件（比如zookeeper，redis等整合包）都很优秀，当其他小公司（开发者）生产机器人（项目）需要使用到它的电子器件时，就发现需要大量的焊接工作（配置XML）来连接自己的电子器件（zookeeper，redis），这样真的太耗时了，而<strong>SpringBoot</strong> 就像这个电子器件生产公司在原来电子器件的基础上包装出来的许多统一的插口（各种starter），这些插头可以与小公司的电子器件可以直接连接，不需要焊接工作就可以直接使用。</p>
<p>通过上面的比喻我们可以了解到他们两者的区别，也发现其实SpringBoot并不是什么新东西，它只是原来Spring的基础上重新包装过，从而简化了Spring的相关配置。</p>
<h2 id="SpringBoot的核心功能"><a href="#SpringBoot的核心功能" class="headerlink" title="SpringBoot的核心功能"></a>SpringBoot的核心功能</h2><ol>
<li>SpringBoot可以以jar包的形式<strong>独立运行</strong>，因为SpringBoot内嵌Servlet容器，如Tomcat、Jetty。</li>
<li>Spring会根据类路径中的jar包、类，为jar包里的类自动配置Bean，极大减少了我们要使用的配置。</li>
<li>提供starter(起动机)简化了Maven配置(依赖加载)，一个starter依赖抵了好几个依赖。</li>
</ol>
<h1 id="SpringBoot运行原理"><a href="#SpringBoot运行原理" class="headerlink" title="SpringBoot运行原理"></a>SpringBoot运行原理</h1><ol>
<li><p>对于SpringBoot工程我们总是先看到它的启动类，如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootLoginApplication</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		SpringApplication.run(SpringbootLoginApplication.class, args);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对于SpringBoot的运作原理，我们应该先从启动类的@SpringBootApplication注解来分析，这个注解是一个组合注解，我们进入它的源码看看：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@SpringBootConfiguration</span></div><div class="line"><span class="meta">@EnableAutoConfiguration</span></div><div class="line"><span class="meta">@ComponentScan</span>(</div><div class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</div><div class="line">    type = FilterType.CUSTOM,</div><div class="line">    classes = &#123;TypeExcludeFilter.class&#125;</div><div class="line">), <span class="meta">@Filter</span>(</div><div class="line">    type = FilterType.CUSTOM,</div><div class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</div><div class="line">)&#125;</div><div class="line">)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</div><div class="line">    <span class="meta">@AliasFor</span>(</div><div class="line">        annotation = EnableAutoConfiguration.class</div><div class="line">    )</div><div class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="meta">@AliasFor</span>(</div><div class="line">        annotation = EnableAutoConfiguration.class</div><div class="line">    )</div><div class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="meta">@AliasFor</span>(</div><div class="line">        annotation = ComponentScan.class,</div><div class="line">        attribute = <span class="string">"basePackages"</span></div><div class="line">    )</div><div class="line">    String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="meta">@AliasFor</span>(</div><div class="line">        annotation = ComponentScan.class,</div><div class="line">        attribute = <span class="string">"basePackageClasses"</span></div><div class="line">    )</div><div class="line">    Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 总得来说最重要的就是@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan这三个注解，我们一个个分析：</p>
<ol>
<li><p>@SpringBootConfiguration</p>
<p> 我们进入该注解，我发现它的代码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 你会发现其核心注解就是@Configuration，它对于我们来说应该不陌生，因为它就是Java配置形式的Spring Ioc容器的配置类使用的那个@Configuration（相当于XML配置文件的一个Bean），SpringBoot社区推荐使用基于JavaConfig的配置形式，所以，这里的启动类标注了@Configuration之后，本身其实也是一个IoC容器的配置类。</p>
</li>
<li><p>@ComponentScan</p>
<p> 这个注解很简单，很常见，但是也很<strong>重要</strong>。它主要的作用就是自动扫描并加载符合条件的组件（比如@Controller和@Service等）或者bean定义，最终将这些bean定义加载到IoC容器中。我们看看它的源码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Repeatable</span>(ComponentScans.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ComponentScan &#123;</div><div class="line"><span class="comment">// 设置默认路径</span></div><div class="line"><span class="meta">@AliasFor</span>(<span class="string">"basePackages"</span>)</div><div class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"><span class="comment">// 如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。</span></div><div class="line"><span class="comment">// 所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。</span></div><div class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</div><div class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</div><div class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</div><div class="line">Class&lt;? extends BeanNameGenerator&gt; nameGenerator() <span class="keyword">default</span> BeanNameGenerator.class;</div><div class="line">Class&lt;? extends ScopeMetadataResolver&gt; scopeResolver() <span class="keyword">default</span> AnnotationScopeMetadataResolver.class;</div><div class="line"><span class="function">ScopedProxyMode <span class="title">scopedProxy</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.DEFAULT</span>;</div><div class="line"><span class="comment">// 扫描类型</span></div><div class="line"><span class="function">String <span class="title">resourcePattern</span><span class="params">()</span> <span class="keyword">default</span> "**<span class="comment">/*.class";</span></span></div><div class="line">// 可设置过滤器</div><div class="line">boolean useDefaultFilters() default true;</div><div class="line">ComponentScan.Filter[] includeFilters() default &#123;&#125;;</div><div class="line">ComponentScan.Filter[] excludeFilters() default &#123;&#125;;</div><div class="line">// 配置懒加载，如果没被使用，就先不生成Bean</div><div class="line">boolean lazyInit() default false;</div><div class="line"></div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Target(&#123;&#125;)</div><div class="line">public @interface Filter &#123;</div><div class="line">    FilterType type() default FilterType.ANNOTATION;</div><div class="line"></div><div class="line">    @AliasFor("classes")</div><div class="line">    Class&lt;?&gt;[] value() default &#123;&#125;;</div><div class="line"></div><div class="line">    @AliasFor("value")</div><div class="line">    Class&lt;?&gt;[] classes() default &#123;&#125;;</div><div class="line"></div><div class="line">    String[] pattern() default &#123;&#125;;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>@EnableAutoConfiguration</p>
<p> 这个注解可以说是SpringBoot自动配置的核心了，<strong>灰常重要</strong>。我们进去看一下它的源码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@AutoConfigurationPackage</span></div><div class="line"><span class="comment">// 借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器</span></div><div class="line"><span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</div><div class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</div><div class="line"></div><div class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 我们需要好好看看AutoConfigurationImportSelector，它利用SpringFactoriesLoader.loadFactoryNames方法来扫描具有META-INF/spring.factories 文件的jar包，代码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</div><div class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</div><div class="line"><span class="keyword">return</span> configurations;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 配合@EnableAutoConfiguration使用的话，它更多是提供一种配置查找的功能支持，即根据@EnableAutoConfiguration的完整类名如org.springframework.boot.autoconfigure.EnableAutoConfiguration作为查找的Key,<strong>获取对应的一组@Configuration类</strong>，并将其中org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的配置项实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个（相当于一个XML文件）并加载到IoC容器（和Spring一样）。</p>
<p> 我们可以看看spring-boot-autoconfigure.jar 里就有一个spring.factories 文件，此文件中声明了有哪些自动配置。我们看一点点：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Auto Configure</div><div class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</div><div class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</div><div class="line"># 配置AOP对象</div><div class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>看完@SpringBootApplication注解，我们再看看SpringApplication的run方法。</p>
<ol>
<li><p>我们通过debug发现将进入这个方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 会先创建SpringApplication对象实例，然后调用它的实例run方法</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> SpringApplication(primarySources)).run(args);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>我们看看在实例初始化的过程中他做了什么：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class... primarySources)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.sources = <span class="keyword">new</span> LinkedHashSet();</div><div class="line">    <span class="comment">// banner的打印模式，此时是控制台模式</span></div><div class="line">    <span class="keyword">this</span>.bannerMode = Mode.CONSOLE;</div><div class="line">    <span class="comment">// 开启日志</span></div><div class="line">    <span class="keyword">this</span>.logStartupInfo = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">// 启用CommandLineProperties</span></div><div class="line">    <span class="keyword">this</span>.addCommandLineProperties = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">// 开启headless模式支持，Headless模式是在缺少显示屏、键盘或者鼠标时的系统配置（自行了解）</span></div><div class="line">    <span class="keyword">this</span>.headless = <span class="keyword">true</span></div><div class="line">    <span class="comment">// 启用注册ShutdownHook，用于在非Web应用中关闭IoC容器和资源</span></div><div class="line">    <span class="keyword">this</span>.registerShutdownHook = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">this</span>.additionalProfiles = <span class="keyword">new</span> HashSet();</div><div class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</div><div class="line">    <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet(Arrays.asList(primarySources));</div><div class="line">    <span class="comment">// 判断是否是web运行环境(Servlet)</span></div><div class="line">    <span class="keyword">this</span>.webApplicationType = <span class="keyword">this</span>.deduceWebApplicationType();</div><div class="line">    <span class="comment">// 设置初始化器(在META-INF/spring.factories 文件里，可扩展)</span></div><div class="line">    <span class="keyword">this</span>.setInitializers(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));</div><div class="line">    <span class="comment">// 设置监听器(在META-INF/spring.factories 文件里，可扩展)</span></div><div class="line">    <span class="keyword">this</span>.setListeners(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationListener.class));</div><div class="line">    <span class="comment">// 推断并设置main方法的定义类</span></div><div class="line">    <span class="keyword">this</span>.mainApplicationClass = <span class="keyword">this</span>.deduceMainApplicationClass();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑，如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 开启任务执行时间监听器</span></div><div class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</div><div class="line">    stopWatch.start();</div><div class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</div><div class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList();</div><div class="line">    <span class="comment">// 设置系统属性</span></div><div class="line">    <span class="keyword">this</span>.configureHeadlessProperty();</div><div class="line">    <span class="comment">//开启广播，宣告SpringBoot要开始执行了</span></div><div class="line">    SpringApplicationRunListeners listeners = <span class="keyword">this</span>.getRunListeners(args);</div><div class="line">    listeners.starting();</div><div class="line"></div><div class="line">    Collection exceptionReporters;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</div><div class="line">        <span class="comment">// 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。</span></div><div class="line">        ConfigurableEnvironment environment = <span class="keyword">this</span>.prepareEnvironment(listeners, applicationArguments);</div><div class="line">        <span class="comment">// 宣告SpringBoot应用使用的Environment准备好了。</span></div><div class="line">        <span class="keyword">this</span>.configureIgnoreBeanInfo(environment);</div><div class="line">        <span class="comment">// 决定是否打印Banner</span></div><div class="line">        Banner printedBanner = <span class="keyword">this</span>.printBanner(environment);</div><div class="line">        <span class="comment">// 根据用户是否明确设置了applicationContextClass类型，决定该为当前SpringBoot应用创建什么类型的ApplicationContext</span></div><div class="line">        <span class="comment">// 然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，</span></div><div class="line">        <span class="comment">// 最重要的是将之前准备好的Environment设置给创建好的ApplicationContext使用。</span></div><div class="line">        context = <span class="keyword">this</span>.createApplicationContext();</div><div class="line">        <span class="comment">// 得到异常报告者</span></div><div class="line">        exceptionReporters = <span class="keyword">this</span>.getSpringFactoriesInstances(SpringBootExceptionReporter.class, <span class="keyword">new</span> Class[]&#123;ConfigurableApplicationContext.class&#125;, <span class="keyword">new</span> Object[]&#123;context&#125;);</div><div class="line">        <span class="comment">// ApplicationContext创建好之后，遍历调用ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</span></div><div class="line">        <span class="comment">// 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</span></div><div class="line">        <span class="comment">// 将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext</span></div><div class="line">        <span class="comment">// (很重要，可以进入看看)</span></div><div class="line">        <span class="keyword">this</span>.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</div><div class="line">        <span class="comment">// 初始化所有自动配置类，调用ApplicationContext的refresh()方法</span></div><div class="line">        <span class="keyword">this</span>.refreshContext(context);</div><div class="line">        <span class="comment">// 调用所有的SpringApplicationRunListener的finished()方法，宣告SpringBoot已经完成了ApplicationContext初始化的全部过程。</span></div><div class="line">        <span class="keyword">this</span>.afterRefresh(context, applicationArguments);</div><div class="line">        <span class="comment">//关闭任务执行时间监听器</span></div><div class="line">        stopWatch.stop();</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logStartupInfo) &#123;</div><div class="line">            <span class="comment">// //如果开启日志，则打印执行的时间</span></div><div class="line">            (<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)).logStarted(<span class="keyword">this</span>.getApplicationLog(), stopWatch);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        listeners.started(context);</div><div class="line">        <span class="keyword">this</span>.callRunners(context, applicationArguments);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</div><div class="line">        <span class="comment">// //调用异常分析器打印报告，调用所有的SpringApplicationRunListener的finished()方法将异常信息发布出去</span></div><div class="line">        <span class="keyword">this</span>.handleRunFailure(context, var10, exceptionReporters, listeners);</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var10);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        listeners.running(context);</div><div class="line">        <span class="keyword">return</span> context;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</div><div class="line">        <span class="keyword">this</span>.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var9);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnblogs.com/zheting/p/6707035.html" target="_blank" rel="external">Spring Boot干货系列：（三）启动原理解析</a></li>
<li><a href="https://www.jianshu.com/p/cb5cb5937686" target="_blank" rel="external">Spring Boot学习笔记03–深入了解SpringBoot的启动过程</a></li>
<li><a href="https://blog.csdn.net/hengyunabc/article/details/50120001" target="_blank" rel="external">spring boot应用启动原理分析</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：可能你早已开始使用SpringBoot，但是你却不知道SpringBoot是个什么东西，他又是怎么运行的，这里给你答案！
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="SpringBoot" scheme="http://bestlixiang.site/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>HelloWorld_SSMLogin</title>
    <link href="http://bestlixiang.site/2018/04/17/HelloWorld/HelloWorld-SSMLogin/"/>
    <id>http://bestlixiang.site/2018/04/17/HelloWorld/HelloWorld-SSMLogin/</id>
    <published>2018-04-17T10:55:22.000Z</published>
    <updated>2018-04-17T11:01:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：想着怎么教一个人快速入门SSM，讲原理是真的太费时间，还是以搭建具体流程加上源码比较好吧，先模仿，后创新嘛！<a id="more"></a></p>
<h1 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h1><p><strong><a href="https://github.com/todorex/SSM_LoginDemo" target="_blank" rel="external">项目仓库地址</a></strong></p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/helloworld/png/ssm.png" alt="ssm"></p>
<p>我们先把文件夹创建好，当然也可以先直接从我<a href="https://github.com/todorex/SSM_LoginDemo" target="_blank" rel="external">仓库地址</a>把它克隆下来，删除其中部分的代码文件。</p>
<h1 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h1><p><strong>配置文件里面都有注释，大家可以对照着看：</strong></p>
<h2 id="pom-xml文件"><a href="#pom-xml文件" class="headerlink" title="pom.xml文件"></a>pom.xml文件</h2><p>pom文件作为Maven工程的核心，主要是用来引入jar包的，在我的pom文件中也详细列出了我们需要哪些包，以及哪些包是用来干什么的。</p>
<h2 id="web-xml文件"><a href="#web-xml文件" class="headerlink" title="web.xml文件"></a>web.xml文件</h2><p>web.xml作为Web功能的核心，主要是设置了如何接受请求，这里会结合SpringMVC的前端控制器类DispatcherServlet作为请求分发的核心Servlet，以及在第一次加载过程中，后台服务需要加载哪些配置文件。</p>
<h2 id="ssm配置文件（依靠Spring整合）"><a href="#ssm配置文件（依靠Spring整合）" class="headerlink" title="ssm配置文件（依靠Spring整合）"></a>ssm配置文件（依靠Spring整合）</h2><p>我们看到spring文件夹下有三个文件，分别对应了dao，service，web三层的Bean配置。</p>
<h3 id="spring-dao-config-xml文件"><a href="#spring-dao-config-xml文件" class="headerlink" title="spring-dao-config.xml文件"></a>spring-dao-config.xml文件</h3><p>这里主要是配置数据库连接池（数据源），以及注入SqlSessionFactory和所有在com.todorex.dao下得所有Dao接口。</p>
<h3 id="spring-service-config-xml文件"><a href="#spring-service-config-xml文件" class="headerlink" title="spring-service-config.xml文件"></a>spring-service-config.xml文件</h3><p>这里主要配置扫描并注入com.todorex.service包下所有Service注解类，以及配置事务管理器。</p>
<h3 id="spring-web-config-xml文件"><a href="#spring-web-config-xml文件" class="headerlink" title="spring-web-config.xml文件"></a>spring-web-config.xml文件</h3><p>这里主要配置扫描并注入com.todorex.controller包下所有Controller注解类，以及配置视图解析器。这里还有一个超级重要的就是配置处理静态资源的方式。</p>
<h2 id="mybatis-config-xml文件"><a href="#mybatis-config-xml文件" class="headerlink" title="mybatis-config.xml文件"></a>mybatis-config.xml文件</h2><p>这里主要是设置mybatis的全局属性。</p>
<h2 id="jdbc-properties文件"><a href="#jdbc-properties文件" class="headerlink" title="jdbc.properties文件"></a>jdbc.properties文件</h2><p>这里主要配置数据库连接的相关信息。</p>
<h2 id="log4j-properties文件"><a href="#log4j-properties文件" class="headerlink" title="log4j.properties文件"></a>log4j.properties文件</h2><p>这里主要配置日志记录的相关信息。</p>
<p>配置文件都配置完了，我们终于可以开始写代码了!</p>
<h1 id="SSM代码"><a href="#SSM代码" class="headerlink" title="SSM代码"></a>SSM代码</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>实现用户的登录与注销。</p>
<h2 id="上帝视角开发（我需要什么就造什么）"><a href="#上帝视角开发（我需要什么就造什么）" class="headerlink" title="上帝视角开发（我需要什么就造什么）"></a>上帝视角开发（我需要什么就造什么）</h2><h3 id="我需要一个能处理我的请求（URL）的Controller"><a href="#我需要一个能处理我的请求（URL）的Controller" class="headerlink" title="我需要一个能处理我的请求（URL）的Controller"></a>我需要一个能处理我的请求（URL）的Controller</h3><p>知道要controller，我们就造一个，我们在com.todorex.controller包下新建一个LoginController类。</p>
<p>Controller的作用主要是根据你请求的URL来做不同的事（对应的方法），结果是返回一个ModelAndView（当然View和Model也可以分开），如果方法的逻辑只是页面间的跳转和简单数据处理，我们就用不到Service了，如过我们需要进行业务处理以及操作数据库，那么我们就需要用到Service了。</p>
<p>PS：这里需要注意请求转发和请求重定向的区别（注释中有）</p>
<h3 id="我需要一个能处理业务的Service"><a href="#我需要一个能处理业务的Service" class="headerlink" title="我需要一个能处理业务的Service"></a>我需要一个能处理业务的Service</h3><p>在service层设计一个好的接口是至关重要的（我们还是HelloWorld，以后有经验了自然能设计得好一些），如果实现类有多个的话 ，可以用@Service(“userService1”)来注入，@Resource(name=”userService1”) 来对应获取。在处理业务逻辑的时候，一般都会涉及到数据库操作，这个时候我们就需要用到Dao了。</p>
<h3 id="我需要一个能处理数据的Dao"><a href="#我需要一个能处理数据的Dao" class="headerlink" title="我需要一个能处理数据的Dao"></a>我需要一个能处理数据的Dao</h3><p>这里我们要明确一点：一个Dao接口对应一个Mapper文件，Dao定义接口方法，Mapper文件实现该方法的sql语句。</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>这里我们举一个例子，就是记录登录用户的名字和时间，看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</div><div class="line">    <span class="comment">// 获得日志对象</span></div><div class="line">    Logger logger = Logger.getLogger(LoginController.class);</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/checkLogin"</span>,method = RequestMethod.POST)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">checkLogin</span><span class="params">(User user, Model model)</span> </span>&#123;</div><div class="line">        user = userService.checkLogin(user.getUsername(),user.getPassword());</div><div class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 日志记录用户登录</span></div><div class="line">            logger.info(user.getUsername()+<span class="string">"在"</span>+<span class="keyword">new</span> Date() + <span class="string">"登录过!"</span>);</div><div class="line">            model.addAttribute(<span class="string">"user"</span>,user);</div><div class="line">            <span class="keyword">return</span> <span class="string">"redirect:/success"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"redirect:/fail"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol>
<li><p>配置一个基类（用于加载配置文件）</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class) <span class="comment">//使用junit4进行测试</span></div><div class="line"><span class="comment">// 导入多个配置文件</span></div><div class="line"><span class="meta">@ContextConfiguration</span>(locations=&#123;<span class="string">"classpath:spring/spring-*.xml"</span>,<span class="string">"classpath:mybatis-config.xml"</span>&#125;) <span class="comment">//加载配置文件</span></div><div class="line"><span class="comment">//所有继承该类的测试类都会遵循该配置</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseJunit4Test</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在各个对应的包下建立单元测试，如;</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> <span class="keyword">extends</span> <span class="title">BaseJunit4Test</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserDao userDao;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFindByUsername</span><span class="params">()</span> </span>&#123;</div><div class="line">        User user = userDao.findByUsername(<span class="string">"rex"</span>);</div><div class="line">        System.out.println(user);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="页面编写"><a href="#页面编写" class="headerlink" title="页面编写"></a>页面编写</h1><p>这里只举一个例子（其实主要就是jsp的用法）,success.jsp:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</div><div class="line">         pageEncoding=&quot;UTF-8&quot;%&gt;</div><div class="line">&lt;%--引入jstl标签库，很重要--%&gt;</div><div class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;</div><div class="line"> &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Insert title here&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;!--添加背景图片--&gt;</div><div class="line">&lt;body background=&quot;image/success.jpg&quot;&gt;</div><div class="line"></div><div class="line">&lt;div style=&quot;margin: auto&quot;&gt;</div><div class="line">&lt;div&gt;</div><div class="line">    &lt;%--利用jstl标签获取session中的user的值--%&gt;</div><div class="line">    &lt;strong style=&quot;font-size: 100px;color: red&quot;&gt; $&#123;sessionScope.user.username&#125;!&lt;/strong&gt;</div><div class="line">    &lt;strong style=&quot;font-size: 100px;color: blue&quot;&gt; ，你他妈登录成功了&lt;/strong&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;form action=&quot;/LoginDemo/outLogin&quot; &gt;</div><div class="line">    &lt;button type=&quot;submit&quot; class=&quot;btn btn-success col-lg-12&quot; style=&quot;font-size: 100px;text-align: center&quot;&gt;退出登录&lt;/button&gt;</div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p><strong>终于大功告成！！！</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/s740556472/article/details/71247285" target="_blank" rel="external">SSM搭建(整合)+用户模块(登录和注销)实现</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：想着怎么教一个人快速入门SSM，讲原理是真的太费时间，还是以搭建具体流程加上源码比较好吧，先模仿，后创新嘛！
    
    </summary>
    
      <category term="HelloWorld" scheme="http://bestlixiang.site/categories/HelloWorld/"/>
    
    
      <category term="Spring" scheme="http://bestlixiang.site/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="http://bestlixiang.site/tags/SpringMVC/"/>
    
      <category term="Mybatis" scheme="http://bestlixiang.site/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Mybatis(二)_Mybatis工作原理</title>
    <link href="http://bestlixiang.site/2018/04/16/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Mybatis-%E4%BA%8C-Mybatis%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://bestlixiang.site/2018/04/16/深入SSM/揭秘Mybatis-二-Mybatis工作原理/</id>
    <published>2018-04-16T07:38:03.000Z</published>
    <updated>2018-04-16T07:38:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：了解完Mybatis的架构，那么它的执行流程又是怎么样的呢？<a id="more"></a></p>
<h1 id="Mybatis主要组件及工作流程"><a href="#Mybatis主要组件及工作流程" class="headerlink" title="Mybatis主要组件及工作流程"></a>Mybatis主要组件及工作流程</h1><h2 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h2><ol>
<li>Configuration：MyBatis所有的配置信息都维持在Configuration对象之中</li>
<li>SqlSession：作为MyBatis接口层的AOP，表示和数据库交互的会话，完成必要数据库增删改查功能</li>
<li>Executor：MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护</li>
<li>StatementHandler：封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合</li>
<li>ParameterHandler：负责对用户传递的参数转换成JDBC Statement 所需要的参数</li>
<li>resultSetHandler：负责将JDBC返回的ResultSet结果集对象转换成List类型的集合</li>
<li>TypeHandler：负责java数据类型和jdbc数据类型之间的映射和转换</li>
<li>MappedStatement：MappedStatement维护了一条<select|update|delete|insert>节点的封装</select|update|delete|insert></li>
<li>SqlSource：负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回</li>
<li>BoundSql：表示动态生成的SQL语句以及相应的参数信息</li>
</ol>
<h2 id="工作流程图"><a href="#工作流程图" class="headerlink" title="工作流程图"></a>工作流程图</h2><p><img src="https://upload-images.jianshu.io/upload_images/2062729-a2f20529d6d908a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="workflow"></p>
<p>这张图也超级棒（Nice 兄Dei），在下面参考也将看到出处。我们下面的源码分析也会参考这张图。</p>
<h1 id="Mybatis初始化源码分析"><a href="#Mybatis初始化源码分析" class="headerlink" title="Mybatis初始化源码分析"></a>Mybatis初始化源码分析</h1><ol>
<li><p>获取配置文件创建SqlSessionFactory</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String resource = &quot;mybatis-config.xml&quot;;</div><div class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</div><div class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</div></pre></td></tr></table></figure>
</li>
<li><p>进入到SqlSessionFactory的build方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</div><div class="line">    SqlSessionFactory var5;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 解析刚刚创建的配置文件文件流</span></div><div class="line">        XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</div><div class="line">        var5 = <span class="keyword">this</span>.build(parser.parse());</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception var14) &#123;</div><div class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, var14);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        ErrorContext.instance().reset();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            inputStream.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException var13) &#123;</div><div class="line">            ;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> var5;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>会进入到XMLConfigBuilder的parse方法去解析配置文件的具体内容生成Configuration对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.parsed) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.parsed = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">// 解析配置文件</span></div><div class="line">        <span class="keyword">this</span>.parseConfiguration(<span class="keyword">this</span>.parser.evalNode(<span class="string">"/configuration"</span>));</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.configuration;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 解析&lt;properties&gt;节点，数据源配置文件</span></div><div class="line">        <span class="keyword">this</span>.propertiesElement(root.evalNode(<span class="string">"properties"</span>));</div><div class="line">        <span class="comment">// 解析&lt;typeAliases&gt;节点，别名节点</span></div><div class="line">        <span class="keyword">this</span>.typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</div><div class="line">        <span class="comment">// 解析&lt;plugins&gt;节点，插件节点</span></div><div class="line">        <span class="keyword">this</span>.pluginElement(root.evalNode(<span class="string">"plugins"</span>));</div><div class="line">        <span class="comment">// 解析&lt;objectFactory&gt;节点</span></div><div class="line">        <span class="keyword">this</span>.objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</div><div class="line">        <span class="comment">// 解析&lt;reflectorFactory&gt;节点</span></div><div class="line">        <span class="keyword">this</span>.objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</div><div class="line">        <span class="comment">// 解析&lt;settings&gt;节点</span></div><div class="line">        <span class="keyword">this</span>.settingsElement(root.evalNode(<span class="string">"settings"</span>));</div><div class="line">        <span class="comment">// 解析&lt;environments&gt;节点</span></div><div class="line">        <span class="keyword">this</span>.environmentsElement(root.evalNode(<span class="string">"environments"</span>));</div><div class="line">        <span class="keyword">this</span>.databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</div><div class="line">        <span class="keyword">this</span>.typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</div><div class="line">        <span class="comment">// 解析&lt;mappers&gt;节点，很重要</span></div><div class="line">        <span class="keyword">this</span>.mapperElement(root.evalNode(<span class="string">"mappers"</span>));</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception var3) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + var3, var3);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>我们最关心的可能就是mapper的解析了，所以我们进入mapperElement方法看看：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</div><div class="line">            Iterator i$ = parent.getChildren().iterator();</div><div class="line"></div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">                <span class="comment">// 遍历&lt;mappers&gt;下所有子节点</span></div><div class="line">                <span class="keyword">while</span>(i$.hasNext()) &#123;</div><div class="line">                    XNode child = (XNode)i$.next();</div><div class="line">                    String resource;</div><div class="line">                    <span class="comment">// 如果当前节点为&lt;package&gt;</span></div><div class="line">                    <span class="keyword">if</span>(<span class="string">"package"</span>.equals(child.getName())) &#123;</div><div class="line">                        <span class="comment">// 获取&lt;package&gt;的name属性（该属性值为mapper class所在的包名）</span></div><div class="line">                        resource = child.getStringAttribute(<span class="string">"name"</span>);</div><div class="line">                        <span class="comment">// 将该包下的所有Mapper Class注册到configuration的mapperRegistry容器中</span></div><div class="line">                        <span class="keyword">this</span>.configuration.addMappers(resource);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// 依次获取resource、url、class属性</span></div><div class="line">                        resource = child.getStringAttribute(<span class="string">"resource"</span>);</div><div class="line">                        String url = child.getStringAttribute(<span class="string">"url"</span>);</div><div class="line">                        String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</div><div class="line">                        XMLMapperBuilder mapperParser;</div><div class="line">                        InputStream inputStream;</div><div class="line">                        <span class="comment">// 解析resource属性（Mapper.xml文件的路径）</span></div><div class="line">                        <span class="keyword">if</span>(resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</div><div class="line">                            ErrorContext.instance().resource(resource);</div><div class="line">                            <span class="comment">// 将Mapper.xml文件解析成输入流</span></div><div class="line">                            inputStream = Resources.getResourceAsStream(resource);</div><div class="line">                            <span class="comment">// 使用XMLMapperBuilder解析Mapper.xml，并将Mapper Class注册进configuration对象的mapperRegistry容器中</span></div><div class="line">                            mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, <span class="keyword">this</span>.configuration, resource, <span class="keyword">this</span>.configuration.getSqlFragments());</div><div class="line">                            <span class="comment">// 这个很重要，看看具体怎么解析</span></div><div class="line">                            mapperParser.parse();</div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</div><div class="line">                            <span class="comment">// 解析url属性（Mapper.xml文件的路径）</span></div><div class="line">                            ErrorContext.instance().resource(url);</div><div class="line">                            inputStream = Resources.getUrlAsStream(url);</div><div class="line">                            mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, <span class="keyword">this</span>.configuration, url, <span class="keyword">this</span>.configuration.getSqlFragments());</div><div class="line">                            mapperParser.parse();</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="comment">// 解析class属性（Mapper Class的全限定名）</span></div><div class="line">                            <span class="keyword">if</span>(resource != <span class="keyword">null</span> || url != <span class="keyword">null</span> || mapperClass == <span class="keyword">null</span>) &#123;</div><div class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</div><div class="line">                            &#125;</div><div class="line">                            <span class="comment">// 将Mapper Class的权限定名转化成Class对象</span></div><div class="line">                            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</div><div class="line">                            <span class="keyword">this</span>.configuration.addMapper(mapperInterface);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.configuration.isResourceLoaded(<span class="keyword">this</span>.resource)) &#123;</div><div class="line">        <span class="comment">// 解析&lt;mapper&gt;节点</span></div><div class="line">        <span class="keyword">this</span>.configurationElement(<span class="keyword">this</span>.parser.evalNode(<span class="string">"/mapper"</span>));</div><div class="line">        <span class="comment">// 将该Mapper.xml添加至configuration的LoadedResource容器中，下回无需再解析</span></div><div class="line">        <span class="keyword">this</span>.configuration.addLoadedResource(<span class="keyword">this</span>.resource);</div><div class="line">        <span class="comment">// 将该Mapper.xml对应的Mapper Class注册进configuration的mapperRegistry容器中，很重要，下马需要仔细看看</span></div><div class="line">        <span class="keyword">this</span>.bindMapperForNamespace();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.parsePendingResultMaps();</div><div class="line">    <span class="keyword">this</span>.parsePendingChacheRefs();</div><div class="line">    <span class="keyword">this</span>.parsePendingStatements();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>bindMapperForNamespace极其重要，因为这里会给Mapper接口创建动态代理对象，我们看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMapperForNamespace</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 获取当前映射文件对应的DAO接口的全限定名</span></div><div class="line">        String namespace = <span class="keyword">this</span>.builderAssistant.getCurrentNamespace();</div><div class="line">        <span class="keyword">if</span>(namespace != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 将全限定名解析成Class对象</span></div><div class="line">            Class boundType = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                boundType = Resources.classForName(namespace);</div><div class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var4) &#123;</div><div class="line">                ;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(boundType != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.configuration.hasMapper(boundType)) &#123;</div><div class="line">                <span class="comment">// 将当前Mapper.xml标注为已加载下回就不用再加载了</span></div><div class="line">                <span class="keyword">this</span>.configuration.addLoadedResource(<span class="string">"namespace:"</span> + namespace);</div><div class="line">                <span class="comment">// 将Mapper接口的Class对象注册进configuration中（其实是在configuration的MapperRegistry里面）</span></div><div class="line">                <span class="keyword">this</span>.configuration.addMapper(boundType);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>我们再进入到this.configuration.addMapper方法中看看会做些什么：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.mapperRegistry.addMapper(type);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(type.isInterface()) &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.hasMapper(type)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is already known to the MapperRegistry."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 创建MapperProxyFactory对象（用于创建DAO接口的代理对象），并put进knownMappers中</span></div><div class="line">            <span class="comment">// 为后面的创建Mapper代理对象做准备</span></div><div class="line">            <span class="keyword">this</span>.knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory(type));</div><div class="line">            MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(<span class="keyword">this</span>.config, type);</div><div class="line">            parser.parse();</div><div class="line">            loadCompleted = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span>(!loadCompleted) &#123;</div><div class="line">                <span class="keyword">this</span>.knownMappers.remove(type);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>等Mapper全都解析好之后，初始化工作基本就完成了。</p>
</li>
</ol>
<h1 id="Mybatis工作流程源码分析"><a href="#Mybatis工作流程源码分析" class="headerlink" title="Mybatis工作流程源码分析"></a>Mybatis工作流程源码分析</h1><ol>
<li><p>创建SqlSession对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 从数据源创建SqlSession会话对象</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.openSessionFromDataSource(<span class="keyword">this</span>.configuration.getDefaultExecutorType(), (TransactionIsolationLevel)<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</div><div class="line">    Transaction tx = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    DefaultSqlSession var8;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 初始化读取了Environment里面的数据源以及事务配置</span></div><div class="line">        Environment environment = <span class="keyword">this</span>.configuration.getEnvironment();</div><div class="line">        <span class="comment">// 获取事务工厂</span></div><div class="line">        TransactionFactory transactionFactory = <span class="keyword">this</span>.getTransactionFactoryFromEnvironment(environment);</div><div class="line">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</div><div class="line">        <span class="comment">// 生成MyBatis执行器</span></div><div class="line">        Executor executor = <span class="keyword">this</span>.configuration.newExecutor(tx, execType);</div><div class="line">        <span class="comment">// 创建DefaultSqlSession对象</span></div><div class="line">        var8 = <span class="keyword">new</span> DefaultSqlSession(<span class="keyword">this</span>.configuration, executor, autoCommit);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception var12) &#123;</div><div class="line">        <span class="keyword">this</span>.closeTransaction(tx);</div><div class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + var12, var12);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        ErrorContext.instance().reset();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> var8;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>从SqlSession对象获得Mapper（后面会看到这是个代理对象），看看执行流程：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</div><div class="line">    <span class="comment">// 进入configuration</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.configuration.getMapper(type, <span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</div><div class="line">    <span class="comment">// 调用configuration对象的apperRegistry的getMapper方法</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mapperRegistry.getMapper(type, sqlSession);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</div><div class="line">    <span class="comment">// 这个是在初始化过程中解析mapper时生成的，现有看到了Mapper对象的工厂</span></div><div class="line">    MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory)<span class="keyword">this</span>.knownMappers.get(type);</div><div class="line">    <span class="keyword">if</span>(mapperProxyFactory == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 生成Mapper实例，进入看看</span></div><div class="line">            <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + var5, var5);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</div><div class="line">    <span class="comment">// 原来这个还是个代理对象</span></div><div class="line">    MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy(sqlSession, <span class="keyword">this</span>.mapperInterface, <span class="keyword">this</span>.methodCache);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.newInstance(mapperProxy);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>获得Mapper代理对象我看看他是怎么执行Mapper接口的方法的：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">List&lt;User&gt; userList = userMapper.selectList();</div><div class="line"></div><div class="line"><span class="comment">// 一进去就发现直接到了invoke方法，相当于把方法的执行都交给了代理对象去执行</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="keyword">if</span>(Object.class.equals(method.getDeclaringClass())) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</div><div class="line">            <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(var5);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 从当前代理对象处理类MapperProxy的methodCache属性中获取MapperMethod对象,如果methodCache中没有就创建并加进去。</span></div><div class="line">        MapperMethod mapperMethod = <span class="keyword">this</span>.cachedMapperMethod(method);</div><div class="line">        <span class="comment">// 该方法就会调用JDBC执行相应的SQL语句</span></div><div class="line">        <span class="keyword">return</span> mapperMethod.execute(<span class="keyword">this</span>.sqlSession, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</div><div class="line">    Object param;</div><div class="line">    Object result;</div><div class="line">    <span class="comment">// 比对mapper标签</span></div><div class="line">    <span class="keyword">if</span>(SqlCommandType.INSERT == <span class="keyword">this</span>.command.getType()) &#123;</div><div class="line">        param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = <span class="keyword">this</span>.rowCountResult(sqlSession.insert(<span class="keyword">this</span>.command.getName(), param));</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(SqlCommandType.UPDATE == <span class="keyword">this</span>.command.getType()) &#123;</div><div class="line">        param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = <span class="keyword">this</span>.rowCountResult(sqlSession.update(<span class="keyword">this</span>.command.getName(), param));</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(SqlCommandType.DELETE == <span class="keyword">this</span>.command.getType()) &#123;</div><div class="line">        param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = <span class="keyword">this</span>.rowCountResult(sqlSession.delete(<span class="keyword">this</span>.command.getName(), param));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(SqlCommandType.SELECT != <span class="keyword">this</span>.command.getType()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + <span class="keyword">this</span>.command.getName());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.method.returnsVoid() &amp;&amp; <span class="keyword">this</span>.method.hasResultHandler()) &#123;</div><div class="line">            <span class="keyword">this</span>.executeWithResultHandler(sqlSession, args);</div><div class="line">            result = <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.method.returnsMany()) &#123;</div><div class="line">            <span class="comment">// 最终会进入这里</span></div><div class="line">            result = <span class="keyword">this</span>.executeForMany(sqlSession, args);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.method.returnsMap()) &#123;</div><div class="line">            result = <span class="keyword">this</span>.executeForMap(sqlSession, args);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</div><div class="line">            result = sqlSession.selectOne(<span class="keyword">this</span>.command.getName(), param);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(result == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.method.getReturnType().isPrimitive() &amp;&amp; !<span class="keyword">this</span>.method.returnsVoid()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + <span class="keyword">this</span>.command.getName() + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + <span class="keyword">this</span>.method.getReturnType() + <span class="string">")."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>MapperMethod到底如何去执行executeForMap(sqlSession, args)的呢？我们可以继续进入：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 将参数拼接到SQL</span></div><div class="line">        Object param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</div><div class="line">        List result;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.method.hasRowBounds()) &#123;</div><div class="line">            RowBounds rowBounds = <span class="keyword">this</span>.method.extractRowBounds(args);</div><div class="line">            result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param, rowBounds);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 进入到这里，让sqlSession来处理</span></div><div class="line">            result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.method.getReturnType().isAssignableFrom(result.getClass())?(<span class="keyword">this</span>.method.getReturnType().isArray()?<span class="keyword">this</span>.convertToArray(result):<span class="keyword">this</span>.convertToDeclaredCollection(sqlSession.getConfiguration(), result)):result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.selectList(statement, parameter, RowBounds.DEFAULT);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</div><div class="line">    List var6;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 根据StatementId(com.todorex.UserMapper.selectList)，</span></div><div class="line">        <span class="comment">// 在配置对象Configuration中查找相对应的MappedStatement</span></div><div class="line">        MappedStatement ms = <span class="keyword">this</span>.configuration.getMappedStatement(statement);</div><div class="line">        <span class="comment">// 将查询任务委托给MyBatis 的执行器 Executor</span></div><div class="line">        List&lt;E&gt; result = <span class="keyword">this</span>.executor.query(ms, <span class="keyword">this</span>.wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</div><div class="line">        var6 = result;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception var10) &#123;</div><div class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + var10, var10);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        ErrorContext.instance().reset();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> var6;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="comment">// 根据具体传入的参数，动态地生成需要执行的SQL语句，用BoundSql对象表示</span></div><div class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);</div><div class="line">    <span class="comment">// 为当前的查询创建一个缓存Key  </span></div><div class="line">    CacheKey key = <span class="keyword">this</span>.createCacheKey(ms, parameterObject, rowBounds, boundSql);</div><div class="line">    <span class="comment">// 再进去</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="comment">// 获得缓存对象</span></div><div class="line">    Cache cache = ms.getCache();</div><div class="line">    <span class="keyword">if</span>(cache != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.flushCacheIfRequired(ms);</div><div class="line">        <span class="keyword">if</span>(ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.ensureNoOutParams(ms, parameterObject, boundSql);</div><div class="line">            <span class="comment">// 如果缓存中有查询结果，则返回查询结果</span></div><div class="line">            List&lt;E&gt; list = (List)<span class="keyword">this</span>.tcm.getObject(cache, key);</div><div class="line">            <span class="keyword">if</span>(list == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// 如果缓存中没有查询结果则查询数据库</span></div><div class="line">                list = <span class="keyword">this</span>.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</div><div class="line">                <span class="comment">// 将查询结果放入缓存中</span></div><div class="line">                <span class="keyword">this</span>.tcm.putObject(cache, key, list);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> list;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果没有缓存对象则查询数据库（进入这里）</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.closed) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</div><div class="line">            <span class="keyword">this</span>.clearLocalCache();</div><div class="line">        &#125;</div><div class="line">        List list;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ++<span class="keyword">this</span>.queryStack;</div><div class="line">            list = resultHandler == <span class="keyword">null</span>?(List)<span class="keyword">this</span>.localCache.getObject(key):<span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span>(list != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">this</span>.handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 缓存中没有值，直接从数据库中读取数据（进入这里）</span></div><div class="line">                list = <span class="keyword">this</span>.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            --<span class="keyword">this</span>.queryStack;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="keyword">this</span>.localCache.putObject(key, ExecutionPlaceholder.EXECUTION_PLACEHOLDER);</div><div class="line">    List list;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 执行查询返回List 结果（进入这里）</span></div><div class="line">        list = <span class="keyword">this</span>.doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// 清楚之前的缓存</span></div><div class="line">        <span class="keyword">this</span>.localCache.removeObject(key);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将查询的结果放入缓存之中</span></div><div class="line">    <span class="keyword">this</span>.localCache.putObject(key, list);</div><div class="line">    <span class="keyword">if</span>(ms.getStatementType() == StatementType.CALLABLE) &#123;</div><div class="line">        <span class="keyword">this</span>.localOutputParameterCache.putObject(key, parameter);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    Statement stmt = <span class="keyword">null</span>;</div><div class="line">    List var9;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Configuration configuration = ms.getConfiguration();</div><div class="line">        <span class="comment">// 创建StatementHandler对象来执行查询操作  </span></div><div class="line">        StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>.wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</div><div class="line">        <span class="comment">// 利用StatementHandler对象创建java.Sql.Statement对象（进入这里）</span></div><div class="line">        stmt = <span class="keyword">this</span>.prepareStatement(handler, ms.getStatementLog());</div><div class="line">        <span class="comment">// 调用StatementHandler.query()方法，返回List结果集 （进入这里）</span></div><div class="line">        var9 = handler.query(stmt, resultHandler);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">this</span>.closeStatement(stmt);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> var9;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="comment">// 创建连接</span></div><div class="line">    Connection connection = <span class="keyword">this</span>.getConnection(statementLog);</div><div class="line">    <span class="comment">// 创建java.Sql.Statement对象，传递给StatementHandler对象</span></div><div class="line">    Statement stmt = handler.prepare(connection);</div><div class="line">    <span class="comment">// 对创建的Statement对象设置参数，即设置SQL语句中占位符设置为指定的参数</span></div><div class="line">    handler.parameterize(stmt);</div><div class="line">    <span class="keyword">return</span> stmt;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="comment">// 调用preparedStatemnt的execute()方法，然后将resultSet交给ResultSetHandler处理</span></div><div class="line">    PreparedStatement ps = (PreparedStatement)statement;</div><div class="line">    ps.execute();</div><div class="line">    <span class="comment">// 使用ResultHandler来处理ResultSet（进入这里）</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.resultSetHandler.handleResultSets(ps);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>终于查询完了，现在可以处理结果了，我们看看handleResultSets(Statement stmt)方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    ErrorContext.instance().activity(<span class="string">"handling results"</span>).object(<span class="keyword">this</span>.mappedStatement.getId());</div><div class="line">    <span class="comment">// 最后的结果集</span></div><div class="line">    List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList();</div><div class="line">    <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</div><div class="line">    ResultSetWrapper rsw = <span class="keyword">this</span>.getFirstResultSet(stmt);</div><div class="line">    List&lt;ResultMap&gt; resultMaps = <span class="keyword">this</span>.mappedStatement.getResultMaps();</div><div class="line">    <span class="keyword">int</span> resultMapCount = resultMaps.size();</div><div class="line">    <span class="keyword">this</span>.validateResultMapsCount(rsw, resultMapCount);</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</div><div class="line">        <span class="comment">// 获得resultMap</span></div><div class="line">        ResultMap resultMap = (ResultMap)resultMaps.get(resultSetCount);</div><div class="line">        <span class="comment">// 这里才开始处理（这里自己去看吧，反正会先处理行值，然后映射成对象，和JDBC一样）</span></div><div class="line">        <span class="keyword">this</span>.handleResultSet(rsw, resultMap, multipleResults, (ResultMapping)<span class="keyword">null</span>);</div><div class="line">        rsw = <span class="keyword">this</span>.getNextResultSet(stmt);</div><div class="line">        <span class="keyword">this</span>.cleanUpAfterHandlingResultSet();</div><div class="line">        ++resultSetCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    String[] resultSets = <span class="keyword">this</span>.mappedStatement.getResulSets();</div><div class="line">    <span class="keyword">if</span>(resultSets != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">while</span>(rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</div><div class="line">            ResultMapping parentMapping = (ResultMapping)<span class="keyword">this</span>.nextResultMaps.get(resultSets[resultSetCount]);</div><div class="line">            <span class="keyword">if</span>(parentMapping != <span class="keyword">null</span>) &#123;</div><div class="line">                String nestedResultMapId = parentMapping.getNestedResultMapId();</div><div class="line">                ResultMap resultMap = <span class="keyword">this</span>.configuration.getResultMap(nestedResultMapId);</div><div class="line">                <span class="keyword">this</span>.handleResultSet(rsw, resultMap, (List)<span class="keyword">null</span>, parentMapping);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            rsw = <span class="keyword">this</span>.getNextResultSet(stmt);</div><div class="line">            <span class="keyword">this</span>.cleanUpAfterHandlingResultSet();</div><div class="line">            ++resultSetCount;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.collapseSingleResultList(multipleResults);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/ec40a82cae28" target="_blank" rel="external">终结篇：MyBatis原理深入解析（一）</a></li>
<li><a href="https://blog.csdn.net/u010425776/article/details/78215845" target="_blank" rel="external"> MyBatis源码解析(二)——动态代理实现函数调用</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：了解完Mybatis的架构，那么它的执行流程又是怎么样的呢？
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Mybatis" scheme="http://bestlixiang.site/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Mybatis(一)_Mybatis架构</title>
    <link href="http://bestlixiang.site/2018/04/16/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Mybatis-%E4%B8%80-Mybatis%E6%9E%B6%E6%9E%84/"/>
    <id>http://bestlixiang.site/2018/04/16/深入SSM/揭秘Mybatis-一-Mybatis架构/</id>
    <published>2018-04-16T07:37:53.000Z</published>
    <updated>2018-04-16T07:38:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：从JDBC到Hibernate再到Mybatis，你可能会使用很多框架，但是你却不知道框架为你解决什么了或是不知道它的整个架构，我们这里就是帮你解决这些问题！<a id="more"></a></p>
<h1 id="为什么要使用Mybatis"><a href="#为什么要使用Mybatis" class="headerlink" title="为什么要使用Mybatis"></a>为什么要使用Mybatis</h1><h2 id="JDBC的使用"><a href="#JDBC的使用" class="headerlink" title="JDBC的使用"></a>JDBC的使用</h2><p>每一个人学Java的数据库操作应该都是从JDBC开始，它基本有以下7个步骤：</p>
<ol>
<li>加载JDBC驱动</li>
<li>建立并获取数据库连接</li>
<li>创建 JDBC Statements 对象</li>
<li>设置SQL语句的传入参数</li>
<li>执行SQL语句并获得查询结果</li>
<li>对查询结果进行转换处理并将处理结果返回；</li>
<li>释放相关资源（关闭Connection，关闭Statement，关闭ResultSet）；</li>
</ol>
<h2 id="JDBC相应的问题"><a href="#JDBC相应的问题" class="headerlink" title="JDBC相应的问题"></a>JDBC相应的问题</h2><ol>
<li>数据库连接频繁的开启和关闭本身就造成了资源的浪费，影响系统的性能</li>
<li>SQL语句基本都散落在各个JAVA类中可读性很差，不利于维护以及做性能调优。</li>
<li>在后台代码中自己需要根据请求的传入参数（参数个数和顺序都不确定）去拼凑相应的SQL语句。</li>
<li>执行SQL语句后，返回的是一个ResultSet结果集，这个时候我们就需要将ResultSet对象的数据取出来，不然等到释放资源时就取不到这些结果信息了。</li>
<li>SQL重复的问题，不利于维护和复用。</li>
</ol>
<h2 id="Mybatis相应的解决"><a href="#Mybatis相应的解决" class="headerlink" title="Mybatis相应的解决"></a>Mybatis相应的解决</h2><ol>
<li>数据库连接的获取和关闭我们可以使用数据库连接池来解决资源浪费的问题。通过连接池就可以反复利用已经建立的连接去访问数据库了。减少连接的开启和关闭的时间。（数据库连接池以及数据源的配置）</li>
<li>将这些SQL语句统一集中放到配置文件或者数据库里面（以key-value的格式存放）。然后通过SQL语句的key值去获取对应的SQL语句。（Mapper文件）</li>
<li>使用一种有别于SQL的语法来嵌入变量（比如使用＃变量名）。这样，SQL语句经过解析后就可以动态的生成符合上下文的SQL语句。（Mapper文件里面的SQL语句）</li>
<li>将结果不做任何处理就直接返回，也有可能将结果转换成一个JavaBean对象返回、一个Map返回、一个List返回等，而且可以将SQL语句和传入参数两部分合起来可以作为数据缓存的key值。（语句标签返回结果的配置）</li>
<li>将重复的代码抽离出来成为独立的一个类，然后在各个需要使用的地方进行引用（SQL代码块）</li>
</ol>
<h1 id="Mybatis架构"><a href="#Mybatis架构" class="headerlink" title="Mybatis架构"></a>Mybatis架构</h1><p><img src="https://upload-images.jianshu.io/upload_images/2062729-58069e90e9c66d5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="mybatis"></p>
<p>这张图超级棒，可以在后面的参考找到出处。我们就按照这个4层进行分析：</p>
<h2 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h2><p>接口调用方式主要有以下两种：</p>
<ol>
<li><p>基于StatementId(命名空间+语句id)，范例如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;?&gt;|<span class="keyword">int</span>|<span class="keyword">void</span> sqlSession select|update|delete|insert(statementId,params)</div></pre></td></tr></table></figure>
</li>
<li><p>基于Mapper接口</p>
<p> MyBatis 将配置文件中的每一个<mapper> 节点抽象为一个 Mapper 接口,这个接口中声明的方法和<mapper> 节点中的<select|update|delete|insert> 节点项对应，即<select|update|delete|insert> 节点的id值为Mapper 接口中的方法名称，parameterType 值表示Mapper 对应方法的入参类型，而resultMap 值则对应了Mapper 接口表示的返回值类型或者返回结果集的元素类型。范例如下：</select|update|delete|insert></select|update|delete|insert></mapper></mapper></p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;mapper namespace="com.todorex.UserMapper"&gt;</div><div class="line">    &lt;select id="selectList" resultType="com.todorex.User"&gt;</div><div class="line">        select * from user</div><div class="line">    &lt;/select&gt;</div><div class="line">&lt;/mapper&gt;</div><div class="line"></div><div class="line">public interface UserMapper &#123;</div><div class="line"></div><div class="line">    List&lt;User&gt; selectList();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 根据MyBatis 的配置规范配置好后，通过SqlSession.getMapper(UserMapper.class)方法，MyBatis会根据相应的接口声明的方法信息，通过<strong>动态代理机 制</strong> 生成一个Mapper 实例，我们调用Mapper接口的某一个方法时，MyBatis会根据这个方法的方法名和参数类型，确定StatementId，底层还是通过StatementId来实现对数据库的操作，MyBatis引用Mapper接口这种调用方式是为了满足面向接口编程的需 要。<strong>（其实还有一个原因是在于，面向接口的编程，使得用户在接口上可以使用注解来配置SQL语句，这样就可以脱离XML配置文件）</strong>。</p>
</li>
</ol>
<h2 id="数据处理层"><a href="#数据处理层" class="headerlink" title="数据处理层"></a>数据处理层</h2><p>数据处理层可以说是MyBatis的核心，它要完成两个功能：</p>
<ol>
<li><p>通过传入参数构建动态SQL语句</p>
<p> MyBatis 通过传入的参数值，使用 OGNL表达式 来动态地构造SQL语句，使得MyBatis有很强的灵活性和扩展性。参数映射指的是对于java 数据类型和jdbc数据类型之间的转换：这里有包括两个过程：</p>
<ol>
<li>查询阶段，我们要将java类型的数据，转换成jdbc类型的数据，通过 preparedStatement.setXXX() 来设值</li>
<li>返回阶段，我们要对resultset查询结果集的jdbcType 数据转换成java 数据类型</li>
</ol>
</li>
<li><p>SQL语句的执行以及封装查询结果集成List<e></e></p>
<p> 动态SQL语句生成之后，MyBatis 将执行SQL语句，并将可能返回的结果集转换成List<e> 列表。MyBatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换，并且有两种支持方式，一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询。</e></p>
</li>
</ol>
<h2 id="框架支持层"><a href="#框架支持层" class="headerlink" title="框架支持层"></a>框架支持层</h2><ol>
<li><p>事务管理机制</p>
<p> 事务管理机制对于ORM框架而言是不可缺少的一部分，事务管理机制的质量也是考量一个ORM框架是否优秀的一个标准。</p>
</li>
<li><p>连接池管理机制</p>
<p> 由于创建一个数据库连接所占用的资源比较大，对于数据吞吐量大和访问量非常大的应用而言，连接池的设计就显得非常重要。</p>
</li>
<li><p>缓存机制<br> 为了提高数据利用率和减小服务器和数据库的压力，MyBatis 会对于一些查询提供会话级别的数据缓存，会将对某一次查询，放置到SqlSession 中，在允许的时间间隔内，对于完全相同的查询，MyBatis会直接将缓存结果返回给用户，而不用再到数据库中查找。</p>
</li>
<li><p>SQL语句的配置方式<br> 传统的MyBatis 配置SQL语句方式就是使用XML文件进行配置的，但是这种方式不能很好地支持面向接口编程的理念，为了支持面向接口的编程，MyBatis 引入了Mapper接口的概念，面向接口的引入，对使用注解来配置SQL语句成为可能，用户只需要在接口上添加必要的注解即可，不用再去配置XML文件了，但是，目前的MyBatis 只是对注解配置SQL语句提供了有限的支持，某些高级功能还是要依赖XML配置文件配置SQL 语句。</p>
</li>
</ol>
<h2 id="引导层"><a href="#引导层" class="headerlink" title="引导层"></a>引导层</h2><p>引导层是配置和启动MyBatis配置信息的方式。MyBatis 提供两种方式来引导MyBatis：</p>
<ul>
<li><p>基于XML配置文件的方式</p>
</li>
<li><p>基于Java API 的方式</p>
</li>
</ul>
<p>范例可以查看官方使用手册：<a href="http://www.mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="external">Mybatis官方使用手册</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/ec40a82cae28" target="_blank" rel="external">终结篇：MyBatis原理深入解析（一）</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：从JDBC到Hibernate再到Mybatis，你可能会使用很多框架，但是你却不知道框架为你解决什么了或是不知道它的整个架构，我们这里就是帮你解决这些问题！
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Mybatis" scheme="http://bestlixiang.site/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>揭秘SpringMVC(一)_.SpringMVC大全解</title>
    <link href="http://bestlixiang.site/2018/04/15/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98SpringMVC-%E4%B8%80-SpringMVC%E5%A4%A7%E5%85%A8%E8%A7%A3/"/>
    <id>http://bestlixiang.site/2018/04/15/深入SSM/揭秘SpringMVC-一-SpringMVC大全解/</id>
    <published>2018-04-15T08:55:34.000Z</published>
    <updated>2018-04-15T08:56:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：现在基于所有的Web应用都离不开Spring，用了Spring，你自然会去用他家的MVC框架——SpringMVC！所以掌握SpringMVC也是非常重要的。<a id="more"></a></p>
<h1 id="SpringMVC请求处理流程总览"><a href="#SpringMVC请求处理流程总览" class="headerlink" title="SpringMVC请求处理流程总览"></a>SpringMVC请求处理流程总览</h1><p>我们可以用下面一张图来介绍SpringMVC的核心组件和请求处理流程：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/springmvc.png" alt="springmvc"></p>
<p>流程中出现的核心组件如下：</p>
<ol>
<li>DispatcherServlet是springmvc中的前端控制器，负责接收request并将request转发给对应的处理组件.</li>
<li>HanlerMapping是springmvc中完成url到controller映射的组件.DispatcherServlet接收request,然后从HandlerMapping查找处理request的controller.</li>
<li>Controller（HandlerAdapter）处理request,并返回ModelAndView对象,Controller是springmvc中负责处理request的组件(类似于struts2中的Action)</li>
<li>ModelAndView是封装Model对象和View对象的组件</li>
<li>ViewResolver是视图解析器，负责解析ModelAndView对象生成对应的View对象</li>
<li>View视图组件，复制渲染页面</li>
</ol>
<p>整个流程的大致流程如下：</p>
<ol>
<li>当request到来时，DispatcherServlet对request进行捕获，并执行doService方法，继而执行doDispatch方法。</li>
<li>HandlerMapping解析请求，并且返回HandlerExecutionChain（其中包含对应的controller和interceptors）</li>
<li>通过HandlerExecutionChain得到Handler相关类，Handler先执行拦截器的pre相关方法，接着执行handler方法，最后调用拦截器的post相关方法</li>
<li>解析handler方法返回的ModelAndView</li>
<li>根据ViewResolver（可以在配置文件中配置，也就是视图解析器）生成View对象</li>
<li>View对象渲染页面并response给客户端</li>
</ol>
<h1 id="SpringMVC请求处理初始化源码分析"><a href="#SpringMVC请求处理初始化源码分析" class="headerlink" title="SpringMVC请求处理初始化源码分析"></a>SpringMVC请求处理初始化源码分析</h1><ol>
<li><p>首先，Tomcat每次启动时都会加载并解析/WEB-INF/web.xml文件，所以可以先从web.xml找突破口（DispatcherServlet的配置），主要代码如下（我们每次都会这样配置）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;servlet &gt;</div><div class="line">    &lt;servlet-name &gt;spring-mvc&lt;/servlet-name&gt;</div><div class="line">    &lt;!-- DispatcherServlet类，这个类在spring-mvc的包下面 --&gt;</div><div class="line">    &lt;servlet-class &gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</div><div class="line">    &lt;!-- 初始化参数，这里主要是读取SpringMVC的一些配置信息，比如：</div><div class="line">    配置注解驱动，静态资源映射，视图解析器，自动扫描装配等相关信息。</div><div class="line">    --&gt;</div><div class="line">    &lt;init-param &gt;</div><div class="line">      &lt;param-name &gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">      &lt;param-value &gt;classpath:/spring-mvc.xml&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;!-- 启动时加载 --&gt;</div><div class="line">    &lt;load-on-startup &gt;1&lt;/load-on-startup&gt;</div><div class="line">  &lt;/servlet&gt;</div><div class="line">  &lt;servlet-mapping &gt;</div><div class="line">    &lt;servlet-name &gt;spring-mvc&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern &gt;/&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>进入DispatchServlet的分析，先看它的类图：</p>
<p> <img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/DispatcherServlet.png" alt="DispatchServlet"></p>
<p> 它是一个Servlet的子类，那么我们就要专注于它的init、service（后续分析）、doGet、doPost等相关方法，在它的父类HttpServeltBean，我们找到了init方法，如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 获取Servlet中的init参数，并创建了一个BeanWapper对象，由子类真正执行BeanWrapper的初始化工作</span></div><div class="line">        <span class="comment">// 但是HttpServeltBean的子类并没有覆盖其initBeanWrapper方法，所以创建的BeanWrapper没有用</span></div><div class="line">        PropertyValues pvs = <span class="keyword">new</span> HttpServletBean.ServletConfigPropertyValues(<span class="keyword">this</span>.getServletConfig(), <span class="keyword">this</span>.requiredProperties);</div><div class="line">        BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</div><div class="line">        ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(<span class="keyword">this</span>.getServletContext());</div><div class="line">        bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, <span class="keyword">this</span>.getEnvironment()));</div><div class="line">        <span class="keyword">this</span>.initBeanWrapper(bw);</div><div class="line">        bw.setPropertyValues(pvs, <span class="keyword">true</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (BeansException var4) &#123;</div><div class="line">        <span class="keyword">this</span>.logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"'"</span>, var4);</div><div class="line">        <span class="keyword">throw</span> var4;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 这里进要进入到Framework的initServletBean方法了</span></div><div class="line">    <span class="keyword">this</span>.initServletBean();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 从上面的init方法中，我们由它的initServletBean方法进入到FrameworkServlet的initServletBean方法，如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 创建Spring容器，并调用onRefresh方法来完成配置文件的加载</span></div><div class="line">        <span class="keyword">this</span>.webApplicationContext = <span class="keyword">this</span>.initWebApplicationContext();</div><div class="line">        <span class="keyword">this</span>.initFrameworkServlet();</div><div class="line">    &#125; <span class="keyword">catch</span> (ServletException var5) &#123;</div><div class="line">        <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, var5);</div><div class="line">        <span class="keyword">throw</span> var5;</div><div class="line">    &#125; <span class="keyword">catch</span> (RuntimeException var6) &#123;</div><div class="line">        <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, var6);</div><div class="line">        <span class="keyword">throw</span> var6;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 在容器加载的过程中会调用DispatchServlet的initStrategies方法来完成Dispatchservlet中定义的初始化工作，看DispatchServlet的源码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.initStrategies(context);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 初始化SpringMVC框架需要的8个组件，这8个组件对应8个bean对象保存在DispatchServlet类中</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">    <span class="comment">// 用于处理文件上传服务，将Request包装成DefaultMultipartHttpServletRequest</span></div><div class="line">    <span class="keyword">this</span>.initMultipartResolver(context);</div><div class="line">    <span class="comment">// 用于处理应用的国际化问题，控制应用中的字符编码问题</span></div><div class="line">    <span class="keyword">this</span>.initLocaleResolver(context);</div><div class="line">    <span class="comment">// 用于定义一个主题</span></div><div class="line">    <span class="keyword">this</span>.initThemeResolver(context);</div><div class="line">    <span class="comment">// 用于定义用户设置的请求映射关系，将用户请求的URL映射后才能一个个Handler实例</span></div><div class="line">    <span class="comment">// 如果没有定义HandlerMapping，将获取默认的BeanNameURLHandlerMapping和DefaultAnnotaionHandlerMapping</span></div><div class="line">    <span class="keyword">this</span>.initHandlerMappings(context);</div><div class="line">    <span class="comment">// 用于根据Handler的类型定义不同的处理规则（调用Controller实例），默认的为：</span></div><div class="line">    <span class="comment">// HttpRequestHandlerAdapter、SimpleControllerHandlerAdapter、ThrowawayControllerAdapter、AnnotationMethodHandlerAdapter</span></div><div class="line">    <span class="keyword">this</span>.initHandlerAdapters(context);</div><div class="line">    <span class="comment">// 当Handle处理出错时，会通过这个Handler来统一处理，默认为SimpleMappingExceptionResolver，</span></div><div class="line">    <span class="comment">// 将错误日志记录在日志文件中，并且跳转到默认的错误页面</span></div><div class="line">    <span class="keyword">this</span>.initHandlerExceptionResolvers(context);</div><div class="line">    <span class="comment">// 将指定的ViewName按照定义的requestToViewNameTranslator替换成想要的格式，如加上前缀或者后缀。</span></div><div class="line">    <span class="keyword">this</span>.initRequestToViewNameTranslator(context);</div><div class="line">    <span class="comment">// 用于将View解析成页面，在ViewResolvers中可以设置多个解析策略，默认的解析策略为InternalResourceViewResolver，按照JSP页面来解析</span></div><div class="line">    <span class="keyword">this</span>.initViewResolvers(context);</div><div class="line">    <span class="comment">// 为一个请求存储意图为另外一个请求所使用的属性提供了一条途径(通常存储在session)</span></div><div class="line">    <span class="keyword">this</span>.initFlashMapManager(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="SpringMVC请求处理流程源码分析"><a href="#SpringMVC请求处理流程源码分析" class="headerlink" title="SpringMVC请求处理流程源码分析"></a>SpringMVC请求处理流程源码分析</h1><p>关注完初始化init方法，我们要进入正式的流程分析了，其实就是在sevice方法里面(在其父类FrameworkServlet里)，我们看看下面的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span>(HttpMethod.PATCH.matches(request.getMethod())) &#123;</div><div class="line">        <span class="keyword">this</span>.processRequest(request, response);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">super</span>.service(request, response);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据service方法，我们一步步调试进入service –&gt; processRequest –&gt; doService（将ApplicationContext、localeResolver、themeResolver等对象添加到request中以便后面使用） –&gt; doDispatch，我们最终将目光定位在doDispatch，因为从它的方法体就可以看出它是整个SpringMVC的核心方法。我们看看DispatchServlet里面的doDispatch方法源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        HttpServletRequest processedRequest = request;</div><div class="line">        HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</div><div class="line">        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                ModelAndView mv = <span class="keyword">null</span>;</div><div class="line">                Exception dispatchException = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// //处理文件上传请求</span></div><div class="line">                    processedRequest = <span class="keyword">this</span>.checkMultipart(request);</div><div class="line">                    multipartRequestParsed = processedRequest != request;</div><div class="line">                    <span class="comment">// 解析请求（匹配URL），获取HandlerExecutionChain对象</span></div><div class="line">                    mappedHandler = <span class="keyword">this</span>.getHandler(processedRequest);</div><div class="line">                    <span class="keyword">if</span>(mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">this</span>.noHandlerFound(processedRequest, response);</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 从HandlerExecutionChain对象获取HandlerAdapter对象，实际上是从HandlerMapping对象中获取</span></div><div class="line">                    HandlerAdapter ha = <span class="keyword">this</span>.getHandlerAdapter(mappedHandler.getHandler());</div><div class="line">                    String method = request.getMethod();</div><div class="line">                    <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</div><div class="line">                    <span class="keyword">if</span>(isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</div><div class="line">                        <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</div><div class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</div><div class="line">                            <span class="keyword">this</span>.logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="keyword">if</span>((<span class="keyword">new</span> ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                   <span class="comment">// 在controller方法执行前，执行拦截器的相关方法（pre） if(!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span></div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 执行HandlerAdapter对象的handle方法，返回ModelAndView</span></div><div class="line">                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</div><div class="line">                    <span class="keyword">if</span>(asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">this</span>.applyDefaultViewName(processedRequest, mv);</div><div class="line">                   <span class="comment">// 在controller方法执行后，执行拦截器的相关方法（post）</span></div><div class="line">                   mappedHandler.applyPostHandle(processedRequest, response, mv);</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception var19) &#123;</div><div class="line">                    dispatchException = var19;</div><div class="line">                &#125;</div><div class="line">               <span class="comment">// 进行视图解析</span></div><div class="line">               <span class="keyword">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception var20) &#123;</div><div class="line">                <span class="keyword">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var20);</div><div class="line">            &#125; <span class="keyword">catch</span> (Error var21) &#123;</div><div class="line">                <span class="keyword">this</span>.triggerAfterCompletionWithError(processedRequest, response, mappedHandler, var21);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span>(asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">                <span class="keyword">if</span>(mappedHandler != <span class="keyword">null</span>) &#123;</div><div class="line">                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(multipartRequestParsed) &#123;</div><div class="line">                <span class="keyword">this</span>.cleanupMultipart(processedRequest);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>上面是整体的流程，下面我们具体到对MVC架构的三个模块的分析：</p>
<h2 id="Control（C）"><a href="#Control（C）" class="headerlink" title="Control（C）"></a>Control（C）</h2><p>Spring MVC的Control主要由HandlerMapping和HandlerAdapters两个组件提供。</p>
<p>HandlerMapping并没有规定这个URL与应用的处理类如何映射，在这个接口中只定义了根据URL必须返回一个由HandlerExecutionChain代理的处理链，我们可以在这里处理链中添加任意的HandlerAdapters实例来处理这个URL对应的请求。这个和Servlet规范中的filter处理是类似的。</p>
<h3 id="HandlerMapping的初始化"><a href="#HandlerMapping的初始化" class="headerlink" title="HandlerMapping的初始化"></a>HandlerMapping的初始化</h3><p><strong>（可以参照HandlerMapping的子类SimpleUrlHandlerMapping里面的initApplicationContext方法代码）</strong></p>
<p>HandlerMapping的初始化工作完成的两个最重要的工作就是将URL与Handler的对应关系保存在handlerMap集合中，并将所有的<strong>interceptors</strong>对象保存在adaptedInterceptors数组中，等到请求到来时执行所有的adaptedInterceptors数组中的Interceptor对象，所有的Interceptor对象必须实现HandlerInterceptor接口。</p>
<h3 id="HandlerAdapter-可以看成Controller-的初始化"><a href="#HandlerAdapter-可以看成Controller-的初始化" class="headerlink" title="HandlerAdapter(可以看成Controller)的初始化"></a>HandlerAdapter(可以看成Controller)的初始化</h3><p><strong>（可以参照HandlerAdapter的子类SimpleControllerHandlerAdapter里面的代码）</strong></p>
<p>HandlerAdapter的初始化工作主要是创建一个HandlerAdapter对象，将这个HandlerAdapter对象保存在DispatcherServlet的HandlerAdapters集合中。当SpringMVC将某个URL对应到某个Handler时，在HandlerAdapters集合中查询那个HandlerAdapters对象supports这个Handler，那么HandlerAdapters就会被返回（设计模式），并调用这个HandlerAdapters接口对应的方法。如果这个HandlerAdapters对象是SimpleControllerHandlerAdapter，则将调用其ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)方法。如果用户没有定义HandlerAdapter的实现类，默认的为：HttpRequestHandlerAdapter、SimpleControllerHandlerAdapter、ThrowawayControllerAdapter、AnnotationMethodHandlerAdapter。</p>
<h3 id="Control的调用逻辑"><a href="#Control的调用逻辑" class="headerlink" title="Control的调用逻辑"></a>Control的调用逻辑</h3><p>根据DispatcherServlet的doDispath方法我们可以看到通过getHandler方法匹配到某个Handler并返回这个Handler的处理链HandlerExecutionChain对象，而这个HandlerExecutionChain对象将会包含一个匹配上的HandlerAdapter以及用户自定义的多个HandlerInterceptor对象。我们先看HandlerInterceptor接口，在HandlerInterceptor接口中有三个方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</div><div class="line">    <span class="comment">// 在Handler执行前</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">    <span class="comment">// 在Handler执行后</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3, ModelAndView var4)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">    <span class="comment">// 在View渲染完成后，DispatchServlet返回之前执行。</span></div><div class="line">    <span class="comment">// PS：当preHandler返回false时，当前的请求将在执行完该方法后直接返回，Handler不再执行</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3, Exception var4)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们然后看看HandlerExecutionChain类的getHandler方法，你会发现返回的是Object对象，所以在这里Handler对象是没有类型的，Handler的类型是由HandlerAdapter（匹配到的）决定的。接下里执行Handler对象的具体方法，如果Handler对象的相应方法返回一个ModelAndView对象，接下去就去执行View渲染。</p>
<h2 id="Model（M）"><a href="#Model（M）" class="headerlink" title="Model（M）"></a>Model（M）</h2><p>Model实例既在业务逻辑层被使用，也在渲染页面中被使用，我们这里主要讲一下在页面模板渲染中的使用。</p>
<p>如果Handler返回了ModelAndView对象，那么说明Handler需要传一个Model实例给View去渲染模板。可以说ModelAndView对象就是连接业务逻辑层与View视图层的桥梁，对SpringMVC来说它也是连接Handler与View的桥梁。</p>
<p>ModelAndView对象会持有一个ModelMap对象和一个View对象（可以查看ModelAndView的源码），ModelMap对象就是执行模板渲染时所需要的变量对应的实例（对应到Struts2的值栈），如JSP通过request.getAttribute(String)获得JSTL标签名对应的对象。ModelMap其实也是个Map，在Handler中将模板需要的对象存在这个Map中，然后传递到View对应的ViewResolvers中。</p>
<h2 id="View（V）"><a href="#View（V）" class="headerlink" title="View（V）"></a>View（V）</h2><p>Spring MVC的View主要由RequestToViewNameTranslator和ViewResolver两个组件提供。</p>
<ul>
<li>RequestToViewNameTranslator支持用户自定义对ViewName的解析，如加上前缀或者后缀等。</li>
<li>ViewResolver会根据用户的请求的ViewName创建合适的模板引擎（解析器）来渲染最终的页面。ViewResolver会根据ViewName创建一个View对象，调用View对象的render方法渲染页面。</li>
</ul>
<p>我们重点关注这个ViewResolver，先看他的类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/viewResolver.png" alt="ViewResolver"></p>
<p>我们从UrlBaseViewResolver对象的loadView方法-&gt;buildView方法可以看到如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> AbstractUrlBasedView <span class="title">buildView</span><span class="params">(String viewName)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    AbstractUrlBasedView view = (AbstractUrlBasedView)BeanUtils.instantiateClass(<span class="keyword">this</span>.getViewClass());</div><div class="line">    view.setUrl(<span class="keyword">this</span>.getPrefix() + viewName + <span class="keyword">this</span>.getSuffix());</div><div class="line">    String contentType = <span class="keyword">this</span>.getContentType();</div><div class="line">    <span class="keyword">if</span>(contentType != <span class="keyword">null</span>) &#123;</div><div class="line">        view.setContentType(contentType);</div><div class="line">    &#125;</div><div class="line">    ... 省略</div><div class="line">    <span class="keyword">return</span> view;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结合类图可以发现不同的解析器生成的View对象是不一样的。</p>
<p>获得View对象之后就可以调用View对象的render方法渲染页面。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入分析Java Web技术内幕》</li>
<li><a href="https://blog.csdn.net/lang_programmer/article/details/71598042" target="_blank" rel="external">一步步分析SpringMVC源码</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：现在基于所有的Web应用都离不开Spring，用了Spring，你自然会去用他家的MVC框架——SpringMVC！所以掌握SpringMVC也是非常重要的。
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://bestlixiang.site/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Spring(四)_Spring设计模式</title>
    <link href="http://bestlixiang.site/2018/04/12/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Spring-%E5%9B%9B-Spring%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/04/12/深入SSM/揭秘Spring-四-Spring设计模式/</id>
    <published>2018-04-12T13:07:10.000Z</published>
    <updated>2018-04-12T13:10:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：说完了IOC和AOP（虽然可能还是不够深入，不够全面，但是对于自己还是有一定的收获，日后有新的领悟再来调整），再来说说Spring这么优秀的框架所使用的的设计模式，可谓遍地都是，我就自己看到写一下。<a id="more"></a></p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">设计模式之禅——单例模式</a>。</p>
<p>Spring应用到的单例模式可以在org.springframework.beans.factory.config.AbstractFactoryBean类中看到这个逻辑。看看它的getObject方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 如果是单例且已经初始化，就直接返回</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.isSingleton()?(<span class="keyword">this</span>.initialized?<span class="keyword">this</span>.singletonInstance:<span class="keyword">this</span>.getEarlySingletonInstance()):<span class="keyword">this</span>.createInstance();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>工厂方法模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">设计模式之禅——工厂方法模式</a>。</p>
<p>Spring应用到的工厂方法模式可以在org.springframework.beans.factory.BeanFactory类中看到这个逻辑。我们看到下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</div><div class="line">    <span class="comment">// 根据唯一标识来获得Bean对象</span></div><div class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String var1)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">设计模式之禅——抽象工厂模式</a>。</p>
<p>Spring应用到的抽象工厂模式可以在org.springframework.beans.factory.BeanFactory类中看到这个逻辑。通过它的实现，我们可以从Spring的容器访问bean。根据采用的策略，getBean方法可以返回已创建的对象（共享实例，单例作用域）或初始化新的对象（原型作用域）。在BeanFactory的实现中，我们可以区分：ClassPathXmlApplicationContext，XmlWebApplicationContext，StaticWebApplicationContext，StaticPortletApplicationContext，GenericApplicationContext，StaticApplicationContext，相当于不同的Creator。</p>
<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式之禅——建造者模式</a>。</p>
<p>Spring应用到的建造者模式可以在org.springframework.beans.factory.support.BeanDefinitionBuilder类中检索这个逻辑。这是一个允许我们以编程方式定义bean的类。BeanDefinitionBuilder包含几个方法，它们为AbstractBeanDefinition抽象类的相关实现设置值，比如作用域，工厂方法，属性等。想看看它是如何工作的，请查看以下这些方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionBuilder</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> AbstractBeanDefinition beanDefinition;</div><div class="line"></div><div class="line">  <span class="comment">// 设置Bean的父类名</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setParentName</span><span class="params">(String parentName)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.setParentName(parentName);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 设置Bean的工厂方法</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setFactoryMethod</span><span class="params">(String factoryMethod)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.setFactoryMethodName(factoryMethod);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 设置Bean的构造函数参数</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">addConstructorArgValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(</div><div class="line">                    <span class="keyword">this</span>.constructorArgIndex++, value);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 添加Bean的属性值</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">addPropertyValue</span><span class="params">(String name, Object value)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.getPropertyValues().add(name, value);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 设置Bean的初始化方法</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setInitMethodName</span><span class="params">(String methodName)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.setInitMethodName(methodName);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 返回建造好的对象</span></div><div class="line">  <span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">getBeanDefinition</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.validate();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinition;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>原型模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">设计模式之禅——原型模式</a>。</p>
<p>Spring应用到的原型模式可以在org.springframework.beans.factory.support.AbstractBeanFactory类中看到这个逻辑。它使用一种特定的原型设计模式，它先初始化bean原型作用域(克隆)。新对象基于配置文件中的bean定义。</p>
<h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><p>模板模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">设计模式之禅——模板模式</a>。</p>
<p>Spring应用到的模板模式可以在org.springframework.context.support.AbstractApplicationContext类以及它的实现类中看到这个逻辑。它的模板方法是refresh方法，而refreshBeanFactory以及getBeanFactory等方法都由子类具体实现。</p>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><p>访问者模式模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式之禅——访问者模式</a>。</p>
<p>Spring应用到的访问者模式可以在org.springframework.beans.factory.config.BeanDefinitionVisitor类中看到这个逻辑。该对象用于解析bean元数据并将其解析为String（例如：具有作用域或工厂方法名称的XML属性）或Object（例如：构造函数定义中的参数）。已解析的值在与分析的bean关联的BeanDefinition实例中进行判断设置。具体的源码请看BeanDefinitionVisitor的代码片段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionVisitor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitBeanDefinition</span><span class="params">(BeanDefinition beanDefinition)</span> </span>&#123;</div><div class="line">      visitParentName(beanDefinition);</div><div class="line">      visitBeanClassName(beanDefinition);</div><div class="line">      visitFactoryBeanName(beanDefinition);</div><div class="line">      visitFactoryMethodName(beanDefinition);</div><div class="line">      visitScope(beanDefinition);</div><div class="line">      visitPropertyValues(beanDefinition.getPropertyValues());</div><div class="line">      ConstructorArgumentValues cas = beanDefinition.</div><div class="line">        getConstructorArgumentValues();</div><div class="line">      visitIndexedArgumentValues(cas.</div><div class="line">        getIndexedArgumentValues());</div><div class="line">      visitGenericArgumentValues(cas.</div><div class="line">        getGenericArgumentValues());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">visitParentName</span><span class="params">(BeanDefinition beanDefinition)</span> </span>&#123;</div><div class="line">      String parentName = beanDefinition.getParentName();</div><div class="line">      <span class="keyword">if</span> (parentName != <span class="keyword">null</span>) &#123;</div><div class="line">        String resolvedName = resolveStringValue(parentName);</div><div class="line">        <span class="keyword">if</span> (!parentName.equals(resolvedName)) &#123;</div><div class="line">          beanDefinition.setParentName(resolvedName);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">设计模式之禅——代理模式</a>。</p>
<p>Spring应用到的代理模式可以在org.springframework.aop.framework.ProxyFactoryBean类中看到这个逻辑。详细说明可以参照上一篇文章。</p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">设计模式之禅——策略模式</a>。</p>
<p>Spring应用到的策略模式可以在org.springframework.aop.framework.DefaultAopProxyFactory类中看到这个逻辑。看一下这个类的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !<span class="keyword">this</span>.hasNoUserSuppliedProxyInterfaces(config)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</div><div class="line">            <span class="keyword">if</span>(targetClass == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: Either an interface or a target is required for proxy creation."</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 根据目标类是否有接口而采取不同的策略</span></div><div class="line">                <span class="keyword">return</span> (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass)?<span class="keyword">new</span> ObjenesisCglibAopProxy(config):<span class="keyword">new</span> JdkDynamicAopProxy(config));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>适配器模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">设计模式之禅——适配器模式</a>。</p>
<p>Spring应用到的适配器模式可以在org.springframework.aop.framework.adapter.DefaultAdvisorAdapterRegistry类中看到这个逻辑，Spring需要将每个Advice（通知）都封装成对应的拦截器类型，返回给容器，所以需要使用适配器模式对Advice进行转换。下面我们看看具体的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Adaptee</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">BeforeAdvice</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable</span>;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Target</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvisorAdapter</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span></span>;  </div><div class="line"></div><div class="line">    <span class="function">MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span></span>;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Adapter</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceAdapter</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapter</span>, <span class="title">Serializable</span> </span>&#123;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> (advice <span class="keyword">instanceof</span> MethodBeforeAdvice);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;  </div><div class="line">        MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodBeforeAdviceInterceptor(advice);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式之禅——观察者模式</a>。</p>
<p>Spring应用到的观察者模式可以应用程序上下文相关的事件传输看到这个逻辑，具体一点在AbstractApplicationContext与org.springframework.context.ApplicationListener以及org.springframework.context.event.ApplicationEventMulticaster中看到，我们可以看到下面的相关代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span>, <span class="title">DisposableBean</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义传播者，用来传播消息</span></div><div class="line">    <span class="keyword">private</span> ApplicationEventMulticaster applicationEventMulticaster;</div><div class="line">    <span class="comment">// 注册监听者</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationEventMulticaster</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addApplicationListenerBean</span><span class="params">(String var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeApplicationListenerBean</span><span class="params">(String var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeAllListeners</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(ApplicationEvent var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(ApplicationEvent var1, ResolvableType var2)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><p>解释器模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/">设计模式之禅——解释器模式</a>。</p>
<p>Spring应用到的解释器模式主要以Spring Expression Language（SpEL）为例。SpEL是一种由Spring的org.springframework.expression.ExpressionParser实现分析和执行的语言。这些实现使用作为字符串给出的Spel表达式，并将它们转换为org.springframework.expression.Expression的实例。上下文组件由org.springframework.expression.EvaluationContext实现表示，例如：StandardEvaluationContext。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>参考了超级多，都快忘了，各位大佬不要介意！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：说完了IOC和AOP（虽然可能还是不够深入，不够全面，但是对于自己还是有一定的收获，日后有新的领悟再来调整），再来说说Spring这么优秀的框架所使用的的设计模式，可谓遍地都是，我就自己看到写一下。
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Spring" scheme="http://bestlixiang.site/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Centos7利用Nginx配置HTTPS</title>
    <link href="http://bestlixiang.site/2018/04/12/%E5%B7%A5%E5%85%B7/Centos7%E5%88%A9%E7%94%A8Nginx%E9%85%8D%E7%BD%AEHTTPS/"/>
    <id>http://bestlixiang.site/2018/04/12/工具/Centos7利用Nginx配置HTTPS/</id>
    <published>2018-04-12T08:53:31.000Z</published>
    <updated>2018-04-12T08:54:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：最近在做一个微信小程序项目，坑爹的小程序不仅需要https协议，而且还要是80端口才能访问后台，这里总结一下Nginx的安装过程与HTTPS的配置。<a id="more"></a></p>
<h1 id="Ngnix的安装"><a href="#Ngnix的安装" class="headerlink" title="Ngnix的安装"></a>Ngnix的安装</h1><p>由于后面Nginx需要添加模块，所以我们采用<strong>源码安装</strong>，具体安装方法可以参考 <a href="http://bestlixiang.site/2018/04/08/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/">走进Linux_软件安装</a> 中的源码安装一节。</p>
<p>这里需要注意的我们在 <strong>产生makefile文件的时候</strong> 需要加一些configure arguments，以便安装相关模块。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module</div></pre></td></tr></table></figure></p>
<p>安装完之后可以利用下面的命令查看Ngnix版本及其编译参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/usr/local/nginx/sbin/nginx -V</div><div class="line"></div><div class="line">// 输出如下结果就是对的</div><div class="line">nginx version: nginx/1.11.6</div><div class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC)</div><div class="line">built with OpenSSL 1.0.2k-fips  26 Jan 2017</div><div class="line">TLS SNI support enabled</div><div class="line">configure arguments: --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module</div></pre></td></tr></table></figure></p>
<p>然后我们测试新的nginx程序是否正确：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/usr/local/nginx/sbin/nginx -t</div><div class="line"></div><div class="line">// 输出如下结果J就表面安装成功</div><div class="line">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</div><div class="line">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</div></pre></td></tr></table></figure></p>
<h1 id="配置HTTPS"><a href="#配置HTTPS" class="headerlink" title="配置HTTPS"></a>配置HTTPS</h1><h2 id="SSL证书申请"><a href="#SSL证书申请" class="headerlink" title="SSL证书申请"></a>SSL证书申请</h2><p>SSL证书遵守 SSL（Secure Sockets Layer 安全套接层）协议，由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能，也就是说你想要使用https就需要拥有SSL证书。</p>
<p>这里我们使用openssl证书来举例，<a href="https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=10_4" target="_blank" rel="external">微信小程序官网也是使用openssl来进行HTTPS服务器配置</a>。</p>
<ol>
<li><p>生成私钥</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 进入nginx的安装目录</div><div class="line">cd /usr/local/nginx</div><div class="line"></div><div class="line">// 创建一个存放私钥的文件夹（自定义）</div><div class="line">mkdir key</div><div class="line"></div><div class="line">// 进入key文件夹</div><div class="line">cd key</div><div class="line"></div><div class="line">// 生成私钥</div><div class="line">openssl genrsa -out server.key 2048</div></pre></td></tr></table></figure>
</li>
<li><p>生成csr文件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// CSR 是Certificate Signing Request的缩写，即证书签名请求，</div><div class="line">// 这不是证书，可以简单理解成公钥，生成证书时要把这个提交给权威的证书颁发机构。</div><div class="line"></div><div class="line"></div><div class="line">// 生成csr文件</div><div class="line">openssl req -new -key server.key -out certreq.csr</div><div class="line"></div><div class="line">// 输入上面的命令后会要求你输入一些信息：</div><div class="line">Country Name： CN        //您所在国家的ISO标准代号，中国为CN</div><div class="line">State or Province Name：guandong //您单位所在地省/自治区/直辖市</div><div class="line">Locality Name：shenzhen      //您单位所在地的市/县/区</div><div class="line">Organization Name： Tencent Technology (Shenzhen) Company Limited    //您单位/机构/企业合法的名称</div><div class="line">Organizational Unit Name： R&amp;D         //部门名称</div><div class="line">Common Name： www.example.com     //通用名，网站域名。此项必须与您访问提供SSL服务的服务器时所应用的域名完全匹配。</div><div class="line">Email Address：      //您的邮件地址，不必输入，直接回车跳过</div><div class="line">&quot;extra&quot;attributes  // 以下信息不必输入，回车跳过直到命令执行完毕。</div></pre></td></tr></table></figure>
</li>
<li><p>生成crt证书</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// CRT 即 certificate的缩写，即证书。</div><div class="line">openssl x509 -req -days 365 -in certreq.csr -signkey server.key -out certreq.crt</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Nginx配置SSL加密"><a href="#Nginx配置SSL加密" class="headerlink" title="Nginx配置SSL加密"></a>Nginx配置SSL加密</h2><p>想要https就要监听443端口，nginx.conf已经预留出了server，只要我们把注释去掉开启即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 编辑Ngnix配置文件</div><div class="line">vim /usr/local/nginx/conf/nginx.conf</div><div class="line"></div><div class="line">// 修改监听443端口的Server，使其如下：</div><div class="line">server &#123;</div><div class="line">    listen 443 ssl;</div><div class="line">    server_name www.example.com;</div><div class="line">    ssl on;</div><div class="line">    # ssl_certificate证书其实是个公钥，它会被发送到连接服务器的每个客户端</div><div class="line">    ssl_certificate /usr/local/nginx/key/certreq.crt;</div><div class="line">    # ssl_certificate_key私钥是用来解密的，所以它的权限要得到保护但nginx的主进程能够读取</div><div class="line">    ssl_certificate_key /usr/local/nginx/key/server.key;</div><div class="line">    ssl_session_timeout  5m;</div><div class="line">    # 指定SSL服务器端支持的协议版本</div><div class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">    # 选择加密算法</div><div class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</div><div class="line">    # ssl_ciphers  ALL：!ADH：!EXPORT56：RC4+RSA：+HIGH：+MEDIUM：+LOW：+SSLv2：+EXP;</div><div class="line">    # 在使用SSLv3和TLS协议时指定服务器的加密算法要优先于客户端的加密算法</div><div class="line">    ssl_prefer_server_ciphers   on;</div><div class="line">    # 虽然我们要使用HTTPS，但是服务器的程序接收的还是HTTP，所以要做个反向代理</div><div class="line">    location /&#123;</div><div class="line">        proxy_pass http://localhost:8080;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>这样虽然可以利用https来访问我们的ip，但是对于浏览器还是不受信任的。</strong></p>
<h2 id="导入证书"><a href="#导入证书" class="headerlink" title="导入证书"></a>导入证书</h2><p>如果你是找一个知名的SSL证书颁发机构如VeriSign、Wosign、StartSSL签发的证书，<strong>并且浏览器已经内置并信任了这些根证书</strong>，如果你是自建证书（向我们刚才那样）或获得二级证书授权，那么就<strong>需要将证书添加到浏览器</strong>，这样在访问站点时才不会显示不安全连接。<strong>不够买证书微信小程序会不支持。</strong> 证书生成的方法有很多，这里说两种：</p>
<ol>
<li><p>购买阿里云的免费证书</p>
</li>
<li><p>购买<a href="http://note.youdao.com/" target="_blank" rel="external">GETSSL官网</a>证书</p>
</li>
</ol>
<p>购买好证书并下载后（可以将证书和私钥放到之前的key目录）需要从新配置nginx.conf文件，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 443 ssl;</div><div class="line">    server_name www.example.com;</div><div class="line">    ssl on;</div><div class="line">    # pem是crt的一种，内容是BASE64编码，Apache和*NIX服务器偏向于使用这种编码格式</div><div class="line">    ssl_certificate /usr/local/nginx/key/*.pem;</div><div class="line">    ssl_certificate_key /usr/local/nginx/key/*.key;</div><div class="line">    ssl_session_timeout  5m;</div><div class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</div><div class="line">    ssl_prefer_server_ciphers   on;</div><div class="line">    location /&#123;</div><div class="line">        proxy_pass http://localhost:8080;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/w410589502/article/details/72833283" target="_blank" rel="external"> linux nginx配置https</a></li>
<li><a href="https://www.cnblogs.com/yjmyzz/p/openssl-tutorial.html" target="_blank" rel="external">openssl、x509、crt、cer、key、csr、ssl、tls 这些都是什么鬼?</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：最近在做一个微信小程序项目，坑爹的小程序不仅需要https协议，而且还要是80端口才能访问后台，这里总结一下Nginx的安装过程与HTTPS的配置。
    
    </summary>
    
      <category term="工具" scheme="http://bestlixiang.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
      <category term="HTTPS" scheme="http://bestlixiang.site/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Spring(三)_Spring之AOP</title>
    <link href="http://bestlixiang.site/2018/04/11/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Spring-%E4%B8%89-Spring%E4%B9%8BAOP/"/>
    <id>http://bestlixiang.site/2018/04/11/深入SSM/揭秘Spring-三-Spring之AOP/</id>
    <published>2018-04-11T13:21:34.000Z</published>
    <updated>2018-04-11T13:47:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：前一节讲到Spring的核心概念IOC，那么就不能不提到Spring的另一个核心概念AOP，我们先是先讲一下它的概念与原理实现，然后在讲Spring中AOP的实现。<a id="more"></a></p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="AOP思想"><a href="#AOP思想" class="headerlink" title="AOP思想"></a>AOP思想</h2><p>AOP（Aspect Oriented Programming的缩写，意为：面向切面编程）是对OOP的一种补充。</p>
<ul>
<li>面向对象(OOP)引入了继承、多态、封装，将系统的业务功能按照模块划分，每个模块用一个或多个类来表示。<strong>而对于一些系统功能，无法使用OOP的思想来实现它们。这些系统功能往往穿插在业务功能的各处，和业务代码耦合在一起；而且系统功能往往会被重复使用，这就导致了模块不利于复用，这就是使用OOP实现系统功能的弊端。</strong></li>
<li>AOP即为面向切面编程，它把系统需求按照功能分门归类，把它们封装在一个个切面中，然后再指定这些系统功能往业务功能，主要应用于权限认证、日志，事务等。</li>
</ul>
<p>它的主要是好处如下：</p>
<ul>
<li><p>降低模块之间的耦合度</p>
</li>
<li><p>使系统容易扩展</p>
</li>
<li><p>更好的代码复用。</p>
</li>
</ul>
<h2 id="AOP实现原理"><a href="#AOP实现原理" class="headerlink" title="AOP实现原理"></a>AOP实现原理</h2><p>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。而Spring采用的是动态代理技术，关于动态代理的实现可以参照自己之前的博客 <a href="http://bestlixiang.site/2018/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">设计模式之禅——代理模式</a>一文中的动态代理这一节去了解。</p>
<h1 id="SpringAOP实现"><a href="#SpringAOP实现" class="headerlink" title="SpringAOP实现"></a>SpringAOP实现</h1><p>Spring的AOP实现遵守AOP联盟的约定。同时Spring又扩展了它，增加了Pointcut、Advisor等一些接口使得其更加灵活。</p>
<h2 id="Spring-AOP的基本概念"><a href="#Spring-AOP的基本概念" class="headerlink" title="Spring AOP的基本概念"></a>Spring AOP的基本概念</h2><ul>
<li>切面（Aspect）：类似于OOP中的Class，一个Aspect存放一个系统功能的所有逻辑。切面用Spring的 Advisor或拦截器实现。</li>
<li>连接点（Joinpoint）：程序执行过程中的某一事件，如方法被调用时、抛出异常时。</li>
<li>切入点（Pointcut）：指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上。</li>
<li>引入（Introduction）: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口。</li>
<li>目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象（POJO）。</li>
<li>AOP代理（AOP Proxy）: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</li>
<li>织入（Weaving）: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</li>
<li>通知（Advice）：具体的横切逻辑；Spring中有五种Advice：<ul>
<li>前置通知（Before Advice）</li>
<li>后置通知（After Advice）</li>
<li>返回通知（After Return Advice）</li>
<li>环绕通知（Around Advice）</li>
<li>抛出异常后通知（After Throwing Advice）</li>
</ul>
</li>
</ul>
<h2 id="SpringAOP动态代理"><a href="#SpringAOP动态代理" class="headerlink" title="SpringAOP动态代理"></a>SpringAOP动态代理</h2><p>Spring AOP中使用了两种动态代理，一种是JDK的动态代理，一种CGLIB的动态代理。JDK的动态代理必须指定接口，这些接口都是已经被代理对象实现了的；而CGLIB代理则不需要指定接口。</p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>如果被代理对象实现了需要被代理的接口，则使用JDK的动态代理。我们一步步来看这个过程：</p>
<ol>
<li><p>首先明确我们使要生成一个代理，而Spring的内部机制是由FactoryBean的getObject方法来产生的，所以我们会一步步debug到这个方法行（在FactoryBeanRegistrySupport类的doGetObjectFromFactoryBean中），我们看看这个方法的源代码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    <span class="comment">// 初始化通知器链，为代理对象配置通知器链。</span></div><div class="line">    <span class="keyword">this</span>.initializeAdvisorChain();</div><div class="line">    <span class="comment">//区分SingleTon和ProtoType，生成对应的Proxy</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.isSingleton()) &#123;</div><div class="line">    <span class="comment">// 只有SingleTon的Bean才会一开始就初始化，ProtoType的只有在请求的时候才会初始化，代理也一样</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getSingletonInstance();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.logger.warn(<span class="string">"Using non-singleton proxies with singleton targets is often undesirable. Enable prototype proxies by setting the 'targetName' property."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.newPrototypeInstance();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>到达getObject方法后，我们需要去看看它是怎么初始化通知链的就是initializeAdvisorChain的代码：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initializeAdvisorChain</span><span class="params">()</span> <span class="keyword">throws</span> AopConfigException, BeansException </span>&#123;</div><div class="line">    <span class="comment">// 初始化过程的标志位advisorChainInitialized，这个标志用来表示通知器链是否已经初始化。</span></div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.advisorChainInitialized) &#123;</div><div class="line">        <span class="keyword">if</span>(!ObjectUtils.isEmpty(<span class="keyword">this</span>.interceptorNames)) &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.beanFactory == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No BeanFactory available anymore (probably due to serialization) - cannot resolve interceptor names "</span> + Arrays.asList(<span class="keyword">this</span>.interceptorNames));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.interceptorNames[<span class="keyword">this</span>.interceptorNames.length - <span class="number">1</span>].endsWith(<span class="string">"*"</span>) &amp;&amp; <span class="keyword">this</span>.targetName == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSource == EMPTY_TARGET_SOURCE) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Target required after globals"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            String[] var1 = <span class="keyword">this</span>.interceptorNames;</div><div class="line">            <span class="keyword">int</span> var2 = var1.length;</div><div class="line"></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</div><div class="line">                String name = var1[var3];</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</div><div class="line">                    <span class="keyword">this</span>.logger.trace(<span class="string">"Configuring advisor or advice '"</span> + name + <span class="string">"'"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(name.endsWith(<span class="string">"*"</span>)) &#123;</div><div class="line">                    <span class="keyword">if</span>(!(<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ListableBeanFactory)) &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Can only use global advisors or interceptors with a ListableBeanFactory"</span>);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">this</span>.addGlobalAdvisor((ListableBeanFactory)<span class="keyword">this</span>.beanFactory, name.substring(<span class="number">0</span>, name.length() - <span class="string">"*"</span>.length()));</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    Object advice;</div><div class="line">                    <span class="keyword">if</span>(!<span class="keyword">this</span>.singleton &amp;&amp; !<span class="keyword">this</span>.beanFactory.isSingleton(name)) &#123;</div><div class="line">                        advice = <span class="keyword">new</span> ProxyFactoryBean.PrototypePlaceholderAdvisor(name);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        advice = <span class="keyword">this</span>.beanFactory.getBean(name);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">this</span>.addAdvisorOnChainCreation(advice, name);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.advisorChainInitialized = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  初始化只是在应用第一次通过ProxyFactoryBean获取代理对象的时候。完成这个初始化之后，接着会读取配置中出现的所有通知器（把通知器的名字交给容器的getBean，IOC容器的回调获取通知器），把通知器加入拦截器链（addAdvisoronChainCreation实现）。</p>
</li>
<li><p>生成代理对象，利用ProxyFactoryBean的getSingletonInstance方法，源码如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Object <span class="title">getSingletonInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.singletonInstance == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//这里会调用getBean，获取被代理对象</span></div><div class="line">        <span class="keyword">this</span>.targetSource = <span class="keyword">this</span>.freshTargetSource();</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.autodetectInterfaces &amp;&amp; <span class="keyword">this</span>.getProxiedInterfaces().length == <span class="number">0</span> &amp;&amp; !<span class="keyword">this</span>.isProxyTargetClass()) &#123;</div><div class="line">            <span class="comment">// 根据 AOP 框架判断需要代理的接口</span></div><div class="line">            Class&lt;?&gt; targetClass = <span class="keyword">this</span>.getTargetClass();</div><div class="line">            <span class="keyword">if</span>(targetClass == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FactoryBeanNotInitializedException(<span class="string">"Cannot determine target class for proxy"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//这里是设置代理对象的接口</span></div><div class="line">            <span class="keyword">this</span>.setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, <span class="keyword">this</span>.proxyClassLoader));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>.setFrozen(<span class="keyword">this</span>.freezeProxy);</div><div class="line">        <span class="comment">//这里方法会使用ProxyFactory生成需要的Proxy</span></div><div class="line">        <span class="keyword">this</span>.singletonInstance = <span class="keyword">this</span>.getProxy(<span class="keyword">this</span>.createAopProxy());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.singletonInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>进入ProxyCreatorSupport的createAopProxy，源码如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</div><div class="line">    activate();</div><div class="line">&#125;</div><div class="line"><span class="comment">//通过AopProxyFactory取得AopProxy，AopProxyFactory是在初始化函数中定义的，使用的是DefaultAopProxyFactory</span></div><div class="line"><span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>那么DefaultAopProxyFactory如何生成AopProxy了，这里有两种方式，JdkDynamicAopProxy和CglibProxyFactory,DefaultAopProxyFactory的createAopProxy的源码如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</div><div class="line">            <span class="comment">//获取配置的目标对象</span></div><div class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</div><div class="line">            <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//如果没有目标对象，抛出异常，提醒AOP应用提供正确的目标配置</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</div><div class="line">                        <span class="string">"Either an interface or a target is required for proxy creation."</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 这个判断很重要，通过目标类是否是接口来决定采用什么代理方式</span></div><div class="line">            <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//由于CGLIB是一个第三方类库，所以需要在CLASSPATH中配置</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>由于我们这里目标类是接口，所以采用JdkDynamicAopProxy 生成AopProxy代理对象，我们可以看一下JdkDynamicAopProxy的invoke方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">       Object oldProxy = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</div><div class="line">       TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</div><div class="line">       Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</div><div class="line">       Object target = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">       Object var13;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">if</span>(!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</div><div class="line">               Boolean var20 = Boolean.valueOf(<span class="keyword">this</span>.equals(args[<span class="number">0</span>]));</div><div class="line">               <span class="keyword">return</span> var20;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span>(!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</div><div class="line">               Integer var18 = Integer.valueOf(<span class="keyword">this</span>.hashCode());</div><div class="line">               <span class="keyword">return</span> var18;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">if</span>(method.getDeclaringClass() == DecoratingProxy.class) &#123;</div><div class="line">               Class var17 = AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</div><div class="line">               <span class="keyword">return</span> var17;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           Object retVal;</div><div class="line"></div><div class="line">           <span class="comment">// Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知</span></div><div class="line">           <span class="keyword">if</span>(!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</div><div class="line">               retVal = AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</div><div class="line">               <span class="keyword">return</span> retVal;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">if</span>(<span class="keyword">this</span>.advised.exposeProxy) &#123;</div><div class="line">               oldProxy = AopContext.setCurrentProxy(proxy);</div><div class="line">               setProxyContext = <span class="keyword">true</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">//获得目标对象的类</span></div><div class="line">           target = targetSource.getTarget();</div><div class="line">           <span class="keyword">if</span>(target != <span class="keyword">null</span>) &#123;</div><div class="line">               targetClass = target.getClass();</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 获得拦截链</span></div><div class="line">           List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</div><div class="line">           <span class="comment">// 如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)</span></div><div class="line">           <span class="keyword">if</span>(chain.isEmpty()) &#123;</div><div class="line">               Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</div><div class="line">               retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="comment">//创建MethodInvocation</span></div><div class="line">               MethodInvocation invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</div><div class="line">               <span class="comment">// 处理通知</span></div><div class="line">               retVal = invocation.proceed();</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           Class&lt;?&gt; returnType = method.getReturnType();</div><div class="line">           <span class="keyword">if</span>(retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp; returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp; !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</div><div class="line">               retVal = proxy;</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           var13 = retVal;</div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           <span class="keyword">if</span>(target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</div><div class="line">               targetSource.releaseTarget(target);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">if</span>(setProxyContext) &#123;</div><div class="line">               AopContext.setCurrentProxy(oldProxy);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> var13;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>如果被代理对象没有实现需要被代理的接口，则使用CGLIB动态代理，CGLIB动态代理按照前面的分析基本与JDK动态代理一样，由于在Spring AOP中对应的包装类为CglibAopProxy，CglibAopProxy的intercept回调方法的实现和JdkDynamicAopProxy的回调实现是非常类似的，只是在CglibAopProxy中构造的是CglibMethodInvocation对象来完成拦截器链的调用，这里看一下与invoke类似的getCallbacks源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Callback[] getCallbacks(Class&lt;?&gt; rootClass) <span class="keyword">throws</span> Exception &#123;</div><div class="line">    <span class="keyword">boolean</span> exposeProxy = <span class="keyword">this</span>.advised.isExposeProxy();</div><div class="line">    <span class="keyword">boolean</span> isFrozen = <span class="keyword">this</span>.advised.isFrozen();</div><div class="line">    <span class="keyword">boolean</span> isStatic = <span class="keyword">this</span>.advised.getTargetSource().isStatic();</div><div class="line">    Callback aopInterceptor = <span class="keyword">new</span> CglibAopProxy.DynamicAdvisedInterceptor(<span class="keyword">this</span>.advised);</div><div class="line">    Object targetInterceptor;</div><div class="line">    <span class="keyword">if</span>(exposeProxy) &#123;</div><div class="line">        targetInterceptor = isStatic?<span class="keyword">new</span> CglibAopProxy.StaticUnadvisedExposedInterceptor(<span class="keyword">this</span>.advised.getTargetSource().getTarget()):<span class="keyword">new</span> CglibAopProxy.DynamicUnadvisedExposedInterceptor(<span class="keyword">this</span>.advised.getTargetSource());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        targetInterceptor = isStatic?<span class="keyword">new</span> CglibAopProxy.StaticUnadvisedInterceptor(<span class="keyword">this</span>.advised.getTargetSource().getTarget()):<span class="keyword">new</span> CglibAopProxy.DynamicUnadvisedInterceptor(<span class="keyword">this</span>.advised.getTargetSource());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Callback targetDispatcher = (Callback)(isStatic?<span class="keyword">new</span> CglibAopProxy.StaticDispatcher(<span class="keyword">this</span>.advised.getTargetSource().getTarget()):<span class="keyword">new</span> CglibAopProxy.SerializableNoOp());</div><div class="line">    Callback[] mainCallbacks = <span class="keyword">new</span> Callback[]&#123;aopInterceptor, (Callback)targetInterceptor, <span class="keyword">new</span> CglibAopProxy.SerializableNoOp(), targetDispatcher, <span class="keyword">this</span>.advisedDispatcher, <span class="keyword">new</span> CglibAopProxy.EqualsInterceptor(<span class="keyword">this</span>.advised), <span class="keyword">new</span> CglibAopProxy.HashCodeInterceptor(<span class="keyword">this</span>.advised)&#125;;</div><div class="line">    Callback[] callbacks;</div><div class="line">    <span class="keyword">if</span>(isStatic &amp;&amp; isFrozen) &#123;</div><div class="line">        Method[] methods = rootClass.getMethods();</div><div class="line">        Callback[] fixedCallbacks = <span class="keyword">new</span> Callback[methods.length];</div><div class="line">        <span class="keyword">this</span>.fixedInterceptorMap = <span class="keyword">new</span> HashMap(methods.length);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; methods.length; ++x) &#123;</div><div class="line">            <span class="comment">// 获得拦截链</span></div><div class="line">            List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(methods[x], rootClass);</div><div class="line">            <span class="comment">// 准备处理通知</span></div><div class="line">            fixedCallbacks[x] = <span class="keyword">new</span> CglibAopProxy.FixedChainStaticTargetInterceptor(chain, <span class="keyword">this</span>.advised.getTargetSource().getTarget(), <span class="keyword">this</span>.advised.getTargetClass());</div><div class="line">            <span class="keyword">this</span>.fixedInterceptorMap.put(methods[x].toString(), Integer.valueOf(x));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        callbacks = <span class="keyword">new</span> Callback[mainCallbacks.length + fixedCallbacks.length];</div><div class="line">        System.arraycopy(mainCallbacks, <span class="number">0</span>, callbacks, <span class="number">0</span>, mainCallbacks.length);</div><div class="line">        System.arraycopy(fixedCallbacks, <span class="number">0</span>, callbacks, mainCallbacks.length, fixedCallbacks.length);</div><div class="line">        <span class="keyword">this</span>.fixedInterceptorOffset = mainCallbacks.length;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        callbacks = mainCallbacks;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> callbacks;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/u010425776/article/details/59112466" target="_blank" rel="external"> 深入剖析Spring(四)——AOP</a></li>
<li><a href="https://blog.csdn.net/zly9923218/article/details/51348583" target="_blank" rel="external">Spring AOP源码分析（生成代理对象）</a></li>
<li><a href="https://blog.csdn.net/zhangliangzi/article/details/52334964" target="_blank" rel="external">Spring AOP四种实现方式Demo详解与相关知识探究</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前一节讲到Spring的核心概念IOC，那么就不能不提到Spring的另一个核心概念AOP，我们先是先讲一下它的概念与原理实现，然后在讲Spring中AOP的实现。
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Spring" scheme="http://bestlixiang.site/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Spring(二)_Spring之IOC</title>
    <link href="http://bestlixiang.site/2018/04/11/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Spring(%E4%BA%8C)_Spring%E4%B9%8BIOC/"/>
    <id>http://bestlixiang.site/2018/04/11/深入SSM/揭秘Spring(二)_Spring之IOC/</id>
    <published>2018-04-11T02:26:40.000Z</published>
    <updated>2018-04-11T02:29:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：前一篇文章我们介绍了Spring的整体架构以及核心组件，接下来我们将讲解Spring的核心概念之一IOC，我们将先简单介绍IOC与DI，然后再深入SpringIOC容器的工作流程。<a id="more"></a></p>
<h1 id="IOC与DI"><a href="#IOC与DI" class="headerlink" title="IOC与DI"></a>IOC与DI</h1><p>IoC和DI是Spring的两个核心概念，很多人都把它们视为相同的东西（之前自己也一直这样认为），<strong>但事实并非如此</strong>。</p>
<ul>
<li>IoC(Inversion of Control)：控制反转。</li>
<li>DI(Dependency Injection)：依赖注入</li>
</ul>
<p><strong>开始画重点了：</strong> 控制反转是<strong>目的</strong>，依赖注入是实现控制反转的<strong>手段</strong>。</p>
<p>控制反转是一种设计模式思想，它是一种宽泛的概念，只要一个类将对它内部状态的控制权交由其他机制去完成即为控制反转。控制反转是为了降低类与类之间的耦合度。而Spring采用依赖注入这一具体的手段来达到控制反转的目的。</p>
<p>关于依赖注入可以看我之前的文章<a href="http://bestlixiang.site/2018/02/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%88%E5%90%B9%E5%93%8D%E5%8F%A3%E5%8F%B7-6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">先吹响口号_6大设计原则</a>中的依赖倒置原则 DIP一节，这里就不做过多的介绍了。</p>
<h1 id="IOC容器工作流程"><a href="#IOC容器工作流程" class="headerlink" title="IOC容器工作流程"></a>IOC容器工作流程</h1><p>IOC容器实际上就是 Context 组件结合其他Bean和Core组件共同构建了一个 Bean 关系网，如何构建这个关系网？构建的入口就在 AbstractApplicationContext 类的 refresh 方法中。这个方法的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</div><div class="line">        Object var1 = <span class="keyword">this</span>.startupShutdownMonitor;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</div><div class="line">            <span class="comment">// 为刷新准备新的context</span></div><div class="line">            <span class="keyword">this</span>.prepareRefresh();</div><div class="line">            <span class="comment">// **创建BeanFactory**</span></div><div class="line">            ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</div><div class="line">            <span class="comment">// 刷新所有BeanFactory子容器</span></div><div class="line">            <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 注册实现了BeanPostProcessor接口的bean（AOP使用）</span></div><div class="line">                <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</div><div class="line">                <span class="comment">// 初始化和执行BeanFactoryPostProcessor beans</span></div><div class="line">                <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</div><div class="line">                <span class="comment">// 初始化和执行BeanPostProcessors beans</span></div><div class="line">                <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</div><div class="line">                <span class="comment">// 初始化MessageSource</span></div><div class="line">                <span class="keyword">this</span>.initMessageSource();</div><div class="line">                <span class="comment">// 初始化 event multicaster （多路广播）</span></div><div class="line">                <span class="keyword">this</span>.initApplicationEventMulticaster();</div><div class="line">                <span class="comment">// 刷新由子类实现的方法</span></div><div class="line">                <span class="keyword">this</span>.onRefresh();</div><div class="line">                <span class="comment">// 注册事件</span></div><div class="line">                <span class="keyword">this</span>.registerListeners();</div><div class="line">                <span class="comment">// 初始化单例Bean</span></div><div class="line">                <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</div><div class="line">                <span class="comment">// 发布相应的事件</span></div><div class="line">                <span class="keyword">this</span>.finishRefresh();</div><div class="line">            &#125; <span class="keyword">catch</span> (BeansException var9) &#123;</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</div><div class="line">                    <span class="keyword">this</span>.logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> + var9);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 销毁beans</span></div><div class="line">                <span class="keyword">this</span>.destroyBeans();</div><div class="line">                <span class="keyword">this</span>.cancelRefresh(var9);</div><div class="line">                <span class="keyword">throw</span> var9;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">this</span>.resetCommonCaches();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这个方法就是构建整个IOC容器过程的完整的代码，了解了里面的每一行代码基本上就了解大部分 Spring 的原理和功能了。</p>
<p>这段代码主要包含这样几个步骤：</p>
<ul>
<li>构建 BeanFactory</li>
<li>注册可能感兴趣的事件</li>
<li>创建 Bean 实例对象</li>
<li>触发被监听的事件</li>
</ul>
<p>其中我们我们最关心的就是BeanFactory和创建Bean实例对象了，我们下面可以好好看看：</p>
<h2 id="创建BeanFactory工厂"><a href="#创建BeanFactory工厂" class="headerlink" title="创建BeanFactory工厂"></a>创建BeanFactory工厂</h2><p>我们利用debug可以进入到refresh()方法里面的obtainFreshBeanFactory()方法里面的refreshBeanFactory() <strong>（有点绕，但是自己就不画时序图了）</strong> 去看看他的创建代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.hasBeanFactory()) &#123;</div><div class="line">            <span class="keyword">this</span>.destroyBeans();</div><div class="line">            <span class="keyword">this</span>.closeBeanFactory();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 创建一个DefaultListableBeanFactory（上一节说过的很重要的类）</span></div><div class="line">            DefaultListableBeanFactory beanFactory = <span class="keyword">this</span>.createBeanFactory();</div><div class="line">            beanFactory.setSerializationId(<span class="keyword">this</span>.getId());</div><div class="line">            <span class="keyword">this</span>.customizeBeanFactory(beanFactory);</div><div class="line">            <span class="comment">// **这个方法会加载、解析Bean的定义**</span></div><div class="line">            <span class="keyword">this</span>.loadBeanDefinitions(beanFactory);</div><div class="line">            Object var2 = <span class="keyword">this</span>.beanFactoryMonitor;</div><div class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.beanFactoryMonitor) &#123;</div><div class="line">                <span class="keyword">this</span>.beanFactory = beanFactory;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException var5) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + <span class="keyword">this</span>.getDisplayName(), var5);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="创建Bean实例并构建Bean的关系网"><a href="#创建Bean实例并构建Bean的关系网" class="headerlink" title="创建Bean实例并构建Bean的关系网"></a>创建Bean实例并构建Bean的关系网</h2><p>我们利用debug可以进入到refresh()方法里面的finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory)方法里面的preInstantiateSingletons() <strong>（有点绕，但是自己就不画时序图了）</strong> 去看看它的创建Bean的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</div><div class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList(<span class="keyword">this</span>.beanDefinitionNames);</div><div class="line">        Iterator var2 = beanNames.iterator();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">                String beanName;</div><div class="line">                RootBeanDefinition bd;</div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        <span class="keyword">do</span> &#123;</div><div class="line">                            <span class="keyword">if</span>(!var2.hasNext()) &#123;</div><div class="line">                                var2 = beanNames.iterator();</div><div class="line"></div><div class="line">                                <span class="keyword">while</span>(var2.hasNext()) &#123;</div><div class="line">                                    beanName = (String)var2.next();</div><div class="line">                                    Object singletonInstance = <span class="keyword">this</span>.getSingleton(beanName);</div><div class="line">                                    <span class="keyword">if</span>(singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</div><div class="line">                                        <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;</div><div class="line">                                        <span class="keyword">if</span>(System.getSecurityManager() != <span class="keyword">null</span>) &#123;</div><div class="line">                                            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</div><div class="line">                                                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                                                    smartSingleton.afterSingletonsInstantiated();</div><div class="line">                                                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                                                &#125;</div><div class="line">                                            &#125;, <span class="keyword">this</span>.getAccessControlContext());</div><div class="line">                                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                            smartSingleton.afterSingletonsInstantiated();</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;</div><div class="line">                                &#125;</div><div class="line"></div><div class="line">                                <span class="keyword">return</span>;</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            beanName = (String)var2.next();</div><div class="line">                            bd = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</div><div class="line">                        &#125; <span class="keyword">while</span>(bd.isAbstract());</div><div class="line">                    &#125; <span class="keyword">while</span>(!bd.isSingleton());</div><div class="line">                &#125; <span class="keyword">while</span>(bd.isLazyInit());</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.isFactoryBean(beanName)) &#123;</div><div class="line">                    <span class="comment">// 这个Bean很重要，Spring有一大半扩展功能都与这个Bean有关系，</span></div><div class="line">                    <span class="comment">// 它是个工厂Bean，可以产生Bean实例的Bean，</span></div><div class="line">                    <span class="comment">// Spring获取FactoryBean本身的对象是通过在前面加上&amp;来完成的                    </span></div><div class="line">                    <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean)<span class="keyword">this</span>.getBean(<span class="string">"&amp;"</span> + beanName);</div><div class="line">                    <span class="keyword">boolean</span> isEagerInit;</div><div class="line">                    <span class="keyword">if</span>(System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</div><div class="line">                        isEagerInit = ((Boolean)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</div><div class="line">                            <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                                <span class="keyword">return</span> Boolean.valueOf(((SmartFactoryBean)factory).isEagerInit());</div><div class="line">                            &#125;</div><div class="line">                        &#125;, <span class="keyword">this</span>.getAccessControlContext())).booleanValue();</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        isEagerInit = factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp; ((SmartFactoryBean)factory).isEagerInit();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span>(isEagerInit) &#123;</div><div class="line">                        <span class="comment">// 普通的Bean只要通过getBean方法直接创建它的实例</span></div><div class="line">                        <span class="comment">// getBean方法里面包含了他们关系的创建</span></div><div class="line">                        <span class="keyword">this</span>.getBean(beanName);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">this</span>.getBean(beanName);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="IOC容器的扩展点"><a href="#IOC容器的扩展点" class="headerlink" title="IOC容器的扩展点"></a>IOC容器的扩展点</h2><p>如何让这些 Bean 对象有一定的扩展性（就是可以加入用户的一些操作）也是我们需要思考的！那么有哪些扩展点呢？ Spring 又是如何调用到这些扩展点的？</p>
<p>对 Spring 的 IOC 容器来说，主要有这么几个扩展点：</p>
<ul>
<li>BeanFactoryPostProcessor， BeanPostProcessor：他们分别是在构建 BeanFactory 和构建 Bean 对象时调用。</li>
<li>InitializingBean 和 DisposableBean ：他们分别是在 Bean 实例创建和销毁时被调用。用户可以实现这些接口中定义的方法，Spring 就会在适当的时候调用他们。</li>
<li>FactoryBean ：他是个特殊的 Bean，这个 Bean 可以被用户更多的控制。</li>
</ul>
<p>这些扩展点通常也是我们使用 Spring 来完成我们特定任务的地方，<strong>是否精通 Spring 就看你有没有掌握好Spring有哪些扩展点，并且如何使用他们。</strong></p>
<p>要知道如何使用他们就必须了解他们内在的机理。可以用下面一个比喻（优秀）来解释：</p>
<p>我们把 IOC 容器比作一个箱子，这个箱子里有若干个球的模子，可以用这些模子来造很多种不同的球，还有一个造这些球模的机器，这个机器可以产生球模。那么他们的对应关系就是 BeanFactory 就是那个造球模的机器，球模就是 Bean，而球模造出来的球就是 Bean 的实例。</p>
<p>那前面所说的几个扩展点又在什么地方呢？ BeanFactoryPostProcessor 对应到当造球模被造出来时，你将有机会可以对其做出设当的修正，也就是他可以帮你修改球模。而 InitializingBean 和 DisposableBean 是在球模造球的开始和结束阶段，你可以完成一些预备和扫尾工作。BeanPostProcessor 就可以让你对球模造出来的球做出适当的修正。最后还有一个 FactoryBean，它可是一个神奇的球模。这个球模不是预先就定型了，而是由你来给他确定它的形状，既然你可以确定这个球模型的形状，当然他造出来的球肯定就是你想要的球了，这样在这个箱子里你可以发现所有你想要的球。</p>
<h2 id="IOC容器的使用"><a href="#IOC容器的使用" class="headerlink" title="IOC容器的使用"></a>IOC容器的使用</h2><p>我们使用 Spring 必须要首先构建 IOC 容器，没有它 Spring 无法工作，ApplicatonContext.xml 就是 IOC 容器的默认配置文件，Spring 的所有特性功能都是基于这个 IOC 容器工作的，比如后面要介绍的 AOP。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入分析Java Web技术内幕》</li>
<li><a href="https://blog.csdn.net/u010425776/article/details/55269848" target="_blank" rel="external"> 深入剖析Spring(一)——IoC的基本概念(从面向对象角度介绍)</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前一篇文章我们介绍了Spring的整体架构以及核心组件，接下来我们将讲解Spring的核心概念之一IOC，我们将先简单介绍IOC与DI，然后再深入SpringIOC容器的工作流程。
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Spring" scheme="http://bestlixiang.site/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Spring(一)_Spring架构</title>
    <link href="http://bestlixiang.site/2018/04/10/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Spring-%E4%B8%80-Spring%E6%9E%B6%E6%9E%84/"/>
    <id>http://bestlixiang.site/2018/04/10/深入SSM/揭秘Spring-一-Spring架构/</id>
    <published>2018-04-10T11:31:40.000Z</published>
    <updated>2018-04-10T11:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：Spring作为现在最优秀的框架之一，被广泛得使用在Web场景中。很多人只会使用，但是却不知道Spring整个体系架构。<a id="more"></a></p>
<h1 id="Spring的骨骼架构"><a href="#Spring的骨骼架构" class="headerlink" title="Spring的骨骼架构"></a>Spring的骨骼架构</h1><p>Spring总共有十几个组件，但是真正核心的组件只有几个，如下图为Spring框架开始以来拥有的总体架构图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/gif/spring.gif" alt="spring"></p>
<p>从上图可以看出，在Spring框架中的 <strong>核心组件</strong> 只有三个：core、context、bean。他们构建起整个Spring的骨骼架构，没有他们就不可能有AOP、Web等上层的 <strong>特性功能</strong> 。</p>
<h2 id="Spring的设计理念"><a href="#Spring的设计理念" class="headerlink" title="Spring的设计理念"></a>Spring的设计理念</h2><p>上面说了三个核心组件，但是最重要就是Bean组件了，用过Spring的人都知道，我们所有的类基本上都会交给Spring托管，也就是说Spring就是面向Bean的编程。Bean在Spring中的作用就像Object对OOP的意义一样，没有对象的概念就没有面向对象的概念，在Spring中没有Bean也就没有Spring存在的意义。</p>
<p><strong>使用Spring最大的原因：</strong> 是他解决了一个非常关键的问题，它可以让你把对象之间的依赖关系解耦，其中的关系交由<strong>IOC容器</strong>（Bean关系的集合）来管理，核心就是<strong>依赖注入机制</strong>。Spring也正是通过把对象包装在Bean中达到管理这些对象及做一些列额外操作的目的。</p>
<p><strong>一般框架设计理念：</strong> 先构建一个数据结构，然后根据这个数据结构设计它的生存环境，并让它在这个环境中按照一定的规律不停的运动，在他不停运动的过程中设计它们与环境或者与其他个体完成信息交换。</p>
<h2 id="核心组件如何协同工作"><a href="#核心组件如何协同工作" class="headerlink" title="核心组件如何协同工作"></a>核心组件如何协同工作</h2><p>参考《深入分析Java Web技术内幕》一书中有个形象的比喻：Spring框架就像一场演出，Bean相当于演员，Context相当于演出的舞台背景、Core相当于演出的道具（把演员联系起来）。如果想演出足够新颖，就需要Spring提供的其他特色功能了。</p>
<p>回到Spring：Bean包装的是Object，而Object必然有数据，如何给这些数据提供生成环境就是Context要解决的事情，对于Context来说就是要发现每个Bean之间的关系，为他们建立这种关系并且维护好这种关系，而发现、建立和维护每个Bean之间的关系维护这种关系就需要Core组件了，Core组件其实就是发现、建立和维护每个Bean之间的关系所需要的一些列工具。最后我们发现Context就是一个Bean关系的集合，这个关系集合就叫<strong>IOC容器</strong>，当建立起IOC容器，Spring就可以工作了。他们的关系可以用下图来描述：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/gif/ccb.gif" alt="ccb"></p>
<h1 id="核心组件解析"><a href="#核心组件解析" class="headerlink" title="核心组件解析"></a>核心组件解析</h1><h2 id="Bean组件"><a href="#Bean组件" class="headerlink" title="Bean组件"></a>Bean组件</h2><p>Bean 组件在 Spring 的 org.springframework.beans 包下。这个包下的所有类主要解决了三件事：<strong>Bean 的定义、 Bean 的解析以及对Bean 的创建</strong>。对 Spring 的使用者来说唯一需要关心的就是 Bean 的创建，其他两个由 Spring 在内部帮你完成了，对你来说是透明的。</p>
<h3 id="Bean的定义"><a href="#Bean的定义" class="headerlink" title="Bean的定义"></a>Bean的定义</h3><p>Bean 的定义主要有 BeanDefinition 描述，如下图（RootBeanDefinition类图）说明了这些类的层次关系：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/rootBeanDefinition.png" alt="rootBeanDefinition"></p>
<p>Bean 的定义就是完整的描述了在 Spring 的配置的Bean中所有的信息。当 Spring 成功解析你定义的一个Bean后，在 Spring 的内部他就被转化成 BeanDefinition 对象，它可以定义为SINGLETON还是PROTOTYPE。以后所有的操作都是对这个对象完成的。</p>
<h3 id="Bean的解析"><a href="#Bean的解析" class="headerlink" title="Bean的解析"></a>Bean的解析</h3><p>Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析方式有很多种，这也就导致配置方式有很多种（之后会介绍各种Bean的配置方法，如xml，扫描，注解、java配置）。这里就介绍一下最早的解析XML配置，它的过程主要通过下图中的类(XmlBeanDefinitionReader)完成：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/XmlBeanDefinitionReader.png" alt="XmlBeanDefinitionReader"></p>
<h3 id="Bean的创建"><a href="#Bean的创建" class="headerlink" title="Bean的创建"></a>Bean的创建</h3><p>Spring Bean 的创建是典型的工厂模式，我们可以通过DefaultListableBeanFactory这个类来了解Spring的工厂模式，工厂模式的顶级接口是 BeanFactory，下图是这个工厂的继承层次关系：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/defaultListableBeanFactory.png" alt="image"></p>
<p>BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory。但是从上图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，他实现了所有的接口。</p>
<p>框架核心：那为何要定义这么多层次的接口呢？</p>
<p>查阅这些接口的源码和说明发现，每个接口都有他使用的场合，它主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制，具体如下：</p>
<ul>
<li>ListableBeanFactory 接口表示这些 Bean 是可列表的</li>
<li>HierarchicalBeanFactory 表示的是这些 Bean是有继承关系的，也就是每个 Bean有可能有父 Bean。</li>
<li>AutowireCapableBeanFactory 接口定义Bean的自动装配规则。</li>
</ul>
<p>这四个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为。</p>
<h2 id="Context组件"><a href="#Context组件" class="headerlink" title="Context组件"></a>Context组件</h2><p>Context 在 Spring 的 org.springframework.context 包下，<strong>Context 组件在 Spring 中的作用实际上就是给Spring提供一个运行时的环境，用以保存各个对象的状态</strong> 。下面看一下这个环境是如何构建的。</p>
<p>ApplicationContext 是 Context 的顶级父类，他除了能标识一个应用环境的基本信息外，他还继承了六个接口，这六个接口主要是扩展了 Context 的功能。下面是 Context 相关的类结构图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/AbstractRefreshableWebApplicationContext.png" alt="Context"></p>
<p>从上图中可以看出 ApplicationContext 继承了BeanFactory，这也说明了 Spring 容器中运行的主体对象是 Bean，另外 ApplicationContext 继承了 ResourceLoader 接口，使得 ApplicationContext 可以访问到任何外部资源（就是Core里面的工具了，这将在 Core 中详细说明）。</p>
<p>ApplicationContext 的子类主要包含两个方面：</p>
<ul>
<li>ConfigurableApplicationContext：表示该Context是可修改的，也就是在构建 Context 中用户可以动态添加或修改已有的配置信息，它下面又有多个子类，其中最经常使用的是可更新的 Context，即 AbstractRefreshableApplicationContext 类。</li>
<li>WebApplicationContext ：看到web就知道这为 web 准备的 Context 他可以直接访问到 ServletContext，通常情况下，这个接口使用的少。<br>再往下分就是按照构建 Context 的文件类型（没列出，感兴趣的可以自己去看），接着就是访问 Context 的方式。这样一级一级构成了完整的 Context 等级层次。</li>
</ul>
<p>总体来说 ApplicationContext 必须要完成以下几件事：</p>
<ul>
<li>标识一个应用环境</li>
<li>利用 BeanFactory 创建 Bean 对象</li>
<li>保存对象关系表</li>
<li>能够捕获各种事件</li>
</ul>
<p>Context 作为 Spring 的 <strong>IOC 容器</strong>，基本上整合了 Spring 的大部分功能，或者说是大部分功能的基础。</p>
<h2 id="Core组件"><a href="#Core组件" class="headerlink" title="Core组件"></a>Core组件</h2><p>Core 组件在Spring 的org.springframework.core包下，它作为 Spring的核心组件，他其中包含了很多的关键类，其中一个重要组成部分就是定义了资源（Resource）的访问方式。这种<strong>把所有资源都抽象成一个接口的方式</strong>很值得在以后的设计中拿来学习。下面就重要看一下这个部分在 Spring 的作用。我们通过下图（ Resource 相关的类结构图）来理解：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/resource.png" alt="resource"></p>
<p>从上图可以看出 Resource 接口封装了各种可能的资源类型，也就是对使用者来说屏蔽了文件类型的不同。对资源的提供者来说，如何把资源包装起来交给其他人用这也是一个问题(所以产生了很多方式)，我们看到 Resource 接口继承了 InputStreamSource 接口，这个接口中有个 getInputStream 方法，返回的是 InputStream 类。这样所有的资源都被可以通过 InputStream 这个类来获取，所以也屏蔽了资源的提供者。另外还有一个问题就是加载资源的问题，也就是资源的加载者要统一，从上图中可以看出这个任务是由 ResourceLoader 接口完成，他屏蔽了所有的资源加载者的差异，只需要实现这个接口就可以加载所有的资源，他的默认实现是 DefaultResourceLoader。</p>
<p>那Context 和 Resource 是如何建立关系的？下面是他们的类关系图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/cc.png" alt="cc"></p>
<p>从上图可以看出，Context 是把资源的加载、解析和描述工作委托给了 ResourcePatternResolver 类来完成，他相当于一个接头人，他把资源的加载、解析和资源的定义整合在一起便于其他组件使用。Core 组件中还有很多类似的方式。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入分析Java Web技术内幕》</li>
<li><a href="http://www.jb51.net/article/112039.htm" target="_blank" rel="external">Spring多种加载Bean方式解析</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：Spring作为现在最优秀的框架之一，被广泛得使用在Web场景中。很多人只会使用，但是却不知道Spring整个体系架构。
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Spring" scheme="http://bestlixiang.site/tags/Spring/"/>
    
  </entry>
  
</feed>
