<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rex note</title>
  <subtitle>雨过，云过</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bestlixiang.site/"/>
  <updated>2019-06-19T11:46:10.269Z</updated>
  <id>http://bestlixiang.site/</id>
  
  <author>
    <name>rex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RocketMQ源码分析——Broker启动</title>
    <link href="http://bestlixiang.site/2019/06/19/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Broker%E5%90%AF%E5%8A%A8/"/>
    <id>http://bestlixiang.site/2019/06/19/RocketMQ源码/RocketMQ源码分析——Broker启动/</id>
    <published>2019-06-19T11:46:01.000Z</published>
    <updated>2019-06-19T11:46:10.269Z</updated>
    
    <content type="html"><![CDATA[<p>引：前面讲了NameServer，Producer，Consumer，现在终于轮到Broker了，对于一个消息队列来说，Broker是当仁不让的核心~<a id="more"></a></p>
<h1 id="五大作用"><a href="#五大作用" class="headerlink" title="五大作用"></a>五大作用</h1><ul>
<li>存储消息</li>
<li>接收生产者提交的消息</li>
<li>回复consumer的消息拉取请求</li>
<li>主从节点间同步数据保证高可用</li>
<li>提供简单的api来查询磁盘上的临时数据</li>
</ul>
<p>之后我们也将从上面的作用来进行源码的探索！</p>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>真实使用当然是用命令行去部署，这里为了看源码，我们把<strong>环境搭建</strong>那篇文章的例子搬过来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 设置版本号，很关键，不然topic创建不成功</span></span><br><span class="line">      System.setProperty(RemotingCommand.REMOTING_VERSION_KEY, Integer.toString(MQVersion.CURRENT_VERSION));</span><br><span class="line">      <span class="keyword">final</span> BrokerConfig brokerConfig = <span class="keyword">new</span> BrokerConfig();</span><br><span class="line">      brokerConfig.setBrokerName(<span class="string">"broker-a"</span>);</span><br><span class="line">      brokerConfig.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line"></span><br><span class="line">      BrokerController brokerController = <span class="keyword">new</span> BrokerController(</span><br><span class="line">              brokerConfig,</span><br><span class="line">              <span class="keyword">new</span> NettyServerConfig(),</span><br><span class="line">              <span class="keyword">new</span> NettyClientConfig(),</span><br><span class="line">              <span class="keyword">new</span> MessageStoreConfig());</span><br><span class="line">      assertThat(brokerController.initialize());</span><br><span class="line">      brokerController.start();</span><br><span class="line">      <span class="comment">// 不让主方法结束</span></span><br><span class="line">      Thread.sleep(DateUtils.MILLIS_PER_DAY);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Broker启动"><a href="#Broker启动" class="headerlink" title="Broker启动"></a>Broker启动</h1><p>从上面的例子可以看出Broker启动实质就是<code>org.apache.rocketmq.broker.BrokerController</code>完成初始化和启动的过程。</p>
<h2 id="BrokerController初始化"><a href="#BrokerController初始化" class="headerlink" title="BrokerController初始化"></a>BrokerController初始化</h2><p>我们看到<code>org.apache.rocketmq.broker.BrokerController#initialize()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 从持久化文件中加载数据到内存中</span></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">this</span>.topicConfigManager.load();</span><br><span class="line"></span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.consumerOffsetManager.load();</span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.subscriptionGroupManager.load();</span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.consumerFilterManager.load();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 消息存取的核心接口初始化</span></span><br><span class="line">            <span class="keyword">this</span>.messageStore =</span><br><span class="line">                <span class="keyword">new</span> DefaultMessageStore(<span class="keyword">this</span>.messageStoreConfig, <span class="keyword">this</span>.brokerStatsManager, <span class="keyword">this</span>.messageArrivingListener,</span><br><span class="line">                    <span class="keyword">this</span>.brokerConfig);</span><br><span class="line">            <span class="comment">// messageStore的指标统计类，提供最近一天的消息吞吐量的统计数据</span></span><br><span class="line">            <span class="keyword">this</span>.brokerStats = <span class="keyword">new</span> BrokerStats((DefaultMessageStore) <span class="keyword">this</span>.messageStore);</span><br><span class="line">            <span class="comment">//load plugin</span></span><br><span class="line">            MessageStorePluginContext context = <span class="keyword">new</span> MessageStorePluginContext(messageStoreConfig, brokerStatsManager, messageArrivingListener, brokerConfig);</span><br><span class="line">            <span class="keyword">this</span>.messageStore = MessageStoreFactory.build(context, <span class="keyword">this</span>.messageStore);</span><br><span class="line">            <span class="comment">// 添加消息分发器，分发到布隆过滤器</span></span><br><span class="line">            <span class="keyword">this</span>.messageStore.getDispatcherList().addFirst(<span class="keyword">new</span> CommitLogDispatcherCalcBitMap(<span class="keyword">this</span>.brokerConfig, <span class="keyword">this</span>.consumerFilterManager));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">            log.error(<span class="string">"Failed to initialize"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// messageStore加载内存映射文件，commit log文件，consumer queue文件，index文件</span></span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.messageStore.load();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="comment">// 3. 初始化Netty Server</span></span><br><span class="line">        <span class="keyword">this</span>.remotingServer = <span class="keyword">new</span> NettyRemotingServer(<span class="keyword">this</span>.nettyServerConfig, <span class="keyword">this</span>.clientHousekeepingService);</span><br><span class="line">        NettyServerConfig fastConfig = (NettyServerConfig) <span class="keyword">this</span>.nettyServerConfig.clone();</span><br><span class="line">        <span class="comment">// 初始化VIP通道 Netty Server</span></span><br><span class="line">        fastConfig.setListenPort(nettyServerConfig.getListenPort() - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">this</span>.fastRemotingServer = <span class="keyword">new</span> NettyRemotingServer(fastConfig, <span class="keyword">this</span>.clientHousekeepingService);</span><br><span class="line">        <span class="comment">// 初始化一系列客户端指令执行的线程池，Netty处理的优化</span></span><br><span class="line">        <span class="keyword">this</span>.sendMessageExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getSendMessageThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getSendMessageThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.sendThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"SendMessageThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.pullMessageExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getPullMessageThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getPullMessageThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.pullThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"PullMessageThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.queryMessageExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getQueryMessageThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getQueryMessageThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.queryThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"QueryMessageThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.adminBrokerExecutor =</span><br><span class="line">            Executors.newFixedThreadPool(<span class="keyword">this</span>.brokerConfig.getAdminBrokerThreadPoolNums(), <span class="keyword">new</span> ThreadFactoryImpl(</span><br><span class="line">                <span class="string">"AdminBrokerThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.clientManageExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getClientManageThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getClientManageThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.clientManagerThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"ClientManageThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.heartbeatExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getHeartbeatThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getHeartbeatThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.heartbeatThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"HeartbeatThread_"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.endTransactionExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getEndTransactionThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getEndTransactionThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.endTransactionThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"EndTransactionThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.consumerManageExecutor =</span><br><span class="line">            Executors.newFixedThreadPool(<span class="keyword">this</span>.brokerConfig.getConsumerManageThreadPoolNums(), <span class="keyword">new</span> ThreadFactoryImpl(</span><br><span class="line">                <span class="string">"ConsumerManageThread_"</span>));</span><br><span class="line">        <span class="comment">// 将这些线程池添加到Netty Pipeline中</span></span><br><span class="line">        <span class="keyword">this</span>.registerProcessor();</span><br><span class="line">        <span class="comment">// 4. 打印broker的消息吞吐信息到日志文件定时任务，每天0点记录一次</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> initialDelay = UtilAll.computNextMorningTimeMillis() - System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> period = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>;</span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.getBrokerStats().record();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"schedule record error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, initialDelay, period, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="comment">//  记录consumerOffet到文件定时任务,默认5秒一次</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.consumerOffsetManager.persist();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"schedule persist consumerOffset error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="keyword">this</span>.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="comment">// 记录consumer filter到文件中定时任务,10秒一次</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.consumerFilterManager.persist();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"schedule persist consumer filter error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="comment">// 定时检查consumer的消费记录，如果延时太大,则disable consumer,不再往这个consumer投递消息</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.protectBroker();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"protectBroker error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, <span class="number">3</span>, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 打印当前Queue size日志</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.printWaterMark();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"printWaterMark error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">10</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 打印dispatch落后情况</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">"dispatch behind commit log &#123;&#125; bytes"</span>, BrokerController.<span class="keyword">this</span>.getMessageStore().dispatchBehindBytes());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"schedule dispatchBehindBytes error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="comment">// 定时更新nameserv address信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.brokerConfig.getNamesrvAddr() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.brokerOuterAPI.updateNameServerAddressList(<span class="keyword">this</span>.brokerConfig.getNamesrvAddr());</span><br><span class="line">            log.info(<span class="string">"Set user specified name server address: &#123;&#125;"</span>, <span class="keyword">this</span>.brokerConfig.getNamesrvAddr());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.brokerConfig.isFetchNamesrvAddrByAddressServer()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        BrokerController.<span class="keyword">this</span>.brokerOuterAPI.fetchNameServerAddr();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        log.error(<span class="string">"ScheduledTask fetchNameServerAddr exception"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是broker是slave，启动定时任务，每分钟从master同步配置和offset</span></span><br><span class="line">        <span class="keyword">if</span> (BrokerRole.SLAVE == <span class="keyword">this</span>.messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.messageStoreConfig.getHaMasterAddress() != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageStoreConfig.getHaMasterAddress().length() &gt;= <span class="number">6</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.messageStore.updateHaMasterAddress(<span class="keyword">this</span>.messageStoreConfig.getHaMasterAddress());</span><br><span class="line">                <span class="keyword">this</span>.updateMasterHAServerAddrPeriodically = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.updateMasterHAServerAddrPeriodically = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        BrokerController.<span class="keyword">this</span>.slaveSynchronize.syncAll();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        log.error(<span class="string">"ScheduledTask syncAll slave exception"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果broker是master，定时打印slave延时情况</span></span><br><span class="line">            <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        BrokerController.<span class="keyword">this</span>.printMasterAndSlaveDiff();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        log.error(<span class="string">"schedule printMasterAndSlaveDiff error."</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 初始化事务消息service</span></span><br><span class="line">        initialTransaction();</span><br><span class="line">        initialAcl();</span><br><span class="line">        initialRpcHooks();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑还是非常简单的，一看就知道他在干什么~</p>
<h2 id="BrokerController启动"><a href="#BrokerController启动" class="headerlink" title="BrokerController启动"></a>BrokerController启动</h2><p>当BrokerController初始化完成之后，我们看<code>org.apache.rocketmq.broker.BrokerController#start()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 启动消息存储服务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.messageStore != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.messageStore.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动Netty Server接收请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.remotingServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.remotingServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动VIP Channel Netty Server</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fastRemotingServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fastRemotingServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动TLS签名文件检测服务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fileWatchService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fileWatchService.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动Broker的Netty Client</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerOuterAPI != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerOuterAPI.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动PushConsumer的请求 Hold 服务 (后面会展开)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.pullRequestHoldService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.pullRequestHoldService.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监控客户端连接，定时检查Producer，Consumer和Filter是否长时间未收到心跳</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.clientHousekeepingService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.clientHousekeepingService.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动Filter Server</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.filterServerManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.filterServerManager.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册Broker到Namesrv</span></span><br><span class="line">    <span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时向Namesrv发心跳，如果有变化则同步Broker信息</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BrokerController.<span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, brokerConfig.isForceRegister());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"registerBrokerAll Exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">10</span>, Math.max(<span class="number">10000</span>, Math.min(brokerConfig.getRegisterNameServerPeriod(), <span class="number">60000</span>)), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerStatsManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerStatsManager.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动BrokerFastFailure服务，定时清理长时间未执行的客户端请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerFastFailure != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerFastFailure.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是Master，开启事务消息检查</span></span><br><span class="line">    <span class="keyword">if</span> (BrokerRole.SLAVE != messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.transactionalMessageCheckService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"Start transaction service!"</span>);</span><br><span class="line">            <span class="keyword">this</span>.transactionalMessageCheckService.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从整个过程来看还是比较简单的，水文一篇，但是后面会继续分析Broker的各个作用的实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前面讲了NameServer，Producer，Consumer，现在终于轮到Broker了，对于一个消息队列来说，Broker是当仁不让的核心~
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——Consumer</title>
    <link href="http://bestlixiang.site/2019/06/18/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Consumer/"/>
    <id>http://bestlixiang.site/2019/06/18/RocketMQ源码/RocketMQ源码分析——Consumer/</id>
    <published>2019-06-18T11:43:10.000Z</published>
    <updated>2019-06-18T11:43:32.676Z</updated>
    
    <content type="html"><![CDATA[<p>引：当消息达到Broker之后，就等着Consumer去consume了呀~<a id="more"></a></p>
<h1 id="消费方式"><a href="#消费方式" class="headerlink" title="消费方式"></a>消费方式</h1><ul>
<li><p>PullConsumer：消费者主动调用pull方法来获取消息，没有则返回</p>
</li>
<li><p>PushConsumer：虽然名为Push，但是是消费者主动循环发送Pull请求到broker，如果没有消息，broker会把请求放入等待队列，新消息到达后返回response</p>
</li>
</ul>
<p>所以本质上，两种方式都是通过消费者主动Pull来实现的。</p>
<h1 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h1><p>Consumer的消费模式在初始化consumer时设置的，主要有下面两种：</p>
<ul>
<li>Broadcast模式：消息会发送给group内所有consumer</li>
<li>Cluster模式：每条消息只会发送给group内的一个consumer，但是Cluster模式的支持消费失败重发，从而保证消息一定被消费</li>
</ul>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>这次我们主要看看PushConsumer，以Cluster模式消费的源码是如何实现的，因为这种方式相对来说是最复杂的一种。例子其实也是在之前<strong>环境搭建</strong>那边文章中例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">				<span class="comment">// 指定消费者组的PushConsumer</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_4"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指明Namesrv</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定消费开始位置</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 订阅Topic</span></span><br><span class="line">        consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 指定回调逻辑</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">"%s Receive New Messages: %s %n"</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">			  <span class="comment">// 启动</span></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Consumer启动"><a href="#Consumer启动" class="headerlink" title="Consumer启动"></a>Consumer启动</h1><p>之前其实在Producer分析里面带过Consumer，所以逻辑也是类似的。</p>
<h2 id="DefaultMQPushConsumer初始化"><a href="#DefaultMQPushConsumer初始化" class="headerlink" title="DefaultMQPushConsumer初始化"></a>DefaultMQPushConsumer初始化</h2><p>和Producer一样包装了一个DefaultMQPushConsumerImpl，下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.consumer.DefaultMQPushConsumer</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">DefaultMQPushConsumer</span><span class="params">(<span class="keyword">final</span> String consumerGroup)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(consumerGroup, <span class="keyword">null</span>, <span class="keyword">new</span> AllocateMessageQueueAveragely());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultMQPushConsumer</span><span class="params">(<span class="keyword">final</span> String consumerGroup, RPCHook rpcHook,</span></span></span><br><span class="line"><span class="function"><span class="params">      AllocateMessageQueueStrategy allocateMessageQueueStrategy)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.consumerGroup = consumerGroup;</span><br><span class="line">      <span class="comment">// 默认平均分配</span></span><br><span class="line">      <span class="keyword">this</span>.allocateMessageQueueStrategy = allocateMessageQueueStrategy;</span><br><span class="line">      <span class="comment">// 构造实际类</span></span><br><span class="line">      defaultMQPushConsumerImpl = <span class="keyword">new</span> DefaultMQPushConsumerImpl(<span class="keyword">this</span>, rpcHook);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultMQPushConsumerImpl</span><span class="params">(DefaultMQPushConsumer defaultMQPushConsumer, RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.defaultMQPushConsumer = defaultMQPushConsumer;</span><br><span class="line">      <span class="keyword">this</span>.rpcHook = rpcHook;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="DefaultMQPushConsumer启动"><a href="#DefaultMQPushConsumer启动" class="headerlink" title="DefaultMQPushConsumer启动"></a>DefaultMQPushConsumer启动</h2><p>实质就是defaultMQPushConsumerImpl启动，下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"> 	<span class="comment">// org.apache.rocketmq.client.consumer.DefaultMQPushConsumer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">      <span class="comment">// 实质defaultMQPushConsumerImpl启动</span></span><br><span class="line">      <span class="keyword">this</span>.defaultMQPushConsumerImpl.start();</span><br><span class="line">		<span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">          <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">              log.info(<span class="string">"the consumer [&#123;&#125;] start beginning. messageModel=&#123;&#125;, isUnitMode=&#123;&#125;"</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(),</span><br><span class="line">                  <span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel(), <span class="keyword">this</span>.defaultMQPushConsumer.isUnitMode());</span><br><span class="line">              <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">              <span class="comment">// 基本参数检查</span></span><br><span class="line">              <span class="keyword">this</span>.checkConfig();</span><br><span class="line">              <span class="comment">// 将DefaultMQPushConsumer的订阅信息copy到RebalanceService中</span></span><br><span class="line">              <span class="comment">// 如果是cluster模式，如果订阅了topic,则自动订阅%RETRY%groupname，也加入到RebalanceService中</span></span><br><span class="line">              <span class="keyword">this</span>.copySubscription();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line">                  <span class="comment">// 如果InstanceName参数值为DEFAULT则修改为PID</span></span><br><span class="line">                  <span class="keyword">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 新建一个MQClientInstance,客户端管理类, 单例，一个进程中只有一个</span></span><br><span class="line">              <span class="comment">// 所有的i/o类操作由它管理，缓存客户端和topic信息，各种service，很重要</span></span><br><span class="line">              <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQPushConsumer, <span class="keyword">this</span>.rpcHook);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">this</span>.rebalanceImpl.setConsumerGroup(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">              <span class="keyword">this</span>.rebalanceImpl.setMessageModel(<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel());</span><br><span class="line">              <span class="keyword">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="keyword">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">              <span class="keyword">this</span>.rebalanceImpl.setmQClientFactory(<span class="keyword">this</span>.mQClientFactory);</span><br><span class="line">              <span class="comment">// PullRequest封装实现类，封装了和broker的通信接口</span></span><br><span class="line">              <span class="keyword">this</span>.pullAPIWrapper = <span class="keyword">new</span> PullAPIWrapper(</span><br><span class="line">                  mQClientFactory,</span><br><span class="line">                  <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">              <span class="comment">// 消息被客户端过滤时会回调的钩子</span></span><br><span class="line">              <span class="keyword">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// consumer客户端消费offset持久化</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.offsetStore = <span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore();</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">                      <span class="comment">// 广播消息本地持久化offset</span></span><br><span class="line">                      <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">                          <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> LocalFileOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="comment">// 集群模式broker持久化offset</span></span><br><span class="line">                      <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">                          <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> RemoteBrokerOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">default</span>:</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">this</span>.defaultMQPushConsumer.setOffsetStore(<span class="keyword">this</span>.offsetStore);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 如果是广播模式则从本地文件中load，如果是集群模式不做操作</span></span><br><span class="line">              <span class="keyword">this</span>.offsetStore.load();</span><br><span class="line">              <span class="comment">// 消息消费服务，顺序和并发消息逻辑不同,接收消息并调用listener消费，处理消费结果</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerOrderly) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.consumeOrderly = <span class="keyword">true</span>;</span><br><span class="line">                  <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                      <span class="keyword">new</span> ConsumeMessageOrderlyService(<span class="keyword">this</span>, (MessageListenerOrderly) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerConcurrently) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.consumeOrderly = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                      <span class="keyword">new</span> ConsumeMessageConcurrentlyService(<span class="keyword">this</span>, (MessageListenerConcurrently) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 启动等待处理消息服务（定时服务）</span></span><br><span class="line">              <span class="keyword">this</span>.consumeMessageService.start();</span><br><span class="line">              <span class="comment">// 注册Consumer</span></span><br><span class="line">              <span class="keyword">boolean</span> registerOK = mQClientFactory.registerConsumer(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="keyword">this</span>);</span><br><span class="line">              <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                  <span class="keyword">this</span>.consumeMessageService.shutdown();</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The consumer group["</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()</span><br><span class="line">                      + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                      <span class="keyword">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// mqClient启动</span></span><br><span class="line">              mQClientFactory.start();</span><br><span class="line">              log.info(<span class="string">"the consumer [&#123;&#125;] start OK."</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">              <span class="comment">// 改变状态</span></span><br><span class="line">              <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> RUNNING:</span><br><span class="line">          <span class="keyword">case</span> START_FAILED:</span><br><span class="line">          <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The PushConsumer service state not OK, maybe started once, "</span></span><br><span class="line">                  + <span class="keyword">this</span>.serviceState</span><br><span class="line">                  + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                  <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新Topic信息</span></span><br><span class="line">      <span class="keyword">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line">      <span class="keyword">this</span>.mQClientFactory.checkClientInBroker();</span><br><span class="line">      <span class="comment">// 发送心跳</span></span><br><span class="line">      <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">      <span class="comment">// 做一次rebalance</span></span><br><span class="line">      <span class="keyword">this</span>.mQClientFactory.rebalanceImmediately();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个点说一下：</p>
<ul>
<li>%RETRY% +groupname：如果consumer是cluster模式，并且订阅了TopicA的消息，那客户端会自动订阅%RETRY% + +groupname。我们知道consumer消费消息处理失败的话，broker是会延时一定的时间重新推送的，重新推送不是跟其它新消息一起过来，而是通过单独的%RETRY%过来。</li>
<li>RebalanceService分配策略：Rebalance支持多种分配策略，比如平均分配、一致性Hash等，默认采用平均分配策略(AVG)。</li>
</ul>
<h2 id="MQClientInstance启动"><a href="#MQClientInstance启动" class="headerlink" title="MQClientInstance启动"></a>MQClientInstance启动</h2><p>在讲Producer的时候已经讲过<code>MQClientInstance</code>的启动过程，因为Producer和Consumer共用一个<code>MQClientInstance</code>，下面我们再来看一下Consumer相关逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.impl.factory.MQClientInstance</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">              <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">             			<span class="comment">// 省略不相关...</span></span><br><span class="line">                  <span class="comment">// 开启各种定时任务</span></span><br><span class="line">                  <span class="keyword">this</span>.startScheduledTask();</span><br><span class="line">                  <span class="comment">// 开启拉消息服务(Consumer)</span></span><br><span class="line">                  <span class="keyword">this</span>.pullMessageService.start();</span><br><span class="line">                  <span class="comment">// 开启负载均衡服务，一个线程定时触发rebalance(20秒一次)</span></span><br><span class="line">                  <span class="keyword">this</span>.rebalanceService.start();</span><br><span class="line">                  <span class="comment">// 初始化一个自用的producer，`CLIENT_INNER_PRODUCER`</span></span><br><span class="line">                  <span class="comment">// 主要用于在消费失败或者超时后发送重试的消息给broker</span></span><br><span class="line">                  <span class="keyword">this</span>.defaultMQProducer.getDefaultMQProducerImpl().start(<span class="keyword">false</span>);</span><br><span class="line">                  <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">								<span class="comment">// 省略不相关...</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startScheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 省略不相关...</span></span><br><span class="line">      <span class="comment">// 持久化消费者的Offset</span></span><br><span class="line">    	<span class="comment">// 保存消费进度，广播消息存在本地，集群消息上传到所有的broker</span></span><br><span class="line">      <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  MQClientInstance.<span class="keyword">this</span>.persistAllConsumerOffset();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  log.error(<span class="string">"ScheduledTask persistAllConsumerOffset exception"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据负载调整本地处理消息的线程池corePool大小</span></span><br><span class="line">      <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  MQClientInstance.<span class="keyword">this</span>.adjustThreadPool();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  log.error(<span class="string">"ScheduledTask adjustThreadPool exception"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>到这里Consumer的相关初始化工作就做完了，下面就会去消费消息了。</p>
<h1 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h1><p>这块逻辑有点复杂，为了大家不被细节绕晕，这里画了一下时序图，如下：<br><img src="https://upload-images.jianshu.io/upload_images/10354196-0b1bee5b4c2bb8b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RocketMq——Consumer消息消费时序图.jpg"></p>
<h2 id="RebalanceImpl触发Pull消息"><a href="#RebalanceImpl触发Pull消息" class="headerlink" title="RebalanceImpl触发Pull消息"></a>RebalanceImpl触发Pull消息</h2><p>还记得<code>defaultMQPushConsumerImpl</code>启动代码中最后一行执行了<code>this.mQClientFactory.rebalanceImmediately()</code>，忘记了，可以回头看看，这里会第一次触发Pull消息。我们看看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.impl.factory.MQClientInstance</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rebalanceImmediately</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   		<span class="comment">// 之前说过rebalanceService就是一个线程，继承于ServiceThread</span></span><br><span class="line">      <span class="keyword">this</span>.rebalanceService.wakeup();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.common.ServiceThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 这里主要是唤醒rebalanceService，用来了原子类和闭锁保证线程安全</span></span><br><span class="line">      <span class="keyword">if</span> (hasNotified.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">          waitPoint.countDown(); <span class="comment">// notify</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.rebalanceService</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        	<span class="comment">// 默认20s</span></span><br><span class="line">          <span class="keyword">this</span>.waitForRunning(waitInterval);</span><br><span class="line">          <span class="keyword">this</span>.mqClientFactory.doRebalance();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.factory.MQClientInstance</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 每一个Consumer都要做doRebalance操作</span></span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, MQConsumerInner&gt; entry : <span class="keyword">this</span>.consumerTable.entrySet()) &#123;</span><br><span class="line">          MQConsumerInner impl = entry.getValue();</span><br><span class="line">          <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  impl.doRebalance();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                  log.error(<span class="string">"doRebalance exception"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.pause) &#123;</span><br><span class="line">          <span class="keyword">this</span>.rebalanceImpl.doRebalance(<span class="keyword">this</span>.isConsumeOrderly());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.RebalanceImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebalanceByTopic</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (messageModel) &#123;</span><br><span class="line">          <span class="keyword">case</span> BROADCASTING: &#123;</span><br><span class="line">              Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">              <span class="keyword">if</span> (mqSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">boolean</span> changed = <span class="keyword">this</span>.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);</span><br><span class="line">                  <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                      <span class="keyword">this</span>.messageQueueChanged(topic, mqSet, mqSet);</span><br><span class="line">                      log.info(<span class="string">"messageQueueChanged &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;"</span>,</span><br><span class="line">                          consumerGroup,</span><br><span class="line">                          topic,</span><br><span class="line">                          mqSet,</span><br><span class="line">                          mqSet);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  log.warn(<span class="string">"doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist."</span>, consumerGroup, topic);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">case</span> CLUSTERING: &#123;</span><br><span class="line">              <span class="comment">// 从路由信息中获取topic对应所有的Queue</span></span><br><span class="line">              Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">              <span class="comment">// 从broker获取所有同一个group的所有Consumer ID(192.168.1.28@83721)</span></span><br><span class="line">              List&lt;String&gt; cidAll = <span class="keyword">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">null</span> == mqSet) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                      log.warn(<span class="string">"doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist."</span>, consumerGroup, topic);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">null</span> == cidAll) &#123;</span><br><span class="line">                  log.warn(<span class="string">"doRebalance, &#123;&#125; &#123;&#125;, get consumer id list failed"</span>, consumerGroup, topic);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (mqSet != <span class="keyword">null</span> &amp;&amp; cidAll != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line">                  mqAll.addAll(mqSet);</span><br><span class="line">                  <span class="comment">// 将mq和cid都排好序</span></span><br><span class="line">                  Collections.sort(mqAll);</span><br><span class="line">                  Collections.sort(cidAll);</span><br><span class="line">                  <span class="comment">// 按照初始化是指定的分配策略（默认平均），获取Consumer分配的MQ列表</span></span><br><span class="line">                  AllocateMessageQueueStrategy strategy = <span class="keyword">this</span>.allocateMessageQueueStrategy;</span><br><span class="line"></span><br><span class="line">                  List&lt;MessageQueue&gt; allocateResult = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      allocateResult = strategy.allocate(</span><br><span class="line">                          <span class="keyword">this</span>.consumerGroup,</span><br><span class="line">                          <span class="keyword">this</span>.mQClientFactory.getClientId(),</span><br><span class="line">                          mqAll,</span><br><span class="line">                          cidAll);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                      log.error(<span class="string">"AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;"</span>, strategy.getName(),</span><br><span class="line">                          e);</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  Set&lt;MessageQueue&gt; allocateResultSet = <span class="keyword">new</span> HashSet&lt;MessageQueue&gt;();</span><br><span class="line">                  <span class="keyword">if</span> (allocateResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      allocateResultSet.addAll(allocateResult);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 更新rebalanceImpl中的processQueue用来缓存收到的消息</span></span><br><span class="line">                  <span class="comment">// 对于新加入的Queue，提交一次PullRequest</span></span><br><span class="line">                  <span class="comment">// 对于新启动的consumer来说，所有的queue都是新添加的，所以所有queue都会触发PullRequest</span></span><br><span class="line">                  <span class="keyword">boolean</span> changed = <span class="keyword">this</span>.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);</span><br><span class="line">                  <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                      log.info(</span><br><span class="line">                          <span class="string">"rebalanced result changed. allocateMessageQueueStrategyName=&#123;&#125;, group=&#123;&#125;, topic=&#123;&#125;, clientId=&#123;&#125;, mqAllSize=&#123;&#125;, cidAllSize=&#123;&#125;, rebalanceResultSize=&#123;&#125;, rebalanceResultSet=&#123;&#125;"</span>,</span><br><span class="line">                          strategy.getName(), consumerGroup, topic, <span class="keyword">this</span>.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),</span><br><span class="line">                          allocateResultSet.size(), allocateResultSet);</span><br><span class="line">                      <span class="comment">// 发送一次心跳</span></span><br><span class="line">                      <span class="keyword">this</span>.messageQueueChanged(topic, mqSet, allocateResultSet);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个点重点看看：</p>
<h3 id="Queue分配策略"><a href="#Queue分配策略" class="headerlink" title="Queue分配策略"></a>Queue分配策略</h3><p>我们看这个方法<code>AllocateMessageQueueStrategy#allocate()</code>，他有下面几种实现：</p>
<ul>
<li><p>AllocateMessageQueueAveragely：这是默认的分配方式，一个consumer分到在平均的情况下分到连续的queue，待会我们会看看代码</p>
</li>
<li><p>AllocateMessageQueueAveragelyByCircle： 和上面类似，但是分到的queue不是连续的。比如一共12个Queue，3个consumer，则第一个consumer接收queue1，4，7，9的消息</p>
</li>
<li><p>AllocateMachineRoomNearby：将queue先按照broker划分几个computer room，不同的consumer只消费某几个broker上的消息</p>
</li>
<li><p>AllocateMessageQueueByMachineRoom：根据computer room进行hash分配队列</p>
</li>
<li><p>AllocateMessageQueueByConfig：在用户启动时指定消费哪些Queue的消息</p>
</li>
<li><p>AllocateMessageQueueConsistentHash：使用一致性hash算法来分配Queue，用户需自定义虚拟节点的数量</p>
</li>
</ul>
<p>然后下面我们看看默认的<code>AllocateMessageQueueAveragely</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MessageQueue&gt; <span class="title">allocate</span><span class="params">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;String&gt; cidAll)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="keyword">int</span> index = cidAll.indexOf(currentCID);</span><br><span class="line">    <span class="keyword">int</span> mod = mqAll.size() % cidAll.size();</span><br><span class="line">    <span class="comment">// 1. mq数量 &lt;= consumer数量，size = 1</span></span><br><span class="line">    <span class="comment">// 2. 否则，size = mq数量 / consumer数量，余数是几则前几个consumer的size+1,这样所有的queue都会有consumer消费</span></span><br><span class="line">    <span class="keyword">int</span> averageSize =</span><br><span class="line">        mqAll.size() &lt;= cidAll.size() ? <span class="number">1</span> : (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size()</span><br><span class="line">            + <span class="number">1</span> : mqAll.size() / cidAll.size());</span><br><span class="line">    <span class="keyword">int</span> startIndex = (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod;</span><br><span class="line">    <span class="keyword">int</span> range = Math.min(averageSize, mqAll.size() - startIndex);</span><br><span class="line">    <span class="comment">// 从第一个consumer开始分配，每个分avgSize个连续的Queue，</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">        result.add(mqAll.get((startIndex + i) % mqAll.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="提交Pull请求"><a href="#提交Pull请求" class="headerlink" title="提交Pull请求"></a>提交Pull请求</h3><p>上面我们说过对于新加入的Queue，提交一次PullRequest，那么我们就可以看看<code>org.apache.rocketmq.client.impl.consumer.RebalanceImpl#updateProcessQueueTableInRebalance</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateProcessQueueTableInRebalance</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> Set&lt;MessageQueue&gt; mqSet,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">// 省略</span></span><br><span class="line">      List&lt;PullRequest&gt; pullRequestList = <span class="keyword">new</span> ArrayList&lt;PullRequest&gt;();</span><br><span class="line">      <span class="keyword">for</span> (MessageQueue mq : mqSet) &#123;</span><br><span class="line">          <span class="comment">// 如果是新加入的Queue</span></span><br><span class="line">          <span class="keyword">if</span> (!<span class="keyword">this</span>.processQueueTable.containsKey(mq)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (isOrder &amp;&amp; !<span class="keyword">this</span>.lock(mq)) &#123;</span><br><span class="line">                  log.warn(<span class="string">"doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed"</span>, consumerGroup, mq);</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 从offset store中移除过时的数据</span></span><br><span class="line">              <span class="keyword">this</span>.removeDirtyOffset(mq);</span><br><span class="line">              ProcessQueue pq = <span class="keyword">new</span> ProcessQueue();</span><br><span class="line">              <span class="comment">// 获取起始消费offset</span></span><br><span class="line">              <span class="keyword">long</span> nextOffset = <span class="keyword">this</span>.computePullFromWhere(mq);</span><br><span class="line">              <span class="keyword">if</span> (nextOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 为新的Queue初始化一个ProcessQueue，用来缓存收到的消息</span></span><br><span class="line">                  ProcessQueue pre = <span class="keyword">this</span>.processQueueTable.putIfAbsent(mq, pq);</span><br><span class="line">                  <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      log.info(<span class="string">"doRebalance, &#123;&#125;, mq already exists, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      log.info(<span class="string">"doRebalance, &#123;&#125;, add a new mq, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                      <span class="comment">// 对新加的queue初始化一个PullRequest</span></span><br><span class="line">                      PullRequest pullRequest = <span class="keyword">new</span> PullRequest();</span><br><span class="line">                      pullRequest.setConsumerGroup(consumerGroup);</span><br><span class="line">                      pullRequest.setNextOffset(nextOffset);</span><br><span class="line">                      pullRequest.setMessageQueue(mq);</span><br><span class="line">                      pullRequest.setProcessQueue(pq);</span><br><span class="line">                      pullRequestList.add(pullRequest);</span><br><span class="line">                      changed = <span class="keyword">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  log.warn(<span class="string">"doRebalance, &#123;&#125;, add new mq failed, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 分发pull request到PullMessageService拉取消息</span></span><br><span class="line">      <span class="keyword">this</span>.dispatchPullRequest(pullRequestList);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> changed;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.RebalancePushImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchPullRequest</span><span class="params">(List&lt;PullRequest&gt; pullRequestList)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (PullRequest pullRequest : pullRequestList) &#123;</span><br><span class="line">        	<span class="comment">// 执行拉取消息</span></span><br><span class="line">          <span class="keyword">this</span>.defaultMQPushConsumerImpl.executePullRequestImmediately(pullRequest);</span><br><span class="line">          log.info(<span class="string">"doRebalance, &#123;&#125;, add a new pull request &#123;&#125;"</span>, consumerGroup, pullRequest);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executePullRequestImmediately</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.mQClientFactory.getPullMessageService().executePullRequestImmediately(pullRequest);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.PullMessageService</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executePullRequestImmediately</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">// 将pull request 放入到pullRequestQueue中</span></span><br><span class="line">          <span class="keyword">this</span>.pullRequestQueue.put(pullRequest);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          log.error(<span class="string">"executePullRequestImmediately pullRequestQueue.put"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息拉取服务"><a href="#消息拉取服务" class="headerlink" title="消息拉取服务"></a>消息拉取服务</h2><p>我们在MQClientInstance启动的时候，我们看到我们启动了一个消息拉取的定时服务。这里我们也就知道其实<code>PullMessageService</code>也是一个线程，我们先看run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.impl.consumer.PullMessageService</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="comment">// 取pull request 进行拉取</span></span><br><span class="line">              PullRequest pullRequest = <span class="keyword">this</span>.pullRequestQueue.take();</span><br><span class="line">              <span class="keyword">this</span>.pullMessage(pullRequest);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              log.error(<span class="string">"Pull Message Service Run Method exception"</span>, e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> MQConsumerInner consumer = <span class="keyword">this</span>.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());</span><br><span class="line">      <span class="keyword">if</span> (consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">          DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;</span><br><span class="line">        	<span class="comment">// 实质</span></span><br><span class="line">          impl.pullMessage(pullRequest);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.warn(<span class="string">"No matched consumer for the PullRequest &#123;&#125;, drop it"</span>, pullRequest);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 拿到缓存消息的队列</span></span><br><span class="line">      <span class="keyword">final</span> ProcessQueue processQueue = pullRequest.getProcessQueue();</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 设置拉取时间戳</span></span><br><span class="line">      pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 查看消息缓存队列的消息数量以及大小</span></span><br><span class="line">      <span class="keyword">long</span> cachedMessageCount = processQueue.getMsgCount().get();</span><br><span class="line">      <span class="keyword">long</span> cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">      <span class="comment">// 如果堆积未处理的消息数量过多(大于默认1000条)，则放回pull request队列,延时执行（默认50ms）</span></span><br><span class="line">      <span class="keyword">if</span> (cachedMessageCount &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果堆积未处理的消息的大小过大（大于100MB），同上面的逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (cachedMessageSizeInMiB &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 无序消息，消息offset跨度过大，同上面的逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.consumeOrderly) &#123;</span><br><span class="line">          <span class="keyword">if</span> (processQueue.getMaxSpan() &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) &#123;</span><br><span class="line">              <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">              <span class="comment">// ...</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检查订阅关系有没有变化，有可能在延时期间，topic或者consumer的配置都发生了变化，需要重新处理</span></span><br><span class="line">      <span class="keyword">final</span> SubscriptionData subscriptionData = <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionData) &#123;</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">          log.warn(<span class="string">"find the consumer's subscription failed, &#123;&#125;"</span>, pullRequest);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line">      <span class="comment">// Pull Command发送后的回调</span></span><br><span class="line">      PullCallback pullCallback = <span class="keyword">new</span> PullCallback() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(PullResult pullResult)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (pullResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 消息预处理，客户端再次过滤，设置minOffset和maxOffset</span></span><br><span class="line">                  pullResult = DefaultMQPushConsumerImpl.<span class="keyword">this</span>.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</span><br><span class="line">                      subscriptionData);</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                      <span class="keyword">case</span> FOUND:</span><br><span class="line">                          <span class="keyword">long</span> prevRequestOffset = pullRequest.getNextOffset();</span><br><span class="line">                          pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line">                          <span class="keyword">long</span> pullRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">                          DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),</span><br><span class="line">                              pullRequest.getMessageQueue().getTopic(), pullRT);</span><br><span class="line"></span><br><span class="line">                          <span class="keyword">long</span> firstMsgOffset = Long.MAX_VALUE;</span><br><span class="line">                          <span class="comment">// 如果获取到的消息数为0，则立即发起下一次pull</span></span><br><span class="line">                          <span class="keyword">if</span> (pullResult.getMsgFoundList() == <span class="keyword">null</span> || pullResult.getMsgFoundList().isEmpty()) &#123;</span><br><span class="line">                              DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                              firstMsgOffset = pullResult.getMsgFoundList().get(<span class="number">0</span>).getQueueOffset();</span><br><span class="line"></span><br><span class="line">                              DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),</span><br><span class="line">                                  pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());</span><br><span class="line">                              <span class="comment">// 消息放入ProcessQueue</span></span><br><span class="line">                              <span class="keyword">boolean</span> dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span><br><span class="line">                              <span class="comment">// 消费消息服务（线程池），调用messageListener处理，处理完成会通知ProcessQueue</span></span><br><span class="line">                              DefaultMQPushConsumerImpl.<span class="keyword">this</span>.consumeMessageService.submitConsumeRequest(</span><br><span class="line">                                  pullResult.getMsgFoundList(),</span><br><span class="line">                                  processQueue,</span><br><span class="line">                                  pullRequest.getMessageQueue(),</span><br><span class="line">                                  dispatchToConsume);</span><br><span class="line">                              <span class="comment">// 再次提交pull request</span></span><br><span class="line">                              <span class="keyword">if</span> (DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                  DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest,</span><br><span class="line">                                      DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval());</span><br><span class="line">                              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                  DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                          <span class="keyword">if</span> (pullResult.getNextBeginOffset() &lt; prevRequestOffset</span><br><span class="line">                              || firstMsgOffset &lt; prevRequestOffset) &#123;</span><br><span class="line">                              log.warn(</span><br><span class="line">                                  <span class="string">"[BUG] pull message result maybe data wrong, nextBeginOffset: &#123;&#125; firstMsgOffset: &#123;&#125; prevRequestOffset: &#123;&#125;"</span>,</span><br><span class="line">                                  pullResult.getNextBeginOffset(),</span><br><span class="line">                                  firstMsgOffset,</span><br><span class="line">                                  prevRequestOffset);</span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">case</span> NO_NEW_MSG:</span><br><span class="line">                          <span class="comment">// ...</span></span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">case</span> OFFSET_ILLEGAL:</span><br><span class="line">                          <span class="comment">// ...</span></span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">default</span>:</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 调用Netty去发送Pull Command，其实这后面就和生产者发送消息是一样的，不过这里是异步发送消息</span></span><br><span class="line">        	<span class="comment">// 异步完成之后会执行pullCallback</span></span><br><span class="line">          <span class="keyword">this</span>.pullAPIWrapper.pullKernelImpl(</span><br><span class="line">              pullRequest.getMessageQueue(),</span><br><span class="line">              subExpression,</span><br><span class="line">              subscriptionData.getExpressionType(),</span><br><span class="line">              subscriptionData.getSubVersion(),</span><br><span class="line">              pullRequest.getNextOffset(),</span><br><span class="line">              <span class="keyword">this</span>.defaultMQPushConsumer.getPullBatchSize(),</span><br><span class="line">              sysFlag,</span><br><span class="line">              commitOffsetValue,</span><br><span class="line">              BROKER_SUSPEND_MAX_TIME_MILLIS,</span><br><span class="line">              CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,</span><br><span class="line">              CommunicationMode.ASYNC,</span><br><span class="line">              pullCallback</span><br><span class="line">          );</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          log.error(<span class="string">"pullKernelImpl exception"</span>, e);</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息消费-1"><a href="#消息消费-1" class="headerlink" title="消息消费"></a>消息消费</h2><p>上面我们已经说过了当消息拉取完之后会执行PullCallback，具体一点就是会执行到<code>org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService.submitConsumeRequest()</code>，我们看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitConsumeRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ProcessQueue processQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> MessageQueue messageQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">boolean</span> dispatchToConsume)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> consumeBatchSize = <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line">      <span class="comment">// 看是否需要批量消费，默认阈值是1</span></span><br><span class="line">      <span class="keyword">if</span> (msgs.size() &lt;= consumeBatchSize) &#123;</span><br><span class="line">          <span class="comment">// 创建一个消费任务</span></span><br><span class="line">          ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgs, processQueue, messageQueue);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">              <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 创建批量消费任务</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> total = <span class="number">0</span>; total &lt; msgs.size(); ) &#123;</span><br><span class="line">              List&lt;MessageExt&gt; msgThis = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeBatchSize);</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumeBatchSize; i++, total++) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (total &lt; msgs.size()) &#123;</span><br><span class="line">                      msgThis.add(msgs.get(total));</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgThis, processQueue, messageQueue);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                  <span class="keyword">for</span> (; total &lt; msgs.size(); total++) &#123;</span><br><span class="line">                      msgThis.add(msgs.get(total));</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于ConsumeRequest是一个任务，所以我们可以看看它的run方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">          <span class="comment">// 得到改消息的Listener</span></span><br><span class="line">          MessageListenerConcurrently listener = ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.messageListener;</span><br><span class="line">          ConsumeConcurrentlyContext context = <span class="keyword">new</span> ConsumeConcurrentlyContext(messageQueue);</span><br><span class="line">          ConsumeConcurrentlyStatus status = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">          ConsumeMessageContext consumeMessageContext = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">              consumeMessageContext = <span class="keyword">new</span> ConsumeMessageContext();</span><br><span class="line">              consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">              consumeMessageContext.setProps(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">              consumeMessageContext.setMq(messageQueue);</span><br><span class="line">              consumeMessageContext.setMsgList(msgs);</span><br><span class="line">              consumeMessageContext.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">              ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line">          <span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">          ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.resetRetryTopic(msgs);</span><br><span class="line">              <span class="keyword">if</span> (msgs != <span class="keyword">null</span> &amp;&amp; !msgs.isEmpty()) &#123;</span><br><span class="line">                  <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                      MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// listener执行回调逻辑</span></span><br><span class="line">              status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">              log.warn(<span class="string">"consumeMessage exception: &#123;&#125; Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;"</span>,</span><br><span class="line">                  RemotingHelper.exceptionSimpleDesc(e),</span><br><span class="line">                  ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup,</span><br><span class="line">                  msgs,</span><br><span class="line">                  messageQueue);</span><br><span class="line">              hasException = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">long</span> consumeRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">        	<span class="comment">// 设置消费结果</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">null</span> == status) &#123;</span><br><span class="line">              <span class="keyword">if</span> (hasException) &#123;</span><br><span class="line">                  returnType = ConsumeReturnType.EXCEPTION;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  returnType = ConsumeReturnType.RETURNNULL;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (consumeRT &gt;= defaultMQPushConsumer.getConsumeTimeout() * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">              returnType = ConsumeReturnType.TIME_OUT;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConsumeConcurrentlyStatus.RECONSUME_LATER == status) &#123;</span><br><span class="line">              returnType = ConsumeReturnType.FAILED;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status) &#123;</span><br><span class="line">              returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">              consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());</span><br><span class="line">          &#125;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">          <span class="keyword">if</span> (!processQueue.isDropped()) &#123;</span><br><span class="line">              <span class="comment">// 处理消费结果</span></span><br><span class="line">              ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.processConsumeResult(status, context, <span class="keyword">this</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              log.warn(<span class="string">"processQueue is dropped without process consume result. messageQueue=&#123;&#125;, msgs=&#123;&#125;"</span>, messageQueue, msgs);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConsumeResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ConsumeConcurrentlyStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ConsumeConcurrentlyContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ConsumeRequest consumeRequest</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> ackIndex = context.getAckIndex();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (consumeRequest.getMsgs().isEmpty())</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 设置消费状态</span></span><br><span class="line">      <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">          <span class="comment">// 消费成功</span></span><br><span class="line">          <span class="keyword">case</span> CONSUME_SUCCESS:</span><br><span class="line">              <span class="keyword">if</span> (ackIndex &gt;= consumeRequest.getMsgs().size()) &#123;</span><br><span class="line">                  ackIndex = consumeRequest.getMsgs().size() - <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">int</span> ok = ackIndex + <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">int</span> failed = consumeRequest.getMsgs().size() - ok;</span><br><span class="line">              <span class="keyword">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok);</span><br><span class="line">              <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 重新消费</span></span><br><span class="line">          <span class="keyword">case</span> RECONSUME_LATER:</span><br><span class="line">              ackIndex = -<span class="number">1</span>;</span><br><span class="line">              <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(),</span><br><span class="line">                  consumeRequest.getMsgs().size());</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">          <span class="comment">// broadcast模式，处理失败，不做处理</span></span><br><span class="line">          <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                  MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                  log.warn(<span class="string">"BROADCASTING, the message consume failed, drop it, &#123;&#125;"</span>, msg.toString());</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">              List&lt;MessageExt&gt; msgBackFailed = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeRequest.getMsgs().size());</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                  MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                  <span class="comment">// Cluster模式，将消息发回broker，让broker重新发送</span></span><br><span class="line">                  <span class="comment">// 一共有两种方式让broker重发(有兴趣自己去看看): </span></span><br><span class="line">                  <span class="comment">// 1. 先尝试给broker发送send_msg_back的命令，</span></span><br><span class="line">                  <span class="comment">// 2. 如果失败了，则通过consumer预留的producer给%RETRY%groupname发送消息，等于是自己给自己发一条消息。</span></span><br><span class="line">                  <span class="keyword">boolean</span> result = <span class="keyword">this</span>.sendMessageBack(msg, context);</span><br><span class="line">                  <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                      msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line">                      msgBackFailed.add(msg);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (!msgBackFailed.isEmpty()) &#123;</span><br><span class="line">                  consumeRequest.getMsgs().removeAll(msgBackFailed);</span><br><span class="line">                  <span class="comment">// 发回broker失败，则再次尝试本地消费</span></span><br><span class="line">                  <span class="keyword">this</span>.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将消费前缓存的消息清除</span></span><br><span class="line">      <span class="keyword">long</span> offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</span><br><span class="line">      <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们也基本上吧消息消费的流程走完了， 现在可以再回头看看流程图，如果能对的上就OK啦！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/dd2202cc22ea" target="_blank" rel="noopener">RocketMQ源码解析(四)-Consumer</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：当消息达到Broker之后，就等着Consumer去consume了呀~
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>Seata源码解析——环境搭建</title>
    <link href="http://bestlixiang.site/2019/06/16/Seata%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Seata%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://bestlixiang.site/2019/06/16/Seata源码分析/Seata源码解析——环境搭建/</id>
    <published>2019-06-16T02:18:22.000Z</published>
    <updated>2019-06-16T02:22:00.631Z</updated>
    
    <content type="html"><![CDATA[<p>引：2019 年 1 月，阿里巴巴中间件团队发起了开源项目 <strong>Fescar（Fast &amp; EaSy Commit And Rollback）</strong>，和社区一起共建开源分布式事务解决方案。Fescar 的愿景是让分布式事务的使用像本地事务的使用一样，简单和高效，并逐步解决开发者们遇到的分布式事务方面的所有难题。为了打造更中立、更开放、生态更加丰富的分布式事务开源社区，经过社区核心成员的投票，大家决定对 <strong>Fescar </strong>进行品牌升级，并更名为 <strong>Seata</strong>，意为：<strong>Simple Extensible Autonomous Transaction Architecture</strong>，是一套一站式<strong>分布式事务</strong>解决方案。<a id="more"></a></p>
<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p>还是那句话：<br><strong>源码，是原理的具象化</strong><br><strong>原理，是代码的抽象化</strong></p>
<p>所以在开始看源码前一定要好好了解Seata的使用方式以及原理，喜欢Seata的<a href="https://github.com/seata/seata/wiki" target="_blank" rel="noopener">wiki</a>。</p>
<h1 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h1><ol>
<li>Git</li>
<li>Maven</li>
<li>JDK1.8</li>
<li>IntelliJ IDEA</li>
<li>Mysql</li>
</ol>
<h1 id="源码拉取"><a href="#源码拉取" class="headerlink" title="源码拉取"></a>源码拉取</h1><p>好像是在fescar升级到seata的时候，项目将samples抽出成一个独立的项目了，所以我们需要拉两个工程的代码：</p>
<ol>
<li><a href="https://github.com/seata/seata" target="_blank" rel="noopener">seata</a></li>
<li><a href="https://github.com/seata/seata-samples" target="_blank" rel="noopener">seata-samples</a></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/seata/seata.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/seata/seata-samples.git</span><br></pre></td></tr></table></figure>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="启动Seata-Server"><a href="#启动Seata-Server" class="headerlink" title="启动Seata Server"></a>启动Seata Server</h2><p>在seata工程中找到<code>io.seata.server.Server</code>，直接点击运行main方法即可，我们可以看到如下输出日志：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-06-16 09:11:11.542 INFO [main]io.seata.core.rpc.netty.AbstractRpcRemotingServer.start:176 -Server started ...</span><br></pre></td></tr></table></figure>
<h2 id="启动Seata-samples"><a href="#启动Seata-samples" class="headerlink" title="启动Seata-samples"></a>启动Seata-samples</h2><p>seata-samples项目中提供了各种Demo，我们这里选择最简单的一种好了——dubbo。</p>
<h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><p>使用mysql</p>
<ol>
<li>创建数据库：fescar_demo</li>
<li>执行seata-samples/dubbo/src/main/resources/sql/dubbo_biz.sql</li>
<li>执行seata-samples/dubbo/src/main/resources/sql/undo_log.sql</li>
</ol>
<h3 id="启动基础服务"><a href="#启动基础服务" class="headerlink" title="启动基础服务"></a>启动基础服务</h3><ol>
<li><p>DubboAccountServiceStarter</p>
<p>找到<code>io.seata.samples.dubbo.starter.DubboAccountServiceStarter</code>，直接点击运行main方法，在当前线程下，我们没有看到日志，但是在Server端，我们可以看到下面的日志，就代码Rm已经注册成功啦，同时在数据库<code>account_tbl</code>表中插入了一条记录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-06-16 09:32:45.562 INFO [ServerHandlerThread_1_500]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegRmMessage:112 -rm register success,message:RegisterRMRequest&#123;resourceIds=<span class="string">'jdbc:mysql://127.0.0.1:3306/seata'</span>, applicationId=<span class="string">'dubbo-demo-account-service'</span>, transactionServiceGroup=<span class="string">'my_test_tx_group'</span>&#125;,channel:[id: 0xcbff48be, L:/127.0.0.1:8091 - R:/127.0.0.1:54122]</span><br><span class="line">2019-06-16 09:32:48.139 INFO [NettyServerNIOWorker_2_8]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegTmMessage:128 -checkAuth <span class="keyword">for</span> client:127.0.0.1:54123 vgroup:my_test_tx_group ok</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-10458e4af725f5fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="acount.png"></p>
<ol>
<li><p>DubboStorageServiceStarter</p>
<p>找到<code>io.seata.samples.dubbo.starter.DubboStorageServiceStarter</code>，直接点击运行main方法，在当前线程下，我们没有看到日志，但是在Server端，我们可以看到下面的日志，就代码Rm已经注册成功啦，同时在数据库<code>storage_tbl</code>表中插入了一条记录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-06-16 09:41:06.227 INFO [ServerHandlerThread_2_500]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegRmMessage:112 -rm register success,message:RegisterRMRequest&#123;resourceIds=<span class="string">'jdbc:mysql://127.0.0.1:3306/seata'</span>, applicationId=<span class="string">'dubbo-demo-storage-service'</span>, transactionServiceGroup=<span class="string">'my_test_tx_group'</span>&#125;,channel:[id: 0xf37dc389, L:/127.0.0.1:8091 - R:/127.0.0.1:54214]</span><br><span class="line">2019-06-16 09:41:08.969 INFO [NettyServerNIOWorker_4_8]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegTmMessage:128 -checkAuth <span class="keyword">for</span> client:127.0.0.1:54215 vgroup:my_test_tx_group ok</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-a48b6dba285bba5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="storage.png"></p>
<ol>
<li><p>DubboOrderServiceStarter</p>
<p>找到<code>io.seata.samples.dubbo.DubboOrderServiceStarter</code>，直接点击运行main方法，在当前线程下，我们没有看到日志，但是在Server端，我们可以看到下面的日志，就代码Rm已经注册成功啦：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-06-16 09:44:18.384 INFO [ServerHandlerThread_3_500]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegRmMessage:112 -rm register success,message:RegisterRMRequest&#123;resourceIds=<span class="string">'jdbc:mysql://127.0.0.1.200:3306/seata'</span>, applicationId=<span class="string">'dubbo-demo-order-service'</span>, transactionServiceGroup=<span class="string">'my_test_tx_group'</span>&#125;,channel:[id: 0xe370a8ab, L:/127.0.0.1:8091 - R:/127.0.0.1:54259]</span><br><span class="line">2019-06-16 09:44:21.333 INFO [NettyServerNIOWorker_6_8]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegTmMessage:128 -checkAuth <span class="keyword">for</span> client:127.0.0.1:54261 vgroup:my_test_tx_group ok</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="测试分布式事务"><a href="#测试分布式事务" class="headerlink" title="测试分布式事务"></a>测试分布式事务</h3><p>找到<code>io.seata.samples.dubbo.DubboBusinessTester</code> 这里执行的是一个购买的方法，会先调用库存服务扣减库存，然后调用订单服务生产订单，在生成订单之前，他还会调用扣减账户余额的服务，这样会形成一个微服务链路。</p>
<h4 id="正常提交"><a href="#正常提交" class="headerlink" title="正常提交"></a>正常提交</h4><p>我们先把<code>io.seata.samples.dubbo.service.impl#purchase</code>方法中的异常给注释掉：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purchase</span><span class="params">(String userId, String commodityCode, <span class="keyword">int</span> orderCount)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"purchase begin ... xid: "</span> + RootContext.getXID());</span><br><span class="line">    storageService.deduct(commodityCode, orderCount);</span><br><span class="line">    orderService.create(userId, commodityCode, orderCount);</span><br><span class="line">    <span class="comment">// throw new RuntimeException("xxx");</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后点击运行<code>io.seata.samples.dubbo.DubboBusinessTester#main</code>方法，我们看到方法正常结束，并且表中数据发送了如下变化：<br><img src="https://upload-images.jianshu.io/upload_images/10354196-cb3b6179b4da2d8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="normal-acount.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-42255f8875371e19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="normal-storage.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-e8586aefc68ed8e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="normal-order.png"></p>
<h4 id="异常回滚"><a href="#异常回滚" class="headerlink" title="异常回滚"></a>异常回滚</h4><p>我们先把<code>io.seata.samples.dubbo.service.impl#purchase</code>方法中的异常的注释给放开, 为了更好的看到回滚的过程，我们在抛出异常的那一行代码前面加上<strong>断点</strong>，然后debug运行<code>io.seata.samples.dubbo.DubboBusinessTester#main</code>方法，执行到断点，我们看看数据库的变化：<br><img src="https://upload-images.jianshu.io/upload_images/10354196-53d207bcb1f6e4f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="exception-account.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-3ecd332b64ce4500.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="exception-storage.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-d2b1f11253b620e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="exception-order.png"></p>
<p>我们看到数据其实都已经有了一些变化，然后看看很重要的  <code>undo_log</code>表，发现它也生成了一些记录，不过这里先不管：<br><img src="https://upload-images.jianshu.io/upload_images/10354196-521fd48999566ecc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="undo_log.png"></p>
<p>我们放开断点之后看到方法执行抛出了异常，同时表中数据变成了上面正常提交的数据，同时<code>undo_log</code>表也被清空了，从这里可以看出seata确实是帮我们实现了<strong>分布式事务</strong>。</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>好了，环境到这里就搭建结束了，关于seata代码上是如何实现分布式事务的，我们慢慢来分析~</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/seata/seata/wiki" target="_blank" rel="noopener">Seata Wiki</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：2019 年 1 月，阿里巴巴中间件团队发起了开源项目 &lt;strong&gt;Fescar（Fast &amp;amp; EaSy Commit And Rollback）&lt;/strong&gt;，和社区一起共建开源分布式事务解决方案。Fescar 的愿景是让分布式事务的使用像本地事务的使用一样，简单和高效，并逐步解决开发者们遇到的分布式事务方面的所有难题。为了打造更中立、更开放、生态更加丰富的分布式事务开源社区，经过社区核心成员的投票，大家决定对 &lt;strong&gt;Fescar &lt;/strong&gt;进行品牌升级，并更名为 &lt;strong&gt;Seata&lt;/strong&gt;，意为：&lt;strong&gt;Simple Extensible Autonomous Transaction Architecture&lt;/strong&gt;，是一套一站式&lt;strong&gt;分布式事务&lt;/strong&gt;解决方案。
    
    </summary>
    
      <category term="Seata源码" scheme="http://bestlixiang.site/categories/Seata%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Seata" scheme="http://bestlixiang.site/tags/Seata/"/>
    
      <category term="分布式事务" scheme="http://bestlixiang.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——Producer</title>
    <link href="http://bestlixiang.site/2019/06/15/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Producer/"/>
    <id>http://bestlixiang.site/2019/06/15/RocketMQ源码/RocketMQ源码分析——Producer/</id>
    <published>2019-06-15T06:46:21.000Z</published>
    <updated>2019-06-15T06:50:11.364Z</updated>
    
    <content type="html"><![CDATA[<p>引：使用MQ，第一步构造Producer，然后就可以开始发送消息啦！<a id="more"></a></p>
<h1 id="发送方式"><a href="#发送方式" class="headerlink" title="发送方式"></a>发送方式</h1><p>producer发送消息支持3种方式，同步、异步和Oneway。</p>
<ul>
<li>同步发送：客户端提交消息到broker后会等待返回结果。有可靠性保障。</li>
<li>异步发送：调用发送接口时会注册一个callback类，发送线程继续其它业务逻辑，producer在收到broker结果后回调。当消息结果不影响正常业务逻辑的时候使用。</li>
<li>Oneway：Producer提交消息后，无论broker是否正常接收消息都不关心。适合于追求高吞吐、能容忍消息丢失的场景，比如日志收集。</li>
</ul>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>我们主要讲同步发送，异步发送和Oneway方式和事务消息带过，同步发送例子就是环境搭建中Producer的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化一个Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指明Namesrv</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                    <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                    (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">                );</span><br><span class="line">                SendResult sendResult = producer.send(msg);</span><br><span class="line">                System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面我们实例化一个DefaultMQProducer，设置group name和nameserv的地址。Producer启动后就可以往指定的topic发送消息啦！</p>
<h1 id="Producer启动"><a href="#Producer启动" class="headerlink" title="Producer启动"></a>Producer启动</h1><h2 id="DefaultMQProducer初始化"><a href="#DefaultMQProducer初始化" class="headerlink" title="DefaultMQProducer初始化"></a>DefaultMQProducer初始化</h2><p>下面代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.client.producer.DefaultMQProducer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(producerGroup, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup, RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.producerGroup = producerGroup;</span><br><span class="line">        <span class="comment">// DefaultMQProducer包装了DefaultMQProducerImpl</span></span><br><span class="line">        defaultMQProducerImpl = <span class="keyword">new</span> DefaultMQProducerImpl(<span class="keyword">this</span>, rpcHook);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducerImpl</span><span class="params">(<span class="keyword">final</span> DefaultMQProducer defaultMQProducer, RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMQProducer = defaultMQProducer;</span><br><span class="line">        <span class="keyword">this</span>.rpcHook = rpcHook;</span><br><span class="line">        <span class="comment">// 构造了一个同步发送线程池</span></span><br><span class="line">        <span class="keyword">this</span>.asyncSenderThreadPoolQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">50000</span>);</span><br><span class="line">        <span class="keyword">this</span>.defaultAsyncSenderExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            Runtime.getRuntime().availableProcessors(),</span><br><span class="line">            Runtime.getRuntime().availableProcessors(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.asyncSenderThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                <span class="keyword">private</span> AtomicInteger threadIndex = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncSenderExecutor_"</span> + <span class="keyword">this</span>.threadIndex.incrementAndGet());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="DefaultMQProducer启动"><a href="#DefaultMQProducer启动" class="headerlink" title="DefaultMQProducer启动"></a>DefaultMQProducer启动</h2><p>下面代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.client.producer.DefaultMQProducer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="comment">// 调用实际的实现类</span></span><br><span class="line">    <span class="keyword">this</span>.defaultMQProducerImpl.start();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != traceDispatcher) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            traceDispatcher.start(<span class="keyword">this</span>.getNamesrvAddr());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            log.warn(<span class="string">"trace dispatcher start failed "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.start(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> startFactory)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            <span class="comment">// 如果下面的过程中出错了，那么serviceState就为START_FAILED</span></span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">            <span class="comment">// 检查group name是否合适</span></span><br><span class="line">            <span class="keyword">this</span>.checkConfig();</span><br><span class="line">            <span class="comment">// 更改defaultMQProducer的名称为进程id</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// MQClientManager为单例，创建mQClientFactory</span></span><br><span class="line">            <span class="comment">// 一个进程只会存在一个MQClientInstance， 设置clientId （IP@PID）</span></span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQProducer, rpcHook);</span><br><span class="line">            <span class="comment">// 向mQClientFactory注册defaultMQProducer</span></span><br><span class="line">            <span class="keyword">boolean</span> registerOK = mQClientFactory.registerProducer(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup(), <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer group["</span> + <span class="keyword">this</span>.defaultMQProducer.getProducerGroup()</span><br><span class="line">                    + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加默认的topicPublishInfo</span></span><br><span class="line">            <span class="keyword">this</span>.topicPublishInfoTable.put(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey(), <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (startFactory) &#123;</span><br><span class="line">                <span class="comment">// 核心</span></span><br><span class="line">                <span class="comment">// 启动MQClientInstance</span></span><br><span class="line">                mQClientFactory.start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">"the producer [&#123;&#125;] start OK. sendMessageWithVIPChannel=&#123;&#125;"</span>, <span class="keyword">this</span>.defaultMQProducer.getProducerGroup(),</span><br><span class="line">                <span class="keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel());</span><br><span class="line">            <span class="comment">// 启动完成</span></span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">        <span class="keyword">case</span> START_FAILED:</span><br><span class="line">        <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer service state not OK, maybe started once, "</span></span><br><span class="line">                + <span class="keyword">this</span>.serviceState</span><br><span class="line">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向所有broker发送一次心跳</span></span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到DefaultMQProducer 的start的过程主要就是初始化和启动一个MQClientInstance，将producer注册到instance中。我们来看下MQClientInstance的启动过程。</p>
<h2 id="MQClientInstance启动"><a href="#MQClientInstance启动" class="headerlink" title="MQClientInstance启动"></a>MQClientInstance启动</h2><p>下面是启动代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">                <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">                    <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">                    <span class="comment">// If not specified,looking address from name server</span></span><br><span class="line">                    <span class="comment">// 如果NameservAddr为空，尝试从http server获取nameserv的地址</span></span><br><span class="line">                    <span class="comment">// 这里看出适合于有统一配置中心的系统</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Start request-response channel</span></span><br><span class="line">                    <span class="comment">// 初始化Netty客户端</span></span><br><span class="line">                    <span class="keyword">this</span>.mQClientAPIImpl.start();</span><br><span class="line">                    <span class="comment">// Start various schedule tasks</span></span><br><span class="line">                    <span class="comment">// 开启各种定时任务</span></span><br><span class="line">                    <span class="keyword">this</span>.startScheduledTask();</span><br><span class="line">                    <span class="comment">// Start pull service</span></span><br><span class="line">                    <span class="comment">// producer和consumer公用一个MQClientInstance的实现</span></span><br><span class="line">                    <span class="comment">// 开启拉消息服务(Consumer)</span></span><br><span class="line">                    <span class="keyword">this</span>.pullMessageService.start();</span><br><span class="line">                    <span class="comment">// Start rebalance service</span></span><br><span class="line">                    <span class="comment">// 开启负载均衡服务</span></span><br><span class="line">                    <span class="keyword">this</span>.rebalanceService.start();</span><br><span class="line">                    <span class="comment">// Start push service</span></span><br><span class="line">                    <span class="comment">// 开启Producer</span></span><br><span class="line">                    <span class="keyword">this</span>.defaultMQProducer.getDefaultMQProducerImpl().start(<span class="keyword">false</span>);</span><br><span class="line">                    log.info(<span class="string">"the client factory [&#123;&#125;] start OK"</span>, <span class="keyword">this</span>.clientId);</span><br><span class="line">                    <span class="comment">// 更改client状态</span></span><br><span class="line">                    <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RUNNING:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> START_FAILED:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The Factory object["</span> + <span class="keyword">this</span>.getClientId() + <span class="string">"] has been created before, and failed."</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看看它起了哪些定时任务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startScheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">        <span class="comment">// 获取nameserv地址</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    MQClientInstance.<span class="keyword">this</span>.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"ScheduledTask fetchNameServerAddr exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从nameserv更新topicRouteInfo</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MQClientInstance.<span class="keyword">this</span>.updateTopicRouteInfoFromNameServer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"ScheduledTask updateTopicRouteInfoFromNameServer exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPollNameServerInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除已经下线的broker，并发送心跳</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MQClientInstance.<span class="keyword">this</span>.cleanOfflineBroker();</span><br><span class="line">                MQClientInstance.<span class="keyword">this</span>.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"ScheduledTask sendHeartbeatToAllBroker exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>, <span class="keyword">this</span>.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持久化消费者的Offset(Consumer)</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MQClientInstance.<span class="keyword">this</span>.persistAllConsumerOffset();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"ScheduledTask persistAllConsumerOffset exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态调整消费者的线程池（Consumer）</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MQClientInstance.<span class="keyword">this</span>.adjustThreadPool();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"ScheduledTask adjustThreadPool exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，我们的Producer就启动完成了，接下来我们就可以看看它是怎么发送消息啦！</p>
<h1 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h1><p>Producer默认采用同步方式发送消息，如我们的示例，接下来我们看看这个方法<code>DefaultMQProducer.send( Message msg)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.client.producer.DefaultMQProducer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Message msg)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.defaultMQProducerImpl.send(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.producer.defaultMQProducerImpl</span></span><br><span class="line"><span class="comment">// 超时时间3秒</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Message msg)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> send(msg, <span class="keyword">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到默认采用同步方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sendDefaultImpl(msg, CommunicationMode.SYNC, <span class="keyword">null</span>, timeout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际发送逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendDefaultImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> CommunicationMode communicationMode,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> SendCallback sendCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">long</span> timeout</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 检查client状态是否是runing</span></span><br><span class="line">    <span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line">    <span class="comment">// 参数校验，消息不能发给系统预留的topic，消息体不能超过最大长度4M，或者是空消息</span></span><br><span class="line">    Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> invokeID = random.nextLong();</span><br><span class="line">    <span class="keyword">long</span> beginTimestampFirst = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> beginTimestampPrev = beginTimestampFirst;</span><br><span class="line">    <span class="keyword">long</span> endTimestamp = beginTimestampFirst;</span><br><span class="line">    <span class="comment">// 根据消息的topic，获取该topic的路由信息</span></span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> callTimeout = <span class="keyword">false</span>;</span><br><span class="line">        MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line">        Exception exception = <span class="keyword">null</span>;</span><br><span class="line">        SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 重试次数，同步模式下默认为3次</span></span><br><span class="line">        <span class="keyword">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">        String[] brokersSent = <span class="keyword">new</span> String[timesTotal];</span><br><span class="line">        <span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</span><br><span class="line">            <span class="comment">// 记录上次的发送的broker</span></span><br><span class="line">            String lastBrokerName = <span class="keyword">null</span> == mq ? <span class="keyword">null</span> : mq.getBrokerName();</span><br><span class="line">            <span class="comment">// 从所有topic可用queue中选择一个queue，有不同的策略</span></span><br><span class="line">            MessageQueue mqSelected = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line">            <span class="keyword">if</span> (mqSelected != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mq = mqSelected;</span><br><span class="line">                <span class="comment">// 记录下当前的broker</span></span><br><span class="line">                brokersSent[times] = mq.getBrokerName();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">long</span> costTime = beginTimestampPrev - beginTimestampFirst;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTime) &#123;</span><br><span class="line">                        callTimeout = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 发送消息</span></span><br><span class="line">                    sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);</span><br><span class="line">                    endTimestamp = System.currentTimeMillis();</span><br><span class="line">                    <span class="comment">// 更新本次调用时间到MQFaultStrategy中</span></span><br><span class="line">                    <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">                        <span class="comment">// 异步和ONEWAY方式调用后就直接返回了</span></span><br><span class="line">                        <span class="keyword">case</span> ASYNC:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">case</span> SYNC:</span><br><span class="line">                            <span class="comment">// 发送没成功</span></span><br><span class="line">                            <span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">                                <span class="comment">// 如果broker存储失败，判断是否要重试</span></span><br><span class="line">                                <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">return</span> sendResult;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                    <span class="comment">// 省略异常</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 成功则返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (sendResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sendResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略不重要逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面完整的发送逻辑信息量还是比较大的，我们具体看看几个重要的部分。</p>
<h2 id="获取topic路由信息"><a href="#获取topic路由信息" class="headerlink" title="获取topic路由信息"></a>获取topic路由信息</h2><p>关注<code>DefaultMQProducerImpl#tryToFindTopicPublishInfo()</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TopicPublishInfo <span class="title">tryToFindTopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从本地缓存获取，之前看到过有定时任务会定时更新这个缓存</span></span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="comment">// 如果不存在，则从Namesrv加锁更新TopicRouteInfo ，使用Netty</span></span><br><span class="line">        <span class="keyword">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="comment">// 若获取的 Topic发布信息时候可用，则返回</span></span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当从Namesrv获取不到时，如果允许broker自动创建topic信息则自动创建并更新</span></span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, <span class="keyword">true</span>, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Queue选取策略"><a href="#Queue选取策略" class="headerlink" title="Queue选取策略"></a>Queue选取策略</h2><p>Queue的选取是采用轮询的方式，如果客户端开启延迟容错，那么在轮询的时候会加入broker可用性的判断。<br>关注<code>DefaultMQProducerImpl#selectOneMessageQueue()</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MQFaultStrategy mqFaultStrategy = <span class="keyword">new</span> MQFaultStrategy();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mqFaultStrategy.selectOneMessageQueue(tpInfo, lastBrokerName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.latency.MQFaultStrategy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果开启了延时容错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 首先获取上次使用的Queue index+1，这个index是放在ThreadLocal下</span></span><br><span class="line">            <span class="comment">// 实现了轮询的效果，但是在重试的时候是为了选择上一次发送的broker</span></span><br><span class="line">            <span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                    pos = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 找到index对应的queue</span></span><br><span class="line">                MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</span><br><span class="line">                <span class="comment">// 如果queue对应的broker可用（根据faultItemTable判断），则使用该broker</span></span><br><span class="line">                <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line">                    <span class="comment">// 第一次发送或者是重试，直接选</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line">                        <span class="keyword">return</span> mq;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找个合适的broker，则从所有的broker中选择一个相对合适的，并且是可写的broker</span></span><br><span class="line">            <span class="comment">// 相对合适是指 可用/延迟低/上次不可用时间早</span></span><br><span class="line">            <span class="keyword">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</span><br><span class="line">            <span class="keyword">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</span><br><span class="line">            <span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</span><br><span class="line">                <span class="keyword">if</span> (notBestBroker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mq.setBrokerName(notBestBroker);</span><br><span class="line">                    mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                latencyFaultTolerance.remove(notBestBroker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error occurred when selecting message queue"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tpInfo.selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未开启延时容错，直接按顺序选下一个</span></span><br><span class="line">    <span class="keyword">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于queue选择有很多细节可以说，看以后是不是单独拎出来说一下，这里给个延迟的结论：当发送时长低于100ms时，设置broker不可用时长为0，之后依次增加，如果超过15秒，则有10分钟不可用。可以看到如果上次发送失败的话，也是10分钟不可用，如果重试肯定不会选择相同的broker，即不会选择不可用的broker。</p>
<h2 id="消息发送-1"><a href="#消息发送-1" class="headerlink" title="消息发送"></a>消息发送</h2><p>关注DefaultMQProducerImpl#sendKernelImpl()方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendKernelImpl</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> MessageQueue mq,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> CommunicationMode communicationMode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> SendCallback sendCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> TopicPublishInfo topicPublishInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> beginStartTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 根据brokerName从缓存中获取broker的地址</span></span><br><span class="line">    String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">    <span class="comment">// 如果地址为空，则从namesrv中再获取一次</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddr) &#123;</span><br><span class="line">        tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line">        <span class="comment">// 重新获取</span></span><br><span class="line">        brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SendMessageContext context = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (brokerAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 切换到VIP channel</span></span><br><span class="line">        <span class="comment">// Broker启动时会开启2个端口接收客户端数据，其中一个端口只接收producer的消息，不接受consumer的拉取请求，被称为VIP channel</span></span><br><span class="line">        brokerAddr = MixAll.brokerVIPChannel(<span class="keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] prevBody = msg.getBody();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//for MessageBatch,ID has been set in the generating process</span></span><br><span class="line">            <span class="comment">// 如果不是批量发送则客户端设置的id</span></span><br><span class="line">            <span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line">                MessageClientIDSetter.setUniqID(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sysFlag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> msgBodyCompressed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果消息body过长，则压缩并设置标记位</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tryToCompressMessage(msg)) &#123;</span><br><span class="line">                sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line">                msgBodyCompressed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 事务消息标记</span></span><br><span class="line">            <span class="keyword">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">            <span class="keyword">if</span> (tranMsg != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line">                sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 省略不重要逻辑</span></span><br><span class="line">            <span class="comment">// 设置消息头</span></span><br><span class="line">            SendMessageRequestHeader requestHeader = <span class="keyword">new</span> SendMessageRequestHeader();</span><br><span class="line">            requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">            requestHeader.setTopic(msg.getTopic());</span><br><span class="line">            requestHeader.setDefaultTopic(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey());</span><br><span class="line">            requestHeader.setDefaultTopicQueueNums(<span class="keyword">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</span><br><span class="line">            requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">            requestHeader.setSysFlag(sysFlag);</span><br><span class="line">            requestHeader.setBornTimestamp(System.currentTimeMillis());</span><br><span class="line">            requestHeader.setFlag(msg.getFlag());</span><br><span class="line">            requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line">            requestHeader.setReconsumeTimes(<span class="number">0</span>);</span><br><span class="line">            requestHeader.setUnitMode(<span class="keyword">this</span>.isUnitMode());</span><br><span class="line">            requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);</span><br><span class="line">            <span class="comment">// 要求重新发送的消息，设置重试次数和延时时间</span></span><br><span class="line">            <span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</span><br><span class="line">                <span class="keyword">if</span> (reconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line">                <span class="keyword">if</span> (maxReconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 通过NettyClient发送消息到Broker</span></span><br><span class="line">            <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">                <span class="keyword">case</span> ASYNC:</span><br><span class="line">                    Message tmpMessage = msg;</span><br><span class="line">                    <span class="keyword">if</span> (msgBodyCompressed) &#123;</span><br><span class="line">                        <span class="comment">//If msg body was compressed, msgbody should be reset using prevBody.</span></span><br><span class="line">                        <span class="comment">//Clone new message using commpressed message body and recover origin massage.</span></span><br><span class="line">                        <span class="comment">//Fix bug:https://github.com/apache/rocketmq-externals/issues/66</span></span><br><span class="line">                        tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">                        msg.setBody(prevBody);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">long</span> costTimeAsync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTimeAsync) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendKernelImpl call timeout"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 实际发送消息的位置</span></span><br><span class="line">                    sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">                        brokerAddr,</span><br><span class="line">                        mq.getBrokerName(),</span><br><span class="line">                        tmpMessage,</span><br><span class="line">                        requestHeader,</span><br><span class="line">                        timeout - costTimeAsync,</span><br><span class="line">                        communicationMode,</span><br><span class="line">                        sendCallback,</span><br><span class="line">                        topicPublishInfo,</span><br><span class="line">                        <span class="keyword">this</span>.mQClientFactory,</span><br><span class="line">                        <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),</span><br><span class="line">                        context,</span><br><span class="line">                        <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                <span class="keyword">case</span> SYNC:</span><br><span class="line">                    <span class="keyword">long</span> costTimeSync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTimeSync) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendKernelImpl call timeout"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">                        brokerAddr,</span><br><span class="line">                        mq.getBrokerName(),</span><br><span class="line">                        msg,</span><br><span class="line">                        requestHeader,</span><br><span class="line">                        timeout - costTimeSync,</span><br><span class="line">                        communicationMode,</span><br><span class="line">                        context,</span><br><span class="line">                        <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">                context.setSendResult(sendResult);</span><br><span class="line">                <span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> sendResult;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">           <span class="comment">// ... 省略异常处理</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            msg.setBody(prevBody);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The broker["</span> + mq.getBrokerName() + <span class="string">"] not exist"</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里就结束了！除了队列选择逻辑有点复杂，其他还好，但是还是要好好去体会~</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/02dbc0710f80" target="_blank" rel="noopener">RocketMQ源码解析(三)-Producer</a></li>
<li><a href="[http://b.shiwuliang.com/RocketMQ%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E4%B9%8B%E9%80%89%E6%8B%A9%E9%98%9F%E5%88%97%E5%B9%B6%E5%8F%91%E9%80%81.html](http://b.shiwuliang.com/RocketMQ%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E4%B9%8B%E9%80%89%E6%8B%A9%E9%98%9F%E5%88%97%E5%B9%B6%E5%8F%91%E9%80%81.html">RocketMQ源码解读——消息发送之选择队列并发送</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：使用MQ，第一步构造Producer，然后就可以开始发送消息啦！
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——Namesrv</title>
    <link href="http://bestlixiang.site/2019/06/09/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Namesrv/"/>
    <id>http://bestlixiang.site/2019/06/09/RocketMQ源码/RocketMQ源码分析——Namesrv/</id>
    <published>2019-06-09T10:17:12.000Z</published>
    <updated>2019-06-09T10:19:31.294Z</updated>
    
    <content type="html"><![CDATA[<p>引：NameSrv是RocketMQ的注册中心，保存所有Broker、Topic的元数据。Broker启动后会向namesrv发送心跳，namesrv也会定时检测broker的可用性，并移除不可用的broker。对于生产者和消费者来说，它提供了Broker的查询服务。<a id="more"></a></p>
<h1 id="NameSrv启动"><a href="#NameSrv启动" class="headerlink" title="NameSrv启动"></a>NameSrv启动</h1><p>我们按照按照上一篇环境搭建的<code>#org.apache.rocketmq.namesrv.NameServerInstanceTest</code>出发，我们看到Main函数，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    NamesrvConfig namesrvConfig1 = <span class="keyword">new</span> NamesrvConfig();</span><br><span class="line">    NettyServerConfig nettyServerConfig1 = <span class="keyword">new</span> NettyServerConfig();</span><br><span class="line">    nettyServerConfig1.setListenPort(<span class="number">9876</span>);</span><br><span class="line">    NamesrvController nameSrvController1 = <span class="keyword">new</span> NamesrvController(namesrvConfig1, nettyServerConfig1);</span><br><span class="line">    nameSrvController1.initialize();</span><br><span class="line">    nameSrvController1.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不让主方法结束</span></span><br><span class="line">    Thread.sleep(DateUtils.MILLIS_PER_DAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现主要有三个步骤：</p>
<ol>
<li>构造NamesrvController</li>
<li>初始化NamesrvController</li>
<li>启动NamesrvController</li>
</ol>
<p>可见NamesrvController是关键，负责初始化和后台任务启动。</p>
<h2 id="构造NamesrvController"><a href="#构造NamesrvController" class="headerlink" title="构造NamesrvController"></a>构造NamesrvController</h2><p><code>org.apache.rocketmq.namesrv.NamesrvController</code>的构造函数如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NamesrvController</span><span class="params">(NamesrvConfig namesrvConfig, NettyServerConfig nettyServerConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// namesrv参数配置</span></span><br><span class="line">    <span class="keyword">this</span>.namesrvConfig = namesrvConfig;</span><br><span class="line">    <span class="comment">// netty的参数配置</span></span><br><span class="line">    <span class="keyword">this</span>.nettyServerConfig = nettyServerConfig;</span><br><span class="line">    <span class="comment">// KVConfigManager绑定NamesrvController</span></span><br><span class="line">    <span class="keyword">this</span>.kvConfigManager = <span class="keyword">new</span> KVConfigManager(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 初始化RouteInfoManager，很重要</span></span><br><span class="line">    <span class="keyword">this</span>.routeInfoManager = <span class="keyword">new</span> RouteInfoManager();</span><br><span class="line">    <span class="comment">// 监听客户端连接(Channel)的变化，通知RouteInfoManager检查broker是否有变化</span></span><br><span class="line">    <span class="keyword">this</span>.brokerHousekeepingService = <span class="keyword">new</span> BrokerHousekeepingService(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.configuration = <span class="keyword">new</span> Configuration(</span><br><span class="line">        log,</span><br><span class="line">        <span class="keyword">this</span>.namesrvConfig, <span class="keyword">this</span>.nettyServerConfig</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// namesrv的配置参数会保存到磁盘文件中</span></span><br><span class="line">    <span class="keyword">this</span>.configuration.setStorePathFromConfig(<span class="keyword">this</span>.namesrvConfig, <span class="string">"configStorePath"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中主要的就是<code>org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager</code> 它负责缓存整个集群的broker信息，以及topic和queue的配置信息。我们看看的内部构造：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读写锁，控制并发读写</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="comment">// Topic和Broker的Queue的Map，保存了topic在每个broker上的读写Queue的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line"><span class="comment">// 注册到namesrv上的所有Broker，按照brokername分组，Broker使用brokerName来标识主从关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;</span><br><span class="line"><span class="comment">// broker的集群对应关系，使用clusterName来判断多个broker是不是属于同一个集群。</span></span><br><span class="line"><span class="comment">// 对于同一个cluster下的broker，producer在发送消息时只会选择发送给其中一个</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable;</span><br><span class="line"><span class="comment">// broker最新的心跳时间和配置版本号，nameserv会记录brokerAddr的最后活跃时间，</span></span><br><span class="line"><span class="comment">// 如果超过一定时间没有心跳或其他数据交互，会认为broker已下线</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;</span><br><span class="line"><span class="comment">// broker和FilterServer的对应关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br></pre></td></tr></table></figure></p>
<p>RouteInfoManager的所有数据通过HashMap缓存在内存中，通过读写锁来控制并发更新。这样可最大程度的提高客户端查询数据的速度。</p>
<h2 id="初始化NamesrvController"><a href="#初始化NamesrvController" class="headerlink" title="初始化NamesrvController"></a>初始化NamesrvController</h2><p>我们看看它的初始化方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化KVConfigManager</span></span><br><span class="line">    <span class="keyword">this</span>.kvConfigManager.load();</span><br><span class="line">    <span class="comment">// 初始化netty server</span></span><br><span class="line">    <span class="keyword">this</span>.remotingServer = <span class="keyword">new</span> NettyRemotingServer(<span class="keyword">this</span>.nettyServerConfig, <span class="keyword">this</span>.brokerHousekeepingService);</span><br><span class="line">    <span class="comment">// 初始化客户端请求处理的线程池</span></span><br><span class="line">    <span class="keyword">this</span>.remotingExecutor =</span><br><span class="line">        Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"RemotingExecutorThread_"</span>));</span><br><span class="line">    <span class="comment">// 注册DefaultRequestProcessor，所有的客户端请求都会转给这个Processor来处理</span></span><br><span class="line">    <span class="comment">// 它的逻辑到时候会出现在NettyServerHandler里</span></span><br><span class="line">    <span class="keyword">this</span>.registerProcessor();</span><br><span class="line">    <span class="comment">// 启动定时调度，每10秒钟扫描所有Broker，检查存活状态</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NamesrvController.<span class="keyword">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">// 日志打印的调度器，定时打印kvConfigManager的内容</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NamesrvController.<span class="keyword">this</span>.kvConfigManager.printAllPeriodically();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">// 监听ssl证书文件变化</span></span><br><span class="line">    <span class="keyword">if</span> (TlsSystemConfig.tlsMode != TlsMode.DISABLED) &#123;</span><br><span class="line">        <span class="comment">// Register a listener to reload SslContext</span></span><br><span class="line">       <span class="comment">// 省略无用逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以稍微看看它是怎样踢出无效链接的，代码在<code>org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager</code>中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanNotActiveBroker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;String, BrokerLiveInfo&gt;&gt; it = <span class="keyword">this</span>.brokerLiveTable.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, BrokerLiveInfo&gt; next = it.next();</span><br><span class="line">        <span class="keyword">long</span> last = next.getValue().getLastUpdateTimestamp();</span><br><span class="line">        <span class="comment">// 默认120秒</span></span><br><span class="line">        <span class="keyword">if</span> ((last + BROKER_CHANNEL_EXPIRED_TIME) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">            RemotingUtil.closeChannel(next.getValue().getChannel());</span><br><span class="line">            it.remove();</span><br><span class="line">            <span class="keyword">this</span>.onChannelDestroy(next.getKey(), next.getValue().getChannel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="启动NamesrvController"><a href="#启动NamesrvController" class="headerlink" title="启动NamesrvController"></a>启动NamesrvController</h2><p>启动的过程就是启动netty server开始接收客户端请求，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 开启Netty Server</span></span><br><span class="line">    <span class="keyword">this</span>.remotingServer.start();</span><br><span class="line">    <span class="comment">// 监听ssl文件变化，可以实时更新证书</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fileWatchService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fileWatchService.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，Namesrv就启动完成了，下面我们将讲一下它最重要的两个功能Broker注册（管理）和Broker查询。</p>
<h1 id="DefaultRequestProcessor请求处理"><a href="#DefaultRequestProcessor请求处理" class="headerlink" title="DefaultRequestProcessor请求处理"></a>DefaultRequestProcessor请求处理</h1><p>在讲Broker注册（管理）和Broker查询之前我们要将一下DefaultRequestProcessor，因为所有请求都会被它处理，在上面初始化的过程中，我们也看到了它被注册到Netty的Pipeline上。<br>下面我就看看<code>org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor #processRequest</code>方法是如何处理请求的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略无用逻辑</span></span><br><span class="line">    <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> RequestCode.PUT_KV_CONFIG:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.putKVConfig(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_KV_CONFIG:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getKVConfig(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.DELETE_KV_CONFIG:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.deleteKVConfig(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.QUERY_DATA_VERSION:</span><br><span class="line">            <span class="keyword">return</span> queryBrokerTopicConfig(ctx, request);</span><br><span class="line">        <span class="comment">// Broker注册</span></span><br><span class="line">        <span class="keyword">case</span> RequestCode.REGISTER_BROKER:</span><br><span class="line">            Version brokerVersion = MQVersion.value2Version(request.getVersion());</span><br><span class="line">            <span class="keyword">if</span> (brokerVersion.ordinal() &gt;= MQVersion.Version.V3_0_11.ordinal()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.registerBrokerWithFilterServer(ctx, request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.registerBroker(ctx, request);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// Broker注销</span></span><br><span class="line">        <span class="keyword">case</span> RequestCode.UNREGISTER_BROKER:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.unregisterBroker(ctx, request);</span><br><span class="line">        <span class="comment">// 根据Topic拿到Broker路由信息</span></span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_ROUTEINTO_BY_TOPIC:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getRouteInfoByTopic(ctx, request);</span><br><span class="line">        <span class="comment">// 拿到Broker集群信息</span></span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_BROKER_CLUSTER_INFO:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getBrokerClusterInfo(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.WIPE_WRITE_PERM_OF_BROKER:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.wipeWritePermOfBroker(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_ALL_TOPIC_LIST_FROM_NAMESERVER:</span><br><span class="line">            <span class="keyword">return</span> getAllTopicListFromNameserver(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.DELETE_TOPIC_IN_NAMESRV:</span><br><span class="line">            <span class="keyword">return</span> deleteTopicInNamesrv(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_KVLIST_BY_NAMESPACE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getKVListByNamespace(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_TOPICS_BY_CLUSTER:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getTopicsByCluster(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_SYSTEM_TOPIC_LIST_FROM_NS:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getSystemTopicListFromNs(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_UNIT_TOPIC_LIST:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getUnitTopicList(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_HAS_UNIT_SUB_TOPIC_LIST:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getHasUnitSubTopicList(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_HAS_UNIT_SUB_UNUNIT_TOPIC_LIST:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getHasUnitSubUnUnitTopicList(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.UPDATE_NAMESRV_CONFIG:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.updateConfig(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_NAMESRV_CONFIG:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getConfig(ctx, request);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理器根据RemotingCommand中的请求码将执行具体的请求逻辑，下面我们重点分析一下Broker注册和查询。</p>
<h1 id="Broker注册"><a href="#Broker注册" class="headerlink" title="Broker注册"></a>Broker注册</h1><p>根据上面DefaultRequestProcessor的处理逻辑，我们找到<code>#registerBroker</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">registerBroker</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(RegisterBrokerResponseHeader.class);</span><br><span class="line">    <span class="keyword">final</span> RegisterBrokerResponseHeader responseHeader = (RegisterBrokerResponseHeader) response.readCustomHeader();</span><br><span class="line">    <span class="keyword">final</span> RegisterBrokerRequestHeader requestHeader =</span><br><span class="line">        (RegisterBrokerRequestHeader) request.decodeCommandCustomHeader(RegisterBrokerRequestHeader.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略校验</span></span><br><span class="line">    <span class="comment">// topic相关配置</span></span><br><span class="line">    TopicConfigSerializeWrapper topicConfigWrapper;</span><br><span class="line">    <span class="keyword">if</span> (request.getBody() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        topicConfigWrapper = TopicConfigSerializeWrapper.decode(request.getBody(), TopicConfigSerializeWrapper.class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        topicConfigWrapper = <span class="keyword">new</span> TopicConfigSerializeWrapper();</span><br><span class="line">        topicConfigWrapper.getDataVersion().setCounter(<span class="keyword">new</span> AtomicLong(<span class="number">0</span>));</span><br><span class="line">        topicConfigWrapper.getDataVersion().setTimestamp(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据broker上报的信息更新namesrv的RouteInfo</span></span><br><span class="line">    RegisterBrokerResult result = <span class="keyword">this</span>.namesrvController.getRouteInfoManager().registerBroker(</span><br><span class="line">        requestHeader.getClusterName(),</span><br><span class="line">        requestHeader.getBrokerAddr(),</span><br><span class="line">        requestHeader.getBrokerName(),</span><br><span class="line">        requestHeader.getBrokerId(),</span><br><span class="line">        requestHeader.getHaServerAddr(),</span><br><span class="line">        topicConfigWrapper,</span><br><span class="line">        <span class="keyword">null</span>,</span><br><span class="line">        ctx.channel()</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 返回master和haserver地址</span></span><br><span class="line">    responseHeader.setHaServerAddr(result.getHaServerAddr());</span><br><span class="line">    responseHeader.setMasterAddr(result.getMasterAddr());</span><br><span class="line">    <span class="comment">// 将topic的KV配置信息通过response返回</span></span><br><span class="line">    <span class="keyword">byte</span>[] jsonValue = <span class="keyword">this</span>.namesrvController.getKvConfigManager().getKVListByNamespace(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG);</span><br><span class="line">    response.setBody(jsonValue);</span><br><span class="line">    response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">    response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们继续看看如何更新namesrv的RouteInfo，找到<code>org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager#registerBroker</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RegisterBrokerResult <span class="title">registerBroker</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String clusterName,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String brokerAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String brokerName,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">long</span> brokerId,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String haServerAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> TopicConfigSerializeWrapper topicConfigWrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> List&lt;String&gt; filterServerList,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Channel channel)</span> </span>&#123;</span><br><span class="line">    RegisterBrokerResult result = <span class="keyword">new</span> RegisterBrokerResult();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 更新加锁</span></span><br><span class="line">            <span class="keyword">this</span>.lock.writeLock().lockInterruptibly();</span><br><span class="line">            <span class="comment">// 更新cluster和broker对应关系</span></span><br><span class="line">            Set&lt;String&gt; brokerNames = <span class="keyword">this</span>.clusterAddrTable.get(clusterName);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == brokerNames) &#123;</span><br><span class="line">                brokerNames = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">                <span class="keyword">this</span>.clusterAddrTable.put(clusterName, brokerNames);</span><br><span class="line">            &#125;</span><br><span class="line">            brokerNames.add(brokerName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> registerFirst = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 更新brokername和brokerdata的分组</span></span><br><span class="line">            BrokerData brokerData = <span class="keyword">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</span><br><span class="line">                registerFirst = <span class="keyword">true</span>;</span><br><span class="line">                brokerData = <span class="keyword">new</span> BrokerData(clusterName, brokerName, <span class="keyword">new</span> HashMap&lt;Long, String&gt;());</span><br><span class="line">                <span class="keyword">this</span>.brokerAddrTable.put(brokerName, brokerData);</span><br><span class="line">            &#125;</span><br><span class="line">            String oldAddr = brokerData.getBrokerAddrs().put(brokerId, brokerAddr);</span><br><span class="line">            registerFirst = registerFirst || (<span class="keyword">null</span> == oldAddr);</span><br><span class="line">            <span class="comment">// 如果是master broker，第一次注册或者是topic信息发生变化了，更新topicQueueTable</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != topicConfigWrapper</span><br><span class="line">                &amp;&amp; MixAll.MASTER_ID == brokerId) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion())</span><br><span class="line">                    || registerFirst) &#123;</span><br><span class="line">                    ConcurrentMap&lt;String, TopicConfig&gt; tcTable =</span><br><span class="line">                        topicConfigWrapper.getTopicConfigTable();</span><br><span class="line">                    <span class="keyword">if</span> (tcTable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.createAndUpdateQueueData(brokerName, entry.getValue());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新broker的心跳时间</span></span><br><span class="line">            BrokerLiveInfo prevBrokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.put(brokerAddr,</span><br><span class="line">                <span class="keyword">new</span> BrokerLiveInfo(</span><br><span class="line">                    System.currentTimeMillis(),</span><br><span class="line">                    topicConfigWrapper.getDataVersion(),</span><br><span class="line">                    channel,</span><br><span class="line">                    haServerAddr));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == prevBrokerLiveInfo) &#123;</span><br><span class="line">                log.info(<span class="string">"new broker registered, &#123;&#125; HAServer: &#123;&#125;"</span>, brokerAddr, haServerAddr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新filter server table</span></span><br><span class="line">            <span class="keyword">if</span> (filterServerList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (filterServerList.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.filterServerTable.remove(brokerAddr);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.filterServerTable.put(brokerAddr, filterServerList);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是slave broker注册，如果master存在，则返回master broker信息</span></span><br><span class="line">            <span class="keyword">if</span> (MixAll.MASTER_ID != brokerId) &#123;</span><br><span class="line">                String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</span><br><span class="line">                <span class="keyword">if</span> (masterAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    BrokerLiveInfo brokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.get(masterAddr);</span><br><span class="line">                    <span class="keyword">if</span> (brokerLiveInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</span><br><span class="line">                        result.setMasterAddr(masterAddr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"registerBroker Exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Broker查询"><a href="#Broker查询" class="headerlink" title="Broker查询"></a>Broker查询</h1><p>根据上面DefaultRequestProcessor的处理逻辑，我们找到<code>#getRouteInfoByTopic</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">getRouteInfoByTopic</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> GetRouteInfoRequestHeader requestHeader =</span><br><span class="line">        (GetRouteInfoRequestHeader) request.decodeCommandCustomHeader(GetRouteInfoRequestHeader.class);</span><br><span class="line">    <span class="comment">// 从RouteInfoManager中获取topic的Broker信息</span></span><br><span class="line">    TopicRouteData topicRouteData = <span class="keyword">this</span>.namesrvController.getRouteInfoManager().pickupTopicRouteData(requestHeader.getTopic());</span><br><span class="line">    <span class="comment">// 如果支持顺序消息，则填充KVConfig信息</span></span><br><span class="line">    <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.namesrvController.getNamesrvConfig().isOrderMessageEnable()) &#123;</span><br><span class="line">            String orderTopicConf =</span><br><span class="line">                <span class="keyword">this</span>.namesrvController.getKvConfigManager().getKVConfig(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG,</span><br><span class="line">                    requestHeader.getTopic());</span><br><span class="line">            topicRouteData.setOrderTopicConf(orderTopicConf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] content = topicRouteData.encode();</span><br><span class="line">        response.setBody(content);</span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.setCode(ResponseCode.TOPIC_NOT_EXIST);</span><br><span class="line">    response.setRemark(<span class="string">"No topic route info in name server for the topic: "</span> + requestHeader.getTopic()</span><br><span class="line">        + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们继续看看如何查找namesrv的RouteInfo，找到<code>org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager#pickupTopicRouteData</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TopicRouteData <span class="title">pickupTopicRouteData</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">    TopicRouteData topicRouteData = <span class="keyword">new</span> TopicRouteData();</span><br><span class="line">    <span class="keyword">boolean</span> foundQueueData = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> foundBrokerData = <span class="keyword">false</span>;</span><br><span class="line">    Set&lt;String&gt; brokerNameSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    List&lt;BrokerData&gt; brokerDataList = <span class="keyword">new</span> LinkedList&lt;BrokerData&gt;();</span><br><span class="line">    topicRouteData.setBrokerDatas(brokerDataList);</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, List&lt;String&gt;&gt; filterServerMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">    topicRouteData.setFilterServerTable(filterServerMap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取读锁</span></span><br><span class="line">            <span class="keyword">this</span>.lock.readLock().lockInterruptibly();</span><br><span class="line">            <span class="comment">// 获取所有支持该topic的broker的queue配置</span></span><br><span class="line">            List&lt;QueueData&gt; queueDataList = <span class="keyword">this</span>.topicQueueTable.get(topic);</span><br><span class="line">            <span class="keyword">if</span> (queueDataList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                topicRouteData.setQueueDatas(queueDataList);</span><br><span class="line">                foundQueueData = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 获取BrokerName Set</span></span><br><span class="line">                Iterator&lt;QueueData&gt; it = queueDataList.iterator();</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    QueueData qd = it.next();</span><br><span class="line">                    brokerNameSet.add(qd.getBrokerName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 根据brokerName获取broker主从地址以及过滤器信息</span></span><br><span class="line">                <span class="keyword">for</span> (String brokerName : brokerNameSet) &#123;</span><br><span class="line">                    BrokerData brokerData = <span class="keyword">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != brokerData) &#123;</span><br><span class="line">                        BrokerData brokerDataClone = <span class="keyword">new</span> BrokerData(brokerData.getCluster(), brokerData.getBrokerName(), (HashMap&lt;Long, String&gt;) brokerData</span><br><span class="line">                            .getBrokerAddrs().clone());</span><br><span class="line">                        brokerDataList.add(brokerDataClone);</span><br><span class="line">                        foundBrokerData = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">final</span> String brokerAddr : brokerDataClone.getBrokerAddrs().values()) &#123;</span><br><span class="line">                            List&lt;String&gt; filterServerList = <span class="keyword">this</span>.filterServerTable.get(brokerAddr);</span><br><span class="line">                            filterServerMap.put(brokerAddr, filterServerList);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"pickupTopicRouteData Exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (foundBrokerData &amp;&amp; foundQueueData) &#123;</span><br><span class="line">        <span class="keyword">return</span> topicRouteData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此，我们就介绍完啦！其实简单来看，Namesrv其实一个用Netty写的一个<code>NettyRemotingServer</code>，在Namesrv定义了一个默认处理器<code>DefaultRequestProcessor</code>，在这个处理器中会根绝具体的请求码去做一些更新<code>RouteInfoManager</code>的操作，在<code>RouteInfoManager</code>中利用HashMap保存了各种关系映射，就这么简单，那么到这里结束啦！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/1686fdfc409b" target="_blank" rel="noopener">RocketMQ源码解析(二)-nameserv</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：NameSrv是RocketMQ的注册中心，保存所有Broker、Topic的元数据。Broker启动后会向namesrv发送心跳，namesrv也会定时检测broker的可用性，并移除不可用的broker。对于生产者和消费者来说，它提供了Broker的查询服务。
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>DDD Flag</title>
    <link href="http://bestlixiang.site/2019/06/09/DDD/DDD%20Flag/"/>
    <id>http://bestlixiang.site/2019/06/09/DDD/DDD Flag/</id>
    <published>2019-06-09T05:52:42.000Z</published>
    <updated>2019-06-09T05:02:49.015Z</updated>
    
    <content type="html"><![CDATA[<p>引：上周看完了Eric Evans 的《领域驱动设计—软件核心复杂性应对之道》，影响比较深的就是是这样一句话——软件的核心是其为用户解决领域相关问题的能力。<a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看花是花，看花不是花，看花是花。这是一个过程。我想所有人在学习一个东西都是这样一个过程。在忙于CRUD的过程中，我最初看待业务只是觉得他就是一个自然的业务逻辑，照着写就完事了，这处于第一步；当看完《领域驱动设计—软件核心复杂性应对之道》之后，发现在进行业务编码的时候我们更应该往领域上靠近，最好能形成一套领域模式，但是原来的业务逻辑已经不是简单的业务逻辑了，这是第二步，而我好像就处于这一步；但是我相信以后能熟练的使用领域驱动设计的时候，那时候业务又是业务了，达到第三步。Flag here！</p>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><ol>
<li><a href="https://tech.meituan.com/2017/12/22/ddd-in-practice.html" target="_blank" rel="noopener">领域驱动设计在互联网业务开发中的实践</a></li>
<li><a href="http://www.sohu.com/a/191769788_748431" target="_blank" rel="noopener">交易系统 - 领域驱动设计浅析 </a></li>
</ol>
<p>第二个是自己目前的重点，希望接下来能好好理解并且实践！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：上周看完了Eric Evans 的《领域驱动设计—软件核心复杂性应对之道》，影响比较深的就是是这样一句话——软件的核心是其为用户解决领域相关问题的能力。
    
    </summary>
    
      <category term="DDD" scheme="http://bestlixiang.site/categories/DDD/"/>
    
    
      <category term="DDD" scheme="http://bestlixiang.site/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>再看单元测试</title>
    <link href="http://bestlixiang.site/2019/06/09/%E8%B5%9E/%E5%86%8D%E7%9C%8B%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://bestlixiang.site/2019/06/09/赞/再看单元测试/</id>
    <published>2019-06-09T03:18:46.000Z</published>
    <updated>2019-06-09T03:23:59.594Z</updated>
    
    <content type="html"><![CDATA[<p>引：对于大部分开发来说，写单元测试时一件多么痛苦的事呀！<a id="more"></a></p>
<h1 id="单元测试介绍"><a href="#单元测试介绍" class="headerlink" title="单元测试介绍"></a>单元测试介绍</h1><h2 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h2><p><img src="https://upload-images.jianshu.io/upload_images/10354196-e61d89f061b4de52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试架构.png"><br>单元测试是指对软件中的最小可测试单元进行检查和验证。相信大多数都看见过这幅测试模型图，根据测试金字塔原理，越往上层的测试，所需的测试投入比例越大，效果也越差，而单元测试的成本要小的多，也更容易发现问题。话虽然这么说，但是写单元测试对于大部分开发来说依然是一件很蛋疼的事。在以前没有QA的年代，TDD单元测试驱动开发以前还是很火的，现在就不知道了。因为那个时候没有QA，开发都得靠自己测试，在重构项目时，通过单元测试可以快速的了解到自己重构时发生的修改，然后重新修正。但是现在有专业的QA同学，他们会写集成测试，导致了开发更加不想写单元测试了。但是很多公司都会有单元测试的硬性要求加上谁知道QA是不是一个和蔼可亲的小姐姐，所以单元测试还是得写，不管用不用得上，万一用得上呢？</p>
<h2 id="单元测试和集成测试"><a href="#单元测试和集成测试" class="headerlink" title="单元测试和集成测试"></a>单元测试和集成测试</h2><p>单元测试和集成测试的界线我相信大部分开发也是不清晰的。我也不是特别清楚。个人理解单元测试针对于一块业务逻辑最小的单元，可以简单理解为一个类的方法。一个单元测试不应该包含外部依赖的逻辑，反之就是集成测试了。 但是一个service的一个接口实现一般都会依赖很多第三方：1.本地其它的service 2.dao调用 3.rpc调用 4.微服务调用，等等。相信大家一定身有感受。</p>
<p>但是我们遇到的就是这样的情况，那我们还怎么写单元测试呀？答案是<strong>MOCK</strong>。现在有很多Mock的开源框架比如：mockito，easymock，还有更强大的powermock，最后放了使用参考链接。那么问题来了，既然我们可以mock第三方远程依赖，为何不mock dao、local service呢？没错外部依赖全部mock掉，就是单元测试了。因为我们只关心所测试的方法的业务逻辑，也就是真正高内聚的逻辑单元了。</p>
<p>有了Mock，我们发现：没有什么数据是造不出来的，而且还不产生任何脏数据， 跑case更快了，因为不用启动整个项目。是不是整个世界都清晰了，但是一想又有点害怕，毕竟都mock了还测试个鸡儿。还是回到对单元测试得理解，单元测试应该只针对于目标方法的业务逻辑测试，dao、其它service应该在它们自身的单元测试去测试。对于依赖的第三方，我们应该信任它们能正确的完成我们所预期的。我们应该验证的内容是：方法是否被调用，调用的次数对不对，调用参数对不对，只要这三个验证通过，就OK了。Mockito框架的verify接口就是做这件事情的。如果你理解了上述内容，那么你就开窍了，UT不在变得这么难写。</p>
<h1 id="单元测试规范"><a href="#单元测试规范" class="headerlink" title="单元测试规范"></a>单元测试规范</h1><p>好的单元测试必须遵守AIR 原则<br>A：Automatic（自动化）<br>I:    Independent（独立性）<br>R:   Repeatable（可重复） </p>
<ol>
<li>单元测试必须是全自动的，非交互式的，必须使用assert 验证，不能使用 System.out.println  肉眼观察执行结果，无参方法测试后，需要使用verify 进行验证</li>
<li>保持单元测试的独立性。单元测试用例之间不能相互调用，不能依赖执行的先后顺序</li>
<li><p>单元测试是可以重复执行的，不能受到外界环境的影响</p>
<ul>
<li>业务中使用了localcache、redis 缓存的，执行测试用例前，先清理缓存</li>
<li>DB 的测试，不可以依赖真实的DB，需要用 H2 测试框架mock 数据层，使用方式：<a href="http://www.h2database.com/html/main.html" target="_blank" rel="noopener">http://www.h2database.com/html/main.html</a></li>
<li>所有的第三方 dubbo 调用，也需要mock 调，不可以真实调用。</li>
<li>所有的中间件mock 掉。</li>
</ul>
</li>
<li><p>单元测试必须写在如下工程目录中: src/test/java，不允许写在业务代码目录下。禁止通过在业务代码类中写 main 函数进行测试</p>
</li>
<li>单元测试的BCDE 原则，保证被测模块的交付质量<ul>
<li>B: Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。</li>
<li>C：Correct，正确的输入，并得到预期结果。</li>
<li>D:  Design，与设计文档结合，编写测试用例</li>
<li>E:  Error，错误的信息输入，得到预期结果</li>
</ul>
</li>
</ol>
<h1 id="单元测试实践"><a href="#单元测试实践" class="headerlink" title="单元测试实践"></a>单元测试实践</h1><h2 id="单元测试的过程"><a href="#单元测试的过程" class="headerlink" title="单元测试的过程"></a>单元测试的过程</h2><p><img src="https://upload-images.jianshu.io/upload_images/10354196-1e92c9bd81100ef5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单元测试流程.png"></p>
<p>单元测试的编写，主要包含以下几个阶段：</p>
<ol>
<li>数据准备：在编写测试用例前，尤其是Dao层，需要依赖到一些数据，数据来源一般是数据库，而构造数据，又不能依赖 DAO 层的代码，需要使用原生jdbc 去插入数据，测试代码编写效率低。</li>
<li>构造参数及打桩（stub）：调用方法需要传递入参，有时候一个入参十几个参数需要 set，set 方法写完，代码已经写了十来行了。</li>
<li>执行测试：这一步比较简单，直接调用被测方法即可。</li>
<li>结果验证：这里除了验证被测方法的返回值外，还需要验证插入到数据库中的 数据是否正确，某外部方法被调用过n次或未调用过。</li>
<li>必要的清理：对打桩进行清理，对数据库脏数据进行清理。</li>
</ol>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>基于上面的问题，我们可以采用如下的解决方案：<br><strong>spring-test+powermock +h2数据库 的测试框架</strong></p>
<ol>
<li>H2数据库<br>H2数据库非常适合在测试程序中使用，程序关闭时自动清理数据，H2 数据库的表结构初始化是通过 jdbc:initialize-database 标签实现的，单元测试中使用 H2 数据库非常简单，仅需修改 jdbc 连接即可。</li>
<li>powermock<br>powermock支持静态方法 mock，同时兼容 mockito，powermock 示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXXTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> YourTestService yourTestService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> YourRPCClient yourRPCClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 构造参数，这里可以使用json构造</span></span><br><span class="line">     </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://juejin.im/post/5be7eaf26fb9a049d4415278" target="_blank" rel="noopener">Mockito与PowerMock的使用基础教程</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTY5MDMxNA==&amp;mid=2455759766&amp;idx=1&amp;sn=536939d467bf2f09525809f74b20860e" target="_blank" rel="noopener">有赞单元测试实践</a></li>
<li><a href="http://www.h2database.com/html/quickstart.html" target="_blank" rel="noopener">H2数据库</a></li>
<li><a href="https://github.com/powermock/powermock" target="_blank" rel="noopener">powermock</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：对于大部分开发来说，写单元测试时一件多么痛苦的事呀！
    
    </summary>
    
      <category term="赞" scheme="http://bestlixiang.site/categories/%E8%B5%9E/"/>
    
    
      <category term="单元测试" scheme="http://bestlixiang.site/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——环境搭建</title>
    <link href="http://bestlixiang.site/2019/06/08/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://bestlixiang.site/2019/06/08/RocketMQ源码/RocketMQ源码分析——环境搭建/</id>
    <published>2019-06-08T07:32:37.000Z</published>
    <updated>2019-06-08T07:38:45.257Z</updated>
    
    <content type="html"><![CDATA[<p>引：终于要开始了吗，一直想好好弄清楚一款MQ，作为一名Javaer，肯定选择RocketMQ，希望今天是一个好开始！<a id="more"></a></p>
<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p>在看源码前大家都至少应该使用过RocketMQ，并且了解它的相关原理，所以这里丢出两个链接，虽然有点老~</p>
<ol>
<li><a href="[http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408164726/RocketMQ_userguide.pdf](http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408164726/RocketMQ_userguide.pdf">RocketMQ 用户指南</a></li>
<li><a href="[http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408165024/RocketMQ_design.pdf](http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408165024/RocketMQ_design.pdf">RocketMQ 原理简介</a></li>
</ol>
<h1 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h1><ol>
<li>Git</li>
<li>Maven</li>
<li>JDK1.8</li>
<li>IntelliJ IDEA</li>
</ol>
<h1 id="源码拉取"><a href="#源码拉取" class="headerlink" title="源码拉取"></a>源码拉取</h1><p>从官方仓库 <a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener">https://github.com/apache/rocketmq</a> 通过Git拉取代码到本地，在2019.6.8看到最新的release版本是4.5.1，但是为了和芋艿大佬保持一致，我也选择了4.4.0版本，所以将代码拉取到本地之后，我们切换到4.4.0分支。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/apache/rocketmq.git</span><br><span class="line">git checkout -b release-4.4.0 origin/release-4.4.0</span><br></pre></td></tr></table></figure>
<p>然后我们就可以看是搭建调试环境啦~</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="启动-RocketMQ-Namesrv"><a href="#启动-RocketMQ-Namesrv" class="headerlink" title="启动 RocketMQ Namesrv"></a>启动 RocketMQ Namesrv</h2><p>打开 <code>org.apache.rocketmq.namesrv.NameServerInstanceTest</code> 单元测试类，参考 <code>#startup()</code> 方法，我们编写 <code>#main(String[] args)</code> 静态方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    NamesrvConfig namesrvConfig1 = <span class="keyword">new</span> NamesrvConfig();</span><br><span class="line">    NettyServerConfig nettyServerConfig1 = <span class="keyword">new</span> NettyServerConfig();</span><br><span class="line">    nettyServerConfig1.setListenPort(<span class="number">9876</span>);</span><br><span class="line">    NamesrvController nameSrvController1 = <span class="keyword">new</span> NamesrvController(namesrvConfig1, nettyServerConfig1);</span><br><span class="line">    nameSrvController1.initialize();</span><br><span class="line">    nameSrvController1.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不让主方法结束</span></span><br><span class="line">    Thread.sleep(DateUtils.MILLIS_PER_DAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后，输出如下日志就代表OK啦~</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">14:41:41.202 [NettyEventExecutor] INFO  RocketmqRemoting - NettyEventExecutor service started</span><br><span class="line">14:41:41.203 [FileWatchService] INFO  RocketmqCommon - FileWatchService service started</span><br></pre></td></tr></table></figure>
<h2 id="启动-RocketMQ-Broker"><a href="#启动-RocketMQ-Broker" class="headerlink" title="启动 RocketMQ Broker"></a>启动 RocketMQ Broker</h2><p>打开 <code>org.apache.rocketmq.broker.BrokerControllerTest</code> 单元测试类，参考 <code>#testBrokerRestart()</code> 方法，我们编写 <code>#main(String[] args)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 设置版本号，很关键，不然topic创建不成功</span></span><br><span class="line">      System.setProperty(RemotingCommand.REMOTING_VERSION_KEY, Integer.toString(MQVersion.CURRENT_VERSION));</span><br><span class="line">      <span class="keyword">final</span> BrokerConfig brokerConfig = <span class="keyword">new</span> BrokerConfig();</span><br><span class="line">      brokerConfig.setBrokerName(<span class="string">"broker-a"</span>);</span><br><span class="line">      brokerConfig.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line"></span><br><span class="line">      BrokerController brokerController = <span class="keyword">new</span> BrokerController(</span><br><span class="line">              brokerConfig,</span><br><span class="line">              <span class="keyword">new</span> NettyServerConfig(),</span><br><span class="line">              <span class="keyword">new</span> NettyClientConfig(),</span><br><span class="line">              <span class="keyword">new</span> MessageStoreConfig());</span><br><span class="line">      assertThat(brokerController.initialize());</span><br><span class="line">      brokerController.start();</span><br><span class="line">      <span class="comment">// 不让主方法结束</span></span><br><span class="line">      Thread.sleep(DateUtils.MILLIS_PER_DAY);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>运行之后，虽然在broker下面什么日志都没有，但是在Namesrv已经看到了broker的注册日志，如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">15:19:21.437 [NettyServerCodecThread_4] INFO  RocketmqRemoting - NETTY SERVER PIPELINE: channelRegistered 127.0.0.1:58887</span><br><span class="line">15:19:21.437 [NettyServerCodecThread_4] INFO  RocketmqRemoting - NETTY SERVER PIPELINE: channelActive, the channel[127.0.0.1:58887]</span><br><span class="line">15:19:21.460 [RemotingExecutorThread_7] DEBUG RocketmqNamesrv - receive request, 103 127.0.0.1:58887 RemotingCommand [code=103, language=JAVA, version=293, opaque=0, flag(B)=0, remark=null, extFields=&#123;brokerId=0, bodyCrc32=2135245619, clusterName=DefaultCluster, brokerAddr=192.168.1.28:8888, haServerAddr=192.168.1.28:10912, compressed=<span class="literal">false</span>, brokerName=broker<span class="_">-a</span>&#125;, serializeTypeCurrentRPC=JSON]</span><br><span class="line">15:19:21.461 [RemotingExecutorThread_7] INFO  RocketmqNamesrv - new topic registered, RMQ_SYS_TRANS_HALF_TOPIC QueueData [brokerName=broker<span class="_">-a</span>, <span class="built_in">read</span>QueueNums=1, writeQueueNums=1, perm=6, topicSynFlag=0]</span><br><span class="line">15:19:21.461 [RemotingExecutorThread_7] INFO  RocketmqNamesrv - new broker registered, 192.168.1.28:8888 HAServer: 192.168.1.28:10912</span><br></pre></td></tr></table></figure>
<h2 id="启动-RocketMQ-Producer"><a href="#启动-RocketMQ-Producer" class="headerlink" title="启动 RocketMQ Producer"></a>启动 RocketMQ Producer</h2><p>打开 <code>org.apache.rocketmq.example.quickstart.Producer</code> 示例类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Instantiate with a producer group name.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Specify name server addresses.</span></span><br><span class="line"><span class="comment">         * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Alternatively, you may specify name server addresses via exporting environmental variable: NAMESRV_ADDR</span></span><br><span class="line"><span class="comment">         * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">         * &#123;@code</span></span><br><span class="line"><span class="comment">         * producer.setNamesrvAddr("name-server1-ip:9876;name-server2-ip:9876");</span></span><br><span class="line"><span class="comment">         * &#125;</span></span><br><span class="line"><span class="comment">         * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Launch the instance.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指明Namesrv</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                    <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                    (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Call send message to deliver message to one of brokers.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                SendResult sendResult = producer.send(msg);</span><br><span class="line"></span><br><span class="line">                System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Shut down once the producer instance is not longer in use.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据注释，我们需要指明Namesrv地址:<code>producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);</code></p>
<p>运行之后就会发送1000条消息啦，然后就会断开与Namesrv，broker的连接，日志如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SendResult [sendStatus=SEND_OK, msgId=C0A8011C69E618B4AAC22757459803E7, offsetMsgId=C0A8011C000022B80000000000057CB0, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker<span class="_">-a</span>, queueId=0], queueOffset=499]</span><br><span class="line">15:20:30.889 [NettyClientSelector_1] INFO  RocketmqRemoting - closeChannel: close the connection to remote address[192.168.1.28:8888] result: <span class="literal">true</span></span><br><span class="line">15:20:30.890 [NettyClientSelector_1] INFO  RocketmqRemoting - closeChannel: close the connection to remote address[192.168.1.28:8886] result: <span class="literal">true</span></span><br><span class="line">15:20:30.891 [NettyClientSelector_1] INFO  RocketmqRemoting - closeChannel: close the connection to remote address[127.0.0.1:9876] result: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="启动-RocketMQ-Producer-1"><a href="#启动-RocketMQ-Producer-1" class="headerlink" title="启动 RocketMQ Producer"></a>启动 RocketMQ Producer</h2><p>打开 <code>org.apache.rocketmq.example.quickstart.Consumer</code> 示例类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Instantiate with specified consumer group name.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_4"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Specify name server addresses.</span></span><br><span class="line"><span class="comment">         * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Alternatively, you may specify name server addresses via exporting environmental variable: NAMESRV_ADDR</span></span><br><span class="line"><span class="comment">         * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">         * &#123;@code</span></span><br><span class="line"><span class="comment">         * consumer.setNamesrvAddr("name-server1-ip:9876;name-server2-ip:9876");</span></span><br><span class="line"><span class="comment">         * &#125;</span></span><br><span class="line"><span class="comment">         * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 指明Namesrv</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Specify where to start in case the specified consumer group is a brand new one.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Subscribe one more more topics to consume.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  Register callback to execute on arrival of messages fetched from brokers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">"%s Receive New Messages: %s %n"</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  Launch the consumer instance.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据注释，我们这里也需要指明Namesrv地址:<code>consumer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);</code></p>
<p>疯狂消费的日志如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Consumer Started.</span><br><span class="line">ConsumeMessageThread_3 Receive New Messages: [MessageExt [queueId=1, storeSize=178, queueOffset=250, sysFlag=0, bornTimestamp=1559978428786, bornHost=/192.168.1.28:58898, storeTimestamp=1559978428830, storeHost=/192.168.1.28:8888, msgId=C0A8011C000022B8000000000002BEB2, commitLogOffset=179890, bodyCRC=613185359, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message&#123;topic=<span class="string">'TopicTest'</span>, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=500, CONSUME_START_TIME=1559978752764, UNIQ_KEY=C0A8011C69E618B4AAC227573D700000, WAIT=<span class="literal">true</span>, TAGS=TagA&#125;, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 48], transactionId=<span class="string">'null'</span>&#125;]] </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>It`s over !!</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>很喜欢下面的话：</p>
<p><strong>源码，是原理的具象化</strong><br><strong>原理，是代码的抽象化</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：终于要开始了吗，一直想好好弄清楚一款MQ，作为一名Javaer，肯定选择RocketMQ，希望今天是一个好开始！
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP读后感</title>
    <link href="http://bestlixiang.site/2019/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CSAPP%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <id>http://bestlixiang.site/2019/05/26/计算机基础/CSAPP读后感/</id>
    <published>2019-05-26T13:57:48.000Z</published>
    <updated>2019-05-26T14:31:29.356Z</updated>
    
    <content type="html"><![CDATA[<p>引：对于一个非科班的程序员，计算机基础可能永远都是他的梦魇。我也不例外，虽然之前也看过计算机组成，操作系统，计算机网络，数据结构与算法，但是可能都是自学，然后有点浮于表面，让自己的心里一直都不太踏实。CSAPP是自己一直想读的书，但是很多时候看了两章就放弃了，这次算是坚持了3个星期看完了它，然后发表水文一篇！证明自己来过🤣<a id="more"></a></p>
<h1 id="内容介绍"><a href="#内容介绍" class="headerlink" title="内容介绍"></a>内容介绍</h1><p>在程序的世界，万事离不开HelloWorld，本书也还是从一个helloworld向我们介绍了一个helloworld程序是怎么运行的，从编译到涉及的硬件以及操作系统，网络通信，先把大概的概念来了一套，然后就开始正文啦！！先从数据的表示开始（牛逼），自然而然引出程序的表示（重点在于汇编），接着讲解了处理器是如何执行汇编指令的（处理器是怎么工作的），这里又涉及到了存储器相关内容（存储器山）；接着介绍控制流（涉及到进程，信号）、虚拟内存（动态分配，垃圾搜集）等高级话题，这之后开始涉及诸如I/O、网络编程、并发编程等知识。总之，干货满满，但是需要挺花时间的，哎，懒了懒了！！！</p>
<h1 id="整体感受"><a href="#整体感受" class="headerlink" title="整体感受"></a>整体感受</h1><p>这本书涉及的点还是蛮多的，像是一本计算机组成和操作系统的组合书籍，但是可能也是因为组合，有些点就讲得没有那么细了，但是在书里都可以给出相应的学习建议和参考文献，我觉得很不错。其实这本书还配套了相应的<a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener">实验</a>，这个实验还是有一定难度的，所以自己就不了了之了，希望以后有机会再来搞一遍，相信收获一定挺大。总的来说，这本书还是给我解答了一些疑惑和加深一些印象，尤其是在操作系统方面。刚好借用之前同事说的一句话：<strong>不同的时候，读相同的东西，他的感受和收获一定是不同的</strong>。</p>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>虽说看完了这本书，但是自己还是有很多地方没有理解，以后一定会再看一次的。这里想留给自己一个问题，让自己越来越迷糊的问题（希望清楚的人也能告诉我这个小菜鸡，哈哈）：<strong>计算机从打开电源后是怎么运行的？（从硬件到软件）</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://wdxtub.com/work/" target="_blank" rel="noopener">不周山作品集</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：对于一个非科班的程序员，计算机基础可能永远都是他的梦魇。我也不例外，虽然之前也看过计算机组成，操作系统，计算机网络，数据结构与算法，但是可能都是自学，然后有点浮于表面，让自己的心里一直都不太踏实。CSAPP是自己一直想读的书，但是很多时候看了两章就放弃了，这次算是坚持了3个星期看完了它，然后发表水文一篇！证明自己来过🤣
    
    </summary>
    
      <category term="计算机基础" scheme="http://bestlixiang.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机组成" scheme="http://bestlixiang.site/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
      <category term="操作系统" scheme="http://bestlixiang.site/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>JVM源码——劝退待起航</title>
    <link href="http://bestlixiang.site/2019/04/26/JVM%E6%BA%90%E7%A0%81/JVM%E6%BA%90%E7%A0%81%E2%80%94%E2%80%94%E5%8A%9D%E9%80%80%E5%BE%85%E8%B5%B7%E8%88%AA/"/>
    <id>http://bestlixiang.site/2019/04/26/JVM源码/JVM源码——劝退待起航/</id>
    <published>2019-04-26T12:15:14.000Z</published>
    <updated>2019-04-26T12:25:06.543Z</updated>
    
    <content type="html"><![CDATA[<p>原以为可以平结自己略懂的C++去看JVM源码，但是等到自己真正去打开源码，就算是对着博客看，也是十分吃力，还看了知乎R大对看JVM源码的看法。SO，我被自己和R大劝退了，可能目前的自己还不适合去看，希望自己以后<strong>有需要有梦想</strong>再来看！<a id="more"></a><br><img src="https://upload-images.jianshu.io/upload_images/10354196-a3eeb7ecd08d51cf.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="劝退.jpeg"></p>
<h1 id="劝退"><a href="#劝退" class="headerlink" title="劝退"></a>劝退</h1><p><a href="https://www.zhihu.com/question/20097631" target="_blank" rel="noopener">R大关于 <strong>Java JVM怎么学习啊？从哪方面入手？</strong>的回答</a></p>
<p>这完全取决于题主是为什么要学习JVM，想学到多深。前面 <a href="//www.zhihu.com/people/05f661615136170935175f54719ff0a0">@曹旭东</a> 和 <a href="//www.zhihu.com/people/7a082a33732215bdd02df94467fe6b1f">@Scott</a> 说得很对。<br>如果感觉摸不清东南西北的话请试试从我在豆瓣上发的豆单开始吧：<a href="https://link.zhihu.com/?target=http%3A//book.douban.com/doulist/2545443/" target="_blank" rel="noopener">从表到里学习JVM实现</a><br>如果一上来就想通过阅读OpenJDK里的HotSpot VM的源码来入手学习JVM，那么我推荐先读读我之前写的一个演示稿：<a href="https://link.zhihu.com/?target=http%3A//rednaxelafx.iteye.com/blog/1426530" target="_blank" rel="noopener">为啥别读HotSpot VM的源码</a></p>
<p>虽然说现在不看了，但是自己还是留在几个JVM解析相关博客：</p>
<ol>
<li><a href="https://www.jianshu.com/nb/12554212" target="_blank" rel="noopener">JVM源码分析</a></li>
<li><a href="https://hunterzhao.io/categories/#" target="_blank" rel="noopener">JVM源码揭秘</a></li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>但行好事，莫问前程</p>
<p>状态：感觉什么都懂一点，又感觉什么都不懂 —— 不够深入</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原以为可以平结自己略懂的C++去看JVM源码，但是等到自己真正去打开源码，就算是对着博客看，也是十分吃力，还看了知乎R大对看JVM源码的看法。SO，我被自己和R大劝退了，可能目前的自己还不适合去看，希望自己以后&lt;strong&gt;有需要有梦想&lt;/strong&gt;再来看！
    
    </summary>
    
      <category term="JVM源码" scheme="http://bestlixiang.site/categories/JVM%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM源码——Mac下编译JDK</title>
    <link href="http://bestlixiang.site/2019/04/25/JVM%E6%BA%90%E7%A0%81/JVM%E6%BA%90%E7%A0%81%E2%80%94%E2%80%94Mac%E4%B8%8B%E7%BC%96%E8%AF%91JDK/"/>
    <id>http://bestlixiang.site/2019/04/25/JVM源码/JVM源码——Mac下编译JDK/</id>
    <published>2019-04-25T13:07:14.000Z</published>
    <updated>2019-04-25T12:57:43.140Z</updated>
    
    <content type="html"><![CDATA[<p>引：好像是在大四的时候，自己按照《深入理解Java虚拟机》去编译JDK没有成功！但是在最近经历一些面试之后，感到JVM绝对是面试的一块重点，而看源码绝对是你深入理解JVM的一个很重要的点！在看源码，就需要调试，那么编译自己JDK越是必然的。这次我们在Mac下去编译OpenJDK9！！！<a id="more"></a><br><img src="https://upload-images.jianshu.io/upload_images/10354196-14707d615dd58eed.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="复联4.jpeg"></p>
<p>4.24看完复联4，脑子太多的点化为<strong>爱你三千遍</strong>！</p>
<p>进入今天的正题！！！</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>关于编译JDK，其实在官方的源码包下有个帮助文件（openjdk/common/building.html/md）。这个文件会告诉我们在编译JDK之前需要做的准备以及编译的步骤。具体的大家可以仔细阅读看看。下次只讲述自己这次所编译的过程！</p>
<p>我们需要准备一些东西，首先你需要准备 homebrew，homwbrew是mac下的包管理器，如果你的mac上没有安装，可以按照下面的方式来安装：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby <span class="_">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure></p>
<p>homwbrew下载完成之后，接下来准备编译环境：</p>
<ul>
<li>安装openjdk的版本管理工具mercurial（hg）</li>
<li>安装ccache和freetype，ccache用来加速编译，freetype在编译过程也会依赖到</li>
</ul>
<p>安装脚本为：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install mercurial</span><br><span class="line">brew install ccache</span><br><span class="line">brew install freetype</span><br></pre></td></tr></table></figure></p>
<p>准备好之后就可以开始具体的操作了！</p>
<h1 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h1><h2 id="官方推荐hg"><a href="#官方推荐hg" class="headerlink" title="官方推荐hg"></a>官方推荐hg</h2><p>hg：Mercurial source code management system<br>我为源码专门创建了一个目录 <code>~/jvm</code> ，然后运行下面的命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/jvm</span><br><span class="line">hg <span class="built_in">clone</span> http://hg.openjdk.java.net/jdk9/jdk9 jdk9</span><br></pre></td></tr></table></figure></p>
<p>这条命令运行之后，openjdk的源码并没有下载下来，我们随后进入到<code>~/jvm/jdk9</code>目录，会发现有一个 <code>get_source.sh</code> 的文件，调用这个脚本下载完整的源码之前，需要做一下简单的修改，不然可能你在下载源码的过程中会数次中断。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get clones of all absent nested repositories (harmless if already exist)</span></span><br><span class="line">sh ./common/bin/hgforest.sh <span class="built_in">clone</span> <span class="string">"<span class="variable">$@</span>"</span> || <span class="built_in">exit</span> $?</span><br><span class="line"></span><br><span class="line"><span class="comment"># Update all existing repositories to the latest sources</span></span><br><span class="line">sh ./common/bin/hgforest.sh pull -u</span><br></pre></td></tr></table></figure></p>
<p>我们把上面几行的脚本删掉，替换成下面的脚本：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get clones of all absent nested repositories (harmless if already exist)</span></span><br><span class="line">sh ./common/bin/hgforest.sh <span class="built_in">clone</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ $? <span class="_">-ne</span> 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    sh ./common/bin/hgforest.sh <span class="built_in">clone</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Update all existing repositories to the latest sources</span></span><br><span class="line">sh ./common/bin/hgforest.sh pull -u</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ $? <span class="_">-ne</span> 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    sh ./common/bin/hgforest.sh pull -u</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>然后，愉快地调用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ./get_source.sh</span><br></pre></td></tr></table></figure></p>
<p>本人表示这个这个方法我没有成功，hhh。我在执行<code>hg clone</code> 的时候就一直报网络错误，可能是由于the great wall吧，还好有下面的方法。</p>
<h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. https://github.com/unofficial-openjdk/openjdk/</span><br><span class="line">2. https://github.com/dmlloyd/openjdk</span><br></pre></td></tr></table></figure>
<p>我选择了第二个，切换到了jdk/jdk9分支，因为我们这次要编译jdk9。操作如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/jvm</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/dmlloyd/openjdk.git</span><br><span class="line"><span class="built_in">cd</span> openjdk</span><br><span class="line">git checkout -b jdk9 origin/jdk9/jdk9</span><br></pre></td></tr></table></figure></p>
<p>这个还是挺顺利的，哈哈！</p>
<h1 id="configure"><a href="#configure" class="headerlink" title="configure"></a>configure</h1><p>我们先进行编译前的配置（检查）：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-target-bits=64 --with-freetype=/usr/<span class="built_in">local</span>/Cellar/freetype/2.8.1 --enable-ccache --with-jvm-variants=server,client --with-boot-jdk-jvmargs=<span class="string">"-Xlint:deprecation -Xlint:unchecked"</span> --disable-zip-debug-info --disable-warnings-as-errors --with-debug-level=slowdebug 2&gt;&amp;1 | tee configure_mac_x64.log</span><br></pre></td></tr></table></figure></p>
<p>有日志，出问题查问题也很方便！<br><strong>注意</strong>，上面的freetype，需要替换成本机实际安装的版本</p>
<p>如果出现如下的提示，那么恭喜你，接下来就可以执行编译了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">====================================================</span><br><span class="line">The existing configuration has been successfully updated <span class="keyword">in</span></span><br><span class="line">/Users/rex/jvm/openjdk/build/macosx-x86_64-normal-serverANDclient-slowdebug</span><br><span class="line">using configure arguments <span class="string">'--with-target-bits=64 --with-freetype=/usr/local/Cellar/freetype/2.10.0 --enable-ccache --with-jvm-variants=server,client --with-boot-jdk-jvmargs='</span>-Xlint:deprecation -Xlint:unchecked<span class="string">' --disable-warnings-as-errors --with-debug-level=slowdebug'</span>.</span><br><span class="line"></span><br><span class="line">Configuration summary:</span><br><span class="line">* Debug level:    slowdebug</span><br><span class="line">* HS debug level: debug</span><br><span class="line">* JDK variant:    normal</span><br><span class="line">* JVM variants:   server client</span><br><span class="line">* OpenJDK target: OS: macosx, CPU architecture: x86, address length: 64</span><br><span class="line">* Version string: 9-internal+0-adhoc.rex.openjdk (9-internal)</span><br><span class="line"></span><br><span class="line">Tools summary:</span><br><span class="line">* Boot JDK:       java version <span class="string">"9"</span> Java(TM) SE Runtime Environment (build 9+181) Java HotSpot(TM) 64-Bit Server VM (build 9+181, mixed mode)  (at /Library/Java/JavaVirtualMachines/jdk-9.jdk/Contents/Home)</span><br><span class="line">* Toolchain:      clang (clang/LLVM from Xcode 9.4.1)</span><br><span class="line">* C Compiler:     Version 9.1.0 (at /usr/bin/clang)</span><br><span class="line">* C++ Compiler:   Version 9.1.0 (at /usr/bin/clang++)</span><br><span class="line"></span><br><span class="line">Build performance summary:</span><br><span class="line">* Cores to use:   4</span><br><span class="line">* Memory <span class="built_in">limit</span>:   8192 MB</span><br><span class="line">* ccache status:  Active (3.6)</span><br><span class="line"></span><br><span class="line">NOTE: You have requested to build more than one version of the JVM, <span class="built_in">which</span></span><br><span class="line">will result <span class="keyword">in</span> longer build times.</span><br><span class="line"></span><br><span class="line">WARNING: The result of this configuration has overridden an older</span><br><span class="line">configuration. You *should* run <span class="string">'make clean'</span> to make sure you get a</span><br><span class="line">proper build. Failure to <span class="keyword">do</span> so might result <span class="keyword">in</span> strange build problems.</span><br></pre></td></tr></table></figure></p>
<h1 id="make"><a href="#make" class="headerlink" title="make"></a>make</h1><p>我们执行下面的操作：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=C</span><br><span class="line">make all LOG=debug  2&gt;&amp;1 | tee make_mac_x64.log</span><br></pre></td></tr></table></figure></p>
<p>如果出现如下的提示，那么恭喜你，你的运气太好了！！！<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">----- Build <span class="built_in">times</span> -------</span><br><span class="line">Start 2019-04-25 18:55:19</span><br><span class="line">End   2019-04-25 19:00:57</span><br><span class="line"></span><br><span class="line">00:05:38 TOTAL</span><br><span class="line">-------------------------</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="_">-f</span> /Users/rex/jvm/openjdk/build/macosx-x86_64-normal-serverANDclient-slowdebug/make-support/<span class="built_in">exit</span>-with-error ; <span class="keyword">then</span> \</span><br><span class="line">	    <span class="built_in">exit</span> 1 ; \</span><br><span class="line">	  <span class="keyword">fi</span></span><br><span class="line">/usr/bin/<span class="built_in">printf</span> <span class="string">"Finished building target 'all' in configuration 'macosx-x86_64-normal-serverANDclient-slowdebug'\n"</span> &gt; &gt;(/usr/bin/tee <span class="_">-a</span> /Users/rex/jvm/openjdk/build/macosx-x86_64-normal-serverANDclient-slowdebug/build.log) 2&gt; &gt;(/usr/bin/tee <span class="_">-a</span> /Users/rex/jvm/openjdk/build/macosx-x86_64-normal-serverANDclient-slowdebug/build.log &gt;&amp;2) &amp;&amp; <span class="built_in">wait</span></span><br><span class="line">Finished building target <span class="string">'all'</span> <span class="keyword">in</span> configuration <span class="string">'macosx-x86_64-normal-serverANDclient-slowdebug'</span></span><br></pre></td></tr></table></figure></p>
<p>最后，验证一下<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build/macosx-x86_64-normal-serverANDclient-slowdebug/jdk/bin</span><br><span class="line">./java -version</span><br></pre></td></tr></table></figure></p>
<p>出现下面的提示就完美了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openjdk version <span class="string">"9-internal"</span></span><br><span class="line">OpenJDK Runtime Environment (slowdebug build 9-internal+0-adhoc.rex.openjdk)</span><br><span class="line">OpenJDK 64-Bit Server VM (slowdebug build 9-internal+0-adhoc.rex.openjdk, mixed mode)</span><br></pre></td></tr></table></figure></p>
<h1 id="编译过程中的问题"><a href="#编译过程中的问题" class="headerlink" title="编译过程中的问题"></a>编译过程中的问题</h1><p>根据<strong>墨菲定律</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一、任何事都没有表面看起来那么简单；</span><br><span class="line">二、所有的事都会比你预计的时间长；</span><br><span class="line">三、会出错的事总会出错；</span><br><span class="line">四、如果你担心某种情况发生，那么它就更有可能发生。</span><br></pre></td></tr></table></figure></p>
<p>这个时间会比较长，出错是大概率事件，而我就碰到网上该有的所有错！！！！</p>
<h2 id="Xcode版本问题"><a href="#Xcode版本问题" class="headerlink" title="Xcode版本问题"></a>Xcode版本问题</h2><p>我的Xcode版本原来为10+，XCode升级到10之后, 删除了底层目录下的libstdc++文件。导致在JDK的Make时会报错, 无法识别<new>类似这样的C++语法。而在XCode9时对应文件还是存在的。官方给出的意思是libstdc++已经被标记为过期5年了, 现在统一使用自己libc++。这个问题最简单的问题就是XCode版本回退到9之前即可。<a href="https://developer.apple.com/download/more/" target="_blank" rel="noopener">重新下载地址</a></new></p>
<h2 id="三个空指针转换"><a href="#三个空指针转换" class="headerlink" title="三个空指针转换"></a>三个空指针转换</h2><p>日志被覆盖了，忘记存了，但是可能会出现这样的问题，下面的更改的答案：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1\. src/hotspot/share/memory/virtualspace.cpp # l585</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (base() != NULL) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">#2\. src/hotspot/share/opto/lcm.cpp # l42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Universe::narrow_oop_base() != NULL) &#123; // Implies UseCompressedOops.</span><br><span class="line"></span><br><span class="line"><span class="comment">#3\. src/hotspot/share/opto/loopPredicate.cpp # l915</span></span><br><span class="line"></span><br><span class="line">assert(rng-&gt;Opcode() == Op_LoadRange || iff-&gt;is_RangeCheck() || _igvn.type(rng)-&gt;is_int()-&gt;_lo &gt;= 0, <span class="string">"must be"</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="JVM-crash"><a href="#JVM-crash" class="headerlink" title="JVM crash"></a>JVM crash</h2><p>  自己也忘记截图，所以也盗图了：<br>  <img src="https://upload-images.jianshu.io/upload_images/10354196-b5e7dae0682e7541.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="jvm crash.png"></p>
<p>解决方法：<a href="https://stackoverflow.com/questions/50678467/building-openjdk-9-on-mac-os" target="_blank" rel="noopener">Building OpenJDK 9 on Mac os</a></p>
<p>上面三个问题全被自己遇到了，运气真好，不过走到这里，终于是把JDK编译好了！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>但行好事，莫问前程</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/ee7e9176632c" target="_blank" rel="noopener">mac下编译openjdk1.9及集成clion动态调试</a></li>
<li><a href="https://www.jianshu.com/p/38e697dcbaa5" target="_blank" rel="noopener">MacOS Mojave(10.14)编译openjdk9</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：好像是在大四的时候，自己按照《深入理解Java虚拟机》去编译JDK没有成功！但是在最近经历一些面试之后，感到JVM绝对是面试的一块重点，而看源码绝对是你深入理解JVM的一个很重要的点！在看源码，就需要调试，那么编译自己JDK越是必然的。这次我们在Mac下去编译OpenJDK9！！！
    
    </summary>
    
      <category term="JVM源码" scheme="http://bestlixiang.site/categories/JVM%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="http://bestlixiang.site/2018/12/28/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>http://bestlixiang.site/2018/12/28/分布式/分布式事务/</id>
    <published>2018-12-28T01:15:43.000Z</published>
    <updated>2018-12-27T11:59:10.751Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，事务可以保证一组操作要么全都正确执行，要么全都不执行。目前的数据库只能支持同一个数据库中的事务。但现在的系统往往采用微服务架构，业务系统拥有独立的数据库，因此就出现了跨多个数据库的事务需求，这个时候就需要使用分布式事务啦！<a id="more"></a></p>
<p><img src="https://res.cloudinary.com/cytim/image/upload/v1501433754/simcept/transaction.jpg" alt="tranaction"></p>
<h1 id="什么是分布式事务？"><a href="#什么是分布式事务？" class="headerlink" title="什么是分布式事务？"></a>什么是分布式事务？</h1><p>随着微服务架构的普及，一个大型业务系统往往由若干个子系统构成，这些子系统又拥有各自独立的数据库。往往一个业务流程需要由多个子系统共同完成，而且这些操作可能需要在一个事务中完成。在微服务系统中，这些业务场景是普遍存在的。此时，我们就需要在数据库之上通过某种手段，实现支持跨数据库的事务支持，这就是<strong>分布式事务</strong>。</p>
<p>最典型的分布式事务例子就是用户下单过程，我们按最简单的来说，肯定会有下面两个步骤：</p>
<ol>
<li>用户下单，订单系统会生成一条订单</li>
<li>订单创建成功后，支付系统进行支付</li>
</ol>
<p>上面两个步骤分别是在订单系统和支付系统中完成。以前我们在单机运行的情况下很容易就解决。但是在现在这个微服务架构中，这两个步骤涉及两个系统，涉及两个数据库，此时我们必须在数据库和应用系统之间，通过某项手段，实现分布式事务，要么全都正确执行，要么全都不执行。</p>
<h1 id="分布式事务协议"><a href="#分布式事务协议" class="headerlink" title="分布式事务协议"></a>分布式事务协议</h1><h2 id="两阶段提交协议-2PC"><a href="#两阶段提交协议-2PC" class="headerlink" title="两阶段提交协议 2PC"></a>两阶段提交协议 2PC</h2><p>在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p>
<h3 id="两阶段"><a href="#两阶段" class="headerlink" title="两阶段"></a>两阶段</h3><h4 id="准备阶段（投票阶段）"><a href="#准备阶段（投票阶段）" class="headerlink" title="准备阶段（投票阶段）"></a>准备阶段（投票阶段）</h4><p>事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。</p>
<h4 id="提交阶段（执行阶段）"><a href="#提交阶段（执行阶段）" class="headerlink" title="提交阶段（执行阶段）"></a>提交阶段（执行阶段）</h4><p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</li>
<li>单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</li>
<li>数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</li>
<li>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举</li>
</ol>
<p>由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p>
<h2 id="三阶段提交协议-3PC"><a href="#三阶段提交协议-3PC" class="headerlink" title="三阶段提交协议 3PC"></a>三阶段提交协议 3PC</h2><p>与两阶段提交不同的是，三阶段提交有两个改动点：</p>
<ol>
<li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li>
<li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li>
</ol>
<h3 id="三阶段"><a href="#三阶段" class="headerlink" title="三阶段"></a>三阶段</h3><h4 id="CanCommit阶段"><a href="#CanCommit阶段" class="headerlink" title="CanCommit阶段"></a>CanCommit阶段</h4><ol>
<li>事务询问 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</li>
<li>响应反馈 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No</li>
</ol>
<h4 id="PreCommit阶段"><a href="#PreCommit阶段" class="headerlink" title="PreCommit阶段"></a>PreCommit阶段</h4><p>两种情况：<br><strong>假如协调者从所有的参与者获得的反馈都是Yes响应：</strong></p>
<ol>
<li>发送预提交请求 协调者向参与者发送PreCommit请求，并进入Prepared阶段。</li>
<li>事务预提交 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。</li>
<li>响应反馈 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</li>
</ol>
<p><strong>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后：</strong></p>
<ol>
<li>发送中断请求 协调者向所有参与者发送abort请求。</li>
<li>中断事务 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li>
</ol>
<h4 id="doCommit阶段"><a href="#doCommit阶段" class="headerlink" title="doCommit阶段"></a>doCommit阶段</h4><p>两种情况：<br><strong>协调者接收到参与者发送的ACK响应：</strong></p>
<ol>
<li>发送提交请求 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</li>
<li>事务提交 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</li>
<li>响应反馈 事务提交完之后，向协调者发送Ack响应。</li>
<li>完成事务 协调者接收到所有参与者的ack响应之后，完成事务。</li>
</ol>
<p><strong>协调者没有接收到参与者发送的ACK响应，或者响应超时：</strong></p>
<ol>
<li>发送中断请求 协调者向所有参与者发送abort请求</li>
<li>事务回滚 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</li>
<li>反馈结果 参与者完成事务回滚之后，向协调者发送ACK消息</li>
<li>中断事务 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</li>
</ol>
<h2 id="2PC与3PC的区别"><a href="#2PC与3PC的区别" class="headerlink" title="2PC与3PC的区别"></a>2PC与3PC的区别</h2><p>相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，<strong>因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。</strong> 而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p>
<h1 id="分布式解决方案"><a href="#分布式解决方案" class="headerlink" title="分布式解决方案"></a>分布式解决方案</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当你觉得你的系统中使用<strong>分布式事务</strong>的时候，<strong>你一定要问问自己真的需要吗</strong>?很多时候我们并不需要，也许我们只要将两个微服务聚合成一个单机服务，从而可以使用数据库的本地事务。<strong>因为你只要使用了分布式事务，必然会增加系统的复杂度。</strong> 当然有时候我们是真的需要，下面我们介绍几种常见的方案！</p>
<h2 id="基于XA的分布式事务"><a href="#基于XA的分布式事务" class="headerlink" title="基于XA的分布式事务"></a>基于XA的分布式事务</h2><p><img src="https://pic1.zhimg.com/80/v2-1eb94800ac7dbaa86f103dc9bc7f93a8_hd.jpg" alt="xa"></p>
<p>基于XA的分布式事务其实就是2PC协议的实现。所以它比较简单，成本较低，但是其单点问题，以及不能支持高并发(由于同步阻塞)依然是其最大的弱点。但是Mysql、Oracle都在使用这种方案。</p>
<h2 id="基于消息的最终一致性方案"><a href="#基于消息的最终一致性方案" class="headerlink" title="基于消息的最终一致性方案"></a>基于消息的最终一致性方案</h2><p>这种实现分布式事务的方式需要通过消息中间件来实现。假设有A和B两个系统，分别可以处理任务A和任务B。此时系统A中存在一个业务流程，需要将任务A和任务B在同一个事务中处理。下面来介绍基于消息中间件来实现这种分布式事务。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/10/1620fc30782107d1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="message-commit"></p>
<ol>
<li>在系统A处理任务A前，首先向消息中间件发送一条消息</li>
<li>消息中间件收到后将该条消息持久化，但并不投递。此时下游系统B仍然不知道该条消息的存在。</li>
<li>消息中间件持久化成功后，便向系统A返回一个确认应答；</li>
<li>系统A收到确认应答后，则可以开始处理任务A；</li>
<li>任务A处理完成后，向消息中间件发送Commit请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了，此时它可以处理别的任务了。</li>
<li>但commit消息可能会在传输途中丢失，从而消息中间件并不会向系统B投递这条消息，从而系统就会出现不一致性。这个问题由消息中间件的事务回查机制完成，下文会介绍。</li>
<li>消息中间件收到Commit指令后，便向系统B投递该消息，从而触发任务B的执行；</li>
<li>当任务B执行完成后，系统B向消息中间件返回一个确认应答，告诉消息中间件该消息已经成功消费，此时，这个分布式事务完成。</li>
</ol>
<p>从上面的过程中，我们可以看出：</p>
<ol>
<li>消息中间件扮演者分布式事务协调者的角色。</li>
<li>系统A完成任务A后，到任务B执行完成之间，会存在一定的时间差。在这个时间差内，整个系统处于数据不一致的状态，但这短暂的不一致性是可以接受的，因为经过短暂的时间后，系统又可以保持数据一致性，<strong>满足BASE理论</strong>。</li>
</ol>
<p>上述过程中，如果任务A处理失败，那么需要进入回滚流程，如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/3/10/1620fc307be6c55d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="message-a-rollback"></p>
<ol>
<li>若系统A在处理任务A时失败，那么就会向消息中间件发送Rollback请求。和发送Commit请求一样，系统A发完之后便可以认为回滚已经完成，它便可以去做其他的事情。</li>
<li>消息中间件收到回滚请求后，直接将该消息丢弃，而不投递给系统B，从而不会触发系统B的任务B。</li>
</ol>
<p>上面所介绍的Commit和Rollback都属于理想情况，但在实际系统中，Commit和Rollback指令都有可能在传输途中丢失。那么当出现这种情况的时候，消息中间件是如何保证数据一致性呢？——答案就是超时询问机制。<br><img src="https://user-gold-cdn.xitu.io/2018/3/10/1620fc307c2d185e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="message-b-rollback"></p>
<p>所以系统A除了实现正常的业务流程外，还需提供一个事务询问的接口，供消息中间件调用。当消息中间件收到一条事务型消息后便开始计时，如果到了超时时间也没收到系统A发来的Commit或Rollback指令的话，就会主动调用系统A提供的事务询问接口询问该系统目前的状态。该接口会返回三种结果：</p>
<ul>
<li>提交 若获得的状态是“提交”，则将该消息投递给系统B。</li>
<li>回滚 若获得的状态是“回滚”，则直接将条消息丢弃。</li>
<li>处理中 若获得的状态是“处理中”，则继续等待。</li>
</ul>
<p>上游的的消息投递保证了，那么下游的消息投递的可靠性保证怎么解决呢？</p>
<p>当上游系统执行完任务并向消息中间件提交了Commit指令后，便可以处理其他任务了，此时它可以认为事务已经完成，接下来消息中间件<strong>一定会保证消息被下游系统成功消费掉！</strong>那么这是怎么做到的呢？这由消息中间件的投递流程来保证。<br>消息中间件向下游系统投递完消息后便进入阻塞等待状态，下游系统便立即进行任务的处理，任务处理完成后便向消息中间件返回应答。消息中间件收到确认应答后便认为该事务处理完毕！<br>如果消息在投递过程中丢失，或消息的确认应答在返回途中丢失，那么消息中间件在等待确认应答超时之后就会重新投递，直到下游消费者返回消费成功响应为止。当然，一般消息中间件可以设置消息重试的次数和时间间隔，如果重试多次之后仍然投递失败，那么这条消息就需要人工干预。<br><img src="https://user-gold-cdn.xitu.io/2018/3/10/1620fc3078194980?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="message-0-rollback"><br><img src="https://user-gold-cdn.xitu.io/2018/3/10/1620fc308ece8d2a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="message-1-rollback"></p>
<p>如果消费超时，则需要一直重试，这里就会出现一个问题：<strong>消息接收端需要保证幂等</strong>。这又是另外一个问题，比如使用版本控制。</p>
<p>这里还有一个问题就是，上游系统A向消息中间件提交Commit/Rollback消息采用的是异步方式，消息中间件和下游系统之间为什么要采用同步通信呢？</p>
<ol>
<li>游系统和消息中间件之间采用异步通信是为了提高系统并发度。业务系统直接和用户打交道，用户体验尤为重要，因此这种异步通信方式能够极大程度地降低用户等待时间。此外，异步通信相对于同步通信而言，没有了长时间的阻塞等待，因此系统的并发性也大大增加。但异步通信可能会引起Commit/Rollback指令丢失的问题，这就由消息中间件的超时询问机制来弥补。</li>
<li>消息息中间件和下游系统之间采用同步通信是因为同步虽然降低系统并发度，但实现成本较低。因此，在对并发度要求不是很高的情况下，或者服务器资源较为充裕的情况下，我们可以选择同步来降低系统的复杂度。</li>
</ol>
<h2 id="TCC编程式补偿性事务"><a href="#TCC编程式补偿性事务" class="headerlink" title="TCC编程式补偿性事务"></a>TCC编程式补偿性事务</h2><p><img src="https://img.alicdn.com/tfs/TB1CdK1dKOSBuNjy0FdXXbDnVXa-856-417.png" alt="tcc"></p>
<p>TCC即为<strong>Try Confirm Cancel</strong>，它属于补偿型分布式事务。顾名思义，TCC实现分布式事务一共有三个步骤：</p>
<ol>
<li>Try：尝试待执行的业务<br> 这个过程并未执行业务，只是完成所有业务的一致性检查，并<strong>预留好执行所需的全部资源</strong></li>
<li>Confirm：执行业务<br> 这个过程真正开始执行业务，由于Try阶段已经完成了一致性检查，因此本过程直接执行，而不做任何检查。并且在执行的过程中，会使用到Try阶段预留的业务资源。</li>
<li>Cancel：取消执行的业务<br> 若业务执行失败，则进入Cancel阶段，它会释放所有占用的业务资源，并回滚Confirm阶段执行的操作。</li>
</ol>
<p>就举下单支付的例子：<br>Try：</p>
<ul>
<li>从用户账户扣除100元（预留业务资源）</li>
</ul>
<p>Confirm：</p>
<ul>
<li>订单生成</li>
<li>商户账户增加100元</li>
</ul>
<p>Concel：</p>
<ul>
<li>将用户账户增加100元</li>
<li>将商户账户减去100元</li>
<li>出现任何异常，释放所有占用的业务资源，并回滚Confirm阶段执行的操作。</li>
</ul>
<p>对于TCC来说适合一些:</p>
<ul>
<li>强隔离性，严格一致性要求的活动业务。</li>
<li>执行时间较短的业务</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://juejin.im/post/5aa3c7736fb9a028bb189bca" target="_blank" rel="noopener">常用的分布式事务解决方案</a></li>
<li><a href="https://juejin.im/post/5b5a0bf9f265da0f6523913b" target="_blank" rel="noopener">再有人问你分布式事务，把这篇扔给他</a></li>
<li><a href="http://www.hollischuang.com/archives/681" target="_blank" rel="noopener">关于分布式事务、两阶段提交协议、三阶提交协议</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，事务可以保证一组操作要么全都正确执行，要么全都不执行。目前的数据库只能支持同一个数据库中的事务。但现在的系统往往采用微服务架构，业务系统拥有独立的数据库，因此就出现了跨多个数据库的事务需求，这个时候就需要使用分布式事务啦！
    
    </summary>
    
      <category term="分布式" scheme="http://bestlixiang.site/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式事务" scheme="http://bestlixiang.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://bestlixiang.site/2018/12/27/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://bestlixiang.site/2018/12/27/分布式/分布式锁/</id>
    <published>2018-12-27T05:15:43.000Z</published>
    <updated>2018-12-27T05:16:46.141Z</updated>
    
    <content type="html"><![CDATA[<p>在单机场景下，可以使用语言的内置锁（如JDK中的ReentrantLcok或者synchronized）来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。<a id="more"></a></p>
<p><img src="https://cdn.masterlock.com/masterlock/resources/img/home-sliders/1588D-combinationlock.jpg" alt="lock"></p>
<h1 id="分布式锁性质"><a href="#分布式锁性质" class="headerlink" title="分布式锁性质"></a>分布式锁性质</h1><ol>
<li>获取锁和释放锁的性能要好</li>
<li>判断是否获得锁必须是原子性的，否则可能导致多个请求都获取到锁</li>
<li>网络中断或宕机无法释放锁时，锁必须被清除，不然会发生死锁</li>
<li>可重入获取锁</li>
<li>可以为阻塞锁和非阻塞锁，阻塞锁即没有获取到锁，则继续等待获取锁；非阻塞锁即没有获取到锁后，不继续等待，直接返回锁失败。</li>
</ol>
<h1 id="分布式锁实现方式"><a href="#分布式锁实现方式" class="headerlink" title="分布式锁实现方式"></a>分布式锁实现方式</h1><h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><h3 id="基于MySQL锁表"><a href="#基于MySQL锁表" class="headerlink" title="基于MySQL锁表"></a>基于MySQL锁表</h3><p>该实现方式完全依靠<strong>数据库唯一索引</strong>来实现。当想要获得锁时，即向数据库中插入一条记录，释放锁时就删除这条记录。这种方式存在以下几个问题：</p>
<ol>
<li>锁没有失效时间，解锁失败会导致死锁，其他线程无法再获取到锁，因为唯一索引insert都会返回失败。</li>
<li>只能是非阻塞锁，insert失败直接就报错了，无法进入队列进行重试。</li>
<li>不可重入，同一线程在没有释放锁之前无法再获取到锁。</li>
</ol>
<h3 id="采用乐观锁增加版本号"><a href="#采用乐观锁增加版本号" class="headerlink" title="采用乐观锁增加版本号"></a>采用乐观锁增加版本号</h3><p>根据<strong>版本号字段</strong>来判断更新之前有没有其他线程更新过，如果被更新过，则获取锁失败。</p>
<h2 id="缓存锁"><a href="#缓存锁" class="headerlink" title="缓存锁"></a>缓存锁</h2><p>平时使用的最多的就是redis，这里介绍两种redis的分布式锁。</p>
<h3 id="基于setnx、expire两个命令来实现"><a href="#基于setnx、expire两个命令来实现" class="headerlink" title="基于setnx、expire两个命令来实现"></a>基于setnx、expire两个命令来实现</h3><p>基于setnx（set if not exist）的特点，当缓存里key不存在时，才会去set，否则直接返回false。如果返回true则获取到锁，否则获取锁失败，为了防止死锁，我们再用expire命令对这个key设置一个超时时间来避免。</p>
<p>但是这里看似完美，实则有缺陷，当我们setnx成功后，线程发生异常中断，expire还没来的及设置，那么就会产生死锁。</p>
<p>为了解决上诉问题，我们可以采用redis2.6.12版本以后的set，它提供了一系列选项：</p>
<ul>
<li>EX seconds – 设置键key的过期时间，单位时秒</li>
<li>PX milliseconds – 设置键key的过期时间，单位时毫秒</li>
<li>NX – 只有键key不存在的时候才会设置key的值</li>
<li>XX – 只有键key存在的时候才会设置key的值</li>
</ul>
<h3 id="RedLock算法"><a href="#RedLock算法" class="headerlink" title="RedLock算法"></a>RedLock算法</h3><p>redlock算法是<strong>redis作者推荐</strong>的一种分布式锁实现方式，算法的内容如下：</p>
<ol>
<li>获取当前时间；</li>
<li>尝试从N个相互独立redis客户端获取锁；</li>
<li>计算获取所有锁消耗的时间，当且仅当客户端从多数节点(N/2+1)获取锁，并且获取锁的时间小于锁的有效时间，认为获得锁；</li>
<li>重新计算有效期时间，原有效时间减去获取锁消耗的时间；</li>
<li>删除所有实例的锁</li>
</ol>
<p>redlock算法相对于单节点redis锁可靠性要更高，但是实现起来条件也较为苛刻。</p>
<ol>
<li>必须部署5个节点才能让Redlock的可靠性更强。</li>
<li>需要请求5个节点才能获取到锁，通过Future的方式，先并发向5个节点请求，再一起获得响应结果，能缩短响应时间，不过还是比单节点redis锁要耗费更多时间。</li>
</ol>
<p>然后由于必须获取到5个节点中的3个以上，所以可能出现获取锁冲突，即大家都获得了1-2把锁，结果谁也不能获取到锁，这个问题，redis作者借鉴了raft算法的精髓，通过冲突后在随机时间开始，可以大大降低冲突时间，但是这问题并不能很好的避免，特别是在第一次获取锁的时候，所以获取锁的时间成本增加了。</p>
<p>如果5个节点有2个宕机，此时锁的可用性会极大降低，首先必须等待这两个宕机节点的结果超时才能返回，另外只有3个节点，客户端必须获取到这全部3个节点的锁才能拥有锁，难度也加大了。</p>
<p>如果出现网络分区，那么可能出现客户端永远也无法获取锁的情况，介于这种情况，下面我们来看一种更可靠的分布式锁zookeeper锁。</p>
<h2 id="zookeeper锁"><a href="#zookeeper锁" class="headerlink" title="zookeeper锁"></a>zookeeper锁</h2><h3 id="Zookeeper抽象模型"><a href="#Zookeeper抽象模型" class="headerlink" title="Zookeeper抽象模型"></a>Zookeeper抽象模型</h3><p>Zookeeper 提供了一种树形结构级的命名空间，/app1/p_1 节点的父节点为 /app1。<br><img src="http://s1.51cto.com/oss/201809/12/08308a2ed38371a6fef72f281598b3df.jpg" alt="zookeeper"></p>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><ul>
<li>永久节点：不会因为会话结束或者超时而消失;</li>
<li>临时节点：如何会话结束或者超时就会消失;</li>
<li>有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。</li>
</ul>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。当前zookeeper有如下四种事件：1）节点创建；2）节点删除；3）节点数据修改；4）子节点变更。</p>
<h3 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h3><ol>
<li>创建一个锁目录 /lock；</li>
<li>当一个客户端需要获取锁时，在 /lock 下创建<strong>临时的且有序的</strong>子节点；<br>客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；</li>
<li>执行业务代码</li>
<li>业务代码执行完成后，删除对应的子节点。</li>
</ol>
<p>有些人会在<strong>步骤2中获取子节点列表与设置监听这两步操作的存在原子性问题</strong>，考虑这么个场景：客户端a对应子节点为/lock/lock-0000000000，客户端b对应子节点为/lock/lock-0000000001，客户端b获取子节点列表时发现自己不是序号最小的，但是在设置监听器前客户端a完成业务流程删除了子节点/lock/lock-0000000000，客户端b设置的监听器岂不是丢失了这个事件从而导致永远等待了？这个问题不存在的。<strong>因为zookeeper提供的API中设置监听器的操作与读操作是原子执行的，也就是说在读子节点列表时同时设置监听器，保证不会丢失事件。</strong></p>
<h3 id="羊群效应"><a href="#羊群效应" class="headerlink" title="羊群效应"></a>羊群效应</h3><p>一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应），而我们只希望它的后一个子节点收到通知。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.linkedkeeper.com/detail/blog.action?bid=1023" target="_blank" rel="noopener">浅谈分布式锁</a></li>
<li><a href="http://www.dengshenyu.com/java/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/10/23/zookeeper-distributed-lock.html" target="_blank" rel="noopener">基于Zookeeper的分布式锁</a></li>
<li><a href="https://segmentfault.com/a/1190000012919740#articleHeader5" target="_blank" rel="noopener">基于redis的分布式锁实现</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在单机场景下，可以使用语言的内置锁（如JDK中的ReentrantLcok或者synchronized）来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。
    
    </summary>
    
      <category term="分布式" scheme="http://bestlixiang.site/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式锁" scheme="http://bestlixiang.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>consistent hashing algorithm</title>
    <link href="http://bestlixiang.site/2018/12/27/%E5%88%86%E5%B8%83%E5%BC%8F/consistent%20hashing%20algorithm%20/"/>
    <id>http://bestlixiang.site/2018/12/27/分布式/consistent hashing algorithm /</id>
    <published>2018-12-26T23:14:13.000Z</published>
    <updated>2018-12-26T12:04:02.312Z</updated>
    
    <content type="html"><![CDATA[<p>引：在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这时候一致性哈希算法就站出来了！<a id="more"></a></p>
<p><img src="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1545823709&amp;di=7aa416e5d990fbc2bf752ec187f3932a&amp;src=http://b-ssl.duitang.com/uploads/item/201702/26/20170226001149_Jxmeh.jpeg" alt="curry"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>一致性hash算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性hash修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。 </p>
<h1 id="四个定义"><a href="#四个定义" class="headerlink" title="四个定义"></a>四个定义</h1><p>了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：</p>
<h2 id="平衡性-Balance"><a href="#平衡性-Balance" class="headerlink" title="平衡性(Balance)"></a>平衡性(Balance)</h2><p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p>
<h2 id="单调性-Monotonicity"><a href="#单调性-Monotonicity" class="headerlink" title="单调性(Monotonicity)"></a>单调性(Monotonicity)</h2><p><strong>单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中，哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</strong></p>
<h2 id="分散性-Spread"><a href="#分散性-Spread" class="headerlink" title="分散性(Spread)"></a>分散性(Spread)</h2><p>在分布式环境中，当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的。</p>
<h2 id="负载均衡-Load"><a href="#负载均衡-Load" class="headerlink" title="负载均衡(Load)"></a>负载均衡(Load)</h2><p>负载均衡实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的。</p>
<h1 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h1><h2 id="环形Hash空间"><a href="#环形Hash空间" class="headerlink" title="环形Hash空间"></a>环形Hash空间</h2><p>按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即0~(2\^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图：<br><img src="https://img-blog.csdn.net/20140411000507734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="ring"></p>
<h2 id="数据映射到环上"><a href="#数据映射到环上" class="headerlink" title="数据映射到环上"></a>数据映射到环上</h2><p>现在我们将object1、object2、object3、object4四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。如下图:<br><img src="https://img-blog.csdn.net/20140411000620656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="data-ring"></p>
<h2 id="机器映射到环上"><a href="#机器映射到环上" class="headerlink" title="机器映射到环上"></a>机器映射到环上</h2><p>现在我们将NODE1，NODE2，NODE3三台机器，通过Hash算法得到对应的KEY值，映射到环中，如下图：<br><img src="https://img-blog.csdn.net/20140411000853609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="mechine-ring"></p>
<h1 id="性质维护"><a href="#性质维护" class="headerlink" title="性质维护"></a>性质维护</h1><p>通过hash函数满足分散性和负载均衡是显而易见的，下面我们重点分析单调性和平衡性。</p>
<h2 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h2><p>我们看下面两种情况：</p>
<h3 id="机器的添加"><a href="#机器的添加" class="headerlink" title="机器的添加"></a>机器的添加</h3><p>如果往集群中添加一个新的节点NODE4，通过对应的哈希算法得到KEY4，并映射到环中，如下图<br><img src="https://img-blog.csdn.net/20140411001211062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="machine-add"><br>按照往顺时针迁移的规则，那么object2将被迁移到了NODE4中，其它对象还保持这原有的存储位置。</p>
<h3 id="机器的删除"><a href="#机器的删除" class="headerlink" title="机器的删除"></a>机器的删除</h3><p>如果NODE2因为故障被删除了，如下图：<br><img src="https://img-blog.csdn.net/20140411001033656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="machine-remove"><br>按照往顺时针迁移的规则，object3将会被迁移到NODE3中，这样仅仅是object3的映射位置发生了变化，其它的对象没有任何的改动。</p>
<p>通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，数据的迁移量达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</p>
<h2 id="平衡性"><a href="#平衡性" class="headerlink" title="平衡性"></a>平衡性</h2><p>如果上面只部署了NODE1和NODE3两个节点，object1存储到了NODE1中，而object2、object3、object4都存储到了NODE3中，这样就照成了<strong>非常不平衡</strong>的状态。在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点。</p>
<p><strong>虚拟节点：</strong> 是实际节点（机器）在 hash 空间的复制品（ replica ），一实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值均匀排列。</p>
<p>现在我们以2个副本（复制个数）为例，这样整个hash环中就存在了4个虚拟节点，最后对象映射的关系图如下：<br><img src="https://img-blog.csdn.net/20140411001433375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="machine-replica"></p>
<p>根据上图可知对象的映射关系：object1-&gt;NODE1-1，object2-&gt;NODE1-2，object3-&gt;NODE3-2，object4-&gt;NODE3-1。通过虚拟节点的引入，对象的分布就比较均衡了。那么在实际操作中，正真的对象查询是如何工作的呢？对象从hash到虚拟节点到实际节点的转换如下图：<br><img src="https://img-blog.csdn.net/20140411001540656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="vitualNode-mapping"></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>可以看一下参考2。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/cywosp/article/details/23397179" target="_blank" rel="noopener">每天进步一点点——五分钟理解一致性哈希算法(consistent hashing)</a> 原图戳着！！！</li>
<li><a href="https://www.cnblogs.com/xrq730/p/5186728.html" target="_blank" rel="noopener">对一致性Hash算法，Java代码实现的深入研究</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这时候一致性哈希算法就站出来了！
    
    </summary>
    
      <category term="分布式" scheme="http://bestlixiang.site/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="consistent hashing algorithm" scheme="http://bestlixiang.site/tags/consistent-hashing-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Raft算法</title>
    <link href="http://bestlixiang.site/2018/12/26/%E5%88%86%E5%B8%83%E5%BC%8F/Raft%E7%AE%97%E6%B3%95/"/>
    <id>http://bestlixiang.site/2018/12/26/分布式/Raft算法/</id>
    <published>2018-12-26T13:14:13.000Z</published>
    <updated>2018-12-26T11:31:52.151Z</updated>
    
    <content type="html"><![CDATA[<p>引：占坑！！！！ 不同于Paxos算法直接从分布式一致性问题出发推导出来，Raft算法则是从多副本状态机的角度提出，用于管理多副本状态机的日志复制。自己目前也理解得还不透彻，所以留下链接，待后续加深理解之后再做整理。<a id="more"></a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">Raft: Understandable Distributed Consensus</a></li>
<li><a href="https://www.jianshu.com/p/096ae57d1fe0" target="_blank" rel="noopener">Raft一致性算法笔记</a></li>
<li><a href="https://www.jianshu.com/p/1f5cb602dc71" target="_blank" rel="noopener">分布式系统学习2-Raft算法分析与实现</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32052223" target="_blank" rel="noopener">Raft算法详解</a> [可以继续看他的相关博客]</li>
<li><a href="https://github.com/wenweihu86/raft-java" target="_blank" rel="noopener">raft-java</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：占坑！！！！ 不同于Paxos算法直接从分布式一致性问题出发推导出来，Raft算法则是从多副本状态机的角度提出，用于管理多副本状态机的日志复制。自己目前也理解得还不透彻，所以留下链接，待后续加深理解之后再做整理。
    
    </summary>
    
      <category term="分布式" scheme="http://bestlixiang.site/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Raft" scheme="http://bestlixiang.site/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>Paxos算法</title>
    <link href="http://bestlixiang.site/2018/12/26/%E5%88%86%E5%B8%83%E5%BC%8F/Paxos%E7%AE%97%E6%B3%95/"/>
    <id>http://bestlixiang.site/2018/12/26/分布式/Paxos算法/</id>
    <published>2018-12-26T10:14:13.000Z</published>
    <updated>2018-12-26T10:17:51.929Z</updated>
    
    <content type="html"><![CDATA[<p>引：占坑！！！！ Paxos算法在分布式领域具有非常重要的地位。Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。自己理解得还不透彻，所以留下链接，待后续加深理解之后再做整理。<a id="more"></a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>倪超. 从 Paxos 到 ZooKeeper : 分布式一致性原理与实践 [M]. 电子工业出版社, 2015.</li>
<li><a href="https://angus.nyc/2012/paxos-by-example/" target="_blank" rel="noopener">Paxos By Example</a></li>
<li><a href="https://www.cnblogs.com/linbingdong/p/6253479.html" target="_blank" rel="noopener">分布式系列文章——Paxos算法原理与推导</a></li>
<li><a href="https://github.com/luohaha/MyPaxos" target="_blank" rel="noopener">MyPaxos</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：占坑！！！！ Paxos算法在分布式领域具有非常重要的地位。Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。自己理解得还不透彻，所以留下链接，待后续加深理解之后再做整理。
    
    </summary>
    
      <category term="分布式" scheme="http://bestlixiang.site/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Paxos" scheme="http://bestlixiang.site/tags/Paxos/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统基础</title>
    <link href="http://bestlixiang.site/2018/12/26/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <id>http://bestlixiang.site/2018/12/26/分布式/分布式系统基础/</id>
    <published>2018-12-26T02:25:37.000Z</published>
    <updated>2018-12-26T06:08:14.367Z</updated>
    
    <content type="html"><![CDATA[<p>引：自己这一段时间都在学习分布式系统相关的东西，但是都不成系统，所以这里将会总结目前学习的分布式系统相关内容，这里讲会总结分布式系统的相关概念，持续更新…。<a id="more"></a></p>
<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p>2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。</p>
<p>CAP理论为：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p>
<p>下面举个例子：</p>
<p>假设有两台机器A、B，两者之间互相同步保持数据的一致性。现在B由于网络原因不能与A通信(Network Partition)，假设某个client向A写入数据，现在有两种选择：</p>
<ul>
<li>A拒绝写入，这样能保证与B的一致性，但是牺牲了可用性</li>
<li>A允许写入，但是这样就不能保证与B的一致性了</li>
</ul>
<p>Network Partition是必然的，网络非常可能出现问题（断线、超时），因此CAP理论一般只能AP或CP，而CA一般较难实现。</p>
<ul>
<li>CP: 要实现一致性，则需要一定的一致性算法，一般是基于多数派表决的，如Paxos和Raft</li>
<li>AP: 要实现可用性，则要有一定的策略决议到底用哪个数据，并且数据一般要进行冗余备份(replication)</li>
</ul>
<p>当然，在上面的例子中，A可以先允许写入，等B的网络恢复以后再同步至B（根据CAP原理这样不能保证强一致性了，但是可以考虑实现<strong>最终一致性</strong>）。</p>
<p>下图刚好展示了CA,CP,AP系统是如何实现的：</p>
<p><img src="http://book.mixu.net/distsys/images/CAP.png" alt="CAP"></p>
<ul>
<li>利用2PC协议属于CA，如，mysql等，他们主要通过复制的方式来保证数据的安全性。</li>
<li>利用Gossip协议属于AP，如，redis-cluster、cassandra，Eureka他们是通过实现“最终一致性”来保证AP。</li>
<li>利用Paxos协议属于CP，如redis（多master），hbase，这些数据库集群，节点有可能会因为无法确保数据的一致性而拒绝提供服务。</li>
</ul>
<h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><p>BASE理论是由eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。</p>
<p>BASE理论为：基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。</p>
<h2 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h2><p>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</p>
<p>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</p>
<h2 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h2><p>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。</p>
<p>分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。</p>
<h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p>
<h2 id="ACID和BASE的区别与联系"><a href="#ACID和BASE的区别与联系" class="headerlink" title="ACID和BASE的区别与联系"></a>ACID和BASE的区别与联系</h2><p>ACID是传统数据库常用的设计理念，追求<strong>强一致性模型</strong>。</p>
<p>BASE支持的是大型分布式系统，牺牲掉对一致性的约束（但实现<strong>最终一致性</strong>），来换取一定的可用性。</p>
<p>ACID和BASE代表了两种截然相反的设计哲学。</p>
<p>在英文中，ACID和BASE分别是“酸”和“碱”，看似对立，实则是分别对CAP三特性的不同取舍。在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此ACID和BASE又会结合使用。</p>
<h1 id="FLP-Impossibility"><a href="#FLP-Impossibility" class="headerlink" title="FLP Impossibility"></a>FLP Impossibility</h1><h1 id="Lease机制"><a href="#Lease机制" class="headerlink" title="Lease机制"></a>Lease机制</h1><h1 id="Quorum机制"><a href="#Quorum机制" class="headerlink" title="Quorum机制"></a>Quorum机制</h1><h1 id="Consensus问题"><a href="#Consensus问题" class="headerlink" title="Consensus问题"></a>Consensus问题</h1><h1 id="时序问题"><a href="#时序问题" class="headerlink" title="时序问题"></a>时序问题</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.sczyh30.com/posts/Distributed-System/distributed-system-base/#%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">分布式系统基础总结</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/35608244" target="_blank" rel="noopener">分布式系统中的FLP不可能原理、CAP理论与BASE理论</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：自己这一段时间都在学习分布式系统相关的东西，但是都不成系统，所以这里将会总结目前学习的分布式系统相关内容，这里讲会总结分布式系统的相关概念，持续更新…。
    
    </summary>
    
      <category term="分布式" scheme="http://bestlixiang.site/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://bestlixiang.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mac版百度网盘飞速下载</title>
    <link href="http://bestlixiang.site/2018/10/31/%E5%B7%A5%E5%85%B7/Mac%E7%89%88%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E9%A3%9E%E9%80%9F%E4%B8%8B%E8%BD%BD/"/>
    <id>http://bestlixiang.site/2018/10/31/工具/Mac版百度网盘飞速下载/</id>
    <published>2018-10-31T00:17:46.000Z</published>
    <updated>2018-10-31T00:21:36.636Z</updated>
    
    <content type="html"><![CDATA[<p>引：百度网盘上有很多资源，之前在Mac上一直没有找到好的加速方法或者破解软件，这次终于找到了，请速速戳进来！！<a id="more"></a></p>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/proxyee-down-org/proxyee-down" target="_blank" rel="noopener">Proxyee Down</a></p>
<p>Proxyee Down 是一款开源的免费 HTTP 高速下载器，底层使用<code>netty</code>开发，支持自定义 HTTP 请求下载且支持扩展功能，可以通过安装扩展实现特殊的下载需求。</p>
<h1 id="最近视频教程"><a href="#最近视频教程" class="headerlink" title="最近视频教程"></a>最近视频教程</h1><p>以后也可能就不新了！！</p>
<p><a href="https://www.youtube.com/watch?v=ecZqKGaKIck" target="_blank" rel="noopener">快快保存，2018最新百度云不限制方法proxyee down-2018.9.19，亲测速度达10M</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：百度网盘上有很多资源，之前在Mac上一直没有找到好的加速方法或者破解软件，这次终于找到了，请速速戳进来！！
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JDK源码分析——ReentrantReadWriteLock</title>
    <link href="http://bestlixiang.site/2018/09/13/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ReentrantReadWriteLock/"/>
    <id>http://bestlixiang.site/2018/09/13/JDK源码分析/JDK源码分析——ReentrantReadWriteLock/</id>
    <published>2018-09-13T06:51:39.000Z</published>
    <updated>2018-09-13T10:15:06.003Z</updated>
    
    <content type="html"><![CDATA[<p>引：读写分离是解决并发瓶颈的常用策略，在Java中也有其实现——ReentrantReadWriteLock，它能够有效的提高读比写多的场景下的程序性能。<a id="more"></a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>ReentrantReadWriteLock是通过两把锁实现读写分离的，分别是读锁和写锁。它的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="comment">// 写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    <span class="comment">// 同步器</span></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></figure></p>
<h1 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h1><p>写锁主要是通过重写同步器的tryAcquire和tryRelease实现，其他逻辑都可以参考AQS的解析。</p>
<h2 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 重入最大次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 独占锁（写锁）掩码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 用 state &amp; 65535 得到低 16 位的值</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">// 如果 state 不是0，且低16位是0，说明写锁是空闲的，读锁被霸占了。那么也不能拿锁，返回 fasle。保证了读的时候不能写。</span></span><br><span class="line">        <span class="comment">// 如果低 16 位不是0，说明写锁被霸占了，此时如果持有锁的不是当前线程，那么这次拿锁是失败的。返回 fasle。</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 这里时候应该是写重入锁，如果写重入次数超过最大值 65535，就会溢出</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// writerShouldBlock 判断是否应该阻塞</span></span><br><span class="line">    <span class="comment">// 1. 公平锁情况下，如果队列中有等待锁的线程，则返回ture，应该阻塞</span></span><br><span class="line">    <span class="comment">// 2. 非公平锁情况下，返回false，不应该阻塞，直接参与竞争</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 竞争到锁，设置独占线程</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 设置state状态</span></span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="comment">// 计算写锁的状态（低16位），如果是0，说明是否成功</span></span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h1><p>写锁主要是通过重写同步器的tryAcquireShared和tryReleaseShared实现，其他逻辑都可以参考AQS的解析。</p>
<h2 id="tryAcquireShared"><a href="#tryAcquireShared" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync</span></span><br><span class="line"><span class="comment">// 共享（读锁）重入次数基数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="comment">// 第一个获得读锁的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 第一个获得读锁的线程的重入次数计数器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"><span class="comment">// 最后一个获取读锁的线程的计数器，存放在ThreadLocal中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 用 state &amp; 65535 得到低 16 位的值 不等于0，写锁被霸占了</span></span><br><span class="line">    <span class="comment">// 且</span></span><br><span class="line">    <span class="comment">// 持有锁的不是当前线程</span></span><br><span class="line">    <span class="comment">// 保证了写的时候不能读</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="comment">// 获取锁失败</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果写锁没有被霸占，则将高16位移到低16位</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">// readerShouldBlock判断是否应该阻塞 和写锁逻辑一致</span></span><br><span class="line">    <span class="comment">// 写锁重入次数不超过最大值 65535</span></span><br><span class="line">    <span class="comment">// 设置state成功 (相当于高16位加1)</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="comment">// 读锁空闲</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            <span class="comment">// 计数器为1</span></span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 第一个读线程是当前线程</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 计数器加1</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="comment">// 如果最后一个线程计数器是 null 或者不是当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                <span class="comment">// 新建一个 HoldCounter 对象</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="comment">// 如果不是 null，且 count 是 0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 就将上个线程的 HoldCounter 覆盖本地的（性能考虑，相当于缓存）</span></span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            <span class="comment">// 计数器加1</span></span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死循环获取读锁，和tryReleaseShared逻辑类似，只有多了死循环</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>在tryAcquireShared还体现了锁降级的概念。概念如下：</p>
<p><strong><br>重入还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不可能的。</strong></p>
<p>体现在代码中如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tryAcquireShared 或者 fullTryAcquireShared中</span></span><br><span class="line"><span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码就体现出：当写锁被持有的时候，如果当前是线程是持有写锁的那个线程，可以继续获得读锁。</p>
<p>总得来说就提高了性能。</p>
<h2 id="tryReleaseShared"><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前线程重入次数计数器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 如果是第一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// 如果是 1，将第一个线程设置成 null</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果不是 1，减一操作</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    <span class="comment">// 如果不是当前线程</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="comment">// 如果最后一个线程计数器是 null 或者缓存所属线程不是当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            <span class="comment">// 获取当前线程的计数器</span></span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="comment">// 如果计数器小于等于一，就直接删除计数器</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对计数器减一</span></span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死循环使用 CAS 修改状态</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// 修改成功后，如果是 0，表示读锁和写锁都空闲，则可以唤醒后面的等待线程</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于读写锁，它其实就是一个读锁一个写锁，读锁是共享的，写锁是独占的。然后我们再理解锁降级的相关概念就行了，当然这一切都是需要建立在读AQS的理解之上。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://todorex.com/2018/09/11/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94AbstractQueuedSynchronizer/" target="_blank" rel="noopener">JDK源码分析——AbstractQueuedSynchronizer</a></li>
<li><a href="https://www.jianshu.com/p/6221746fc777" target="_blank" rel="noopener">并发编程之——写锁源码分析</a></li>
<li><a href="https://www.jianshu.com/p/cd485e16456e" target="_blank" rel="noopener">并发编程之——读锁源码分析(解释关于锁降级的争议)</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：读写分离是解决并发瓶颈的常用策略，在Java中也有其实现——ReentrantReadWriteLock，它能够有效的提高读比写多的场景下的程序性能。
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="锁" scheme="http://bestlixiang.site/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析——ReentrantLock</title>
    <link href="http://bestlixiang.site/2018/09/13/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ReentrantLock/"/>
    <id>http://bestlixiang.site/2018/09/13/JDK源码分析/JDK源码分析——ReentrantLock/</id>
    <published>2018-09-13T02:13:39.000Z</published>
    <updated>2018-09-13T06:15:42.266Z</updated>
    
    <content type="html"><![CDATA[<p>引：虽然有了synchronized这种内置的锁功能，但是在JDK5之后又新增了Lock接口，它的实现类可比内置的锁强大多了。今天我们主要看看它的实现类之一ReentrantLock。<a id="more"></a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>在看之前，我们一定要对AbstractQueuedSynchronizer熟悉，不熟悉的可以参考我这篇文章——<a href="http://todorex.com/2018/09/11/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94AbstractQueuedSynchronizer/" target="_blank" rel="noopener">JDK源码分析——AbstractQueuedSynchronizer</a></p>
<p>我们先看看他的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 同步器(可选择公平同步器或者非公平同步器)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fair为true时，采用公平锁策略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;    </span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同步器抽象类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 非公平的TryAcquire</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 为0，则可获得锁，进行CAS操作设置state，并设置当前线程为独占线程</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重入锁的体现</span></span><br><span class="line">        <span class="comment">// 如果当前线程为独占线程，则可重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// 重入次数增加</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 截取释放次数</span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 重入次数要减到0，才是真正得释放了锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 维护了一个条件队列</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h1><p>公平锁是指如果同步器的队列中有线程在等待，后来的线程则直接加入到队列中<br>公平同步器实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// AQS分析逻辑</span></span><br><span class="line">      acquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 公平实现</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">      <span class="keyword">int</span> c = getState();</span><br><span class="line">      <span class="comment">// 可获得锁</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果同步器的队列中没有线程在等待 或者 CAS成功 或者设置独占线程成功</span></span><br><span class="line">          <span class="comment">// 公平的体现</span></span><br><span class="line">          <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">              compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">              setExclusiveOwnerThread(current);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 可重入</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">          <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">          <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">          setState(nextc);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h1><p>非公平锁是指后来的线程也有同样的优先级。</p>
<p>非公平同步器实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用CAS把state从0设置为1</span></span><br><span class="line">        <span class="comment">// 成功则获得锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 进入AQS分析逻辑</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非公平获取</span></span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="条件变量Condition"><a href="#条件变量Condition" class="headerlink" title="条件变量Condition"></a>条件变量Condition</h1><p>Synchronized中，所有的线程都在同一个object的条件队列上等待。而ReentrantLock中，每个condition都维护了一个条件队列。我们先看看在同步器定义的ConditionObject对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 条件队列的头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">// 条件队列的尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们关注它的两个核心方法(条件变量Condition为了解决Object.wait/notify/notifyAll难以使用的问题)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>阻塞线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果线程被中断，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 1. 将线程添加到条件等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 2. 释放持有的锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 是否在AQS的同步队列中</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 3. 不是则挂起该线程</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 被唤醒后，通过acquireQueued方法重新竞争锁，参考AQS</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 清理取消节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 报告中断信息</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 将线程添加到条件等待队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// 如果最后一个节点是取消状态</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 从队列删除取消节点</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程包装成节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 释放持有的锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记是否失败，失败则将节点设为取消状态</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// release可以参考AQS的解析</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h2><p>唤醒线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程是否持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 找到底部个非取消节点，遇到取消节点就进行删除</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将状态设置为0，不行就取消该节点</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 将节点放入到同步队列中</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">// 唤醒线程</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ReetrantLock还提供了其它功能，包括定时的锁等待、可中断的锁等待、公平性、以及实现非块结构的加锁、Condition，对线程的等待和唤醒等操作更加灵活。但是内置锁（Synchronized）与ReentrantLock相比有例外一个优点就是在线程转储中能给出在哪些调用帧中获得了哪些锁，并能够检测和识别发生死锁的线程。因为Reentrant的非块状特性意味着获取锁的操作不能与特定的栈帧关联起来。相比之下内置锁是JVM的内置属性，所以未来更可能提升synchronized而不是ReentrantLock的性能，而照目前的趋势来看确实如此。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://todorex.com/2018/09/11/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94AbstractQueuedSynchronizer/" target="_blank" rel="noopener">JDK源码分析——AbstractQueuedSynchronizer</a></li>
<li><a href="https://www.jianshu.com/p/4358b1466ec9" target="_blank" rel="noopener">深入浅出ReentrantLock</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：虽然有了synchronized这种内置的锁功能，但是在JDK5之后又新增了Lock接口，它的实现类可比内置的锁强大多了。今天我们主要看看它的实现类之一ReentrantLock。
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="锁" scheme="http://bestlixiang.site/tags/%E9%94%81/"/>
    
  </entry>
  
</feed>
