<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rex note</title>
  <subtitle>雨过，云过</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bestlixiang.site/"/>
  <updated>2018-05-03T06:09:29.000Z</updated>
  <id>http://bestlixiang.site/</id>
  
  <author>
    <name>rex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HelloWorld_Shiro Activity</title>
    <link href="http://bestlixiang.site/2018/05/03/HelloWorld/HelloWorld-Shiro-Activity/"/>
    <id>http://bestlixiang.site/2018/05/03/HelloWorld/HelloWorld-Shiro-Activity/</id>
    <published>2018-05-03T06:08:03.000Z</published>
    <updated>2018-05-03T06:09:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：记得去年暑假要弄工作流Activity没有弄出来，这次刚好看到了一个基于Shiro和Activity的考勤项目，就想写一下了！<a id="more"></a></p>
<h1 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h1><ol>
<li>前端模板引擎：Velocity（不做重点讲解，它的页面主要使用的BootStrap的Admin开源框架）</li>
<li>后台：SSM框架</li>
<li>任务调度框架：Quartz</li>
<li>工作流引擎：Activity</li>
<li>权限控制框架：Shiro</li>
</ol>
<h1 id="项目功能"><a href="#项目功能" class="headerlink" title="项目功能"></a>项目功能</h1><ol>
<li>利用Shiro实现登录模块并实现权限控制</li>
<li>实现查看出勤记录</li>
<li>利用Quartz实现定时任务，每天凌晨扫描没有打卡记录的员工并记录</li>
<li>利用Activity实现补签流程</li>
</ol>
<h1 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h1><p><a href="https://github.com/todorex/Shiro_Activity_WorkAttendance" target="_blank" rel="external">HelloWorld_Shiro Activity 之 WorkAttendance考勤项目</a></p>
<h1 id="重点源码说明"><a href="#重点源码说明" class="headerlink" title="重点源码说明"></a>重点源码说明</h1><h2 id="利用Shiro实现登录与权限控制"><a href="#利用Shiro实现登录与权限控制" class="headerlink" title="利用Shiro实现登录与权限控制"></a>利用Shiro实现登录与权限控制</h2><p>我们这里主要利用了Shiro来进行登录验证，我们可以先看看Shiro架构，如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/helloworld/jpg/shiro.jpg" alt="shiro"></p>
<ol>
<li>Subject主要是存储了访问信息</li>
<li>SecurityManager是Shiro的核心，他主要用于协调Shiro内部各种安全组件</li>
<li>Realm用于连接Shiro和客户系统的用户数据的桥梁。一旦Shiro真正需要访问各种安全相关的数据（比如使用用户账户来做用户身份验证以及权限验证）时，他总是通过调用系统配置的各种Realm来读取数据，可以对比为SpringSecurity的Provider。</li>
</ol>
<p>Shrio配置文件主要是WorkAttendance/src/main/resources/spring-shiro.xml，在配置文件中，我们除了配置Realm和SecurityManager，还要配置一个ShiroFilter过滤链，这个过滤链主要配置要拦截或者忽略的路径，可以对比为SpringSecurity的配置类WebSecurityConfigurerAdapter。当然我们也可以使用注解来实现路径权限控制，如: <em>@RequiresPermissions(“attend:attendList”)</em></p>
<p>我们看看登录源代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LoginController的验证登录的方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">checkLogin</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> UnsupportedEncodingException, NoSuchAlgorithmException </span>&#123;</div><div class="line">    String username = request.getParameter(<span class="string">"username"</span>);</div><div class="line">    String pwd = request.getParameter(<span class="string">"password"</span>);</div><div class="line">    <span class="comment">// 组装成Token给Realm使用</span></div><div class="line">    UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username,pwd);</div><div class="line">    <span class="comment">// 等到登录访问信息</span></div><div class="line">    Subject subject = SecurityUtils.getSubject();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 进入Realm进行认证</span></div><div class="line">        subject.login(token);</div><div class="line">        <span class="comment">// 设置session过期时间</span></div><div class="line">        SecurityUtils.getSubject().getSession().setTimeout(<span class="number">1800000</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"login_fail"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">"login_succ"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 自定义的Realm</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserService userService;</div><div class="line"></div><div class="line"><span class="comment">//    授权</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</div><div class="line">        <span class="comment">// PrincipalCollection,可以理解身份上下文</span></div><div class="line">        String username = (String) principalCollection.getPrimaryPrincipal();</div><div class="line">        User user = userService.findUserByUserName(username);</div><div class="line">        SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</div><div class="line">        <span class="keyword">for</span>(Role role :user.getRoleList())&#123;</div><div class="line">            authorizationInfo.addRole(role.getRole());</div><div class="line">            <span class="keyword">for</span>(Permission permission :role.getPermissionList())&#123;</div><div class="line">                authorizationInfo.addStringPermission(permission.getPermission());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> authorizationInfo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//    登入验证</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        <span class="comment">// UsernamePasswordToken封装了用户名和密码</span></div><div class="line">        UsernamePasswordToken usernamePasswordToke = (UsernamePasswordToken)authenticationToken;</div><div class="line">        String username =  usernamePasswordToke.getUsername();</div><div class="line">        User user = userService.findUserByUserName(username);</div><div class="line">        <span class="keyword">if</span>(user==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 会使用自定义的账号密码校验器进行验证，并返回AuthenticationInfo</span></div><div class="line">            AuthenticationInfo info = <span class="keyword">new</span> SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), getName());</div><div class="line">            SecurityUtils.getSubject().getSession().setAttribute(<span class="string">"userInfo"</span>,user);</div><div class="line">            <span class="keyword">return</span> info;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 自定义的密码验证器，配置文件中配置</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCredentialsMatcher</span> <span class="keyword">extends</span> <span class="title">SimpleCredentialsMatcher</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doCredentialsMatch</span><span class="params">(AuthenticationToken authenticationToken, AuthenticationInfo authenticationInfo)</span> </span>&#123;</div><div class="line">        <span class="comment">// 对比用户登入的数据与数据库查询出来的信息</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) authenticationToken;</div><div class="line">            <span class="comment">// 用户登录的密码</span></div><div class="line">            String password = String.valueOf(usernamePasswordToken.getPassword());</div><div class="line">            Object tokenCredentials = MD5Utils.encryptPassword(password);</div><div class="line">            <span class="comment">// getCredentials()和equals都是SimpleCredentialsMatcher自带的方法</span></div><div class="line">            Object acountCredentials = getCredentials(authenticationInfo);</div><div class="line">            <span class="keyword">return</span> equals(tokenCredentials,acountCredentials);</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="利用Quartz实现定时任务"><a href="#利用Quartz实现定时任务" class="headerlink" title="利用Quartz实现定时任务"></a>利用Quartz实现定时任务</h2><p>它的核心元素关系图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/helloworld/jpg/quartz.jpg" alt="quartz"></p>
<p>它的配置文件在WorkAttendance/src/main/resources/spring-job.xml，我们也主要就是配置SchedulerFactory，Trigger和Job。里面关于cronExpression可以使用<a href="http://cron.qqe2.com/" target="_blank" rel="external">在线Cron表达式生成器</a>来确定或者书写。</p>
<p>我们看看定时任务的源代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 其实很简单，因为我们在配置文件中以及配置好要触发的类和方法了</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttendCheckTask</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> AttendService attendService;</div><div class="line">    <span class="comment">// JobMethod</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkAttend</span><span class="params">()</span> </span>&#123;</div><div class="line">        attendService.checkAttend();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="利用Activity实现补签流程"><a href="#利用Activity实现补签流程" class="headerlink" title="利用Activity实现补签流程"></a>利用Activity实现补签流程</h2><p>它的配置文件主要在WorkAttendance/src/main/resources/spring-activity.xml，我们主要就是配置processEngineFactory，processEngineConfiguration（会设置自动建表23张以及要部署的流程资源）以及各个服务类。</p>
<p>关于流程资源我们可以利用IDEA的<strong>actiBPM插件</strong>去画这个流程图，需要注意的是设置好各个ID，因为我们后面需要用到它。</p>
<p>接下来我们看看它的核心代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 开始流程并提交任务</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startReAttendFlow</span><span class="params">(ReAttend reAttend)</span> </span>&#123;</div><div class="line">    <span class="comment">// 从公司组织架构中，查询到此人上级领导人用户名</span></div><div class="line">    <span class="comment">// 这里手动设置</span></div><div class="line">    reAttend.setCurrentHandler(<span class="string">"rex666"</span>);</div><div class="line">    reAttend.setStatus(RE_ATTEND_STATUS_ONGOING);</div><div class="line">    <span class="comment">// 插入数据库补签表(ID自增)</span></div><div class="line">    reAttendMapper.insertSelective(reAttend);</div><div class="line">    <span class="comment">// 将一些需要的参数放入流程中传递，即Variables</span></div><div class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line">    map.put(RE_ATTEND_SIGN, reAttend);</div><div class="line">    <span class="comment">// 后面需要根据流程中的变量名来获取</span></div><div class="line">    map.put(NEXT_HANDLER, reAttend.getCurrentHandler());</div><div class="line">    <span class="comment">// 获得流程实例</span></div><div class="line">    ProcessInstance instance = runtimeService.startProcessInstanceByKey(RE_ATTEND_FLOW_ID, map);</div><div class="line">    <span class="comment">// 获得任务</span></div><div class="line">    Task task = taskService.createTaskQuery().processInstanceId(instance.getId()).singleResult();</div><div class="line">    <span class="comment">// 提交用户补签任务</span></div><div class="line">    taskService.complete(task.getId(), map);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 当前处理人获得需要处理的任务</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;ReAttend&gt; <span class="title">listTasks</span><span class="params">(String userName)</span> </span>&#123;</div><div class="line">    <span class="comment">//转换成页面实体 需要返回的对象</span></div><div class="line">    List&lt;ReAttend&gt; reAttendList = <span class="keyword">new</span> ArrayList&lt;ReAttend&gt;();</div><div class="line">    List&lt;Task&gt; taskList = taskService.createTaskQuery().processVariableValueEquals(userName).list();</div><div class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(taskList)) &#123;</div><div class="line">        <span class="keyword">for</span> (Task task : taskList) &#123;</div><div class="line">            Map&lt;String, Object&gt; variable = taskService.getVariables(task.getId());</div><div class="line">            ReAttend reAttend = (ReAttend) variable.get(RE_ATTEND_SIGN);</div><div class="line">            reAttend.setTaskId(task.getId());</div><div class="line">            reAttendList.add(reAttend);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> reAttendList;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 3.当前处理人处理任务</span></div><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">approve</span><span class="params">(ReAttend reAttend)</span> </span>&#123;</div><div class="line">    <span class="comment">// 需要处理的任务</span></div><div class="line">    Task task = taskService.createTaskQuery().taskId(reAttend.getTaskId()).singleResult();</div><div class="line">    <span class="comment">// 如果同意</span></div><div class="line">    <span class="keyword">if</span> ((<span class="string">""</span> + RE_ATTEND_STATUS_PSSS).equals(reAttend.getApproveFlag())) &#123;</div><div class="line">        Attend attend = <span class="keyword">new</span> Attend();</div><div class="line">        attend.setId(reAttend.getAttendId());</div><div class="line">        attend.setAttendStatus(ATTEND_STATUS_NORMAL);</div><div class="line">        <span class="comment">// 将出勤数据的状态从异常变为正常</span></div><div class="line">        attendMapper.updateByPrimaryKeySelective(attend);</div><div class="line">        <span class="comment">// 审批通过，修改补签数据状态</span></div><div class="line">        reAttend.setStatus(RE_ATTEND_STATUS_PSSS);</div><div class="line">        reAttendMapper.updateByPrimaryKeySelective(reAttend);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="string">""</span> + RE_ATTEND_STATUS_REFUSE.toString()).equals(reAttend.getApproveFlag())) &#123;</div><div class="line">        reAttend.setStatus(RE_ATTEND_STATUS_REFUSE);</div><div class="line">        reAttendMapper.updateByPrimaryKeySelective(reAttend);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 完成任务</span></div><div class="line">    taskService.complete(task.getId());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这个项目关于前端页面前端模板引擎Velocity，SSM架构，Mybatis自动生成插件以及分页方法，这里都不再多说，项目的注释应该算是很全了，认真看就行。</p>
<h1 id="参考与致谢"><a href="#参考与致谢" class="headerlink" title="参考与致谢"></a>参考与致谢</h1><ol>
<li><a href="http://coder520.com/courses/17" target="_blank" rel="external">SSM实战-码码员工考勤系统</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：记得去年暑假要弄工作流Activity没有弄出来，这次刚好看到了一个基于Shiro和Activity的考勤项目，就想写一下了！
    
    </summary>
    
      <category term="HelloWorld" scheme="http://bestlixiang.site/categories/HelloWorld/"/>
    
    
      <category term="SSM" scheme="http://bestlixiang.site/tags/SSM/"/>
    
      <category term="Shiro" scheme="http://bestlixiang.site/tags/Shiro/"/>
    
      <category term="Activity" scheme="http://bestlixiang.site/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>HelloWorld_SpringBoot Angular</title>
    <link href="http://bestlixiang.site/2018/04/25/HelloWorld/HelloWorld-SpringBoot-Angular/"/>
    <id>http://bestlixiang.site/2018/04/25/HelloWorld/HelloWorld-SpringBoot-Angular/</id>
    <published>2018-04-25T11:31:14.000Z</published>
    <updated>2018-04-25T11:32:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：前段时间写了个前后台不分离的<a href="http://todorex.com/2018/04/17/HelloWorld/HelloWorld-SSMLogin/" target="_blank" rel="external">SSMLogin</a>，大家可能会觉得前后台不分离太low，所以这次我们使用SpringBoot+Angular搭建了一个利用Token来进行身份验证的前后台分离登录Demo项目。<a id="more"></a></p>
<h1 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h1><p><a href="https://github.com/todorex/SpringBoot_Angular_HeroesLogin/" target="_blank" rel="external">SpringBoot+Angular</a></p>
<h1 id="Angular前端"><a href="#Angular前端" class="headerlink" title="Angular前端"></a>Angular前端</h1><p>本文前端基于Angular官方样例Tour of Heroes，请先到<a href="https://angular.io/tutorial" target="_blank" rel="external">官网下载</a>，也可以拷贝自己的项目源码（不过最好还是一步步来，先去官网下载源码），这次前端不是主要讲解的地方，所以官网源码部分就不说了，自己去看。我只说增加的核心部分。</p>
<h2 id="login组件"><a href="#login组件" class="headerlink" title="login组件"></a>login组件</h2><p>下面是登录的ts代码：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> LoginComponent <span class="keyword">implements</span> OnInit &#123;</div><div class="line">  <span class="comment">// 用来接收后台的数据</span></div><div class="line">  model: <span class="built_in">any</span> = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="comment">//注入依赖对象</span></div><div class="line">  <span class="keyword">constructor</span>(<span class="params"></span></div><div class="line">    <span class="keyword">private</span> router: Router,</div><div class="line">    <span class="keyword">private</span> authenticationService: AuthenticationService,</div><div class="line">  ) &#123; &#125;</div><div class="line"></div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="comment">// 重置登录状态</span></div><div class="line">    <span class="keyword">this</span>.authenticationService.logout();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  login() &#123;</div><div class="line">    <span class="comment">// 利用authenticationService获取对象</span></div><div class="line">    <span class="keyword">this</span>.authenticationService.login(<span class="keyword">this</span>.model.username, <span class="keyword">this</span>.model.password).subscribe(</div><div class="line">      <span class="function"><span class="params">result</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span> (result) &#123;</div><div class="line">          <span class="comment">// 登录成功，调制路由</span></div><div class="line">          <span class="keyword">this</span>.router.navigate([<span class="string">'dashboard'</span>]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">this</span>.log(<span class="string">'Username or Password is incorrect'</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="AuthenticationService服务"><a href="#AuthenticationService服务" class="headerlink" title="AuthenticationService服务"></a>AuthenticationService服务</h2><p>看看它的代码：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// http头，使用json传递数据</span></div><div class="line"><span class="keyword">const</span> httpOptions = &#123;</div><div class="line">  headers: <span class="keyword">new</span> HttpHeaders(&#123;<span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>&#125;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@Injectable</span>()</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> AuthenticationService &#123;</div><div class="line">  <span class="comment">// 认证的url</span></div><div class="line">  <span class="keyword">private</span> url: <span class="built_in">string</span> = <span class="string">`<span class="subst">$&#123;environment.apiURL&#125;</span>/auth`</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>) &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  login(username: <span class="built_in">string</span>, password: <span class="built_in">string</span>): Observable&lt;<span class="built_in">boolean</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.post&lt;<span class="built_in">any</span>&gt;(<span class="keyword">this</span>.url,<span class="built_in">JSON</span>.stringify(&#123;username: username, password: password&#125;),httpOptions).pipe(</div><div class="line">      tap(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</div><div class="line">        <span class="comment">// 获得token认证</span></div><div class="line">        <span class="keyword">let</span> token = response.token;</div><div class="line">        <span class="keyword">if</span> (token) &#123;</div><div class="line">          <span class="comment">// 存储token到浏览器localStorage中，以后每次都带着它去请求数据</span></div><div class="line">          localStorage.setItem(<span class="string">'currentUser'</span>,token);</div><div class="line">        &#125;</div><div class="line">      &#125;),</div><div class="line">      catchError(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.error(err);</div><div class="line">        <span class="keyword">return</span> of (<span class="literal">false</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">      )</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 从localStorage获得token</span></div><div class="line">  getToken(): <span class="built_in">String</span> &#123;</div><div class="line">    <span class="keyword">return</span> localStorage.getItem(<span class="string">'currentUser'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  logout(): <span class="built_in">void</span> &#123;</div><div class="line">    <span class="comment">// 清空token，那么没有Token也就不能刷新页面了</span></div><div class="line">    localStorage.removeItem(<span class="string">'currentUser'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  isLoggedIn(): <span class="built_in">boolean</span> &#123;</div><div class="line">    <span class="keyword">var</span> token: <span class="built_in">String</span> = <span class="keyword">this</span>.getToken();</div><div class="line">    <span class="keyword">return</span> token &amp;&amp; token.length &gt; <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="AuthenticationInterceptor拦截器"><a href="#AuthenticationInterceptor拦截器" class="headerlink" title="AuthenticationInterceptor拦截器"></a>AuthenticationInterceptor拦截器</h1><p>有了这个拦截器，以后所有的请求都过经过这里，看看它的代码：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Injectable</span>()</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> AuthenticationInterceptor <span class="keyword">implements</span> HttpInterceptor &#123;</div><div class="line"></div><div class="line">  <span class="comment">// next 相当于Java Filter 的chain</span></div><div class="line">  intercept(req: HttpRequest&lt;<span class="built_in">any</span>&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;<span class="built_in">any</span>&gt;&gt; &#123;</div><div class="line">    <span class="keyword">const</span> idToken = localStorage.getItem(<span class="string">'currentUser'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (idToken) &#123;</div><div class="line">      <span class="comment">// 将原来的请求加上token包装成新的请求发送</span></div><div class="line">      <span class="keyword">const</span> cloned = req.clone(&#123;</div><div class="line">        headers: req.headers.set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + idToken)</div><div class="line">      &#125;);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> next.handle(cloned);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> next.handle(req);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="CanActivateAuthGuard保卫"><a href="#CanActivateAuthGuard保卫" class="headerlink" title="CanActivateAuthGuard保卫"></a>CanActivateAuthGuard保卫</h2><p>有了CanActivateAuthGuard就能够防止未登录用户访问其他页面，看看它的代码：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Injectable</span>()</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> CanActivateAuthGuard <span class="keyword">implements</span> CanActivate &#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(<span class="params"></span></div><div class="line">    <span class="keyword">public</span> router: Router,</div><div class="line">    <span class="keyword">private</span> authService: AuthenticationService</div><div class="line">  ) &#123;&#125;</div><div class="line"></div><div class="line">  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.authService.isLoggedIn()) &#123;</div><div class="line">      <span class="comment">// 可以通过</span></div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 不能通过，跳转到登录页面</span></div><div class="line">    <span class="keyword">this</span>.router.navigate([<span class="string">'/login'</span>]);</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Springboot后台"><a href="#Springboot后台" class="headerlink" title="Springboot后台"></a>Springboot后台</h1><p>我们首先要对SpringBoot的项目结构有个熟悉的认识，如果不知道的可以先稍微了解一下他，他太棒了。这次开发也是上帝模式。</p>
<h2 id="SpringSecurity权限控制"><a href="#SpringSecurity权限控制" class="headerlink" title="SpringSecurity权限控制"></a>SpringSecurity权限控制</h2><p>首先我们要对前台的请求进行认证，利用配置文件设置一些值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># 控制跨域访问</div><div class="line">cors:</div><div class="line">  allowedOrigins: &quot;*&quot;</div><div class="line">  allowedMethods: GET,POST,DELETE,PUT,OPTIONS</div><div class="line">  allowedHeaders: Origin,X-Requested-With,Content-Type,Accept,Accept-Encoding,Accept-Language,Host,Referer,Connection,User-Agent,Authorization</div><div class="line"></div><div class="line"># token配置</div><div class="line">jwt:</div><div class="line">  header: Authorization</div><div class="line">  secret: mySecret</div><div class="line">  expiration: 7200</div><div class="line">  issuer: IATA</div><div class="line">  authenticationPath: /auth</div></pre></td></tr></table></figure></p>
<h3 id="SpringSecurity配置类"><a href="#SpringSecurity配置类" class="headerlink" title="SpringSecurity配置类"></a>SpringSecurity配置类</h3><p>在com.todorex.config.WebSecurityConfig类中，在这个类中，我们主要是配置认证路径、跨域访问以及过滤器等设置。</p>
<h3 id="SpringSecurity自定义过滤器"><a href="#SpringSecurity自定义过滤器" class="headerlink" title="SpringSecurity自定义过滤器"></a>SpringSecurity自定义过滤器</h3><p>在com.todorex.config.AuthenticationTokenFilter类中，主要是验证token，但不重新计算token。</p>
<h3 id="token生成方法"><a href="#token生成方法" class="headerlink" title="token生成方法"></a>token生成方法</h3><p>在com.todorex.util.JwtTokenUtil类中，主要有生成token以及验证token的方法。</p>
<h2 id="Contoller"><a href="#Contoller" class="headerlink" title="Contoller"></a>Contoller</h2><p>主要是控制处理URL，其中比较重要的就是com.todorex.controller.AuthenticationController类，它是用来进行权限认证的，我们看看它的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(produces = MediaType.APPLICATION_JSON_VALUE)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationController</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</div><div class="line"></div><div class="line">    <span class="comment">// 请求路径(/auth)</span></div><div class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"$&#123;jwt.authenticationPath&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> AuthenticationResponse <span class="title">login</span><span class="params">(@RequestBody AuthenticationRequest request)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        <span class="comment">// 对包装过后的UsernamePasswordAuthenticationToken精心再包装成Authentication</span></div><div class="line">        <span class="keyword">final</span> Authentication authentication = authenticationManager.authenticate(<span class="keyword">new</span> UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword()));</div><div class="line">        <span class="comment">// 将该认证添加到上下文中（避免多次验证）</span></div><div class="line">        <span class="comment">// SecurityContextHolder用于存储安全上下文（security context）的信息</span></div><div class="line">        SecurityContextHolder.getContext().setAuthentication(authentication);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">final</span> UserDetails userDetails = userDetailsService.loadUserByUsername(request.getUsername());</div><div class="line">        <span class="comment">// 实际应用中，生成token时可能会用到更多的参数</span></div><div class="line">        <span class="keyword">final</span> String token = jwtTokenUtil.generate(userDetails.getUsername());</div><div class="line">        <span class="comment">// 返回Token</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AuthenticationResponse(token);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其他都是普通的Controller，但是对于URL的设计我们需要注意，我们主要是用Restful风格的URL，这种风格是怎么样的呢？我们可以参考下面的博文：<a href="https://blog.csdn.net/chenxiaochan/article/details/73716617" target="_blank" rel="external">【Restful】三分钟彻底了解Restful最佳实践</a>。</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>主要是处理业务的，这里我们需要注意的这个类：com.todorex.service.UserDetailsServiceImpl，我们需要实现UserDetailsService接口，因为SpringSecurity方法会用到，看看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserRepository userRepository;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</div><div class="line">        User user = userRepository.findByUsername(s);</div><div class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(String.format(<span class="string">"No user found with username '%s'."</span>, s));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> create(user);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 包装成SpringSecurity需要的User</div><div class="line">     * <span class="doctag">@param</span> user</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> org.springframework.security.core.userdetails.<span class="function">User <span class="title">create</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> org.springframework.security.core.userdetails.User(user.getUsername(), user.getPassword(), mapToGrantedAuthorities(user.getAuthorities()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 包装权限</div><div class="line">     * <span class="doctag">@param</span> authorities</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;GrantedAuthority&gt; <span class="title">mapToGrantedAuthorities</span><span class="params">(List&lt;Authority&gt; authorities)</span> </span>&#123;</div><div class="line">        <span class="comment">// Java8语法</span></div><div class="line">        <span class="keyword">return</span> authorities.stream()</div><div class="line">                .map(authority -&gt; <span class="keyword">new</span> SimpleGrantedAuthority(authority.getName().name()))</div><div class="line">                .collect(Collectors.toList());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h2><p>这里我们使用的JPA，它内部实现是Hibernate，我们只要先定义Entity再定义Dao类就可以了。</p>
<h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>Entity定义之后可以根据实体自动建表（可在配置文件中配置），如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># jpa配置</div><div class="line">  jpa:</div><div class="line">    database: MYSQL</div><div class="line">    show-sql: true</div><div class="line">    hibernate:</div><div class="line">    # 表不存在就自动建表</div><div class="line">      ddl-auto: create</div></pre></td></tr></table></figure></p>
<h3 id="Dao-1"><a href="#Dao-1" class="headerlink" title="Dao"></a>Dao</h3><p>Dao接口只要继承JpaRepository<t, id="">就会有很多内置方法，如果要自己写SQL也可以参照com.todorex.HeroRepository的写法。</t,></p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>我们可以先定义总的接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootTestAbstract</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后每个要测试的类继承他就可以了，避免了重复配置，IDEA还有很多技巧，自己可以去baidu、google，这里也举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTest</span> <span class="keyword">extends</span> <span class="title">SpringBootTestAbstract</span></span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    ApplicationContext applicationContext;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    DataSourceProperties dataSourceProperties;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// 获取配置的数据源</span></div><div class="line">        DataSource dataSource = applicationContext.getBean(DataSource.class);</div><div class="line">        <span class="comment">// 查看配置数据源信息</span></div><div class="line">        System.out.println(dataSource);</div><div class="line">        System.out.println(dataSource.getClass().getName());</div><div class="line">        System.out.println(dataSourceProperties);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>SpringBoot默认使用logback作为日志框架，我们可以做如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 日志配置</div><div class="line">logging:</div><div class="line">  level:</div><div class="line">    # 配置包以及输出等级</div><div class="line">    com.todorex: debug</div><div class="line">  pattern:</div><div class="line">    console: &quot;%d - %msg%n&quot;</div><div class="line">  path: /var/localLog/</div><div class="line">  file: /var/localLog/springbootdemo.log</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://blog.51cto.com/7308310/2072364" target="_blank" rel="external">Angular 5集成Spring Boot,Spring Security,JWT和CORS</a></li>
<li><a href="https://angular.io/tutorial" target="_blank" rel="external">Angular_Heroes教程</a></li>
<li><a href="http://todorex.com/2018/04/25/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98SpringSecurity-%E4%B8%80-%E8%AF%B7%E6%B1%82%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/" target="_blank" rel="external">揭秘SpringSecurity(一)_请求认证过程</a></li>
<li><a href="http://todorex.com/2018/04/21/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98SpringBoot-%E4%B8%80-SpringBoot%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/" target="_blank" rel="external">揭秘SpringBoot(一)_SpringBoot运行原理</a></li>
<li><a href="https://blog.csdn.net/chenxiaochan/article/details/73716617" target="_blank" rel="external">【Restful】三分钟彻底了解Restful最佳实践</a></li>
<li><a href="https://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="external">什么是 JWT – JSON WEB TOKEN</a></li>
<li><a href="https://blog.csdn.net/cabbges/article/details/53378516" target="_blank" rel="external">ajax 跨域 CROS</a></li>
<li><a href="https://blog.csdn.net/inke88/article/details/75007649" target="_blank" rel="external">Spring Boot 日志配置(超详细)</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前段时间写了个前后台不分离的&lt;a href=&quot;http://todorex.com/2018/04/17/HelloWorld/HelloWorld-SSMLogin/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SSMLogin&lt;/a&gt;，大家可能会觉得前后台不分离太low，所以这次我们使用SpringBoot+Angular搭建了一个利用Token来进行身份验证的前后台分离登录Demo项目。
    
    </summary>
    
      <category term="HelloWorld" scheme="http://bestlixiang.site/categories/HelloWorld/"/>
    
    
      <category term="SpringBoot" scheme="http://bestlixiang.site/tags/SpringBoot/"/>
    
      <category term="SpringSecurity" scheme="http://bestlixiang.site/tags/SpringSecurity/"/>
    
      <category term="JWT" scheme="http://bestlixiang.site/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>揭秘SpringSecurity(一)_请求认证过程</title>
    <link href="http://bestlixiang.site/2018/04/25/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98SpringSecurity-%E4%B8%80-%E8%AF%B7%E6%B1%82%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/"/>
    <id>http://bestlixiang.site/2018/04/25/深入SSM/揭秘SpringSecurity-一-请求认证过程/</id>
    <published>2018-04-25T07:39:06.000Z</published>
    <updated>2018-04-25T11:41:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：有了Spring作为基础，Spring家族的很多框架都显得那么棒，尤其是Springboot的出现，简化了配置，家族框架就显得更棒了，我们这次分析一下其中的SpringSecurity，我们会由请求认证过程，来分析其中的各个组件！<a id="more"></a></p>
<h1 id="一次认证过程"><a href="#一次认证过程" class="headerlink" title="一次认证过程"></a>一次认证过程</h1><p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/springSecurity.png" alt="SpringSecurity"></p>
<p>大家可以找到一个工程，这里也可以看看我的<a href="https://github.com/todorex/SpringBoot_Angular_HeroesLogin" target="_blank" rel="external">SpringBoot+Angular工程</a>debug验证我画的流程图。</p>
<h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>在最开始debug的过程中我们会发现pring Security使用了springSecurityFillterChian作为了安全过滤的入口，我只介绍几个比较常用的过滤器。</p>
<h3 id="SecurityContextPersistenceFilter"><a href="#SecurityContextPersistenceFilter" class="headerlink" title="SecurityContextPersistenceFilter"></a>SecurityContextPersistenceFilter</h3><p>两个主要职责：</p>
<ol>
<li>请求来临时，创建SecurityContext安全上下文信息</li>
<li>请求结束时清空SecurityContextHolder（可获得当前操作的用户是谁，该用户是否已经被认证，他拥有哪些角色权限等信息）。</li>
</ol>
<p>我们看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityContextPersistenceFilter</span> <span class="keyword">extends</span> <span class="title">GenericFilterBean</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String FILTER_APPLIED = <span class="string">"__spring_security_scpf_applied"</span>;</div><div class="line">    <span class="comment">// 安全上下文存储的仓库</span></div><div class="line">    <span class="keyword">private</span> SecurityContextRepository repo;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityContextPersistenceFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// HttpSessionSecurityContextRepository是SecurityContextRepository接口的一个实现类</span></div><div class="line">        <span class="comment">// 使用HttpSession来存储SecurityContext</span></div><div class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> HttpSessionSecurityContextRepository());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">        HttpServletRequest request = (HttpServletRequest)req;</div><div class="line">        HttpServletResponse response = (HttpServletResponse)res;</div><div class="line">        <span class="keyword">if</span>(request.getAttribute(<span class="string">"__spring_security_scpf_applied"</span>) != <span class="keyword">null</span>) &#123;</div><div class="line">            chain.doFilter(request, response);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">boolean</span> debug = <span class="keyword">this</span>.logger.isDebugEnabled();</div><div class="line">            request.setAttribute(<span class="string">"__spring_security_scpf_applied"</span>, Boolean.TRUE);</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.forceEagerSessionCreation) &#123;</div><div class="line">                HttpSession session = request.getSession();</div><div class="line">                <span class="keyword">if</span>(debug &amp;&amp; session.isNew()) &#123;</div><div class="line">                    <span class="keyword">this</span>.logger.debug(<span class="string">"Eagerly created session: "</span> + session.getId());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 包装request，response</span></div><div class="line">            HttpRequestResponseHolder holder = <span class="keyword">new</span> HttpRequestResponseHolder(request, response);</div><div class="line">            <span class="comment">// 从Session中获取安全上下文信息</span></div><div class="line">            SecurityContext contextBeforeChainExecution = <span class="keyword">this</span>.repo.loadContext(holder);</div><div class="line">            <span class="keyword">boolean</span> var13 = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                var13 = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">// 请求开始时，设置安全上下文信息，这样就避免了用户直接从Session中获取安全上下文信息</span></div><div class="line">                SecurityContextHolder.setContext(contextBeforeChainExecution);</div><div class="line">                chain.doFilter(holder.getRequest(), holder.getResponse());</div><div class="line">                var13 = <span class="keyword">false</span>;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">if</span>(var13) &#123;</div><div class="line">                    SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext();\</div><div class="line">                    <span class="comment">//请求结束后，清空安全上下文信息</span></div><div class="line">                    SecurityContextHolder.clearContext();</div><div class="line">                    <span class="keyword">this</span>.repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());</div><div class="line">                    request.removeAttribute(<span class="string">"__spring_security_scpf_applied"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="UsernamePasswordAuthenticationFilter"><a href="#UsernamePasswordAuthenticationFilter" class="headerlink" title="UsernamePasswordAuthenticationFilter"></a>UsernamePasswordAuthenticationFilter</h2><p>这个可能是我们遇见最多的过滤器了，一个最直观的业务场景便是允许用户在表单中输入用户名和密码进行登录，而这背后用到的就是UsernamePasswordAuthenticationFilter。这个过滤器也可以见证我们之前画的时序图，我们看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.postOnly &amp;&amp; !request.getMethod().equals(<span class="string">"POST"</span>)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(<span class="string">"Authentication method not supported: "</span> + request.getMethod());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 获取用户名，密码</span></div><div class="line">            String username = <span class="keyword">this</span>.obtainUsername(request);</div><div class="line">            String password = <span class="keyword">this</span>.obtainPassword(request);</div><div class="line">            <span class="keyword">if</span>(username == <span class="keyword">null</span>) &#123;</div><div class="line">                username = <span class="string">""</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(password == <span class="keyword">null</span>) &#123;</div><div class="line">                password = <span class="string">""</span>;</div><div class="line">            &#125;</div><div class="line">            username = username.trim();</div><div class="line">            <span class="comment">// 生成Authentication，下面会介绍</span></div><div class="line">            UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(username, password);</div><div class="line">            <span class="keyword">this</span>.setDetails(request, authRequest);</div><div class="line">            <span class="comment">// 讲Authentication交给AuthenticationManager认证</span></div><div class="line">            <span class="keyword">return</span>  <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="自定义Filter"><a href="#自定义Filter" class="headerlink" title="自定义Filter"></a>自定义Filter</h3><p>当自带的Filter不能满足你的要求时（例如我们要先对token进行认证），我们可以自定义过滤器，只要继承各种Filter接口，并实现其中方法即可。</p>
<h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p>先看他的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authentication</span> <span class="keyword">extends</span> <span class="title">Principal</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="comment">// 权限信息列表</span></div><div class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</div><div class="line">    <span class="comment">// 密码信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全</span></div><div class="line">    <span class="function">Object <span class="title">getCredentials</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 细节信息，它记录了访问者的ip地址和sessionId的值。</span></div><div class="line">    <span class="function">Object <span class="title">getDetails</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 最重要的身份信息，大部分情况下返回的是UserDetails接口的实现类</span></div><div class="line">    <span class="function">Object <span class="title">getPrincipal</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 是否已认证</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAuthenticated</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> var1)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从它的源码可以知道它拥有的权限信息列表，密码，用户细节信息，用户身份信息，认证信息。</p>
<p>它有很多实现类，比如流程图中的<strong>UsernamePasswordAuthenticationToken</strong>，以及AnonymousAuthenticationToken等。</p>
<h2 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h2><p>先看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationManager</span> </span>&#123;</div><div class="line">    <span class="comment">// 主要是认证传进来的Authentication</span></div><div class="line">    <span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication var1)</span> <span class="keyword">throws</span> AuthenticationException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它最有用的实现类就是流程图中的ProviderManager，我们可以看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderManager</span> <span class="keyword">implements</span> <span class="title">AuthenticationManager</span>, <span class="title">MessageSourceAware</span>, <span class="title">InitializingBean</span> </span>&#123;</div><div class="line">    <span class="comment">// 维护一个AuthenticationProvider列表</span></div><div class="line">    <span class="keyword">private</span> List&lt;AuthenticationProvider&gt; providers;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> eraseCredentialsAfterAuthentication;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</div><div class="line">        AuthenticationException lastException = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 要从新返回的Authentication</span></div><div class="line">        Authentication result = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 遍历AuthenticationProvider列表</span></div><div class="line">        Iterator var6 = <span class="keyword">this</span>.getProviders().iterator();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(var6.hasNext()) &#123;</div><div class="line">            AuthenticationProvider provider = (AuthenticationProvider)var6.next();</div><div class="line">            <span class="keyword">if</span>(provider.supports(toTest)) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// 对传进来的authentication进行认证</span></div><div class="line">                    result = provider.authenticate(authentication);</div><div class="line">                    <span class="keyword">if</span>(result != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">// 将属性复制给result</span></div><div class="line">                        <span class="keyword">this</span>.copyDetails(authentication, result);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (AccountStatusException var11) &#123;</div><div class="line">                    ...</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(result == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 如果列表里的Provider都不支持该authentication，则到父类查找</span></div><div class="line">                result = <span class="keyword">this</span>.parent.authenticate(authentication);</div><div class="line">            &#125; <span class="keyword">catch</span> (ProviderNotFoundException var9) &#123;</div><div class="line">                ;</div><div class="line">            &#125; <span class="keyword">catch</span> (AuthenticationException var10) &#123;</div><div class="line">                lastException = var10;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(result != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.eraseCredentialsAfterAuthentication &amp;&amp; result <span class="keyword">instanceof</span> CredentialsContainer) &#123;</div><div class="line">                <span class="comment">// 擦除密码信息</span></div><div class="line">                ((CredentialsContainer)result).eraseCredentials();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">this</span>.eventPublisher.publishAuthenticationSuccess(result);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="AuthenticationProvider"><a href="#AuthenticationProvider" class="headerlink" title="AuthenticationProvider"></a>AuthenticationProvider</h2><p>看看它的源码先：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationProvider</span> </span>&#123;</div><div class="line">    <span class="comment">// 认证</span></div><div class="line">    <span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication var1)</span> <span class="keyword">throws</span> AuthenticationException</span>;</div><div class="line">    <span class="comment">// 判断是否支持传进来的Authentication</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们接着看看它最常用的一个实现DaoAuthenticationProvider。也看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoAuthenticationProvider</span> <span class="keyword">extends</span> <span class="title">AbstractUserDetailsAuthenticationProvider</span> </span>&#123;</div><div class="line">    <span class="comment">// 密码加密器</span></div><div class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</div><div class="line">    <span class="comment">// 加载用户的UserDetailsService</span></div><div class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(authentication.getCredentials() == <span class="keyword">null</span>) &#123;</div><div class="line">            ...</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 验证密码</span></div><div class="line">            String presentedPassword = authentication.getCredentials().toString();</div><div class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 最核心的方法</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title">retrieveUser</span><span class="params">(String username, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        <span class="keyword">this</span>.prepareTimingAttackProtection();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 获得UserDetails</span></div><div class="line">            UserDetails loadedUser = <span class="keyword">this</span>.getUserDetailsService().loadUserByUsername(username);</div><div class="line">            <span class="keyword">if</span>(loadedUser == <span class="keyword">null</span>) &#123;</div><div class="line">                ...</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> loadedUser;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (UsernameNotFoundException var4) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h2><p>先看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetailsService</span> </span>&#123;</div><div class="line">    <span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String var1)</span> <span class="keyword">throws</span> UsernameNotFoundException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个接口的实现类有JdbcDaoImpl（负责从数据库加载用户）等，当然我们也可以自己实现这个接口。只要实现loadUserByUsername方法即可。</p>
<p>再看看<strong>UserDetails</strong>是个什么东西？</p>
<p>看看它源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="comment">// 权限属性</span></div><div class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</div><div class="line">    <span class="comment">// 密码属性</span></div><div class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 用户名属性</span></div><div class="line">    <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 账户是否过期</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 账户是否被锁</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 密码是否过期</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 是否启用</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它代表了最详细的用户信息，这个接口涵盖了一些必要的用户信息字段，具体的实现类对它进行了扩展。这里我们普通的User类也可以实现这个接口。</p>
<h1 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h1><p>通过我们上面对核心组件的解读再结合流程流就应该可以理解SpringSecurity的请求认证过程。但是不可能我们对所有的路径都需要认证，或者说它总要提供一个东西让我们配置它的细节，那就是WebSecurityConfigurerAdapter接口，它主要使用了适配器模式。我们主要看看我们需要覆盖它的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfigurerAdapter</span> <span class="keyword">implements</span> <span class="title">WebSecurityConfigurer</span>&lt;<span class="title">WebSecurity</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 配置AuthenticationManagerBuilder</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">this</span>.disableLocalConfigureAuthenticationBldr = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 配置WebSecurity</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 配置HttpSecurity</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ((HttpSecurity)((HttpSecurity)((AuthorizedUrl)http.authorizeRequests().anyRequest()).authenticated().and()).formLogin().and()).httpBasic();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="配置AuthenticationManagerBuilder"><a href="#配置AuthenticationManagerBuilder" class="headerlink" title="配置AuthenticationManagerBuilder"></a>配置AuthenticationManagerBuilder</h2><p>我们可以看看它的使用案例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        auth</div><div class="line">            .inMemoryAuthentication()</div><div class="line">            .withUser(<span class="string">"admin"</span>).password(<span class="string">"admin"</span>).roles(<span class="string">"USER"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>想要在WebSecurityConfigurerAdapter中进行认证相关的配置，可以使用configure(AuthenticationManagerBuilder auth)暴露一个AuthenticationManager的建造器：AuthenticationManagerBuilder 。如上所示，我们便完成了内存中用户的配置，也可以在这里讲自己定义的UserDetailService注入。</p>
<h2 id="配置WebSecurity"><a href="#配置WebSecurity" class="headerlink" title="配置WebSecurity"></a>配置WebSecurity</h2><p>我们可以看看它的使用案例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        http</div><div class="line">            <span class="comment">// 配置路径拦截，表明路径访问所对应的权限，角色，认证信息。</span></div><div class="line">            .authorizeRequests()</div><div class="line">                .antMatchers(<span class="string">"/resources/**"</span>, <span class="string">"/signup"</span>, <span class="string">"/about"</span>).permitAll()</div><div class="line">                .antMatchers(<span class="string">"/admin/**"</span>).hasRole(<span class="string">"ADMIN"</span>)</div><div class="line">                .antMatchers(<span class="string">"/db/**"</span>).access(<span class="string">"hasRole('ADMIN') and hasRole('DBA')"</span>)</div><div class="line">                .anyRequest().authenticated()</div><div class="line">                .and()</div><div class="line">            <span class="comment">// 配置表单认证</span></div><div class="line">            .formLogin()</div><div class="line">                .usernameParameter(<span class="string">"username"</span>)</div><div class="line">                .passwordParameter(<span class="string">"password"</span>)</div><div class="line">                .failureForwardUrl(<span class="string">"/login?error"</span>)</div><div class="line">                .loginPage(<span class="string">"/login"</span>)</div><div class="line">                .permitAll()</div><div class="line">                .and()</div><div class="line">            <span class="comment">// 配置注销</span></div><div class="line">            .logout()</div><div class="line">                .logoutUrl(<span class="string">"/logout"</span>)</div><div class="line">                .logoutSuccessUrl(<span class="string">"/index"</span>)</div><div class="line">                .permitAll()</div><div class="line">                .and()</div><div class="line">            <span class="comment">// 配置basic登录</span></div><div class="line">            .httpBasic()</div><div class="line">                .disable();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法里的各项配置分别代表了http请求相关的安全配置，这些配置项无一例外的返回了Configurer类，而所有的http相关配置可以通过查看HttpSecurity的主要方法得知。</p>
<h2 id="WebSecurityBuilder"><a href="#WebSecurityBuilder" class="headerlink" title="WebSecurityBuilder"></a>WebSecurityBuilder</h2><p>我们可以看看它的使用案例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        web</div><div class="line">            .ignoring()</div><div class="line">            .antMatchers(<span class="string">"/resources/**"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个配置中并不会出现太多的配置信息。</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="http://ov0zuistv.bkt.clouddn.com/spring%20security%20architecture.png" alt="image"></p>
<p>将这个架构图结合流程图我们会可以大致总结出核心组件之间的关系，有利于我们我们更好的理解SpringSecurity的架构以及请求认证过程。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnkirito.moe/2017/09/19/spring-security-1/" target="_blank" rel="external">Spring Security(一)–Architecture Overview</a></li>
<li><a href="https://blog.csdn.net/dandandeshangni/article/details/78959131" target="_blank" rel="external">Spring Security源码分析一：Spring Security认证过程</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：有了Spring作为基础，Spring家族的很多框架都显得那么棒，尤其是Springboot的出现，简化了配置，家族框架就显得更棒了，我们这次分析一下其中的SpringSecurity，我们会由请求认证过程，来分析其中的各个组件！
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="SpringSecurity" scheme="http://bestlixiang.site/tags/SpringSecurity/"/>
    
  </entry>
  
  <entry>
    <title>揭秘SpringBoot(一)_SpringBoot运行原理</title>
    <link href="http://bestlixiang.site/2018/04/21/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98SpringBoot-%E4%B8%80-SpringBoot%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://bestlixiang.site/2018/04/21/深入SSM/揭秘SpringBoot-一-SpringBoot运行原理/</id>
    <published>2018-04-21T05:11:48.000Z</published>
    <updated>2018-04-21T05:12:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：可能你早已开始使用SpringBoot，但是你却不知道SpringBoot是个什么东西，他又是怎么运行的，这里给你答案！<a id="more"></a></p>
<h1 id="SpringBoot是什么"><a href="#SpringBoot是什么" class="headerlink" title="SpringBoot是什么"></a>SpringBoot是什么</h1><p>用过Spring的人都知道，你肯定需要些很多很多的XML来用配置复杂的依赖关系，你肯定厌倦了。这个时候SpringBoot出现了，<br><strong>SpringBoot</strong>是由Pivotal团队提供的全新框架，其<strong>设计目的是用来简化新Spring应用的初始搭建以及开发过程</strong>。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置（想想肯定会很开心）。</p>
<h2 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h2><p><strong>习惯优于配置</strong></p>
<h2 id="SpringBoot与Spring-Framework的区别"><a href="#SpringBoot与Spring-Framework的区别" class="headerlink" title="SpringBoot与Spring Framework的区别"></a>SpringBoot与Spring Framework的区别</h2><p>做个下面的<strong>比喻</strong>：</p>
<p><strong>SpringFramework</strong> 就像一个大型电子器件生产公司，它生产的电子器件（比如zookeeper，redis等整合包）都很优秀，当其他小公司（开发者）生产机器人（项目）需要使用到它的电子器件时，就发现需要大量的焊接工作（配置XML）来连接自己的电子器件（zookeeper，redis），这样真的太耗时了，而<strong>SpringBoot</strong> 就像这个电子器件生产公司在原来电子器件的基础上包装出来的许多统一的插口（各种starter），这些插头可以与小公司的电子器件可以直接连接，不需要焊接工作就可以直接使用。</p>
<p>通过上面的比喻我们可以了解到他们两者的区别，也发现其实SpringBoot并不是什么新东西，它只是原来Spring的基础上重新包装过，从而简化了Spring的相关配置。</p>
<h2 id="SpringBoot的核心功能"><a href="#SpringBoot的核心功能" class="headerlink" title="SpringBoot的核心功能"></a>SpringBoot的核心功能</h2><ol>
<li>SpringBoot可以以jar包的形式<strong>独立运行</strong>，因为SpringBoot内嵌Servlet容器，如Tomcat、Jetty。</li>
<li>Spring会根据类路径中的jar包、类，为jar包里的类自动配置Bean，极大减少了我们要使用的配置。</li>
<li>提供starter(起动机)简化了Maven配置(依赖加载)，一个starter依赖抵了好几个依赖。</li>
</ol>
<h1 id="SpringBoot运行原理"><a href="#SpringBoot运行原理" class="headerlink" title="SpringBoot运行原理"></a>SpringBoot运行原理</h1><ol>
<li><p>对于SpringBoot工程我们总是先看到它的启动类，如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootLoginApplication</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		SpringApplication.run(SpringbootLoginApplication.class, args);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对于SpringBoot的运作原理，我们应该先从启动类的@SpringBootApplication注解来分析，这个注解是一个组合注解，我们进入它的源码看看：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@SpringBootConfiguration</span></div><div class="line"><span class="meta">@EnableAutoConfiguration</span></div><div class="line"><span class="meta">@ComponentScan</span>(</div><div class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</div><div class="line">    type = FilterType.CUSTOM,</div><div class="line">    classes = &#123;TypeExcludeFilter.class&#125;</div><div class="line">), <span class="meta">@Filter</span>(</div><div class="line">    type = FilterType.CUSTOM,</div><div class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</div><div class="line">)&#125;</div><div class="line">)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</div><div class="line">    <span class="meta">@AliasFor</span>(</div><div class="line">        annotation = EnableAutoConfiguration.class</div><div class="line">    )</div><div class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="meta">@AliasFor</span>(</div><div class="line">        annotation = EnableAutoConfiguration.class</div><div class="line">    )</div><div class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="meta">@AliasFor</span>(</div><div class="line">        annotation = ComponentScan.class,</div><div class="line">        attribute = <span class="string">"basePackages"</span></div><div class="line">    )</div><div class="line">    String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="meta">@AliasFor</span>(</div><div class="line">        annotation = ComponentScan.class,</div><div class="line">        attribute = <span class="string">"basePackageClasses"</span></div><div class="line">    )</div><div class="line">    Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 总得来说最重要的就是@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan这三个注解，我们一个个分析：</p>
<ol>
<li><p>@SpringBootConfiguration</p>
<p> 我们进入该注解，我发现它的代码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 你会发现其核心注解就是@Configuration，它对于我们来说应该不陌生，因为它就是Java配置形式的Spring Ioc容器的配置类使用的那个@Configuration（相当于XML配置文件的一个Bean），SpringBoot社区推荐使用基于JavaConfig的配置形式，所以，这里的启动类标注了@Configuration之后，本身其实也是一个IoC容器的配置类。</p>
</li>
<li><p>@ComponentScan</p>
<p> 这个注解很简单，很常见，但是也很<strong>重要</strong>。它主要的作用就是自动扫描并加载符合条件的组件（比如@Controller和@Service等）或者bean定义，最终将这些bean定义加载到IoC容器中。我们看看它的源码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Repeatable</span>(ComponentScans.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ComponentScan &#123;</div><div class="line"><span class="comment">// 设置默认路径</span></div><div class="line"><span class="meta">@AliasFor</span>(<span class="string">"basePackages"</span>)</div><div class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"><span class="comment">// 如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。</span></div><div class="line"><span class="comment">// 所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。</span></div><div class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</div><div class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</div><div class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</div><div class="line">Class&lt;? extends BeanNameGenerator&gt; nameGenerator() <span class="keyword">default</span> BeanNameGenerator.class;</div><div class="line">Class&lt;? extends ScopeMetadataResolver&gt; scopeResolver() <span class="keyword">default</span> AnnotationScopeMetadataResolver.class;</div><div class="line"><span class="function">ScopedProxyMode <span class="title">scopedProxy</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.DEFAULT</span>;</div><div class="line"><span class="comment">// 扫描类型</span></div><div class="line"><span class="function">String <span class="title">resourcePattern</span><span class="params">()</span> <span class="keyword">default</span> "**<span class="comment">/*.class";</span></span></div><div class="line">// 可设置过滤器</div><div class="line">boolean useDefaultFilters() default true;</div><div class="line">ComponentScan.Filter[] includeFilters() default &#123;&#125;;</div><div class="line">ComponentScan.Filter[] excludeFilters() default &#123;&#125;;</div><div class="line">// 配置懒加载，如果没被使用，就先不生成Bean</div><div class="line">boolean lazyInit() default false;</div><div class="line"></div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Target(&#123;&#125;)</div><div class="line">public @interface Filter &#123;</div><div class="line">    FilterType type() default FilterType.ANNOTATION;</div><div class="line"></div><div class="line">    @AliasFor("classes")</div><div class="line">    Class&lt;?&gt;[] value() default &#123;&#125;;</div><div class="line"></div><div class="line">    @AliasFor("value")</div><div class="line">    Class&lt;?&gt;[] classes() default &#123;&#125;;</div><div class="line"></div><div class="line">    String[] pattern() default &#123;&#125;;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>@EnableAutoConfiguration</p>
<p> 这个注解可以说是SpringBoot自动配置的核心了，<strong>灰常重要</strong>。我们进去看一下它的源码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@AutoConfigurationPackage</span></div><div class="line"><span class="comment">// 借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器</span></div><div class="line"><span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</div><div class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</div><div class="line"></div><div class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 我们需要好好看看AutoConfigurationImportSelector，它利用SpringFactoriesLoader.loadFactoryNames方法来扫描具有META-INF/spring.factories 文件的jar包，代码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</div><div class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</div><div class="line"><span class="keyword">return</span> configurations;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 配合@EnableAutoConfiguration使用的话，它更多是提供一种配置查找的功能支持，即根据@EnableAutoConfiguration的完整类名如org.springframework.boot.autoconfigure.EnableAutoConfiguration作为查找的Key,<strong>获取对应的一组@Configuration类</strong>，并将其中org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的配置项实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个（相当于一个XML文件）并加载到IoC容器（和Spring一样）。</p>
<p> 我们可以看看spring-boot-autoconfigure.jar 里就有一个spring.factories 文件，此文件中声明了有哪些自动配置。我们看一点点：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Auto Configure</div><div class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</div><div class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</div><div class="line"># 配置AOP对象</div><div class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>看完@SpringBootApplication注解，我们再看看SpringApplication的run方法。</p>
<ol>
<li><p>我们通过debug发现将进入这个方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 会先创建SpringApplication对象实例，然后调用它的实例run方法</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> SpringApplication(primarySources)).run(args);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>我们看看在实例初始化的过程中他做了什么：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class... primarySources)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.sources = <span class="keyword">new</span> LinkedHashSet();</div><div class="line">    <span class="comment">// banner的打印模式，此时是控制台模式</span></div><div class="line">    <span class="keyword">this</span>.bannerMode = Mode.CONSOLE;</div><div class="line">    <span class="comment">// 开启日志</span></div><div class="line">    <span class="keyword">this</span>.logStartupInfo = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">// 启用CommandLineProperties</span></div><div class="line">    <span class="keyword">this</span>.addCommandLineProperties = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">// 开启headless模式支持，Headless模式是在缺少显示屏、键盘或者鼠标时的系统配置（自行了解）</span></div><div class="line">    <span class="keyword">this</span>.headless = <span class="keyword">true</span></div><div class="line">    <span class="comment">// 启用注册ShutdownHook，用于在非Web应用中关闭IoC容器和资源</span></div><div class="line">    <span class="keyword">this</span>.registerShutdownHook = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">this</span>.additionalProfiles = <span class="keyword">new</span> HashSet();</div><div class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</div><div class="line">    <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet(Arrays.asList(primarySources));</div><div class="line">    <span class="comment">// 判断是否是web运行环境(Servlet)</span></div><div class="line">    <span class="keyword">this</span>.webApplicationType = <span class="keyword">this</span>.deduceWebApplicationType();</div><div class="line">    <span class="comment">// 设置初始化器(在META-INF/spring.factories 文件里，可扩展)</span></div><div class="line">    <span class="keyword">this</span>.setInitializers(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));</div><div class="line">    <span class="comment">// 设置监听器(在META-INF/spring.factories 文件里，可扩展)</span></div><div class="line">    <span class="keyword">this</span>.setListeners(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationListener.class));</div><div class="line">    <span class="comment">// 推断并设置main方法的定义类</span></div><div class="line">    <span class="keyword">this</span>.mainApplicationClass = <span class="keyword">this</span>.deduceMainApplicationClass();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑，如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 开启任务执行时间监听器</span></div><div class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</div><div class="line">    stopWatch.start();</div><div class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</div><div class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList();</div><div class="line">    <span class="comment">// 设置系统属性</span></div><div class="line">    <span class="keyword">this</span>.configureHeadlessProperty();</div><div class="line">    <span class="comment">//开启广播，宣告SpringBoot要开始执行了</span></div><div class="line">    SpringApplicationRunListeners listeners = <span class="keyword">this</span>.getRunListeners(args);</div><div class="line">    listeners.starting();</div><div class="line"></div><div class="line">    Collection exceptionReporters;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</div><div class="line">        <span class="comment">// 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。</span></div><div class="line">        ConfigurableEnvironment environment = <span class="keyword">this</span>.prepareEnvironment(listeners, applicationArguments);</div><div class="line">        <span class="comment">// 宣告SpringBoot应用使用的Environment准备好了。</span></div><div class="line">        <span class="keyword">this</span>.configureIgnoreBeanInfo(environment);</div><div class="line">        <span class="comment">// 决定是否打印Banner</span></div><div class="line">        Banner printedBanner = <span class="keyword">this</span>.printBanner(environment);</div><div class="line">        <span class="comment">// 根据用户是否明确设置了applicationContextClass类型，决定该为当前SpringBoot应用创建什么类型的ApplicationContext</span></div><div class="line">        <span class="comment">// 然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，</span></div><div class="line">        <span class="comment">// 最重要的是将之前准备好的Environment设置给创建好的ApplicationContext使用。</span></div><div class="line">        context = <span class="keyword">this</span>.createApplicationContext();</div><div class="line">        <span class="comment">// 得到异常报告者</span></div><div class="line">        exceptionReporters = <span class="keyword">this</span>.getSpringFactoriesInstances(SpringBootExceptionReporter.class, <span class="keyword">new</span> Class[]&#123;ConfigurableApplicationContext.class&#125;, <span class="keyword">new</span> Object[]&#123;context&#125;);</div><div class="line">        <span class="comment">// ApplicationContext创建好之后，遍历调用ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</span></div><div class="line">        <span class="comment">// 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</span></div><div class="line">        <span class="comment">// 将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext</span></div><div class="line">        <span class="comment">// (很重要，可以进入看看)</span></div><div class="line">        <span class="keyword">this</span>.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</div><div class="line">        <span class="comment">// 初始化所有自动配置类，调用ApplicationContext的refresh()方法</span></div><div class="line">        <span class="keyword">this</span>.refreshContext(context);</div><div class="line">        <span class="comment">// 调用所有的SpringApplicationRunListener的finished()方法，宣告SpringBoot已经完成了ApplicationContext初始化的全部过程。</span></div><div class="line">        <span class="keyword">this</span>.afterRefresh(context, applicationArguments);</div><div class="line">        <span class="comment">//关闭任务执行时间监听器</span></div><div class="line">        stopWatch.stop();</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logStartupInfo) &#123;</div><div class="line">            <span class="comment">// //如果开启日志，则打印执行的时间</span></div><div class="line">            (<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)).logStarted(<span class="keyword">this</span>.getApplicationLog(), stopWatch);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        listeners.started(context);</div><div class="line">        <span class="keyword">this</span>.callRunners(context, applicationArguments);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</div><div class="line">        <span class="comment">// //调用异常分析器打印报告，调用所有的SpringApplicationRunListener的finished()方法将异常信息发布出去</span></div><div class="line">        <span class="keyword">this</span>.handleRunFailure(context, var10, exceptionReporters, listeners);</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var10);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        listeners.running(context);</div><div class="line">        <span class="keyword">return</span> context;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</div><div class="line">        <span class="keyword">this</span>.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var9);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnblogs.com/zheting/p/6707035.html" target="_blank" rel="external">Spring Boot干货系列：（三）启动原理解析</a></li>
<li><a href="https://www.jianshu.com/p/cb5cb5937686" target="_blank" rel="external">Spring Boot学习笔记03–深入了解SpringBoot的启动过程</a></li>
<li><a href="https://blog.csdn.net/hengyunabc/article/details/50120001" target="_blank" rel="external">spring boot应用启动原理分析</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：可能你早已开始使用SpringBoot，但是你却不知道SpringBoot是个什么东西，他又是怎么运行的，这里给你答案！
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="SpringBoot" scheme="http://bestlixiang.site/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>HelloWorld_SSMLogin</title>
    <link href="http://bestlixiang.site/2018/04/17/HelloWorld/HelloWorld-SSMLogin/"/>
    <id>http://bestlixiang.site/2018/04/17/HelloWorld/HelloWorld-SSMLogin/</id>
    <published>2018-04-17T10:55:22.000Z</published>
    <updated>2018-04-17T11:01:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：想着怎么教一个人快速入门SSM，讲原理是真的太费时间，还是以搭建具体流程加上源码比较好吧，先模仿，后创新嘛！<a id="more"></a></p>
<h1 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h1><p><strong><a href="https://github.com/todorex/SSM_LoginDemo" target="_blank" rel="external">项目仓库地址</a></strong></p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/helloworld/png/ssm.png" alt="ssm"></p>
<p>我们先把文件夹创建好，当然也可以先直接从我<a href="https://github.com/todorex/SSM_LoginDemo" target="_blank" rel="external">仓库地址</a>把它克隆下来，删除其中部分的代码文件。</p>
<h1 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h1><p><strong>配置文件里面都有注释，大家可以对照着看：</strong></p>
<h2 id="pom-xml文件"><a href="#pom-xml文件" class="headerlink" title="pom.xml文件"></a>pom.xml文件</h2><p>pom文件作为Maven工程的核心，主要是用来引入jar包的，在我的pom文件中也详细列出了我们需要哪些包，以及哪些包是用来干什么的。</p>
<h2 id="web-xml文件"><a href="#web-xml文件" class="headerlink" title="web.xml文件"></a>web.xml文件</h2><p>web.xml作为Web功能的核心，主要是设置了如何接受请求，这里会结合SpringMVC的前端控制器类DispatcherServlet作为请求分发的核心Servlet，以及在第一次加载过程中，后台服务需要加载哪些配置文件。</p>
<h2 id="ssm配置文件（依靠Spring整合）"><a href="#ssm配置文件（依靠Spring整合）" class="headerlink" title="ssm配置文件（依靠Spring整合）"></a>ssm配置文件（依靠Spring整合）</h2><p>我们看到spring文件夹下有三个文件，分别对应了dao，service，web三层的Bean配置。</p>
<h3 id="spring-dao-config-xml文件"><a href="#spring-dao-config-xml文件" class="headerlink" title="spring-dao-config.xml文件"></a>spring-dao-config.xml文件</h3><p>这里主要是配置数据库连接池（数据源），以及注入SqlSessionFactory和所有在com.todorex.dao下得所有Dao接口。</p>
<h3 id="spring-service-config-xml文件"><a href="#spring-service-config-xml文件" class="headerlink" title="spring-service-config.xml文件"></a>spring-service-config.xml文件</h3><p>这里主要配置扫描并注入com.todorex.service包下所有Service注解类，以及配置事务管理器。</p>
<h3 id="spring-web-config-xml文件"><a href="#spring-web-config-xml文件" class="headerlink" title="spring-web-config.xml文件"></a>spring-web-config.xml文件</h3><p>这里主要配置扫描并注入com.todorex.controller包下所有Controller注解类，以及配置视图解析器。这里还有一个超级重要的就是配置处理静态资源的方式。</p>
<h2 id="mybatis-config-xml文件"><a href="#mybatis-config-xml文件" class="headerlink" title="mybatis-config.xml文件"></a>mybatis-config.xml文件</h2><p>这里主要是设置mybatis的全局属性。</p>
<h2 id="jdbc-properties文件"><a href="#jdbc-properties文件" class="headerlink" title="jdbc.properties文件"></a>jdbc.properties文件</h2><p>这里主要配置数据库连接的相关信息。</p>
<h2 id="log4j-properties文件"><a href="#log4j-properties文件" class="headerlink" title="log4j.properties文件"></a>log4j.properties文件</h2><p>这里主要配置日志记录的相关信息。</p>
<p>配置文件都配置完了，我们终于可以开始写代码了!</p>
<h1 id="SSM代码"><a href="#SSM代码" class="headerlink" title="SSM代码"></a>SSM代码</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>实现用户的登录与注销。</p>
<h2 id="上帝视角开发（我需要什么就造什么）"><a href="#上帝视角开发（我需要什么就造什么）" class="headerlink" title="上帝视角开发（我需要什么就造什么）"></a>上帝视角开发（我需要什么就造什么）</h2><h3 id="我需要一个能处理我的请求（URL）的Controller"><a href="#我需要一个能处理我的请求（URL）的Controller" class="headerlink" title="我需要一个能处理我的请求（URL）的Controller"></a>我需要一个能处理我的请求（URL）的Controller</h3><p>知道要controller，我们就造一个，我们在com.todorex.controller包下新建一个LoginController类。</p>
<p>Controller的作用主要是根据你请求的URL来做不同的事（对应的方法），结果是返回一个ModelAndView（当然View和Model也可以分开），如果方法的逻辑只是页面间的跳转和简单数据处理，我们就用不到Service了，如过我们需要进行业务处理以及操作数据库，那么我们就需要用到Service了。</p>
<p>PS：这里需要注意请求转发和请求重定向的区别（注释中有）</p>
<h3 id="我需要一个能处理业务的Service"><a href="#我需要一个能处理业务的Service" class="headerlink" title="我需要一个能处理业务的Service"></a>我需要一个能处理业务的Service</h3><p>在service层设计一个好的接口是至关重要的（我们还是HelloWorld，以后有经验了自然能设计得好一些），如果实现类有多个的话 ，可以用@Service(“userService1”)来注入，@Resource(name=”userService1”) 来对应获取。在处理业务逻辑的时候，一般都会涉及到数据库操作，这个时候我们就需要用到Dao了。</p>
<h3 id="我需要一个能处理数据的Dao"><a href="#我需要一个能处理数据的Dao" class="headerlink" title="我需要一个能处理数据的Dao"></a>我需要一个能处理数据的Dao</h3><p>这里我们要明确一点：一个Dao接口对应一个Mapper文件，Dao定义接口方法，Mapper文件实现该方法的sql语句。</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>这里我们举一个例子，就是记录登录用户的名字和时间，看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</div><div class="line">    <span class="comment">// 获得日志对象</span></div><div class="line">    Logger logger = Logger.getLogger(LoginController.class);</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/checkLogin"</span>,method = RequestMethod.POST)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">checkLogin</span><span class="params">(User user, Model model)</span> </span>&#123;</div><div class="line">        user = userService.checkLogin(user.getUsername(),user.getPassword());</div><div class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 日志记录用户登录</span></div><div class="line">            logger.info(user.getUsername()+<span class="string">"在"</span>+<span class="keyword">new</span> Date() + <span class="string">"登录过!"</span>);</div><div class="line">            model.addAttribute(<span class="string">"user"</span>,user);</div><div class="line">            <span class="keyword">return</span> <span class="string">"redirect:/success"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"redirect:/fail"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol>
<li><p>配置一个基类（用于加载配置文件）</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class) <span class="comment">//使用junit4进行测试</span></div><div class="line"><span class="comment">// 导入多个配置文件</span></div><div class="line"><span class="meta">@ContextConfiguration</span>(locations=&#123;<span class="string">"classpath:spring/spring-*.xml"</span>,<span class="string">"classpath:mybatis-config.xml"</span>&#125;) <span class="comment">//加载配置文件</span></div><div class="line"><span class="comment">//所有继承该类的测试类都会遵循该配置</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseJunit4Test</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在各个对应的包下建立单元测试，如;</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> <span class="keyword">extends</span> <span class="title">BaseJunit4Test</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserDao userDao;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFindByUsername</span><span class="params">()</span> </span>&#123;</div><div class="line">        User user = userDao.findByUsername(<span class="string">"rex"</span>);</div><div class="line">        System.out.println(user);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="页面编写"><a href="#页面编写" class="headerlink" title="页面编写"></a>页面编写</h1><p>这里只举一个例子（其实主要就是jsp的用法）,success.jsp:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</div><div class="line">         pageEncoding=&quot;UTF-8&quot;%&gt;</div><div class="line">&lt;%--引入jstl标签库，很重要--%&gt;</div><div class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;</div><div class="line"> &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Insert title here&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;!--添加背景图片--&gt;</div><div class="line">&lt;body background=&quot;image/success.jpg&quot;&gt;</div><div class="line"></div><div class="line">&lt;div style=&quot;margin: auto&quot;&gt;</div><div class="line">&lt;div&gt;</div><div class="line">    &lt;%--利用jstl标签获取session中的user的值--%&gt;</div><div class="line">    &lt;strong style=&quot;font-size: 100px;color: red&quot;&gt; $&#123;sessionScope.user.username&#125;!&lt;/strong&gt;</div><div class="line">    &lt;strong style=&quot;font-size: 100px;color: blue&quot;&gt; ，你他妈登录成功了&lt;/strong&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;form action=&quot;/LoginDemo/outLogin&quot; &gt;</div><div class="line">    &lt;button type=&quot;submit&quot; class=&quot;btn btn-success col-lg-12&quot; style=&quot;font-size: 100px;text-align: center&quot;&gt;退出登录&lt;/button&gt;</div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p><strong>终于大功告成！！！</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/s740556472/article/details/71247285" target="_blank" rel="external">SSM搭建(整合)+用户模块(登录和注销)实现</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：想着怎么教一个人快速入门SSM，讲原理是真的太费时间，还是以搭建具体流程加上源码比较好吧，先模仿，后创新嘛！
    
    </summary>
    
      <category term="HelloWorld" scheme="http://bestlixiang.site/categories/HelloWorld/"/>
    
    
      <category term="Spring" scheme="http://bestlixiang.site/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="http://bestlixiang.site/tags/SpringMVC/"/>
    
      <category term="Mybatis" scheme="http://bestlixiang.site/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Mybatis(二)_Mybatis工作原理</title>
    <link href="http://bestlixiang.site/2018/04/16/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Mybatis-%E4%BA%8C-Mybatis%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://bestlixiang.site/2018/04/16/深入SSM/揭秘Mybatis-二-Mybatis工作原理/</id>
    <published>2018-04-16T07:38:03.000Z</published>
    <updated>2018-04-16T07:38:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：了解完Mybatis的架构，那么它的执行流程又是怎么样的呢？<a id="more"></a></p>
<h1 id="Mybatis主要组件及工作流程"><a href="#Mybatis主要组件及工作流程" class="headerlink" title="Mybatis主要组件及工作流程"></a>Mybatis主要组件及工作流程</h1><h2 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h2><ol>
<li>Configuration：MyBatis所有的配置信息都维持在Configuration对象之中</li>
<li>SqlSession：作为MyBatis接口层的AOP，表示和数据库交互的会话，完成必要数据库增删改查功能</li>
<li>Executor：MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护</li>
<li>StatementHandler：封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合</li>
<li>ParameterHandler：负责对用户传递的参数转换成JDBC Statement 所需要的参数</li>
<li>resultSetHandler：负责将JDBC返回的ResultSet结果集对象转换成List类型的集合</li>
<li>TypeHandler：负责java数据类型和jdbc数据类型之间的映射和转换</li>
<li>MappedStatement：MappedStatement维护了一条<select|update|delete|insert>节点的封装</select|update|delete|insert></li>
<li>SqlSource：负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回</li>
<li>BoundSql：表示动态生成的SQL语句以及相应的参数信息</li>
</ol>
<h2 id="工作流程图"><a href="#工作流程图" class="headerlink" title="工作流程图"></a>工作流程图</h2><p><img src="https://upload-images.jianshu.io/upload_images/2062729-a2f20529d6d908a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="workflow"></p>
<p>这张图也超级棒（Nice 兄Dei），在下面参考也将看到出处。我们下面的源码分析也会参考这张图。</p>
<h1 id="Mybatis初始化源码分析"><a href="#Mybatis初始化源码分析" class="headerlink" title="Mybatis初始化源码分析"></a>Mybatis初始化源码分析</h1><ol>
<li><p>获取配置文件创建SqlSessionFactory</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String resource = &quot;mybatis-config.xml&quot;;</div><div class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</div><div class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</div></pre></td></tr></table></figure>
</li>
<li><p>进入到SqlSessionFactory的build方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</div><div class="line">    SqlSessionFactory var5;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 解析刚刚创建的配置文件文件流</span></div><div class="line">        XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</div><div class="line">        var5 = <span class="keyword">this</span>.build(parser.parse());</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception var14) &#123;</div><div class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, var14);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        ErrorContext.instance().reset();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            inputStream.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException var13) &#123;</div><div class="line">            ;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> var5;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>会进入到XMLConfigBuilder的parse方法去解析配置文件的具体内容生成Configuration对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.parsed) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.parsed = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">// 解析配置文件</span></div><div class="line">        <span class="keyword">this</span>.parseConfiguration(<span class="keyword">this</span>.parser.evalNode(<span class="string">"/configuration"</span>));</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.configuration;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 解析&lt;properties&gt;节点，数据源配置文件</span></div><div class="line">        <span class="keyword">this</span>.propertiesElement(root.evalNode(<span class="string">"properties"</span>));</div><div class="line">        <span class="comment">// 解析&lt;typeAliases&gt;节点，别名节点</span></div><div class="line">        <span class="keyword">this</span>.typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</div><div class="line">        <span class="comment">// 解析&lt;plugins&gt;节点，插件节点</span></div><div class="line">        <span class="keyword">this</span>.pluginElement(root.evalNode(<span class="string">"plugins"</span>));</div><div class="line">        <span class="comment">// 解析&lt;objectFactory&gt;节点</span></div><div class="line">        <span class="keyword">this</span>.objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</div><div class="line">        <span class="comment">// 解析&lt;reflectorFactory&gt;节点</span></div><div class="line">        <span class="keyword">this</span>.objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</div><div class="line">        <span class="comment">// 解析&lt;settings&gt;节点</span></div><div class="line">        <span class="keyword">this</span>.settingsElement(root.evalNode(<span class="string">"settings"</span>));</div><div class="line">        <span class="comment">// 解析&lt;environments&gt;节点</span></div><div class="line">        <span class="keyword">this</span>.environmentsElement(root.evalNode(<span class="string">"environments"</span>));</div><div class="line">        <span class="keyword">this</span>.databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</div><div class="line">        <span class="keyword">this</span>.typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</div><div class="line">        <span class="comment">// 解析&lt;mappers&gt;节点，很重要</span></div><div class="line">        <span class="keyword">this</span>.mapperElement(root.evalNode(<span class="string">"mappers"</span>));</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception var3) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + var3, var3);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>我们最关心的可能就是mapper的解析了，所以我们进入mapperElement方法看看：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</div><div class="line">            Iterator i$ = parent.getChildren().iterator();</div><div class="line"></div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">                <span class="comment">// 遍历&lt;mappers&gt;下所有子节点</span></div><div class="line">                <span class="keyword">while</span>(i$.hasNext()) &#123;</div><div class="line">                    XNode child = (XNode)i$.next();</div><div class="line">                    String resource;</div><div class="line">                    <span class="comment">// 如果当前节点为&lt;package&gt;</span></div><div class="line">                    <span class="keyword">if</span>(<span class="string">"package"</span>.equals(child.getName())) &#123;</div><div class="line">                        <span class="comment">// 获取&lt;package&gt;的name属性（该属性值为mapper class所在的包名）</span></div><div class="line">                        resource = child.getStringAttribute(<span class="string">"name"</span>);</div><div class="line">                        <span class="comment">// 将该包下的所有Mapper Class注册到configuration的mapperRegistry容器中</span></div><div class="line">                        <span class="keyword">this</span>.configuration.addMappers(resource);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// 依次获取resource、url、class属性</span></div><div class="line">                        resource = child.getStringAttribute(<span class="string">"resource"</span>);</div><div class="line">                        String url = child.getStringAttribute(<span class="string">"url"</span>);</div><div class="line">                        String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</div><div class="line">                        XMLMapperBuilder mapperParser;</div><div class="line">                        InputStream inputStream;</div><div class="line">                        <span class="comment">// 解析resource属性（Mapper.xml文件的路径）</span></div><div class="line">                        <span class="keyword">if</span>(resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</div><div class="line">                            ErrorContext.instance().resource(resource);</div><div class="line">                            <span class="comment">// 将Mapper.xml文件解析成输入流</span></div><div class="line">                            inputStream = Resources.getResourceAsStream(resource);</div><div class="line">                            <span class="comment">// 使用XMLMapperBuilder解析Mapper.xml，并将Mapper Class注册进configuration对象的mapperRegistry容器中</span></div><div class="line">                            mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, <span class="keyword">this</span>.configuration, resource, <span class="keyword">this</span>.configuration.getSqlFragments());</div><div class="line">                            <span class="comment">// 这个很重要，看看具体怎么解析</span></div><div class="line">                            mapperParser.parse();</div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</div><div class="line">                            <span class="comment">// 解析url属性（Mapper.xml文件的路径）</span></div><div class="line">                            ErrorContext.instance().resource(url);</div><div class="line">                            inputStream = Resources.getUrlAsStream(url);</div><div class="line">                            mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, <span class="keyword">this</span>.configuration, url, <span class="keyword">this</span>.configuration.getSqlFragments());</div><div class="line">                            mapperParser.parse();</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="comment">// 解析class属性（Mapper Class的全限定名）</span></div><div class="line">                            <span class="keyword">if</span>(resource != <span class="keyword">null</span> || url != <span class="keyword">null</span> || mapperClass == <span class="keyword">null</span>) &#123;</div><div class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</div><div class="line">                            &#125;</div><div class="line">                            <span class="comment">// 将Mapper Class的权限定名转化成Class对象</span></div><div class="line">                            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</div><div class="line">                            <span class="keyword">this</span>.configuration.addMapper(mapperInterface);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.configuration.isResourceLoaded(<span class="keyword">this</span>.resource)) &#123;</div><div class="line">        <span class="comment">// 解析&lt;mapper&gt;节点</span></div><div class="line">        <span class="keyword">this</span>.configurationElement(<span class="keyword">this</span>.parser.evalNode(<span class="string">"/mapper"</span>));</div><div class="line">        <span class="comment">// 将该Mapper.xml添加至configuration的LoadedResource容器中，下回无需再解析</span></div><div class="line">        <span class="keyword">this</span>.configuration.addLoadedResource(<span class="keyword">this</span>.resource);</div><div class="line">        <span class="comment">// 将该Mapper.xml对应的Mapper Class注册进configuration的mapperRegistry容器中，很重要，下马需要仔细看看</span></div><div class="line">        <span class="keyword">this</span>.bindMapperForNamespace();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.parsePendingResultMaps();</div><div class="line">    <span class="keyword">this</span>.parsePendingChacheRefs();</div><div class="line">    <span class="keyword">this</span>.parsePendingStatements();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>bindMapperForNamespace极其重要，因为这里会给Mapper接口创建动态代理对象，我们看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMapperForNamespace</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 获取当前映射文件对应的DAO接口的全限定名</span></div><div class="line">        String namespace = <span class="keyword">this</span>.builderAssistant.getCurrentNamespace();</div><div class="line">        <span class="keyword">if</span>(namespace != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 将全限定名解析成Class对象</span></div><div class="line">            Class boundType = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                boundType = Resources.classForName(namespace);</div><div class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var4) &#123;</div><div class="line">                ;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(boundType != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.configuration.hasMapper(boundType)) &#123;</div><div class="line">                <span class="comment">// 将当前Mapper.xml标注为已加载下回就不用再加载了</span></div><div class="line">                <span class="keyword">this</span>.configuration.addLoadedResource(<span class="string">"namespace:"</span> + namespace);</div><div class="line">                <span class="comment">// 将Mapper接口的Class对象注册进configuration中（其实是在configuration的MapperRegistry里面）</span></div><div class="line">                <span class="keyword">this</span>.configuration.addMapper(boundType);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>我们再进入到this.configuration.addMapper方法中看看会做些什么：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.mapperRegistry.addMapper(type);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(type.isInterface()) &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.hasMapper(type)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is already known to the MapperRegistry."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 创建MapperProxyFactory对象（用于创建DAO接口的代理对象），并put进knownMappers中</span></div><div class="line">            <span class="comment">// 为后面的创建Mapper代理对象做准备</span></div><div class="line">            <span class="keyword">this</span>.knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory(type));</div><div class="line">            MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(<span class="keyword">this</span>.config, type);</div><div class="line">            parser.parse();</div><div class="line">            loadCompleted = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span>(!loadCompleted) &#123;</div><div class="line">                <span class="keyword">this</span>.knownMappers.remove(type);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>等Mapper全都解析好之后，初始化工作基本就完成了。</p>
</li>
</ol>
<h1 id="Mybatis工作流程源码分析"><a href="#Mybatis工作流程源码分析" class="headerlink" title="Mybatis工作流程源码分析"></a>Mybatis工作流程源码分析</h1><ol>
<li><p>创建SqlSession对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 从数据源创建SqlSession会话对象</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.openSessionFromDataSource(<span class="keyword">this</span>.configuration.getDefaultExecutorType(), (TransactionIsolationLevel)<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</div><div class="line">    Transaction tx = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    DefaultSqlSession var8;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 初始化读取了Environment里面的数据源以及事务配置</span></div><div class="line">        Environment environment = <span class="keyword">this</span>.configuration.getEnvironment();</div><div class="line">        <span class="comment">// 获取事务工厂</span></div><div class="line">        TransactionFactory transactionFactory = <span class="keyword">this</span>.getTransactionFactoryFromEnvironment(environment);</div><div class="line">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</div><div class="line">        <span class="comment">// 生成MyBatis执行器</span></div><div class="line">        Executor executor = <span class="keyword">this</span>.configuration.newExecutor(tx, execType);</div><div class="line">        <span class="comment">// 创建DefaultSqlSession对象</span></div><div class="line">        var8 = <span class="keyword">new</span> DefaultSqlSession(<span class="keyword">this</span>.configuration, executor, autoCommit);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception var12) &#123;</div><div class="line">        <span class="keyword">this</span>.closeTransaction(tx);</div><div class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + var12, var12);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        ErrorContext.instance().reset();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> var8;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>从SqlSession对象获得Mapper（后面会看到这是个代理对象），看看执行流程：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</div><div class="line">    <span class="comment">// 进入configuration</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.configuration.getMapper(type, <span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</div><div class="line">    <span class="comment">// 调用configuration对象的apperRegistry的getMapper方法</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mapperRegistry.getMapper(type, sqlSession);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</div><div class="line">    <span class="comment">// 这个是在初始化过程中解析mapper时生成的，现有看到了Mapper对象的工厂</span></div><div class="line">    MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory)<span class="keyword">this</span>.knownMappers.get(type);</div><div class="line">    <span class="keyword">if</span>(mapperProxyFactory == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 生成Mapper实例，进入看看</span></div><div class="line">            <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + var5, var5);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</div><div class="line">    <span class="comment">// 原来这个还是个代理对象</span></div><div class="line">    MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy(sqlSession, <span class="keyword">this</span>.mapperInterface, <span class="keyword">this</span>.methodCache);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.newInstance(mapperProxy);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>获得Mapper代理对象我看看他是怎么执行Mapper接口的方法的：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">List&lt;User&gt; userList = userMapper.selectList();</div><div class="line"></div><div class="line"><span class="comment">// 一进去就发现直接到了invoke方法，相当于把方法的执行都交给了代理对象去执行</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="keyword">if</span>(Object.class.equals(method.getDeclaringClass())) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</div><div class="line">            <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(var5);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 从当前代理对象处理类MapperProxy的methodCache属性中获取MapperMethod对象,如果methodCache中没有就创建并加进去。</span></div><div class="line">        MapperMethod mapperMethod = <span class="keyword">this</span>.cachedMapperMethod(method);</div><div class="line">        <span class="comment">// 该方法就会调用JDBC执行相应的SQL语句</span></div><div class="line">        <span class="keyword">return</span> mapperMethod.execute(<span class="keyword">this</span>.sqlSession, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</div><div class="line">    Object param;</div><div class="line">    Object result;</div><div class="line">    <span class="comment">// 比对mapper标签</span></div><div class="line">    <span class="keyword">if</span>(SqlCommandType.INSERT == <span class="keyword">this</span>.command.getType()) &#123;</div><div class="line">        param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = <span class="keyword">this</span>.rowCountResult(sqlSession.insert(<span class="keyword">this</span>.command.getName(), param));</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(SqlCommandType.UPDATE == <span class="keyword">this</span>.command.getType()) &#123;</div><div class="line">        param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = <span class="keyword">this</span>.rowCountResult(sqlSession.update(<span class="keyword">this</span>.command.getName(), param));</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(SqlCommandType.DELETE == <span class="keyword">this</span>.command.getType()) &#123;</div><div class="line">        param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = <span class="keyword">this</span>.rowCountResult(sqlSession.delete(<span class="keyword">this</span>.command.getName(), param));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(SqlCommandType.SELECT != <span class="keyword">this</span>.command.getType()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + <span class="keyword">this</span>.command.getName());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.method.returnsVoid() &amp;&amp; <span class="keyword">this</span>.method.hasResultHandler()) &#123;</div><div class="line">            <span class="keyword">this</span>.executeWithResultHandler(sqlSession, args);</div><div class="line">            result = <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.method.returnsMany()) &#123;</div><div class="line">            <span class="comment">// 最终会进入这里</span></div><div class="line">            result = <span class="keyword">this</span>.executeForMany(sqlSession, args);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.method.returnsMap()) &#123;</div><div class="line">            result = <span class="keyword">this</span>.executeForMap(sqlSession, args);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</div><div class="line">            result = sqlSession.selectOne(<span class="keyword">this</span>.command.getName(), param);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(result == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.method.getReturnType().isPrimitive() &amp;&amp; !<span class="keyword">this</span>.method.returnsVoid()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + <span class="keyword">this</span>.command.getName() + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + <span class="keyword">this</span>.method.getReturnType() + <span class="string">")."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>MapperMethod到底如何去执行executeForMap(sqlSession, args)的呢？我们可以继续进入：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 将参数拼接到SQL</span></div><div class="line">        Object param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</div><div class="line">        List result;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.method.hasRowBounds()) &#123;</div><div class="line">            RowBounds rowBounds = <span class="keyword">this</span>.method.extractRowBounds(args);</div><div class="line">            result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param, rowBounds);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 进入到这里，让sqlSession来处理</span></div><div class="line">            result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.method.getReturnType().isAssignableFrom(result.getClass())?(<span class="keyword">this</span>.method.getReturnType().isArray()?<span class="keyword">this</span>.convertToArray(result):<span class="keyword">this</span>.convertToDeclaredCollection(sqlSession.getConfiguration(), result)):result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.selectList(statement, parameter, RowBounds.DEFAULT);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</div><div class="line">    List var6;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 根据StatementId(com.todorex.UserMapper.selectList)，</span></div><div class="line">        <span class="comment">// 在配置对象Configuration中查找相对应的MappedStatement</span></div><div class="line">        MappedStatement ms = <span class="keyword">this</span>.configuration.getMappedStatement(statement);</div><div class="line">        <span class="comment">// 将查询任务委托给MyBatis 的执行器 Executor</span></div><div class="line">        List&lt;E&gt; result = <span class="keyword">this</span>.executor.query(ms, <span class="keyword">this</span>.wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</div><div class="line">        var6 = result;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception var10) &#123;</div><div class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + var10, var10);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        ErrorContext.instance().reset();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> var6;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="comment">// 根据具体传入的参数，动态地生成需要执行的SQL语句，用BoundSql对象表示</span></div><div class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);</div><div class="line">    <span class="comment">// 为当前的查询创建一个缓存Key  </span></div><div class="line">    CacheKey key = <span class="keyword">this</span>.createCacheKey(ms, parameterObject, rowBounds, boundSql);</div><div class="line">    <span class="comment">// 再进去</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="comment">// 获得缓存对象</span></div><div class="line">    Cache cache = ms.getCache();</div><div class="line">    <span class="keyword">if</span>(cache != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.flushCacheIfRequired(ms);</div><div class="line">        <span class="keyword">if</span>(ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.ensureNoOutParams(ms, parameterObject, boundSql);</div><div class="line">            <span class="comment">// 如果缓存中有查询结果，则返回查询结果</span></div><div class="line">            List&lt;E&gt; list = (List)<span class="keyword">this</span>.tcm.getObject(cache, key);</div><div class="line">            <span class="keyword">if</span>(list == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// 如果缓存中没有查询结果则查询数据库</span></div><div class="line">                list = <span class="keyword">this</span>.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</div><div class="line">                <span class="comment">// 将查询结果放入缓存中</span></div><div class="line">                <span class="keyword">this</span>.tcm.putObject(cache, key, list);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> list;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果没有缓存对象则查询数据库（进入这里）</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.closed) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</div><div class="line">            <span class="keyword">this</span>.clearLocalCache();</div><div class="line">        &#125;</div><div class="line">        List list;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ++<span class="keyword">this</span>.queryStack;</div><div class="line">            list = resultHandler == <span class="keyword">null</span>?(List)<span class="keyword">this</span>.localCache.getObject(key):<span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span>(list != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">this</span>.handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 缓存中没有值，直接从数据库中读取数据（进入这里）</span></div><div class="line">                list = <span class="keyword">this</span>.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            --<span class="keyword">this</span>.queryStack;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="keyword">this</span>.localCache.putObject(key, ExecutionPlaceholder.EXECUTION_PLACEHOLDER);</div><div class="line">    List list;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 执行查询返回List 结果（进入这里）</span></div><div class="line">        list = <span class="keyword">this</span>.doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// 清楚之前的缓存</span></div><div class="line">        <span class="keyword">this</span>.localCache.removeObject(key);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将查询的结果放入缓存之中</span></div><div class="line">    <span class="keyword">this</span>.localCache.putObject(key, list);</div><div class="line">    <span class="keyword">if</span>(ms.getStatementType() == StatementType.CALLABLE) &#123;</div><div class="line">        <span class="keyword">this</span>.localOutputParameterCache.putObject(key, parameter);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    Statement stmt = <span class="keyword">null</span>;</div><div class="line">    List var9;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Configuration configuration = ms.getConfiguration();</div><div class="line">        <span class="comment">// 创建StatementHandler对象来执行查询操作  </span></div><div class="line">        StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>.wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</div><div class="line">        <span class="comment">// 利用StatementHandler对象创建java.Sql.Statement对象（进入这里）</span></div><div class="line">        stmt = <span class="keyword">this</span>.prepareStatement(handler, ms.getStatementLog());</div><div class="line">        <span class="comment">// 调用StatementHandler.query()方法，返回List结果集 （进入这里）</span></div><div class="line">        var9 = handler.query(stmt, resultHandler);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">this</span>.closeStatement(stmt);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> var9;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="comment">// 创建连接</span></div><div class="line">    Connection connection = <span class="keyword">this</span>.getConnection(statementLog);</div><div class="line">    <span class="comment">// 创建java.Sql.Statement对象，传递给StatementHandler对象</span></div><div class="line">    Statement stmt = handler.prepare(connection);</div><div class="line">    <span class="comment">// 对创建的Statement对象设置参数，即设置SQL语句中占位符设置为指定的参数</span></div><div class="line">    handler.parameterize(stmt);</div><div class="line">    <span class="keyword">return</span> stmt;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="comment">// 调用preparedStatemnt的execute()方法，然后将resultSet交给ResultSetHandler处理</span></div><div class="line">    PreparedStatement ps = (PreparedStatement)statement;</div><div class="line">    ps.execute();</div><div class="line">    <span class="comment">// 使用ResultHandler来处理ResultSet（进入这里）</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.resultSetHandler.handleResultSets(ps);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>终于查询完了，现在可以处理结果了，我们看看handleResultSets(Statement stmt)方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    ErrorContext.instance().activity(<span class="string">"handling results"</span>).object(<span class="keyword">this</span>.mappedStatement.getId());</div><div class="line">    <span class="comment">// 最后的结果集</span></div><div class="line">    List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList();</div><div class="line">    <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</div><div class="line">    ResultSetWrapper rsw = <span class="keyword">this</span>.getFirstResultSet(stmt);</div><div class="line">    List&lt;ResultMap&gt; resultMaps = <span class="keyword">this</span>.mappedStatement.getResultMaps();</div><div class="line">    <span class="keyword">int</span> resultMapCount = resultMaps.size();</div><div class="line">    <span class="keyword">this</span>.validateResultMapsCount(rsw, resultMapCount);</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</div><div class="line">        <span class="comment">// 获得resultMap</span></div><div class="line">        ResultMap resultMap = (ResultMap)resultMaps.get(resultSetCount);</div><div class="line">        <span class="comment">// 这里才开始处理（这里自己去看吧，反正会先处理行值，然后映射成对象，和JDBC一样）</span></div><div class="line">        <span class="keyword">this</span>.handleResultSet(rsw, resultMap, multipleResults, (ResultMapping)<span class="keyword">null</span>);</div><div class="line">        rsw = <span class="keyword">this</span>.getNextResultSet(stmt);</div><div class="line">        <span class="keyword">this</span>.cleanUpAfterHandlingResultSet();</div><div class="line">        ++resultSetCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    String[] resultSets = <span class="keyword">this</span>.mappedStatement.getResulSets();</div><div class="line">    <span class="keyword">if</span>(resultSets != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">while</span>(rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</div><div class="line">            ResultMapping parentMapping = (ResultMapping)<span class="keyword">this</span>.nextResultMaps.get(resultSets[resultSetCount]);</div><div class="line">            <span class="keyword">if</span>(parentMapping != <span class="keyword">null</span>) &#123;</div><div class="line">                String nestedResultMapId = parentMapping.getNestedResultMapId();</div><div class="line">                ResultMap resultMap = <span class="keyword">this</span>.configuration.getResultMap(nestedResultMapId);</div><div class="line">                <span class="keyword">this</span>.handleResultSet(rsw, resultMap, (List)<span class="keyword">null</span>, parentMapping);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            rsw = <span class="keyword">this</span>.getNextResultSet(stmt);</div><div class="line">            <span class="keyword">this</span>.cleanUpAfterHandlingResultSet();</div><div class="line">            ++resultSetCount;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.collapseSingleResultList(multipleResults);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/ec40a82cae28" target="_blank" rel="external">终结篇：MyBatis原理深入解析（一）</a></li>
<li><a href="https://blog.csdn.net/u010425776/article/details/78215845" target="_blank" rel="external"> MyBatis源码解析(二)——动态代理实现函数调用</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：了解完Mybatis的架构，那么它的执行流程又是怎么样的呢？
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Mybatis" scheme="http://bestlixiang.site/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Mybatis(一)_Mybatis架构</title>
    <link href="http://bestlixiang.site/2018/04/16/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Mybatis-%E4%B8%80-Mybatis%E6%9E%B6%E6%9E%84/"/>
    <id>http://bestlixiang.site/2018/04/16/深入SSM/揭秘Mybatis-一-Mybatis架构/</id>
    <published>2018-04-16T07:37:53.000Z</published>
    <updated>2018-04-16T07:38:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：从JDBC到Hibernate再到Mybatis，你可能会使用很多框架，但是你却不知道框架为你解决什么了或是不知道它的整个架构，我们这里就是帮你解决这些问题！<a id="more"></a></p>
<h1 id="为什么要使用Mybatis"><a href="#为什么要使用Mybatis" class="headerlink" title="为什么要使用Mybatis"></a>为什么要使用Mybatis</h1><h2 id="JDBC的使用"><a href="#JDBC的使用" class="headerlink" title="JDBC的使用"></a>JDBC的使用</h2><p>每一个人学Java的数据库操作应该都是从JDBC开始，它基本有以下7个步骤：</p>
<ol>
<li>加载JDBC驱动</li>
<li>建立并获取数据库连接</li>
<li>创建 JDBC Statements 对象</li>
<li>设置SQL语句的传入参数</li>
<li>执行SQL语句并获得查询结果</li>
<li>对查询结果进行转换处理并将处理结果返回；</li>
<li>释放相关资源（关闭Connection，关闭Statement，关闭ResultSet）；</li>
</ol>
<h2 id="JDBC相应的问题"><a href="#JDBC相应的问题" class="headerlink" title="JDBC相应的问题"></a>JDBC相应的问题</h2><ol>
<li>数据库连接频繁的开启和关闭本身就造成了资源的浪费，影响系统的性能</li>
<li>SQL语句基本都散落在各个JAVA类中可读性很差，不利于维护以及做性能调优。</li>
<li>在后台代码中自己需要根据请求的传入参数（参数个数和顺序都不确定）去拼凑相应的SQL语句。</li>
<li>执行SQL语句后，返回的是一个ResultSet结果集，这个时候我们就需要将ResultSet对象的数据取出来，不然等到释放资源时就取不到这些结果信息了。</li>
<li>SQL重复的问题，不利于维护和复用。</li>
</ol>
<h2 id="Mybatis相应的解决"><a href="#Mybatis相应的解决" class="headerlink" title="Mybatis相应的解决"></a>Mybatis相应的解决</h2><ol>
<li>数据库连接的获取和关闭我们可以使用数据库连接池来解决资源浪费的问题。通过连接池就可以反复利用已经建立的连接去访问数据库了。减少连接的开启和关闭的时间。（数据库连接池以及数据源的配置）</li>
<li>将这些SQL语句统一集中放到配置文件或者数据库里面（以key-value的格式存放）。然后通过SQL语句的key值去获取对应的SQL语句。（Mapper文件）</li>
<li>使用一种有别于SQL的语法来嵌入变量（比如使用＃变量名）。这样，SQL语句经过解析后就可以动态的生成符合上下文的SQL语句。（Mapper文件里面的SQL语句）</li>
<li>将结果不做任何处理就直接返回，也有可能将结果转换成一个JavaBean对象返回、一个Map返回、一个List返回等，而且可以将SQL语句和传入参数两部分合起来可以作为数据缓存的key值。（语句标签返回结果的配置）</li>
<li>将重复的代码抽离出来成为独立的一个类，然后在各个需要使用的地方进行引用（SQL代码块）</li>
</ol>
<h1 id="Mybatis架构"><a href="#Mybatis架构" class="headerlink" title="Mybatis架构"></a>Mybatis架构</h1><p><img src="https://upload-images.jianshu.io/upload_images/2062729-58069e90e9c66d5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="mybatis"></p>
<p>这张图超级棒，可以在后面的参考找到出处。我们就按照这个4层进行分析：</p>
<h2 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h2><p>接口调用方式主要有以下两种：</p>
<ol>
<li><p>基于StatementId(命名空间+语句id)，范例如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;?&gt;|<span class="keyword">int</span>|<span class="keyword">void</span> sqlSession select|update|delete|insert(statementId,params)</div></pre></td></tr></table></figure>
</li>
<li><p>基于Mapper接口</p>
<p> MyBatis 将配置文件中的每一个<mapper> 节点抽象为一个 Mapper 接口,这个接口中声明的方法和<mapper> 节点中的<select|update|delete|insert> 节点项对应，即<select|update|delete|insert> 节点的id值为Mapper 接口中的方法名称，parameterType 值表示Mapper 对应方法的入参类型，而resultMap 值则对应了Mapper 接口表示的返回值类型或者返回结果集的元素类型。范例如下：</select|update|delete|insert></select|update|delete|insert></mapper></mapper></p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;mapper namespace="com.todorex.UserMapper"&gt;</div><div class="line">    &lt;select id="selectList" resultType="com.todorex.User"&gt;</div><div class="line">        select * from user</div><div class="line">    &lt;/select&gt;</div><div class="line">&lt;/mapper&gt;</div><div class="line"></div><div class="line">public interface UserMapper &#123;</div><div class="line"></div><div class="line">    List&lt;User&gt; selectList();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 根据MyBatis 的配置规范配置好后，通过SqlSession.getMapper(UserMapper.class)方法，MyBatis会根据相应的接口声明的方法信息，通过<strong>动态代理机 制</strong> 生成一个Mapper 实例，我们调用Mapper接口的某一个方法时，MyBatis会根据这个方法的方法名和参数类型，确定StatementId，底层还是通过StatementId来实现对数据库的操作，MyBatis引用Mapper接口这种调用方式是为了满足面向接口编程的需 要。<strong>（其实还有一个原因是在于，面向接口的编程，使得用户在接口上可以使用注解来配置SQL语句，这样就可以脱离XML配置文件）</strong>。</p>
</li>
</ol>
<h2 id="数据处理层"><a href="#数据处理层" class="headerlink" title="数据处理层"></a>数据处理层</h2><p>数据处理层可以说是MyBatis的核心，它要完成两个功能：</p>
<ol>
<li><p>通过传入参数构建动态SQL语句</p>
<p> MyBatis 通过传入的参数值，使用 OGNL表达式 来动态地构造SQL语句，使得MyBatis有很强的灵活性和扩展性。参数映射指的是对于java 数据类型和jdbc数据类型之间的转换：这里有包括两个过程：</p>
<ol>
<li>查询阶段，我们要将java类型的数据，转换成jdbc类型的数据，通过 preparedStatement.setXXX() 来设值</li>
<li>返回阶段，我们要对resultset查询结果集的jdbcType 数据转换成java 数据类型</li>
</ol>
</li>
<li><p>SQL语句的执行以及封装查询结果集成List<e></e></p>
<p> 动态SQL语句生成之后，MyBatis 将执行SQL语句，并将可能返回的结果集转换成List<e> 列表。MyBatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换，并且有两种支持方式，一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询。</e></p>
</li>
</ol>
<h2 id="框架支持层"><a href="#框架支持层" class="headerlink" title="框架支持层"></a>框架支持层</h2><ol>
<li><p>事务管理机制</p>
<p> 事务管理机制对于ORM框架而言是不可缺少的一部分，事务管理机制的质量也是考量一个ORM框架是否优秀的一个标准。</p>
</li>
<li><p>连接池管理机制</p>
<p> 由于创建一个数据库连接所占用的资源比较大，对于数据吞吐量大和访问量非常大的应用而言，连接池的设计就显得非常重要。</p>
</li>
<li><p>缓存机制<br> 为了提高数据利用率和减小服务器和数据库的压力，MyBatis 会对于一些查询提供会话级别的数据缓存，会将对某一次查询，放置到SqlSession 中，在允许的时间间隔内，对于完全相同的查询，MyBatis会直接将缓存结果返回给用户，而不用再到数据库中查找。</p>
</li>
<li><p>SQL语句的配置方式<br> 传统的MyBatis 配置SQL语句方式就是使用XML文件进行配置的，但是这种方式不能很好地支持面向接口编程的理念，为了支持面向接口的编程，MyBatis 引入了Mapper接口的概念，面向接口的引入，对使用注解来配置SQL语句成为可能，用户只需要在接口上添加必要的注解即可，不用再去配置XML文件了，但是，目前的MyBatis 只是对注解配置SQL语句提供了有限的支持，某些高级功能还是要依赖XML配置文件配置SQL 语句。</p>
</li>
</ol>
<h2 id="引导层"><a href="#引导层" class="headerlink" title="引导层"></a>引导层</h2><p>引导层是配置和启动MyBatis配置信息的方式。MyBatis 提供两种方式来引导MyBatis：</p>
<ul>
<li><p>基于XML配置文件的方式</p>
</li>
<li><p>基于Java API 的方式</p>
</li>
</ul>
<p>范例可以查看官方使用手册：<a href="http://www.mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="external">Mybatis官方使用手册</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/ec40a82cae28" target="_blank" rel="external">终结篇：MyBatis原理深入解析（一）</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：从JDBC到Hibernate再到Mybatis，你可能会使用很多框架，但是你却不知道框架为你解决什么了或是不知道它的整个架构，我们这里就是帮你解决这些问题！
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Mybatis" scheme="http://bestlixiang.site/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>揭秘SpringMVC(一)_.SpringMVC大全解</title>
    <link href="http://bestlixiang.site/2018/04/15/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98SpringMVC-%E4%B8%80-SpringMVC%E5%A4%A7%E5%85%A8%E8%A7%A3/"/>
    <id>http://bestlixiang.site/2018/04/15/深入SSM/揭秘SpringMVC-一-SpringMVC大全解/</id>
    <published>2018-04-15T08:55:34.000Z</published>
    <updated>2018-04-15T08:56:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：现在基于所有的Web应用都离不开Spring，用了Spring，你自然会去用他家的MVC框架——SpringMVC！所以掌握SpringMVC也是非常重要的。<a id="more"></a></p>
<h1 id="SpringMVC请求处理流程总览"><a href="#SpringMVC请求处理流程总览" class="headerlink" title="SpringMVC请求处理流程总览"></a>SpringMVC请求处理流程总览</h1><p>我们可以用下面一张图来介绍SpringMVC的核心组件和请求处理流程：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/springmvc.png" alt="springmvc"></p>
<p>流程中出现的核心组件如下：</p>
<ol>
<li>DispatcherServlet是springmvc中的前端控制器，负责接收request并将request转发给对应的处理组件.</li>
<li>HanlerMapping是springmvc中完成url到controller映射的组件.DispatcherServlet接收request,然后从HandlerMapping查找处理request的controller.</li>
<li>Controller（HandlerAdapter）处理request,并返回ModelAndView对象,Controller是springmvc中负责处理request的组件(类似于struts2中的Action)</li>
<li>ModelAndView是封装Model对象和View对象的组件</li>
<li>ViewResolver是视图解析器，负责解析ModelAndView对象生成对应的View对象</li>
<li>View视图组件，复制渲染页面</li>
</ol>
<p>整个流程的大致流程如下：</p>
<ol>
<li>当request到来时，DispatcherServlet对request进行捕获，并执行doService方法，继而执行doDispatch方法。</li>
<li>HandlerMapping解析请求，并且返回HandlerExecutionChain（其中包含对应的controller和interceptors）</li>
<li>通过HandlerExecutionChain得到Handler相关类，Handler先执行拦截器的pre相关方法，接着执行handler方法，最后调用拦截器的post相关方法</li>
<li>解析handler方法返回的ModelAndView</li>
<li>根据ViewResolver（可以在配置文件中配置，也就是视图解析器）生成View对象</li>
<li>View对象渲染页面并response给客户端</li>
</ol>
<h1 id="SpringMVC请求处理初始化源码分析"><a href="#SpringMVC请求处理初始化源码分析" class="headerlink" title="SpringMVC请求处理初始化源码分析"></a>SpringMVC请求处理初始化源码分析</h1><ol>
<li><p>首先，Tomcat每次启动时都会加载并解析/WEB-INF/web.xml文件，所以可以先从web.xml找突破口（DispatcherServlet的配置），主要代码如下（我们每次都会这样配置）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;servlet &gt;</div><div class="line">    &lt;servlet-name &gt;spring-mvc&lt;/servlet-name&gt;</div><div class="line">    &lt;!-- DispatcherServlet类，这个类在spring-mvc的包下面 --&gt;</div><div class="line">    &lt;servlet-class &gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</div><div class="line">    &lt;!-- 初始化参数，这里主要是读取SpringMVC的一些配置信息，比如：</div><div class="line">    配置注解驱动，静态资源映射，视图解析器，自动扫描装配等相关信息。</div><div class="line">    --&gt;</div><div class="line">    &lt;init-param &gt;</div><div class="line">      &lt;param-name &gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">      &lt;param-value &gt;classpath:/spring-mvc.xml&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;!-- 启动时加载 --&gt;</div><div class="line">    &lt;load-on-startup &gt;1&lt;/load-on-startup&gt;</div><div class="line">  &lt;/servlet&gt;</div><div class="line">  &lt;servlet-mapping &gt;</div><div class="line">    &lt;servlet-name &gt;spring-mvc&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern &gt;/&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>进入DispatchServlet的分析，先看它的类图：</p>
<p> <img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/DispatcherServlet.png" alt="DispatchServlet"></p>
<p> 它是一个Servlet的子类，那么我们就要专注于它的init、service（后续分析）、doGet、doPost等相关方法，在它的父类HttpServeltBean，我们找到了init方法，如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 获取Servlet中的init参数，并创建了一个BeanWapper对象，由子类真正执行BeanWrapper的初始化工作</span></div><div class="line">        <span class="comment">// 但是HttpServeltBean的子类并没有覆盖其initBeanWrapper方法，所以创建的BeanWrapper没有用</span></div><div class="line">        PropertyValues pvs = <span class="keyword">new</span> HttpServletBean.ServletConfigPropertyValues(<span class="keyword">this</span>.getServletConfig(), <span class="keyword">this</span>.requiredProperties);</div><div class="line">        BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</div><div class="line">        ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(<span class="keyword">this</span>.getServletContext());</div><div class="line">        bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, <span class="keyword">this</span>.getEnvironment()));</div><div class="line">        <span class="keyword">this</span>.initBeanWrapper(bw);</div><div class="line">        bw.setPropertyValues(pvs, <span class="keyword">true</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (BeansException var4) &#123;</div><div class="line">        <span class="keyword">this</span>.logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"'"</span>, var4);</div><div class="line">        <span class="keyword">throw</span> var4;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 这里进要进入到Framework的initServletBean方法了</span></div><div class="line">    <span class="keyword">this</span>.initServletBean();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 从上面的init方法中，我们由它的initServletBean方法进入到FrameworkServlet的initServletBean方法，如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 创建Spring容器，并调用onRefresh方法来完成配置文件的加载</span></div><div class="line">        <span class="keyword">this</span>.webApplicationContext = <span class="keyword">this</span>.initWebApplicationContext();</div><div class="line">        <span class="keyword">this</span>.initFrameworkServlet();</div><div class="line">    &#125; <span class="keyword">catch</span> (ServletException var5) &#123;</div><div class="line">        <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, var5);</div><div class="line">        <span class="keyword">throw</span> var5;</div><div class="line">    &#125; <span class="keyword">catch</span> (RuntimeException var6) &#123;</div><div class="line">        <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, var6);</div><div class="line">        <span class="keyword">throw</span> var6;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 在容器加载的过程中会调用DispatchServlet的initStrategies方法来完成Dispatchservlet中定义的初始化工作，看DispatchServlet的源码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.initStrategies(context);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 初始化SpringMVC框架需要的8个组件，这8个组件对应8个bean对象保存在DispatchServlet类中</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">    <span class="comment">// 用于处理文件上传服务，将Request包装成DefaultMultipartHttpServletRequest</span></div><div class="line">    <span class="keyword">this</span>.initMultipartResolver(context);</div><div class="line">    <span class="comment">// 用于处理应用的国际化问题，控制应用中的字符编码问题</span></div><div class="line">    <span class="keyword">this</span>.initLocaleResolver(context);</div><div class="line">    <span class="comment">// 用于定义一个主题</span></div><div class="line">    <span class="keyword">this</span>.initThemeResolver(context);</div><div class="line">    <span class="comment">// 用于定义用户设置的请求映射关系，将用户请求的URL映射后才能一个个Handler实例</span></div><div class="line">    <span class="comment">// 如果没有定义HandlerMapping，将获取默认的BeanNameURLHandlerMapping和DefaultAnnotaionHandlerMapping</span></div><div class="line">    <span class="keyword">this</span>.initHandlerMappings(context);</div><div class="line">    <span class="comment">// 用于根据Handler的类型定义不同的处理规则（调用Controller实例），默认的为：</span></div><div class="line">    <span class="comment">// HttpRequestHandlerAdapter、SimpleControllerHandlerAdapter、ThrowawayControllerAdapter、AnnotationMethodHandlerAdapter</span></div><div class="line">    <span class="keyword">this</span>.initHandlerAdapters(context);</div><div class="line">    <span class="comment">// 当Handle处理出错时，会通过这个Handler来统一处理，默认为SimpleMappingExceptionResolver，</span></div><div class="line">    <span class="comment">// 将错误日志记录在日志文件中，并且跳转到默认的错误页面</span></div><div class="line">    <span class="keyword">this</span>.initHandlerExceptionResolvers(context);</div><div class="line">    <span class="comment">// 将指定的ViewName按照定义的requestToViewNameTranslator替换成想要的格式，如加上前缀或者后缀。</span></div><div class="line">    <span class="keyword">this</span>.initRequestToViewNameTranslator(context);</div><div class="line">    <span class="comment">// 用于将View解析成页面，在ViewResolvers中可以设置多个解析策略，默认的解析策略为InternalResourceViewResolver，按照JSP页面来解析</span></div><div class="line">    <span class="keyword">this</span>.initViewResolvers(context);</div><div class="line">    <span class="comment">// 为一个请求存储意图为另外一个请求所使用的属性提供了一条途径(通常存储在session)</span></div><div class="line">    <span class="keyword">this</span>.initFlashMapManager(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="SpringMVC请求处理流程源码分析"><a href="#SpringMVC请求处理流程源码分析" class="headerlink" title="SpringMVC请求处理流程源码分析"></a>SpringMVC请求处理流程源码分析</h1><p>关注完初始化init方法，我们要进入正式的流程分析了，其实就是在sevice方法里面(在其父类FrameworkServlet里)，我们看看下面的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span>(HttpMethod.PATCH.matches(request.getMethod())) &#123;</div><div class="line">        <span class="keyword">this</span>.processRequest(request, response);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">super</span>.service(request, response);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据service方法，我们一步步调试进入service –&gt; processRequest –&gt; doService（将ApplicationContext、localeResolver、themeResolver等对象添加到request中以便后面使用） –&gt; doDispatch，我们最终将目光定位在doDispatch，因为从它的方法体就可以看出它是整个SpringMVC的核心方法。我们看看DispatchServlet里面的doDispatch方法源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        HttpServletRequest processedRequest = request;</div><div class="line">        HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</div><div class="line">        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                ModelAndView mv = <span class="keyword">null</span>;</div><div class="line">                Exception dispatchException = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// //处理文件上传请求</span></div><div class="line">                    processedRequest = <span class="keyword">this</span>.checkMultipart(request);</div><div class="line">                    multipartRequestParsed = processedRequest != request;</div><div class="line">                    <span class="comment">// 解析请求（匹配URL），获取HandlerExecutionChain对象</span></div><div class="line">                    mappedHandler = <span class="keyword">this</span>.getHandler(processedRequest);</div><div class="line">                    <span class="keyword">if</span>(mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">this</span>.noHandlerFound(processedRequest, response);</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 从HandlerExecutionChain对象获取HandlerAdapter对象，实际上是从HandlerMapping对象中获取</span></div><div class="line">                    HandlerAdapter ha = <span class="keyword">this</span>.getHandlerAdapter(mappedHandler.getHandler());</div><div class="line">                    String method = request.getMethod();</div><div class="line">                    <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</div><div class="line">                    <span class="keyword">if</span>(isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</div><div class="line">                        <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</div><div class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</div><div class="line">                            <span class="keyword">this</span>.logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="keyword">if</span>((<span class="keyword">new</span> ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                   <span class="comment">// 在controller方法执行前，执行拦截器的相关方法（pre） if(!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span></div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 执行HandlerAdapter对象的handle方法，返回ModelAndView</span></div><div class="line">                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</div><div class="line">                    <span class="keyword">if</span>(asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">this</span>.applyDefaultViewName(processedRequest, mv);</div><div class="line">                   <span class="comment">// 在controller方法执行后，执行拦截器的相关方法（post）</span></div><div class="line">                   mappedHandler.applyPostHandle(processedRequest, response, mv);</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception var19) &#123;</div><div class="line">                    dispatchException = var19;</div><div class="line">                &#125;</div><div class="line">               <span class="comment">// 进行视图解析</span></div><div class="line">               <span class="keyword">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception var20) &#123;</div><div class="line">                <span class="keyword">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var20);</div><div class="line">            &#125; <span class="keyword">catch</span> (Error var21) &#123;</div><div class="line">                <span class="keyword">this</span>.triggerAfterCompletionWithError(processedRequest, response, mappedHandler, var21);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span>(asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">                <span class="keyword">if</span>(mappedHandler != <span class="keyword">null</span>) &#123;</div><div class="line">                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(multipartRequestParsed) &#123;</div><div class="line">                <span class="keyword">this</span>.cleanupMultipart(processedRequest);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>上面是整体的流程，下面我们具体到对MVC架构的三个模块的分析：</p>
<h2 id="Control（C）"><a href="#Control（C）" class="headerlink" title="Control（C）"></a>Control（C）</h2><p>Spring MVC的Control主要由HandlerMapping和HandlerAdapters两个组件提供。</p>
<p>HandlerMapping并没有规定这个URL与应用的处理类如何映射，在这个接口中只定义了根据URL必须返回一个由HandlerExecutionChain代理的处理链，我们可以在这里处理链中添加任意的HandlerAdapters实例来处理这个URL对应的请求。这个和Servlet规范中的filter处理是类似的。</p>
<h3 id="HandlerMapping的初始化"><a href="#HandlerMapping的初始化" class="headerlink" title="HandlerMapping的初始化"></a>HandlerMapping的初始化</h3><p><strong>（可以参照HandlerMapping的子类SimpleUrlHandlerMapping里面的initApplicationContext方法代码）</strong></p>
<p>HandlerMapping的初始化工作完成的两个最重要的工作就是将URL与Handler的对应关系保存在handlerMap集合中，并将所有的<strong>interceptors</strong>对象保存在adaptedInterceptors数组中，等到请求到来时执行所有的adaptedInterceptors数组中的Interceptor对象，所有的Interceptor对象必须实现HandlerInterceptor接口。</p>
<h3 id="HandlerAdapter-可以看成Controller-的初始化"><a href="#HandlerAdapter-可以看成Controller-的初始化" class="headerlink" title="HandlerAdapter(可以看成Controller)的初始化"></a>HandlerAdapter(可以看成Controller)的初始化</h3><p><strong>（可以参照HandlerAdapter的子类SimpleControllerHandlerAdapter里面的代码）</strong></p>
<p>HandlerAdapter的初始化工作主要是创建一个HandlerAdapter对象，将这个HandlerAdapter对象保存在DispatcherServlet的HandlerAdapters集合中。当SpringMVC将某个URL对应到某个Handler时，在HandlerAdapters集合中查询那个HandlerAdapters对象supports这个Handler，那么HandlerAdapters就会被返回（设计模式），并调用这个HandlerAdapters接口对应的方法。如果这个HandlerAdapters对象是SimpleControllerHandlerAdapter，则将调用其ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)方法。如果用户没有定义HandlerAdapter的实现类，默认的为：HttpRequestHandlerAdapter、SimpleControllerHandlerAdapter、ThrowawayControllerAdapter、AnnotationMethodHandlerAdapter。</p>
<h3 id="Control的调用逻辑"><a href="#Control的调用逻辑" class="headerlink" title="Control的调用逻辑"></a>Control的调用逻辑</h3><p>根据DispatcherServlet的doDispath方法我们可以看到通过getHandler方法匹配到某个Handler并返回这个Handler的处理链HandlerExecutionChain对象，而这个HandlerExecutionChain对象将会包含一个匹配上的HandlerAdapter以及用户自定义的多个HandlerInterceptor对象。我们先看HandlerInterceptor接口，在HandlerInterceptor接口中有三个方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</div><div class="line">    <span class="comment">// 在Handler执行前</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">    <span class="comment">// 在Handler执行后</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3, ModelAndView var4)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">    <span class="comment">// 在View渲染完成后，DispatchServlet返回之前执行。</span></div><div class="line">    <span class="comment">// PS：当preHandler返回false时，当前的请求将在执行完该方法后直接返回，Handler不再执行</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3, Exception var4)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们然后看看HandlerExecutionChain类的getHandler方法，你会发现返回的是Object对象，所以在这里Handler对象是没有类型的，Handler的类型是由HandlerAdapter（匹配到的）决定的。接下里执行Handler对象的具体方法，如果Handler对象的相应方法返回一个ModelAndView对象，接下去就去执行View渲染。</p>
<h2 id="Model（M）"><a href="#Model（M）" class="headerlink" title="Model（M）"></a>Model（M）</h2><p>Model实例既在业务逻辑层被使用，也在渲染页面中被使用，我们这里主要讲一下在页面模板渲染中的使用。</p>
<p>如果Handler返回了ModelAndView对象，那么说明Handler需要传一个Model实例给View去渲染模板。可以说ModelAndView对象就是连接业务逻辑层与View视图层的桥梁，对SpringMVC来说它也是连接Handler与View的桥梁。</p>
<p>ModelAndView对象会持有一个ModelMap对象和一个View对象（可以查看ModelAndView的源码），ModelMap对象就是执行模板渲染时所需要的变量对应的实例（对应到Struts2的值栈），如JSP通过request.getAttribute(String)获得JSTL标签名对应的对象。ModelMap其实也是个Map，在Handler中将模板需要的对象存在这个Map中，然后传递到View对应的ViewResolvers中。</p>
<h2 id="View（V）"><a href="#View（V）" class="headerlink" title="View（V）"></a>View（V）</h2><p>Spring MVC的View主要由RequestToViewNameTranslator和ViewResolver两个组件提供。</p>
<ul>
<li>RequestToViewNameTranslator支持用户自定义对ViewName的解析，如加上前缀或者后缀等。</li>
<li>ViewResolver会根据用户的请求的ViewName创建合适的模板引擎（解析器）来渲染最终的页面。ViewResolver会根据ViewName创建一个View对象，调用View对象的render方法渲染页面。</li>
</ul>
<p>我们重点关注这个ViewResolver，先看他的类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/viewResolver.png" alt="ViewResolver"></p>
<p>我们从UrlBaseViewResolver对象的loadView方法-&gt;buildView方法可以看到如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> AbstractUrlBasedView <span class="title">buildView</span><span class="params">(String viewName)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    AbstractUrlBasedView view = (AbstractUrlBasedView)BeanUtils.instantiateClass(<span class="keyword">this</span>.getViewClass());</div><div class="line">    view.setUrl(<span class="keyword">this</span>.getPrefix() + viewName + <span class="keyword">this</span>.getSuffix());</div><div class="line">    String contentType = <span class="keyword">this</span>.getContentType();</div><div class="line">    <span class="keyword">if</span>(contentType != <span class="keyword">null</span>) &#123;</div><div class="line">        view.setContentType(contentType);</div><div class="line">    &#125;</div><div class="line">    ... 省略</div><div class="line">    <span class="keyword">return</span> view;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结合类图可以发现不同的解析器生成的View对象是不一样的。</p>
<p>获得View对象之后就可以调用View对象的render方法渲染页面。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入分析Java Web技术内幕》</li>
<li><a href="https://blog.csdn.net/lang_programmer/article/details/71598042" target="_blank" rel="external">一步步分析SpringMVC源码</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：现在基于所有的Web应用都离不开Spring，用了Spring，你自然会去用他家的MVC框架——SpringMVC！所以掌握SpringMVC也是非常重要的。
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://bestlixiang.site/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Spring(四)_Spring设计模式</title>
    <link href="http://bestlixiang.site/2018/04/12/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Spring-%E5%9B%9B-Spring%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/04/12/深入SSM/揭秘Spring-四-Spring设计模式/</id>
    <published>2018-04-12T13:07:10.000Z</published>
    <updated>2018-04-12T13:10:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：说完了IOC和AOP（虽然可能还是不够深入，不够全面，但是对于自己还是有一定的收获，日后有新的领悟再来调整），再来说说Spring这么优秀的框架所使用的的设计模式，可谓遍地都是，我就自己看到写一下。<a id="more"></a></p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">设计模式之禅——单例模式</a>。</p>
<p>Spring应用到的单例模式可以在org.springframework.beans.factory.config.AbstractFactoryBean类中看到这个逻辑。看看它的getObject方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 如果是单例且已经初始化，就直接返回</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.isSingleton()?(<span class="keyword">this</span>.initialized?<span class="keyword">this</span>.singletonInstance:<span class="keyword">this</span>.getEarlySingletonInstance()):<span class="keyword">this</span>.createInstance();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>工厂方法模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">设计模式之禅——工厂方法模式</a>。</p>
<p>Spring应用到的工厂方法模式可以在org.springframework.beans.factory.BeanFactory类中看到这个逻辑。我们看到下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</div><div class="line">    <span class="comment">// 根据唯一标识来获得Bean对象</span></div><div class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String var1)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">设计模式之禅——抽象工厂模式</a>。</p>
<p>Spring应用到的抽象工厂模式可以在org.springframework.beans.factory.BeanFactory类中看到这个逻辑。通过它的实现，我们可以从Spring的容器访问bean。根据采用的策略，getBean方法可以返回已创建的对象（共享实例，单例作用域）或初始化新的对象（原型作用域）。在BeanFactory的实现中，我们可以区分：ClassPathXmlApplicationContext，XmlWebApplicationContext，StaticWebApplicationContext，StaticPortletApplicationContext，GenericApplicationContext，StaticApplicationContext，相当于不同的Creator。</p>
<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式之禅——建造者模式</a>。</p>
<p>Spring应用到的建造者模式可以在org.springframework.beans.factory.support.BeanDefinitionBuilder类中检索这个逻辑。这是一个允许我们以编程方式定义bean的类。BeanDefinitionBuilder包含几个方法，它们为AbstractBeanDefinition抽象类的相关实现设置值，比如作用域，工厂方法，属性等。想看看它是如何工作的，请查看以下这些方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionBuilder</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> AbstractBeanDefinition beanDefinition;</div><div class="line"></div><div class="line">  <span class="comment">// 设置Bean的父类名</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setParentName</span><span class="params">(String parentName)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.setParentName(parentName);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 设置Bean的工厂方法</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setFactoryMethod</span><span class="params">(String factoryMethod)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.setFactoryMethodName(factoryMethod);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 设置Bean的构造函数参数</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">addConstructorArgValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(</div><div class="line">                    <span class="keyword">this</span>.constructorArgIndex++, value);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 添加Bean的属性值</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">addPropertyValue</span><span class="params">(String name, Object value)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.getPropertyValues().add(name, value);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 设置Bean的初始化方法</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setInitMethodName</span><span class="params">(String methodName)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.setInitMethodName(methodName);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 返回建造好的对象</span></div><div class="line">  <span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">getBeanDefinition</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.validate();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinition;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>原型模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">设计模式之禅——原型模式</a>。</p>
<p>Spring应用到的原型模式可以在org.springframework.beans.factory.support.AbstractBeanFactory类中看到这个逻辑。它使用一种特定的原型设计模式，它先初始化bean原型作用域(克隆)。新对象基于配置文件中的bean定义。</p>
<h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><p>模板模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">设计模式之禅——模板模式</a>。</p>
<p>Spring应用到的模板模式可以在org.springframework.context.support.AbstractApplicationContext类以及它的实现类中看到这个逻辑。它的模板方法是refresh方法，而refreshBeanFactory以及getBeanFactory等方法都由子类具体实现。</p>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><p>访问者模式模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式之禅——访问者模式</a>。</p>
<p>Spring应用到的访问者模式可以在org.springframework.beans.factory.config.BeanDefinitionVisitor类中看到这个逻辑。该对象用于解析bean元数据并将其解析为String（例如：具有作用域或工厂方法名称的XML属性）或Object（例如：构造函数定义中的参数）。已解析的值在与分析的bean关联的BeanDefinition实例中进行判断设置。具体的源码请看BeanDefinitionVisitor的代码片段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionVisitor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitBeanDefinition</span><span class="params">(BeanDefinition beanDefinition)</span> </span>&#123;</div><div class="line">      visitParentName(beanDefinition);</div><div class="line">      visitBeanClassName(beanDefinition);</div><div class="line">      visitFactoryBeanName(beanDefinition);</div><div class="line">      visitFactoryMethodName(beanDefinition);</div><div class="line">      visitScope(beanDefinition);</div><div class="line">      visitPropertyValues(beanDefinition.getPropertyValues());</div><div class="line">      ConstructorArgumentValues cas = beanDefinition.</div><div class="line">        getConstructorArgumentValues();</div><div class="line">      visitIndexedArgumentValues(cas.</div><div class="line">        getIndexedArgumentValues());</div><div class="line">      visitGenericArgumentValues(cas.</div><div class="line">        getGenericArgumentValues());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">visitParentName</span><span class="params">(BeanDefinition beanDefinition)</span> </span>&#123;</div><div class="line">      String parentName = beanDefinition.getParentName();</div><div class="line">      <span class="keyword">if</span> (parentName != <span class="keyword">null</span>) &#123;</div><div class="line">        String resolvedName = resolveStringValue(parentName);</div><div class="line">        <span class="keyword">if</span> (!parentName.equals(resolvedName)) &#123;</div><div class="line">          beanDefinition.setParentName(resolvedName);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">设计模式之禅——代理模式</a>。</p>
<p>Spring应用到的代理模式可以在org.springframework.aop.framework.ProxyFactoryBean类中看到这个逻辑。详细说明可以参照上一篇文章。</p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">设计模式之禅——策略模式</a>。</p>
<p>Spring应用到的策略模式可以在org.springframework.aop.framework.DefaultAopProxyFactory类中看到这个逻辑。看一下这个类的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !<span class="keyword">this</span>.hasNoUserSuppliedProxyInterfaces(config)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</div><div class="line">            <span class="keyword">if</span>(targetClass == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: Either an interface or a target is required for proxy creation."</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 根据目标类是否有接口而采取不同的策略</span></div><div class="line">                <span class="keyword">return</span> (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass)?<span class="keyword">new</span> ObjenesisCglibAopProxy(config):<span class="keyword">new</span> JdkDynamicAopProxy(config));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>适配器模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">设计模式之禅——适配器模式</a>。</p>
<p>Spring应用到的适配器模式可以在org.springframework.aop.framework.adapter.DefaultAdvisorAdapterRegistry类中看到这个逻辑，Spring需要将每个Advice（通知）都封装成对应的拦截器类型，返回给容器，所以需要使用适配器模式对Advice进行转换。下面我们看看具体的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Adaptee</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">BeforeAdvice</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable</span>;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Target</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvisorAdapter</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span></span>;  </div><div class="line"></div><div class="line">    <span class="function">MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span></span>;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Adapter</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceAdapter</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapter</span>, <span class="title">Serializable</span> </span>&#123;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> (advice <span class="keyword">instanceof</span> MethodBeforeAdvice);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;  </div><div class="line">        MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodBeforeAdviceInterceptor(advice);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式之禅——观察者模式</a>。</p>
<p>Spring应用到的观察者模式可以应用程序上下文相关的事件传输看到这个逻辑，具体一点在AbstractApplicationContext与org.springframework.context.ApplicationListener以及org.springframework.context.event.ApplicationEventMulticaster中看到，我们可以看到下面的相关代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span>, <span class="title">DisposableBean</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义传播者，用来传播消息</span></div><div class="line">    <span class="keyword">private</span> ApplicationEventMulticaster applicationEventMulticaster;</div><div class="line">    <span class="comment">// 注册监听者</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationEventMulticaster</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addApplicationListenerBean</span><span class="params">(String var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeApplicationListenerBean</span><span class="params">(String var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeAllListeners</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(ApplicationEvent var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(ApplicationEvent var1, ResolvableType var2)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><p>解释器模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/">设计模式之禅——解释器模式</a>。</p>
<p>Spring应用到的解释器模式主要以Spring Expression Language（SpEL）为例。SpEL是一种由Spring的org.springframework.expression.ExpressionParser实现分析和执行的语言。这些实现使用作为字符串给出的Spel表达式，并将它们转换为org.springframework.expression.Expression的实例。上下文组件由org.springframework.expression.EvaluationContext实现表示，例如：StandardEvaluationContext。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>参考了超级多，都快忘了，各位大佬不要介意！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：说完了IOC和AOP（虽然可能还是不够深入，不够全面，但是对于自己还是有一定的收获，日后有新的领悟再来调整），再来说说Spring这么优秀的框架所使用的的设计模式，可谓遍地都是，我就自己看到写一下。
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Spring" scheme="http://bestlixiang.site/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Centos7利用Nginx配置HTTPS</title>
    <link href="http://bestlixiang.site/2018/04/12/%E5%B7%A5%E5%85%B7/Centos7%E5%88%A9%E7%94%A8Nginx%E9%85%8D%E7%BD%AEHTTPS/"/>
    <id>http://bestlixiang.site/2018/04/12/工具/Centos7利用Nginx配置HTTPS/</id>
    <published>2018-04-12T08:53:31.000Z</published>
    <updated>2018-04-12T08:54:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：最近在做一个微信小程序项目，坑爹的小程序不仅需要https协议，而且还要是80端口才能访问后台，这里总结一下Nginx的安装过程与HTTPS的配置。<a id="more"></a></p>
<h1 id="Ngnix的安装"><a href="#Ngnix的安装" class="headerlink" title="Ngnix的安装"></a>Ngnix的安装</h1><p>由于后面Nginx需要添加模块，所以我们采用<strong>源码安装</strong>，具体安装方法可以参考 <a href="http://bestlixiang.site/2018/04/08/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/">走进Linux_软件安装</a> 中的源码安装一节。</p>
<p>这里需要注意的我们在 <strong>产生makefile文件的时候</strong> 需要加一些configure arguments，以便安装相关模块。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module</div></pre></td></tr></table></figure></p>
<p>安装完之后可以利用下面的命令查看Ngnix版本及其编译参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/usr/local/nginx/sbin/nginx -V</div><div class="line"></div><div class="line">// 输出如下结果就是对的</div><div class="line">nginx version: nginx/1.11.6</div><div class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC)</div><div class="line">built with OpenSSL 1.0.2k-fips  26 Jan 2017</div><div class="line">TLS SNI support enabled</div><div class="line">configure arguments: --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module</div></pre></td></tr></table></figure></p>
<p>然后我们测试新的nginx程序是否正确：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/usr/local/nginx/sbin/nginx -t</div><div class="line"></div><div class="line">// 输出如下结果J就表面安装成功</div><div class="line">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</div><div class="line">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</div></pre></td></tr></table></figure></p>
<h1 id="配置HTTPS"><a href="#配置HTTPS" class="headerlink" title="配置HTTPS"></a>配置HTTPS</h1><h2 id="SSL证书申请"><a href="#SSL证书申请" class="headerlink" title="SSL证书申请"></a>SSL证书申请</h2><p>SSL证书遵守 SSL（Secure Sockets Layer 安全套接层）协议，由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能，也就是说你想要使用https就需要拥有SSL证书。</p>
<p>这里我们使用openssl证书来举例，<a href="https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=10_4" target="_blank" rel="external">微信小程序官网也是使用openssl来进行HTTPS服务器配置</a>。</p>
<ol>
<li><p>生成私钥</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 进入nginx的安装目录</div><div class="line">cd /usr/local/nginx</div><div class="line"></div><div class="line">// 创建一个存放私钥的文件夹（自定义）</div><div class="line">mkdir key</div><div class="line"></div><div class="line">// 进入key文件夹</div><div class="line">cd key</div><div class="line"></div><div class="line">// 生成私钥</div><div class="line">openssl genrsa -out server.key 2048</div></pre></td></tr></table></figure>
</li>
<li><p>生成csr文件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// CSR 是Certificate Signing Request的缩写，即证书签名请求，</div><div class="line">// 这不是证书，可以简单理解成公钥，生成证书时要把这个提交给权威的证书颁发机构。</div><div class="line"></div><div class="line"></div><div class="line">// 生成csr文件</div><div class="line">openssl req -new -key server.key -out certreq.csr</div><div class="line"></div><div class="line">// 输入上面的命令后会要求你输入一些信息：</div><div class="line">Country Name： CN        //您所在国家的ISO标准代号，中国为CN</div><div class="line">State or Province Name：guandong //您单位所在地省/自治区/直辖市</div><div class="line">Locality Name：shenzhen      //您单位所在地的市/县/区</div><div class="line">Organization Name： Tencent Technology (Shenzhen) Company Limited    //您单位/机构/企业合法的名称</div><div class="line">Organizational Unit Name： R&amp;D         //部门名称</div><div class="line">Common Name： www.example.com     //通用名，网站域名。此项必须与您访问提供SSL服务的服务器时所应用的域名完全匹配。</div><div class="line">Email Address：      //您的邮件地址，不必输入，直接回车跳过</div><div class="line">&quot;extra&quot;attributes  // 以下信息不必输入，回车跳过直到命令执行完毕。</div></pre></td></tr></table></figure>
</li>
<li><p>生成crt证书</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// CRT 即 certificate的缩写，即证书。</div><div class="line">openssl x509 -req -days 365 -in certreq.csr -signkey server.key -out certreq.crt</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Nginx配置SSL加密"><a href="#Nginx配置SSL加密" class="headerlink" title="Nginx配置SSL加密"></a>Nginx配置SSL加密</h2><p>想要https就要监听443端口，nginx.conf已经预留出了server，只要我们把注释去掉开启即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 编辑Ngnix配置文件</div><div class="line">vim /usr/local/nginx/conf/nginx.conf</div><div class="line"></div><div class="line">// 修改监听443端口的Server，使其如下：</div><div class="line">server &#123;</div><div class="line">    listen 443 ssl;</div><div class="line">    server_name www.example.com;</div><div class="line">    ssl on;</div><div class="line">    # ssl_certificate证书其实是个公钥，它会被发送到连接服务器的每个客户端</div><div class="line">    ssl_certificate /usr/local/nginx/key/certreq.crt;</div><div class="line">    # ssl_certificate_key私钥是用来解密的，所以它的权限要得到保护但nginx的主进程能够读取</div><div class="line">    ssl_certificate_key /usr/local/nginx/key/server.key;</div><div class="line">    ssl_session_timeout  5m;</div><div class="line">    # 指定SSL服务器端支持的协议版本</div><div class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">    # 选择加密算法</div><div class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</div><div class="line">    # ssl_ciphers  ALL：!ADH：!EXPORT56：RC4+RSA：+HIGH：+MEDIUM：+LOW：+SSLv2：+EXP;</div><div class="line">    # 在使用SSLv3和TLS协议时指定服务器的加密算法要优先于客户端的加密算法</div><div class="line">    ssl_prefer_server_ciphers   on;</div><div class="line">    # 虽然我们要使用HTTPS，但是服务器的程序接收的还是HTTP，所以要做个反向代理</div><div class="line">    location /&#123;</div><div class="line">        proxy_pass http://localhost:8080;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>这样虽然可以利用https来访问我们的ip，但是对于浏览器还是不受信任的。</strong></p>
<h2 id="导入证书"><a href="#导入证书" class="headerlink" title="导入证书"></a>导入证书</h2><p>如果你是找一个知名的SSL证书颁发机构如VeriSign、Wosign、StartSSL签发的证书，<strong>并且浏览器已经内置并信任了这些根证书</strong>，如果你是自建证书（向我们刚才那样）或获得二级证书授权，那么就<strong>需要将证书添加到浏览器</strong>，这样在访问站点时才不会显示不安全连接。<strong>不够买证书微信小程序会不支持。</strong> 证书生成的方法有很多，这里说两种：</p>
<ol>
<li><p>购买阿里云的免费证书</p>
</li>
<li><p>购买<a href="http://note.youdao.com/" target="_blank" rel="external">GETSSL官网</a>证书</p>
</li>
</ol>
<p>购买好证书并下载后（可以将证书和私钥放到之前的key目录）需要从新配置nginx.conf文件，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 443 ssl;</div><div class="line">    server_name www.example.com;</div><div class="line">    ssl on;</div><div class="line">    # pem是crt的一种，内容是BASE64编码，Apache和*NIX服务器偏向于使用这种编码格式</div><div class="line">    ssl_certificate /usr/local/nginx/key/*.pem;</div><div class="line">    ssl_certificate_key /usr/local/nginx/key/*.key;</div><div class="line">    ssl_session_timeout  5m;</div><div class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</div><div class="line">    ssl_prefer_server_ciphers   on;</div><div class="line">    location /&#123;</div><div class="line">        proxy_pass http://localhost:8080;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/w410589502/article/details/72833283" target="_blank" rel="external"> linux nginx配置https</a></li>
<li><a href="https://www.cnblogs.com/yjmyzz/p/openssl-tutorial.html" target="_blank" rel="external">openssl、x509、crt、cer、key、csr、ssl、tls 这些都是什么鬼?</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：最近在做一个微信小程序项目，坑爹的小程序不仅需要https协议，而且还要是80端口才能访问后台，这里总结一下Nginx的安装过程与HTTPS的配置。
    
    </summary>
    
      <category term="工具" scheme="http://bestlixiang.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
      <category term="HTTPS" scheme="http://bestlixiang.site/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Spring(三)_Spring之AOP</title>
    <link href="http://bestlixiang.site/2018/04/11/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Spring-%E4%B8%89-Spring%E4%B9%8BAOP/"/>
    <id>http://bestlixiang.site/2018/04/11/深入SSM/揭秘Spring-三-Spring之AOP/</id>
    <published>2018-04-11T13:21:34.000Z</published>
    <updated>2018-04-11T13:47:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：前一节讲到Spring的核心概念IOC，那么就不能不提到Spring的另一个核心概念AOP，我们先是先讲一下它的概念与原理实现，然后在讲Spring中AOP的实现。<a id="more"></a></p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="AOP思想"><a href="#AOP思想" class="headerlink" title="AOP思想"></a>AOP思想</h2><p>AOP（Aspect Oriented Programming的缩写，意为：面向切面编程）是对OOP的一种补充。</p>
<ul>
<li>面向对象(OOP)引入了继承、多态、封装，将系统的业务功能按照模块划分，每个模块用一个或多个类来表示。<strong>而对于一些系统功能，无法使用OOP的思想来实现它们。这些系统功能往往穿插在业务功能的各处，和业务代码耦合在一起；而且系统功能往往会被重复使用，这就导致了模块不利于复用，这就是使用OOP实现系统功能的弊端。</strong></li>
<li>AOP即为面向切面编程，它把系统需求按照功能分门归类，把它们封装在一个个切面中，然后再指定这些系统功能往业务功能，主要应用于权限认证、日志，事务等。</li>
</ul>
<p>它的主要是好处如下：</p>
<ul>
<li><p>降低模块之间的耦合度</p>
</li>
<li><p>使系统容易扩展</p>
</li>
<li><p>更好的代码复用。</p>
</li>
</ul>
<h2 id="AOP实现原理"><a href="#AOP实现原理" class="headerlink" title="AOP实现原理"></a>AOP实现原理</h2><p>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。而Spring采用的是动态代理技术，关于动态代理的实现可以参照自己之前的博客 <a href="http://bestlixiang.site/2018/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">设计模式之禅——代理模式</a>一文中的动态代理这一节去了解。</p>
<h1 id="SpringAOP实现"><a href="#SpringAOP实现" class="headerlink" title="SpringAOP实现"></a>SpringAOP实现</h1><p>Spring的AOP实现遵守AOP联盟的约定。同时Spring又扩展了它，增加了Pointcut、Advisor等一些接口使得其更加灵活。</p>
<h2 id="Spring-AOP的基本概念"><a href="#Spring-AOP的基本概念" class="headerlink" title="Spring AOP的基本概念"></a>Spring AOP的基本概念</h2><ul>
<li>切面（Aspect）：类似于OOP中的Class，一个Aspect存放一个系统功能的所有逻辑。切面用Spring的 Advisor或拦截器实现。</li>
<li>连接点（Joinpoint）：程序执行过程中的某一事件，如方法被调用时、抛出异常时。</li>
<li>切入点（Pointcut）：指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上。</li>
<li>引入（Introduction）: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口。</li>
<li>目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象（POJO）。</li>
<li>AOP代理（AOP Proxy）: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</li>
<li>织入（Weaving）: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</li>
<li>通知（Advice）：具体的横切逻辑；Spring中有五种Advice：<ul>
<li>前置通知（Before Advice）</li>
<li>后置通知（After Advice）</li>
<li>返回通知（After Return Advice）</li>
<li>环绕通知（Around Advice）</li>
<li>抛出异常后通知（After Throwing Advice）</li>
</ul>
</li>
</ul>
<h2 id="SpringAOP动态代理"><a href="#SpringAOP动态代理" class="headerlink" title="SpringAOP动态代理"></a>SpringAOP动态代理</h2><p>Spring AOP中使用了两种动态代理，一种是JDK的动态代理，一种CGLIB的动态代理。JDK的动态代理必须指定接口，这些接口都是已经被代理对象实现了的；而CGLIB代理则不需要指定接口。</p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>如果被代理对象实现了需要被代理的接口，则使用JDK的动态代理。我们一步步来看这个过程：</p>
<ol>
<li><p>首先明确我们使要生成一个代理，而Spring的内部机制是由FactoryBean的getObject方法来产生的，所以我们会一步步debug到这个方法行（在FactoryBeanRegistrySupport类的doGetObjectFromFactoryBean中），我们看看这个方法的源代码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    <span class="comment">// 初始化通知器链，为代理对象配置通知器链。</span></div><div class="line">    <span class="keyword">this</span>.initializeAdvisorChain();</div><div class="line">    <span class="comment">//区分SingleTon和ProtoType，生成对应的Proxy</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.isSingleton()) &#123;</div><div class="line">    <span class="comment">// 只有SingleTon的Bean才会一开始就初始化，ProtoType的只有在请求的时候才会初始化，代理也一样</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getSingletonInstance();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.logger.warn(<span class="string">"Using non-singleton proxies with singleton targets is often undesirable. Enable prototype proxies by setting the 'targetName' property."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.newPrototypeInstance();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>到达getObject方法后，我们需要去看看它是怎么初始化通知链的就是initializeAdvisorChain的代码：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initializeAdvisorChain</span><span class="params">()</span> <span class="keyword">throws</span> AopConfigException, BeansException </span>&#123;</div><div class="line">    <span class="comment">// 初始化过程的标志位advisorChainInitialized，这个标志用来表示通知器链是否已经初始化。</span></div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.advisorChainInitialized) &#123;</div><div class="line">        <span class="keyword">if</span>(!ObjectUtils.isEmpty(<span class="keyword">this</span>.interceptorNames)) &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.beanFactory == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No BeanFactory available anymore (probably due to serialization) - cannot resolve interceptor names "</span> + Arrays.asList(<span class="keyword">this</span>.interceptorNames));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.interceptorNames[<span class="keyword">this</span>.interceptorNames.length - <span class="number">1</span>].endsWith(<span class="string">"*"</span>) &amp;&amp; <span class="keyword">this</span>.targetName == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSource == EMPTY_TARGET_SOURCE) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Target required after globals"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            String[] var1 = <span class="keyword">this</span>.interceptorNames;</div><div class="line">            <span class="keyword">int</span> var2 = var1.length;</div><div class="line"></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</div><div class="line">                String name = var1[var3];</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</div><div class="line">                    <span class="keyword">this</span>.logger.trace(<span class="string">"Configuring advisor or advice '"</span> + name + <span class="string">"'"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(name.endsWith(<span class="string">"*"</span>)) &#123;</div><div class="line">                    <span class="keyword">if</span>(!(<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ListableBeanFactory)) &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Can only use global advisors or interceptors with a ListableBeanFactory"</span>);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">this</span>.addGlobalAdvisor((ListableBeanFactory)<span class="keyword">this</span>.beanFactory, name.substring(<span class="number">0</span>, name.length() - <span class="string">"*"</span>.length()));</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    Object advice;</div><div class="line">                    <span class="keyword">if</span>(!<span class="keyword">this</span>.singleton &amp;&amp; !<span class="keyword">this</span>.beanFactory.isSingleton(name)) &#123;</div><div class="line">                        advice = <span class="keyword">new</span> ProxyFactoryBean.PrototypePlaceholderAdvisor(name);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        advice = <span class="keyword">this</span>.beanFactory.getBean(name);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">this</span>.addAdvisorOnChainCreation(advice, name);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.advisorChainInitialized = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  初始化只是在应用第一次通过ProxyFactoryBean获取代理对象的时候。完成这个初始化之后，接着会读取配置中出现的所有通知器（把通知器的名字交给容器的getBean，IOC容器的回调获取通知器），把通知器加入拦截器链（addAdvisoronChainCreation实现）。</p>
</li>
<li><p>生成代理对象，利用ProxyFactoryBean的getSingletonInstance方法，源码如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Object <span class="title">getSingletonInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.singletonInstance == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//这里会调用getBean，获取被代理对象</span></div><div class="line">        <span class="keyword">this</span>.targetSource = <span class="keyword">this</span>.freshTargetSource();</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.autodetectInterfaces &amp;&amp; <span class="keyword">this</span>.getProxiedInterfaces().length == <span class="number">0</span> &amp;&amp; !<span class="keyword">this</span>.isProxyTargetClass()) &#123;</div><div class="line">            <span class="comment">// 根据 AOP 框架判断需要代理的接口</span></div><div class="line">            Class&lt;?&gt; targetClass = <span class="keyword">this</span>.getTargetClass();</div><div class="line">            <span class="keyword">if</span>(targetClass == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FactoryBeanNotInitializedException(<span class="string">"Cannot determine target class for proxy"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//这里是设置代理对象的接口</span></div><div class="line">            <span class="keyword">this</span>.setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, <span class="keyword">this</span>.proxyClassLoader));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>.setFrozen(<span class="keyword">this</span>.freezeProxy);</div><div class="line">        <span class="comment">//这里方法会使用ProxyFactory生成需要的Proxy</span></div><div class="line">        <span class="keyword">this</span>.singletonInstance = <span class="keyword">this</span>.getProxy(<span class="keyword">this</span>.createAopProxy());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.singletonInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>进入ProxyCreatorSupport的createAopProxy，源码如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</div><div class="line">    activate();</div><div class="line">&#125;</div><div class="line"><span class="comment">//通过AopProxyFactory取得AopProxy，AopProxyFactory是在初始化函数中定义的，使用的是DefaultAopProxyFactory</span></div><div class="line"><span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>那么DefaultAopProxyFactory如何生成AopProxy了，这里有两种方式，JdkDynamicAopProxy和CglibProxyFactory,DefaultAopProxyFactory的createAopProxy的源码如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</div><div class="line">            <span class="comment">//获取配置的目标对象</span></div><div class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</div><div class="line">            <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//如果没有目标对象，抛出异常，提醒AOP应用提供正确的目标配置</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</div><div class="line">                        <span class="string">"Either an interface or a target is required for proxy creation."</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 这个判断很重要，通过目标类是否是接口来决定采用什么代理方式</span></div><div class="line">            <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//由于CGLIB是一个第三方类库，所以需要在CLASSPATH中配置</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>由于我们这里目标类是接口，所以采用JdkDynamicAopProxy 生成AopProxy代理对象，我们可以看一下JdkDynamicAopProxy的invoke方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">       Object oldProxy = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</div><div class="line">       TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</div><div class="line">       Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</div><div class="line">       Object target = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">       Object var13;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">if</span>(!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</div><div class="line">               Boolean var20 = Boolean.valueOf(<span class="keyword">this</span>.equals(args[<span class="number">0</span>]));</div><div class="line">               <span class="keyword">return</span> var20;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span>(!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</div><div class="line">               Integer var18 = Integer.valueOf(<span class="keyword">this</span>.hashCode());</div><div class="line">               <span class="keyword">return</span> var18;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">if</span>(method.getDeclaringClass() == DecoratingProxy.class) &#123;</div><div class="line">               Class var17 = AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</div><div class="line">               <span class="keyword">return</span> var17;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           Object retVal;</div><div class="line"></div><div class="line">           <span class="comment">// Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知</span></div><div class="line">           <span class="keyword">if</span>(!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</div><div class="line">               retVal = AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</div><div class="line">               <span class="keyword">return</span> retVal;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">if</span>(<span class="keyword">this</span>.advised.exposeProxy) &#123;</div><div class="line">               oldProxy = AopContext.setCurrentProxy(proxy);</div><div class="line">               setProxyContext = <span class="keyword">true</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">//获得目标对象的类</span></div><div class="line">           target = targetSource.getTarget();</div><div class="line">           <span class="keyword">if</span>(target != <span class="keyword">null</span>) &#123;</div><div class="line">               targetClass = target.getClass();</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 获得拦截链</span></div><div class="line">           List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</div><div class="line">           <span class="comment">// 如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)</span></div><div class="line">           <span class="keyword">if</span>(chain.isEmpty()) &#123;</div><div class="line">               Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</div><div class="line">               retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="comment">//创建MethodInvocation</span></div><div class="line">               MethodInvocation invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</div><div class="line">               <span class="comment">// 处理通知</span></div><div class="line">               retVal = invocation.proceed();</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           Class&lt;?&gt; returnType = method.getReturnType();</div><div class="line">           <span class="keyword">if</span>(retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp; returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp; !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</div><div class="line">               retVal = proxy;</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           var13 = retVal;</div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           <span class="keyword">if</span>(target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</div><div class="line">               targetSource.releaseTarget(target);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">if</span>(setProxyContext) &#123;</div><div class="line">               AopContext.setCurrentProxy(oldProxy);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> var13;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>如果被代理对象没有实现需要被代理的接口，则使用CGLIB动态代理，CGLIB动态代理按照前面的分析基本与JDK动态代理一样，由于在Spring AOP中对应的包装类为CglibAopProxy，CglibAopProxy的intercept回调方法的实现和JdkDynamicAopProxy的回调实现是非常类似的，只是在CglibAopProxy中构造的是CglibMethodInvocation对象来完成拦截器链的调用，这里看一下与invoke类似的getCallbacks源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Callback[] getCallbacks(Class&lt;?&gt; rootClass) <span class="keyword">throws</span> Exception &#123;</div><div class="line">    <span class="keyword">boolean</span> exposeProxy = <span class="keyword">this</span>.advised.isExposeProxy();</div><div class="line">    <span class="keyword">boolean</span> isFrozen = <span class="keyword">this</span>.advised.isFrozen();</div><div class="line">    <span class="keyword">boolean</span> isStatic = <span class="keyword">this</span>.advised.getTargetSource().isStatic();</div><div class="line">    Callback aopInterceptor = <span class="keyword">new</span> CglibAopProxy.DynamicAdvisedInterceptor(<span class="keyword">this</span>.advised);</div><div class="line">    Object targetInterceptor;</div><div class="line">    <span class="keyword">if</span>(exposeProxy) &#123;</div><div class="line">        targetInterceptor = isStatic?<span class="keyword">new</span> CglibAopProxy.StaticUnadvisedExposedInterceptor(<span class="keyword">this</span>.advised.getTargetSource().getTarget()):<span class="keyword">new</span> CglibAopProxy.DynamicUnadvisedExposedInterceptor(<span class="keyword">this</span>.advised.getTargetSource());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        targetInterceptor = isStatic?<span class="keyword">new</span> CglibAopProxy.StaticUnadvisedInterceptor(<span class="keyword">this</span>.advised.getTargetSource().getTarget()):<span class="keyword">new</span> CglibAopProxy.DynamicUnadvisedInterceptor(<span class="keyword">this</span>.advised.getTargetSource());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Callback targetDispatcher = (Callback)(isStatic?<span class="keyword">new</span> CglibAopProxy.StaticDispatcher(<span class="keyword">this</span>.advised.getTargetSource().getTarget()):<span class="keyword">new</span> CglibAopProxy.SerializableNoOp());</div><div class="line">    Callback[] mainCallbacks = <span class="keyword">new</span> Callback[]&#123;aopInterceptor, (Callback)targetInterceptor, <span class="keyword">new</span> CglibAopProxy.SerializableNoOp(), targetDispatcher, <span class="keyword">this</span>.advisedDispatcher, <span class="keyword">new</span> CglibAopProxy.EqualsInterceptor(<span class="keyword">this</span>.advised), <span class="keyword">new</span> CglibAopProxy.HashCodeInterceptor(<span class="keyword">this</span>.advised)&#125;;</div><div class="line">    Callback[] callbacks;</div><div class="line">    <span class="keyword">if</span>(isStatic &amp;&amp; isFrozen) &#123;</div><div class="line">        Method[] methods = rootClass.getMethods();</div><div class="line">        Callback[] fixedCallbacks = <span class="keyword">new</span> Callback[methods.length];</div><div class="line">        <span class="keyword">this</span>.fixedInterceptorMap = <span class="keyword">new</span> HashMap(methods.length);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; methods.length; ++x) &#123;</div><div class="line">            <span class="comment">// 获得拦截链</span></div><div class="line">            List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(methods[x], rootClass);</div><div class="line">            <span class="comment">// 准备处理通知</span></div><div class="line">            fixedCallbacks[x] = <span class="keyword">new</span> CglibAopProxy.FixedChainStaticTargetInterceptor(chain, <span class="keyword">this</span>.advised.getTargetSource().getTarget(), <span class="keyword">this</span>.advised.getTargetClass());</div><div class="line">            <span class="keyword">this</span>.fixedInterceptorMap.put(methods[x].toString(), Integer.valueOf(x));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        callbacks = <span class="keyword">new</span> Callback[mainCallbacks.length + fixedCallbacks.length];</div><div class="line">        System.arraycopy(mainCallbacks, <span class="number">0</span>, callbacks, <span class="number">0</span>, mainCallbacks.length);</div><div class="line">        System.arraycopy(fixedCallbacks, <span class="number">0</span>, callbacks, mainCallbacks.length, fixedCallbacks.length);</div><div class="line">        <span class="keyword">this</span>.fixedInterceptorOffset = mainCallbacks.length;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        callbacks = mainCallbacks;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> callbacks;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/u010425776/article/details/59112466" target="_blank" rel="external"> 深入剖析Spring(四)——AOP</a></li>
<li><a href="https://blog.csdn.net/zly9923218/article/details/51348583" target="_blank" rel="external">Spring AOP源码分析（生成代理对象）</a></li>
<li><a href="https://blog.csdn.net/zhangliangzi/article/details/52334964" target="_blank" rel="external">Spring AOP四种实现方式Demo详解与相关知识探究</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前一节讲到Spring的核心概念IOC，那么就不能不提到Spring的另一个核心概念AOP，我们先是先讲一下它的概念与原理实现，然后在讲Spring中AOP的实现。
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Spring" scheme="http://bestlixiang.site/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Spring(二)_Spring之IOC</title>
    <link href="http://bestlixiang.site/2018/04/11/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Spring(%E4%BA%8C)_Spring%E4%B9%8BIOC/"/>
    <id>http://bestlixiang.site/2018/04/11/深入SSM/揭秘Spring(二)_Spring之IOC/</id>
    <published>2018-04-11T02:26:40.000Z</published>
    <updated>2018-04-11T02:29:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：前一篇文章我们介绍了Spring的整体架构以及核心组件，接下来我们将讲解Spring的核心概念之一IOC，我们将先简单介绍IOC与DI，然后再深入SpringIOC容器的工作流程。<a id="more"></a></p>
<h1 id="IOC与DI"><a href="#IOC与DI" class="headerlink" title="IOC与DI"></a>IOC与DI</h1><p>IoC和DI是Spring的两个核心概念，很多人都把它们视为相同的东西（之前自己也一直这样认为），<strong>但事实并非如此</strong>。</p>
<ul>
<li>IoC(Inversion of Control)：控制反转。</li>
<li>DI(Dependency Injection)：依赖注入</li>
</ul>
<p><strong>开始画重点了：</strong> 控制反转是<strong>目的</strong>，依赖注入是实现控制反转的<strong>手段</strong>。</p>
<p>控制反转是一种设计模式思想，它是一种宽泛的概念，只要一个类将对它内部状态的控制权交由其他机制去完成即为控制反转。控制反转是为了降低类与类之间的耦合度。而Spring采用依赖注入这一具体的手段来达到控制反转的目的。</p>
<p>关于依赖注入可以看我之前的文章<a href="http://bestlixiang.site/2018/02/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%88%E5%90%B9%E5%93%8D%E5%8F%A3%E5%8F%B7-6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">先吹响口号_6大设计原则</a>中的依赖倒置原则 DIP一节，这里就不做过多的介绍了。</p>
<h1 id="IOC容器工作流程"><a href="#IOC容器工作流程" class="headerlink" title="IOC容器工作流程"></a>IOC容器工作流程</h1><p>IOC容器实际上就是 Context 组件结合其他Bean和Core组件共同构建了一个 Bean 关系网，如何构建这个关系网？构建的入口就在 AbstractApplicationContext 类的 refresh 方法中。这个方法的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</div><div class="line">        Object var1 = <span class="keyword">this</span>.startupShutdownMonitor;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</div><div class="line">            <span class="comment">// 为刷新准备新的context</span></div><div class="line">            <span class="keyword">this</span>.prepareRefresh();</div><div class="line">            <span class="comment">// **创建BeanFactory**</span></div><div class="line">            ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</div><div class="line">            <span class="comment">// 刷新所有BeanFactory子容器</span></div><div class="line">            <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 注册实现了BeanPostProcessor接口的bean（AOP使用）</span></div><div class="line">                <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</div><div class="line">                <span class="comment">// 初始化和执行BeanFactoryPostProcessor beans</span></div><div class="line">                <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</div><div class="line">                <span class="comment">// 初始化和执行BeanPostProcessors beans</span></div><div class="line">                <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</div><div class="line">                <span class="comment">// 初始化MessageSource</span></div><div class="line">                <span class="keyword">this</span>.initMessageSource();</div><div class="line">                <span class="comment">// 初始化 event multicaster （多路广播）</span></div><div class="line">                <span class="keyword">this</span>.initApplicationEventMulticaster();</div><div class="line">                <span class="comment">// 刷新由子类实现的方法</span></div><div class="line">                <span class="keyword">this</span>.onRefresh();</div><div class="line">                <span class="comment">// 注册事件</span></div><div class="line">                <span class="keyword">this</span>.registerListeners();</div><div class="line">                <span class="comment">// 初始化单例Bean</span></div><div class="line">                <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</div><div class="line">                <span class="comment">// 发布相应的事件</span></div><div class="line">                <span class="keyword">this</span>.finishRefresh();</div><div class="line">            &#125; <span class="keyword">catch</span> (BeansException var9) &#123;</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</div><div class="line">                    <span class="keyword">this</span>.logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> + var9);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 销毁beans</span></div><div class="line">                <span class="keyword">this</span>.destroyBeans();</div><div class="line">                <span class="keyword">this</span>.cancelRefresh(var9);</div><div class="line">                <span class="keyword">throw</span> var9;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">this</span>.resetCommonCaches();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这个方法就是构建整个IOC容器过程的完整的代码，了解了里面的每一行代码基本上就了解大部分 Spring 的原理和功能了。</p>
<p>这段代码主要包含这样几个步骤：</p>
<ul>
<li>构建 BeanFactory</li>
<li>注册可能感兴趣的事件</li>
<li>创建 Bean 实例对象</li>
<li>触发被监听的事件</li>
</ul>
<p>其中我们我们最关心的就是BeanFactory和创建Bean实例对象了，我们下面可以好好看看：</p>
<h2 id="创建BeanFactory工厂"><a href="#创建BeanFactory工厂" class="headerlink" title="创建BeanFactory工厂"></a>创建BeanFactory工厂</h2><p>我们利用debug可以进入到refresh()方法里面的obtainFreshBeanFactory()方法里面的refreshBeanFactory() <strong>（有点绕，但是自己就不画时序图了）</strong> 去看看他的创建代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.hasBeanFactory()) &#123;</div><div class="line">            <span class="keyword">this</span>.destroyBeans();</div><div class="line">            <span class="keyword">this</span>.closeBeanFactory();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 创建一个DefaultListableBeanFactory（上一节说过的很重要的类）</span></div><div class="line">            DefaultListableBeanFactory beanFactory = <span class="keyword">this</span>.createBeanFactory();</div><div class="line">            beanFactory.setSerializationId(<span class="keyword">this</span>.getId());</div><div class="line">            <span class="keyword">this</span>.customizeBeanFactory(beanFactory);</div><div class="line">            <span class="comment">// **这个方法会加载、解析Bean的定义**</span></div><div class="line">            <span class="keyword">this</span>.loadBeanDefinitions(beanFactory);</div><div class="line">            Object var2 = <span class="keyword">this</span>.beanFactoryMonitor;</div><div class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.beanFactoryMonitor) &#123;</div><div class="line">                <span class="keyword">this</span>.beanFactory = beanFactory;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException var5) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + <span class="keyword">this</span>.getDisplayName(), var5);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="创建Bean实例并构建Bean的关系网"><a href="#创建Bean实例并构建Bean的关系网" class="headerlink" title="创建Bean实例并构建Bean的关系网"></a>创建Bean实例并构建Bean的关系网</h2><p>我们利用debug可以进入到refresh()方法里面的finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory)方法里面的preInstantiateSingletons() <strong>（有点绕，但是自己就不画时序图了）</strong> 去看看它的创建Bean的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</div><div class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList(<span class="keyword">this</span>.beanDefinitionNames);</div><div class="line">        Iterator var2 = beanNames.iterator();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">                String beanName;</div><div class="line">                RootBeanDefinition bd;</div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        <span class="keyword">do</span> &#123;</div><div class="line">                            <span class="keyword">if</span>(!var2.hasNext()) &#123;</div><div class="line">                                var2 = beanNames.iterator();</div><div class="line"></div><div class="line">                                <span class="keyword">while</span>(var2.hasNext()) &#123;</div><div class="line">                                    beanName = (String)var2.next();</div><div class="line">                                    Object singletonInstance = <span class="keyword">this</span>.getSingleton(beanName);</div><div class="line">                                    <span class="keyword">if</span>(singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</div><div class="line">                                        <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;</div><div class="line">                                        <span class="keyword">if</span>(System.getSecurityManager() != <span class="keyword">null</span>) &#123;</div><div class="line">                                            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</div><div class="line">                                                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                                                    smartSingleton.afterSingletonsInstantiated();</div><div class="line">                                                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                                                &#125;</div><div class="line">                                            &#125;, <span class="keyword">this</span>.getAccessControlContext());</div><div class="line">                                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                            smartSingleton.afterSingletonsInstantiated();</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;</div><div class="line">                                &#125;</div><div class="line"></div><div class="line">                                <span class="keyword">return</span>;</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            beanName = (String)var2.next();</div><div class="line">                            bd = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</div><div class="line">                        &#125; <span class="keyword">while</span>(bd.isAbstract());</div><div class="line">                    &#125; <span class="keyword">while</span>(!bd.isSingleton());</div><div class="line">                &#125; <span class="keyword">while</span>(bd.isLazyInit());</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.isFactoryBean(beanName)) &#123;</div><div class="line">                    <span class="comment">// 这个Bean很重要，Spring有一大半扩展功能都与这个Bean有关系，</span></div><div class="line">                    <span class="comment">// 它是个工厂Bean，可以产生Bean实例的Bean，</span></div><div class="line">                    <span class="comment">// Spring获取FactoryBean本身的对象是通过在前面加上&amp;来完成的                    </span></div><div class="line">                    <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean)<span class="keyword">this</span>.getBean(<span class="string">"&amp;"</span> + beanName);</div><div class="line">                    <span class="keyword">boolean</span> isEagerInit;</div><div class="line">                    <span class="keyword">if</span>(System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</div><div class="line">                        isEagerInit = ((Boolean)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</div><div class="line">                            <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                                <span class="keyword">return</span> Boolean.valueOf(((SmartFactoryBean)factory).isEagerInit());</div><div class="line">                            &#125;</div><div class="line">                        &#125;, <span class="keyword">this</span>.getAccessControlContext())).booleanValue();</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        isEagerInit = factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp; ((SmartFactoryBean)factory).isEagerInit();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span>(isEagerInit) &#123;</div><div class="line">                        <span class="comment">// 普通的Bean只要通过getBean方法直接创建它的实例</span></div><div class="line">                        <span class="comment">// getBean方法里面包含了他们关系的创建</span></div><div class="line">                        <span class="keyword">this</span>.getBean(beanName);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">this</span>.getBean(beanName);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="IOC容器的扩展点"><a href="#IOC容器的扩展点" class="headerlink" title="IOC容器的扩展点"></a>IOC容器的扩展点</h2><p>如何让这些 Bean 对象有一定的扩展性（就是可以加入用户的一些操作）也是我们需要思考的！那么有哪些扩展点呢？ Spring 又是如何调用到这些扩展点的？</p>
<p>对 Spring 的 IOC 容器来说，主要有这么几个扩展点：</p>
<ul>
<li>BeanFactoryPostProcessor， BeanPostProcessor：他们分别是在构建 BeanFactory 和构建 Bean 对象时调用。</li>
<li>InitializingBean 和 DisposableBean ：他们分别是在 Bean 实例创建和销毁时被调用。用户可以实现这些接口中定义的方法，Spring 就会在适当的时候调用他们。</li>
<li>FactoryBean ：他是个特殊的 Bean，这个 Bean 可以被用户更多的控制。</li>
</ul>
<p>这些扩展点通常也是我们使用 Spring 来完成我们特定任务的地方，<strong>是否精通 Spring 就看你有没有掌握好Spring有哪些扩展点，并且如何使用他们。</strong></p>
<p>要知道如何使用他们就必须了解他们内在的机理。可以用下面一个比喻（优秀）来解释：</p>
<p>我们把 IOC 容器比作一个箱子，这个箱子里有若干个球的模子，可以用这些模子来造很多种不同的球，还有一个造这些球模的机器，这个机器可以产生球模。那么他们的对应关系就是 BeanFactory 就是那个造球模的机器，球模就是 Bean，而球模造出来的球就是 Bean 的实例。</p>
<p>那前面所说的几个扩展点又在什么地方呢？ BeanFactoryPostProcessor 对应到当造球模被造出来时，你将有机会可以对其做出设当的修正，也就是他可以帮你修改球模。而 InitializingBean 和 DisposableBean 是在球模造球的开始和结束阶段，你可以完成一些预备和扫尾工作。BeanPostProcessor 就可以让你对球模造出来的球做出适当的修正。最后还有一个 FactoryBean，它可是一个神奇的球模。这个球模不是预先就定型了，而是由你来给他确定它的形状，既然你可以确定这个球模型的形状，当然他造出来的球肯定就是你想要的球了，这样在这个箱子里你可以发现所有你想要的球。</p>
<h2 id="IOC容器的使用"><a href="#IOC容器的使用" class="headerlink" title="IOC容器的使用"></a>IOC容器的使用</h2><p>我们使用 Spring 必须要首先构建 IOC 容器，没有它 Spring 无法工作，ApplicatonContext.xml 就是 IOC 容器的默认配置文件，Spring 的所有特性功能都是基于这个 IOC 容器工作的，比如后面要介绍的 AOP。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入分析Java Web技术内幕》</li>
<li><a href="https://blog.csdn.net/u010425776/article/details/55269848" target="_blank" rel="external"> 深入剖析Spring(一)——IoC的基本概念(从面向对象角度介绍)</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前一篇文章我们介绍了Spring的整体架构以及核心组件，接下来我们将讲解Spring的核心概念之一IOC，我们将先简单介绍IOC与DI，然后再深入SpringIOC容器的工作流程。
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Spring" scheme="http://bestlixiang.site/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Spring(一)_Spring架构</title>
    <link href="http://bestlixiang.site/2018/04/10/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Spring-%E4%B8%80-Spring%E6%9E%B6%E6%9E%84/"/>
    <id>http://bestlixiang.site/2018/04/10/深入SSM/揭秘Spring-一-Spring架构/</id>
    <published>2018-04-10T11:31:40.000Z</published>
    <updated>2018-04-10T11:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：Spring作为现在最优秀的框架之一，被广泛得使用在Web场景中。很多人只会使用，但是却不知道Spring整个体系架构。<a id="more"></a></p>
<h1 id="Spring的骨骼架构"><a href="#Spring的骨骼架构" class="headerlink" title="Spring的骨骼架构"></a>Spring的骨骼架构</h1><p>Spring总共有十几个组件，但是真正核心的组件只有几个，如下图为Spring框架开始以来拥有的总体架构图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/gif/spring.gif" alt="spring"></p>
<p>从上图可以看出，在Spring框架中的 <strong>核心组件</strong> 只有三个：core、context、bean。他们构建起整个Spring的骨骼架构，没有他们就不可能有AOP、Web等上层的 <strong>特性功能</strong> 。</p>
<h2 id="Spring的设计理念"><a href="#Spring的设计理念" class="headerlink" title="Spring的设计理念"></a>Spring的设计理念</h2><p>上面说了三个核心组件，但是最重要就是Bean组件了，用过Spring的人都知道，我们所有的类基本上都会交给Spring托管，也就是说Spring就是面向Bean的编程。Bean在Spring中的作用就像Object对OOP的意义一样，没有对象的概念就没有面向对象的概念，在Spring中没有Bean也就没有Spring存在的意义。</p>
<p><strong>使用Spring最大的原因：</strong> 是他解决了一个非常关键的问题，它可以让你把对象之间的依赖关系解耦，其中的关系交由<strong>IOC容器</strong>（Bean关系的集合）来管理，核心就是<strong>依赖注入机制</strong>。Spring也正是通过把对象包装在Bean中达到管理这些对象及做一些列额外操作的目的。</p>
<p><strong>一般框架设计理念：</strong> 先构建一个数据结构，然后根据这个数据结构设计它的生存环境，并让它在这个环境中按照一定的规律不停的运动，在他不停运动的过程中设计它们与环境或者与其他个体完成信息交换。</p>
<h2 id="核心组件如何协同工作"><a href="#核心组件如何协同工作" class="headerlink" title="核心组件如何协同工作"></a>核心组件如何协同工作</h2><p>参考《深入分析Java Web技术内幕》一书中有个形象的比喻：Spring框架就像一场演出，Bean相当于演员，Context相当于演出的舞台背景、Core相当于演出的道具（把演员联系起来）。如果想演出足够新颖，就需要Spring提供的其他特色功能了。</p>
<p>回到Spring：Bean包装的是Object，而Object必然有数据，如何给这些数据提供生成环境就是Context要解决的事情，对于Context来说就是要发现每个Bean之间的关系，为他们建立这种关系并且维护好这种关系，而发现、建立和维护每个Bean之间的关系维护这种关系就需要Core组件了，Core组件其实就是发现、建立和维护每个Bean之间的关系所需要的一些列工具。最后我们发现Context就是一个Bean关系的集合，这个关系集合就叫<strong>IOC容器</strong>，当建立起IOC容器，Spring就可以工作了。他们的关系可以用下图来描述：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/gif/ccb.gif" alt="ccb"></p>
<h1 id="核心组件解析"><a href="#核心组件解析" class="headerlink" title="核心组件解析"></a>核心组件解析</h1><h2 id="Bean组件"><a href="#Bean组件" class="headerlink" title="Bean组件"></a>Bean组件</h2><p>Bean 组件在 Spring 的 org.springframework.beans 包下。这个包下的所有类主要解决了三件事：<strong>Bean 的定义、 Bean 的解析以及对Bean 的创建</strong>。对 Spring 的使用者来说唯一需要关心的就是 Bean 的创建，其他两个由 Spring 在内部帮你完成了，对你来说是透明的。</p>
<h3 id="Bean的定义"><a href="#Bean的定义" class="headerlink" title="Bean的定义"></a>Bean的定义</h3><p>Bean 的定义主要有 BeanDefinition 描述，如下图（RootBeanDefinition类图）说明了这些类的层次关系：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/rootBeanDefinition.png" alt="rootBeanDefinition"></p>
<p>Bean 的定义就是完整的描述了在 Spring 的配置的Bean中所有的信息。当 Spring 成功解析你定义的一个Bean后，在 Spring 的内部他就被转化成 BeanDefinition 对象，它可以定义为SINGLETON还是PROTOTYPE。以后所有的操作都是对这个对象完成的。</p>
<h3 id="Bean的解析"><a href="#Bean的解析" class="headerlink" title="Bean的解析"></a>Bean的解析</h3><p>Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析方式有很多种，这也就导致配置方式有很多种（之后会介绍各种Bean的配置方法，如xml，扫描，注解、java配置）。这里就介绍一下最早的解析XML配置，它的过程主要通过下图中的类(XmlBeanDefinitionReader)完成：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/XmlBeanDefinitionReader.png" alt="XmlBeanDefinitionReader"></p>
<h3 id="Bean的创建"><a href="#Bean的创建" class="headerlink" title="Bean的创建"></a>Bean的创建</h3><p>Spring Bean 的创建是典型的工厂模式，我们可以通过DefaultListableBeanFactory这个类来了解Spring的工厂模式，工厂模式的顶级接口是 BeanFactory，下图是这个工厂的继承层次关系：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/defaultListableBeanFactory.png" alt="image"></p>
<p>BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory。但是从上图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，他实现了所有的接口。</p>
<p>框架核心：那为何要定义这么多层次的接口呢？</p>
<p>查阅这些接口的源码和说明发现，每个接口都有他使用的场合，它主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制，具体如下：</p>
<ul>
<li>ListableBeanFactory 接口表示这些 Bean 是可列表的</li>
<li>HierarchicalBeanFactory 表示的是这些 Bean是有继承关系的，也就是每个 Bean有可能有父 Bean。</li>
<li>AutowireCapableBeanFactory 接口定义Bean的自动装配规则。</li>
</ul>
<p>这四个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为。</p>
<h2 id="Context组件"><a href="#Context组件" class="headerlink" title="Context组件"></a>Context组件</h2><p>Context 在 Spring 的 org.springframework.context 包下，<strong>Context 组件在 Spring 中的作用实际上就是给Spring提供一个运行时的环境，用以保存各个对象的状态</strong> 。下面看一下这个环境是如何构建的。</p>
<p>ApplicationContext 是 Context 的顶级父类，他除了能标识一个应用环境的基本信息外，他还继承了六个接口，这六个接口主要是扩展了 Context 的功能。下面是 Context 相关的类结构图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/AbstractRefreshableWebApplicationContext.png" alt="Context"></p>
<p>从上图中可以看出 ApplicationContext 继承了BeanFactory，这也说明了 Spring 容器中运行的主体对象是 Bean，另外 ApplicationContext 继承了 ResourceLoader 接口，使得 ApplicationContext 可以访问到任何外部资源（就是Core里面的工具了，这将在 Core 中详细说明）。</p>
<p>ApplicationContext 的子类主要包含两个方面：</p>
<ul>
<li>ConfigurableApplicationContext：表示该Context是可修改的，也就是在构建 Context 中用户可以动态添加或修改已有的配置信息，它下面又有多个子类，其中最经常使用的是可更新的 Context，即 AbstractRefreshableApplicationContext 类。</li>
<li>WebApplicationContext ：看到web就知道这为 web 准备的 Context 他可以直接访问到 ServletContext，通常情况下，这个接口使用的少。<br>再往下分就是按照构建 Context 的文件类型（没列出，感兴趣的可以自己去看），接着就是访问 Context 的方式。这样一级一级构成了完整的 Context 等级层次。</li>
</ul>
<p>总体来说 ApplicationContext 必须要完成以下几件事：</p>
<ul>
<li>标识一个应用环境</li>
<li>利用 BeanFactory 创建 Bean 对象</li>
<li>保存对象关系表</li>
<li>能够捕获各种事件</li>
</ul>
<p>Context 作为 Spring 的 <strong>IOC 容器</strong>，基本上整合了 Spring 的大部分功能，或者说是大部分功能的基础。</p>
<h2 id="Core组件"><a href="#Core组件" class="headerlink" title="Core组件"></a>Core组件</h2><p>Core 组件在Spring 的org.springframework.core包下，它作为 Spring的核心组件，他其中包含了很多的关键类，其中一个重要组成部分就是定义了资源（Resource）的访问方式。这种<strong>把所有资源都抽象成一个接口的方式</strong>很值得在以后的设计中拿来学习。下面就重要看一下这个部分在 Spring 的作用。我们通过下图（ Resource 相关的类结构图）来理解：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/resource.png" alt="resource"></p>
<p>从上图可以看出 Resource 接口封装了各种可能的资源类型，也就是对使用者来说屏蔽了文件类型的不同。对资源的提供者来说，如何把资源包装起来交给其他人用这也是一个问题(所以产生了很多方式)，我们看到 Resource 接口继承了 InputStreamSource 接口，这个接口中有个 getInputStream 方法，返回的是 InputStream 类。这样所有的资源都被可以通过 InputStream 这个类来获取，所以也屏蔽了资源的提供者。另外还有一个问题就是加载资源的问题，也就是资源的加载者要统一，从上图中可以看出这个任务是由 ResourceLoader 接口完成，他屏蔽了所有的资源加载者的差异，只需要实现这个接口就可以加载所有的资源，他的默认实现是 DefaultResourceLoader。</p>
<p>那Context 和 Resource 是如何建立关系的？下面是他们的类关系图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/cc.png" alt="cc"></p>
<p>从上图可以看出，Context 是把资源的加载、解析和描述工作委托给了 ResourcePatternResolver 类来完成，他相当于一个接头人，他把资源的加载、解析和资源的定义整合在一起便于其他组件使用。Core 组件中还有很多类似的方式。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入分析Java Web技术内幕》</li>
<li><a href="http://www.jb51.net/article/112039.htm" target="_blank" rel="external">Spring多种加载Bean方式解析</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：Spring作为现在最优秀的框架之一，被广泛得使用在Web场景中。很多人只会使用，但是却不知道Spring整个体系架构。
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Spring" scheme="http://bestlixiang.site/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_防火墙配置</title>
    <link href="http://bestlixiang.site/2018/04/09/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux-%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"/>
    <id>http://bestlixiang.site/2018/04/09/走进Linux/走进Linux-防火墙配置/</id>
    <published>2018-04-09T04:41:43.000Z</published>
    <updated>2018-04-09T04:42:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：保障数据的安全性是继保障数据的可用性之后最为重要的一项工作。防火墙作为公网与内网之间的保护屏障，在保障数据的安全性方面起着至关重要的作用。<a id="more"></a></p>
<h1 id="防火墙管理工具"><a href="#防火墙管理工具" class="headerlink" title="防火墙管理工具"></a>防火墙管理工具</h1><p>在公网与企业内网之间充当保护屏障的防火墙虽然有软件或硬件之分，但主要功能都是 <strong>依据策略对穿越防火墙自身的流量进行过滤。</strong> 防火墙策略可以基于流量的源目地址、端口号、协议、应用等信息来定制，然后防火墙使用预先定制的策略规则监控出入的流量，若流量与某一条策略规则相匹配，则执行相应的处理，反之则丢弃。这样一来，就可以保证仅有合法的流量在企业内网和外部公网之间流动了。</p>
<p>在Centos 7系统中，firewalld防火墙取代了iptables防火墙。但是 <strong>iptables与firewalld都不是真正的防火墙</strong> ，它们都只是用来定义防火墙策略的 <strong>防火墙管理工具</strong> 而已，或者说，它们只是一种 <strong>服务</strong> 。iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。虽然这些工具各有优劣，但它们在防火墙策略的配置思路上是保持一致的。</p>
<h1 id="Iptables"><a href="#Iptables" class="headerlink" title="Iptables"></a>Iptables</h1><p>在早期的Linux系统中，默认使用的是iptables防火墙管理服务来配置防火墙。尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables。</p>
<h2 id="策略与规则链"><a href="#策略与规则链" class="headerlink" title="策略与规则链"></a>策略与规则链</h2><p>防火墙会从上至下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。<strong>一般而言，防火墙策略规则的设置有两种：一种是“通”（即放行），一种是“堵”（即阻止）。当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否则谁都进不来；如果防火墙的默认策略为允许时，就要设置拒绝规则，否则谁都能进来，</strong> 防火墙也就失去了防范的作用。</p>
<p>iptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下：</p>
<ul>
<li>在进行路由选择前处理数据包（PREROUTING）</li>
<li>处理流入的数据包（INPUT）</li>
<li>处理流出的数据包（OUTPUT）</li>
<li>处理转发的数据包（FORWARD）</li>
<li>在进行路由选择后处理数据包（POSTROUTING）</li>
</ul>
<p>一般来说，从内网向外网发送的流量一般都是可控且良性的，<strong>因此我们使用最多的就是INPUT规则链</strong>， 该规则链可以增大黑客人员从外网入侵内网的难度。</p>
<p>iptables还可以选择采用什么样的动作来处理这些匹配的流量，比如“允许”、“拒绝”、“登记”、“不理它”。这些动作对应到iptables服务的术语中分别是</p>
<ul>
<li>ACCEPT（允许流量通过）</li>
<li>REJECT（拒绝流量通过）：</li>
<li>LOG（记录日志信息）</li>
<li>DROP（拒绝流量通过）。</li>
</ul>
<p>“允许流量通过”和“记录日志信息”都比较好理解，这里需要着重讲解的是REJECT和DROP的不同点。就DROP来说，它是直接将流量丢弃而且不响应；REJECT则会在拒绝流量后再回复一条“您的信息已经收到，但是被扔掉了”信息，从而让流量发送方清晰地看到数据被拒绝的响应信息。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>iptables是一款基于命令行的防火墙策略管理工具，对于日常的防火墙策略配置来讲，只需要掌握常用的参数并做到灵活搭配即可，这就足以应对日常工作了。</p>
<p>iptables命令可以根据<strong>流量的源地址、目的地址、传输协议、服务类型等信息进行匹配</strong>，一旦匹配成功，iptables就会根据策略规则所预设的动作来处理这些流量。另外，再次提醒一下，<strong>防火墙策略规则的匹配顺序是从上至下的，因此要把较为严格、优先级较高的策略规则放到前面，以免发生错误</strong>。下表总结归纳了常用的iptables命令参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-P</td>
<td>设置默认策略</td>
</tr>
<tr>
<td>-F</td>
<td>清空规则链</td>
</tr>
<tr>
<td>-L</td>
<td>查看规则链</td>
</tr>
<tr>
<td>-A</td>
<td>在规则链的末尾加入新规则</td>
</tr>
<tr>
<td>-I num</td>
<td>在规则链的头部加入新规则</td>
</tr>
<tr>
<td>-D num</td>
<td>删除某一条规则</td>
</tr>
<tr>
<td>-s</td>
<td>匹配来源地址IP/MASK，加叹号“!”表示除这个IP外</td>
</tr>
<tr>
<td>-d</td>
<td>匹配目标地址</td>
</tr>
<tr>
<td>-i</td>
<td>网卡名称    匹配从这块网卡流入的数据</td>
</tr>
<tr>
<td>-o</td>
<td>网卡名称    匹配从这块网卡流出的数据</td>
</tr>
<tr>
<td>-p</td>
<td>匹配协议，如TCP、UDP、ICMP</td>
</tr>
<tr>
<td>–dport num</td>
<td>匹配目标端口号</td>
</tr>
<tr>
<td>–sport num</td>
<td>匹配来源端口号</td>
</tr>
</tbody>
</table>
<p>范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 1. 查看已有的防火墙规则链</div><div class="line">iptables -L</div><div class="line"></div><div class="line">// 2. 清空已有的防火墙规则链</div><div class="line">iptables -F</div><div class="line"></div><div class="line">// 3. 把INPUT规则链的默认策略设置为拒绝(规则链的默认策略拒绝动作只能是DROP，而不能是REJECT)</div><div class="line">// 特别注意，如果你是在云服务上做实验，千万不要这样做，因为它会由于防火墙断开你的ssh连接，只能到控制台登录修改。</div><div class="line">iptables -P INPUT DROP</div><div class="line"></div><div class="line">// 4. 向INPUT链中添加拒绝ICMP流量进入的策略规则</div><div class="line">iptables -I INPUT -p icmp -j DROP</div><div class="line"></div><div class="line">// 5. 删除INPUT规则链中刚刚加入的那条策略（允许ICMP流量）</div><div class="line">iptables -D INPUT 1</div><div class="line"></div><div class="line">// 6. 将INPUT规则链设置为只允许指定网段的主机访问本机的22端口，拒绝来自其他所有主机的流量</div><div class="line">iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPT</div><div class="line"></div><div class="line">// 7. 向INPUT规则链中添加拒绝所有人访问本机12345端口的策略规则</div><div class="line">iptables -I INPUT -p tcp --dport 12345 -j REJECT</div><div class="line"></div><div class="line">// 8. 向INPUT规则链中添加拒绝192.168.10.5主机访问本机80端口（Web服务）的策略规则</div><div class="line">iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT</div><div class="line"></div><div class="line">// 9. 向INPUT规则链中添加拒绝所有主机访问本机1000～1024端口的策略规则</div><div class="line">iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT</div><div class="line"></div><div class="line">// 10. 使用iptables命令配置的防火墙规则默认会在系统下一次重启时失效，如果想让配置的防火墙策略永久生效，还要执行</div><div class="line">// 保存命令：</div><div class="line">service iptables save</div><div class="line">// 如果出现</div><div class="line">The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.</div><div class="line">需要如下操作：</div><div class="line">yum install iptables-services // 安装服务</div><div class="line">systemctl enable iptables // 设置开机启动iptables</div><div class="line">systemctl start iptables //打开iptables</div><div class="line">然后执行就可以了</div></pre></td></tr></table></figure></p>
<h1 id="Firewalld"><a href="#Firewalld" class="headerlink" title="Firewalld"></a>Firewalld</h1><p>Centos7系统中集成了多款防火墙管理工具，其中firewalld（Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器）服务是默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式。但是我们只介绍命令行界面。</p>
<h2 id="区域Zone"><a href="#区域Zone" class="headerlink" title="区域Zone"></a>区域Zone</h2><p>相较于传统的防火墙管理配置工具，<strong>firewalld支持动态更新技术并加入了区域（zone）的概念</strong>。简单来说，区域就是firewalld预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。从而极大地提升了防火墙策略的应用效率。firewalld中常见的区域名称（默认为public）以及相应的策略规则如下表所示：</p>
<table>
<thead>
<tr>
<th>区域</th>
<th>默认规则策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>trusted</td>
<td>允许所有的数据包</td>
</tr>
<tr>
<td>home</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>internal</td>
<td>等同于home区域</td>
</tr>
<tr>
<td>work</td>
<td>拒绝流入的流量，除非与流出的流量数相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>public</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>external</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>dmz</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>block</td>
<td>拒绝流入的流量，除非与流出的流量相关</td>
</tr>
<tr>
<td>drop</td>
<td>拒绝流入的流量，除非与流出的流量相关</td>
</tr>
</tbody>
</table>
<h2 id="基本使用：firewall-cmd"><a href="#基本使用：firewall-cmd" class="headerlink" title="基本使用：firewall-cmd"></a>基本使用：firewall-cmd</h2><p>firewall-cmd是firewalld防火墙配置管理工具的CLI（命令行界面）版本。它的参数一般都是以“长格式”来提供的，但是Centos7支持部分命令的参数补齐，其中就包含这条命令，美滋滋。也就是说，现在除了能用Tab键自动补齐命令或文件名等内容之外，还可以用Tab键来补齐下表中所示的长格式参数了：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>–get-default-zone</td>
<td>查询默认的区域名称</td>
</tr>
<tr>
<td>–set-default-zone=&lt;区域名称&gt;</td>
<td>设置默认的区域，使其永久生效</td>
</tr>
<tr>
<td>–get-zones</td>
<td>显示可用的区域</td>
</tr>
<tr>
<td>–get-services</td>
<td>显示预先定义的服务</td>
</tr>
<tr>
<td>–get-active-zones</td>
<td>显示当前正在使用的区域与网卡名称</td>
</tr>
<tr>
<td>–remove-source=</td>
<td>将源自此IP或子网的流量导向指定的区域</td>
</tr>
<tr>
<td>–remove-source=</td>
<td>不再将源自此IP或子网的流量导向某个指定区域</td>
</tr>
<tr>
<td>–add-interface=&lt;网卡名称&gt;</td>
<td>将源自该网卡的所有流量都导向某个指定区域</td>
</tr>
<tr>
<td>–change-interface=&lt;网卡名称&gt;</td>
<td>将某个网卡与区域进行关联</td>
</tr>
<tr>
<td>–list-all</td>
<td>显示当前区域的网卡配置参数、资源、端口以及服务等信息</td>
</tr>
<tr>
<td>–list-all-zones</td>
<td>显示所有区域的网卡配置参数、资源、端口以及服务等信息</td>
</tr>
<tr>
<td>–add-service=&lt;服务名&gt;</td>
<td>设置默认区域允许该服务的流量</td>
</tr>
<tr>
<td>–add-port=&lt;端口号/协议&gt;</td>
<td>设置默认区域允许该端口的流量</td>
</tr>
<tr>
<td>–remove-service=&lt;服务名&gt;</td>
<td>设置默认区域不再允许该服务的流量</td>
</tr>
<tr>
<td>–remove-port=&lt;端口号/协议&gt;</td>
<td>设置默认区域不再允许该端口的流量</td>
</tr>
<tr>
<td>–reload</td>
<td>让“永久生效”的配置规则立即生效，并覆盖当前的配置规则</td>
</tr>
<tr>
<td>–panic-on</td>
<td>开启应急状况模式</td>
</tr>
<tr>
<td>–panic-off</td>
<td>关闭应急状况模式</td>
</tr>
</tbody>
</table>
<p>与Linux系统中其他的防火墙策略配置工具一样，<strong>使用firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且随着系统的重启会失效。如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd命令正常设置防火墙策略时添加–permanent参数，这样配置的防火墙策略就可以永久生效了。但是使用永久生效模式设置的策略只有在系统重启之后才能自动生效。如果想让配置的策略立即生效，需要手动执行firewall-cmd –reload命令。</strong></p>
<p>使用范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">// 1. 查看firewalld服务当前所使用的区域</div><div class="line">firewall-cmd --get-default-zone</div><div class="line"></div><div class="line">// 2. 查询eth0网卡在firewalld服务中的区域</div><div class="line">firewall-cmd --get-zone-of-interface=eth0</div><div class="line"></div><div class="line">// 3. 把firewalld服务中eth0网卡的默认区域修改为external，并在系统重启后生效。</div><div class="line">// 分别查看当前与永久模式下的区域名称：</div><div class="line">firewall-cmd --permanent --zone=external --change-interface=eth0</div><div class="line">firewall-cmd --get-zone-of-interface=eth0</div><div class="line">firewall-cmd --permanent --get-zone-of-interface=eth0</div><div class="line"></div><div class="line">// 4. 把firewalld服务的当前默认区域设置为public</div><div class="line">firewall-cmd --set-default-zone=public</div><div class="line"></div><div class="line">// 5. 启动/关闭firewalld防火墙服务的应急状况模式，阻断一切网络连接（当远程控制服务器时请慎用）</div><div class="line">firewall-cmd --panic-on</div><div class="line">firewall-cmd --panic-off</div><div class="line"></div><div class="line">// 6. 查询public区域是否允许请求SSH和HTTPS协议的流量</div><div class="line">firewall-cmd --zone=public --query-service=ssh</div><div class="line">firewall-cmd --zone=public --query-service=https</div><div class="line"></div><div class="line">// 7. 把firewalld服务中请求HTTPS协议的流量设置为永久允许，并立即生效</div><div class="line">firewall-cmd --zone=public --add-service=https</div><div class="line">firewall-cmd --permanent --zone=public --add-service=https</div><div class="line">firewall-cmd --reload</div><div class="line"></div><div class="line">// 8. 把firewalld服务中请求HTTP协议的流量设置为永久拒绝，并立即生效</div><div class="line">firewall-cmd --permanent --zone=public --remove-service=http</div><div class="line">firewall-cmd --reload</div><div class="line"></div><div class="line">// 9. 把在firewalld服务中访问8080和8081端口的流量策略设置为允许，但仅限当前生效</div><div class="line">firewall-cmd --zone=public --add-port=8080-8081/tcp</div><div class="line"></div><div class="line">// 10. 把原本访问本机888端口的流量转发到22端口，要且求当前和长期均有效</div><div class="line">firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.10.10(目标地址)</div><div class="line">firewall-cmd --reload</div><div class="line"></div><div class="line">// 11. firewalld中的富规则表示更细致、更详细的防火墙策略配置，</div><div class="line">// 它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置。</div><div class="line">// 它的优先级在所有的防火墙策略中也是最高的。比如，我们可以在firewalld服务中配置一条富规则，使其拒绝192.168.10.0/24网段的所有用户访问本机的ssh服务（22端口）：</div><div class="line">firewall-cmd --permanent --zone=public --add-rich-rule=&quot;rule family=&quot;ipv4&quot; \</div><div class="line">source address=&quot;192.168.10.0/24&quot; service name=&quot;ssh&quot; reject&quot;</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.linuxprobe.com/chapter-08.html" target="_blank" rel="external">iptables与firewalld防火墙</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：保障数据的安全性是继保障数据的可用性之后最为重要的一项工作。防火墙作为公网与内网之间的保护屏障，在保障数据的安全性方面起着至关重要的作用。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_Linux中常用的网络命令</title>
    <link href="http://bestlixiang.site/2018/04/08/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_Linux%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://bestlixiang.site/2018/04/08/走进Linux/走进Linux_Linux中常用的网络命令/</id>
    <published>2018-04-08T12:51:27.000Z</published>
    <updated>2018-04-09T04:31:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：Linux的网络功能是相当强大的。所以我们必须要好好了解它，这里我们只是介绍一下常用的命令。<a id="more"></a></p>
<h1 id="设置网络参数的命令"><a href="#设置网络参数的命令" class="headerlink" title="设置网络参数的命令"></a>设置网络参数的命令</h1><h2 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h2><p>ifconfig主要是可以都手动启动、查看与修改网络接口的相关参数，范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 1. 查看所有网络接口</div><div class="line">ifconfig</div><div class="line">// 2. 查看eth0网卡</div><div class="line">ifconfig eth0</div><div class="line"></div><div class="line">输出：</div><div class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</div><div class="line">        inet 172.16.0.9  netmask 255.255.240.0  broadcast 172.16.15.255</div><div class="line">        ether 52:54:00:1c:91:2a  txqueuelen 1000  (Ethernet)</div><div class="line">        RX packets 15979545  bytes 1741444280 (1.6 GiB)</div><div class="line">        RX errors 0  dropped 0  overruns 0  frame 0</div><div class="line">        TX packets 15811187  bytes 2149680103 (2.0 GiB)</div><div class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</div><div class="line"></div><div class="line">* eth0：就是网络卡的代号，也有 lo 这个 loopback</div><div class="line">* mtu：网络接口的最大传输单元</div><div class="line">* inet：IPv4 的 IP 地址，后续是子网掩码和广播地址</div><div class="line">* RX：那一行代表的是网络由启动到目前为止的封包接收情况， packets 代表封包数、errors 代表封包发生错误的数量、 dropped 代表封包由于有问题而遭丢弃的数量等等</div><div class="line">* TX：与 RX 相反，为网络由启动到目前为止的传送情况；collisions：代表封包碰撞的情况，如果发生太多次， 表示您的网络状况不太好</div><div class="line"></div><div class="line">// 3. 暂时修改网络接口，给予eth0一个192.168.100.100/24的参数</div><div class="line">ifconfig eth0 192.168.100.100</div><div class="line"></div><div class="line">// 4. 将手动的处理全部取消，使用原有的设置值重置网络参数</div><div class="line">/etc/init.d/network restart</div></pre></td></tr></table></figure></p>
<h1 id="网络排错与查看命令"><a href="#网络排错与查看命令" class="headerlink" title="网络排错与查看命令"></a>网络排错与查看命令</h1><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>这个 ping 是很重要的指令，ping 主要透过 ICMP（Internet控制报文协议） 封包来进行整个网络的状况报告。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 1. 检测一下168.95.1.1这部DNS主机是否存在(存在于网络环境中)</div><div class="line">ping -c 3 168.95.1.1</div><div class="line"></div><div class="line">输出：</div><div class="line">PING 168.95.1.1 (168.95.1.1) 56(84) bytes of data.</div><div class="line">64 bytes from 168.95.1.1: icmp_seq=1 ttl=239 time=69.9 ms</div><div class="line">64 bytes from 168.95.1.1: icmp_seq=2 ttl=239 time=70.4 ms</div><div class="line">64 bytes from 168.95.1.1: icmp_seq=3 ttl=239 time=69.9 ms</div><div class="line"></div><div class="line">--- 168.95.1.1 ping statistics ---</div><div class="line">3 packets transmitted, 3 received, 0% packet loss, time 2002ms</div><div class="line">rtt min/avg/max/mdev = 69.920/70.119/70.467/0.328 ms</div><div class="line"></div><div class="line"></div><div class="line">// 2. 找出最大的MTU数值(如果有响应，那就是可以接受这个数据包，如果无响应，就表示这个MTU太大了)</div><div class="line">ping -c 2 -s 1000 -M do 192.168.1.254</div></pre></td></tr></table></figure></p>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>如果你觉得你的某个网络服务明明就启动了，但是就是无法造成联机的话，要查询一下自己的网络接口所监听的端口 (port) 来看看是否真的有启动。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 1. 列出当前路由表状态，且以IP及port number进行系那是</div><div class="line">netstat -rn</div><div class="line"></div><div class="line">// 2. 列出当前的所有网络连接状态，使用IP与port number</div><div class="line">netstat -an</div><div class="line"></div><div class="line">// 3. 显示目前已经启动的网络服务</div><div class="line">netstat -tulnp</div><div class="line"></div><div class="line">// 4. 查看本机上所有的网络连接状态</div><div class="line">netstat -atunp</div></pre></td></tr></table></figure></p>
<h2 id="host"><a href="#host" class="headerlink" title="host"></a>host</h2><p>这个命令可以用来查出某个主机名的IP，范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 列出www.yahoo.com的IP(向/etc/resolv.conf里面记录的DNS服务器查询IP)</div><div class="line">host www.yohoo.com</div></pre></td></tr></table></figure></p>
<h2 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h2><p>功能和host一样，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. 查询www.google.com的IP</div><div class="line">nslookup www.google.com</div><div class="line"></div><div class="line">// 2. 找出168.95.1.1的主机名   (建议使用dig)</div><div class="line">nslookup 168.95.1.1</div></pre></td></tr></table></figure>
<h1 id="远程连接命令与即时通信软件"><a href="#远程连接命令与即时通信软件" class="headerlink" title="远程连接命令与即时通信软件"></a>远程连接命令与即时通信软件</h1><h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p>telnet本身数据的在传输过程中使用的是明文，所以数据在Internet上面传输的时候，会比较危险。使用范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 1. 连接到当前热门的PTT BBS站点ptt.cc</div><div class="line">yum install telnet // 默认没有安装（自己未成功）</div><div class="line"></div><div class="line">// 2. 检测本地主机的110这个port是否正确启动,</div><div class="line">// 如果出现telnet: connect to address 127.0.0.1: Connection refused，代表这个port没有启动或者这个连接有问题</div><div class="line">telnet localhost 22</div></pre></td></tr></table></figure></p>
<h2 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h2><p>用于处理ftp服务器的下载数据，范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 连接到一个ftp服务器</div><div class="line">ftp ip //之后可以利用help来帮助操作</div></pre></td></tr></table></figure></p>
<h1 id="文字接口网页浏览"><a href="#文字接口网页浏览" class="headerlink" title="文字接口网页浏览"></a>文字接口网页浏览</h1><h2 id="links"><a href="#links" class="headerlink" title="links"></a>links</h2><p>最大的功能就是查阅Linux本机上面以html语法写成的文件数据。具体效果自己看吧，范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 浏览Linux kernel网站</div><div class="line">links http://www.kernel.org</div></pre></td></tr></table></figure></p>
<h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p>主要的功能是取得网页数据。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 1. 下载 2.6.17 版的linux内核</div><div class="line">wget \</div><div class="line">http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.17.tar.gz</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：Linux的网络功能是相当强大的。所以我们必须要好好了解它，这里我们只是介绍一下常用的命令。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_软件安装</title>
    <link href="http://bestlixiang.site/2018/04/08/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://bestlixiang.site/2018/04/08/走进Linux/走进Linux_软件安装-软件安装/</id>
    <published>2018-04-08T09:14:14.000Z</published>
    <updated>2018-04-09T04:34:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：当你拿到一台新电脑的第一反应是什么，当然是装软件，然后好好玩呀！服务器也是如此，所以你必须掌握软件的安装。<a id="more"></a></p>
<h1 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h1><h2 id="开放源码的软件安装相关概念"><a href="#开放源码的软件安装相关概念" class="headerlink" title="开放源码的软件安装相关概念"></a>开放源码的软件安装相关概念</h2><p>Linux上几乎所有的软件都经过了GPL授权，因此几乎所有的软件都会提供源码。<br>而一个软件要在Linux上执行，必须是二进制文件，因此当我们拿到软件源码后，需要将它编译成二进制文件才能在Linux上运行。</p>
<h3 id="开放源码、编译程序、可执行文件"><a href="#开放源码、编译程序、可执行文件" class="headerlink" title="开放源码、编译程序、可执行文件"></a>开放源码、编译程序、可执行文件</h3><ol>
<li>开放源码：就是程序代码，写给人类看的语言，但机器并不认识，所以无法执行。</li>
<li>编译程序：将程序代码转译称为机器看得懂的语言。</li>
<li>可执行文件：经过编译程序变成二进制程序后，机器看得懂所以可执行的文件。</li>
</ol>
<h3 id="函式库"><a href="#函式库" class="headerlink" title="函式库"></a>函式库</h3><p>类似子程序的角色，可以被呼叫来执行的一段功能函数。</p>
<h3 id="make与configure"><a href="#make与configure" class="headerlink" title="make与configure"></a>make与configure</h3><ol>
<li>configure:侦测用户操作环境，是否支持软件的运行，侦测完毕生成makefile文件<ul>
<li>是否有适合的编译程序可以编译本软件的程序代码</li>
<li>是否已经存在本软件所需要的函数库，或其他需要的相依软件</li>
<li>操作系统平台是否适合本软件，包括 Linux 的核心版本</li>
<li>核心的头文件定义档 (header include) 是否存在 (驱动程序必须要的侦测)。</li>
</ul>
</li>
<li>make:make是一个程序，会去找makefile文件，然后执行编译。</li>
</ol>
<h3 id="tarball软件"><a href="#tarball软件" class="headerlink" title="tarball软件"></a>tarball软件</h3><p>tarball文件其实就是将软件的源码先以tar打包，然后再压缩。其实就是一个<strong>软件包</strong>。通常解压缩之后会存在源代码文件、侦测程序文件（configure）、本软件的简易说明与安装说明（README）。</p>
<h2 id="Tarball的安装的基本步骤"><a href="#Tarball的安装的基本步骤" class="headerlink" title="Tarball的安装的基本步骤"></a>Tarball的安装的基本步骤</h2><ol>
<li>取得源文件：将tarball文件在/usr/local/src目录解压缩</li>
<li>取得步骤流程：进入新建立的目录下面，去查阅INSTALL与README等相关文件内容（很重要）</li>
<li>相关属性软件安装：根据INSTALL/README的内容查看并安装好一些相关的软件</li>
<li>建立makefile文件：以自动检测程序（configure）检测操作环境，并建立Makefile文件</li>
<li>编译：以make这个程序并使用该目录下得Makefile作为它的参数配置文件，来进行make的操作</li>
<li>安装：以make这个程序，并以Makefile这个参数配置文件，依据install这个目标（在Makefile文件中会有多个操作目标，如clean）的指定来安装到正确地路径。</li>
</ol>
<h2 id="Tarball软件安装的建议事项"><a href="#Tarball软件安装的建议事项" class="headerlink" title="Tarball软件安装的建议事项"></a>Tarball软件安装的建议事项</h2><p>在默认情况下，原本的Linux distribution发布安装的软件大多是在/usr里面的，而自行安装的软件则建议放置在/usr/local里面。</p>
<ul>
<li>linux distribution默认的安装软件的路径如下，以httpd为例：<ul>
<li>/etc/httpd（配置文件）</li>
<li>/usr/lib（函数库）</li>
<li>/usr/bin（可执行文件）</li>
<li>/usr/share/man（在线帮助文档）</li>
</ul>
</li>
<li>tarball安装，默认放在/usr/local，如下目录：（升级，删除不方便）<ul>
<li>/usr/local/etc</li>
<li>/usr/local/bin</li>
<li>/usr/local/lib</li>
<li>/usr/local/man</li>
</ul>
</li>
<li>tarball安装，但是单一软件都在同一个目录下，以apache为例：（利于删除，升级）<ul>
<li>/usr/local/apache/etc</li>
<li>/usr/local/apache/bin</li>
<li>/usr/local/apache/lib</li>
<li>/usr/local/apache/man</li>
</ul>
</li>
</ul>
<p>当然，<strong>实际安装的时候还是得视该软件的Makefile里头的install目标信息才能知道安装路径情况。</strong></p>
<p>为了方便Tarball的管理，这样建议：</p>
<ol>
<li>最好将tarball的原始数据解压缩到/usr/local/src当中</li>
<li>安装时，最好安装到/usr/local这个默认路径下</li>
<li>考虑将来的删除，最好可以将每个软件<strong>单独</strong>安装在/usr/local下面</li>
<li>为安装到单独目录的软件的man page加入到man path搜索，即在/etc/man.config增加一行。</li>
</ol>
<h2 id="简单安装范例（ntp时间服务器）"><a href="#简单安装范例（ntp时间服务器）" class="headerlink" title="简单安装范例（ntp时间服务器）"></a>简单安装范例（ntp时间服务器）</h2><p>假设这个软件在/opt下，解压到/usr/local/src，并安装到/usr/local/ntp目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/src //切换目录</div><div class="line"></div><div class="line">tar -zxvf /opt/ntp-4.2.4p7.tar.gz //解压缩到此目录</div><div class="line"></div><div class="line">cd ntp-4.2.4p7/</div><div class="line"></div><div class="line">vi INSTALL // 查阅安装信息</div><div class="line"></div><div class="line">// 检查configure支持参数，并实际生成makefile规则文件(很重要)</div><div class="line">./configure --help | more</div><div class="line"></div><div class="line">./configure --prefix=/usr/local/ntp \</div><div class="line">--enable-all-clocks --enable-parse-clocks //开始建立makefile（设置了安装目录等）</div><div class="line"></div><div class="line"></div><div class="line">// 开始编译并安装</div><div class="line">make clean; make</div><div class="line">make check</div><div class="line">make install</div></pre></td></tr></table></figure></p>
<h2 id="利用patch更新源码"><a href="#利用patch更新源码" class="headerlink" title="利用patch更新源码"></a>利用patch更新源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 基本语法</div><div class="line">1. patch -p 数字 &lt; patch_file  更新</div><div class="line">2. patch -R &lt; patch_file 还原更新</div><div class="line"></div><div class="line">假如patch_file第一行是***/home/guest/example/expatch.old，</div><div class="line">如果执行patch -p0  &lt; patch_file，则更新的文件是/home/guest/example/expatch.old，</div><div class="line">如果执行patch -p4  &lt; patch_file，则更新的文件是expatch.old，</div><div class="line">基本语法中数字是指拿掉第几个下划线之前的东西（包括下划线）。</div><div class="line"></div><div class="line">在更新之后，还是需要重新编辑，这才是最终的正确的软件。</div></pre></td></tr></table></figure>
<h1 id="RPM安装"><a href="#RPM安装" class="headerlink" title="RPM安装"></a>RPM安装</h1><h2 id="RPM和DPKG"><a href="#RPM和DPKG" class="headerlink" title="RPM和DPKG"></a>RPM和DPKG</h2><p>当前Linux上有两款主流的软件管理程序，分别是：RPM和DPKG。<br>这两款软件均提供在线升级机制。</p>
<ul>
<li><p>RPM</p>
<p>  RPM全称为Red Hat Package Manager，是Red Hat公司研发的Linux软件管理程序。目前CentOS、SuSE、Fedora等操作系统使用它。<br>  RPM使用YUM进行在线升级。</p>
</li>
<li><p>DPKG<br>  dpkg由Debian Linux开发，目前使用该软件的操作系统有Ubuntu、B2D等。<br>  dpkg使用apt-get进行在线升级。</p>
</li>
</ul>
<p>PS：什么是“在线升级机制”？<br>一个软件往往会依赖其他软件的一些功能，那么在安装过程中，只有确保一个软件所依赖的所有软件都被安装后，该软件才能被正确安装。<br>而在线升级机制能够在软件安装过程中，若发现该软件的依赖软件尚未安装，则会自动从互联网中下载所依赖的软件。这就是在线升级机制</p>
<h2 id="RPM默认安装的路径"><a href="#RPM默认安装的路径" class="headerlink" title="RPM默认安装的路径"></a>RPM默认安装的路径</h2><table>
<thead>
<tr>
<th>/etc</th>
<th>一些设置文件放置的目录，例如/etc/crontab</th>
</tr>
</thead>
<tbody>
<tr>
<td>/usr/bin</td>
<td>一些可执行文件</td>
</tr>
<tr>
<td>/usr/lib</td>
<td>一些程序使用的动态函数库</td>
</tr>
<tr>
<td>/usr/share/doc</td>
<td>一些基本的软件使用手册与帮助文档</td>
</tr>
<tr>
<td>/usr/share/man</td>
<td>一些man page文件</td>
</tr>
</tbody>
</table>
<h2 id="RPM安装-1"><a href="#RPM安装-1" class="headerlink" title="RPM安装"></a>RPM安装</h2><p>因为安装软件是root的工作，所以你必须是root用户才能使用rpm命令，使用范例如下(例子为安装rp-pppoe-3.5-32.1.i386.rpm)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 安装软件是，显示安装信息与进度</div><div class="line">rpm -ivh rp-pppoe-3.5-32.1.i386.rpm</div></pre></td></tr></table></figure></p>
<h2 id="RPM的升级与更新"><a href="#RPM的升级与更新" class="headerlink" title="RPM的升级与更新"></a>RPM的升级与更新</h2><p>范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rpm -Uvh 需要升级的软件名</div><div class="line"></div><div class="line">-Uvh:若待升级的软件尚未安装，则直接安装</div><div class="line"></div><div class="line">rpm -Fvh 需要升级的软件名</div><div class="line"></div><div class="line">-Fvh:若待升级的软件尚未安装，则该软件不会被安装</div></pre></td></tr></table></figure></p>
<h2 id="RPM查询"><a href="#RPM查询" class="headerlink" title="RPM查询"></a>RPM查询</h2><p>查询的信息分为两类，一类是查询已被安装的软件的信息(由/var/lib/rpm提供)，另一类是查询尚未被安装的软件安装包的信息。 第一类信息通过rpm -q查询，第二类信息通过rpm -qp查询。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 1. 找出你的Linux是否安装logrotate这个软件</div><div class="line">rpm -q logrorate</div><div class="line"></div><div class="line">// 2. 列出logrotate这个软件所提供的所有目录与文件</div><div class="line">rpm -ql logrorate</div><div class="line"></div><div class="line">// 3. 列出logrotate这个软件的相关文件说明</div><div class="line">rpm -qi logrorate</div><div class="line"></div><div class="line">// 4. 列出logrotate这个软件的设置文件与帮助文件</div><div class="line">rpm -qc logrorate</div><div class="line">rpm -qd logrorate</div><div class="line"></div><div class="line">// 5. 列出logrotate这个软件所依赖软件的文件</div><div class="line">rpm -qR logrorate</div><div class="line"></div><div class="line">// 6. 列出该文件属于哪一个软件</div><div class="line">rpm -qf /bin/sh</div></pre></td></tr></table></figure></p>
<h2 id="卸载RPM与重建数据库"><a href="#卸载RPM与重建数据库" class="headerlink" title="卸载RPM与重建数据库"></a>卸载RPM与重建数据库</h2><p>卸载一个软件非常方便，通过-e即可删除。但一个软件所提供的动态函数库被其他软件引用，那么该软件将无法卸载，除非将引用该函数库的所有软件都卸载后才能卸载。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 找出与pam有关的软件名称，并尝试删除pam这个软件</div><div class="line">rpm -qa | grep pam</div><div class="line">rpm -e pam（出错，因为你需要先删除依赖它的软件）</div><div class="line"></div><div class="line">2. 删除pam-devel软件</div><div class="line">rpm -e pam-devel (成功)</div></pre></td></tr></table></figure></p>
<p>当/var/lib/rpm内的文件发生损坏时，可以通过如下命令重建数据库修复：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm --rebuilddb</div></pre></td></tr></table></figure></p>
<h1 id="YUM安装"><a href="#YUM安装" class="headerlink" title="YUM安装"></a>YUM安装</h1><p>RPM虽然省去了编译过程，并且提供数据库存储软件的信息，但仍然需要我们手动下载RPM安装包，而YUM的出现解决了这一问题。较多软件的RPM安装包都存放在了YUM Server上，只要我们的计算机能连互联网，就能使用yum自动下载RPM安装包并安装软件。</p>
<h2 id="yum功能"><a href="#yum功能" class="headerlink" title="yum功能"></a>yum功能</h2><p>yum的使用非常简单，就是通过yum这个命令，用法范例如下：</p>
<ol>
<li><p>查询功能</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 1. 搜索磁盘阵列相关的软件</div><div class="line">yum search raid</div><div class="line"></div><div class="line">// 2. 找出mdadm这个软件的功能如何</div><div class="line">yum info mdadm</div><div class="line"></div><div class="line">// 3. 列出yum服务器上面提供的所有软件名称</div><div class="line">yum list</div><div class="line"></div><div class="line">// 4. 列出目前服务器上可供本机升级的软件有哪些</div><div class="line">yum list updates</div><div class="line"></div><div class="line">// 5. 列出提供passwd这个文件的软件有哪些</div><div class="line">yum provides passwd</div></pre></td></tr></table></figure>
</li>
<li><p>安装/升级功能</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 安装/升级pam-devel</div><div class="line">yum install/update pam-devel</div></pre></td></tr></table></figure>
</li>
<li><p>删除功能</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 删除pam-devel</div><div class="line">yum remove pam-devel</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="管理的选择：RPM-or-Tarball"><a href="#管理的选择：RPM-or-Tarball" class="headerlink" title="管理的选择：RPM or Tarball"></a>管理的选择：RPM or Tarball</h1><p>建议如下：</p>
<ol>
<li>优先选择原厂的RPM功能</li>
<li>选择软件官方网站发布的RPM或者是提供的容器网址（yum server）</li>
<li>利用Tabball安装特殊软件（没有RPM）</li>
<li>用Tarball测试新版软件</li>
</ol>
<p>RPM与Tarball各有优点，但是如果有RPM的话，优先选择RPM。如果无法解决依赖性问题，那就选tarball。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：当你拿到一台新电脑的第一反应是什么，当然是装软件，然后好好玩呀！服务器也是如此，所以你必须掌握软件的安装。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_daemon为服务(service)保驾护航</title>
    <link href="http://bestlixiang.site/2018/04/03/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_daemon%E4%B8%BA%E6%9C%8D%E5%8A%A1(service)%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA/"/>
    <id>http://bestlixiang.site/2018/04/03/走进Linux/走进Linux_daemon为服务(service)保驾护航/</id>
    <published>2018-04-03T08:59:47.000Z</published>
    <updated>2018-04-09T04:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：我们进程会听到daemon，但是却不知道其义，其实就是一个守护进程，作用是支持其他服务(service)的运行。我们下面可以好好看看linux中的daemon与service！<a id="more"></a></p>
<h1 id="什么是daemon与服务"><a href="#什么是daemon与服务" class="headerlink" title="什么是daemon与服务"></a>什么是daemon与服务</h1><p>系统为了某些功能必须要提供一些服务，这个服务就称为<strong>service</strong>。但是service的提供总是需要进程的运行，所以实现这个service的程序我们就称它为<strong>daemon</strong>。</p>
<h2 id="daemon的分类"><a href="#daemon的分类" class="headerlink" title="daemon的分类"></a>daemon的分类</h2><p>分类方式一：按照“是否可以独立启动”分类</p>
<ol>
<li>stand alone类型的daemon：这种类型的daemon可以自行启动，启动之后可以常驻内存，直到手动关闭该daemon才释放资源。如www。</li>
<li>由super daemon管理的daemon：这种类型的daemon由super daemon统一管理，当请求到来时，由super daemon启动请求的服务，请求完成后便释放内存资源。如telnet。</li>
</ol>
<p>分类方式二：按照“请求到来时是否能够立即运行”分类</p>
<ol>
<li><p>signal-control类型的daemon<br>这种类型的daemon当有请求到来时便能立即执行。如打印机服务。</p>
</li>
<li><p>interval-control类型的daemon<br>这种类型的daemon会周期性地执行某项工作，因此它没有请求一说，它会周期性地读取配置文件，并执行配置文件中要求的功能。如crond、atd都属于interval-control类型的daemon。</p>
</li>
</ol>
<p>通常在服务的名称的之后都会加一个d。</p>
<h2 id="网络服务与端口的对应"><a href="#网络服务与端口的对应" class="headerlink" title="网络服务与端口的对应"></a>网络服务与端口的对应</h2><p>当系统提供了网络服务，就会涉及到端口的问题，这些服务与端口的定义文件在/etc/services。大家可以自己查看一下。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tcpmux          1/tcp                           # TCP port service multiplexer</div><div class="line">tcpmux          1/udp                           # TCP port service multiplexer</div></pre></td></tr></table></figure></p>
<p>第一列为daemon的名称，第二列为该daemon所使用的端口号与网络数据包协议。</p>
<h2 id="daemon的启动脚本与启动方式"><a href="#daemon的启动脚本与启动方式" class="headerlink" title="daemon的启动脚本与启动方式"></a>daemon的启动脚本与启动方式</h2><p>stand-alone类型的daemon和super daemon类型的daemon有各自的启动方式</p>
<h3 id="stand-alone型Daemon的启动方式"><a href="#stand-alone型Daemon的启动方式" class="headerlink" title="stand alone型Daemon的启动方式"></a>stand alone型Daemon的启动方式</h3><ol>
<li><p>通过/etc/init.d/xxx启动。启动一个服务是一个繁琐的过程，你需要进行一系列启动前的操作，为了避免这些麻烦，服务提供商把这些繁琐的过程封装在一个shell srcipt中，我们只需执行一个shell script即可启动一个daemon。几乎所有的stand alone型daemon的启动脚本都放在/etc/init.d/下，所以我们只需执行 <strong>/etc/init.d/xxx start</strong> 即可启动xxx服务。</p>
</li>
<li><p>通过service命令启动。若每次启动一个命令都要写/etc/init.d/略微有些麻烦，service命令将其进行了封装，我们只要执行 <strong>“service xxx start/status/restart/stop”</strong> 即可开启/查看/重启/关闭xxx服务。</p>
</li>
</ol>
<h3 id="super-daemon型Daemon的启动方式"><a href="#super-daemon型Daemon的启动方式" class="headerlink" title="super daemon型Daemon的启动方式"></a>super daemon型Daemon的启动方式</h3><ol>
<li><p>设置daemon的配置文件，每一个被super daemon管理的daemon都有一个配置文件，在/etc/xinetd.d/目录下。每个daemon的开启或关闭均在该daemon对应的配置文件中设置。</p>
</li>
<li><p>启动super daemon，super daemon是一个stand alone型daemon，因此在daemon的配置文件设置好后可通过<strong>service xinetd start</strong>启动所有由super daemon管理的daemon。</p>
</li>
</ol>
<h1 id="解析super-daemon的配置文件"><a href="#解析super-daemon的配置文件" class="headerlink" title="解析super daemon的配置文件"></a>解析super daemon的配置文件</h1><h2 id="默认值配置文件：xinetd-conf"><a href="#默认值配置文件：xinetd-conf" class="headerlink" title="默认值配置文件：xinetd.conf"></a>默认值配置文件：xinetd.conf</h2><p>高版本的contos可能没有该文件，是因为没有安装，所以要先用“yum install xinetd”安装之后，就可以看见了。</p>
<p>super daemon的默认配置文件为:/etc/xinetd.conf，它为它所管理的所有daemon做了一些默认的配置。<br>从最后一行的includedir /etc/xinetd.d可以看出，它加载了它所管理的所有daemon的配置。</p>
<p>下面来看一下具体的某个daemon的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">service rsync #service后为daemon的名字</div><div class="line">&#123;</div><div class="line">        disable = yes  # yes表示关闭此daemon，no表示开启此daemon</div><div class="line">        socket_type     = stream #stream表示使用TCP、dgram表示使用UDP、raw表示直接与IP交互</div><div class="line">        wait            = no</div><div class="line">        user            = root #以什么用户的身份启动这个daemon</div><div class="line">        server          = /usr/bin/rsync #这个daemon的启动程序</div><div class="line">        server_args     = --daemon #启动时所需的参数</div><div class="line">        log_on_failure  += USERID # 登录失败时需要记录用户</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>=：表示将某个参数设为等号右侧的值，若先前设置中已设置过该参数，则直接覆盖</li>
<li>+=：表示保留先前设置的这个参数，再给这个参数增加个值。</li>
<li>-和-=的含义同上。</li>
</ul>
<h1 id="super-deamon的防火墙管理"><a href="#super-deamon的防火墙管理" class="headerlink" title="super deamon的防火墙管理"></a>super deamon的防火墙管理</h1><p>由于受super daemon管理的daemon的请求都首先需要经过super daemon，因此super daemon可以充当防火墙的角色，拒绝一些不安全的请求。<br>super daemon提供了两种防火墙机制，第一种方式提供较多详细的安全设置，而第二种方式只能阻挡或允许指定的IP，具体见下：</p>
<ol>
<li><p>使用受super daemon管理的daemon的配置文件实现防火墙机制</p>
<p> 在某个具体的daemon配置文件中添加如下参数，即可为daemon配置防火墙：</p>
<ul>
<li>instance=数字/UNLIMITED：设置该daemon能够承受的最大连接数。`  </li>
<li>per_source=数字/UNLIMITED：每个IP的最大连接数。</li>
<li>Cps=数字1 数字2：该daemon在一秒内的连接数超过数字1，则暂时关闭该da* emon数字2的秒数。</li>
<li>log_on_success/failure=PID/HOST/USERID/EXIT/DURATION：当登录成功/* 失败时记录的信息。HOST：连接者的IP、EXIT：离开时间、DURATION：为该用户服务的时间。</li>
<li>redirect=IP：将用户的请求转至指定服务器。</li>
<li>bind=IP：允许用户用哪个IP访问本服务。<br>only_from=[0.0.0.0,192.168.1.0:24]：只允许指定IP的用户访问。0.0.0.0表示允许所有用户，192.168.1.0:24表示只允许192.168.1.1－192.168.1.255之间的用户访问。<br>access_time=00:00-12:00：只允许该时间段内访问。</li>
</ul>
</li>
<li><p>使用xinetd提供的/etc/hosts.allow和/etc/hosts.deny实现防火墙机制</p>
<ul>
<li><p>/etc/hosts.allow ：我们可以在该文件中设置允许访问的IP</p>
</li>
<li><p>/etc/hosts.deny ：我们可以在该文件中设置不允许访问的IP</p>
</li>
</ul>
</li>
</ol>
<h1 id="系统开启的服务"><a href="#系统开启的服务" class="headerlink" title="系统开启的服务"></a>系统开启的服务</h1><h2 id="查看系统启动的服务"><a href="#查看系统启动的服务" class="headerlink" title="查看系统启动的服务"></a>查看系统启动的服务</h2><p>一般情况下，我们会比较关心网络监听的服务，所以都会使用netstat命令(之前也提到过)，这里再次说明几个范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 1. 找出目前系统开启的网络服务</div><div class="line">netstat -tulp</div><div class="line"></div><div class="line">// 2. 找出所有有监听网络的服务</div><div class="line">netstat -lnp</div><div class="line"></div><div class="line">// 3. 查看所有的服务状态</div><div class="line"> service --status-all</div></pre></td></tr></table></figure></p>
<h2 id="设置Daemon开启启动"><a href="#设置Daemon开启启动" class="headerlink" title="设置Daemon开启启动"></a>设置Daemon开启启动</h2><p>在设置Daemon开机启动之前，最好先了解一下Linux主机是怎么开机的？</p>
<ol>
<li>打开计算机电源，开始读取BIOS并进行主机的自我测试</li>
<li>通过BIOS取得第一个可开机设备，读取主要开机区(MBR)取得启动装载程序</li>
<li>通过启动装载程序的设置，取得kernel并加载内存且检测系统硬件</li>
<li>内核主动调用init进程</li>
<li>init进程开始执行系统初始化(/etc/rc.d/rec.sysinit)</li>
<li>依据init的设置进行daemonstart(/etc/rc.d/rc[0-6].d/*)</li>
<li>加载本机设置</li>
</ol>
<p>在启动Linux系统时，可以进入不同的模式，这模式我们称为执行等级(run level)，不同执行等级有不同的功能与服务。图型界面为run level5，纯文本界面为run level3。当我们想要知道哪些服务默认可以启动，这就需要下面的命令来查询:</p>
<ol>
<li><p>chkconfig：管理系统服务<strong>默认开机启动与否</strong>，范例如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 1. 列出目前系统上面所有被chkconfig管理的服务</div><div class="line">chkconfig --list | more // 分为两个块，分别为两种启动方式的daemon</div><div class="line"></div><div class="line">// 2. 显示目前在run level 3 启动的服务</div><div class="line">chkconfig --list | grep &apos;2:on&apos;</div><div class="line"></div><div class="line">// 3. 让atd这个服务在run level 3，4，5时启动</div><div class="line">chkconfig --level 345 atd on</div><div class="line"></div><div class="line">// 4. 查看httpd，再查看默认有无启动，之后以chkconfig设置为默认启动</div><div class="line">/etc/init.d/httpd status // 查看本身</div><div class="line">chkconfig --list httpd // 查看是否默认启动</div><div class="line">chconfig httpd on; //设置为开机启动</div></pre></td></tr></table></figure>
<ol>
<li>chkconfig：设置自己的系统服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig [--add|--del] [服务名称] // 该服务必须在/etc/init.d/内</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h1 id="RHEL7的sytemctl（代替service和chkconfig）"><a href="#RHEL7的sytemctl（代替service和chkconfig）" class="headerlink" title="RHEL7的sytemctl（代替service和chkconfig）"></a>RHEL7的sytemctl（代替service和chkconfig）</h1><p>centos7版本中使用了systemd，systemd同时兼容service,对应的命令就是systemctl 。systemctl是RHEL 7 的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。可以使用它永久性或只在当前会话中启用/禁用服务。</p>
<p>systemd把不同的资源称为Unit<br>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit<br>存放目录：/etc/systemd/system和/usr/lib/systemd/system。</p>
<p>使用范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// 1. 以树形列出正在运行的进程，它可以递归显示控制组内容</div><div class="line">systemd-cgls</div><div class="line"></div><div class="line">// 2. 启动一个服务</div><div class="line">systemctl start firewalld.service</div><div class="line"></div><div class="line">// 3. 关闭一个服务</div><div class="line">systemctl stop firewalld.service</div><div class="line"></div><div class="line">// 4. 重启一个服务</div><div class="line">systemctl restart firewalld.service</div><div class="line"></div><div class="line">// 5. 显示一个服务的状态</div><div class="line">systemctl status firewalld.service</div><div class="line"></div><div class="line">// 6. 在开机时启动一个服务</div><div class="line">systemctl enable firewalld.service</div><div class="line"></div><div class="line">// 7. 在开机时禁用一个服务</div><div class="line">systemctl disable firewalld.service</div><div class="line"></div><div class="line">// 8. 查看服务是否开机启动</div><div class="line">systemctl is-enabled  firewalld.service</div><div class="line"></div><div class="line">// 9. 查看已启动的服务列表</div><div class="line">systemctl list-unit-files | grep enabled</div><div class="line"></div><div class="line">// 10. 查看启动失败的服务列表</div><div class="line">systemctl --failed</div><div class="line"></div><div class="line">PS：</div><div class="line">1. 使用命令 systemctl is-enabled firewalld.service 得到的值可以是enable、disable或static，</div><div class="line">     这里的 static 它是指对应的 Unit 文件中没有定义[Install]区域，因此无法配置为开机启动服务。</div><div class="line">2. 启用服务就是在当前“runlevel”的配置文件目录/etc/systemd/system/multi-user.target.wants/里，建立/usr/lib/systemd/system里面对应服务配置文件的软链接；</div><div class="line">  禁用服务就是删除此软链接，添加服务就是添加软连接。</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
<li><a href="https://blog.csdn.net/catoop/article/details/47318225" target="_blank" rel="external">RHEL7的sytemctl（代替service和chkconfig）</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：我们进程会听到daemon，但是却不知道其义，其实就是一个守护进程，作用是支持其他服务(service)的运行。我们下面可以好好看看linux中的daemon与service！
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_认识你的进程</title>
    <link href="http://bestlixiang.site/2018/04/02/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_%E8%AE%A4%E8%AF%86%E4%BD%A0%E7%9A%84%E8%BF%9B%E7%A8%8B/"/>
    <id>http://bestlixiang.site/2018/04/02/走进Linux/走进Linux_认识你的进程/</id>
    <published>2018-04-02T04:58:22.000Z</published>
    <updated>2018-04-09T04:33:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：linux服务器上可以跑很多很多的程序，当然也会遇到很多的问题，所以我们需要学会去管理好它。尤其像ps，top这些命令，你一定会很想去了解它吧！<a id="more"></a></p>
<h1 id="理解进程"><a href="#理解进程" class="headerlink" title="理解进程"></a>理解进程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p><strong>进程：</strong> 一个程序被加载到内存当中运行，那么在内存中的那个数据就被称为进程。</p>
<p>系统也会给予这个进程一个ID，称为<strong>PID</strong>。同时触发这个进程的用户与相关属性关系，给予这个PID一组有效的权限设置。</p>
<h2 id="进程与程序"><a href="#进程与程序" class="headerlink" title="进程与程序"></a>进程与程序</h2><h3 id="程序和进程概念"><a href="#程序和进程概念" class="headerlink" title="程序和进程概念"></a>程序和进程概念</h3><ol>
<li>程序：通常为二进制程序，放置在存储媒介中，以物理文件的形式存在。</li>
<li>进程：程序在触发后，执行者的权限与属性、程序的程序代码与所需数据等都会被加载到内存中，操作系统给予这个内存中的单元一个标识符（PID），可以说，进程就是一个正在运行的程序。</li>
</ol>
<h3 id="子进程与父进程"><a href="#子进程与父进程" class="headerlink" title="子进程与父进程"></a>子进程与父进程</h3><p>举个栗子：当我们登录系统后，会取得一个bash的shell，然后，我们用这个bash提供的接口去执行另一个命令，那些另外执行的命令也会被触发称为PID，那个后来执行命令才产生的PID就是“子进程”，而在我们原本在bash环境下，就称为“父进程”。子进程会具有PPID(父PID)。</p>
<h3 id="fork-and-exec：过程调用的流程"><a href="#fork-and-exec：过程调用的流程" class="headerlink" title="fork and exec：过程调用的流程"></a>fork and exec：过程调用的流程</h3><p>在Linux的过程调用中通常被称为fork and exec的流程，进程都会父进程以复制(fork)的方式产生一个一模一样的子进程（PID不一样），然后被复制出来的子进程再以exec的方式来执行实际要进行的进程，最终称为一个子进程的存在。</p>
<h1 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h1><h2 id="什么是工作管理"><a href="#什么是工作管理" class="headerlink" title="什么是工作管理"></a>什么是工作管理</h2><p><strong>工作管理：</strong> 当我们登录系统取得bash shell之后，在<strong>单一终端机下</strong>同时进行多个工作的行为管理。</p>
<p>下面是前台和后台定义:</p>
<p><strong>前台:</strong> 你可以控制与执行命令的环境</p>
<p><strong>后台：</strong> 可以自行运行的工作，你无法用ctrl + c终止它，但是可以用bg/fg调用该工作的环境</p>
<p>要进行bash的工作管理必须要注意的限制是：</p>
<ul>
<li>这些工作所触发的进程必须要来自你的shell子进程（只管理自己的bash）</li>
<li>后台中“执行”的进程不能等待terminal/shell的输入。</li>
</ul>
<h2 id="job管理"><a href="#job管理" class="headerlink" title="job管理"></a>job管理</h2><p>实际中使用的job控制主要有下面的命令：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 直接将命令丢到后台中“执行”的 &amp;</span></div><div class="line">tar -zpcf /tmp/tec/tar.gz /etc &amp;</div><div class="line"><span class="comment">/*</span></div><div class="line">会出现[1]（工作好） 13456（进程号）</div><div class="line">完成后会输出： [1]   完成                  tar -zpcf /tmp/etc.tar.gz /etc */</div><div class="line"><span class="comment">/*</span></div><div class="line">但是需要注意的是，运行的信息还是会出现在屏幕上，会影响我们正常继续使用，</div><div class="line">所以我们需要利用数据流重定向输入到文件中。*/</div><div class="line"></div><div class="line"><span class="comment">// 2. 将目前的工作丢到后台中“暂停”：ctrl + z</span></div><div class="line">vim ~/.bashrc 按ctrl+z</div><div class="line"><span class="comment">/*</span></div><div class="line">会输出 [2]+  已停止               vim ~/.bashrc */</div><div class="line"></div><div class="line"><span class="comment">// 3. 查看目前的后台工作状态：jobs</span></div><div class="line"></div><div class="line"><span class="comment">// 4. 将后台工作拿到前台来处理：fg</span></div><div class="line">fg %<span class="number">2</span> <span class="comment">//拿出刚刚vim的工作</span></div><div class="line"></div><div class="line"><span class="comment">// 5. 让工作在后台下得状态变成运行中：bg</span></div><div class="line">bg %<span class="number">2</span></div><div class="line"></div><div class="line"><span class="comment">// 6. 管理后台当中的工作：kill</span></div><div class="line">kill -signal %jobnumber/PID/命令</div><div class="line"><span class="comment">/* signal</span></div><div class="line">-1：重新读取一次参数的配置文件</div><div class="line">-2：与ctrl + c一样</div><div class="line">-9：立刻强制删除一个工作，不会删除过程文件</div><div class="line">-15(默认值)：以正常的程序方式终止一项工作，会删除过程文件 */</div></pre></td></tr></table></figure></p>
<h2 id="脱机管理"><a href="#脱机管理" class="headerlink" title="脱机管理"></a>脱机管理</h2><p>如果你是使用&amp;来放置后台工作，当你断开与终端机的连接（脱机），那么后台工作就会被中断掉。如果我们不想这样就可以使用at或者nohup命令，我们主要讲一下nohup的这个命令，这个命令可以让你在脱机或注销系统后，还能够让工作继续进行。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. 在终端机前台中工作</div><div class="line">nohup 命令</div><div class="line"></div><div class="line">// 1. 在终端机后台工作</div><div class="line">nohup 命令 &amp;</div></pre></td></tr></table></figure></p>
<p>当你使用这个命令之后，你会发现会出现一个nohup.out文件，这个文件其实就是将原本前台显示的东西重定向到这个文件中。</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程的查看"><a href="#进程的查看" class="headerlink" title="进程的查看"></a>进程的查看</h2><h3 id="静态的ps"><a href="#静态的ps" class="headerlink" title="静态的ps"></a>静态的ps</h3><p>PS：如果man page不好查阅，最好是直接被几个常用的参数。</p>
<p>这个命令是将某个时间点的进程运行情况选取下来，主要的范例如下：</p>
<ol>
<li><p>仅查看自己的bash的相关进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">ps -l</div><div class="line"></div><div class="line">/* 输出列子如下：</div><div class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</div><div class="line">4 S     0 10573 10567  0  80   0 - 29064 wait   pts/0    00:00:00 bash</div><div class="line"></div><div class="line">含义如下：</div><div class="line">F：程序标识（process flags），说明程序的权限，4代表root，1代表子程序仅能fork不能exec</div><div class="line"></div><div class="line">S：程序状态（state），主要有R(running)、S(sleep)、D(不可唤醒)、T(stop)、Z（僵尸，命令位会跟&lt;defunct&gt;）</div><div class="line"></div><div class="line">UID/PID/PPID  ：PPID指父程序的PID</div><div class="line"></div><div class="line">C：代表CPU使用率，单位为百分比</div><div class="line"></div><div class="line">PRI/NI：此程序被CPU执行优先级，数值越小程序优先级越高</div><div class="line"></div><div class="line">ADDR/SZ/WCHAN：ADDR代表在内存哪个部分，SZ代表用掉多少内存，WCHAN表示程序是否正在运作</div><div class="line"></div><div class="line">TTY：登陆者的终端机位置，远程登录时为 pts/n</div><div class="line"></div><div class="line">TIME：使用掉的CPU时间，程序实际花费CPU运作时间</div><div class="line"></div><div class="line">CMD：触发程序的指令 */</div></pre></td></tr></table></figure>
</li>
<li><p>查看系统所有进程：ps aux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">ps aux</div><div class="line"></div><div class="line">/* 输出列子如下：</div><div class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</div><div class="line">root         1  0.0  0.1  43156  3136 ?        Ss   3月10   1:27 /usr/lib/systemd/systemd --swi</div><div class="line"></div><div class="line">含义如下：</div><div class="line">USER：该进程属于哪个用户账号</div><div class="line"></div><div class="line">PID  ：进程ID</div><div class="line"></div><div class="line">%CPU：该进程使用掉的CPU资源内存百分比</div><div class="line"></div><div class="line">%MEM：该进程所占用的物理内存百分比</div><div class="line"></div><div class="line">VSZ：该进程使用掉的虚拟内存量（KB）</div><div class="line"></div><div class="line">RSS：该进程占用的固定的内存量（KB）</div><div class="line"></div><div class="line">TTY：登陆者的终端机位置，远程登录时为 pts/n</div><div class="line"></div><div class="line">STAT：与ps -l的S表示相同</div><div class="line"></div><div class="line">START：该进程被触发启动的时间</div><div class="line"></div><div class="line">TIME：程序实际花费CPU运作时间</div><div class="line"></div><div class="line">CMD：该进程的实际命令 */</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="动态的top"><a href="#动态的top" class="headerlink" title="动态的top"></a>动态的top</h3><p>这个命令可以持续的检测进程运行的状态，主要范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 1. 每两秒更新一次top，查看整体信息，默认5秒</div><div class="line">top -d 2</div><div class="line"></div><div class="line">/* 输出例子：</div><div class="line">top - 10:54:10 up 22 days, 19:25,  1 user,  load average: 0.13, 0.07, 0.06</div><div class="line">Tasks:  69 total,   2 running,  66 sleeping,   1 stopped,   0 zombie</div><div class="line">%Cpu(s):  0.5 us,  0.0 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</div><div class="line">KiB Mem :  1883844 total,    77012 free,   356884 used,  1449948 buff/cache</div><div class="line">KiB Swap:        0 total,        0 free,        0 used.  1328820 avail Mem</div><div class="line"></div><div class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                     </div><div class="line"> 1861 root      20   0  608356  12236   1788 S  0.5  0.6  60:48.59 barad_agent</div><div class="line"></div><div class="line"> top见界面主要分为两个界面：</div><div class="line"></div><div class="line"> 上面为整个系统的资源使用状态，基本上总共有六行，显示的内容依次是：</div><div class="line"> 1. 目前的时间，开机到目前为止所经过的时间，已经登录系统的的用户数,系统在1，5，15分钟的平均工作负载</div><div class="line"> 2. 目前进程的总量与各个累呗进程的总量，注意zombie僵尸进程的数量</div><div class="line"> 3. CPU的整体负载，注意wa（I/Owait）</div><div class="line"> 4. 物理内存的使用情况</div><div class="line"> 5. 虚拟内存的使用情况，swap的是用来一定要小</div><div class="line"> 6. 这个是当在top进程中输入命令时显示状态的地方，输入r可修改nice值</div><div class="line"></div><div class="line"> 下面为每个进程使用资源情况，各个参数含义可参照ps。</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<h3 id="进程树pstree"><a href="#进程树pstree" class="headerlink" title="进程树pstree"></a>进程树pstree</h3><p>如果想找到进程之间的相关性，这个pstree就能够很好的帮助我们，它会使用线段将相关性进程连接起来，范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 1.列出目前系统上面所有的进程数的相关性</div><div class="line">pstree -A</div><div class="line">输入如下：</div><div class="line">systemd-+-acpid</div><div class="line">        |-2*[agetty]</div><div class="line">        |-atd</div><div class="line">        |-auditd---&#123;auditd&#125;</div><div class="line">        ...</div><div class="line"></div><div class="line">// 2. 在1的基础上，同时显示出PID与users</div><div class="line">pstree -Aup</div></pre></td></tr></table></figure></p>
<h2 id="进程的执行顺序"><a href="#进程的执行顺序" class="headerlink" title="进程的执行顺序"></a>进程的执行顺序</h2><p>CPU优先处理哪个进程，这就需要考虑到程序的优先执行序(priority)与CPU的调度。具体到值来说就是要考虑到PRI和nice值（之前用top和ps显示过）。<strong>PRI值越低代表越优先</strong>，不过这个PRI值是由内核动态调整的，具有无法调整，但是Nice值我们可以改变。下面的PRI值改变的公式：</p>
<pre><code>PRI(new) = PRI(old) + nice
</code></pre><p>下面是关于nice值的使用范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. 在使用命令的时候设置nice值，给nice值为-5去执行vi</div><div class="line">nice -n vi &amp;</div><div class="line"></div><div class="line">// 2. 已存在进程的nice重新分配，将PID为18625的进程nice值调整到10</div><div class="line">renice 10 18625</div></pre></td></tr></table></figure></p>
<h2 id="系统资源的查看"><a href="#系统资源的查看" class="headerlink" title="系统资源的查看"></a>系统资源的查看</h2><ol>
<li><p>查看内存的使用情况，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 查看目前系统的内存容量</div><div class="line">free -m</div></pre></td></tr></table></figure>
</li>
<li><p>查看系统与内核相关信息，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 输出系统的基本信息</div><div class="line">uname -a</div></pre></td></tr></table></figure>
</li>
<li><p>查看系统启动时间与内存负载，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uptime</div></pre></td></tr></table></figure>
</li>
<li><p>跟踪网络(很重要)，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. 列出目前系统以及新建的网络连接与unix socket状态</div><div class="line">netstat</div><div class="line"></div><div class="line">// 2. 找出目前系统上已在监听的网络连接机及其PID(很重要)</div><div class="line">netstat -tlnp</div></pre></td></tr></table></figure>
</li>
<li><p>分析内核产生的信息，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. 输出所有的内核开机时的信息</div><div class="line">dmesg | more</div><div class="line"></div><div class="line">// 2. 查找开机的时候硬盘的相关信息</div><div class="line">dmesg | grep i hd</div></pre></td></tr></table></figure>
</li>
<li><p>检测系统资源变化，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 1. 统计目前主机CPU状态，每秒一次，共计三次</div><div class="line">vmstat 1 3</div><div class="line"></div><div class="line">// 2. 系统上面所有磁盘的读写状态</div><div class="line">vmstat -d</div><div class="line"></div><div class="line">PS：详细的各个字段的含义，大家就自己查询man vmstat好了，习惯就好。</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：linux服务器上可以跑很多很多的程序，当然也会遇到很多的问题，所以我们需要学会去管理好它。尤其像ps，top这些命令，你一定会很想去了解它吧！
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_例行性工作(crontab)</title>
    <link href="http://bestlixiang.site/2018/03/31/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_%E4%BE%8B%E8%A1%8C%E6%80%A7%E5%B7%A5%E4%BD%9C(crontab)/"/>
    <id>http://bestlixiang.site/2018/03/31/走进Linux/走进Linux_例行性工作(crontab)/</id>
    <published>2018-03-31T12:35:07.000Z</published>
    <updated>2018-04-09T04:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：系统常常会主动进行一些任务，这依靠的就是设置了例行性工作。<a id="more"></a></p>
<h1 id="什么是例行性工作（定时任务crontab）"><a href="#什么是例行性工作（定时任务crontab）" class="headerlink" title="什么是例行性工作（定时任务crontab）"></a>什么是例行性工作（定时任务crontab）</h1><p>根据单词crontab（定时任务）就可以知道 <strong>例行性工作</strong> 其实就是每天都会干的事。</p>
<h2 id="Linux工作调度的种类"><a href="#Linux工作调度的种类" class="headerlink" title="Linux工作调度的种类"></a>Linux工作调度的种类</h2><ol>
<li>例行性的，就是每隔一定的周期要来办的事，利用crontab实现，这个命令所设置的工作将会循环一直进行下去，可循环的时间为分钟，小时，每周，每月或每年等，crontab除了可以使用命令执行外，也可编辑/etc/crontab来支持。至于让crontab可以生效的后台服务是crond这个服务。</li>
<li>突发性的，就是这次做完以后就没有的事，利用at实现，但是这个必须要有atd后台服务支持才行。</li>
</ol>
<h2 id="Linux上常见的例行性工作"><a href="#Linux上常见的例行性工作" class="headerlink" title="Linux上常见的例行性工作"></a>Linux上常见的例行性工作</h2><ol>
<li>进行日志文件的轮替，让旧的数据和新的数据分开存放</li>
<li>日志文件分析logwatch的任务</li>
<li>新建locate的数据库，系统会主动进行updatedb</li>
<li>whatis数据库的建立</li>
<li>删除临时文件</li>
</ol>
<h1 id="仅执行一次的工作调度：at"><a href="#仅执行一次的工作调度：at" class="headerlink" title="仅执行一次的工作调度：at"></a>仅执行一次的工作调度：at</h1><h2 id="at的运行方式"><a href="#at的运行方式" class="headerlink" title="at的运行方式"></a>at的运行方式</h2><p>我们使用at这个命令来生成所要进行的工作，并将这个工作以文本文件的方式写入/var/spool/at目录中，该工作便能等待atd这个服务的取用与执行了。但是并不是所有的人都可以进行at工作调度工作的，因为安全。我们可以利用/etc/at.allow与/etc/at.deny这两个文件进行at的使用限制，加上这两个文件后，at的工作情况其实是这样的：</p>
<ol>
<li>先寻找/etc/at.allow这个文件，写在这个文件中的用户才能使用at，没有在这个文件中的用户则不能使用at(即时没有写在at.deny当中)</li>
<li>如果/etc/at.allow不存在，就寻找/etc/at.deny这个文件，若卸载这个at.deny的用户则不能使用at，而没有在这个文件中的用户就可以使用at了</li>
<li>如果这两个文件都不存在，那么就只有root可以使用at这个命令</li>
</ol>
<h2 id="实际运行单一工作调度"><a href="#实际运行单一工作调度" class="headerlink" title="实际运行单一工作调度"></a>实际运行单一工作调度</h2><p>单一工作调度的进行就使用at这个命令，这个命令的运行十分简单！将at加上一个时间即可！范例入下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. at [-mldv] TIME</div><div class="line">at noe + 5 minutes // 再过五分钟执行，接下来输入执行的命令，使用ctrl  + d 结束。</div><div class="line"></div><div class="line">// 2. at -c 工作号码 // 将第几号工作调出来查看</div><div class="line">at -c 1 // 将第一号工作调出来</div></pre></td></tr></table></figure></p>
<p>事实上，当我们使用at时会进入一个at shell的环境来让用户执行工作命令，此时，建议你最好使用绝对路径来执行你的命令，比较不会有问题。</p>
<p>at还有一个很棒的优点就是<strong>后台执行的功能</strong>，和nohup类似。</p>
<p><strong>at的工作管理</strong> 主要是利用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 查询目前主机上面有多少的at工作调度</div><div class="line">atq</div><div class="line"></div><div class="line"># 将第3个工作删除</div><div class="line">atrm 3</div></pre></td></tr></table></figure></p>
<h1 id="循环执行的例行性工作调度"><a href="#循环执行的例行性工作调度" class="headerlink" title="循环执行的例行性工作调度"></a>循环执行的例行性工作调度</h1><p>相对于at是仅执行一次的工作，循环执行的例行性工作调度室友crond这个系统服务来控制的，由于Linux系统上原本就有很多的例行性工作，所以这个系统服务是默认开启的。另外，由于用户自己也可以进行例行性工作调度，所以，Linux可提供用户控制例行性工作调度的命令（crontab）。</p>
<h2 id="用户的设置与使用"><a href="#用户的设置与使用" class="headerlink" title="用户的设置与使用"></a>用户的设置与使用</h2><p>为了安全性的问题，与at类似，我们可以限制使用crontab的用户账号。使用的限制数据有：</p>
<ul>
<li>/etc/cron.allow：将可以使用crontab的账号写入其中，若不在这个文件内的用户则不可使用crontab。</li>
<li>/etc/cron.deny：将不可以使用crontab的账号写入其中，若为记录到这个文件中的用户，就可以使用crontab。</li>
</ul>
<p>以优先级来说，/etc/cron.allow比/etc/cron.deny要优先，而判断上面，两个文件只选择一个来限制而已，因此，建议你只要保留一个即可。</p>
<p>当用户使用crontab这个命令来新建工作调度之后，该项工作就会被记录/var/spool/cron/里面，而且是以账号来区分的。另外，cron执行的每一项工作都会被记录到/var/log/cron这个日志文件中，所以，如果你的Linux不知道是否被植入密码，也可以查询一下这个日志文件。</p>
<p>下面是它的使用范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 1. 用root的身份在每天的12:00和14:00查看主文件夹目录ß</div><div class="line"># 编辑crontab的工作内容</div><div class="line">crontab -e</div><div class="line"># 进入vi界面，每项工作都是一行</div><div class="line">0 12,14 * * * ls /  // 解释各列含义：</div><div class="line">// 1. 分；2. 小时；3. 日期；4. 月份; 5. 周； 6. 命令</div><div class="line">// 其中“,”表示分割时段，“-”表示一段时间范围，/n 表示每隔n单位间隔</div><div class="line"></div><div class="line">// 2. 查询crontab任务</div><div class="line">crontab -l</div><div class="line"></div><div class="line">// 3. 若要删除一项工作，必须要用crontab -e去编辑，如果想要删除全部工作，如下：</div><div class="line">crontab -r</div></pre></td></tr></table></figure></p>
<h2 id="系统的配置文件：-etc-crontab"><a href="#系统的配置文件：-etc-crontab" class="headerlink" title="系统的配置文件：/etc/crontab"></a>系统的配置文件：/etc/crontab</h2><p>crontab -e是针对用户的例行性工作来设计的，如果我们要修改系统的例行性任务，就需要编辑/etc/crontab了。</p>
<p>基本上，cron这个服务的最低检测限制是“分钟”，所以cron会每分钟去读取一次/etc/crontab与/var/spool/cron里面的数据内容。</p>
<h1 id="可唤醒停机期间的工作任务"><a href="#可唤醒停机期间的工作任务" class="headerlink" title="可唤醒停机期间的工作任务"></a>可唤醒停机期间的工作任务</h1><p>如果例行性工作是在凌晨4点运行的，但是刚好关机了， 你7点开机了，你总不能不管它吧，这就需要用到anacron。</p>
<h2 id="什么是anacron"><a href="#什么是anacron" class="headerlink" title="什么是anacron"></a>什么是anacron</h2><p><strong>anacron存在的目的</strong> 是处理非24小时一直启动的linux系统的crontab的执行。</p>
<p>anacron也是通过crontab来运行的，因此anacron的运行的时间通常有两个，一是系统开机期间运行，一个是写入crontab的调度中。</p>
<h2 id="anacron使用"><a href="#anacron使用" class="headerlink" title="anacron使用"></a>anacron使用</h2><p>anacron的语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">anacron [-sfn] [job]</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：系统常常会主动进行一些任务，这依靠的就是设置了例行性工作。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_账号管理</title>
    <link href="http://bestlixiang.site/2018/03/31/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/"/>
    <id>http://bestlixiang.site/2018/03/31/走进Linux/走进Linux_账号管理/</id>
    <published>2018-03-31T05:15:52.000Z</published>
    <updated>2018-04-09T04:34:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：管理员的工作中，相对重要的一环就是“账号管理”。因为整个系统都是你在管理，并且所有的一般用户的账号申请必须要通过你的协助才行。所以我们必须要知道如果管理好一个服务器主机的账号！<a id="more"></a></p>
<h1 id="账号与用户组"><a href="#账号与用户组" class="headerlink" title="账号与用户组"></a>账号与用户组</h1><p>在管理Linux账号时，我们必须要先了解一下Linux到底是如何辨别每一个用户的。</p>
<h2 id="用户表示符：UID与GID"><a href="#用户表示符：UID与GID" class="headerlink" title="用户表示符：UID与GID"></a>用户表示符：UID与GID</h2><p>虽然我们登录Linux主机的时候，输入的是我们的账号，但是其实Linux主机并不会直接认识你的账号，它仅认识ID，而你的ID域账号的对应关系就在/etc/passwd当中。</p>
<p>每一个文件都具有<strong>所有者与所属用户组</strong>的属性，所以每个登录的用户至少会取得两个ID，一个是用户ID(UID)，一个是用户组ID(GID)。</p>
<h2 id="用户账号"><a href="#用户账号" class="headerlink" title="用户账号"></a>用户账号</h2><p>Linyx系统上面的用户如果需要登录主机以取得shell的工作环境，它必须要在计算机前面利用tty1~tty7的终端机提供的login接口，并输入账号与密码后才能登录。当我们输入账号密码后，系统主要做了如下工作：</p>
<ol>
<li>先寻找/etc/passwd里面是否有你输入的帐号？如果没有则跳出，如果有的话则将该帐号对应的UID与GID（在/etc/group中）读出来，另外，该帐号的主文件夹与shell设定也一并读出。</li>
<li>再来则是核对密码表啦！这是Linux会进入/etc/shadow里面找出对应的帐号与UID，然后核对一下你刚刚输入的密码与里面的密码是否相符。</li>
<li>如果一切都OK的话，就进入Shell控管的阶段咯！</li>
</ol>
<ul>
<li><p>/etc/passwd文件结构如下：</p>
<p>  这个文件的构造是这样的：每一行代表一个帐号，有几行就代表有几个帐号在你的系统中！不过需要特别留意的是，里头很多帐号本身就是系统正常运作所必须要的，我们可以简称为<strong>系统帐号</strong>，如bin，daemon，adm，nobody等。</p>
<p>  我们先来看一下每个Linux系统都会有的第一行，就是root这个系统管理员那一行好了，你可以明显的看出来，每一行使用：分隔，共有七个字段，分别是</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>字段号</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>    1</td>
<td>账号名称</td>
</tr>
<tr>
<td>    2</td>
<td>密码，被该放到/etc/shadow文件中，以x代替</td>
</tr>
<tr>
<td>    3</td>
<td>UID，0为系统管理员，可以多个账号的UID为0，但不建议。1~99为发现版自建系统账号，100~499为用户使用的系统账号，500~*为一般用户可登录账号</td>
</tr>
<tr>
<td>    4</td>
<td>密码，GID，与/etc/group有关</td>
</tr>
<tr>
<td>    5</td>
<td>用户信息说明</td>
</tr>
<tr>
<td>    6</td>
<td>主文件夹</td>
</tr>
<tr>
<td>    7</td>
<td>shell</td>
</tr>
</tbody>
</table>
<ul>
<li><p>/etc/shadow文件结构如下：</p>
<p>  文件构造基本与/etc/passwd一样，但是它有9个字段，分别是：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>字段号</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>    1</td>
<td>账号名称，需要与/etc/passwd对应</td>
</tr>
<tr>
<td>    2</td>
<td>密码，但是被加密过的</td>
</tr>
<tr>
<td>    3</td>
<td>最近更改密码的日期，以1970年1月1号作为1而累加的日期</td>
</tr>
<tr>
<td>    4</td>
<td>密码不可被更动的日期</td>
</tr>
<tr>
<td>    5</td>
<td>密码需要重新更改的天数</td>
</tr>
<tr>
<td>    6</td>
<td>密码需要更改期限前的警告天数</td>
</tr>
<tr>
<td>    7</td>
<td>密码过期后的账号宽限时间（密码失效日）</td>
</tr>
<tr>
<td>    8</td>
<td>账号失效日期</td>
</tr>
<tr>
<td>    9</td>
<td>保留，用于以后扩展</td>
</tr>
</tbody>
</table>
<h2 id="有效与初始用户组：groups，newgrp"><a href="#有效与初始用户组：groups，newgrp" class="headerlink" title="有效与初始用户组：groups，newgrp"></a>有效与初始用户组：groups，newgrp</h2><ul>
<li><p>/etc/group文件结构如下：</p>
<p>  文件构造基本与/etc/passwd一样，但是它有4个字段，分别是：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>字段号</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>    1</td>
<td>用户组名称</td>
</tr>
<tr>
<td>    2</td>
<td>用户组密码，以x代替</td>
</tr>
<tr>
<td>    3</td>
<td>GID，/etc/passwd第四个字段使用的GID对应的用户组名就是由这里来的</td>
</tr>
<tr>
<td>    4</td>
<td>用户组支持的账号名称，多用户以”,”分割</td>
</tr>
</tbody>
</table>
<pre><code>我们知道用户可以同时加入多个用户组，那么我们在执行工作时，到底是以哪个用户组为准呢？，这就需要引入有效用户组的概念。    
</code></pre><ul>
<li><p>/etc/gshadow文件结构如下：</p>
<p>  文件构造基本与/etc/group一样，它有4个字段，分别是：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>字段号</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>    1</td>
<td>用户组名称</td>
</tr>
<tr>
<td>    2</td>
<td>用户组密码,开头为!表示无合法密码，所以无用户组管理员</td>
</tr>
<tr>
<td>    3</td>
<td>用户组管理员的账号，用户组管理员能够将账号添加到自己管理的用户组中</td>
</tr>
<tr>
<td>    4</td>
<td>该用户组的所属账号（与/etc/group内容相同）</td>
</tr>
</tbody>
</table>
<ul>
<li>有效用户组与初始用户组<ul>
<li>初始用户组：就是/etc/passwd里面的第四列的GID，当用户登录系统，立刻就拥有这个用户组的相关权限。</li>
<li>有效用户组：就是利用groups命令看到的第一个用户组，可以利用newgrp命令更改有效用户组，newgrp命令更改目前用户的有效用户组是以另一个shell来提供这个功能的，如果要回到原来的用户组只要输入exit即可。</li>
</ul>
</li>
</ul>
<h1 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h1><p>管理账号主要是新增、删除与更改用户的相关信息。</p>
<h2 id="新增与删除用户"><a href="#新增与删除用户" class="headerlink" title="新增与删除用户"></a>新增与删除用户</h2><p>账号可以使用useradd命令来新建用户，密码的给予则是使用passwd命令。下面是范例：（里面有很多参数，自己可以去了解）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 新增</div><div class="line">useradd leonard</div><div class="line">ll -d /home/leonard/</div><div class="line"><span class="meta">#</span> 默认会创建用户主文件夹，且权限为700，这是重点</div><div class="line"><span class="meta">#</span> drwx------ 2 leonard leonard 4096 3月  31 09:36 /home/leonard/</div><div class="line"></div><div class="line">grep leonard /etc/passwd /etc/shadow /etc/group</div><div class="line"><span class="meta">#</span> /etc/passwd:leonard:x:1001:1001::/home/leonard:/bin/bash</div><div class="line"><span class="meta">#</span> /etc/shadow:leonard:!!:17621:0:99999:7:::</div><div class="line"><span class="meta">#</span> /etc/group:leonard:x:1001:</div><div class="line"><span class="meta"></span></div><div class="line"># 不加账号，默认修改自己的密码</div><div class="line">passwd leonard</div><div class="line"><span class="meta"></span></div><div class="line"># 显示账号的相关信息</div><div class="line">chage leonard</div><div class="line"><span class="meta"></span></div><div class="line"># 修改账号的相关信息</div><div class="line">usermod leonard</div><div class="line"><span class="meta"></span></div><div class="line"># 删除账号，-r：连主文件夹一起删除</div><div class="line">userdel leonard</div></pre></td></tr></table></figure></p>
<p>其实系统已经帮我们设置好了非常多的默认值，所以我们可以简单的使用“useradd 账号”来创建用户，Centos这些默认值主要会帮我们处理下面几个项目：</p>
<ul>
<li>在/etc/passwd 里面创建一行与账号相关的数据，包括创建UID/GID/主文件夹等；</li>
<li>在/etc/shadow里面将此账号的密码相关参数填入，但是尚未有密码；</li>
<li>在/etc/group里面加入一个与账号名称一模一样的组名；</li>
<li>在/home下面创建一个与账号同名的目录作为用户的主文件夹，且权限为700</li>
</ul>
<h2 id="用户功能"><a href="#用户功能" class="headerlink" title="用户功能"></a>用户功能</h2><p>不论是useradd、usermod还是userdel，那都是系统管理员能够使用的命令，下面我们就介绍一些一般身份用户常用的账号数据更改与查询命令</p>
<ul>
<li><p>finger，可以查阅很多用户相关的信息，大部分都是/etc/passwd这个文件的信息。范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 我的linux默认没有装finger，可以利用下面的命令安装</div><div class="line">yum install finger</div><div class="line"></div><div class="line">// 查阅用户信息，若不跟没有用户，则查询当前用户</div><div class="line">finger rex</div></pre></td></tr></table></figure>
</li>
<li><p>chfn(change finger)，用于修改一些相关信息,范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">chfn rex</div><div class="line">Changing finger information for rex.</div><div class="line">名称 []: rex</div><div class="line">办公 []: 123456</div><div class="line">办公电话 []: 123456</div><div class="line">住宅电话 []: 123456</div></pre></td></tr></table></figure>
</li>
<li><p>chsh(change shell)，用于修改shell。</p>
</li>
<li>id，用于查询自己或某人的相关UID/GID等信息。</li>
</ul>
<h2 id="新增与删除用户组"><a href="#新增与删除用户组" class="headerlink" title="新增与删除用户组"></a>新增与删除用户组</h2><p>基本上，用户组的内容都与这两个文件有关：/etc/group,/etc/gshadow。下面是一些相关命令使用的范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># 新建一个用户组，名称为hd</div><div class="line">groupadd hd</div><div class="line"></div><div class="line"># 修改用户组的相关参数 -g：修改既有GID，-n：修改既有组名</div><div class="line">groupmod -g 201 -n myhd hd</div><div class="line"></div><div class="line"># 删除用户组名</div><div class="line">groupdel myhd</div><div class="line"></div><div class="line"># 用户组管理员相关命令</div><div class="line"># 给用户组设置一个密码</div><div class="line">gpasswd hd</div><div class="line"># 加入用户组管理员为rex</div><div class="line">gpasswd -A rex hd</div><div class="line"># 让rex登录系统，增加leonard为hd成员</div><div class="line">gpasswd -a leonard hd</div></pre></td></tr></table></figure></p>
<h1 id="主机的具体权限规划：ACL的使用"><a href="#主机的具体权限规划：ACL的使用" class="headerlink" title="主机的具体权限规划：ACL的使用"></a>主机的具体权限规划：ACL的使用</h1><h2 id="什么是ACL"><a href="#什么是ACL" class="headerlink" title="什么是ACL"></a>什么是ACL</h2><p>ACL是Access Control List的缩写，主要的目的是提供传统的owner、group、others的read、write、execute权限之外的具体权限设置。ACL可以针对单一用户、单一文件或目录进行r、w、x的权限设置，对于需要特殊权限的使用状况非常有帮助。</p>
<p>ACL主要可以针对下面几方面来设置控制权限：</p>
<ul>
<li>用户：可以针对用户来设置权限</li>
<li>用户组：可以针对用户组来设置权限</li>
<li>默认属性（mask）：还可以在该目录下新建文件目录设置新数据的权限、</li>
</ul>
<h2 id="ACL的设置技巧"><a href="#ACL的设置技巧" class="headerlink" title="ACL的设置技巧"></a>ACL的设置技巧</h2><ol>
<li>getfacl：取得某个文件/目录的ACL设置项目</li>
<li>setfacl：设置某个文件/目录的ACL规定</li>
</ol>
<p>下面是范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 取得某个文件/目录的ACL设置项目</div><div class="line">getfacl rootfile</div><div class="line"></div><div class="line">// 输出</div><div class="line"># file: rootfile</div><div class="line"># owner: root</div><div class="line"># group: root</div><div class="line">user::rw-</div><div class="line">group::r--</div><div class="line">other::r--</div><div class="line"></div><div class="line">// 设置某个文件/目录的ACL规定</div><div class="line">setfacl -m u:rex:rwx rootfile</div></pre></td></tr></table></figure></p>
<h1 id="用户身份切换"><a href="#用户身份切换" class="headerlink" title="用户身份切换"></a>用户身份切换</h1><p>在Linux系统中是需要做身份的变换的，主要有以下几个原因：</p>
<ul>
<li>使用一般账号：系统平日操作的好习惯（不然你就有机会从删库到跑路了）</li>
<li>用较低的权限启动系统服务</li>
<li>软件本身的限制</li>
</ul>
<p>根据上面的考虑，我们都是使用一般账号登录系统的，等有需要进行系统维护或软件更新时才转为root身份来操作。从一般用户转变为root主要有下面两种方式：</p>
<ul>
<li>“su -”：需要root用户密码</li>
<li>“sudo命令”：sudo需要输入用户自己的密码</li>
</ul>
<h2 id="su"><a href="#su" class="headerlink" title="su"></a>su</h2><p>su是最简单的身份切换命令了，它可以进行任何身份的切换。但是下面有几点比较重要：</p>
<ol>
<li>若要完整切换到新用户的环境，必须要使用“su -username” 或 “su -|username”，才会连同PATH/USER/MAIL等变量都转成新用户的环境。如果只是使用“su”切换到root用户，PATH/USER/MAIL等变量都没有变，会导致很多命令执行不了。</li>
<li>如果仅想执行一次root命令，可以利用“su - -c “命令串””d的方式来处理。</li>
<li>使用root切换成为任何用户时，并不需要输入新用户的密码。</li>
</ol>
<p>虽然使用su很方便，但是会导致root密码外流。所以很多情况下我们通过sudo来处理。</p>
<h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h2><p>sudo的执行仅需要自己的密码即可！甚至可以设置不需要密码即可执行sudo，由于sudo可以让你以其他用户身份执行命令（通常是使用root的身份来执行命令），因此不是所有人都能够执行sudo，而是仅有/etc/sudoers内的用户才能够执行sudo这个命令。</p>
<ol>
<li><p>sudo的命令用法</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo [-u 新用户账号]</div><div class="line"></div><div class="line">// 范例，以sshd的身份在/tmp下面新建一个名为mysshd的文件</div><div class="line">sudo -u sshd touch /tmp/mysshd</div></pre></td></tr></table></figure>
</li>
<li><p>sudo的执行流程</p>
<ul>
<li>当用户执行sudo时，系统在/etc/sudoers文件中查找该用户是否有执行sudo的权限；</li>
<li>若用户具有可执行sudo的权限后，便让用户输入用户自己的密码来确认；</li>
<li>若密码输入成功，便开始进行sudo后面接的命令（root执行sudo不需要输入密码）</li>
<li>若欲切换的身份与执行者的身份相同，也不需要输入密码</li>
</ul>
</li>
<li><p>visudo与/etc/sudoers</p>
<p> 我们一般不直接去修改/etc/sudoers文件，而是利用visudo命令去修改，因为这个命令会在结束离开的时候去检验/etc/sudoers的语法，下面是他的用法案例：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 1. 单一用户可以执行root的所有命令与sudoers文件语法</div><div class="line">// 四个参数含义为(1).用户账号，(2).登陆者的来源主机，(3).(可切换的身份)，(4).可执行的命令</div><div class="line">root    ALL=(ALL)       ALL //文件中原有</div><div class="line">rex     ALL=(ALL)       ALL //新增</div><div class="line"></div><div class="line">// 2. 利用用户组以及免密码的功能处理visudo</div><div class="line"># %wheel        ALL=(ALL)       NOPASSWD: ALL //文件中原有，需要将#去掉，文件中的%表示后面接一个用户组</div><div class="line">usermod -a -G wheel rex //将rex加入wheel组中</div><div class="line"></div><div class="line">// 3. 有限制的命令操作，通过更改可执行的命令一栏的数据，就可以控制具体操作的安全性</div><div class="line">rex ALL=(ALL) !/usr/bin/passed //不让rex可以修改密码</div><div class="line"></div><div class="line">// 4. 通过别名设置visudo</div><div class="line">User_Alias ADMPW(大写) = rex1,rex2</div><div class="line">Cmnd_Alias ADMPWCOM(大写) = !/usr/bin/passwd, /usr/bin/passed [A-Za-z]</div><div class="line">ADMPW     ALL=(root)       ADMPWCOM</div><div class="line"></div><div class="line">// 5. sudo搭配su的使用方式,让用户用自己的密码变成root</div><div class="line">User_Alias ADMPW(大写) = rex1,rex2</div><div class="line">ADMPW     ALL=(root)       /bin/su -</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：管理员的工作中，相对重要的一环就是“账号管理”。因为整个系统都是你在管理，并且所有的一般用户的账号申请必须要通过你的协助才行。所以我们必须要知道如果管理好一个服务器主机的账号！
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
</feed>
