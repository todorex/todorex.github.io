<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rex note</title>
  <subtitle>雨过，云过</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bestlixiang.site/"/>
  <updated>2018-03-26T09:46:51.000Z</updated>
  <id>http://bestlixiang.site/</id>
  
  <author>
    <name>rex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux私房菜_学会使用vim程序编辑器</title>
    <link href="http://bestlixiang.site/2018/03/26/Linux%E7%A7%81%E6%88%BF%E8%8F%9C-%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://bestlixiang.site/2018/03/26/Linux私房菜-学会使用vim程序编辑器/</id>
    <published>2018-03-26T09:06:33.000Z</published>
    <updated>2018-03-26T09:46:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：系统管理员的重要工作就是修改与设置某些重要软件的配置文件，因此至少得到学会一种以上的命令行界面的文本编辑器。在所有的Linux发行版中都具有vi这款编辑器，我们这次学的它的高级版vim。<a id="more"></a></p>
<h1 id="vi与vim"><a href="#vi与vim" class="headerlink" title="vi与vim"></a>vi与vim</h1><p>虽然在Linux在命令行界面下的文本编辑器有很多，比如Emacs，pico，nano，joe与vim等。但是我们却一定要学会vi或者说vim，vim相当于vi的高级版。</p>
<h2 id="为什么要学vim"><a href="#为什么要学vim" class="headerlink" title="为什么要学vim"></a>为什么要学vim</h2><ol>
<li>所有的UNIX Like系统都会内置vi文本编辑器，其他文本编辑器不一定存在。</li>
<li>所有软件的编辑结构都会主动调用vi（例如crontab，visudo,edquota等）<strong>很重要</strong></li>
<li>vim具有程序编辑能力，可以主动以字体颜色辨别语法的正确性，方便程序设计。</li>
<li>程序简单，编辑速度相当快速。</li>
</ol>
<h1 id="vi的使用"><a href="#vi的使用" class="headerlink" title="vi的使用"></a>vi的使用</h1><p>vi分为3种模式，分别是一般模式、编辑模式与命令行模式。它们的作用如下：</p>
<ol>
<li>一般模式：以vi打开一个文件就直接进入一般模式了。在这个模式中，你可以使用左右按键来移动光标，你可以删除字符或删除整行，也可以复制，粘贴你的文件数据。</li>
<li>编辑模式：在一般模式中是无法编辑文件内容的。要等到你按下“i,l,o,O,a,A,r,R”等任何一个字母之后才会进入编辑模式。通常在Linux中，按下这些按键时，在界面的左下方会出现INSERT或REPLACE的字样，此时才可以编辑，如果要回到一般模式，必须要按下ESC才可以退出编辑模式。</li>
<li>命令行模式：在一般模式中，输入“:、/、?”3个中的任何一个按钮，就可以将光标移动到最下面的那一行。在这个模式当中，可以提供你查找数据的操作，而读取、保存、大量替换字符、离开vi、显示行号等操作就是在此模式中完成的。</li>
</ol>
<h2 id="vi按键说明"><a href="#vi按键说明" class="headerlink" title="vi按键说明"></a>vi按键说明</h2><p>这个按键说明大部分人都会有总结，所以这里也就不再做无用功了，所以贴出下面的链接，遇到问题去查就好了，但是需要保证所有按键都亲自去试一遍！</p>
<p><strong><a href="https://blog.csdn.net/zyq522376829/article/details/47321739" target="_blank" rel="external">Linux - vim按键说明</a></strong></p>
<p>但是这里我还是想把<strong>常用的命令</strong>在这里再贴出来，希望能够记住：</p>
<ol>
<li>一般模式可用的按钮说明，光标移动、复制粘贴、查找替换等</li>
</ol>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + f</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键</td>
</tr>
<tr>
<td>Ctrl + b</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键</td>
</tr>
<tr>
<td>0 或功能键Home</td>
<td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td>
</tr>
<tr>
<td>$ 或功能键End</td>
<td>移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td>G</td>
<td>移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td>gg</td>
<td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td>
</tr>
<tr>
<td>nEnter</td>
<td>n为数字。光标向下移动 n 行(常用)</td>
</tr>
<tr>
<td>/word</td>
<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 server这个字符串，就输入 /vbird 即可！ (常用)</td>
</tr>
<tr>
<td>:n1,n2s/word1/word2/g</td>
<td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2</td>
</tr>
<tr>
<td>:1,$s/word1/word2/g</td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2</td>
</tr>
<tr>
<td>:1,$s/word1/word2/gc</td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代</td>
</tr>
<tr>
<td>x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键)</td>
</tr>
<tr>
<td>dd</td>
<td>删除游标所在的那一整列</td>
</tr>
<tr>
<td>ndd</td>
<td>n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列</td>
</tr>
<tr>
<td>yy</td>
<td>复制游标所在的那一行</td>
</tr>
<tr>
<td>nyy</td>
<td>n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列</td>
</tr>
<tr>
<td>p, P</td>
<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。</td>
</tr>
<tr>
<td>u</td>
<td>复原前一个动作</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>重做上一个动作</td>
</tr>
<tr>
<td>.</td>
<td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点“.”就好了！</td>
</tr>
</tbody>
</table>
<ol>
<li>一般模式切换到编辑模式的可用的按钮说明</li>
</ol>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>i, I</td>
<td>进入插入模式(Insert mode)：i 为从目前光标所在处插入， I 为在目前所在行的第一个非空格符处开始插入。</td>
</tr>
<tr>
<td>a, A</td>
<td>进入插入模式(Insert mode)：a为从目前光标所在的下一个字符处开始插入， A 为从光标所在行的最后一个字符处开始插入。</td>
</tr>
<tr>
<td>o, O</td>
<td>进入插入模式(Insert mode)：这是英文字母 o 的大小写。o 为在目前光标所在的下一行处插入新的一』； O 为在目前光标所在处的上一行插入新的一行！</td>
</tr>
<tr>
<td>r, R</td>
<td>进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止。</td>
</tr>
<tr>
<td>Esc</td>
<td>退出编辑模式，回到一般模式中</td>
</tr>
</tbody>
</table>
<ol>
<li>一般模式切换到指令列模式的可用的按钮说明</li>
</ol>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:w</td>
<td>将编辑的数据写入硬盘档案中</td>
</tr>
<tr>
<td>:q</td>
<td>离开 vi</td>
</tr>
<tr>
<td>:wq</td>
<td>储存后离开，若为 :wq! 则为强制储存后离开</td>
</tr>
</tbody>
</table>
<h1 id="vim的功能"><a href="#vim的功能" class="headerlink" title="vim的功能"></a>vim的功能</h1><p>目前大部分的发行版都以vim替代vi的功能了，如果你使用vi后，却看到界面的右下角有显示目前光标的行列号码，那么你的vi已经被vim替代了，vim相比于vi有许多新的功能。</p>
<h2 id="块操作"><a href="#块操作" class="headerlink" title="块操作"></a>块操作</h2><p>vi的操作基本上都是以行为单位的操作，但是vim具有块操作的功能，具体的按键说明如下：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>v</td>
<td>字符选择，将光标经过的地方反白选择</td>
</tr>
<tr>
<td>V</td>
<td>行选择，将光标经过的行反白选择</td>
</tr>
<tr>
<td>Ctrl + v</td>
<td>块选择，可以用长方形选择数据</td>
</tr>
<tr>
<td>y</td>
<td>将反白的地方复制</td>
</tr>
<tr>
<td>d</td>
<td>删除反白的地方</td>
</tr>
</tbody>
</table>
<h2 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h2><p>有事我们需要在一个vim内编辑多个文件，这个时候我们就需要多文件编辑功能，具体按键如下：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:n</td>
<td>编辑下一个文件</td>
</tr>
<tr>
<td>:N</td>
<td>编辑上一个文件</td>
</tr>
<tr>
<td>:files</td>
<td>列出目前这个vim打开的所有文件</td>
</tr>
</tbody>
</table>
<h2 id="多窗口功能"><a href="#多窗口功能" class="headerlink" title="多窗口功能"></a>多窗口功能</h2><p>很多时候我们需要对比文件，但是情况是在同一个vim窗口，这时候也就需要用到多窗口功能，具体按键如下：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>：sp filename</td>
<td>打开新窗口，如果有加filename,新窗口打开新文件，否则打开相同文件</td>
</tr>
<tr>
<td>Ctrl + w + j/↓</td>
<td>按键的按法是：先按下Ctrl不放，再按下w后放开所有的按键，然后再按下j或箭头，则光标可移动到下方的窗口</td>
</tr>
<tr>
<td>Ctrl + w + k/↑</td>
<td>同上，但是光标移动到上面的窗口</td>
</tr>
</tbody>
</table>
<h2 id="vim常用命令示意图"><a href="#vim常用命令示意图" class="headerlink" title="vim常用命令示意图"></a>vim常用命令示意图</h2><p><img src="http://o6plzvjf2.bkt.clouddn.com/linux/jpg/vim.jpg" alt="vim"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
<li><a href="https://blog.csdn.net/zyq522376829/article/details/47321739" target="_blank" rel="external">Linux - vim按键说明</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：系统管理员的重要工作就是修改与设置某些重要软件的配置文件，因此至少得到学会一种以上的命令行界面的文本编辑器。在所有的Linux发行版中都具有vi这款编辑器，我们这次学的它的高级版vim。
    
    </summary>
    
      <category term="Linux私房菜" scheme="http://bestlixiang.site/categories/Linux%E7%A7%81%E6%88%BF%E8%8F%9C/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux私房菜_Linux磁盘与文件系统管理</title>
    <link href="http://bestlixiang.site/2018/03/25/Linux%E7%A7%81%E6%88%BF%E8%8F%9C-Linux%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    <id>http://bestlixiang.site/2018/03/25/Linux私房菜-Linux磁盘与文件系统管理/</id>
    <published>2018-03-25T12:02:04.000Z</published>
    <updated>2018-03-25T12:02:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：系统管理员最重要的任务之一就是管理好自己的磁盘文件系统，所以本文的知识对于那些需要规划自己磁盘文件系统的人群特别重要，有些内容可能不太详细，所以日后自己亲身实践过后，希望能再开一篇详细的文章。<a id="more"></a></p>
<h1 id="认识文件系统"><a href="#认识文件系统" class="headerlink" title="认识文件系统"></a>认识文件系统</h1><p>Linux最传统的磁盘文件系统使用的是EXT2（索引式文件系统）。所以要了解文件系统就得要又认识EXT2开始。</p>
<p>在Linux中，需要记录文件权限与文件属性，所以文件系统通常会将这两部分的数据分别存放在不同的块，权限和属性放置到inode中，至于实际数据则放置到data block块中，另外还有一个超级块（superblock）会记录整体文件系统的整体信息。<br>每个inode，block都有编号，下面简略说明上面三个数据的意义：</p>
<ol>
<li>super block：记录此文件系统的整体信息，包括inode/block的总量、使用量、以及文件系统的格式与相关信息。</li>
<li>inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block号码。</li>
<li>block：实际记录文件的内容，若文件太大时，会占用多个block。</li>
</ol>
<h1 id="Linux的Ext2文件系统"><a href="#Linux的Ext2文件系统" class="headerlink" title="Linux的Ext2文件系统"></a>Linux的Ext2文件系统</h1><ol>
<li>Ext2文件系统主要有boot sector，superblock，inode bitmap，block bitmap，inode table，data block六大部分。</li>
<li>data block是用来放置文件内容数据的地方，在Ext2文件系统中所支持的block大小有1KB、2KB及4KB三种。</li>
<li>inode记录文件的属性/权限等数据，每个inode大小均固定为128bytes；每个文件都仅占有一个inode而已；因此文件系统能够新建的文件数量，与inode数量有关。</li>
<li>文件的block记录文件的实际数据，目录的block则记录该目录下面文件名与其inode号码的对照表。</li>
<li>日志文件系统会多出一块记录区，随时记载文件系统的主要活动，可加快恢复时间。</li>
<li>Linux文件系统为增加其性能，会让主存储器作为大量的磁盘高速缓存。</li>
</ol>
<h1 id="文件系统的简单操作"><a href="#文件系统的简单操作" class="headerlink" title="文件系统的简单操作"></a>文件系统的简单操作</h1><h2 id="磁盘与目录的容量：df，du"><a href="#磁盘与目录的容量：df，du" class="headerlink" title="磁盘与目录的容量：df，du"></a>磁盘与目录的容量：df，du</h2><ol>
<li><p>df：列出文件系统的整体磁盘使用量</p>
<p> 在执行df命令之后，会出现如下信息：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">文件系统          1K-块    已用     可用 已用% 挂载点</div><div class="line">/dev/vda1      51474044 6759800 42092876   14% /</div><div class="line">devtmpfs         932632       0   932632    0% /dev</div><div class="line">tmpfs            941920      24   941896    1% /dev/shm</div><div class="line">tmpfs            941920     316   941604    1% /run</div><div class="line">tmpfs            941920       0   941920    0% /sys/fs/cgroup</div><div class="line">tmpfs            188388       0   188388    0% /run/user/0</div></pre></td></tr></table></figure>
</li>
<li><p>du：评估文件系统的磁盘使用量（常用于评估目录所占容量）</p>
<p> 可以看看下面的案例：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 1. 列出目前目录下的所有文件容量</div><div class="line">du</div><div class="line">// 2. 同范例一，但是将文件的容量也列出来</div><div class="line">du -a</div><div class="line">// 3. 检查根目录下面每个目录所占用的容量</div><div class="line">du -sm /*</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="连接文件"><a href="#连接文件" class="headerlink" title="连接文件"></a>连接文件</h2><ol>
<li><p>hard link (硬连接或实际连接)</p>
<p> hard link只是在某个目录下新建一条文件名连接到某inode号码的管理记录。它的命令如下：</p>
<blockquote>
<p>ln</p>
</blockquote>
<p> hard link是有如下限制的：</p>
<ul>
<li>不能跨文件系统</li>
<li>不能连接到目录</li>
</ul>
</li>
<li><p>symbolic link (符号连接，也即是快捷方式)</p>
<p> symbolic link就是在创建一个独立的文件，而这个文件会让数据的读取指向它连接的按个文件的文件名。它的命令如下：</p>
<blockquote>
<p>ls -s</p>
</blockquote>
<p> symbolic link与Windows的快捷方式可以画上等号，如果原文件被删除了，那symbolic link也就不能用了。</p>
</li>
</ol>
<h1 id="磁盘的分区、格式化、校验与挂载"><a href="#磁盘的分区、格式化、校验与挂载" class="headerlink" title="磁盘的分区、格式化、校验与挂载"></a>磁盘的分区、格式化、校验与挂载</h1><p>对于一个系统管理者(root)而言，磁盘的管理是相对重要的一环，如果我们想要在系统里面新增一块硬盘，应该有哪些动作需要做？</p>
<ol>
<li>对磁盘进行分区，以新建可用的分区</li>
<li>对该分区进行格式化，以创建系统可用的文件系统</li>
<li>若想要仔细一点，则可对刚才新建好的文件系统进行校验</li>
<li>在Linux系统上，需要创建挂载点（也即是目录），并将它挂载上来</li>
</ol>
<h2 id="磁盘分区：fdisk"><a href="#磁盘分区：fdisk" class="headerlink" title="磁盘分区：fdisk"></a>磁盘分区：fdisk</h2><p>输入如下命令，进入磁盘分区操作：</p>
<blockquote>
<p>fdisk /dev/hdc(磁盘名)</p>
</blockquote>
<p>接下来就是按照提示新增或者删除分区了。</p>
<h2 id="磁盘格式化：mkfs"><a href="#磁盘格式化：mkfs" class="headerlink" title="磁盘格式化：mkfs"></a>磁盘格式化：mkfs</h2><p>分区完毕之后就要进行格式化，格式化非常简单，使用mkfs（make file system）即可。命令如下：</p>
<blockquote>
<p>mkfs [-t 文件系统格式] 磁盘设备的文件名</p>
</blockquote>
<p>-t后的文件系统格式就是让你指定将文件系统格式化成哪种文件系统。如ext2、ext3、vfat等。</p>
<h2 id="磁盘检验：fsck"><a href="#磁盘检验：fsck" class="headerlink" title="磁盘检验：fsck"></a>磁盘检验：fsck</h2><p>当系统运行出现问题导致文件系统发生错乱，此时就需要磁盘的检验。命令如下：</p>
<blockquote>
<p>fsck [-t 文件系统] [-ACay] 设备名称</p>
</blockquote>
<p>通常只有root用户，而且在文件系统有问题的时候才能进行这个操作，因为在正常情况下使用这个命令会对系统伤害很大。 此外，fsck在扫描的时候，有问题的数据会被放在lost＋found这个文件夹中。所以正常情况下这个文件夹中是不应该有数据的。</p>
<h2 id="磁盘挂载与卸载：mount，umount"><a href="#磁盘挂载与卸载：mount，umount" class="headerlink" title="磁盘挂载与卸载：mount，umount"></a>磁盘挂载与卸载：mount，umount</h2><p>在挂载前需要确定下面几件事：</p>
<ol>
<li>单一文件系统不应该被重复挂载在不同的挂载点（目录）中</li>
<li>单一目录不应该重复挂载多个文件系统</li>
<li>作为挂载带你的目录理论上应该都是空目录</li>
</ol>
<p>具体命令如下</p>
<ul>
<li><p>挂载：</p>
<blockquote>
<p>mount [-t 文件系统] [-L 文件系统的卷标名称] [-o 额外选项] [-n] 设备文件名 挂载点  </p>
</blockquote>
</li>
<li><p>卸载</p>
<blockquote>
<p>umount [-fn] 设备文件名或挂载点</p>
</blockquote>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：系统管理员最重要的任务之一就是管理好自己的磁盘文件系统，所以本文的知识对于那些需要规划自己磁盘文件系统的人群特别重要，有些内容可能不太详细，所以日后自己亲身实践过后，希望能再开一篇详细的文章。
    
    </summary>
    
      <category term="Linux私房菜" scheme="http://bestlixiang.site/categories/Linux%E7%A7%81%E6%88%BF%E8%8F%9C/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux私房菜_Linux文件与目录管理大全解</title>
    <link href="http://bestlixiang.site/2018/03/25/Linux%E7%A7%81%E6%88%BF%E8%8F%9C-Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E5%A4%A7%E5%85%A8%E8%A7%A3/"/>
    <id>http://bestlixiang.site/2018/03/25/Linux私房菜-Linux文件与目录管理大全解/</id>
    <published>2018-03-25T01:40:30.000Z</published>
    <updated>2018-03-25T03:20:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在使用Linux的过程中，最多的命令莫过于在操作文件与目录，所以通过本文，能让你大概率熟悉所有关于文件与目录的命令与知识，但是参数方面就需要自己去查询了。<a id="more"></a></p>
<h1 id="目录与路径"><a href="#目录与路径" class="headerlink" title="目录与路径"></a>目录与路径</h1><h2 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h2><ol>
<li>绝对路径：路径的写法<strong>一定由根目录/写起</strong>。</li>
<li>相对路径：路径的写法是相对于当前工作目录写的。</li>
</ol>
<h2 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h2><ol>
<li><p>特殊目录列表</p>
<ul>
<li>. ：当前目录</li>
<li>.. ：上层目录</li>
<li>- ：前一个工作目录</li>
<li>~ ：登陆用户的主文件夹</li>
<li>~account ：这个用户的主文件夹 （account是个账号名称）</li>
</ul>
</li>
<li><p>常见目录处理的命令</p>
<ul>
<li>cd：切换目录</li>
<li>pwd：显示当前目录</li>
<li>mkdir：新建一个新的目录</li>
<li>rmdir：删除一个空的目录，删除非空目录需要使用rm -r</li>
<li>好习惯：经常利用Tab键快速完整地输入目录或命令</li>
</ul>
</li>
<li><p>环境变量PATH</p>
<p> 当我们执行命令：ls －al的时候，系统会按照PATH设置的路径，去这些路径中寻找ls这个文件，并执行。如果PATH路径中有多个ls文件，那么先找到的那个ls文件被执行。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 查看PATH</span></div><div class="line">echo $PATH</div><div class="line"><span class="comment">// 在PATH中添加路径/demo</span></div><div class="line">PATH=<span class="string">"$PATH"</span>:/demo</div></pre></td></tr></table></figure>
<p> 对于PATH我们有几点需要清楚：</p>
<ul>
<li>不同身份用户默认的PATH不同，默认能够随意执行的命令也不同，差异较大的地方在于/sbin和/usr/sbin。</li>
<li>PATH是可以修改的，所以一般用户还是可以通过修改PATH来执行某些位于/sbin或/usr/sbin下的命令来查询。</li>
<li>使用绝对路径或相对路径直接指定某个命令的文件名来执行。</li>
<li>命令应该要放在正确的目录下，执行才会比较方便。</li>
<li>本目录（.）最好不要放到PATH当中，因为本目录会变化。</li>
</ul>
</li>
</ol>
<h1 id="文件和目录管理"><a href="#文件和目录管理" class="headerlink" title="文件和目录管理"></a>文件和目录管理</h1><p>在文件与目录的管理上，不外乎“显示属性”、“复制”、“删除文件”、“移动目录或文件”等。下面这这种管理动作的具体指令：</p>
<ol>
<li>显示属性<blockquote>
<p>ls</p>
</blockquote>
</li>
<li>复制<blockquote>
<p>cp</p>
</blockquote>
</li>
<li>删除<blockquote>
<p>rm</p>
</blockquote>
</li>
<li>移动(重命名)<blockquote>
<p>mv</p>
</blockquote>
</li>
</ol>
<p>这些指令的具体参数，希望大家能够通过man info去熟悉。</p>
<p>我们可以通过下面的命令去取得路径的文件名与目录名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 取得文件名称</div><div class="line">basename /etc/sysconfig/network</div><div class="line">// 取得文件目录</div><div class="line">dirname /etc/sysconfig/network</div></pre></td></tr></table></figure></p>
<h1 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h1><p>主要有下面一些命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>cat</td>
<td>由第一行开始显示文件内容</td>
</tr>
<tr>
<td>tac</td>
<td>从最后一行开始显示，可以看出tac是cat的到写形式</td>
</tr>
<tr>
<td>nl</td>
<td>显示的时候，顺便输出符号</td>
</tr>
<tr>
<td>more</td>
<td>一页一页显示文件内容</td>
</tr>
<tr>
<td>less</td>
<td>与more类似，但是比more更好的是，它可以往前翻页</td>
</tr>
<tr>
<td>head</td>
<td>只看头几行</td>
</tr>
<tr>
<td>tail</td>
<td>只看尾几行</td>
</tr>
<tr>
<td>od</td>
<td>以二进制的方式读取文件内容</td>
</tr>
</tbody>
</table>
<h1 id="文件与目录的默认权限和隐藏权限"><a href="#文件与目录的默认权限和隐藏权限" class="headerlink" title="文件与目录的默认权限和隐藏权限"></a>文件与目录的默认权限和隐藏权限</h1><p>除了基本的rwx权限之外，Linux的ext2/ext3文件系统下，我们还可以设置系统隐藏属性，它可以用chattr来设置，用lsattr来查看。最重要的属性就是可以设置文件/目录为不可修改，这可以让文件所有者都不能进行修改，这对于安全性方面是非常重要的。</p>
<h2 id="文件的默认权限：umask"><a href="#文件的默认权限：umask" class="headerlink" title="文件的默认权限：umask"></a>文件的默认权限：umask</h2><p>umask指定了目前用户在新建文件或目录时候的权限默认值。</p>
<p>指定了以下面的方式来指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@VM_0_9_centos ~]# umask</div><div class="line">0022 // 与一般权限有关的是后面是三个数字(表示不拥有该数值的权限，此例就表示group不拥有w，others不拥有w)</div><div class="line">[root@VM_0_9_centos ~]# umask -S</div><div class="line">u=rwx,g=rx,o=rx</div><div class="line"></div><div class="line">// 设置默认权限</div><div class="line">umask 002</div></pre></td></tr></table></figure></p>
<p>在默认权限的属性上，目录与文件是不一样的，x权限对于目录是非常重要的，但是一般文件的创建则不应该拥有执行权限。所以默认情况下：</p>
<ul>
<li>若用户创建“文件”则默认没有可执行权限，默认权限为666，即-rw-rw-rw-</li>
<li>若用户创建“目录”则默认拥有可执行权限，默认权限为777，即drwxrwxrwx</li>
</ul>
<h2 id="文件隐藏属性chattr，lsattr"><a href="#文件隐藏属性chattr，lsattr" class="headerlink" title="文件隐藏属性chattr，lsattr"></a>文件隐藏属性chattr，lsattr</h2><ol>
<li><p>chattr 设置文件的隐藏属性</p>
<p> 注意参数a（文件只能增加数据，不能删除也不能修改数据）和i(不能 删除，修改)</p>
</li>
<li>lsattr 显示文件隐藏属性</li>
</ol>
<h2 id="文件的特殊权限SUID-SGID-SBIT"><a href="#文件的特殊权限SUID-SGID-SBIT" class="headerlink" title="文件的特殊权限SUID,SGID,SBIT"></a>文件的特殊权限SUID,SGID,SBIT</h2><ol>
<li>SUID(u+s,如x为空，则出现大S)，限制与功能如下：<ul>
<li>SUID权限仅对二进制程序有效</li>
<li>执行者对于该程序需要x的可执行权限</li>
<li>本权限仅在执行该程序的过程中有效</li>
<li>执行者将具有该程序所有者的权限</li>
</ul>
</li>
<li>SGID（g+s,如x为空，则出现大S），对于文件功能与SUID类似，但是对于目录有如下功能：<ul>
<li>用户若对于此目录具有r与x的权限时，该用户能够进入此目录</li>
<li>用户在此目录下得有效用户组将变成该目录的用户组</li>
<li>若用户在此目录下具有w的权限（可以新建文件），则用户所创建的新文件的用户组与此目录的用户组相同</li>
</ul>
</li>
<li>SBIT（o+t,如x为空，则出现大T），目前只针对目录有效，它的作用如下：<ul>
<li>当用户对于此目录具有w，x权限，即具有写入的权限时，当用户在该目录下创建文件或目录时，仅有自己与root才有权利删除该文件。</li>
</ul>
</li>
</ol>
<h2 id="查看文件类型：file"><a href="#查看文件类型：file" class="headerlink" title="查看文件类型：file"></a>查看文件类型：file</h2><p>如果想知道某个文件的基本数据，就可以使用file这个命令查看。</p>
<h1 id="文件与命令的查询"><a href="#文件与命令的查询" class="headerlink" title="文件与命令的查询"></a>文件与命令的查询</h1><h2 id="脚本文件名的查询"><a href="#脚本文件名的查询" class="headerlink" title="脚本文件名的查询"></a>脚本文件名的查询</h2><p>如果你想知道类似ls这种命令的脚本放在哪里，就通过which或type来找寻。</p>
<p>which命令是根据PATH这个环境变量所规范的路径去查询“执行文件”的文件名。</p>
<h2 id="文件名的查找"><a href="#文件名的查找" class="headerlink" title="文件名的查找"></a>文件名的查找</h2><p>通常find不很常用，因为速度慢，通常我们都是先使用whereis或者是locate来检查，如果真的找不到了，才以find来查找，因为whereis与loacate是利用数据库来查询数据的，而find是直接查找硬盘的。</p>
<ol>
<li>whereis：寻找特定文件</li>
<li>locate：根据文件的部分名称查找，由于是查询数据库的，而数据库是当晚更新，所以你新建文件是查找不到的，可以利用updatedb手动更新，但是较慢。</li>
<li>find：参数很多，自己用的时候需要使用man page自行了解。</li>
</ol>
<h1 id="文件与文件系统的压缩与打包"><a href="#文件与文件系统的压缩与打包" class="headerlink" title="文件与文件系统的压缩与打包"></a>文件与文件系统的压缩与打包</h1><h2 id="常见的压缩命令"><a href="#常见的压缩命令" class="headerlink" title="常见的压缩命令"></a>常见的压缩命令</h2><p>不同的压缩打包技术，对应着不同的解压缩拆包技术，所以在Linux中用后缀名来分辨压缩打包技术，如下表：</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>压缩打包技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>*.Z</td>
<td>compress程序压缩</td>
</tr>
<tr>
<td>*.gz</td>
<td>gzip程序压缩</td>
</tr>
<tr>
<td>*.bz2</td>
<td>bzip2程序压缩</td>
</tr>
<tr>
<td>*.tar</td>
<td>tar程序打包，未压缩</td>
</tr>
<tr>
<td>*.tar.gz</td>
<td>tar程序打包,gzip程序压缩</td>
</tr>
<tr>
<td>*.tar.bz2</td>
<td>tar程序打包,bzip2程序压缩</td>
</tr>
</tbody>
</table>
<p>由于compress已经不再流行，所有我们主要讲解gzip和gzip2:</p>
<ol>
<li><p>gzip,zcat（用来替代compress）</p>
<p> 目前gzip可以解开compress、zip与gzip等软件压缩的文件。可以看一下下面的案例：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 1. 压缩文件</div><div class="line">gzip -v 文件名 // 参数v显示压缩比</div><div class="line">// 2. 查看压缩文件内容</div><div class="line">zcat 压缩文件</div><div class="line">// 3. 解压缩</div><div class="line">gzip -d 压缩文件名 // 参数d表示解压缩</div></pre></td></tr></table></figure>
</li>
<li><p>bzip2,bzcat（用来替代gzip）</p>
<p> 使用方法与gzip基本相同，不再赘述。</p>
</li>
</ol>
<h2 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h2><p>在压缩文件夹之前需要打包，然后我们就需要用到大名鼎鼎的tar，下面通过命令来具体介绍他的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 1. 压缩，参数的含义自己去用man page查看</div><div class="line">tar -jcv -f filename.tar.bz2 // 要被压缩的文件或目录名称，tar并不会主动产生创建的文件名</div><div class="line">// 2. 查询</div><div class="line">tar -jtv -f filename.tar.bz2</div><div class="line">// 3. 解压缩</div><div class="line">tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录（如：/tmp）</div></pre></td></tr></table></figure></p>
<p>对于只是打包没有压缩的文件叫做tarfile</p>
<p>对于打包了并且压缩的文件叫做tarball</p>
<h2 id="完整备份工具"><a href="#完整备份工具" class="headerlink" title="完整备份工具"></a>完整备份工具</h2><ol>
<li>dump 备份</li>
<li>restore 恢复</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在使用Linux的过程中，最多的命令莫过于在操作文件与目录，所以通过本文，能让你大概率熟悉所有关于文件与目录的命令与知识，但是参数方面就需要自己去查询了。
    
    </summary>
    
      <category term="Linux私房菜" scheme="http://bestlixiang.site/categories/Linux%E7%A7%81%E6%88%BF%E8%8F%9C/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux私房菜_Linux的文件权限与目录配置</title>
    <link href="http://bestlixiang.site/2018/03/22/Linux%E7%A7%81%E6%88%BF%E8%8F%9C-Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://bestlixiang.site/2018/03/22/Linux私房菜-Linux的文件权限与目录配置/</id>
    <published>2018-03-22T09:03:13.000Z</published>
    <updated>2018-03-22T09:06:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：了解好文件权限和目录的具体含义才能更好的操作Linux，所以理解好文件权限与目录配置才至关重要。<a id="more"></a></p>
<h1 id="用户与用户组"><a href="#用户与用户组" class="headerlink" title="用户与用户组"></a>用户与用户组</h1><h2 id="用户（User）"><a href="#用户（User）" class="headerlink" title="用户（User）"></a>用户（User）</h2><ol>
<li>用户可以随意改变自己所拥有的文件</li>
<li>root用户就是最大的大佬，可以干任何事。</li>
</ol>
<h2 id="用户组（Group）"><a href="#用户组（Group）" class="headerlink" title="用户组（Group）"></a>用户组（Group）</h2><ol>
<li>同一个用户组的用户可以访问该用户组的文件</li>
<li>每个账号可以加入多个用户组</li>
<li>在同一个用户组的文件也可以设置不同的权限，可以不让本组用户查看</li>
</ol>
<h2 id="其他人（Others）"><a href="#其他人（Others）" class="headerlink" title="其他人（Others）"></a>其他人（Others）</h2><p>除了文件用户、同组用户以外的人就是其他人。</p>
<h2 id="Linux用户身份与用户组记录的文件"><a href="#Linux用户身份与用户组记录的文件" class="headerlink" title="Linux用户身份与用户组记录的文件"></a>Linux用户身份与用户组记录的文件</h2><ol>
<li>系统上的账号与一般身份用户以及root的相关信息都记录在/etc/passwd文件中</li>
<li>个人的密码都记录在/etc/shadow文件中</li>
<li>Linux所有的组名都记录在/etc/group文件中</li>
</ol>
<h1 id="文件权限概念"><a href="#文件权限概念" class="headerlink" title="文件权限概念"></a>文件权限概念</h1><h2 id="Linux文件属性"><a href="#Linux文件属性" class="headerlink" title="Linux文件属性"></a>Linux文件属性</h2><p>我们可以利用下面的命令来查看文件属性：</p>
<blockquote>
<p>ls -al  // 列出所有文件详细的权限和属性（包含隐藏文件）</p>
</blockquote>
<p>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">总用量 92</div><div class="line">drwxr-xr-x. 22 root root 4096 3月  17 12:33 .</div><div class="line">dr-xr-xr-x. 20 root root 4096 3月  22 09:14 ..</div><div class="line">drwxr-xr-x.  2 root root 4096 11月  5 2016 adm</div><div class="line">drwxr-xr-x   2 root root 4096 3月  12 10:27 alldata</div><div class="line">... 省略</div></pre></td></tr></table></figure></p>
<p>解释一下上面7列的意思：</p>
<ol>
<li><p>第一列：文件的类型与权限</p>
<p> 第一个字符代表这个文件是“目录、文件或链接文件等”。</p>
<ul>
<li>d：目录文件</li>
<li>-：普通文件</li>
<li>l：链接文件</li>
<li>b：用于存储数据的设备文件</li>
<li><p>c：用于传输数据的设备文件：鼠标、键盘</p>
<p>接下来都是三个字符为一组，分别表示文件所有者的权限、同组用户的权限、其他用户的权限，而且r（读）、w（写）、x（执行）的顺序是固定不变的。</p>
</li>
</ul>
</li>
<li>第二列：有多少文件名连接到此节点</li>
<li>第三列：这个文件（或目录）的所有者账号</li>
<li>第四列：这个文件所属的用户组</li>
<li>第五列：这个文件的大小，单位是B</li>
<li>第六列：这个文件的创建日期或修改日期</li>
<li>第七列：文件名</li>
</ol>
<h2 id="改变文件属性与权限的命令"><a href="#改变文件属性与权限的命令" class="headerlink" title="改变文件属性与权限的命令"></a>改变文件属性与权限的命令</h2><ol>
<li>chgrp：改变文件所属的用户组 （注意-R 参数，递归更改）</li>
<li>chown：改变文件所有者 （注意-R 参数，递归更改）</li>
<li><p>chmod：改变文件的权限 （注意-R 参数，递归更改）</p>
<p> 改变文件的权限有两种办法，分别是：用数字进行权限的修改、用符号进行权限的修改。</p>
<ul>
<li><p>用数字进行权限的修改：权限有9个字母组成，并且每三个为一组，分别表示：文件主的权限、同组用户的权限、其他人的权限。在这种方式中，r＝4、w＝2、x＝1，将每一组的三个值加起来，组成一个三位数即可。实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod -R 754 文件或目录</div></pre></td></tr></table></figure>
</li>
<li><p>用符号进行权限的修改：我们通过u(user)，g(group)，o(others)，a(all)来表示身份权限，通过<br>r（读）,w（写）,x（执行）来表示读写的权限，通过+（加入），-（除去），=（设置）来表示修改操作，实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod u/g/o/a  +/-/=  r/w/x  文件/目录</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="目录与文件的权限意义"><a href="#目录与文件的权限意义" class="headerlink" title="目录与文件的权限意义"></a>目录与文件的权限意义</h2><ol>
<li>权限对文件的重要性：<ul>
<li>r：可读取此文件的实际内容。</li>
<li>w：可以编辑、新增或者修改该文件的内容（单不含删除该文件）</li>
<li>x：该文件具有可以被系统执行的权限。</li>
</ul>
</li>
<li>权限对目录的重要性<ul>
<li>r：表示具有读取目录结构的权限，即可以执行ls命令</li>
<li>w：表示具有更改该目录结构列表的权限，比如新建新的文件与目录、删除已经存在的文件与目录、将已存在或目录进行重命名、转移该目录内的文件和目录位置</li>
<li>x：表示用户能否进入该目录，即可以使用cd进入该目录</li>
</ul>
</li>
</ol>
<h2 id="文件种类与扩展名"><a href="#文件种类与扩展名" class="headerlink" title="文件种类与扩展名"></a>文件种类与扩展名</h2><ol>
<li>文件种类<ul>
<li>普通文件<ul>
<li>纯文本文件（ASCII），可以用cat命令读取</li>
<li>二进制文件（binary），Linux中的可执行文件</li>
<li>数据格式文件（data），就是程序运行时会被读取的具有特定格式的文件，如配置文件，需要用last命令去读取，用cat读取会乱码</li>
</ul>
</li>
<li>目录</li>
<li>连接文件，类似Windows下的快捷方式</li>
<li>设备与设备文件<ul>
<li>块设备文件，用于存储数据的设备文件，如：硬盘、软盘</li>
<li>字符设备文件，用于数据传输的设备文件，如：键盘、鼠标</li>
<li>套接字，这个设备文件在/var/run中</li>
<li>管道，用于解决多个程序同时访问一个文件所造成的错误问题</li>
</ul>
</li>
</ul>
</li>
<li><p>文件扩展名</p>
<p> Linux并没有扩展名，一个Linux的文件是否可以执行，取决于这个文件的属性中是否有x这个权限（也要真的可以执行）。<br> 但是为了增强文件的可读性，我们还是给文件增加了“扩展名“。如下面几种（等）：</p>
<ul>
<li>＊.sh表示脚本或批处理文件</li>
<li>＊Z、＊.tar、＊.tar.gz、＊.zip、＊.tgz他们都是压缩文件</li>
<li><p>注意：从网上下载的文件的权限是有可能发生改变的，所以当我们下载的文件无法运行时查看一下它的权限是否有x。</p>
<p>Linux对文件的限制：Linxu默认采用Ext2/Ext3文件系统，对文件名的长度限制为，单个文件名或目录名最大长度255个字符；完整的文件或目录名最大长度为4096个字符。</p>
</li>
</ul>
</li>
</ol>
<h1 id="Linux目录配置"><a href="#Linux目录配置" class="headerlink" title="Linux目录配置"></a>Linux目录配置</h1><h2 id="Linux目录配置标准"><a href="#Linux目录配置标准" class="headerlink" title="Linux目录配置标准"></a>Linux目录配置标准</h2><p>FHS一句文件系统使用的频繁与否与是否允许用户随意改动，而将目录定义为四中交互的形态，如下：</p>
<table>
<thead>
<tr>
<th>/</th>
<th>可分享的(shareable)</th>
<th>不可分享的(unshareable)</th>
</tr>
</thead>
<tbody>
<tr>
<td>不变的(static)</td>
<td>/usr (软件放置处)</td>
<td>/etc (配置文件)</td>
</tr>
<tr>
<td>不变的(static)</td>
<td>/opt (第三方软件)</td>
<td>/boot(开机与内核文件)</td>
</tr>
<tr>
<td>可变动的(variable)</td>
<td>/var/mail (用户邮箱信件)</td>
<td>/var/run (程序相关)</td>
</tr>
<tr>
<td>可变动的(variable)</td>
<td>/var/spool/news (新闻组)</td>
<td>/var/lock (程序相关)</td>
</tr>
</tbody>
</table>
<p>解释一下四个类型的意思：</p>
<ul>
<li>可分享的：可以分享给网络上的其他主机挂载使用</li>
<li>不可分享的：只与自己的机器有关，所以自然就不能分享给其他主机</li>
<li>不变的：不管什么样的distributions，这些数据基本不发生变化。一般这些目录中存放函数库、系统配置文件等</li>
<li>可变的：经常改变的数据，如登录文件、新闻组等</li>
</ul>
<p><strong>根目录是整个系统最重要的目录，其他所有的子目录都是由根目录衍生而来的，同时根目录也与开机、还原、系统修复等操作有关。</strong></p>
<p>FHS建议：根目录要足够的小，而且应用程序不要和根目录放在同一个分区中。同时，FHS建议根目录下应该要有这些目录：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin</td>
<td>在bin目录下的命令可以被所有账号使用，一般的命令是：cat、chmod、chown、date、mv、mkdir、cp、bash</td>
</tr>
<tr>
<td>/boot</td>
<td>主要放置开机会使用到的文件</td>
</tr>
<tr>
<td>/dev</td>
<td>任何设备都是以文件的形式存放在这个目录当中</td>
</tr>
<tr>
<td>/etc</td>
<td>统主要的配置文件都放在这个目录中。这个目录下的文件属性是可以给一般用户查阅的，但只有root才可以修改，FHS建议：这个目录下不要放置可执行文件</td>
</tr>
<tr>
<td>/home</td>
<td>系统默认的用户主文件夹,～表示当前登陆用户的主文件夹 ，～rex表示指定用户的主文件夹</td>
</tr>
<tr>
<td>/lib</td>
<td>存放开机时用到的库函数及/bin、/sbin目录下的命令会使用到的库函数</td>
</tr>
<tr>
<td>/media</td>
<td>放置可删除的设备文件。如：软盘、光盘</td>
</tr>
<tr>
<td>/mnt</td>
<td>如果要临时挂载一些额外的设备就放在这个文件夹下</td>
</tr>
<tr>
<td>/opt</td>
<td>放置第三方软件的目录</td>
</tr>
<tr>
<td>/root</td>
<td>系统管理员的主文件夹</td>
</tr>
<tr>
<td>/sbin</td>
<td>放置开机过程中需要的，包括开机、修复、还原系统所需要的命令</td>
</tr>
<tr>
<td>/srv</td>
<td>是service的缩写，存放网络服务所需的一些数据</td>
</tr>
<tr>
<td>/tmp</td>
<td>一般用户执行程序暂时存放数据的地方。任何人都可以访问，所以要定时清理一下。FHS建议distributions开机时要将这个目录清空</td>
</tr>
</tbody>
</table>
<p>其他重要的目录：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>/lost+found</td>
<td>使用ext2/ext3文件系统才会产生的一个目录。当文件系统发生错误时，一些丢失的片段就会放在这个目录中</td>
</tr>
<tr>
<td>/proc</td>
<td>是一个虚拟文件系统，也就是它的数据都是存放在内存中的，不占用硬盘空间</td>
</tr>
<tr>
<td>/sys</td>
<td>也是一个虚拟文件系统，记录内核相关信息</td>
</tr>
</tbody>
</table>
<p>开机的时候只有根目录被挂载了，其他的目录所在的分区都是在系统启动完成之后才被挂载的。因此与开机过程有关的目录就必须要和根目录放在同一个分区中。必须与根目录放在同一个分区中的目录有下面这些目录：</p>
<ul>
<li>/etc：配置文件</li>
<li>/bin：重要的执行文件</li>
<li>/dev：所需要的设备文件</li>
<li>/lib：执行文件所需要的库函数与内核所需要的模块</li>
<li>/sbin：重要的系统执行文件</li>
</ul>
<p>/usr目录：＝UNIX Software Resource，是操作系统关键资源放置的目录。<br>FHS建议：所有软件开发者都应将数据放置在这个目录的子目录下，而不要自行创建独立的目录。<br>这个目录就相当于Windows下的c:\program files</p>
<p>/var目录：/usr放置安装程序时所需要的较大容量的文件，而/var下存放系统运行后才会渐渐占用硬盘的目录。如：缓存、日志、Mysql数据库的文件等。</p>
<h2 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h2><p>在Linux里面，所有的文件与目录都是由根目录开始的，那是所有目录与文件的源头，然后在一个一个分支下来，我们称这种目录配置为<strong>目录树</strong>。</p>
<p>目录树主要有以下特征：</p>
<ol>
<li>目录树的起始点为根目录（/，root）</li>
<li>每个目录不只能使用本地端的文件系统，也可以使用网络上的文件系统，例如可以利用NFS服务器挂载某特定目录等</li>
<li>米格文件在此目录树的文件名（包含完整路径）都是独一无二的。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：了解好文件权限和目录的具体含义才能更好的操作Linux，所以理解好文件权限与目录配置才至关重要。
    
    </summary>
    
      <category term="Linux私房菜" scheme="http://bestlixiang.site/categories/Linux%E7%A7%81%E6%88%BF%E8%8F%9C/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux私房菜_Linux基本命令使用与查询</title>
    <link href="http://bestlixiang.site/2018/03/21/Linux%E7%A7%81%E6%88%BF%E8%8F%9C_Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%9F%A5%E8%AF%A2/"/>
    <id>http://bestlixiang.site/2018/03/21/Linux私房菜_Linux基本命令使用与查询/</id>
    <published>2018-03-21T08:55:52.000Z</published>
    <updated>2018-03-25T01:44:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：从浅入深，我们也从基础命令开始。学会基本命令的使用，学会怎么去查命令的使用，最后学会一丢丢维护（开关机）。<br><a id="more"></a></p>
<h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><h2 id="开始执行命令"><a href="#开始执行命令" class="headerlink" title="开始执行命令"></a>开始执行命令</h2><p>首先我们要了解命令的格式：</p>
<blockquote>
<p>command(命令或可执行文件) <a href="选项">-options</a> parameter1(参数1) parameter2(参数2)</p>
</blockquote>
<p>如果命令太长，我们可以使用反斜杠(\)来转义[enter符号]，注意反斜杠必须立刻接特殊字符，才能转义。</p>
<p>在linux下面是区分大小写的。</p>
<h2 id="基础命令的操作"><a href="#基础命令的操作" class="headerlink" title="基础命令的操作"></a>基础命令的操作</h2><ol>
<li>显示日期与时间的命令：date</li>
<li>显示日历的命令：cal</li>
<li>简单好用的计算器：bc，使用quit停止</li>
</ol>
<h2 id="重要的热键"><a href="#重要的热键" class="headerlink" title="重要的热键"></a>重要的热键</h2><ol>
<li>Tab按键：具有命令补全，文件补齐的功能</li>
<li>ctrl + c：可以让程序立刻停下来</li>
<li>ctrl + d：通常代码键盘输入结束，相当于exit</li>
</ol>
<h1 id="在线求助man-page-与info-page"><a href="#在线求助man-page-与info-page" class="headerlink" title="在线求助man page 与info page"></a>在线求助man page 与info page</h1><h2 id="man-page"><a href="#man-page" class="headerlink" title="man page"></a>man page</h2><p>man其实是manual（操作说明）的简写，只要通过（man + 命令） 就会有详细的说明出现。</p>
<p>如 man date可以得到下面的文本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">DATE(1)                                  User Commands                                  DATE(1)</div><div class="line"></div><div class="line">NAME</div><div class="line">       date - print or set the system date and time</div><div class="line"></div><div class="line">SYNOPSIS</div><div class="line">       date [OPTION]... [+FORMAT]</div><div class="line">       date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</div><div class="line"></div><div class="line">DESCRIPTION</div><div class="line">       Display the current time in the given FORMAT, or set the system date.</div><div class="line"></div><div class="line">       Mandatory arguments to long options are mandatory for short options too.</div><div class="line"></div><div class="line">       -d, --date=STRING</div><div class="line">              display time described by STRING, not &apos;now&apos;</div><div class="line"></div><div class="line">        ...省略其他参数</div><div class="line"></div><div class="line">ENVIRONMENT</div><div class="line"></div><div class="line">EXAMPLES</div><div class="line"></div><div class="line">DATE STRING</div><div class="line"></div><div class="line">AUTHOR</div><div class="line">       Written by David MacKenzie.</div><div class="line"></div><div class="line">COPYRIGHT</div><div class="line"></div><div class="line">SEE ALSO</div><div class="line"></div><div class="line">GNU coreutils 8.22                       November 2016                                  DATE(1)</div></pre></td></tr></table></figure></p>
<p>我们首先看到的是“DATE(1)”，这个(1)是有特殊含义的，如下表：</p>
<table>
<thead>
<tr>
<th>代号</th>
<th>代表内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>用户在shell环境中可以操作的命令或可执行的文件</td>
</tr>
<tr>
<td>2</td>
<td>系统内核可调用的函数与工具等</td>
</tr>
<tr>
<td>3</td>
<td>一些常用的函数与函数库，大部分为C的函数库</td>
</tr>
<tr>
<td>4</td>
<td>设备文件的说明，通常在/dev的文件</td>
</tr>
<tr>
<td>5</td>
<td>配置文件或者某些文件的格式</td>
</tr>
<tr>
<td>6</td>
<td>游戏</td>
</tr>
<tr>
<td>7</td>
<td>惯例与协议等，例如Linux文件系统，网络协议、ASCII code等说明</td>
</tr>
<tr>
<td>8</td>
<td>系统管理员与可用的管理命令</td>
</tr>
<tr>
<td>9</td>
<td>跟kernel有关的文件</td>
</tr>
</tbody>
</table>
<p>我们要特别注意1，5，8这三个号码，尽量背下来。</p>
<p>在上面的man page中，以NAME作为开始介绍，最后还有个SEE ALSO来作为结束。基本上，man page大致分为以下几个部分：</p>
<table>
<thead>
<tr>
<th>代号</th>
<th>内容说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME</td>
<td>简短的命令、数据名称说明</td>
</tr>
<tr>
<td>SYNOPSIS</td>
<td>简短的命令执行语法（syntax）简介</td>
</tr>
<tr>
<td>DESCRIPTION</td>
<td>较为完整的说明，最好仔细看看</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>针对SYNNPSIS部分中，有列举的所有可用的选项说明</td>
</tr>
<tr>
<td>COMMANDS</td>
<td>在这个程序在执行的时候，可以在此程序中执行的命令</td>
</tr>
<tr>
<td>FILES</td>
<td>这个程序或数据所使用或参考或连接到的某些文件</td>
</tr>
<tr>
<td>SEE ALSO</td>
<td>这个命令或数据有相关的其他说明</td>
</tr>
<tr>
<td>EXAMPLES</td>
<td>一些可以参考的范例</td>
</tr>
<tr>
<td>BUGS</td>
<td>是否有相关的错误</td>
</tr>
</tbody>
</table>
<p>通常在查询某些数据是这样来查阅的：</p>
<ol>
<li>先看NAME的项目，略微看一下数据的意思</li>
<li>再仔细看一下DESCRIPTION，这个部分会提到很多相关的资料和用法。</li>
<li>如果这个命令其实很熟悉了，那么主要就是查询OPTIONS的部分了。</li>
<li>最后会看一下和这个资料有关的还有哪些东西可以使用。</li>
<li>某些说明内容还会列举有关的文件（FILES）来提供我们参考。</li>
</ol>
<p>man page 常用的按键：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>进行工作</th>
</tr>
</thead>
<tbody>
<tr>
<td>空格键</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>Page Down</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>Page Up</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>Home</td>
<td>去到第一页</td>
</tr>
<tr>
<td>End</td>
<td>在去到最后一页</td>
</tr>
<tr>
<td>/string</td>
<td>向下查询string字符串</td>
</tr>
<tr>
<td>?string</td>
<td>向上查询string字符串</td>
</tr>
<tr>
<td>n,N</td>
<td>利用/或？来查询字符串时，可以用n来继续查询下一个查询，可以利用N来进行反向查询</td>
</tr>
<tr>
<td>q</td>
<td>结束这次man page</td>
</tr>
</tbody>
</table>
<p>下面还有两个man的用途：</p>
<ol>
<li>man -f command （= whatis）：查询和command这个命令有关的说明文件</li>
<li>man -k data（= apropos）：查询包含data这个数据有关的文件</li>
</ol>
<h2 id="info-page"><a href="#info-page" class="headerlink" title="info page"></a>info page</h2><p>info与man的用途差不多，都是用来查询命令的用法或者文件的格式，但是与man page一下子输出一堆信息不同的是，info page则是将文件数据拆成一个一个段落，每个段落用自己的页面来撰写，并且在各个页面中还有类似网页的“超链接”来调到各个页面，每个独立的页面也被称为一个节点（node）。</p>
<p>这里这里不多说，有兴趣者可以自己去看看使用。</p>
<h2 id="其他有用的文件"><a href="#其他有用的文件" class="headerlink" title="其他有用的文件"></a>其他有用的文件</h2><p>一般而言，命令或者软件开发者都会将自己的命令或者是软件的说明制作成“在线帮助文件”，但是毕竟不是什么都需要做成在线帮助文件的，在/usr/share/doc中我们会发现会有很多说明文件文档，这些会告诉我们怎么做，以及一些相关的原理。</p>
<h1 id="开机与关机"><a href="#开机与关机" class="headerlink" title="开机与关机"></a>开机与关机</h1><h2 id="开机与登录"><a href="#开机与登录" class="headerlink" title="开机与登录"></a>开机与登录</h2><p>一般服务器都不怎么重启，我们在登录服务器的时候，基本上都是使用ssh来登录，我们可以使用下面的命令：</p>
<blockquote>
<p>ssh ip</p>
</blockquote>
<p>在这个命令之后会要求与你输入密码即可成功。</p>
<h2 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h2><p>在Linux中，由于每个程序都是在后台运行的，因此你看不到屏幕后面其实可能有很多人同时在你的主机上面工作，所以我们不能随意关机。所以在正常情况下，要关机时要注意下面几件事：</p>
<ol>
<li>查看系统的使用状态<ul>
<li>如果要看目前有谁在线：执行“who”这个命令</li>
<li>如果要看网络的联机状态：执行“netstat -a”这个命令</li>
<li>如果要看后台执行的程序：执行“ps -aux”这个命令</li>
</ul>
</li>
<li>通知在线用户关机的时刻</li>
<li>正确地关机命令使用：shutdown与reboot</li>
<li>将数据同步写入硬盘的命令：sync</li>
<li>惯用的关机命令：shutdown</li>
<li>重启、关机：reboot,halt,poweroff</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一章最为基础，灰常重要，就像地基，只有有了地基，我们才能好好造下面的房子。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：从浅入深，我们也从基础命令开始。学会基本命令的使用，学会怎么去查命令的使用，最后学会一丢丢维护（开关机）。&lt;br&gt;
    
    </summary>
    
      <category term="Linux私房菜" scheme="http://bestlixiang.site/categories/Linux%E7%A7%81%E6%88%BF%E8%8F%9C/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux私房菜_Linux磁盘分区</title>
    <link href="http://bestlixiang.site/2018/03/21/Linux%E7%A7%81%E6%88%BF%E8%8F%9C-Linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"/>
    <id>http://bestlixiang.site/2018/03/21/Linux私房菜-Linux磁盘分区/</id>
    <published>2018-03-21T05:49:21.000Z</published>
    <updated>2018-03-21T05:49:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：Linux在我印象中最大的特点就是它把所有的硬件都当做一个文件，然后还是以/为根节点的目录树，简洁明了，相信大家一定会爱上它的。因为涉及到文件的存储，所以我们要重视磁盘分区。<a id="more"></a></p>
<h1 id="硬件设备在linux中的文件名"><a href="#硬件设备在linux中的文件名" class="headerlink" title="硬件设备在linux中的文件名"></a>硬件设备在linux中的文件名</h1><p>Linux中每一个设备都被当成文件，所有的设备文件都在/dev这个目录下。下面列出几个常见设备与其在Linux当中的文件名，如下表：</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>设备在Linux内的文件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE硬盘</td>
<td>/dev/hd[a-d]</td>
</tr>
<tr>
<td>SATA/USB/SCSI硬盘</td>
<td>/dev/sd[a-p]</td>
</tr>
<tr>
<td>U盘</td>
<td>/dev/sd[a-p]（与SATA相同）</td>
</tr>
<tr>
<td>软驱</td>
<td>/dev/fd[0－1]</td>
</tr>
<tr>
<td>打印机</td>
<td>25针：/dev/lp[0－2] usb：/dev/usb/lp[0-15]</td>
</tr>
<tr>
<td>鼠标</td>
<td>usb:/dev/usb/mouse[0－15] ps2:/dev/psaux</td>
</tr>
<tr>
<td>当前CD/DVD ROM</td>
<td>/dev/cdrom</td>
</tr>
<tr>
<td>当前鼠标</td>
<td>/dev/mouse</td>
</tr>
<tr>
<td>磁带机</td>
<td>IDE:/dev/ht0 SCSI:/dev/st0</td>
</tr>
</tbody>
</table>
<h1 id="硬盘分区"><a href="#硬盘分区" class="headerlink" title="硬盘分区"></a>硬盘分区</h1><h2 id="磁盘的文件命名规则"><a href="#磁盘的文件命名规则" class="headerlink" title="磁盘的文件命名规则"></a>磁盘的文件命名规则</h2><p>磁盘的接口有两种，分别是IDE接口、SATA接口。目前主流的接口是SATA接口。<br>使用IDE接口的设备我们称为IDE设备。</p>
<ol>
<li>IDE设备：一个IDE接口可以连接两个IDE设备，主机中一般用两个IDE接口，因此最多可以连接四个IDE设备。这两个IDE接口通常被称为IDE1、IDE2，而每个IDE接口连接的两个IDE设备又被分为主设备和从设备。这四个IDE设备的文件名如下表：</li>
</ol>
<table>
<thead>
<tr>
<th>IDE接口</th>
<th>主设备</th>
<th>从设备</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE1</td>
<td>/dev/hda</td>
<td>/dev/hdb</td>
</tr>
<tr>
<td>IDE2</td>
<td>/dev/hdc</td>
<td>/dev/hdd</td>
</tr>
</tbody>
</table>
<ol>
<li>SATA设备：以SATA/USB/SCSI为接口的磁盘使用的都是SCSI模块来驱动的，因此他们的设备文件名都是/dev/sd[a-p]。但是与IDE设备不同的是，他们的文件名没有一定的顺序，谁先插上去，谁就是a，以此类推。</li>
</ol>
<h2 id="磁盘的组成"><a href="#磁盘的组成" class="headerlink" title="磁盘的组成"></a>磁盘的组成</h2><p>整个磁盘的第一个扇区非常重要，因为他记录了下面的重要的信息：</p>
<ol>
<li>主引导分区Master Boot Record,MBR：可以安装“引导加载程序”的地方。有446bytes。</li>
<li>分区表：记录整块硬盘的分区状况，有64bytes。</li>
</ol>
<h2 id="磁盘分区表"><a href="#磁盘分区表" class="headerlink" title="磁盘分区表"></a>磁盘分区表</h2><p>对磁盘进行分区时，采用柱面作为基本单位。分区表有64bytes，被分成四个区域，每个区域记录当前磁盘的所有分区的起始和结束柱面号。例如：一块IDE硬盘被分成四个区域： P1：/dev/hda1 ，P2：/dev/hda2 ，P3：/dev/hda3 ，P4：/dev/hda4。每个磁盘的分区表只能被分成四个区域，这四个区域被称为<strong>主分区或扩展分区</strong>。当系统进行数据的读写时，一定要参考分区表才能进行。</p>
<h3 id="分区的原因"><a href="#分区的原因" class="headerlink" title="分区的原因"></a>分区的原因</h3><p>保证数据的安全性（分区不会影响）；提升系统的性能（只在自己的分区查找）。</p>
<h3 id="扩展分区"><a href="#扩展分区" class="headerlink" title="扩展分区"></a>扩展分区</h3><p>主分区和扩展分区都是分区表中的一条记录，主分区中存放通过直接索引就能到达的分区的开始和结束的柱面号；而扩展分区中存放的是逻辑分区表的开始和结束柱面号，这张逻辑分区表中才存放分区的开始和结束柱面号。</p>
<p>由于一张分区表只能存放四条记录，也就是四个分区，当我们想要多一些分区的时候就必须要通过扩展分区来实现。 分区表中的四条记录对应的设备文件名是不会变的。如上面的四个名字，所以逻辑分区的文件名一定是从5开始的。如：/dev/hda5。</p>
<h3 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h3><ol>
<li>扩展分区最多只能有1个。</li>
<li>Linux中，IDE硬盘最多有59个逻辑分区，5号－63号；SATA硬盘最多有11个逻辑分区，5号－15号。</li>
<li>在Windows中若D、E盘都是扩展分区中的逻辑分区，那么他们可以整合成一个分区；若两个盘一个是逻辑分区，一个是主分区，那他们是不能合并的。</li>
<li>一块硬盘的第一个扇区记录了MBR和分区表，非常的重要，如果第一个扇区坏了，那么整个硬盘就报废了。</li>
</ol>
<h1 id="开机流程"><a href="#开机流程" class="headerlink" title="开机流程"></a>开机流程</h1><p>整个开机流程到操作系统之前的动作应该是这样的：</p>
<ol>
<li>BIOS：开机主动执行的韧体，会认识第一个可开机的对象。</li>
<li>MBR：第一个可开机设备的第一个扇区的主引导分区块，内包含引导加载程序。</li>
<li>引导加载程序：一支可读取内核文件来执行的软件。（可多个不同系统的加载程序对应了不同的操作系统）</li>
<li>内核文件：开始操作系统的功能。</li>
</ol>
<p>PS：为什么如果安装多重引导，最好先安装Windows在安装Linux？——因为Linux在安装的时候可以选择将引导加载程序安装在MBR或个别分区的启动扇区，而且在linnux的loader可以手动设置菜单，所以你可以在Linux的boot loader里面加入Windows开机的选项。Windows在安装的时候，它的安装程序会主动覆盖掉MBR以及自己所在分区的启动扇区，你没有选择的机会，而且没有让我们选择菜单的功能。</p>
<h1 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h1><h2 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h2><p>在Linux中，整个文件系统呈一棵以/为根目录的树。</p>
<h2 id="文件系统与目录树的关系（挂载）"><a href="#文件系统与目录树的关系（挂载）" class="headerlink" title="文件系统与目录树的关系（挂载）"></a>文件系统与目录树的关系（挂载）</h2><p><strong>挂载</strong>就是把一个目录当作磁盘中某一个分区的进入点，也就是说，进入了这个目录，就进入了这个磁盘的这个分区。这个进入的目录我们就称为挂载点。<br>根目录一定要挂载到某个分区。</p>
<p>如何寻找挂载点（判断某个在文件在哪个分区下）？答：通过反向追踪即可，当我们想要知道/home/rex/test文件在那个分区时，只要逆向寻找第一个挂载点就是这个文件的挂载点。 可以使用下面的命令：</p>
<blockquote>
<p>df /home/rex/test</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>了解分区，了解开机流程，了解挂载，ok，就这些！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：Linux在我印象中最大的特点就是它把所有的硬件都当做一个文件，然后还是以/为根节点的目录树，简洁明了，相信大家一定会爱上它的。因为涉及到文件的存储，所以我们要重视磁盘分区。
    
    </summary>
    
      <category term="Linux私房菜" scheme="http://bestlixiang.site/categories/Linux%E7%A7%81%E6%88%BF%E8%8F%9C/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux私房菜_Linux基础学习</title>
    <link href="http://bestlixiang.site/2018/03/20/Linux%E7%A7%81%E6%88%BF%E8%8F%9C-Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://bestlixiang.site/2018/03/20/Linux私房菜-Linux基础学习/</id>
    <published>2018-03-20T12:13:05.000Z</published>
    <updated>2018-03-20T12:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：了解Linux，学习Linux，深入Linux。<a id="more"></a></p>
<h1 id="Linux是什么"><a href="#Linux是什么" class="headerlink" title="Linux是什么"></a>Linux是什么</h1><p><strong>Linux就是一套操作系统，它的内核是Linux Torvalds在1991年开发出来的。</strong></p>
<h2 id="Linux的内核版本"><a href="#Linux的内核版本" class="headerlink" title="Linux的内核版本"></a>Linux的内核版本</h2><p>看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2.6.18-92.e15</div><div class="line">主版本.次版本.释出版本-修改版本</div></pre></td></tr></table></figure></p>
<ol>
<li>主、次版本为奇数：开发中版本，如2.5.xx，这种版本仅内核开发工程师使用。</li>
<li>主、次版本为偶数：稳定版本，如2.6.xx ，家庭、企业使用。</li>
</ol>
<p>我们可以通过下面的命令查看自己的linux的版本号：</p>
<pre><code>uname -r
</code></pre><h2 id="Linux发行版"><a href="#Linux发行版" class="headerlink" title="Linux发行版"></a>Linux发行版</h2><p>Linux其实就是Linux Kernel（内核）＋内核工具。他是GNU GPL授权模式，任何人都可以获取源代码并进行修改。因此Linux的全名是：GNU/Linux。<br>Linux ditribution是由各个商业公司开发，本质上是LinuxKernel＋内核工具＋软件，让普通用户都能使用的操作系统。 基本上Linux distributions并无太大区别，可以根据自己的喜好选择。他们的内核都是从www.kernel.org上下载的。</p>
<h2 id="Linux的特色"><a href="#Linux的特色" class="headerlink" title="Linux的特色"></a>Linux的特色</h2><ol>
<li>自由与开放的使用与学习环境</li>
<li>配置需求低廉</li>
<li>内核功能强大而稳定</li>
<li>独立作业</li>
</ol>
<h2 id="Linux优点"><a href="#Linux优点" class="headerlink" title="Linux优点"></a>Linux优点</h2><ol>
<li>稳定的系统</li>
<li>免费或少许费用</li>
<li>安全性、漏洞的快速修补</li>
<li>多任务、多用户</li>
<li>用户与用户组的规划</li>
<li>相对比较不耗资源的系统</li>
<li>整合度佳且多样的图形用户界面</li>
</ol>
<h2 id="Linux缺点"><a href="#Linux缺点" class="headerlink" title="Linux缺点"></a>Linux缺点</h2><ol>
<li>没有特定的支持产商</li>
<li>游戏的支持度不足</li>
<li>专业软件的支持度不足</li>
</ol>
<h1 id="Linux当前的角色"><a href="#Linux当前的角色" class="headerlink" title="Linux当前的角色"></a>Linux当前的角色</h1><h2 id="企业环境的应用"><a href="#企业环境的应用" class="headerlink" title="企业环境的应用"></a>企业环境的应用</h2><ol>
<li>网络服务器（当今最热门的运用）</li>
<li>关键任务的应用（金融数据库、大型企业）</li>
<li>学术机构的高性能运算任务</li>
</ol>
<h2 id="个人环境的使用"><a href="#个人环境的使用" class="headerlink" title="个人环境的使用"></a>个人环境的使用</h2><ol>
<li>桌面计算机(在Linux系统上装一个X Window System软件之后，就能有桌面了)</li>
<li>手持设备（PAD、手机）</li>
<li>嵌入式系统</li>
</ol>
<h1 id="Linux的学习路线"><a href="#Linux的学习路线" class="headerlink" title="Linux的学习路线"></a>Linux的学习路线</h1><ol>
<li>学习计算机概论及硬件相关知识</li>
<li>从Linux的安装开始学起</li>
<li>学会使用Linux的基本技能</li>
<li>学会vi编辑器</li>
<li>shell与shell脚本的学习</li>
<li>一定要会软件管理员</li>
<li>了解网络基础</li>
<li>使用Linux架设网站</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在使用Linux之前请学会Linux！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：了解Linux，学习Linux，深入Linux。
    
    </summary>
    
      <category term="Linux私房菜" scheme="http://bestlixiang.site/categories/Linux%E7%A7%81%E6%88%BF%E8%8F%9C/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux私房菜_计算机基础</title>
    <link href="http://bestlixiang.site/2018/03/20/Linux%E7%A7%81%E6%88%BF%E8%8F%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://bestlixiang.site/2018/03/20/Linux私房菜-计算机基础/</id>
    <published>2018-03-20T10:29:00.000Z</published>
    <updated>2018-03-20T10:38:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：我也算是从通信专业转到计算机的，所以当然对计算机专业课知识不太了解，所以也想简单掌握以下计算机基础知识。<a id="more"></a></p>
<p>计算机其实是：<strong>接收用户输入指令和数据，经过中央处理器的数据欲逻辑单元运算处理后，以产生或存储成有用的信息。</strong></p>
<h1 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h1><h2 id="计算机硬件的五大单元"><a href="#计算机硬件的五大单元" class="headerlink" title="计算机硬件的五大单元"></a>计算机硬件的五大单元</h2><ol>
<li>输入单元</li>
<li>输出单元</li>
<li>CPU内部的控制单元</li>
<li>CPU内部的算术逻辑单元</li>
<li>内存</li>
</ol>
<h2 id="CPU的种类"><a href="#CPU的种类" class="headerlink" title="CPU的种类"></a>CPU的种类</h2><p>CPU内部已经含有一些小指令集，我们所使用的软件都要经过CPU内部的微指令集来完成才行。这些指令集的设计主要被分为两种设计理念，如下：</p>
<ol>
<li><p>精简指令集（RISC）</p>
<p> 采用精简指令集的cpu的指令较为精简，每条指令的执行时间很短，完成的操作也很单纯，指令的执行性能较好；但是如果要做一些复杂的操作，则需要多个指令来协同完成。</p>
<p> 常见的精简指令集CPU有：</p>
<ul>
<li>sun公司的SPARC系列，常应用于学术领域的大型工作站</li>
<li>IBM公司的Power Architecture（包括Power PC），如索尼的PS3</li>
<li>IBM公司的ARM系列，常用于手机、pda、导航系统、网络设备等 （使用最广泛）</li>
</ul>
</li>
<li><p>复杂指令集（CISC）</p>
<p> 每一条指令较为复杂，因为执行的时间比较长，但是每条指令处理的工作较为丰富。</p>
<p> 常见的复杂指令集的CPU：AMD、Intel、VIA等x86架构的cpu。由于这些采用了复杂指令集的x86架构的cpu常常被用在个人计算机上，所以个人计算机常常就被称为x86计算机。x86架构的CPU最早由因特尔开发，并且它将CPU从8位提升为16位、32位。后来，AMD公司基于x86架构开发出了64位的CPU。所以64位CPUu的架构叫做x86_64，非64位cpu的架构仍然叫做x86。</p>
</li>
</ol>
<h2 id="接口设备"><a href="#接口设备" class="headerlink" title="接口设备"></a>接口设备</h2><ol>
<li>存储设备：包括硬盘，软盘等</li>
<li>显示设备：显卡等</li>
<li>网络设备：网卡等</li>
</ol>
<h2 id="计算机分类"><a href="#计算机分类" class="headerlink" title="计算机分类"></a>计算机分类</h2><ol>
<li>超级计算机：运算速度最快的计算机，主要是用于需要有高速计算的项目中。</li>
<li>大型计算机：功能上不及超级计算机，但也可以用来处理大量数据与复杂计算。</li>
<li>迷你计算机：主机可以放在一般场所，无需像大型计算机一样需要特殊的空调场所。</li>
<li>工作站：工作站的价格比迷你计算机便宜许多，。是针对特殊用途而设计的计算机。</li>
<li>微电脑：个人计算机（PC）。</li>
</ol>
<h2 id="计算机上面的常用的计算单位（大小、速度等）"><a href="#计算机上面的常用的计算单位（大小、速度等）" class="headerlink" title="计算机上面的常用的计算单位（大小、速度等）"></a>计算机上面的常用的计算单位（大小、速度等）</h2><ol>
<li>文件大小：1GB=1024*1024*1024Byte；1Byte=8bit</li>
<li>CPU运算速度：MHz或者GHz，Hz为秒分之一</li>
<li>网络传输：Mbit/s或者MB/s，注意bit还是Byte</li>
</ol>
<h1 id="个人计算机架构与接口设备"><a href="#个人计算机架构与接口设备" class="headerlink" title="个人计算机架构与接口设备"></a>个人计算机架构与接口设备</h1><p>在计算机主板上的芯片组通常又分为两个桥接器来控制各组件的通信：</p>
<ul>
<li>北桥负责连接速度较快的CPU、内存与显卡等组件。北桥的总线称为系统总线。因为是内存传输的主要通道，所以速度快。</li>
<li>南桥负责链接速度较慢的周边接口，包括硬盘、USB、网卡等。南桥的总线称为输入输出(I/O)总线。</li>
</ul>
<p>AMD和Intel的芯片组架构最主要的区别是AMD的内存是直接与CPU通信而不通过北桥。</p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="外频与内屏"><a href="#外频与内屏" class="headerlink" title="外频与内屏"></a>外频与内屏</h3><ol>
<li>外频：CPU与外部组件进行数据传输/运算时的速度。</li>
<li>倍频：CPU内部用来加速工作性能的一个倍速，两者相乘才是cpu 的频率。</li>
</ol>
<h3 id="32位与64位"><a href="#32位与64位" class="headerlink" title="32位与64位"></a>32位与64位</h3><ol>
<li>北桥所支持的频率称为前端总线速（FSB）度，而每次传送的位数则是总线宽度，所谓总线频宽则是“FSB*总线宽度”，业技术每秒钟可以传送的最大数据量。</li>
<li>CPU每次能处理的数据量称为字组大小(word size)，字组大小依据cpu的设计有32／64位。我们现在称计算机是32／64位是根据CPU解析的字组大小来的。</li>
</ol>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>我们平时所说的内存的全名叫做动态随机访问存储器（DRAM）。DRAM是一种挥发性内存，只有它通电的时候才能被使用，断电数据就消失。DRAM分为：</p>
<ol>
<li>SDRAM</li>
<li>DDR SDRAM，DDR=Double Data Rate 所以他的传输速度比SDRAM要快。</li>
</ol>
<p>对服务器而言，内存的容量比CPU的速度更加重要。CPU与内存的外频应该相同才好。</p>
<h3 id="双通道设计"><a href="#双通道设计" class="headerlink" title="双通道设计"></a>双通道设计</h3><p>总线宽度一般是64位，也就是每次总线从内存中读写64位数据，若在主板上插两根内存条，那么总线宽度就达到128位，从而提升了内存的读写速度。在主板上插两根内存条的设计就叫做双通道设计。<br>但是要启动双通道功能，安插的两根内存条必须型号一样，大小一样，这样才能整体上提升内存的读写速度。</p>
<h3 id="DRAM与SRAM"><a href="#DRAM与SRAM" class="headerlink" title="DRAM与SRAM"></a>DRAM与SRAM</h3><p>DRAM就是我们平时所说的内存，它的全称叫做动态随机访问存储器。而SRAM的全程叫做静态随机访问存储器。SRAM可以用在很多不同的地方，而CPU中的第二层高速缓存就是选择SRAM作为存储器。由于L2 Cache集成在CPU内部，CPU读取数据无需再经过北桥从内存中获取，直接从L2 Cache中获取，从而能提升性能。</p>
<h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><p>显卡又叫做VGA（Video Graphics Array）。图形影响的显示质量的好坏重点在于分辨率和色彩深度。<br>由于显示的每一个像素都会占用内存，因此显卡上面也有个存储器，而这个存储器的大小直接影响显示的效果。早期时候3D的运算是交给CPU去处理的，为了减少CPU的负担，所以在显卡上设置一个处理器，这个处理器就是GPU。</p>
<p>PS: 如果你的主机是用来打3D游戏，那么显卡的选购非常重要，如果你的主机是用来作为网络服务器，那么简单的入门级显卡对你的主机来说就非常够用了。</p>
<h2 id="硬盘与存储设备"><a href="#硬盘与存储设备" class="headerlink" title="硬盘与存储设备"></a>硬盘与存储设备</h2><p>计算机系统上的存储设备包括硬盘、软盘、U盘等，我们主要介绍硬盘：</p>
<ol>
<li>硬盘主要是由许多的盘片、机械手臂、磁头与主轴马达所组成。实际的数据都是写在具有磁性物质的盘片上，硬盘运行时，主轴马达让盘片转动，机械手臂可以伸缩，让读取头在盘片上面进行读写操作。</li>
<li>硬盘的最小存储单位是扇区，每个扇区的大小是512bytes，这个值是不可改变的。扇区组成的环叫做磁道。上下的所有磁道构成柱面。柱面是分割硬盘的最小单位。一般硬盘制造商杂显示硬盘容量时，大多是以十进制来编号，所有500GB的硬盘，理论上仅会有460GB左右的容量。</li>
<li>传输接口主要有以下几种：<ul>
<li>IDE接口：每秒传输可达133MB。</li>
<li>SATA接口：SATA－1每秒传输150MB，SATA－2每秒传输300MB，目前个人计算机都已使用SATA。</li>
<li>SCSI接口：这个接口含有一个处理器，硬盘的读写操作由这个处理器完成，从而提升计算机整体性能。</li>
</ul>
</li>
</ol>
<p>PS：硬盘很脆弱，千万别让它摔了还是怎样，血的教训。</p>
<h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><p>主板可以说是整台主机相当重要的地方，因为重要的组件都是安插在主板上面的，而主板上面负责通信各个组件的就是芯片组。下面说说主板我们常用的东西：</p>
<ol>
<li>CMOS与BIOS：CMOS主要的功能是记录主板上面的重要参数，如系统时间等。BIOS为写入到主板上某一块闪存或EEPROM的程序，它可以在开机的时候执行，已加载CMOS当中的参数，并尝试调用存储设备中的开机程序，进一步进入操作系统当中。</li>
<li>连接接口设备：主板与各项输出/输入设备的链接主要都是在主机箱的后方，如USB接口RJ-45接口等。</li>
</ol>
<h1 id="计算机编码"><a href="#计算机编码" class="headerlink" title="计算机编码"></a>计算机编码</h1><ol>
<li>常用的英文编码表是ASKII，每个字符占1B，因此总共有2的8次方种变化。</li>
<li>中文编码表常用gb2312，每个字符占2B，定义了一万三千多个字。但是，这个编码表对于数据库存储有问题，从数据库读出数据的时候有些字会被读错。</li>
<li>为了解决上面的问题，出现了Unicode编码表，就是UTF-8。</li>
</ol>
<h1 id="软件程序运行"><a href="#软件程序运行" class="headerlink" title="软件程序运行"></a>软件程序运行</h1><p>一般来说目前的计算机系统将软件分为两大类：一是系统软件（内核），一个是应用程序（日常所说的软件）。</p>
<h2 id="机器程序与编译程序"><a href="#机器程序与编译程序" class="headerlink" title="机器程序与编译程序"></a>机器程序与编译程序</h2><ol>
<li>机器程序：都是机器码，可以直接给机器识别。</li>
<li>编译程序：能够将高级语言编译成机器程序。</li>
</ol>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>先看看操作系统的角色，从底层到高层：硬件-&gt;内核-&gt;系统调用-&gt;应用程序。其中内核以及系统调用被称为操作系统。</p>
<ol>
<li>操作系统内核：操作系统其实也是一组程序，这组程序的重点在于管理计算机的所有活动以及驱动系统的所有硬件。</li>
<li>系统调用：操作系统提供的一组开发接口。</li>
<li>内核功能：<ul>
<li>系统调用接口</li>
<li>程序管理</li>
<li>内存管理</li>
<li>文件系统管理</li>
<li>设备驱动</li>
</ul>
</li>
<li>操作系统与驱动程序：操作系统通常会提供一个开发接口给硬件商，让他们可以根据这个接口色合计可以驱动他们硬件的驱动程序。</li>
</ol>
<h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><p>应用程序是参考操作系统提供的开发接口所开发出来的软件，这些软件可以让用户操作，以达到某些计算机的功能利用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>了解好计算机的基础知道，我们对计算机里面的硬件以及程序的实现有了一个大概的了解，有利于我们学习下面的知识。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：我也算是从通信专业转到计算机的，所以当然对计算机专业课知识不太了解，所以也想简单掌握以下计算机基础知识。
    
    </summary>
    
      <category term="Linux私房菜" scheme="http://bestlixiang.site/categories/Linux%E7%A7%81%E6%88%BF%E8%8F%9C/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——桥梁模式</title>
    <link href="http://bestlixiang.site/2018/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/19/设计模式之禅——桥梁模式/</id>
    <published>2018-03-19T01:32:24.000Z</published>
    <updated>2018-03-19T01:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：不变的部分用继承来实现，变得部分放在外部，并通过<strong>桥梁模式</strong>抽象耦合进来，这样就解决了继承的弊端。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>桥梁模式也叫做桥接模式，其定义如下：</p>
<p><strong>将抽象和实现解耦，使得两者可以独立变化。——结构类</strong></p>
<p>下面是桥梁模式的通用类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/bridge.png" alt="bridge"></p>
<p>我们看看桥梁模式类图中的4个角色：</p>
<ol>
<li>Abstraction抽象化角色：主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。</li>
<li>Implementor实现化角色：定义角色必须的行为和属性。</li>
<li>RefinedAbstraction修正抽象化角色：它引用实现化角色对抽象化角色进行修正。</li>
<li>ConcreteImplementor具体实现化角色：实现接口或抽象类定义的方法和属性。</li>
</ol>
<p>它的通用源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</div><div class="line">    <span class="comment">// 基本方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体实现化角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementor1</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementor2</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象化角色</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义对实现化角色的引用</span></div><div class="line">    <span class="keyword">private</span> Implementor imp;</div><div class="line">    <span class="comment">// 约束子类必须实现该构造函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Abstraction</span><span class="params">(Implementor _imp)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.imp = _imp;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 自身的行为和属性</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.imp.doSomething();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 获得实现化角色</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Implementor <span class="title">getImp</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> imp;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体抽象化角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</div><div class="line">    <span class="comment">// 覆写构造函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor _imp)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(_imp);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 修正父类的行为</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.request();</div><div class="line">        <span class="keyword">super</span>.getImp().doAnything();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 定义一个实现化角色</span></div><div class="line">        Implementor imp = <span class="keyword">new</span> ConcreteImplementor1();</div><div class="line">        <span class="comment">// 定义一个抽象化角色</span></div><div class="line">        Abstraction abs = <span class="keyword">new</span> RefinedAbstraction(imp);</div><div class="line">        <span class="comment">// 执行</span></div><div class="line">        abs.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>抽象和实现分离。</li>
<li>优秀的扩充能力。</li>
<li>实现细节对客户透明。</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>不希望或不合适使用继承的场景。</li>
<li>接口或抽象类不稳定的场景。</li>
<li>重用性要求较高的场景。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>使用桥梁模式主要考虑如何拆分抽象和实现。桥梁模式的意图还是对变化的封装，尽量把可能变化的因素封装到最细、最小的逻辑单元，避免风险扩散。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>继承非常好，但是有缺点。我们可以扬长避短，对于比较明确不发生变化的，则通过继承来完成；若不能确定是否会发生变化的，那就认为会发生变化，则通过桥梁模式来搭建一个桥梁将变化的的东西放在外部和本体进行连接。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：不变的部分用继承来实现，变得部分放在外部，并通过&lt;strong&gt;桥梁模式&lt;/strong&gt;抽象耦合进来，这样就解决了继承的弊端。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——享元模式</title>
    <link href="http://bestlixiang.site/2018/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/18/设计模式之禅——享元模式/</id>
    <published>2018-03-18T12:03:02.000Z</published>
    <updated>2018-03-18T12:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：对象多了，而且还都是处于有用状态，那一定会出现内存溢出的问题，我们可以通过<strong>享元模式</strong>来实现对象的复用，以达到减少的目的，从而解决内存溢出的问题。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>享元模式是<strong>池技术</strong>的重要实现方式，其定义如下：</p>
<p><strong>使用”共享对象”可有效地支持大量的”细粒度的对象”。——结构类</strong></p>
<p>享元模式的定义为我们提出了两个要求：细粒度对象和共享对象。我们知道分配太多的对象到应用程序中将有损程序的性能，同时还容易造成内存溢出，那怎么避免呢？就是享元模式提到的共享技术。我们先来了解一下对象的内部状态和外部状态：</p>
<ul>
<li>内部状态：内部状态是对象可共享出来的信息，存储在享元对象并且不会随环境改变而改变，不必存储在具体某个对象中，属于可以共享的部分。</li>
<li>外部状态：外部状态是对象得以依赖的一个标记，是随环境改变而改变的，不可以共享的状态，他是一批对象的统一标识，是唯一的索引值。</li>
</ul>
<p>下面是享元模式的通用类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/flyweight.png" alt="flyweight"></p>
<p>简单介绍类图中的角色：</p>
<ol>
<li>Flyweight抽象享元角色：产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现。</li>
<li>ConcreteFlyWeight具体享元角色：具体的一个产品类，实现抽象角色定义的业务。该角色中需要注意的是内部状态处理应该与环境无关，不应该出现一个操作改变了内部状态，同时修改了外部状态，这是绝对不允许的。</li>
<li>UnsharedConcreteFlyWeight不可共享的享元角色：不存在外部状态或者安全要求（如线程安全）不能够使用共享技术的对象，该对象一般不会出现享元工厂中。（有点不太理解）</li>
<li>FlyWeightFactory享元工厂：职责非常简单，就是构造一个池容器，同时提供从池中获取对象的方法。</li>
</ol>
<p>享元模式的目的在于运用共享技术，使得一些细粒度的对象可以共享，多使用细粒度的对象，便于重构或重用，下面是它的通用代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  抽象享元角色</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span> </span>&#123;</div><div class="line">    <span class="comment">// 内部状态</span></div><div class="line">    <span class="keyword">private</span> String intrinsic;</div><div class="line">    <span class="comment">// 外部状态 注意final</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String extrinsic;</div><div class="line">    <span class="comment">// 要求享元角色必须接受外部状态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Flyweight</span><span class="params">(String _extrinsic)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.extrinsic = _extrinsic;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 定义业务操作</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> vid <span class="title">operate</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 内部状态的getter/setter</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIntrinsic</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> intrinsic;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntrinsic</span><span class="params">(String intrinsic)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.intrinsic = intrinsic;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体享元角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight1</span> <span class="keyword">extends</span> <span class="title">Flyweight</span> </span>&#123;</div><div class="line">    <span class="comment">// 接受外部状态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight1</span><span class="params">(String _extrinsic)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(_extrinsic)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 根据外部状态进行逻辑处理</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight2</span> <span class="keyword">extends</span> <span class="title">Flyweight</span> </span>&#123;</div><div class="line">    <span class="comment">// 接受外部状态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight2</span><span class="params">(String _extrinsic)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(_extrinsic)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 根据外部状态进行逻辑处理</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 享元工厂</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义一个池容器</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String,Flyweight&gt; pool = <span class="keyword">new</span> HashMap&lt;String,Flyweight&gt;();</div><div class="line">    <span class="comment">// 享元工厂</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String extrinsic)</span> </span>&#123;</div><div class="line">        <span class="comment">// 需要返回的对象</span></div><div class="line">        Flyweight flyweight = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 在池中没有该对象</span></div><div class="line">        <span class="keyword">if</span>(pool.containKey(extrinsic)) &#123;</div><div class="line">            flyweight = pool.get(extrinsic);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 根据外部状态创建享元对象</span></div><div class="line">            flyweight = <span class="keyword">new</span> ConcreteFlyweight1(extrinsic);</div><div class="line">            <span class="comment">// 放置到池中</span></div><div class="line">            pool.put(extrinsic,flyweight);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> flyweight;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>可以大大减少应用程序创建的对象，降低程序内存的占用，增强程序对的性能。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>提高了系统的复杂性，需要分离出外部状态和内部状态，而且外部状态具有固化特性（加fianl关键字），不应该随内部改变而改变，否则导致系统的逻辑混乱。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>系统中存在大量的相似对象。</li>
<li>细粒度的对象都具有较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</li>
<li>需要缓冲池的场景。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>当对象池的对象太少时，会出现线程不安全的现象。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>享元模式在Java API中也是随处可见的，比如String类的intern方法就是利用了String的对象池。当然对象池主要解决复用，而享元模式主要解决对象的共享问题，如果建立多个可共享的细粒度对象是其关注的重点。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：对象多了，而且还都是处于有用状态，那一定会出现内存溢出的问题，我们可以通过&lt;strong&gt;享元模式&lt;/strong&gt;来实现对象的复用，以达到减少的目的，从而解决内存溢出的问题。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——解释器模式</title>
    <link href="http://bestlixiang.site/2018/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/18/设计模式之禅——解释器模式/</id>
    <published>2018-03-18T05:46:46.000Z</published>
    <updated>2018-03-18T05:48:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：无论是编译原理，还是解释型语言，都会涉及到解释，其思想也都和<strong>解释器模式</strong>类似。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>给定一门语言，定义它的文法的一组表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。——行为类</strong></p>
<p>解释器模式的通用类图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/interpreter.png" alt="interpreter"></p>
<p>这里解释一下类图中的角色:</p>
<ol>
<li>AbstractExpression抽象解释器：具体的即时任务又各个实现类完成，具体的解释器分别由TerminalExpression（值）和NotermianlExpression（符号）完成。</li>
<li>TerminalExpression终结符表达式：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但是有多个实例，对应不同的终结符。</li>
<li>NotermianlExpression非终结符表达式：文法中的每条规则对应于一个非终结表达式。</li>
<li>Context环境角色：存放数据</li>
</ol>
<p>解释器是一个比较少用的模式，以下为其通用源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象表达式</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span> </span>&#123;</div><div class="line">    <span class="comment">// 每个表达式必须有一个解释任务</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">interpreter</span><span class="params">(Context ctx)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 终结符表达式</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</div><div class="line">    <span class="comment">// 通常终结符表达式只有一个，但是有多个对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interpreter</span><span class="params">(Context ctx)</span> </span>&#123;</div><div class="line">        <span class="comment">// 主要处理场景元素和数据的转换</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 非终结符表达式</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotermianlExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</div><div class="line">    <span class="comment">// 每个非终结符表达式都会对其他表达式产生依赖</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotermianlExpression</span><span class="params">(Expression... expression)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interpreter</span><span class="params">(Context ctx)</span> </span>&#123;</div><div class="line">        <span class="comment">// 进行文法处理</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Context ctx = <span class="keyword">new</span> Context();</div><div class="line">        <span class="comment">// 通常定一个语法容器，容纳一个具体的表达式，通常为ListArray、LinkedList、Stack等容器</span></div><div class="line">        Stack&lt;Expression&gt; stack = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span>(;;) &#123;</div><div class="line">            <span class="comment">// 进行语法判断，并产生递归调用</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 产生一个完整的语法树，由各个具体的语法分析进行解析</span></div><div class="line">        Expression exp = stack.pop();</div><div class="line">        <span class="comment">// 具体元素进入场景</span></div><div class="line">        exp.interpreter(ctx);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通常Client是一个封装类，封装的结果就是传递进来的规范语法文件，解释器分析后产生结果并返回，避免了调用者与语法解析器的耦合关系。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>解释器是一个简单语法分析工具，它最显著的有点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>解释器模式会引起类膨胀（显而易见）</li>
<li>解释器采用递归调用方法，调试复杂，且影响效率。</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>重复发生的问题可以使用解释器模式，如对不同的日志文件进行不同的分析。</li>
<li>一个简单语法需要解释的场景。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>尽量不要在重要的模块中使用解释器模式，否则维护回事一个很大的问题。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>解释器模式在实际的系统开发中使用得非常少，因为它会引起效率问题、性能以及维护等问题，一般在大中型的框架型项目能够找到它的身影，如一些数据分析工具、报表设计工具、科学计算工具等，若你确实遇到“一种特定类型的问题发生的频率足够高”的情况下，准备使用解释器模式时，可以考虑一下Expression4J、MESP、Jep等开元的解析工具包。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：无论是编译原理，还是解释型语言，都会涉及到解释，其思想也都和&lt;strong&gt;解释器模式&lt;/strong&gt;类似。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——状态模式</title>
    <link href="http://bestlixiang.site/2018/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/18/设计模式之禅——状态模式/</id>
    <published>2018-03-18T04:57:11.000Z</published>
    <updated>2018-03-18T04:57:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：状态（一个变量）变化了，然后就会出现不同的行为，这就是对<strong>状态模式</strong>最简单的理解，当然它还有很多约束。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>当一个对象内在状态改变时允许其他改变行为，这个对象看起来像改变其类。——行为类</strong></p>
<p>状态模式的核心是封装，状态的变更引起了行为的变更，从外部开起来就好像这个对象对应的类发生了改变一样，状态模式的通用类图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/state.png" alt="state"></p>
<p>简单介绍类图中的3个角色</p>
<ol>
<li>State抽象状态角色：负责对象的状态的定义，并且封装环境角色以实现状态的切换。</li>
<li>ConcreteState具体对象状态定义：每个具体状态必须完成两个职责：本状态的行为管理以及<strong>趋向状态</strong>处理。</li>
<li>Context环境角色：定义客户端需要的接口，并且负责具体状态的切换。</li>
</ol>
<p>下面是它的通用源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象状态角色</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义一个环境角色，提供子类访问</span></div><div class="line">    <span class="keyword">protected</span> Context context;</div><div class="line">    <span class="comment">// 设置环境角色</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(Context _context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.context = _context;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 行为1</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle1</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 行为2</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle2</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体状态角色</span></div><div class="line"><span class="keyword">public</span> alass concreteState1 extends State &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 本状态下必须处理的逻辑</span></div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 设置当前状态为state2</span></div><div class="line">        <span class="keyword">super</span>.context.setCurrentState(Context.STATE2);</div><div class="line">        <span class="comment">// 过度到state2状态，由Context实现</span></div><div class="line">        <span class="keyword">super</span>.context.handle2();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> alass concreteState2 extends State &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 本状态下必须处理的逻辑</span></div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 设置当前状态为state1</span></div><div class="line">        <span class="keyword">super</span>.context.setCurrentState(Context.STATE1);</div><div class="line">        <span class="comment">// 过度到state1状态，由Context实现</span></div><div class="line">        <span class="keyword">super</span>.context.handle1();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 环境角色，它具有以下两个不成文的约束：</span></div><div class="line"><span class="comment">// 1. 把状态对象声明为静态变量，有几个状态对象就声明几个静态变量</span></div><div class="line"><span class="comment">// 2. 环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义状态</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> State STATE1 = <span class="keyword">new</span> ConcreteState1();</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> State STATE2 = <span class="keyword">new</span> ConcreteState2();</div><div class="line">    <span class="comment">// 当前状态</span></div><div class="line">    <span class="keyword">private</span> State currentState;</div><div class="line">    <span class="comment">// 获得当前状态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</div><div class="line">        returncurrentState;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置当前状态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(State currentState)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.currentState = currentState;</div><div class="line">        <span class="comment">// 切换状态, 重要</span></div><div class="line">        <span class="keyword">this</span>.currentState.setContext(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">// 行为委托, 重要</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle1</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.currentState.handle1();</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle2</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.currentState.handle2();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 定义环境角色</span></div><div class="line">        Context context = <span class="keyword">new</span> Context();</div><div class="line">        <span class="comment">// 初始化状态</span></div><div class="line">        context.setCurrentState(<span class="keyword">new</span> ConcreteState1());</div><div class="line">        <span class="comment">// 行为执行</span></div><div class="line">        context.handle1();</div><div class="line">        context.handle2();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>结构清晰，提高系统的可维护性</li>
<li>遵循设计原则，很好体现了开闭原则和单一职责原则。</li>
<li>封装性非常好，将状态变化放置到类的内部来实现，外部的调用不用知道类内部如何实现状态和行为的变换。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>只有一个缺点，就是会随着状态的增多会出现类膨胀。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>行为随状态改变而改变的场景，如权限设计。</li>
<li>条件、分支判断语句的替代者。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>状态模式适用于当某个对象在它的状态发生改变时，它的行为也随着发生比较大的变化，也就是说在行为受状态约束的情况下可以使用状态模式，而且使用时对象的状态最好不要超过5个。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>状态模式其实经常会遇到，因为基本上都会遇到状态的切换。对于状态顺序的不同组成不同的状态变化线，我们可以使用建造者模式。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：状态（一个变量）变化了，然后就会出现不同的行为，这就是对&lt;strong&gt;状态模式&lt;/strong&gt;最简单的理解，当然它还有很多约束。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——访问者模式</title>
    <link href="http://bestlixiang.site/2018/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/15/设计模式之禅——访问者模式/</id>
    <published>2018-03-15T06:45:32.000Z</published>
    <updated>2018-03-15T06:46:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：一个对象结构包含很多类对象，他们又有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作，接可以使用<strong>访问者模式</strong>。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用与这些元素的新操作。——行为类</strong></p>
<p>它的通用类图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/visitor.png" alt="visitor"></p>
<p>我们看看类图中几个角色的职责：</p>
<ol>
<li>Visitor抽象访问者：声明访问者可以访问哪些元素，具体到程序找那个就是visit方法的参数定义哪些对象是可以被访问的。</li>
<li>ConcreteVisitor具体访问者：它影响访问者访问到一个类后该怎么干，要做什么事情。</li>
<li>Element抽象元素：声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。</li>
<li>ConcreteElement具体元素：实现accept方法，通常是visitor.visit(this)，基本都形成了一种模式了。</li>
<li>ObjectStruture结构对象：元素产生者，一般容纳在多个不同类，不同接口的容器，如List，Set，Map等，在项目中，一般很好抽象出这个角色。</li>
</ol>
<p>接着看看具体的通用源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象元素</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</div><div class="line">	<span class="comment">// 定义业务逻辑</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">	<span class="comment">// 允许谁来访问</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Ivisitor visitor)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体元素</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElement1</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</div><div class="line">    <span class="comment">// 完善业务逻辑</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务处理</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 允许哪个访问者访问</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Ivisitor visitor)</span> </span>&#123;</div><div class="line">        visitor.visit(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElement2</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</div><div class="line">    <span class="comment">// 完善业务逻辑</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务处理</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 允许哪个访问者访问</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Ivisitor visitor)</span> </span>&#123;</div><div class="line">        visitor.visit(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象访问者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Ivisitor</span> </span>&#123;</div><div class="line">    <span class="comment">// 可以访问哪些对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitor</span> <span class="params">(ConcreteElement1 el1)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitor</span> <span class="params">(ConcreteElement2 el2)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体访问者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Visitor</span> <span class="keyword">implements</span> <span class="title">Ivisitor</span> </span>&#123;</div><div class="line">    <span class="comment">// 访问el1元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement1 el1)</span> </span>&#123;</div><div class="line">        el1.doSomething;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 访问el2元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement2 el2)</span> </span>&#123;</div><div class="line">        el2.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 结构对象 产生不同的元素对象，可以用工厂方式模式模拟</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStruture</span> </span>&#123;</div><div class="line">    <span class="comment">// 对象生成器，通过工厂方法模式模拟</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">createElement</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random random = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">if</span>(random.nextInt(<span class="number">100</span>) &gt;<span class="number">50</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteElement1();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteElement2();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="comment">// 获取元素对象</span></div><div class="line">            Element el = ObjectStruture.createElement();</div><div class="line">            <span class="comment">// 接受访问者访问</span></div><div class="line">            el.accept(<span class="keyword">new</span> Visitor());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>符合单一职责原则。具体元素角色负责数据的加载，访问者类负责报表的展现，职责明确。</li>
<li>优秀的扩展性。报表不同只需要修改visit方法。</li>
<li>灵活性非常高。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>具体元素对访问者公布细节，不符合迪米特法则。</li>
<li>具体元素变更比较困难。</li>
<li>违背了依赖倒置原则，访问者依赖的是具体元素，而不是抽象元素。</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>一个对象结构包含很多类对象，他们又有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作，也就是说用迭代器模式已经不能胜任的情景。</li>
<li>需要对一个对象结构中的对象进行不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。</li>
<li>总结：在这种地方一定要考虑使用访问者模式：业务规则要求遍历多个不同的对象，迭代器只能访问同类或同接口的数据，而访问者模式是对迭代器模式的扩充，可以遍历不同的对象，然后执行不同的操作。访问者模式还可以充当拦截器的角色。</li>
</ol>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>访问者模式一种集中规整模式，特别适用于大规模重构的项目。通过访问这么欧式可以很容易吧一些进行梳理，达到最终目的——功能集中化。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：一个对象结构包含很多类对象，他们又有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作，接可以使用&lt;strong&gt;访问者模式&lt;/strong&gt;。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——备忘录模式</title>
    <link href="http://bestlixiang.site/2018/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/14/设计模式之禅——备忘录模式/</id>
    <published>2018-03-14T05:11:10.000Z</published>
    <updated>2018-03-14T05:11:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>引： <strong>备忘录模式</strong>是我们设计上的“月光宝盒”，可以让我们回到需要的年代；是程序数据的“后悔药”，吃了它就可以返回上一个状态；是设计人员的定心丸，确保即使在最坏的情况下也能获得最近的对象状态。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>备忘录模式提供了一种弥补真实世界缺陷的方法，让“后悔药”在程序的世界中真实可行，其定义如下：</p>
<p><strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在改对象之外保存这个状态，这样以后就可将该对象的恢复到原先保存的状态。——行为类</strong></p>
<p>备忘录模式就是一个对象的备份模式，提供了一种程序数据的备份方法，其通用类图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/memento.png" alt="memento"></p>
<p>下面简单介绍类图中的几个角色：</p>
<ol>
<li>Originator发起人角色：记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。</li>
<li>Memento备忘录角色：负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。</li>
<li>Caretaker备忘录管理员角色：对备忘录进行管理，保存和提供备忘录。</li>
</ol>
<p>下面是它的通用源代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 发起人角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originate</span> </span>&#123;</div><div class="line">    <span class="comment">// 内部状态</span></div><div class="line">    <span class="keyword">private</span> String state = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String  <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.state = state;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 创建一个备忘录</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(<span class="keyword">this</span>.state);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 恢复一个备忘录</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Memento _memento)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.setState(_memento.getState());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 备忘录角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</div><div class="line">    <span class="comment">// 发起人内部状态</span></div><div class="line">    <span class="keyword">private</span> String state = <span class="string">""</span>;</div><div class="line">    <span class="comment">// 构造函数传递</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String _state)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.state = _state;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.state = state;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 备忘录管理者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span> </span>&#123;</div><div class="line">    <span class="comment">// 备忘录对象</span></div><div class="line">    <span class="keyword">private</span> Memento memento;</div><div class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> memento;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.memento = memento;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 定义发起人</span></div><div class="line">        Originator originator = <span class="keyword">new</span> Originator();</div><div class="line">        <span class="comment">// 定义出备忘录管理员</span></div><div class="line">        Caretaker caretaker = <span class="keyword">new</span> Caretaker();</div><div class="line">        <span class="comment">// 创建一个备忘录</span></div><div class="line">        caretaker.setMemento(originator.createMemento());</div><div class="line">        <span class="comment">// 恢复一个备忘录</span></div><div class="line">        originator.restoreMemento(caretaker.getMemento());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>需要保存和恢复数据的相关状态场景。</li>
<li>提供一个可回滚的操作。</li>
<li>需要监控的副本场景。</li>
<li>数据库连接的事务管理就是用的备忘录模式。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><p>备忘录的生命周期</p>
<p> 备忘录创建出来就要在“最近”的代码中使用，要主动管理它的生命周期，建立就要使用，不使用就要立刻删除其引用，等待垃圾回收器对它的回收处理。</p>
</li>
<li><p>备忘录性能</p>
<p> 不要在频繁建立备份的场景中使用备忘录模式，原因有而：一是控制不了备忘录建立的对象数量；二是大对象的建立是要消耗资源的，系统的性能需要考虑。</p>
</li>
</ol>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="clone方式的备忘录"><a href="#clone方式的备忘录" class="headerlink" title="clone方式的备忘录"></a>clone方式的备忘录</h2><p>发起人角色融入了发起人角色和备份路角色，利用clone()方法克隆出来的对象充当备忘录对象。但是由于存在深拷贝和浅拷贝的问题，在复杂的场景下它会让你的程序逻辑异常混乱，因此Clone方式的备忘录模式适用于比较简单的场景。</p>
<h2 id="多状态的备忘录模式"><a href="#多状态的备忘录模式" class="headerlink" title="多状态的备忘录模式"></a>多状态的备忘录模式</h2><p>将多个状态转换到HashMap中，方便备忘录角色存储。</p>
<h2 id="多备份的备忘录"><a href="#多备份的备忘录" class="headerlink" title="多备份的备忘录"></a>多备份的备忘录</h2><p>将备份的数据存入到HashMap中，并给每个不同的备份一个不同的key。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>大家主要的还是记住数据库的事务用的是备忘录模式就好了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引： &lt;strong&gt;备忘录模式&lt;/strong&gt;是我们设计上的“月光宝盒”，可以让我们回到需要的年代；是程序数据的“后悔药”，吃了它就可以返回上一个状态；是设计人员的定心丸，确保即使在最坏的情况下也能获得最近的对象状态。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——门面模式</title>
    <link href="http://bestlixiang.site/2018/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/13/设计模式之禅——门面模式/</id>
    <published>2018-03-13T02:18:20.000Z</published>
    <updated>2018-03-13T02:18:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：怎样保证“金玉其外，败絮其中”，<strong>门面模式</strong>可以达到你的要求！<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。——结构类</strong></p>
<p>门面模式注重<strong>统一的对象</strong>，也就是提供一个访问子系统的接口，除了这个接口不允许有任何访问子系统的行为发生，其通用类图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/facade.png" alt="facade"></p>
<p>下面简单介绍类图中的两个角色：</p>
<ol>
<li>Facade门面角色：客户端调用这个角色的方法，此角色知晓子系统的所有功能和责任。一般情况下，本角色会将所有从客户端发起的请求委派到相应的子系统去，也就是说该角色没有实际的业务逻辑，只是一个委托类。</li>
<li>Subsystem Classes子系统所有类角色：可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合，子系统不知道门面的存在。</li>
</ol>
<p>下面是它的通用源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 子系统</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingA</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassC</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingC</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 门面对象</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</div><div class="line">    <span class="comment">// 被委托的对象</span></div><div class="line">    <span class="keyword">private</span> ClassA a = <span class="keyword">new</span> ClassA();</div><div class="line">    <span class="keyword">private</span> ClassB b = <span class="keyword">new</span> ClassB();</div><div class="line">    <span class="keyword">private</span> ClassC c = <span class="keyword">new</span> ClassC();</div><div class="line">    <span class="comment">// 提供给外部访问的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.a.doSomethingA();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.b.doSomethingB();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.c.doSomethingC();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>减少系统的相互依赖。所有的依赖都是对门面对象的依赖，与子系统无关。</li>
<li>提供了灵活性。不管子系统内部如何变化，只要不影响到门面对象，任你自由活动。</li>
<li>提供安全性。想让你访问子系统的那些业务就开通那些逻辑，不在门面上开通的方法，你休想访问到。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>门面模式最大的缺点就是不符合开闭原则，没有对修改关闭，对扩展开放。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>为一个复杂的模块或子系统提供一个供外界访问的接口。</li>
<li>子系统相对独立——外界对子系统的访问只要黑箱操作即可。</li>
<li>预防低水平人员带来的风险扩散。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>一个系统可以有多个门面。比如下面的情况：<ul>
<li>门面已经庞大到不能忍受的程度</li>
<li>子系统可以提供不同访问路径</li>
</ul>
</li>
<li>门面不参与子系统内的业务逻辑。</li>
</ol>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>门面模式是一个很好的封装方法，很多情况都可以使用到，如下面的情况：</p>
<ol>
<li>一个子系统比较复杂，就可以封装出一个或多个门面，项目结构简单，扩展性非常好。</li>
<li>对于一个比较大的项目，为了避免人员带来的风险，也可以使用门面模式，技术水平差的成员，尽量安排独立的模块，然后把他写的程序封装到一个门面李，尽量让其他项目成员不用看到这些人的代码。看也看不懂，哈哈。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：怎样保证“金玉其外，败絮其中”，&lt;strong&gt;门面模式&lt;/strong&gt;可以达到你的要求！
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——观察者模式</title>
    <link href="http://bestlixiang.site/2018/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/12/设计模式之禅——观察者模式/</id>
    <published>2018-03-12T12:33:37.000Z</published>
    <updated>2018-03-12T12:34:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：被观察者做出动作了，然后通知观察者做出反应。<strong>观察者模式</strong>就是这么简单！<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>观察者模式又称发布订阅模式。</p>
<p><strong>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有它依赖的对象都会得到通知并被自动更新。行为类</strong></p>
<p>下面是它的通用类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/observer.png" alt="observer"></p>
<p>下面简单介绍一下类图中的几个角色：</p>
<ol>
<li>Subject被观察者：定义观察者必须实现的职责，它必须能够动态地增加、取消观察者。管理观察者并通知观察者。</li>
<li>Observer观察者：观察者接受到消息后，即进行update操作，对接收的信息进行处理。</li>
</ol>
<p>下面是它的通用源代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 被观察者</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义一个观察者数组</span></div><div class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; observerVector = <span class="keyword">new</span> Vector&lt;Observer&gt;();</div><div class="line">    <span class="comment">// 增加一个观察者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.observerVector.add(o);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 删除一个观察者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer <span class="number">0</span>)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.observerVector.remove(o);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 通知所有观察者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Observer o : <span class="keyword">this</span>.observerVector) &#123;</div><div class="line">            o.update();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体被观察者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="comment">// 具体的业务</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// do somthing</span></div><div class="line">        <span class="keyword">super</span>.notifyObservers();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 观察者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="comment">// 更新方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体观察者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="comment">// 实现更新方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updatea</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"接到消息，并进行处理"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 场景一个被观察者</span></div><div class="line">        ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject();</div><div class="line">        <span class="comment">// 定义一个观察者</span></div><div class="line">        Observer obs = <span class="keyword">new</span> ConcreteObserver();</div><div class="line">        <span class="comment">// 观察者观察被观察者</span></div><div class="line">        subject.addObserver(obs);</div><div class="line">        <span class="comment">// 观察者开始活动了</span></div><div class="line">        subject.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>观察者和被观察者之间是<strong>抽象耦合</strong>的，不管是增加观察者都非常容易扩展。</li>
<li>建立一套触发机制。容易在单一职责下构建一条触发链。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>观察者模式需要考虑一下开发效率和运行效率问题，一个被观察者，多个观察者，开发和调试就会比较复杂，而且在Java中消息的通知默认是顺序执行的，一个观察者卡壳，会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>关联行为场景。这种关联行为时可以拆分的。</li>
<li>事件多级触发场景。</li>
<li>跨系统的消息交换场景，如消息队列的处理机制。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>广播链。在一个观察者模式中最多出现一个对象既是观察者又是被观察者，也就是说消息最多被转发一次。（和责任链的区别在于广播链在消息传播过程中消息是可变的）</li>
<li>异步处理问题。如果观察者比较多，处理时间长，我们就需要用异步。异步处理需要考虑到线程安全和队列问题。</li>
</ol>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="Java世界中的观察者模式"><a href="#Java世界中的观察者模式" class="headerlink" title="Java世界中的观察者模式"></a>Java世界中的观察者模式</h2><p>在JDK中已经提供了java.util.Observable实现类（被观察者）以及java.util.Observer接口（观察者）。大家要记住在java的世界里横行时，多看看API，有很大的帮助，很多东西Java已经帮我们设计了一个良好的框架。</p>
<h2 id="项目中真实的观察者模式"><a href="#项目中真实的观察者模式" class="headerlink" title="项目中真实的观察者模式"></a>项目中真实的观察者模式</h2><p>在系统设计中会对观察者模式进行改造或改装，主要在以下3个方面：</p>
<ol>
<li><p>观察者和被观察者之间的消息沟通</p>
<p> 被观察者状态改变会触发观察者的一个行为，同时会传递一个消息给观察者，这是正确地，但是在实际中一般的做法是：观察者中update方法会接受两个参数，一个是被观察者，一个是DTO（数据传输对象），DTO一般是一个纯洁的JavaBean，由被观察者生成，由观察者消费。</p>
</li>
<li><p>观察者响应方式</p>
<p>为了解决观察者的快速响应有以下两个办法：</p>
<ul>
<li>采用多线程技术</li>
<li>缓存技术（同步架构）</li>
</ul>
</li>
<li><p>被观察者尽量自己做主</p>
<p>被观察者的状态改变不一定要通知观察者，所以doSomething方法可以被重载，增加一个doSomething(boolean isNotifyObs)方法，决定是否通知观察者，而不是在消息到达观察和才判断是否要消费。</p>
</li>
</ol>
<h2 id="订阅发布模型"><a href="#订阅发布模型" class="headerlink" title="订阅发布模型"></a>订阅发布模型</h2><p>顾名思义就是消息的发布者发布一个消息，然后利用消息队列通知订阅者做出反应。这相当于观察者模式的升级版。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>观察者模式在实际项目中和生活中非常常见，如下面的例子：</p>
<ol>
<li>文件系统：在一个目录下新建立一个文件，这个动作会同时通知目录管理器增加该目录。文件是一个被观察者，目录管理器是一个被观察者。</li>
<li>广播收音机：电台在广播，收音机在收听。电台是一个被观察者，收音机是一个被观察者。<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1></li>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：被观察者做出动作了，然后通知观察者做出反应。&lt;strong&gt;观察者模式&lt;/strong&gt;就是这么简单！
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——组合模式</title>
    <link href="http://bestlixiang.site/2018/03/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/10/设计模式之禅——组合模式/</id>
    <published>2018-03-10T01:46:05.000Z</published>
    <updated>2018-03-10T01:46:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：部分类可以组成整体类，然后拥有一个统一的接口，这就是<strong>组合模式</strong>。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。——结构类</strong></p>
<p>组合模式也叫合成模式，有时又叫做部分——整体模式，主要用来描述部分和整体的关系。下面是它的通用类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/composite.png" alt="composite"></p>
<p>接下来简单介绍类图的几个类：</p>
<ol>
<li>Component抽象构建角色：定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性。</li>
<li>Leaf叶子构件：叶子对象，其下再也没有其他的分支，遍历的最小单位。</li>
<li>Composite树枝构件：树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。</li>
</ol>
<p>下面是它的通用源代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象构建</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="comment">// 个体和整体都具有的共享</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 编写逻辑业务</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 树枝构件</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="comment">// 构件容器</span></div><div class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; componentArrayList = <span class="keyword">new</span> ArrayList&lt;Component&gt;();</div><div class="line">    <span class="comment">// 增加一个叶子构件或树枝构件</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.componentArrayList.add(component);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 删除一个叶子构件或树枝构件</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.componentArrayList.remove(component);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 获得分支下的所有叶子构件和树枝构件</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Component&gt; <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.componentArrayList;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 树叶节点</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 覆写父类方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 创建一个根节点</span></div><div class="line">        Composite root = <span class="keyword">new</span> Composite();</div><div class="line">        root.doSomething();</div><div class="line">        <span class="comment">// 创建一个树枝节点</span></div><div class="line">        Composite branch = <span class="keyword">new</span> Composite();</div><div class="line">        <span class="comment">// 创建一个叶子节点</span></div><div class="line">        Leaf leaf = <span class="keyword">new</span> Leaf();</div><div class="line">        <span class="comment">// 建立整体</span></div><div class="line">        root.add(branch);</div><div class="line">        branch.add(leaf);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 通过递归遍历树</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Composite root)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(Component c : root.getChildren()) &#123;</div><div class="line">            <span class="keyword">if</span> (c <span class="keyword">instanceof</span> Leaf) &#123;</div><div class="line">                c.doSomething();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                display((Composite) c);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以从场景类看出组合模式破坏了依赖倒转原则，树枝和树叶直接使用了实现类。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>高层模块调用节点，一棵树机构中的所有节点都是Component。</li>
<li>节点自由增加，容易扩展，符合开闭原则。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>与依赖倒置原则冲突，限制了接口的影响范围。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>维护和展示部分-整体关系的场景，如树形菜单，文件和文件夹管理。</li>
<li>从一个整体能够独立出部分模块或功能的场景。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>只要是树形结构或者体现局部和整体的关系的时候，要考虑组合模式。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>组合模式在项目中到处都有，比如页面结构，XML结构等等。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：部分类可以组成整体类，然后拥有一个统一的接口，这就是&lt;strong&gt;组合模式&lt;/strong&gt;。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——迭代器模式</title>
    <link href="http://bestlixiang.site/2018/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/08/设计模式之禅——迭代器模式/</id>
    <published>2018-03-08T07:45:50.000Z</published>
    <updated>2018-03-08T07:46:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：提起迭代器，大家一定能想到Java的Iterator，不错，我们这次讲的迭代器模式就是目前大部分语言都已经实现的迭代器。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>它提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。——创造类</strong></p>
<p>迭代器是为容器服务的，能容纳对象的所有类型都可以称为容器。迭代器模式提供了遍历 容器的方便性，容器主要管理增减元素就可以了，需要遍历时交由迭代器进行。目前基本上不会单独写一个迭代器。下面是它的通用类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/iterator.png" alt="iterator"></p>
<p>下面简单介绍类图中的几个角色：</p>
<ol>
<li>Iterator抽象迭代器：抽象迭代器负责定义访问和遍历元素的接口。</li>
<li>ConcreteIterator具体迭代器：实现迭代器接口，完成容器元素的遍历。</li>
<li>Aggregate抽象容器：容器角色负责提供创建具体迭代器角色的的接口，必然提供一个类似createIterator()这样的方法，在Java中一般是iterator()方法。</li>
<li>ConcreteAggregate具体容器：实现容器接口定义的方法，创建出容纳迭代器的对象。</li>
</ol>
<p>下面是迭代器模式的通用源代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象迭代器</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</div><div class="line">    <span class="comment">// 遍历到下一个元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 是否已经遍历到尾部</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 删除当前指向的元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体迭代器</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Vector vector = <span class="keyword">new</span> Vector();</div><div class="line">    <span class="comment">// 定义当前游标</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cursor = <span class="number">0</span>;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"checked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(Vector _vector)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.vector = _vector;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 判断是否到达尾部</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.cursor == <span class="keyword">this</span>.vector.size()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 返回下一个元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        Object result = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasNext()) &#123;</div><div class="line">            result = <span class="keyword">this</span>.vector.get(<span class="keyword">this</span>.cursor++);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            result = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 删除当前元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.vector.remove(<span class="keyword">this</span>.cursor);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象容器</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</div><div class="line">    <span class="comment">// 是容器必然有元素的增加</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object object)</span></span>;</div><div class="line">    <span class="comment">// 减少元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object object)</span></span>;</div><div class="line">    <span class="comment">// 由迭代器来遍历所有的元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体容器</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</div><div class="line">    <span class="comment">// 容纳对象的容器</span></div><div class="line">    <span class="keyword">private</span> Vector vector = <span class="keyword">new</span> Vector();</div><div class="line">    <span class="comment">// 增加一个元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object object)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.vector.add(object);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 返回迭代器对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(<span class="keyword">this</span>.vector);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 删除一个元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object object)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.remove(object);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 声明容器</span></div><div class="line">        Aggregate agg = <span class="keyword">new</span> ConcreteAggregate();</div><div class="line">        <span class="comment">// 产生对象数据放进去</span></div><div class="line">        agg.add(<span class="string">"abc"</span>);</div><div class="line">        agg.add(<span class="string">"aaa"</span>);</div><div class="line">        agg.add(<span class="string">"1234"</span>);</div><div class="line">        <span class="comment">// 遍历一下</span></div><div class="line">        Iterator iterator = agg.iterator();</div><div class="line">        <span class="keyword">while</span>(Iterator.hasNext()) &#123;</div><div class="line">            System.out.println(iterator.next());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>只要不是在使用那些古董级的编程语言，都不用自己动手写迭代器。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>如果你是做Java开发，尽量不要自己写迭代器模式。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：提起迭代器，大家一定能想到Java的Iterator，不错，我们这次讲的迭代器模式就是目前大部分语言都已经实现的迭代器。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——适配器模式</title>
    <link href="http://bestlixiang.site/2018/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/08/设计模式之禅——适配器模式/</id>
    <published>2018-03-08T05:35:56.000Z</published>
    <updated>2018-03-08T07:46:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：<strong>适配器模式</strong>在生活中非常常见，比如你的笔记本上的电源适配器，通过它笔记本可以使用在110~220V之间变化的电源，而笔记本还可以正常工作。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>将一个类的接口变换成客户端期待的另一种接口，从而使原本因接口不匹配而无法再一起工作的两个类能够在一起工作。——结构类</strong></p>
<p>下面是它的通用类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/adapter.png" alt="adapter"></p>
<p>下面简单介绍类图中的几个类：</p>
<ol>
<li>Target目标角色：该角色定义吧其他类转化为何种接口，也就是我们期望的接口。</li>
<li>Adaptee源角色：需要转化的角色，通过适配器角色的包装可以成为一个新角色。</li>
<li>Adapter适配器角色：它的职责就是通过继承或者类关联的方式把源角色转化为目标角色。</li>
</ol>
<p>下面是他的通过源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 目标角色</span></div><div class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="comment">// 目标角色有自己的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 目标角色的实现类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteTarget</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"if you need any help,please call me!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 源角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</div><div class="line">    <span class="comment">// 原有的业务逻辑</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"I`m kind of busy,leave me alone,please!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 适配器橘色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 原有的业务逻辑</span></div><div class="line">        Target target = <span class="keyword">new</span> ConcreteTarget();</div><div class="line">        target.request();</div><div class="line">        <span class="comment">// 现在增加了适配器角色的业务逻辑</span></div><div class="line">        Target target2 = <span class="keyword">new</span> Adapter();</div><div class="line">        target2.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>适配器模式可以让两个没有任何关系的类一起运行</li>
<li>提高了类的透明性，源角色对于高层模块是透明的</li>
<li>提高了类的复用度，源角色在原系统中还是可以正常使用的</li>
<li>灵活性非常好，不需要适配器的时候删除掉这个适配器即可</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当你有动机修改一个已经投产中的接口时，适配器可能是最适合的你模式。比如系统扩展了，需要使用一个已有或新建立的类，当这个类又不符合系统的接口，那么就可以使用适配器模式。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>适配器模式最好在详细设计阶段不要考虑它，它不是为解决还处在开发阶段的问题，而是解决正在服役的项目问题。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>适配器模式是一个补救模式，通常用来解决接口不相容的问题。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：&lt;strong&gt;适配器模式&lt;/strong&gt;在生活中非常常见，比如你的笔记本上的电源适配器，通过它笔记本可以使用在110~220V之间变化的电源，而笔记本还可以正常工作。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——策略模式</title>
    <link href="http://bestlixiang.site/2018/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/07/设计模式之禅——策略模式/</id>
    <published>2018-03-07T09:19:02.000Z</published>
    <updated>2018-03-07T09:19:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：将所有方法封装起来，要用什么方法就打开什么方法，这就是<strong>策略模式</strong>。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。——行为类</strong></p>
<p>我们先看它的类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/strategy.png" alt="strategy"></p>
<p>简单介绍类图中的几个类：</p>
<ol>
<li>Context封装角色，也叫上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问。</li>
<li>Strategy抽象策略角色，定义每个策略或算法必须具有的方法和属性。</li>
<li>ConcreteStrategy具体策略角色，实现抽象策略的操作，该类含有具体的算法。</li>
</ol>
<p>下面是它的通用源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象的策略角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="comment">// 策略模式的运算法则</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体角色类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy1</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"具体策略1的运算法则"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy2</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"具体策略2的运算法则"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 封装角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</div><div class="line">    <span class="comment">// 抽象策略</span></div><div class="line">    <span class="keyword">private</span> Strategy strategy = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 构造函数设置具体策略</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy _strategy)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.strategy = _strategy;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 封装后的策略方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAngthing</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.strategy.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 声明一个具体的策略</span></div><div class="line">        Strategy strategy = <span class="keyword">new</span> ConcreteStrategy1();</div><div class="line">        <span class="comment">// 声明上下文对象</span></div><div class="line">        Context context = <span class="keyword">new</span> Context(strategy);</div><div class="line">        <span class="comment">// 执行封装后的方法</span></div><div class="line">        context.doAngthing();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>策略模式实质是采用了面向对象的继承和<strong>多态机制</strong>。但是一个类实现多个接口很正常，所以识别出抽象策略接口是系统分析师的价值所在。策略模式和代理模式的区别是策略模式的封装角色和被封装的策略类不用是同一个接口。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>算法可以自由切换</li>
<li>避免使用多重条件判断</li>
<li>扩展性良好</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>策略类数量增多，复用可能性小</li>
<li>所有策略类都需要对外暴露，上层模块需要知道有哪些策略，违背了迪米特法则</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>多个类只有在算法或行为上稍有不同的场景</li>
<li>算法需要自由切换的场景</li>
<li>需要屏蔽算法规则的场景</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果系统中的一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀和对外暴露问题。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>策略模式在项目中会经常使用，但是它具有一个致命缺陷：所有的策略都需要暴露出去。在实际项目中，我们一般通过工厂方法模式来实现策略类的声明。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：将所有方法封装起来，要用什么方法就打开什么方法，这就是&lt;strong&gt;策略模式&lt;/strong&gt;。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
