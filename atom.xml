<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rex note</title>
  <subtitle>雨过，云过</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bestlixiang.site/"/>
  <updated>2018-03-21T05:49:52.000Z</updated>
  <id>http://bestlixiang.site/</id>
  
  <author>
    <name>rex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux私房菜_Linux磁盘分区</title>
    <link href="http://bestlixiang.site/2018/03/21/Linux%E7%A7%81%E6%88%BF%E8%8F%9C-Linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"/>
    <id>http://bestlixiang.site/2018/03/21/Linux私房菜-Linux磁盘分区/</id>
    <published>2018-03-21T05:49:21.000Z</published>
    <updated>2018-03-21T05:49:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：Linux在我印象中最大的特点就是它把所有的硬件都当做一个文件，然后还是以/为根节点的目录树，简洁明了，相信大家一定会爱上它的。因为涉及到文件的存储，所以我们要重视磁盘分区。<a id="more"></a></p>
<h1 id="硬件设备在linux中的文件名"><a href="#硬件设备在linux中的文件名" class="headerlink" title="硬件设备在linux中的文件名"></a>硬件设备在linux中的文件名</h1><p>Linux中每一个设备都被当成文件，所有的设备文件都在/dev这个目录下。下面列出几个常见设备与其在Linux当中的文件名，如下表：</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>设备在Linux内的文件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE硬盘</td>
<td>/dev/hd[a-d]</td>
</tr>
<tr>
<td>SATA/USB/SCSI硬盘</td>
<td>/dev/sd[a-p]</td>
</tr>
<tr>
<td>U盘</td>
<td>/dev/sd[a-p]（与SATA相同）</td>
</tr>
<tr>
<td>软驱</td>
<td>/dev/fd[0－1]</td>
</tr>
<tr>
<td>打印机</td>
<td>25针：/dev/lp[0－2] usb：/dev/usb/lp[0-15]</td>
</tr>
<tr>
<td>鼠标</td>
<td>usb:/dev/usb/mouse[0－15] ps2:/dev/psaux</td>
</tr>
<tr>
<td>当前CD/DVD ROM</td>
<td>/dev/cdrom</td>
</tr>
<tr>
<td>当前鼠标</td>
<td>/dev/mouse</td>
</tr>
<tr>
<td>磁带机</td>
<td>IDE:/dev/ht0 SCSI:/dev/st0</td>
</tr>
</tbody>
</table>
<h1 id="硬盘分区"><a href="#硬盘分区" class="headerlink" title="硬盘分区"></a>硬盘分区</h1><h2 id="磁盘的文件命名规则"><a href="#磁盘的文件命名规则" class="headerlink" title="磁盘的文件命名规则"></a>磁盘的文件命名规则</h2><p>磁盘的接口有两种，分别是IDE接口、SATA接口。目前主流的接口是SATA接口。<br>使用IDE接口的设备我们称为IDE设备。</p>
<ol>
<li>IDE设备：一个IDE接口可以连接两个IDE设备，主机中一般用两个IDE接口，因此最多可以连接四个IDE设备。这两个IDE接口通常被称为IDE1、IDE2，而每个IDE接口连接的两个IDE设备又被分为主设备和从设备。这四个IDE设备的文件名如下表：</li>
</ol>
<table>
<thead>
<tr>
<th>IDE接口</th>
<th>主设备</th>
<th>从设备</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE1</td>
<td>/dev/hda</td>
<td>/dev/hdb</td>
</tr>
<tr>
<td>IDE2</td>
<td>/dev/hdc</td>
<td>/dev/hdd</td>
</tr>
</tbody>
</table>
<ol>
<li>SATA设备：以SATA/USB/SCSI为接口的磁盘使用的都是SCSI模块来驱动的，因此他们的设备文件名都是/dev/sd[a-p]。但是与IDE设备不同的是，他们的文件名没有一定的顺序，谁先插上去，谁就是a，以此类推。</li>
</ol>
<h2 id="磁盘的组成"><a href="#磁盘的组成" class="headerlink" title="磁盘的组成"></a>磁盘的组成</h2><p>整个磁盘的第一个扇区非常重要，因为他记录了下面的重要的信息：</p>
<ol>
<li>主引导分区Master Boot Record,MBR：可以安装“引导加载程序”的地方。有446bytes。</li>
<li>分区表：记录整块硬盘的分区状况，有64bytes。</li>
</ol>
<h2 id="磁盘分区表"><a href="#磁盘分区表" class="headerlink" title="磁盘分区表"></a>磁盘分区表</h2><p>对磁盘进行分区时，采用柱面作为基本单位。分区表有64bytes，被分成四个区域，每个区域记录当前磁盘的所有分区的起始和结束柱面号。例如：一块IDE硬盘被分成四个区域： P1：/dev/hda1 ，P2：/dev/hda2 ，P3：/dev/hda3 ，P4：/dev/hda4。每个磁盘的分区表只能被分成四个区域，这四个区域被称为<strong>主分区或扩展分区</strong>。当系统进行数据的读写时，一定要参考分区表才能进行。</p>
<h3 id="分区的原因"><a href="#分区的原因" class="headerlink" title="分区的原因"></a>分区的原因</h3><p>保证数据的安全性（分区不会影响）；提升系统的性能（只在自己的分区查找）。</p>
<h3 id="扩展分区"><a href="#扩展分区" class="headerlink" title="扩展分区"></a>扩展分区</h3><p>主分区和扩展分区都是分区表中的一条记录，主分区中存放通过直接索引就能到达的分区的开始和结束的柱面号；而扩展分区中存放的是逻辑分区表的开始和结束柱面号，这张逻辑分区表中才存放分区的开始和结束柱面号。</p>
<p>由于一张分区表只能存放四条记录，也就是四个分区，当我们想要多一些分区的时候就必须要通过扩展分区来实现。 分区表中的四条记录对应的设备文件名是不会变的。如上面的四个名字，所以逻辑分区的文件名一定是从5开始的。如：/dev/hda5。</p>
<h3 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h3><ol>
<li>扩展分区最多只能有1个。</li>
<li>Linux中，IDE硬盘最多有59个逻辑分区，5号－63号；SATA硬盘最多有11个逻辑分区，5号－15号。</li>
<li>在Windows中若D、E盘都是扩展分区中的逻辑分区，那么他们可以整合成一个分区；若两个盘一个是逻辑分区，一个是主分区，那他们是不能合并的。</li>
<li>一块硬盘的第一个扇区记录了MBR和分区表，非常的重要，如果第一个扇区坏了，那么整个硬盘就报废了。</li>
</ol>
<h1 id="开机流程"><a href="#开机流程" class="headerlink" title="开机流程"></a>开机流程</h1><p>整个开机流程到操作系统之前的动作应该是这样的：</p>
<ol>
<li>BIOS：开机主动执行的韧体，会认识第一个可开机的对象。</li>
<li>MBR：第一个可开机设备的第一个扇区的主引导分区块，内包含引导加载程序。</li>
<li>引导加载程序：一支可读取内核文件来执行的软件。（可多个不同系统的加载程序对应了不同的操作系统）</li>
<li>内核文件：开始操作系统的功能。</li>
</ol>
<p>PS：为什么如果安装多重引导，最好先安装Windows在安装Linux？——因为Linux在安装的时候可以选择将引导加载程序安装在MBR或个别分区的启动扇区，而且在linnux的loader可以手动设置菜单，所以你可以在Linux的boot loader里面加入Windows开机的选项。Windows在安装的时候，它的安装程序会主动覆盖掉MBR以及自己所在分区的启动扇区，你没有选择的机会，而且没有让我们选择菜单的功能。</p>
<h1 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h1><h2 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h2><p>在Linux中，整个文件系统呈一棵以/为根目录的树。</p>
<h2 id="文件系统与目录树的关系（挂载）"><a href="#文件系统与目录树的关系（挂载）" class="headerlink" title="文件系统与目录树的关系（挂载）"></a>文件系统与目录树的关系（挂载）</h2><p><strong>挂载</strong>就是把一个目录当作磁盘中某一个分区的进入点，也就是说，进入了这个目录，就进入了这个磁盘的这个分区。这个进入的目录我们就称为挂载点。<br>根目录一定要挂载到某个分区。</p>
<p>如何寻找挂载点（判断某个在文件在哪个分区下）？答：通过反向追踪即可，当我们想要知道/home/rex/test文件在那个分区时，只要逆向寻找第一个挂载点就是这个文件的挂载点。 可以使用下面的命令：</p>
<blockquote>
<p>df /home/rex/test</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>了解分区，了解开机流程，了解挂载，ok，就这些！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：Linux在我印象中最大的特点就是它把所有的硬件都当做一个文件，然后还是以/为根节点的目录树，简洁明了，相信大家一定会爱上它的。因为涉及到文件的存储，所以我们要重视磁盘分区。
    
    </summary>
    
      <category term="Linux私房菜" scheme="http://bestlixiang.site/categories/Linux%E7%A7%81%E6%88%BF%E8%8F%9C/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux私房菜_Linux基础学习</title>
    <link href="http://bestlixiang.site/2018/03/20/Linux%E7%A7%81%E6%88%BF%E8%8F%9C-Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://bestlixiang.site/2018/03/20/Linux私房菜-Linux基础学习/</id>
    <published>2018-03-20T12:13:05.000Z</published>
    <updated>2018-03-20T12:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：了解Linux，学习Linux，深入Linux。<a id="more"></a></p>
<h1 id="Linux是什么"><a href="#Linux是什么" class="headerlink" title="Linux是什么"></a>Linux是什么</h1><p><strong>Linux就是一套操作系统，它的内核是Linux Torvalds在1991年开发出来的。</strong></p>
<h2 id="Linux的内核版本"><a href="#Linux的内核版本" class="headerlink" title="Linux的内核版本"></a>Linux的内核版本</h2><p>看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2.6.18-92.e15</div><div class="line">主版本.次版本.释出版本-修改版本</div></pre></td></tr></table></figure></p>
<ol>
<li>主、次版本为奇数：开发中版本，如2.5.xx，这种版本仅内核开发工程师使用。</li>
<li>主、次版本为偶数：稳定版本，如2.6.xx ，家庭、企业使用。</li>
</ol>
<p>我们可以通过下面的命令查看自己的linux的版本号：</p>
<pre><code>uname -r
</code></pre><h2 id="Linux发行版"><a href="#Linux发行版" class="headerlink" title="Linux发行版"></a>Linux发行版</h2><p>Linux其实就是Linux Kernel（内核）＋内核工具。他是GNU GPL授权模式，任何人都可以获取源代码并进行修改。因此Linux的全名是：GNU/Linux。<br>Linux ditribution是由各个商业公司开发，本质上是LinuxKernel＋内核工具＋软件，让普通用户都能使用的操作系统。 基本上Linux distributions并无太大区别，可以根据自己的喜好选择。他们的内核都是从www.kernel.org上下载的。</p>
<h2 id="Linux的特色"><a href="#Linux的特色" class="headerlink" title="Linux的特色"></a>Linux的特色</h2><ol>
<li>自由与开放的使用与学习环境</li>
<li>配置需求低廉</li>
<li>内核功能强大而稳定</li>
<li>独立作业</li>
</ol>
<h2 id="Linux优点"><a href="#Linux优点" class="headerlink" title="Linux优点"></a>Linux优点</h2><ol>
<li>稳定的系统</li>
<li>免费或少许费用</li>
<li>安全性、漏洞的快速修补</li>
<li>多任务、多用户</li>
<li>用户与用户组的规划</li>
<li>相对比较不耗资源的系统</li>
<li>整合度佳且多样的图形用户界面</li>
</ol>
<h2 id="Linux缺点"><a href="#Linux缺点" class="headerlink" title="Linux缺点"></a>Linux缺点</h2><ol>
<li>没有特定的支持产商</li>
<li>游戏的支持度不足</li>
<li>专业软件的支持度不足</li>
</ol>
<h1 id="Linux当前的角色"><a href="#Linux当前的角色" class="headerlink" title="Linux当前的角色"></a>Linux当前的角色</h1><h2 id="企业环境的应用"><a href="#企业环境的应用" class="headerlink" title="企业环境的应用"></a>企业环境的应用</h2><ol>
<li>网络服务器（当今最热门的运用）</li>
<li>关键任务的应用（金融数据库、大型企业）</li>
<li>学术机构的高性能运算任务</li>
</ol>
<h2 id="个人环境的使用"><a href="#个人环境的使用" class="headerlink" title="个人环境的使用"></a>个人环境的使用</h2><ol>
<li>桌面计算机(在Linux系统上装一个X Window System软件之后，就能有桌面了)</li>
<li>手持设备（PAD、手机）</li>
<li>嵌入式系统</li>
</ol>
<h1 id="Linux的学习路线"><a href="#Linux的学习路线" class="headerlink" title="Linux的学习路线"></a>Linux的学习路线</h1><ol>
<li>学习计算机概论及硬件相关知识</li>
<li>从Linux的安装开始学起</li>
<li>学会使用Linux的基本技能</li>
<li>学会vi编辑器</li>
<li>shell与shell脚本的学习</li>
<li>一定要会软件管理员</li>
<li>了解网络基础</li>
<li>使用Linux架设网站</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在使用Linux之前请学会Linux！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：了解Linux，学习Linux，深入Linux。
    
    </summary>
    
      <category term="Linux私房菜" scheme="http://bestlixiang.site/categories/Linux%E7%A7%81%E6%88%BF%E8%8F%9C/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux私房菜_计算机基础</title>
    <link href="http://bestlixiang.site/2018/03/20/Linux%E7%A7%81%E6%88%BF%E8%8F%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://bestlixiang.site/2018/03/20/Linux私房菜-计算机基础/</id>
    <published>2018-03-20T10:29:00.000Z</published>
    <updated>2018-03-20T10:38:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：我也算是从通信专业转到计算机的，所以当然对计算机专业课知识不太了解，所以也想简单掌握以下计算机基础知识。<a id="more"></a></p>
<p>计算机其实是：<strong>接收用户输入指令和数据，经过中央处理器的数据欲逻辑单元运算处理后，以产生或存储成有用的信息。</strong></p>
<h1 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h1><h2 id="计算机硬件的五大单元"><a href="#计算机硬件的五大单元" class="headerlink" title="计算机硬件的五大单元"></a>计算机硬件的五大单元</h2><ol>
<li>输入单元</li>
<li>输出单元</li>
<li>CPU内部的控制单元</li>
<li>CPU内部的算术逻辑单元</li>
<li>内存</li>
</ol>
<h2 id="CPU的种类"><a href="#CPU的种类" class="headerlink" title="CPU的种类"></a>CPU的种类</h2><p>CPU内部已经含有一些小指令集，我们所使用的软件都要经过CPU内部的微指令集来完成才行。这些指令集的设计主要被分为两种设计理念，如下：</p>
<ol>
<li><p>精简指令集（RISC）</p>
<p> 采用精简指令集的cpu的指令较为精简，每条指令的执行时间很短，完成的操作也很单纯，指令的执行性能较好；但是如果要做一些复杂的操作，则需要多个指令来协同完成。</p>
<p> 常见的精简指令集CPU有：</p>
<ul>
<li>sun公司的SPARC系列，常应用于学术领域的大型工作站</li>
<li>IBM公司的Power Architecture（包括Power PC），如索尼的PS3</li>
<li>IBM公司的ARM系列，常用于手机、pda、导航系统、网络设备等 （使用最广泛）</li>
</ul>
</li>
<li><p>复杂指令集（CISC）</p>
<p> 每一条指令较为复杂，因为执行的时间比较长，但是每条指令处理的工作较为丰富。</p>
<p> 常见的复杂指令集的CPU：AMD、Intel、VIA等x86架构的cpu。由于这些采用了复杂指令集的x86架构的cpu常常被用在个人计算机上，所以个人计算机常常就被称为x86计算机。x86架构的CPU最早由因特尔开发，并且它将CPU从8位提升为16位、32位。后来，AMD公司基于x86架构开发出了64位的CPU。所以64位CPUu的架构叫做x86_64，非64位cpu的架构仍然叫做x86。</p>
</li>
</ol>
<h2 id="接口设备"><a href="#接口设备" class="headerlink" title="接口设备"></a>接口设备</h2><ol>
<li>存储设备：包括硬盘，软盘等</li>
<li>显示设备：显卡等</li>
<li>网络设备：网卡等</li>
</ol>
<h2 id="计算机分类"><a href="#计算机分类" class="headerlink" title="计算机分类"></a>计算机分类</h2><ol>
<li>超级计算机：运算速度最快的计算机，主要是用于需要有高速计算的项目中。</li>
<li>大型计算机：功能上不及超级计算机，但也可以用来处理大量数据与复杂计算。</li>
<li>迷你计算机：主机可以放在一般场所，无需像大型计算机一样需要特殊的空调场所。</li>
<li>工作站：工作站的价格比迷你计算机便宜许多，。是针对特殊用途而设计的计算机。</li>
<li>微电脑：个人计算机（PC）。</li>
</ol>
<h2 id="计算机上面的常用的计算单位（大小、速度等）"><a href="#计算机上面的常用的计算单位（大小、速度等）" class="headerlink" title="计算机上面的常用的计算单位（大小、速度等）"></a>计算机上面的常用的计算单位（大小、速度等）</h2><ol>
<li>文件大小：1GB=1024*1024*1024Byte；1Byte=8bit</li>
<li>CPU运算速度：MHz或者GHz，Hz为秒分之一</li>
<li>网络传输：Mbit/s或者MB/s，注意bit还是Byte</li>
</ol>
<h1 id="个人计算机架构与接口设备"><a href="#个人计算机架构与接口设备" class="headerlink" title="个人计算机架构与接口设备"></a>个人计算机架构与接口设备</h1><p>在计算机主板上的芯片组通常又分为两个桥接器来控制各组件的通信：</p>
<ul>
<li>北桥负责连接速度较快的CPU、内存与显卡等组件。北桥的总线称为系统总线。因为是内存传输的主要通道，所以速度快。</li>
<li>南桥负责链接速度较慢的周边接口，包括硬盘、USB、网卡等。南桥的总线称为输入输出(I/O)总线。</li>
</ul>
<p>AMD和Intel的芯片组架构最主要的区别是AMD的内存是直接与CPU通信而不通过北桥。</p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="外频与内屏"><a href="#外频与内屏" class="headerlink" title="外频与内屏"></a>外频与内屏</h3><ol>
<li>外频：CPU与外部组件进行数据传输/运算时的速度。</li>
<li>倍频：CPU内部用来加速工作性能的一个倍速，两者相乘才是cpu 的频率。</li>
</ol>
<h3 id="32位与64位"><a href="#32位与64位" class="headerlink" title="32位与64位"></a>32位与64位</h3><ol>
<li>北桥所支持的频率称为前端总线速（FSB）度，而每次传送的位数则是总线宽度，所谓总线频宽则是“FSB*总线宽度”，业技术每秒钟可以传送的最大数据量。</li>
<li>CPU每次能处理的数据量称为字组大小(word size)，字组大小依据cpu的设计有32／64位。我们现在称计算机是32／64位是根据CPU解析的字组大小来的。</li>
</ol>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>我们平时所说的内存的全名叫做动态随机访问存储器（DRAM）。DRAM是一种挥发性内存，只有它通电的时候才能被使用，断电数据就消失。DRAM分为：</p>
<ol>
<li>SDRAM</li>
<li>DDR SDRAM，DDR=Double Data Rate 所以他的传输速度比SDRAM要快。</li>
</ol>
<p>对服务器而言，内存的容量比CPU的速度更加重要。CPU与内存的外频应该相同才好。</p>
<h3 id="双通道设计"><a href="#双通道设计" class="headerlink" title="双通道设计"></a>双通道设计</h3><p>总线宽度一般是64位，也就是每次总线从内存中读写64位数据，若在主板上插两根内存条，那么总线宽度就达到128位，从而提升了内存的读写速度。在主板上插两根内存条的设计就叫做双通道设计。<br>但是要启动双通道功能，安插的两根内存条必须型号一样，大小一样，这样才能整体上提升内存的读写速度。</p>
<h3 id="DRAM与SRAM"><a href="#DRAM与SRAM" class="headerlink" title="DRAM与SRAM"></a>DRAM与SRAM</h3><p>DRAM就是我们平时所说的内存，它的全称叫做动态随机访问存储器。而SRAM的全程叫做静态随机访问存储器。SRAM可以用在很多不同的地方，而CPU中的第二层高速缓存就是选择SRAM作为存储器。由于L2 Cache集成在CPU内部，CPU读取数据无需再经过北桥从内存中获取，直接从L2 Cache中获取，从而能提升性能。</p>
<h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><p>显卡又叫做VGA（Video Graphics Array）。图形影响的显示质量的好坏重点在于分辨率和色彩深度。<br>由于显示的每一个像素都会占用内存，因此显卡上面也有个存储器，而这个存储器的大小直接影响显示的效果。早期时候3D的运算是交给CPU去处理的，为了减少CPU的负担，所以在显卡上设置一个处理器，这个处理器就是GPU。</p>
<p>PS: 如果你的主机是用来打3D游戏，那么显卡的选购非常重要，如果你的主机是用来作为网络服务器，那么简单的入门级显卡对你的主机来说就非常够用了。</p>
<h2 id="硬盘与存储设备"><a href="#硬盘与存储设备" class="headerlink" title="硬盘与存储设备"></a>硬盘与存储设备</h2><p>计算机系统上的存储设备包括硬盘、软盘、U盘等，我们主要介绍硬盘：</p>
<ol>
<li>硬盘主要是由许多的盘片、机械手臂、磁头与主轴马达所组成。实际的数据都是写在具有磁性物质的盘片上，硬盘运行时，主轴马达让盘片转动，机械手臂可以伸缩，让读取头在盘片上面进行读写操作。</li>
<li>硬盘的最小存储单位是扇区，每个扇区的大小是512bytes，这个值是不可改变的。扇区组成的环叫做磁道。上下的所有磁道构成柱面。柱面是分割硬盘的最小单位。一般硬盘制造商杂显示硬盘容量时，大多是以十进制来编号，所有500GB的硬盘，理论上仅会有460GB左右的容量。</li>
<li>传输接口主要有以下几种：<ul>
<li>IDE接口：每秒传输可达133MB。</li>
<li>SATA接口：SATA－1每秒传输150MB，SATA－2每秒传输300MB，目前个人计算机都已使用SATA。</li>
<li>SCSI接口：这个接口含有一个处理器，硬盘的读写操作由这个处理器完成，从而提升计算机整体性能。</li>
</ul>
</li>
</ol>
<p>PS：硬盘很脆弱，千万别让它摔了还是怎样，血的教训。</p>
<h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><p>主板可以说是整台主机相当重要的地方，因为重要的组件都是安插在主板上面的，而主板上面负责通信各个组件的就是芯片组。下面说说主板我们常用的东西：</p>
<ol>
<li>CMOS与BIOS：CMOS主要的功能是记录主板上面的重要参数，如系统时间等。BIOS为写入到主板上某一块闪存或EEPROM的程序，它可以在开机的时候执行，已加载CMOS当中的参数，并尝试调用存储设备中的开机程序，进一步进入操作系统当中。</li>
<li>连接接口设备：主板与各项输出/输入设备的链接主要都是在主机箱的后方，如USB接口RJ-45接口等。</li>
</ol>
<h1 id="计算机编码"><a href="#计算机编码" class="headerlink" title="计算机编码"></a>计算机编码</h1><ol>
<li>常用的英文编码表是ASKII，每个字符占1B，因此总共有2的8次方种变化。</li>
<li>中文编码表常用gb2312，每个字符占2B，定义了一万三千多个字。但是，这个编码表对于数据库存储有问题，从数据库读出数据的时候有些字会被读错。</li>
<li>为了解决上面的问题，出现了Unicode编码表，就是UTF-8。</li>
</ol>
<h1 id="软件程序运行"><a href="#软件程序运行" class="headerlink" title="软件程序运行"></a>软件程序运行</h1><p>一般来说目前的计算机系统将软件分为两大类：一是系统软件（内核），一个是应用程序（日常所说的软件）。</p>
<h2 id="机器程序与编译程序"><a href="#机器程序与编译程序" class="headerlink" title="机器程序与编译程序"></a>机器程序与编译程序</h2><ol>
<li>机器程序：都是机器码，可以直接给机器识别。</li>
<li>编译程序：能够将高级语言编译成机器程序。</li>
</ol>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>先看看操作系统的角色，从底层到高层：硬件-&gt;内核-&gt;系统调用-&gt;应用程序。其中内核以及系统调用被称为操作系统。</p>
<ol>
<li>操作系统内核：操作系统其实也是一组程序，这组程序的重点在于管理计算机的所有活动以及驱动系统的所有硬件。</li>
<li>系统调用：操作系统提供的一组开发接口。</li>
<li>内核功能：<ul>
<li>系统调用接口</li>
<li>程序管理</li>
<li>内存管理</li>
<li>文件系统管理</li>
<li>设备驱动</li>
</ul>
</li>
<li>操作系统与驱动程序：操作系统通常会提供一个开发接口给硬件商，让他们可以根据这个接口色合计可以驱动他们硬件的驱动程序。</li>
</ol>
<h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><p>应用程序是参考操作系统提供的开发接口所开发出来的软件，这些软件可以让用户操作，以达到某些计算机的功能利用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>了解好计算机的基础知道，我们对计算机里面的硬件以及程序的实现有了一个大概的了解，有利于我们学习下面的知识。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：我也算是从通信专业转到计算机的，所以当然对计算机专业课知识不太了解，所以也想简单掌握以下计算机基础知识。
    
    </summary>
    
      <category term="Linux私房菜" scheme="http://bestlixiang.site/categories/Linux%E7%A7%81%E6%88%BF%E8%8F%9C/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——桥梁模式</title>
    <link href="http://bestlixiang.site/2018/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/19/设计模式之禅——桥梁模式/</id>
    <published>2018-03-19T01:32:24.000Z</published>
    <updated>2018-03-19T01:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：不变的部分用继承来实现，变得部分放在外部，并通过<strong>桥梁模式</strong>抽象耦合进来，这样就解决了继承的弊端。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>桥梁模式也叫做桥接模式，其定义如下：</p>
<p><strong>将抽象和实现解耦，使得两者可以独立变化。——结构类</strong></p>
<p>下面是桥梁模式的通用类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/bridge.png" alt="bridge"></p>
<p>我们看看桥梁模式类图中的4个角色：</p>
<ol>
<li>Abstraction抽象化角色：主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。</li>
<li>Implementor实现化角色：定义角色必须的行为和属性。</li>
<li>RefinedAbstraction修正抽象化角色：它引用实现化角色对抽象化角色进行修正。</li>
<li>ConcreteImplementor具体实现化角色：实现接口或抽象类定义的方法和属性。</li>
</ol>
<p>它的通用源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</div><div class="line">    <span class="comment">// 基本方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体实现化角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementor1</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementor2</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象化角色</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义对实现化角色的引用</span></div><div class="line">    <span class="keyword">private</span> Implementor imp;</div><div class="line">    <span class="comment">// 约束子类必须实现该构造函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Abstraction</span><span class="params">(Implementor _imp)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.imp = _imp;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 自身的行为和属性</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.imp.doSomething();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 获得实现化角色</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Implementor <span class="title">getImp</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> imp;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体抽象化角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</div><div class="line">    <span class="comment">// 覆写构造函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor _imp)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(_imp);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 修正父类的行为</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.request();</div><div class="line">        <span class="keyword">super</span>.getImp().doAnything();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 定义一个实现化角色</span></div><div class="line">        Implementor imp = <span class="keyword">new</span> ConcreteImplementor1();</div><div class="line">        <span class="comment">// 定义一个抽象化角色</span></div><div class="line">        Abstraction abs = <span class="keyword">new</span> RefinedAbstraction(imp);</div><div class="line">        <span class="comment">// 执行</span></div><div class="line">        abs.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>抽象和实现分离。</li>
<li>优秀的扩充能力。</li>
<li>实现细节对客户透明。</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>不希望或不合适使用继承的场景。</li>
<li>接口或抽象类不稳定的场景。</li>
<li>重用性要求较高的场景。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>使用桥梁模式主要考虑如何拆分抽象和实现。桥梁模式的意图还是对变化的封装，尽量把可能变化的因素封装到最细、最小的逻辑单元，避免风险扩散。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>继承非常好，但是有缺点。我们可以扬长避短，对于比较明确不发生变化的，则通过继承来完成；若不能确定是否会发生变化的，那就认为会发生变化，则通过桥梁模式来搭建一个桥梁将变化的的东西放在外部和本体进行连接。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：不变的部分用继承来实现，变得部分放在外部，并通过&lt;strong&gt;桥梁模式&lt;/strong&gt;抽象耦合进来，这样就解决了继承的弊端。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——享元模式</title>
    <link href="http://bestlixiang.site/2018/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/18/设计模式之禅——享元模式/</id>
    <published>2018-03-18T12:03:02.000Z</published>
    <updated>2018-03-18T12:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：对象多了，而且还都是处于有用状态，那一定会出现内存溢出的问题，我们可以通过<strong>享元模式</strong>来实现对象的复用，以达到减少的目的，从而解决内存溢出的问题。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>享元模式是<strong>池技术</strong>的重要实现方式，其定义如下：</p>
<p><strong>使用”共享对象”可有效地支持大量的”细粒度的对象”。——结构类</strong></p>
<p>享元模式的定义为我们提出了两个要求：细粒度对象和共享对象。我们知道分配太多的对象到应用程序中将有损程序的性能，同时还容易造成内存溢出，那怎么避免呢？就是享元模式提到的共享技术。我们先来了解一下对象的内部状态和外部状态：</p>
<ul>
<li>内部状态：内部状态是对象可共享出来的信息，存储在享元对象并且不会随环境改变而改变，不必存储在具体某个对象中，属于可以共享的部分。</li>
<li>外部状态：外部状态是对象得以依赖的一个标记，是随环境改变而改变的，不可以共享的状态，他是一批对象的统一标识，是唯一的索引值。</li>
</ul>
<p>下面是享元模式的通用类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/flyweight.png" alt="flyweight"></p>
<p>简单介绍类图中的角色：</p>
<ol>
<li>Flyweight抽象享元角色：产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现。</li>
<li>ConcreteFlyWeight具体享元角色：具体的一个产品类，实现抽象角色定义的业务。该角色中需要注意的是内部状态处理应该与环境无关，不应该出现一个操作改变了内部状态，同时修改了外部状态，这是绝对不允许的。</li>
<li>UnsharedConcreteFlyWeight不可共享的享元角色：不存在外部状态或者安全要求（如线程安全）不能够使用共享技术的对象，该对象一般不会出现享元工厂中。（有点不太理解）</li>
<li>FlyWeightFactory享元工厂：职责非常简单，就是构造一个池容器，同时提供从池中获取对象的方法。</li>
</ol>
<p>享元模式的目的在于运用共享技术，使得一些细粒度的对象可以共享，多使用细粒度的对象，便于重构或重用，下面是它的通用代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  抽象享元角色</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span> </span>&#123;</div><div class="line">    <span class="comment">// 内部状态</span></div><div class="line">    <span class="keyword">private</span> String intrinsic;</div><div class="line">    <span class="comment">// 外部状态 注意final</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String extrinsic;</div><div class="line">    <span class="comment">// 要求享元角色必须接受外部状态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Flyweight</span><span class="params">(String _extrinsic)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.extrinsic = _extrinsic;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 定义业务操作</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> vid <span class="title">operate</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 内部状态的getter/setter</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIntrinsic</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> intrinsic;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntrinsic</span><span class="params">(String intrinsic)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.intrinsic = intrinsic;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体享元角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight1</span> <span class="keyword">extends</span> <span class="title">Flyweight</span> </span>&#123;</div><div class="line">    <span class="comment">// 接受外部状态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight1</span><span class="params">(String _extrinsic)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(_extrinsic)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 根据外部状态进行逻辑处理</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight2</span> <span class="keyword">extends</span> <span class="title">Flyweight</span> </span>&#123;</div><div class="line">    <span class="comment">// 接受外部状态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight2</span><span class="params">(String _extrinsic)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(_extrinsic)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 根据外部状态进行逻辑处理</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 享元工厂</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义一个池容器</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String,Flyweight&gt; pool = <span class="keyword">new</span> HashMap&lt;String,Flyweight&gt;();</div><div class="line">    <span class="comment">// 享元工厂</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String extrinsic)</span> </span>&#123;</div><div class="line">        <span class="comment">// 需要返回的对象</span></div><div class="line">        Flyweight flyweight = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 在池中没有该对象</span></div><div class="line">        <span class="keyword">if</span>(pool.containKey(extrinsic)) &#123;</div><div class="line">            flyweight = pool.get(extrinsic);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 根据外部状态创建享元对象</span></div><div class="line">            flyweight = <span class="keyword">new</span> ConcreteFlyweight1(extrinsic);</div><div class="line">            <span class="comment">// 放置到池中</span></div><div class="line">            pool.put(extrinsic,flyweight);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> flyweight;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>可以大大减少应用程序创建的对象，降低程序内存的占用，增强程序对的性能。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>提高了系统的复杂性，需要分离出外部状态和内部状态，而且外部状态具有固化特性（加fianl关键字），不应该随内部改变而改变，否则导致系统的逻辑混乱。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>系统中存在大量的相似对象。</li>
<li>细粒度的对象都具有较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</li>
<li>需要缓冲池的场景。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>当对象池的对象太少时，会出现线程不安全的现象。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>享元模式在Java API中也是随处可见的，比如String类的intern方法就是利用了String的对象池。当然对象池主要解决复用，而享元模式主要解决对象的共享问题，如果建立多个可共享的细粒度对象是其关注的重点。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：对象多了，而且还都是处于有用状态，那一定会出现内存溢出的问题，我们可以通过&lt;strong&gt;享元模式&lt;/strong&gt;来实现对象的复用，以达到减少的目的，从而解决内存溢出的问题。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——解释器模式</title>
    <link href="http://bestlixiang.site/2018/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/18/设计模式之禅——解释器模式/</id>
    <published>2018-03-18T05:46:46.000Z</published>
    <updated>2018-03-18T05:48:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：无论是编译原理，还是解释型语言，都会涉及到解释，其思想也都和<strong>解释器模式</strong>类似。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>给定一门语言，定义它的文法的一组表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。——行为类</strong></p>
<p>解释器模式的通用类图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/interpreter.png" alt="interpreter"></p>
<p>这里解释一下类图中的角色:</p>
<ol>
<li>AbstractExpression抽象解释器：具体的即时任务又各个实现类完成，具体的解释器分别由TerminalExpression（值）和NotermianlExpression（符号）完成。</li>
<li>TerminalExpression终结符表达式：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但是有多个实例，对应不同的终结符。</li>
<li>NotermianlExpression非终结符表达式：文法中的每条规则对应于一个非终结表达式。</li>
<li>Context环境角色：存放数据</li>
</ol>
<p>解释器是一个比较少用的模式，以下为其通用源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象表达式</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span> </span>&#123;</div><div class="line">    <span class="comment">// 每个表达式必须有一个解释任务</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">interpreter</span><span class="params">(Context ctx)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 终结符表达式</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</div><div class="line">    <span class="comment">// 通常终结符表达式只有一个，但是有多个对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interpreter</span><span class="params">(Context ctx)</span> </span>&#123;</div><div class="line">        <span class="comment">// 主要处理场景元素和数据的转换</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 非终结符表达式</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotermianlExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</div><div class="line">    <span class="comment">// 每个非终结符表达式都会对其他表达式产生依赖</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotermianlExpression</span><span class="params">(Expression... expression)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interpreter</span><span class="params">(Context ctx)</span> </span>&#123;</div><div class="line">        <span class="comment">// 进行文法处理</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Context ctx = <span class="keyword">new</span> Context();</div><div class="line">        <span class="comment">// 通常定一个语法容器，容纳一个具体的表达式，通常为ListArray、LinkedList、Stack等容器</span></div><div class="line">        Stack&lt;Expression&gt; stack = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span>(;;) &#123;</div><div class="line">            <span class="comment">// 进行语法判断，并产生递归调用</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 产生一个完整的语法树，由各个具体的语法分析进行解析</span></div><div class="line">        Expression exp = stack.pop();</div><div class="line">        <span class="comment">// 具体元素进入场景</span></div><div class="line">        exp.interpreter(ctx);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通常Client是一个封装类，封装的结果就是传递进来的规范语法文件，解释器分析后产生结果并返回，避免了调用者与语法解析器的耦合关系。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>解释器是一个简单语法分析工具，它最显著的有点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>解释器模式会引起类膨胀（显而易见）</li>
<li>解释器采用递归调用方法，调试复杂，且影响效率。</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>重复发生的问题可以使用解释器模式，如对不同的日志文件进行不同的分析。</li>
<li>一个简单语法需要解释的场景。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>尽量不要在重要的模块中使用解释器模式，否则维护回事一个很大的问题。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>解释器模式在实际的系统开发中使用得非常少，因为它会引起效率问题、性能以及维护等问题，一般在大中型的框架型项目能够找到它的身影，如一些数据分析工具、报表设计工具、科学计算工具等，若你确实遇到“一种特定类型的问题发生的频率足够高”的情况下，准备使用解释器模式时，可以考虑一下Expression4J、MESP、Jep等开元的解析工具包。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：无论是编译原理，还是解释型语言，都会涉及到解释，其思想也都和&lt;strong&gt;解释器模式&lt;/strong&gt;类似。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——状态模式</title>
    <link href="http://bestlixiang.site/2018/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/18/设计模式之禅——状态模式/</id>
    <published>2018-03-18T04:57:11.000Z</published>
    <updated>2018-03-18T04:57:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：状态（一个变量）变化了，然后就会出现不同的行为，这就是对<strong>状态模式</strong>最简单的理解，当然它还有很多约束。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>当一个对象内在状态改变时允许其他改变行为，这个对象看起来像改变其类。——行为类</strong></p>
<p>状态模式的核心是封装，状态的变更引起了行为的变更，从外部开起来就好像这个对象对应的类发生了改变一样，状态模式的通用类图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/state.png" alt="state"></p>
<p>简单介绍类图中的3个角色</p>
<ol>
<li>State抽象状态角色：负责对象的状态的定义，并且封装环境角色以实现状态的切换。</li>
<li>ConcreteState具体对象状态定义：每个具体状态必须完成两个职责：本状态的行为管理以及<strong>趋向状态</strong>处理。</li>
<li>Context环境角色：定义客户端需要的接口，并且负责具体状态的切换。</li>
</ol>
<p>下面是它的通用源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象状态角色</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义一个环境角色，提供子类访问</span></div><div class="line">    <span class="keyword">protected</span> Context context;</div><div class="line">    <span class="comment">// 设置环境角色</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(Context _context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.context = _context;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 行为1</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle1</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 行为2</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle2</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体状态角色</span></div><div class="line"><span class="keyword">public</span> alass concreteState1 extends State &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 本状态下必须处理的逻辑</span></div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 设置当前状态为state2</span></div><div class="line">        <span class="keyword">super</span>.context.setCurrentState(Context.STATE2);</div><div class="line">        <span class="comment">// 过度到state2状态，由Context实现</span></div><div class="line">        <span class="keyword">super</span>.context.handle2();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> alass concreteState2 extends State &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 本状态下必须处理的逻辑</span></div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 设置当前状态为state1</span></div><div class="line">        <span class="keyword">super</span>.context.setCurrentState(Context.STATE1);</div><div class="line">        <span class="comment">// 过度到state1状态，由Context实现</span></div><div class="line">        <span class="keyword">super</span>.context.handle1();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 环境角色，它具有以下两个不成文的约束：</span></div><div class="line"><span class="comment">// 1. 把状态对象声明为静态变量，有几个状态对象就声明几个静态变量</span></div><div class="line"><span class="comment">// 2. 环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义状态</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> State STATE1 = <span class="keyword">new</span> ConcreteState1();</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> State STATE2 = <span class="keyword">new</span> ConcreteState2();</div><div class="line">    <span class="comment">// 当前状态</span></div><div class="line">    <span class="keyword">private</span> State currentState;</div><div class="line">    <span class="comment">// 获得当前状态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</div><div class="line">        returncurrentState;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置当前状态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(State currentState)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.currentState = currentState;</div><div class="line">        <span class="comment">// 切换状态, 重要</span></div><div class="line">        <span class="keyword">this</span>.currentState.setContext(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">// 行为委托, 重要</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle1</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.currentState.handle1();</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle2</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.currentState.handle2();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 定义环境角色</span></div><div class="line">        Context context = <span class="keyword">new</span> Context();</div><div class="line">        <span class="comment">// 初始化状态</span></div><div class="line">        context.setCurrentState(<span class="keyword">new</span> ConcreteState1());</div><div class="line">        <span class="comment">// 行为执行</span></div><div class="line">        context.handle1();</div><div class="line">        context.handle2();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>结构清晰，提高系统的可维护性</li>
<li>遵循设计原则，很好体现了开闭原则和单一职责原则。</li>
<li>封装性非常好，将状态变化放置到类的内部来实现，外部的调用不用知道类内部如何实现状态和行为的变换。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>只有一个缺点，就是会随着状态的增多会出现类膨胀。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>行为随状态改变而改变的场景，如权限设计。</li>
<li>条件、分支判断语句的替代者。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>状态模式适用于当某个对象在它的状态发生改变时，它的行为也随着发生比较大的变化，也就是说在行为受状态约束的情况下可以使用状态模式，而且使用时对象的状态最好不要超过5个。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>状态模式其实经常会遇到，因为基本上都会遇到状态的切换。对于状态顺序的不同组成不同的状态变化线，我们可以使用建造者模式。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：状态（一个变量）变化了，然后就会出现不同的行为，这就是对&lt;strong&gt;状态模式&lt;/strong&gt;最简单的理解，当然它还有很多约束。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——访问者模式</title>
    <link href="http://bestlixiang.site/2018/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/15/设计模式之禅——访问者模式/</id>
    <published>2018-03-15T06:45:32.000Z</published>
    <updated>2018-03-15T06:46:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：一个对象结构包含很多类对象，他们又有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作，接可以使用<strong>访问者模式</strong>。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用与这些元素的新操作。——行为类</strong></p>
<p>它的通用类图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/visitor.png" alt="visitor"></p>
<p>我们看看类图中几个角色的职责：</p>
<ol>
<li>Visitor抽象访问者：声明访问者可以访问哪些元素，具体到程序找那个就是visit方法的参数定义哪些对象是可以被访问的。</li>
<li>ConcreteVisitor具体访问者：它影响访问者访问到一个类后该怎么干，要做什么事情。</li>
<li>Element抽象元素：声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。</li>
<li>ConcreteElement具体元素：实现accept方法，通常是visitor.visit(this)，基本都形成了一种模式了。</li>
<li>ObjectStruture结构对象：元素产生者，一般容纳在多个不同类，不同接口的容器，如List，Set，Map等，在项目中，一般很好抽象出这个角色。</li>
</ol>
<p>接着看看具体的通用源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象元素</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</div><div class="line">	<span class="comment">// 定义业务逻辑</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">	<span class="comment">// 允许谁来访问</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Ivisitor visitor)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体元素</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElement1</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</div><div class="line">    <span class="comment">// 完善业务逻辑</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务处理</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 允许哪个访问者访问</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Ivisitor visitor)</span> </span>&#123;</div><div class="line">        visitor.visit(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElement2</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</div><div class="line">    <span class="comment">// 完善业务逻辑</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务处理</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 允许哪个访问者访问</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Ivisitor visitor)</span> </span>&#123;</div><div class="line">        visitor.visit(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象访问者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Ivisitor</span> </span>&#123;</div><div class="line">    <span class="comment">// 可以访问哪些对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitor</span> <span class="params">(ConcreteElement1 el1)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitor</span> <span class="params">(ConcreteElement2 el2)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体访问者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Visitor</span> <span class="keyword">implements</span> <span class="title">Ivisitor</span> </span>&#123;</div><div class="line">    <span class="comment">// 访问el1元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement1 el1)</span> </span>&#123;</div><div class="line">        el1.doSomething;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 访问el2元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement2 el2)</span> </span>&#123;</div><div class="line">        el2.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 结构对象 产生不同的元素对象，可以用工厂方式模式模拟</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStruture</span> </span>&#123;</div><div class="line">    <span class="comment">// 对象生成器，通过工厂方法模式模拟</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">createElement</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random random = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">if</span>(random.nextInt(<span class="number">100</span>) &gt;<span class="number">50</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteElement1();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteElement2();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="comment">// 获取元素对象</span></div><div class="line">            Element el = ObjectStruture.createElement();</div><div class="line">            <span class="comment">// 接受访问者访问</span></div><div class="line">            el.accept(<span class="keyword">new</span> Visitor());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>符合单一职责原则。具体元素角色负责数据的加载，访问者类负责报表的展现，职责明确。</li>
<li>优秀的扩展性。报表不同只需要修改visit方法。</li>
<li>灵活性非常高。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>具体元素对访问者公布细节，不符合迪米特法则。</li>
<li>具体元素变更比较困难。</li>
<li>违背了依赖倒置原则，访问者依赖的是具体元素，而不是抽象元素。</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>一个对象结构包含很多类对象，他们又有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作，也就是说用迭代器模式已经不能胜任的情景。</li>
<li>需要对一个对象结构中的对象进行不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。</li>
<li>总结：在这种地方一定要考虑使用访问者模式：业务规则要求遍历多个不同的对象，迭代器只能访问同类或同接口的数据，而访问者模式是对迭代器模式的扩充，可以遍历不同的对象，然后执行不同的操作。访问者模式还可以充当拦截器的角色。</li>
</ol>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>访问者模式一种集中规整模式，特别适用于大规模重构的项目。通过访问这么欧式可以很容易吧一些进行梳理，达到最终目的——功能集中化。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：一个对象结构包含很多类对象，他们又有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作，接可以使用&lt;strong&gt;访问者模式&lt;/strong&gt;。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——备忘录模式</title>
    <link href="http://bestlixiang.site/2018/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/14/设计模式之禅——备忘录模式/</id>
    <published>2018-03-14T05:11:10.000Z</published>
    <updated>2018-03-14T05:11:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>引： <strong>备忘录模式</strong>是我们设计上的“月光宝盒”，可以让我们回到需要的年代；是程序数据的“后悔药”，吃了它就可以返回上一个状态；是设计人员的定心丸，确保即使在最坏的情况下也能获得最近的对象状态。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>备忘录模式提供了一种弥补真实世界缺陷的方法，让“后悔药”在程序的世界中真实可行，其定义如下：</p>
<p><strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在改对象之外保存这个状态，这样以后就可将该对象的恢复到原先保存的状态。——行为类</strong></p>
<p>备忘录模式就是一个对象的备份模式，提供了一种程序数据的备份方法，其通用类图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/memento.png" alt="memento"></p>
<p>下面简单介绍类图中的几个角色：</p>
<ol>
<li>Originator发起人角色：记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。</li>
<li>Memento备忘录角色：负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。</li>
<li>Caretaker备忘录管理员角色：对备忘录进行管理，保存和提供备忘录。</li>
</ol>
<p>下面是它的通用源代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 发起人角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originate</span> </span>&#123;</div><div class="line">    <span class="comment">// 内部状态</span></div><div class="line">    <span class="keyword">private</span> String state = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String  <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.state = state;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 创建一个备忘录</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(<span class="keyword">this</span>.state);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 恢复一个备忘录</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Memento _memento)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.setState(_memento.getState());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 备忘录角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</div><div class="line">    <span class="comment">// 发起人内部状态</span></div><div class="line">    <span class="keyword">private</span> String state = <span class="string">""</span>;</div><div class="line">    <span class="comment">// 构造函数传递</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String _state)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.state = _state;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.state = state;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 备忘录管理者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span> </span>&#123;</div><div class="line">    <span class="comment">// 备忘录对象</span></div><div class="line">    <span class="keyword">private</span> Memento memento;</div><div class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> memento;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.memento = memento;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 定义发起人</span></div><div class="line">        Originator originator = <span class="keyword">new</span> Originator();</div><div class="line">        <span class="comment">// 定义出备忘录管理员</span></div><div class="line">        Caretaker caretaker = <span class="keyword">new</span> Caretaker();</div><div class="line">        <span class="comment">// 创建一个备忘录</span></div><div class="line">        caretaker.setMemento(originator.createMemento());</div><div class="line">        <span class="comment">// 恢复一个备忘录</span></div><div class="line">        originator.restoreMemento(caretaker.getMemento());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>需要保存和恢复数据的相关状态场景。</li>
<li>提供一个可回滚的操作。</li>
<li>需要监控的副本场景。</li>
<li>数据库连接的事务管理就是用的备忘录模式。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><p>备忘录的生命周期</p>
<p> 备忘录创建出来就要在“最近”的代码中使用，要主动管理它的生命周期，建立就要使用，不使用就要立刻删除其引用，等待垃圾回收器对它的回收处理。</p>
</li>
<li><p>备忘录性能</p>
<p> 不要在频繁建立备份的场景中使用备忘录模式，原因有而：一是控制不了备忘录建立的对象数量；二是大对象的建立是要消耗资源的，系统的性能需要考虑。</p>
</li>
</ol>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="clone方式的备忘录"><a href="#clone方式的备忘录" class="headerlink" title="clone方式的备忘录"></a>clone方式的备忘录</h2><p>发起人角色融入了发起人角色和备份路角色，利用clone()方法克隆出来的对象充当备忘录对象。但是由于存在深拷贝和浅拷贝的问题，在复杂的场景下它会让你的程序逻辑异常混乱，因此Clone方式的备忘录模式适用于比较简单的场景。</p>
<h2 id="多状态的备忘录模式"><a href="#多状态的备忘录模式" class="headerlink" title="多状态的备忘录模式"></a>多状态的备忘录模式</h2><p>将多个状态转换到HashMap中，方便备忘录角色存储。</p>
<h2 id="多备份的备忘录"><a href="#多备份的备忘录" class="headerlink" title="多备份的备忘录"></a>多备份的备忘录</h2><p>将备份的数据存入到HashMap中，并给每个不同的备份一个不同的key。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>大家主要的还是记住数据库的事务用的是备忘录模式就好了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引： &lt;strong&gt;备忘录模式&lt;/strong&gt;是我们设计上的“月光宝盒”，可以让我们回到需要的年代；是程序数据的“后悔药”，吃了它就可以返回上一个状态；是设计人员的定心丸，确保即使在最坏的情况下也能获得最近的对象状态。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——门面模式</title>
    <link href="http://bestlixiang.site/2018/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/13/设计模式之禅——门面模式/</id>
    <published>2018-03-13T02:18:20.000Z</published>
    <updated>2018-03-13T02:18:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：怎样保证“金玉其外，败絮其中”，<strong>门面模式</strong>可以达到你的要求！<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。——结构类</strong></p>
<p>门面模式注重<strong>统一的对象</strong>，也就是提供一个访问子系统的接口，除了这个接口不允许有任何访问子系统的行为发生，其通用类图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/facade.png" alt="facade"></p>
<p>下面简单介绍类图中的两个角色：</p>
<ol>
<li>Facade门面角色：客户端调用这个角色的方法，此角色知晓子系统的所有功能和责任。一般情况下，本角色会将所有从客户端发起的请求委派到相应的子系统去，也就是说该角色没有实际的业务逻辑，只是一个委托类。</li>
<li>Subsystem Classes子系统所有类角色：可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合，子系统不知道门面的存在。</li>
</ol>
<p>下面是它的通用源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 子系统</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingA</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassC</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingC</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 门面对象</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</div><div class="line">    <span class="comment">// 被委托的对象</span></div><div class="line">    <span class="keyword">private</span> ClassA a = <span class="keyword">new</span> ClassA();</div><div class="line">    <span class="keyword">private</span> ClassB b = <span class="keyword">new</span> ClassB();</div><div class="line">    <span class="keyword">private</span> ClassC c = <span class="keyword">new</span> ClassC();</div><div class="line">    <span class="comment">// 提供给外部访问的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.a.doSomethingA();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.b.doSomethingB();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.c.doSomethingC();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>减少系统的相互依赖。所有的依赖都是对门面对象的依赖，与子系统无关。</li>
<li>提供了灵活性。不管子系统内部如何变化，只要不影响到门面对象，任你自由活动。</li>
<li>提供安全性。想让你访问子系统的那些业务就开通那些逻辑，不在门面上开通的方法，你休想访问到。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>门面模式最大的缺点就是不符合开闭原则，没有对修改关闭，对扩展开放。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>为一个复杂的模块或子系统提供一个供外界访问的接口。</li>
<li>子系统相对独立——外界对子系统的访问只要黑箱操作即可。</li>
<li>预防低水平人员带来的风险扩散。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>一个系统可以有多个门面。比如下面的情况：<ul>
<li>门面已经庞大到不能忍受的程度</li>
<li>子系统可以提供不同访问路径</li>
</ul>
</li>
<li>门面不参与子系统内的业务逻辑。</li>
</ol>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>门面模式是一个很好的封装方法，很多情况都可以使用到，如下面的情况：</p>
<ol>
<li>一个子系统比较复杂，就可以封装出一个或多个门面，项目结构简单，扩展性非常好。</li>
<li>对于一个比较大的项目，为了避免人员带来的风险，也可以使用门面模式，技术水平差的成员，尽量安排独立的模块，然后把他写的程序封装到一个门面李，尽量让其他项目成员不用看到这些人的代码。看也看不懂，哈哈。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：怎样保证“金玉其外，败絮其中”，&lt;strong&gt;门面模式&lt;/strong&gt;可以达到你的要求！
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——观察者模式</title>
    <link href="http://bestlixiang.site/2018/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/12/设计模式之禅——观察者模式/</id>
    <published>2018-03-12T12:33:37.000Z</published>
    <updated>2018-03-12T12:34:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：被观察者做出动作了，然后通知观察者做出反应。<strong>观察者模式</strong>就是这么简单！<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>观察者模式又称发布订阅模式。</p>
<p><strong>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有它依赖的对象都会得到通知并被自动更新。行为类</strong></p>
<p>下面是它的通用类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/observer.png" alt="observer"></p>
<p>下面简单介绍一下类图中的几个角色：</p>
<ol>
<li>Subject被观察者：定义观察者必须实现的职责，它必须能够动态地增加、取消观察者。管理观察者并通知观察者。</li>
<li>Observer观察者：观察者接受到消息后，即进行update操作，对接收的信息进行处理。</li>
</ol>
<p>下面是它的通用源代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 被观察者</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义一个观察者数组</span></div><div class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; observerVector = <span class="keyword">new</span> Vector&lt;Observer&gt;();</div><div class="line">    <span class="comment">// 增加一个观察者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.observerVector.add(o);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 删除一个观察者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer <span class="number">0</span>)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.observerVector.remove(o);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 通知所有观察者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Observer o : <span class="keyword">this</span>.observerVector) &#123;</div><div class="line">            o.update();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体被观察者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="comment">// 具体的业务</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// do somthing</span></div><div class="line">        <span class="keyword">super</span>.notifyObservers();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 观察者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="comment">// 更新方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体观察者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="comment">// 实现更新方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updatea</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"接到消息，并进行处理"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 场景一个被观察者</span></div><div class="line">        ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject();</div><div class="line">        <span class="comment">// 定义一个观察者</span></div><div class="line">        Observer obs = <span class="keyword">new</span> ConcreteObserver();</div><div class="line">        <span class="comment">// 观察者观察被观察者</span></div><div class="line">        subject.addObserver(obs);</div><div class="line">        <span class="comment">// 观察者开始活动了</span></div><div class="line">        subject.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>观察者和被观察者之间是<strong>抽象耦合</strong>的，不管是增加观察者都非常容易扩展。</li>
<li>建立一套触发机制。容易在单一职责下构建一条触发链。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>观察者模式需要考虑一下开发效率和运行效率问题，一个被观察者，多个观察者，开发和调试就会比较复杂，而且在Java中消息的通知默认是顺序执行的，一个观察者卡壳，会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>关联行为场景。这种关联行为时可以拆分的。</li>
<li>事件多级触发场景。</li>
<li>跨系统的消息交换场景，如消息队列的处理机制。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>广播链。在一个观察者模式中最多出现一个对象既是观察者又是被观察者，也就是说消息最多被转发一次。（和责任链的区别在于广播链在消息传播过程中消息是可变的）</li>
<li>异步处理问题。如果观察者比较多，处理时间长，我们就需要用异步。异步处理需要考虑到线程安全和队列问题。</li>
</ol>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="Java世界中的观察者模式"><a href="#Java世界中的观察者模式" class="headerlink" title="Java世界中的观察者模式"></a>Java世界中的观察者模式</h2><p>在JDK中已经提供了java.util.Observable实现类（被观察者）以及java.util.Observer接口（观察者）。大家要记住在java的世界里横行时，多看看API，有很大的帮助，很多东西Java已经帮我们设计了一个良好的框架。</p>
<h2 id="项目中真实的观察者模式"><a href="#项目中真实的观察者模式" class="headerlink" title="项目中真实的观察者模式"></a>项目中真实的观察者模式</h2><p>在系统设计中会对观察者模式进行改造或改装，主要在以下3个方面：</p>
<ol>
<li><p>观察者和被观察者之间的消息沟通</p>
<p> 被观察者状态改变会触发观察者的一个行为，同时会传递一个消息给观察者，这是正确地，但是在实际中一般的做法是：观察者中update方法会接受两个参数，一个是被观察者，一个是DTO（数据传输对象），DTO一般是一个纯洁的JavaBean，由被观察者生成，由观察者消费。</p>
</li>
<li><p>观察者响应方式</p>
<p>为了解决观察者的快速响应有以下两个办法：</p>
<ul>
<li>采用多线程技术</li>
<li>缓存技术（同步架构）</li>
</ul>
</li>
<li><p>被观察者尽量自己做主</p>
<p>被观察者的状态改变不一定要通知观察者，所以doSomething方法可以被重载，增加一个doSomething(boolean isNotifyObs)方法，决定是否通知观察者，而不是在消息到达观察和才判断是否要消费。</p>
</li>
</ol>
<h2 id="订阅发布模型"><a href="#订阅发布模型" class="headerlink" title="订阅发布模型"></a>订阅发布模型</h2><p>顾名思义就是消息的发布者发布一个消息，然后利用消息队列通知订阅者做出反应。这相当于观察者模式的升级版。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>观察者模式在实际项目中和生活中非常常见，如下面的例子：</p>
<ol>
<li>文件系统：在一个目录下新建立一个文件，这个动作会同时通知目录管理器增加该目录。文件是一个被观察者，目录管理器是一个被观察者。</li>
<li>广播收音机：电台在广播，收音机在收听。电台是一个被观察者，收音机是一个被观察者。<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1></li>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：被观察者做出动作了，然后通知观察者做出反应。&lt;strong&gt;观察者模式&lt;/strong&gt;就是这么简单！
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——组合模式</title>
    <link href="http://bestlixiang.site/2018/03/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/10/设计模式之禅——组合模式/</id>
    <published>2018-03-10T01:46:05.000Z</published>
    <updated>2018-03-10T01:46:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：部分类可以组成整体类，然后拥有一个统一的接口，这就是<strong>组合模式</strong>。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。——结构类</strong></p>
<p>组合模式也叫合成模式，有时又叫做部分——整体模式，主要用来描述部分和整体的关系。下面是它的通用类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/composite.png" alt="composite"></p>
<p>接下来简单介绍类图的几个类：</p>
<ol>
<li>Component抽象构建角色：定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性。</li>
<li>Leaf叶子构件：叶子对象，其下再也没有其他的分支，遍历的最小单位。</li>
<li>Composite树枝构件：树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。</li>
</ol>
<p>下面是它的通用源代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象构建</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="comment">// 个体和整体都具有的共享</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 编写逻辑业务</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 树枝构件</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="comment">// 构件容器</span></div><div class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; componentArrayList = <span class="keyword">new</span> ArrayList&lt;Component&gt;();</div><div class="line">    <span class="comment">// 增加一个叶子构件或树枝构件</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.componentArrayList.add(component);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 删除一个叶子构件或树枝构件</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.componentArrayList.remove(component);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 获得分支下的所有叶子构件和树枝构件</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Component&gt; <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.componentArrayList;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 树叶节点</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 覆写父类方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 创建一个根节点</span></div><div class="line">        Composite root = <span class="keyword">new</span> Composite();</div><div class="line">        root.doSomething();</div><div class="line">        <span class="comment">// 创建一个树枝节点</span></div><div class="line">        Composite branch = <span class="keyword">new</span> Composite();</div><div class="line">        <span class="comment">// 创建一个叶子节点</span></div><div class="line">        Leaf leaf = <span class="keyword">new</span> Leaf();</div><div class="line">        <span class="comment">// 建立整体</span></div><div class="line">        root.add(branch);</div><div class="line">        branch.add(leaf);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 通过递归遍历树</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Composite root)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(Component c : root.getChildren()) &#123;</div><div class="line">            <span class="keyword">if</span> (c <span class="keyword">instanceof</span> Leaf) &#123;</div><div class="line">                c.doSomething();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                display((Composite) c);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以从场景类看出组合模式破坏了依赖倒转原则，树枝和树叶直接使用了实现类。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>高层模块调用节点，一棵树机构中的所有节点都是Component。</li>
<li>节点自由增加，容易扩展，符合开闭原则。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>与依赖倒置原则冲突，限制了接口的影响范围。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>维护和展示部分-整体关系的场景，如树形菜单，文件和文件夹管理。</li>
<li>从一个整体能够独立出部分模块或功能的场景。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>只要是树形结构或者体现局部和整体的关系的时候，要考虑组合模式。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>组合模式在项目中到处都有，比如页面结构，XML结构等等。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：部分类可以组成整体类，然后拥有一个统一的接口，这就是&lt;strong&gt;组合模式&lt;/strong&gt;。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——迭代器模式</title>
    <link href="http://bestlixiang.site/2018/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/08/设计模式之禅——迭代器模式/</id>
    <published>2018-03-08T07:45:50.000Z</published>
    <updated>2018-03-08T07:46:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：提起迭代器，大家一定能想到Java的Iterator，不错，我们这次讲的迭代器模式就是目前大部分语言都已经实现的迭代器。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>它提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。——创造类</strong></p>
<p>迭代器是为容器服务的，能容纳对象的所有类型都可以称为容器。迭代器模式提供了遍历 容器的方便性，容器主要管理增减元素就可以了，需要遍历时交由迭代器进行。目前基本上不会单独写一个迭代器。下面是它的通用类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/iterator.png" alt="iterator"></p>
<p>下面简单介绍类图中的几个角色：</p>
<ol>
<li>Iterator抽象迭代器：抽象迭代器负责定义访问和遍历元素的接口。</li>
<li>ConcreteIterator具体迭代器：实现迭代器接口，完成容器元素的遍历。</li>
<li>Aggregate抽象容器：容器角色负责提供创建具体迭代器角色的的接口，必然提供一个类似createIterator()这样的方法，在Java中一般是iterator()方法。</li>
<li>ConcreteAggregate具体容器：实现容器接口定义的方法，创建出容纳迭代器的对象。</li>
</ol>
<p>下面是迭代器模式的通用源代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象迭代器</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</div><div class="line">    <span class="comment">// 遍历到下一个元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 是否已经遍历到尾部</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 删除当前指向的元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体迭代器</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Vector vector = <span class="keyword">new</span> Vector();</div><div class="line">    <span class="comment">// 定义当前游标</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cursor = <span class="number">0</span>;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"checked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(Vector _vector)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.vector = _vector;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 判断是否到达尾部</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.cursor == <span class="keyword">this</span>.vector.size()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 返回下一个元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        Object result = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasNext()) &#123;</div><div class="line">            result = <span class="keyword">this</span>.vector.get(<span class="keyword">this</span>.cursor++);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            result = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 删除当前元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.vector.remove(<span class="keyword">this</span>.cursor);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象容器</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</div><div class="line">    <span class="comment">// 是容器必然有元素的增加</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object object)</span></span>;</div><div class="line">    <span class="comment">// 减少元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object object)</span></span>;</div><div class="line">    <span class="comment">// 由迭代器来遍历所有的元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体容器</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</div><div class="line">    <span class="comment">// 容纳对象的容器</span></div><div class="line">    <span class="keyword">private</span> Vector vector = <span class="keyword">new</span> Vector();</div><div class="line">    <span class="comment">// 增加一个元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object object)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.vector.add(object);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 返回迭代器对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(<span class="keyword">this</span>.vector);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 删除一个元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object object)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.remove(object);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 声明容器</span></div><div class="line">        Aggregate agg = <span class="keyword">new</span> ConcreteAggregate();</div><div class="line">        <span class="comment">// 产生对象数据放进去</span></div><div class="line">        agg.add(<span class="string">"abc"</span>);</div><div class="line">        agg.add(<span class="string">"aaa"</span>);</div><div class="line">        agg.add(<span class="string">"1234"</span>);</div><div class="line">        <span class="comment">// 遍历一下</span></div><div class="line">        Iterator iterator = agg.iterator();</div><div class="line">        <span class="keyword">while</span>(Iterator.hasNext()) &#123;</div><div class="line">            System.out.println(iterator.next());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>只要不是在使用那些古董级的编程语言，都不用自己动手写迭代器。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>如果你是做Java开发，尽量不要自己写迭代器模式。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：提起迭代器，大家一定能想到Java的Iterator，不错，我们这次讲的迭代器模式就是目前大部分语言都已经实现的迭代器。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——适配器模式</title>
    <link href="http://bestlixiang.site/2018/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/08/设计模式之禅——适配器模式/</id>
    <published>2018-03-08T05:35:56.000Z</published>
    <updated>2018-03-08T07:46:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：<strong>适配器模式</strong>在生活中非常常见，比如你的笔记本上的电源适配器，通过它笔记本可以使用在110~220V之间变化的电源，而笔记本还可以正常工作。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>将一个类的接口变换成客户端期待的另一种接口，从而使原本因接口不匹配而无法再一起工作的两个类能够在一起工作。——结构类</strong></p>
<p>下面是它的通用类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/adapter.png" alt="adapter"></p>
<p>下面简单介绍类图中的几个类：</p>
<ol>
<li>Target目标角色：该角色定义吧其他类转化为何种接口，也就是我们期望的接口。</li>
<li>Adaptee源角色：需要转化的角色，通过适配器角色的包装可以成为一个新角色。</li>
<li>Adapter适配器角色：它的职责就是通过继承或者类关联的方式把源角色转化为目标角色。</li>
</ol>
<p>下面是他的通过源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 目标角色</span></div><div class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="comment">// 目标角色有自己的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 目标角色的实现类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteTarget</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"if you need any help,please call me!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 源角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</div><div class="line">    <span class="comment">// 原有的业务逻辑</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"I`m kind of busy,leave me alone,please!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 适配器橘色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 原有的业务逻辑</span></div><div class="line">        Target target = <span class="keyword">new</span> ConcreteTarget();</div><div class="line">        target.request();</div><div class="line">        <span class="comment">// 现在增加了适配器角色的业务逻辑</span></div><div class="line">        Target target2 = <span class="keyword">new</span> Adapter();</div><div class="line">        target2.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>适配器模式可以让两个没有任何关系的类一起运行</li>
<li>提高了类的透明性，源角色对于高层模块是透明的</li>
<li>提高了类的复用度，源角色在原系统中还是可以正常使用的</li>
<li>灵活性非常好，不需要适配器的时候删除掉这个适配器即可</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当你有动机修改一个已经投产中的接口时，适配器可能是最适合的你模式。比如系统扩展了，需要使用一个已有或新建立的类，当这个类又不符合系统的接口，那么就可以使用适配器模式。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>适配器模式最好在详细设计阶段不要考虑它，它不是为解决还处在开发阶段的问题，而是解决正在服役的项目问题。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>适配器模式是一个补救模式，通常用来解决接口不相容的问题。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：&lt;strong&gt;适配器模式&lt;/strong&gt;在生活中非常常见，比如你的笔记本上的电源适配器，通过它笔记本可以使用在110~220V之间变化的电源，而笔记本还可以正常工作。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——策略模式</title>
    <link href="http://bestlixiang.site/2018/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/07/设计模式之禅——策略模式/</id>
    <published>2018-03-07T09:19:02.000Z</published>
    <updated>2018-03-07T09:19:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：将所有方法封装起来，要用什么方法就打开什么方法，这就是<strong>策略模式</strong>。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。——行为类</strong></p>
<p>我们先看它的类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/strategy.png" alt="strategy"></p>
<p>简单介绍类图中的几个类：</p>
<ol>
<li>Context封装角色，也叫上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问。</li>
<li>Strategy抽象策略角色，定义每个策略或算法必须具有的方法和属性。</li>
<li>ConcreteStrategy具体策略角色，实现抽象策略的操作，该类含有具体的算法。</li>
</ol>
<p>下面是它的通用源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象的策略角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="comment">// 策略模式的运算法则</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体角色类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy1</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"具体策略1的运算法则"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy2</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"具体策略2的运算法则"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 封装角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</div><div class="line">    <span class="comment">// 抽象策略</span></div><div class="line">    <span class="keyword">private</span> Strategy strategy = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 构造函数设置具体策略</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy _strategy)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.strategy = _strategy;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 封装后的策略方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAngthing</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.strategy.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 声明一个具体的策略</span></div><div class="line">        Strategy strategy = <span class="keyword">new</span> ConcreteStrategy1();</div><div class="line">        <span class="comment">// 声明上下文对象</span></div><div class="line">        Context context = <span class="keyword">new</span> Context(strategy);</div><div class="line">        <span class="comment">// 执行封装后的方法</span></div><div class="line">        context.doAngthing();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>策略模式实质是采用了面向对象的继承和<strong>多态机制</strong>。但是一个类实现多个接口很正常，所以识别出抽象策略接口是系统分析师的价值所在。策略模式和代理模式的区别是策略模式的封装角色和被封装的策略类不用是同一个接口。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>算法可以自由切换</li>
<li>避免使用多重条件判断</li>
<li>扩展性良好</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>策略类数量增多，复用可能性小</li>
<li>所有策略类都需要对外暴露，上层模块需要知道有哪些策略，违背了迪米特法则</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>多个类只有在算法或行为上稍有不同的场景</li>
<li>算法需要自由切换的场景</li>
<li>需要屏蔽算法规则的场景</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果系统中的一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀和对外暴露问题。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>策略模式在项目中会经常使用，但是它具有一个致命缺陷：所有的策略都需要暴露出去。在实际项目中，我们一般通过工厂方法模式来实现策略类的声明。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：将所有方法封装起来，要用什么方法就打开什么方法，这就是&lt;strong&gt;策略模式&lt;/strong&gt;。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——装饰模式</title>
    <link href="http://bestlixiang.site/2018/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/07/设计模式之禅——装饰模式/</id>
    <published>2018-03-07T04:09:48.000Z</published>
    <updated>2018-03-07T05:42:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：想给某些类增加一些功能，有些人可能会想到直接修改类，但是要求不影响子类，这就需要用到<strong>装饰模式</strong>了。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。——结构类</strong></p>
<p>装饰模式和代理模式很像，它的通用类图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/decorator.png" alt="decorator"></p>
<p>下面简单说说类图中的4个对象：</p>
<ol>
<li>Component是一个接口或者抽象类，就是定义我们最核心的对象，也是最原始的对象。</li>
<li>ConcreteComponent是最核心的对象的实现，我们要装饰的就是它。</li>
<li>Decorator装饰对象，它里面不一定有抽象的方法，但是它的属性里必然有一个private变量指向Component。</li>
<li>ConcreteDecorator是装饰对象的实现类。</li>
</ol>
<p>装饰模式的具体实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="comment">// 抽象的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="title">exgtends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="comment">// 具体实现</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"do something"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象装饰类，如果只有一个装饰类，则可以没有抽象装饰者</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Component component = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 通过构造函数传递被修饰者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component _component)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.component = _component;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 委托给被修饰者执行</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.component.operate();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体装饰类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator1</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义被修饰者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator1</span><span class="params">(Component _component)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(_component);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 定义自己的修饰方法</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"method1 修饰"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 重写父类的operate方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.method1();</div><div class="line">        <span class="keyword">super</span>.operate();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator2</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义被修饰者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator2</span><span class="params">(Component _component)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(_component);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 定义自己的修饰方法</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"method2 修饰"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 重写父类的operate方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.method2();</div><div class="line">        <span class="keyword">super</span>.operate();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Component component = <span class="keyword">new</span> ConcreteComponent();</div><div class="line">        <span class="comment">// 第一次修饰</span></div><div class="line">        component = <span class="keyword">new</span> ConcreteDecorator1(component);</div><div class="line">        <span class="comment">// 第二次修饰</span></div><div class="line">        component = <span class="keyword">new</span> ConcreteDecorator2(component);</div><div class="line">        <span class="comment">// 修饰后运行</span></div><div class="line">        component.operate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>装饰类和被修饰类可以独立发展，而不会相互耦合。</li>
<li>装饰模式是继承关系的一个替代方案。</li>
<li>装饰模式可以动态地扩展一个实现类的功能。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>多层的装饰是比较复杂的。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>需要扩展一个类的功能，或给一个类增加附加功能。</li>
<li>需要动态地给一个对象增加功能，这些功能可以再动态地撤销的。</li>
<li>需要为一批兄弟类进行改装或加装功能。</li>
</ol>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ol>
<li>装饰模式是对继承的有力补充。</li>
<li>在业务变更的时候，增强类的功能。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：想给某些类增加一些功能，有些人可能会想到直接修改类，但是要求不影响子类，这就需要用到&lt;strong&gt;装饰模式&lt;/strong&gt;了。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——责任链模式</title>
    <link href="http://bestlixiang.site/2018/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/07/设计模式之禅——责任链模式/</id>
    <published>2018-03-07T01:58:26.000Z</published>
    <updated>2018-03-07T01:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：一个问题对应一个解决方法，你一般需要去找到对应的方法，现在有一种方法就是你不管遇到什么问题只要交给第一个解决方法就可以了，美滋滋，这就是<strong>责任链模式</strong>。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。——行为类</strong></p>
<p>责任链模式的重点在“链”上，由一条链去处理相似的请求在链中决定谁来处理这个请求，并返回相应的结果。其通用类图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/chain.png" alt="chain"></p>
<p>责任链模式的核心在链上，“链”是由多个处理者ConcreteHandle组成的，它的通用源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象处理者</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Handler nextHandler;</div><div class="line">    <span class="comment">// 每个处理者都必须对请求做出处理</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Response <span class="title">handleMessage</span><span class="params">(Request request)</span> </span>&#123; <span class="comment">// final关键字参考模板模式的模板方法</span></div><div class="line">        <span class="comment">//  判断是否是自己的处理级别</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getHandlerLevel().equals(request.getRequestLevel())) &#123;</div><div class="line">            response = <span class="keyword">this</span>.echo(request);</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不属于自己的处理级别</span></div><div class="line">            <span class="comment">// 判断是否有下一个处理者</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.nextHandler != <span class="keyword">null</span>) &#123;</div><div class="line">                response = <span class="keyword">this</span>.nextHandler.handleMessage(request);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 没有适当处理者，业务自行处理</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> response;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置下一个处理者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Handler _handler)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.nextHandler = _handler;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 每个处理者都有一个处理级别</span></div><div class="line">    <span class="function">protect <span class="keyword">abstract</span> Level <span class="title">getHandlerLevel</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//每个处理者都必须实现处理任务</span></div><div class="line">    <span class="function">protect <span class="keyword">abstract</span> Response <span class="title">echo</span><span class="params">(Request request)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体处理者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Concretehandler1</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义自己的处理逻辑</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Response <span class="title">echo</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">        <span class="comment">// 完成处理逻辑</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置自己的处理级别</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Level <span class="title">getHandlerLevel</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 设置自己的处理级别</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Concretehandler2</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义自己的处理逻辑</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Response <span class="title">echo</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">        <span class="comment">// 完成处理逻辑</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置自己的处理级别</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Level <span class="title">getHandlerLevel</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 设置自己的处理级别</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Concretehandler3</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义自己的处理逻辑</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Response <span class="title">echo</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">        <span class="comment">// 完成处理逻辑</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置自己的处理级别</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Level <span class="title">getHandlerLevel</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 设置自己的处理级别</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 模式中有关框架代码</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Level</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义一个请求和处理等级</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</div><div class="line">    <span class="comment">// 请求的等级</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Level <span class="title">getRequestLevel</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">publci <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</div><div class="line">    <span class="comment">// 处理者返回的数据</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 声明所有的处理节点</span></div><div class="line">        Handler handler1 = <span class="keyword">new</span> ConcreteHandler1();</div><div class="line">        Handler handler2 = <span class="keyword">new</span> ConcreteHandler2();</div><div class="line">        Handler handler3 = <span class="keyword">new</span> ConcreteHandler3();</div><div class="line">        <span class="comment">// 设置链中的阶段顺序1--&gt;2--&gt;3</span></div><div class="line">        handler1.setNext(handler2);</div><div class="line">        handler2.setNext(handler3);</div><div class="line">        <span class="comment">// 提交请求，返回结果</span></div><div class="line">        Response response = handler1.handlerMessage(<span class="keyword">new</span> Request());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在实际应用中，一般会有一个封装类对责任模式进行封装，直接返回链中的第一个处理者，具体链的设置不需要高层模块关系，这样，简化了高层次模式的调用，减少模块间的耦合，提高系统的灵活性。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>将请求和处理分开，请求者可以不用知道谁处理的，处理者可以不用知道请求的全貌，两者解耦。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>性能问题，每个请求都是从链头遍历到链尾，在链比较长的时候，性能就会出现问题。</li>
<li>调试不方便，调试逻辑复制。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>链中节点数量需要控制，避免出现超长链的情况，一般做法是在Handler中设置一个最大节点数量，在setNext方法中判断是否已经超过其阈值，超过则不允许该链建立。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ol>
<li>融合模板方法模式，每个实现类只要实现两个方法：echo方法处理请求和getHandlerLevel获得处理级别，符合单一职责原则和迪米特法则。</li>
<li>责任链模式的核心它屏蔽了请求的处理过程，只要你把请求抛给责任链的第一个处理者，最终会返回一个处理结果，作为请求者不用知道需要谁来处理。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：一个问题对应一个解决方法，你一般需要去找到对应的方法，现在有一种方法就是你不管遇到什么问题只要交给第一个解决方法就可以了，美滋滋，这就是&lt;strong&gt;责任链模式&lt;/strong&gt;。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——命令模式</title>
    <link href="http://bestlixiang.site/2018/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/06/设计模式之禅——命令模式/</id>
    <published>2018-03-06T02:30:12.000Z</published>
    <updated>2018-03-06T02:31:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：作为领导人只要发布命令即可，而不用在发布命令的时候还要去找到实施的人，我相信领导人一定超级高兴，因为实施的人已经包含在命令里了。这就是<strong>命令模式</strong>。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。——行为类</strong></p>
<p>命令模式是一个高内聚模式。它的封装性非常好，把请求方（Invoker）和执行方（Receiver）封开了。</p>
<p>它的通用类图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/command.png" alt="image"></p>
<p>通用代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通用Receiver类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</div><div class="line">    <span class="comment">// 抽象接收者，定义每个接收者都必须完成的业务</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体的Receiver类，可以是N个，和业务有关</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcereteReceiver1</span> <span class="keyword">extends</span> <span class="title">Receiver</span> </span>&#123;</div><div class="line">    <span class="comment">// 每个接收者都必须处理一定的业务逻辑</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcereteReceiver2</span> <span class="keyword">extends</span> <span class="title">Receiver</span> </span>&#123;</div><div class="line">    <span class="comment">// 每个接收者都必须处理一定的业务逻辑</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象的Command类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</div><div class="line">    <span class="comment">// 每个命令类都必须有一个执行命令的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体的Command类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand1</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</div><div class="line">    <span class="comment">//关联，对哪个Receiver类进行命令处理</span></div><div class="line">    <span class="keyword">private</span> Receiver receiver;</div><div class="line">    <span class="comment">// 构造函数传递接收者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand1</span><span class="params">(Receiver _receiver)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.receiver = _receiver;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 必须实现一个命令</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务处理</span></div><div class="line">        <span class="keyword">this</span>.receiver.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand2</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</div><div class="line">    <span class="comment">//关联，对哪个Receiver类进行命令处理</span></div><div class="line">    <span class="keyword">private</span> Receiver receiver;</div><div class="line">    <span class="comment">// 构造函数传递接收者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand2</span><span class="params">(Receiver _receiver)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.receiver = _receiver;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 必须实现一个命令</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务处理</span></div><div class="line">        <span class="keyword">this</span>.receiver.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用者Invoker类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Command command;</div><div class="line">    <span class="comment">// 接受命令</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command _command)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.command = _command;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 执行命令</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.command.execute();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 首先声明调用者Invoker</span></div><div class="line">        Invoker invoker = <span class="keyword">new</span> Invoker();</div><div class="line">        <span class="comment">// 定义接收者</span></div><div class="line">        Receiver receiver = <span class="keyword">new</span> ConcreteReceiver1();</div><div class="line">        <span class="comment">// 定义一个发送给接受者的命令</span></div><div class="line">        Command command = <span class="keyword">new</span> ConcreteCommand1(receiver);</div><div class="line">        <span class="comment">// 把命令交给调用者去执行</span></div><div class="line">        invoker.setCommand(command);</div><div class="line">        invoker.action();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>类间解耦：调用者与接收者之间没有任何依赖关系，调用者实现功能时只需要调用Command抽象类的execute方法即可，不需要了解是哪个接收者执行。</li>
<li>可扩展性：Command的子类非常容易扩展。</li>
<li>命令模式结合其他模式会更优秀，例如责任链模式，模板方法模式。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>有N个命令就会有N个Command的子类，这样这个类就会膨胀了。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>只要是你认为是命令的地方就可以采用命令模式。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>根据开发场景要求可以有多个接收者，那就需要用集合类型来封装Command类了。该设计模式最大的优点就是高层模式不需要知道接收者，Perfect！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：作为领导人只要发布命令即可，而不用在发布命令的时候还要去找到实施的人，我相信领导人一定超级高兴，因为实施的人已经包含在命令里了。这就是&lt;strong&gt;命令模式&lt;/strong&gt;。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——中介者模式</title>
    <link href="http://bestlixiang.site/2018/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/02/10/设计模式之禅——中介者模式/</id>
    <published>2018-02-10T10:29:44.000Z</published>
    <updated>2018-02-10T10:31:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：多个对象相互依赖，关系错综复杂，我们经常会感到无从下手，如果这个时候出现一个对象，能够协调各个对象的关系，并且其他对象只要与这个对象交流，那还不是美滋滋，这就是<strong>中介者模式</strong>。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立得改变他们之间的交互。——行为类</strong></p>
<p>它的通用类图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/mediator.png" alt="mediator"></p>
<p>从类图中看，中介者模式由以下几部分组成：</p>
<ul>
<li>Mediator抽象中介者角色：定义统一的接口，用于各同事角色之间的通信。</li>
<li>ConcreteMediator具体中介者角色：依赖于各个同事角色，协调各同事角色实现协作行为。</li>
<li>Colleague同事角色：每一个同事角色都知道中介者角色，而且与其他的同时角色通信的时候，一定要通过中介者角色协作。同事类的行为分两种：一是同事本身的行为（本身行为），二是必须依赖中介者才能完成的行为（依赖方法）。</li>
</ul>
<p>它的通用源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通用抽象中介者</span></div><div class="line"><span class="comment">// 在该抽象类中，我们利用了同事实现类注入，是因为同事类虽然有抽象，但是没有每个同事必须要实现的方法。</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义同事类</span></div><div class="line">    protect ConcreteColleague1 c1;</div><div class="line">    protect ConcreteColleague2 c2;</div><div class="line">    <span class="comment">// 通过getter/setter方法吧同事类注入进来</span></div><div class="line">    ... 省略get、set方法</div><div class="line"></div><div class="line">    <span class="comment">// 中介者模式的业务逻辑</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething1</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething2</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 通用中介者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="title">extend</span> <span class="title">Mediator</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 调用同事类的方法</span></div><div class="line">        <span class="keyword">super</span>.c1.selfMethod1();</div><div class="line">        <span class="keyword">super</span>.c2.selfMethod2();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 调用同事类的方法</span></div><div class="line">        <span class="keyword">super</span>.c1.selfMethod1();</div><div class="line">        <span class="keyword">super</span>.c2.selfMethod2();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象同事类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> Mediator mediator;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator _mediator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mediator = _mediator;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体同事类 1,2 类似</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</div><div class="line">    <span class="comment">// 通过构造函数传递中介者，因为同事类必须要有中介者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleague1</span><span class="params">(Mediator _mediator)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(_mediator);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 自有方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfMethod1</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 处理自己的业务逻辑</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 依赖方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depMethod1</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 自己不能处理的业务逻辑，委托给中介者处理</span></div><div class="line">        <span class="keyword">super</span>.mediator.doSomething1();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>同事类越多，中介者的逻辑就越复杂。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>中介者模式适用于多个对象之间紧密耦合的情况，紧密耦合的标准是：在类图中出现了蜘蛛网状结构。在这种情况下一定要考虑使用中介者模式，这有利于把蜘蛛网梳理为星型结构，使原本复杂混乱的关系变得清晰简单。但是我们需要量力而行，避免中介者过于复杂化。</p>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><ol>
<li>机场调度中心</li>
<li>MVC框架的C协调M和V</li>
<li>媒体网关——中转站</li>
<li>中介服务</li>
</ol>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>可以在如下的情况下尝试使用中介者模式:</p>
<ol>
<li>N个对象之间产生相互的依赖关系（N &gt; 2）</li>
<li>多个对象有依赖关系，但是依赖的行为尚不确定或者有发生改变的可能。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：多个对象相互依赖，关系错综复杂，我们经常会感到无从下手，如果这个时候出现一个对象，能够协调各个对象的关系，并且其他对象只要与这个对象交流，那还不是美滋滋，这就是&lt;strong&gt;中介者模式&lt;/strong&gt;。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——原型模式</title>
    <link href="http://bestlixiang.site/2018/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/02/10/设计模式之禅——原型模式/</id>
    <published>2018-02-10T04:52:31.000Z</published>
    <updated>2018-02-10T04:52:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：由一个正本创建多个副本，并可以进行适当的修改，这就是<strong>原型模式</strong>。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。——创造类</strong></p>
<p>下面是它的通用类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/prototype.png" alt="prototype
"></p>
<p>原型模式的核心是一个clone方法，通过该方法进行对象的拷贝，Java提供了一个Cloneable接口标识这个对象是可拷贝的，在JVM中具有这个标识的对象才<strong>有可能被拷贝</strong>，但是只有在覆盖clone方法之后才<strong>可以被拷贝</strong>。</p>
<p>它的通用代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象原型类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">    <span class="comment">// 覆写父类Object方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        Prototype prototype = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            prototype = (Prototype) <span class="keyword">super</span>.clone();</div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">            <span class="comment">// 异常处理</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> prototype;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体原型类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    Prototype prototype = <span class="keyword">new</span> ConcretePrototype();</div><div class="line">    <span class="comment">// 复制一个对象</span></div><div class="line">    Prototype prototype1 = prototype.clone();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>性能优良。原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好的多，特别是要在一个循环体内产生大量的对象时，</li>
<li>逃避构造函数的约束。是优点也是缺点。</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>资源优化场景。因为类的初始化需要消耗非常多的资源。</li>
<li>性能和安全要求的场景。因为通过new产生一个对象需要非常繁琐的数据准备和访问权限。</li>
<li>一个对象多个修改者。这样次就能避免并发带来数据混乱的问题。</li>
</ol>
<p>原型模式很少单独出现，一般是与工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>构造函数不会执行。因为Object类的clone方法的原理是从内存中以二进制流的方式进行拷贝，重新分配一个内存块。</li>
<li>浅拷贝和深拷贝<ul>
<li>浅拷贝：只拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址。</li>
<li>深拷贝：在浅拷贝的基础上，对私有的类变量进行独立的拷贝。</li>
<li>使用原型模式时，引用的成员变量必须满足两个条件才不会被拷贝：一是类的成员变量，二是必须是一个可变的引用对象。</li>
</ul>
</li>
<li>对象的clone和对象内的final关键字是有冲突的。要使用clone方法，类的成员变量上不要增加final关键字。</li>
</ol>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>原型模式先产生一个包含大量信息的类，然后可以拷贝出副本，修正细节信息，建立了一个完整的个性对象。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：由一个正本创建多个副本，并可以进行适当的修改，这就是&lt;strong&gt;原型模式&lt;/strong&gt;。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
