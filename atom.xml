<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rex note</title>
  <subtitle>雨过，云过</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bestlixiang.site/"/>
  <updated>2017-12-06T03:00:51.000Z</updated>
  <id>http://bestlixiang.site/</id>
  
  <author>
    <name>rex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解JVM_9_类加载器</title>
    <link href="http://bestlixiang.site/2017/12/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-9-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://bestlixiang.site/2017/12/06/深入理解JVM-9-类加载器/</id>
    <published>2017-12-06T02:59:56.000Z</published>
    <updated>2017-12-06T03:00:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：之前一直在说类加载，类加载就需要类加载器，类加载最初是为了满足Java Applet，现在基本已经死掉了，但是类加载却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为Java体系中一块重要的基石，可谓失之桑榆，收之东隅。<a id="more"></a></p>
<h1 id="什么是类加载器？"><a href="#什么是类加载器？" class="headerlink" title="什么是类加载器？"></a>什么是类加载器？</h1><p>虚拟机设计团队把类加载阶段的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己去决定如何去获取所需要的类，实现这个动作的代码模块称为“类加载器”。</p>
<h1 id="同一个Class文件，不同的类"><a href="#同一个Class文件，不同的类" class="headerlink" title="同一个Class文件，不同的类"></a>同一个Class文件，不同的类</h1><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。换个说法：比较两个类是否“相等”，只是在这两个类是由同一个类加载器加载的前提下才有意义，如果这两个类源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<p>这里的相等包括：代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法返回结果，下面的代码展示了不同的类加载器对instanceof关键字运算的结果的影响。(下面的代码属于破坏双亲委派模型，只是为了验证类的命名空间)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</div><div class="line"></div><div class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</div><div class="line">                    <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</div><div class="line">                    is.read(b);</div><div class="line">                    <span class="keyword">return</span> defineClass(name,b,<span class="number">0</span>,b.length);</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Object obj = myLoader.loadClass(<span class="string">"com.todorex.demo.ClassLoaderTest"</span>).newInstance();</div><div class="line"></div><div class="line">        System.out.println(obj.getClass());</div><div class="line"></div><div class="line">        System.out.println(obj <span class="keyword">instanceof</span> com.todorex.demo.ClassLoaderTest );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class com.todorex.demo.ClassLoaderTest</div><div class="line">false</div></pre></td></tr></table></figure></p>
<p>这里的false就证明了两个类虽然来自于同一个Class文件，但是由于使用的类加载器不同，就依然是两个独立的类。</p>
<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><h2 id="类加载器的类型"><a href="#类加载器的类型" class="headerlink" title="类加载器的类型"></a>类加载器的类型</h2><h3 id="Java虚拟机角度"><a href="#Java虚拟机角度" class="headerlink" title="Java虚拟机角度"></a>Java虚拟机角度</h3><ol>
<li>启动类加载器，它本身是由C++语言实现，或者底层的关键方法是用C实现的。</li>
<li>所有其他类加载器，这些类加载器都由Java语言实现。</li>
</ol>
<h3 id="Java开发人员角度"><a href="#Java开发人员角度" class="headerlink" title="Java开发人员角度"></a>Java开发人员角度</h3><ol>
<li>启动类加载器：这个类加载器负责将存放在<java_home>\lib目录中的，或者被-Xbootclasspath参数所指定的路径找那个的，并且是虚拟机识别的（按照文件名识别的）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接使用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，直接使用null即可。（不知道怎么用，知道的大佬请告知！！！！）</java_home></li>
<li>扩展类加载器：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<java_home>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以使用扩展类加载器。</java_home></li>
<li>应用程序类加载器：这个类加载器由sun.misc.Launcher$AppClassLoader实现，也称系统类加载器。它负责加载用户所指定的类路径java -classpath或-Djava.class.path的所有类，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ol>
<h2 id="类加载器的双亲委派模型"><a href="#类加载器的双亲委派模型" class="headerlink" title="类加载器的双亲委派模型"></a>类加载器的双亲委派模型</h2><h3 id="模型图"><a href="#模型图" class="headerlink" title="模型图"></a>模型图</h3><p><img src="http://o6plzvjf2.bkt.clouddn.com/image/parentsDelegationModel.jpg" alt="Parents Delegation Model"></p>
<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里的类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。（组合就是在一个类中调用另一个类的代码）</p>
<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>我相信这张图最清楚了：</p>
<p><img src="http://static.zybuluo.com/Rico123/8ty4pk8xgubfhq123dhxg68m/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E7%B1%BB%E7%9A%84%E8%BF%87%E7%A8%8B" alt="双亲委派模型工作流程"></p>
<p>我们可以由图看到以下过程：</p>
<ol>
<li>自底向上检查类是否已经加载，若已加载，直接返回。</li>
<li>若所有父类都没有加载该类，则自顶向下尝试加载该类。</li>
<li>如果加载不成功，则抛出ClassNotFoundException异常。</li>
</ol>
<p>我们可以从代码看看他是怎么实现的？</p>
<ol>
<li>先看ClassLoader函数的loadClass函数<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</div><div class="line">      <span class="keyword">throws</span> ClassNotFoundException</div><div class="line">  &#123;</div><div class="line">      <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</div><div class="line">          <span class="comment">// 先从缓存查找该class对象，找到就不用重新加载</span></div><div class="line">          Class&lt;?&gt; c = findLoadedClass(name);</div><div class="line">          <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line">              <span class="keyword">try</span> &#123;</div><div class="line">                  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">                      <span class="comment">//如果找不到，则委托给父类加载器去加载</span></div><div class="line">                      c = parent.loadClass(name, <span class="keyword">false</span>);</div><div class="line">                  &#125; <span class="keyword">else</span> &#123;</div><div class="line">                  <span class="comment">//如果没有父类，则委托给启动加载器去加载</span></div><div class="line">                      c = findBootstrapClassOrNull(name);</div><div class="line">                  &#125;</div><div class="line">              &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                  <span class="comment">// ClassNotFoundException thrown if class not found</span></div><div class="line">                  <span class="comment">// from the non-null parent class loader</span></div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">                  <span class="comment">// If still not found, then invoke findClass in order</span></div><div class="line">                  <span class="comment">// 如果都没有找到，则通过自定义实现的findClass去查找并加载</span></div><div class="line">                  c = findClass(name);</div><div class="line"></div><div class="line">                  <span class="comment">// this is the defining class loader; record the stats</span></div><div class="line">                  sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</div><div class="line">                  sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</div><div class="line">                  sun.misc.PerfCounter.getFindClasses().increment();</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (resolve) &#123;<span class="comment">//是否需要在加载时进行解析</span></div><div class="line">              resolveClass(c);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> c;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>从该函数我们可以得知双亲委派模型会先递归去查找父加载器是否已经加载过该类了。如果父加载器都没有加载过该类，则开始调用fandClass<br>()尝试去加载该类。由于启动类加载器不可知，我们可以去看看扩展类加载器的findClass()。我们可以看到下面的类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/image/jpg/ExtClassLoader.jpg" alt="ExtClassLoader"></p>
<p>我接着我想去看看ExtClassLoader类里面的findClass()方法，结果发现没有，只要去他的父类URLClassLoader去找找，还好找到了，可以看看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)</div><div class="line">    <span class="keyword">throws</span> ClassNotFoundException</div><div class="line">&#123;</div><div class="line">    <span class="keyword">final</span> Class&lt;?&gt; result;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        result = AccessController.doPrivileged(</div><div class="line">            <span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</div><div class="line">                <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">                    String path = name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>);</div><div class="line">                    Resource res = ucp.getResource(path, <span class="keyword">false</span>);</div><div class="line">                    <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                             <span class="comment">//defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象</span></div><div class="line">                            <span class="keyword">return</span> defineClass(name, res);</div><div class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;, acc);</div><div class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</div><div class="line">        <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实AppClassLoader的findClass()也是继承自URLCLassLoader，所以都是一样的，我们再结合最开始的loadClass()就可以很好的理解了上面双亲委派模型的工作流程了。</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>java随着它的类加载一起具备了一种带有优先级的层次关系，它能保证一个类在程序中各种类加载器环境中都是同一个类。</p>
<h3 id="双亲委派模型的“双亲”"><a href="#双亲委派模型的“双亲”" class="headerlink" title="双亲委派模型的“双亲”"></a>双亲委派模型的“双亲”</h3><p>在Java虚拟机英文文章里双亲委派模型的英文是Parent-Delegation Model，不知道为什么中文翻译会称他为双亲委派模型，可能是他一般都会找到一个爸爸去委托去处理吧。</p>
<h1 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h1><p>目前为止，双亲委派模型主要出现过3次较大的“被破坏”的情况。</p>
<ol>
<li>在JDK1.2之前，新建加载器都是通过重写loadClass()方法来区分不同的加载器,以及修改加载逻辑，这样就破坏了双亲委派模型的向上寻找父加载器去加载的规范，在JDK1.2之后为了向前兼容，ClassLoader添加了新的protect方法findCLass()方法，从而实现了在双亲委派模型上实现加载逻辑的修改。</li>
<li>线程上下文类加载器，如JNDI服务(没用过)</li>
<li>实现动态性，如OSGi(没用过)</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有时候分析东西查看源码是必要的，还要利用一些工具去分析他们的继承关系。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入理解Java虚拟机》</li>
<li><a href="http://blog.csdn.net/javazejian/article/details/73413292" target="_blank" rel="external">深入理解Java类加载器(ClassLoader)</a></li>
<li><a href="http://blog.csdn.net/justloveyou_/article/details/72217806" target="_blank" rel="external">深入理解Java类加载器(一)：Java类加载原理解析</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：之前一直在说类加载，类加载就需要类加载器，类加载最初是为了满足Java Applet，现在基本已经死掉了，但是类加载却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为Java体系中一块重要的基石，可谓失之桑榆，收之东隅。
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="jvm" scheme="http://bestlixiang.site/tags/jvm/"/>
    
      <category term="jdk" scheme="http://bestlixiang.site/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_8_虚拟机类加载机制</title>
    <link href="http://bestlixiang.site/2017/12/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-8-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://bestlixiang.site/2017/12/02/深入理解JVM-8-虚拟机类加载机制/</id>
    <published>2017-12-02T07:22:11.000Z</published>
    <updated>2017-12-02T08:04:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在Class文件中描述的各种信息最终都需要加载到虚拟机之中之后才能运行和使用。而虚拟机如何加载这些Class文件？Class文件中的信息进入到虚拟机后会发生什么变化？<a id="more"></a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>虚拟机的类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p>
<p>C/C++和Java链接的不同：</p>
<ol>
<li>C/C++：在编译时完成链接工作；降低了运行时的性能开销，但是也降低了运行时的灵活性。</li>
<li>Java：类型的加载、链接和初始化过程都是在程序运行期间完成的；增加了运行时的性能开销，但是增强了运行时的灵活性，使Java变成了可以动态扩展的语言。这里的动态扩展可以分为两点：<ul>
<li>动态加载：用户可以通过Java预定义的或者自定义的类加载，让一个本地的应用程序可以在运行时在从网络或其他地方加载一个二进制流作为程序代码的一部分。</li>
<li>动态链接：如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类。</li>
</ul>
</li>
</ol>
<h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/image/classloading1.jpg" alt="classloading1"></p>
<p>其中链接包括下面三个部分：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/image/classloading2.jpg" alt="classloading2"></p>
<p>生命周期中加载、验证、准备、初始化和卸载这5个阶段顺序是确定的，但是又是可以互相交叉混合式进行的。</p>
<h2 id="类的初始化时机"><a href="#类的初始化时机" class="headerlink" title="类的初始化时机"></a>类的初始化时机</h2><p>什么情况下需要开始类加载过程的第一阶段：加载？Java虚拟机规范没有进行强制约束，但是对初始化阶段，虚拟机规范则是严格规定了<strong>有且只有</strong>5种情况必须立即对类“初始化”。</p>
<ol>
<li>遇到new、getstatic、putstatic或者invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要触发其初始化，生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段（被final修饰并且已在编译器把结果放在常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包的时候对类进行反射调用的时候，如果类没有进行过初始化，则需要触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要制定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个类。</li>
<li>如果一个java.lang.invoke.MethodHandle实例解析结果是REF_getStaic,REF_putStatic,REF_invokeStatic的方法句柄，并且这个句柄所对应的类没有进行过初始化，则需要先触发其初始化。（还没用过）</li>
</ol>
<p>上面5种场景中的行为成为对一个类的<strong>主动引用</strong>，除此之外，所有应用类的方式都不会触发初始化，成为<strong>被动引用</strong>。下面是几个被动引用的场景：</p>
<ol>
<li>通过子类引用父类的静态字段，不会导致子类初始化。</li>
<li>通过数组来定义引用类，不会触发此类的初始化。</li>
<li>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，不会触发该类的初始化，因为在编译阶段通过常量传播优化，已经将其他类的常量存入到调用类的常量池了。</li>
</ol>
<p>说一点接口与类初始化世时机的不同：在有且只有的5条中的第3条,当一个类在初始化时，要求其父类全部都已经初始化过了，但是接口在初始化时，不要求其父接口全部都完成了初始化，只有真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p>
<h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><p>Java虚拟机中类加载的全过程为：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/image/classloading3.jpg" alt="classloading3"></p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><h3 id="虚拟机在加载阶段要干什么"><a href="#虚拟机在加载阶段要干什么" class="headerlink" title="虚拟机在加载阶段要干什么"></a>虚拟机在加载阶段要干什么</h3><ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个类的字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<h3 id="二进制字节流的来源"><a href="#二进制字节流的来源" class="headerlink" title="二进制字节流的来源"></a>二进制字节流的来源</h3><ol>
<li>从ZIP包中读取，最终成为了日后JAR、EAR、WAR格式的基础。</li>
<li>从网络中获取，这个场景最典型的应用就是Applet（没用过）。</li>
<li>运行时计算生成，这个场景使用的最多的就是动态代理技术，生成代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。</li>
</ol>
<h3 id="加载阶段的注意点"><a href="#加载阶段的注意点" class="headerlink" title="加载阶段的注意点"></a>加载阶段的注意点</h3><ol>
<li>非数组类的加载阶段是开发人员可控性最强的，加载阶段既可以使用系统提供的引导类加载器，也可以使用用户自定义的类加载器。</li>
<li>数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的，但是最终还是要靠类加载器是创建数组类里面的元素类型，每个数组都会在加载数组元素的类加载器的类名称空间上被标识。</li>
<li>Java虚拟机规范没有规定类在方法区的具体数据结构，也没有规定生成的Class对象存储在哪里，对于HotSpot虚拟机而言，它被存放在方法区里面，jdk1.8以后应该在直接内存中吧。</li>
<li>加载阶段与连接阶段的部分内容（一部分字节码文件格式验证工作）是交叉进行的。</li>
</ol>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="验证目的"><a href="#验证目的" class="headerlink" title="验证目的"></a>验证目的</h3><p>由于Class文件并不一定要求用Java源码编译而来，可以使用任何途径产生，所以安全性得不到保证，而验证的目的就是为了确保Class文件的字节流包含的信息符合虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h3><ol>
<li><p>文件格式验证</p>
<p> 主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上负荷一个Java类型信息的要求，这个阶段的验证是基于二进制字节流进行的，只有通过这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字符流。</p>
</li>
<li><p>元数据验证</p>
<p> 主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</p>
</li>
<li><p>字节码验证</p>
<p> 主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</p>
</li>
<li><p>符号引用验证</p>
<p> 发生在解析阶段（将符号引用转化为直接引用），主要目的是确保解析动作能正常执行。</p>
</li>
</ol>
<h3 id="调优的地方"><a href="#调优的地方" class="headerlink" title="调优的地方"></a>调优的地方</h3><p>如果所运行的代码都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为<strong>类变量</strong>分配内存并设置<strong>类变量</strong>初始值的阶段，但是这里的初始值需要注意一下：</p>
<ol>
<li>通常情况：初始值是数据类型的零值</li>
<li>类变量有fianl关键字修饰：初始值是ConstantValue属性所指定的值</li>
</ol>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。这里解释一下直接引用和符号引用：</p>
<ol>
<li>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量。它的字面量形式明确定义在Java虚拟机规范的Class文件格式中。符号引用于虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</li>
<li>直接引用：它可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局相关，有了直接引用，那么引用的目标必定已经在内存中存在。</li>
</ol>
<p>虚拟机规范中并未规定解析阶段发生的具体时间。所以虚拟机可以根据需要来判断到底是在类被加载器加载时就对常量池的符号引用进行解析，还是等到一个符号引用被使用前再去解析它。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>类初始化时类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化变量和其他资源，从另一个角度来表达：初始化阶段是执行类构造器clinit()方法的过程。下面是clinit()方法的注意点：</p>
<ol>
<li><p>clinit()方法是由编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和静态语句块中语句合并产生的，收集的顺序是有语句在源文件出现的顺序决定的，这里有很特别的一点：<strong>静态语句块中只能访问到定义在静态语句块之前的变量，定义在之后的变量，在前面的静态语句块可以赋值，但是不能访问</strong>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        i =<span class="number">0</span>; <span class="comment">//正常编译</span></div><div class="line">        System.out.println(i);  <span class="comment">//提示“非法向前引用”</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i =<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>clinit()方法不需要显式地调用父类构造器，虚拟机会保证在子类的clinit()方法执行前，父类的clinit()方法已经执行完毕。</p>
</li>
<li>由于父类的clinit()方法先执行，所以父类定义的静态语句块要优先于子类的变量赋值操作。</li>
<li>虚拟机会保证一个类的clinit()方法在多线程中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其他线程都要阻塞等待，直到活动线程执行clinit()方法完毕。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>类加载的5个阶段都很重要，对理解对象的创建过程有了更好的理解。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入理解Java虚拟机》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在Class文件中描述的各种信息最终都需要加载到虚拟机之中之后才能运行和使用。而虚拟机如何加载这些Class文件？Class文件中的信息进入到虚拟机后会发生什么变化？
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="jvm" scheme="http://bestlixiang.site/tags/jvm/"/>
    
      <category term="jdk" scheme="http://bestlixiang.site/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_7_探秘类文件</title>
    <link href="http://bestlixiang.site/2017/12/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-7-%E6%8E%A2%E7%A7%98%E7%B1%BB%E6%96%87%E4%BB%B6/"/>
    <id>http://bestlixiang.site/2017/12/01/深入理解JVM-7-探秘类文件/</id>
    <published>2017-12-01T12:52:36.000Z</published>
    <updated>2017-12-01T13:05:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：java代码编译的结果从本地机器码转变为字节码，并且生成了类文件，那么这个类文件里面是什么东西呢？<a id="more"></a></p>
<h1 id="JVM的无关性"><a href="#JVM的无关性" class="headerlink" title="JVM的无关性"></a>JVM的无关性</h1><p>一般提到Java的好处，其中必定有一条是平台无关性，但是这个太狭隘了，其实它有两点无关性。</p>
<h2 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h2><p>Java在刚刚诞生之时就有一个著名的宣传口号：“一次编写，到处运行（Write Once, Run Anywhere）”。“与平台无关”的理想最终实现在操作系统的应用层上：其实就是Java虚拟机了，他可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写，到处运行”。</p>
<h2 id="语言无关性"><a href="#语言无关性" class="headerlink" title="语言无关性"></a>语言无关性</h2><p>目前已经一大批能够在JVM运行语言了，就我自己知道并且使用过就有Groovy、Jython、Scala等。实现语言无关性的基础仍然是虚拟机和字节码存储格式。其他语言通过自己的编译把程序代码编程成符合Java虚拟机规范的Class文件即可。</p>
<h1 id="类文件的结构"><a href="#类文件的结构" class="headerlink" title="类文件的结构"></a>类文件的结构</h1><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑排列在Class文件之中，中间没有任何分隔符。Class文件只有两种数据类型：无符号数和表</p>
<ul>
<li>无符号数：以u1，u2，u4，u8来分别代表1个字节，2个字节，4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数值量或者按照UTF-8编码构成字符串值。</li>
<li>表：它是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表习惯地以“_info”结尾。</li>
</ul>
<p>整个Class文件本质上就是一张表，它由下表所示的数据项构成。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u4</td>
<td>魔数</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>次版本号</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>主版本号</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>常量数量</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>常量池</td>
<td>常量数量-1</td>
</tr>
<tr>
<td>u2</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>类索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>父类索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>接口数量</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>接口索引集合</td>
<td>接口数量</td>
</tr>
<tr>
<td>u2</td>
<td>字段数量</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>字段表</td>
<td>字段数量</td>
</tr>
<tr>
<td>u2</td>
<td>方法数量</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>方法表</td>
<td>方法数量</td>
</tr>
<tr>
<td>u2</td>
<td>属性数量</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>属性表</td>
<td>属性数量</td>
</tr>
</tbody>
</table>
<p>接下里稍微详细看看上面的数据：</p>
<p>不过按例子来吧，下面是一个简单的Java类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.todorex.demo;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> m+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先编译这个类得到TestClass.class文件，打开它可以下面的16进制数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">cafe babe 0000 0034 0013 0a00 0400 0f09</div><div class="line">0003 0010 0700 1107 0012 0100 016d 0100</div><div class="line">0149 0100 063c 696e 6974 3e01 0003 2829</div><div class="line">5601 0004 436f 6465 0100 0f4c 696e 654e</div><div class="line">756d 6265 7254 6162 6c65 0100 0369 6e63</div><div class="line">0100 0328 2949 0100 0a53 6f75 7263 6546</div><div class="line">696c 6501 000e 5465 7374 436c 6173 732e</div><div class="line">6a61 7661 0c00 0700 080c 0005 0006 0100</div><div class="line">1a63 6f6d 2f74 6f64 6f72 6578 2f64 656d</div><div class="line">6f2f 5465 7374 436c 6173 7301 0010 6a61</div><div class="line">7661 2f6c 616e 672f 4f62 6a65 6374 0021</div><div class="line">0003 0004 0000 0001 0002 0005 0006 0000</div><div class="line">0002 0001 0007 0008 0001 0009 0000 001d</div><div class="line">0001 0001 0000 0005 2ab7 0001 b100 0000</div><div class="line">0100 0a00 0000 0600 0100 0000 0600 0100</div><div class="line">0b00 0c00 0100 0900 0000 1f00 0200 0100</div><div class="line">0000 072a b400 0204 60ac 0000 0001 000a</div><div class="line">0000 0006 0001 0000 0009 0001 000d 0000</div><div class="line">0002 000e</div></pre></td></tr></table></figure></p>
<p>然后用javap 解析TestClass.class文件，得到：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">Classfile /Users/rex/IdeaProjects/JVMTest/src/com/todorex/demo/TestClass.class</div><div class="line">  Last modified 2017-12-1; size 292 bytes</div><div class="line">  MD5 checksum 337a51d3bebe0e9a82142a352eb0977e</div><div class="line">  Compiled from "TestClass.java"</div><div class="line">public class com.todorex.demo.TestClass</div><div class="line">  minor version: 0</div><div class="line">  major version: 52</div><div class="line">  flags: ACC_PUBLIC, ACC_SUPER</div><div class="line">Constant pool:</div><div class="line">   #1 = Methodref          #4.#15         // java/lang/Object."&lt;init&gt;":()V</div><div class="line">   #2 = Fieldref           #3.#16         // com/todorex/demo/TestClass.m:I</div><div class="line">   #3 = Class              #17            // com/todorex/demo/TestClass</div><div class="line">   #4 = Class              #18            // java/lang/Object</div><div class="line">   #5 = Utf8               m</div><div class="line">   #6 = Utf8               I</div><div class="line">   #7 = Utf8               &lt;init&gt;</div><div class="line">   #8 = Utf8               ()V</div><div class="line">   #9 = Utf8               Code</div><div class="line">  #10 = Utf8               LineNumberTable</div><div class="line">  #11 = Utf8               inc</div><div class="line">  #12 = Utf8               ()I</div><div class="line">  #13 = Utf8               SourceFile</div><div class="line">  #14 = Utf8               TestClass.java</div><div class="line">  #15 = NameAndType        #7:#8          // "&lt;init&gt;":()V</div><div class="line">  #16 = NameAndType        #5:#6          // m:I</div><div class="line">  #17 = Utf8               com/todorex/demo/TestClass</div><div class="line">  #18 = Utf8               java/lang/Object</div><div class="line">&#123;</div><div class="line">  public com.todorex.demo.TestClass();</div><div class="line">    descriptor: ()V</div><div class="line">    flags: ACC_PUBLIC</div><div class="line">    Code:</div><div class="line">      stack=1, locals=1, args_size=1</div><div class="line">         0: aload_0</div><div class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</div><div class="line">         4: return</div><div class="line">      LineNumberTable:</div><div class="line">        line 6: 0</div><div class="line"></div><div class="line">  public int inc();</div><div class="line">    descriptor: ()I</div><div class="line">    flags: ACC_PUBLIC</div><div class="line">    Code:</div><div class="line">      stack=2, locals=1, args_size=1</div><div class="line">         0: aload_0</div><div class="line">         1: getfield      #2                  // Field m:I</div><div class="line">         4: iconst_1</div><div class="line">         5: iadd</div><div class="line">         6: ireturn</div><div class="line">      LineNumberTable:</div><div class="line">        line 9: 0</div><div class="line">&#125;</div><div class="line">SourceFile: "TestClass.java"</div></pre></td></tr></table></figure></p>
<h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><ol>
<li>每个Class文件的头4个字节成为魔数</li>
<li>使用魔数来进行身份识别（文件类别），因为如果使用文件名来识别，安全性太低，由于文件名可以随意改动。</li>
<li>Class文件的魔数的获得就有“浪漫气息”，值为0xcafebabe,上面16进制文件也可以看到。这让自己想起了高中用的三星手机打开qq就是一杯咖啡的标志。</li>
</ol>
<h2 id="Class文件的版本"><a href="#Class文件的版本" class="headerlink" title="Class文件的版本"></a>Class文件的版本</h2><p>接下来第5，6个字节显示的是次版本号，7，8字节显示的是主版本号。</p>
<p>高版本的JDK可以向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>在版本号之后的是常量池入口。</p>
<ol>
<li>常量池是Class文件结构中与其他项目关联最大的数据类型，也是占Class文件空间最大的数据项目之一。</li>
<li>常量池常量的数据不是固定的，在最前面的Class文件组成可以看到有一个常量数量项，这个容量计数是从1而不是0开始的，比如上面的十六进制的值为0x0013(19)就代表有18个常量。</li>
<li><p>常量池主要存放两大类变量</p>
<ul>
<li>字面量：文本字符串、声明为final的常量值等</li>
<li>符号引用：（编译原理的概念）<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
</ul>
</li>
<li><p>常量池的每一项常量都是表，常量的顺序可以参照javap解析出来的常量顺序，在JDK1.7以后共有14种不同类型的表，他们共同点是表的第一位是一个u1类型的标志位（tag），具体的标志对应的类型参照书《深入理解Java虚拟机》。这里提一下CONSTANT_UTF8_info这个表：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>bytes</td>
<td>length</td>
</tr>
</tbody>
</table>
<pre><code>length值说明了UTF-8编码的字符串长度是多少字节，他后面跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。而u2最大值是65535，所以说如果Java程序如果定义了超过64KB（大约）英文字符的变量或者方法名，将无法编译。
</code></pre><ol>
<li>UTF-8缩略编码和UTF-8编码的区别：UTF-8编码都是使用3个字节编码，而UTF-8缩略编码可以使用1或2或3个字节编码。</li>
</ol>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等，访问标志一共有16个标志位可以使用，当前只定义了8个。</p>
<h2 id="类索引、父类索引、接口索引集合"><a href="#类索引、父类索引、接口索引集合" class="headerlink" title="类索引、父类索引、接口索引集合"></a>类索引、父类索引、接口索引集合</h2><ol>
<li>类索引、父类索引都是u2类型的数据，类索引、父类索引都是指向一个CONSTANT_Class_info的类描述符常量</li>
<li>接口索引集合是一组u2类型的数据的集合，它入口的第一项是u2的接口计数器，后面就是具体接口索引</li>
<li>Class文件有这三项数据来确定这个类的继承关系</li>
</ol>
<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>接下来是字段表，字段表用于描述接口或者类中声明的变量，包括类级变量以及实例级变量，不包括方法内部声明的局部变量。我们看一下一个字段表的构成：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>简单名称索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>属性数量</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>属性表</td>
<td>属性数量</td>
</tr>
</tbody>
</table>
<p>根据上表我们解析一下其中的含义：</p>
<ol>
<li>访问标志：它和之前的访问标志很类似。</li>
<li>简单名称索引：它指向一个CONSTANT_UTF8_info类型的常量，这里面存储了本字段的名字信息，像javap解析后的第5个常量m。</li>
<li>描述符索引：用来描述字段的数据类型，像javap解析后的第6个常量I,代表了基本类型int</li>
<li>属性表（可能有ConstantValue表</li>
</ol>
<p>下面是字符表的注意点：</p>
<ol>
<li>字段表集合不会列出从超类或者父接口继承而来的字段。</li>
<li>字段表有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加执行外部类实例的字段。（不懂，大佬请指教）</li>
<li>Java语言中字段是无法重载的，名称必须不一样，但是对于字节码来说，如果两个字段的描述符不一致，那么字段重名是合法的。</li>
</ol>
<h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>接下来是方法表，方法表的内容和字段表几乎完全一致。其中坑顶也看一下方法表的构成：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>简单名称索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>属性数量</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>属性表</td>
<td>属性数量</td>
</tr>
</tbody>
</table>
<p>这里解释一下和字段表不一样的地方</p>
<ol>
<li>简单名称索引：它指向一个CONSTANT_UTF8_info类型的常量，这里面存储了本字段的名字信息，像javap解析后的第11个常量inc。</li>
<li>描述符索引：它的作用是用来描方法的参数列表（包括数量、类型以及顺序）和返回值，像javap解析后的第12个常量()I,表示的就是一个返回值为int的方法。</li>
<li>属性表：这里肯定存放了Code属性表（方法里的Java代码）</li>
</ol>
<p>下面是方法表的注意点：</p>
<ol>
<li>如果父类方法在子类没有被重写，方法表集合中就不会出现来自父类的方法信息。</li>
<li>可能会出现由编译器自动添加的方法，最典型的有类构造器“<clinit>”方法和实例构造器“<init>”方法，就像javap解析后的第11个常量<init>。</init></init></clinit></li>
<li>在Java语言中，要重载一个方法，需要相同的简单名称和与原方法不同的Java代码的方法特征签名，这里需要解释一下Java特征签名和JVM特征签名：<ul>
<li>Java特征签名：方法名称、参数顺序</li>
<li>JVM特征签名：Java特征签名、方法返回值以及受查异常表</li>
</ul>
</li>
</ol>
<h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>最后就是属性表集合了，在Class文件、字段表、方法表都可以携带自己的属性表集合，以及用于描述某些场景专有的信息。属性表集合不要求各个属性具有严格的顺序，并且只要不与已有属性名重复就好。</p>
<p>上面程序的例子出现过几个属性表：Code、LineNumberTable、SourceFile、ConstantValue，接下来我们详细说一下：</p>
<h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h3><p>Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内，Code属性出现在方法表属性集合之中，我们先看看Code属性表的结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>属性名索引</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>属性长度</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>操作数栈深度的最大值</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>局部变量表所需的存储空间</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>Java方法代码字节码指令长度</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>Java方法代码字节码</td>
<td>Java方法代码字节码指令长度</td>
</tr>
<tr>
<td>u2</td>
<td>显式异常表长度</td>
<td>1</td>
</tr>
<tr>
<td>exception_info</td>
<td>显式异常表</td>
<td>显式异常表长度</td>
</tr>
<tr>
<td>u2</td>
<td>属性个数</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>属性表</td>
<td>属性个数</td>
</tr>
</tbody>
</table>
<p>接下来我们说明一下几个关键项：</p>
<ol>
<li>属性名索引：它是一项指向CONSTANT_UTF8_info型的索引，常量值固定为“Code”，就像上面javap解析出来的常量池的第9个。</li>
<li>属性长度：固定为整个属性表长度减去6个字节。</li>
<li>操作数栈深度的最大值：在方法执行的任意时刻，操作数栈都不会超过这个深度，虚拟机运行的时候需要根据这个值来分配栈栈中的操作数栈深度。</li>
<li>局部变量表所需的存储空间：它的单位是Slot，局部变量表存储了方法参数（包括<strong>实例方法</strong>中的隐藏参数this）、显示异常处理器的参数（try-catch检查的异常）、方法体中定义的局部变量，Javac编译器会根据变量的作用域来分配Slot，然后计算出需要的存储空间大小。</li>
<li><p>Java方法代码字节码指令长度和Java方法代码字节码：存储了Java源程序编译后生成的字节码指令，目前Java虚拟机规范已经定义了约200条编码值对应的指令含义。</p>
<p> PS：如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义以及其他信息）两部分，那么在整个Class文件，Code属性用来描述代码，所有其他数据项目都用于描述元数据。</p>
</li>
<li>显式异常表：用于显示try-catch代码块要检查的异常</li>
</ol>
<h3 id="LineNumberTable"><a href="#LineNumberTable" class="headerlink" title="LineNumberTable"></a>LineNumberTable</h3><p>它的使用位置是在Code属性，用于描述Java源码行号与字节码行号之间的对应关系，当抛出异常的时候堆栈会显示出错的行号。</p>
<h3 id="SourceFile"><a href="#SourceFile" class="headerlink" title="SourceFile"></a>SourceFile</h3><p>它的使用位置是类文件，用于记录生成这个Class文件的源码文件名称，当抛出异常的时候会显示出错代码所属的文件名。</p>
<h3 id="ConstantValue"><a href="#ConstantValue" class="headerlink" title="ConstantValue"></a>ConstantValue</h3><p>它的使用位置是字段表，作用是通知虚拟机自动为静态变量赋值，只有static关键字修饰的变量（类变量）才可以使用这项属性，虚拟机对于类变量和实例变量赋值的方式有所不用。</p>
<ol>
<li>实例变量：在实例构造器<init>方法中进行</init></li>
<li>类变量：在类构造器<clinit>方法中或者使用ConstantValue属性</clinit></li>
</ol>
<p>目前Sun Javac编译器的选择是：如果同时使用final和static来修饰一个变量，并且这个常量的数据类型是基本类型或者String类型，就生成ConstantValue属性来进行初始化，如果这个变量没有被final修饰，或者并非基本类型或者字符串，则将会选择在<clinit>方法中进行初始化。</clinit></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面的分析，我们一定能清楚的知道Class文件是什么以及Class文件包含什么东西，再也不怕了！！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入理解Java虚拟机》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：java代码编译的结果从本地机器码转变为字节码，并且生成了类文件，那么这个类文件里面是什么东西呢？
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="jvm" scheme="http://bestlixiang.site/tags/jvm/"/>
    
      <category term="jdk" scheme="http://bestlixiang.site/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_6_JVM调优实战</title>
    <link href="http://bestlixiang.site/2017/11/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-6-JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/"/>
    <id>http://bestlixiang.site/2017/11/30/深入理解JVM-6-JVM调优实战/</id>
    <published>2017-11-30T13:46:19.000Z</published>
    <updated>2017-11-30T13:48:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：带着浅尝基本的Java诊断工具就这样把《深入理解Java虚拟机》的调优部分看完了，似懂非懂，我想待自己经历过一次性能调优，结合自身经历再来好好总结一番吧。<a id="more"></a></p>
<h1 id="此处暂时省略一万字。。。"><a href="#此处暂时省略一万字。。。" class="headerlink" title="此处暂时省略一万字。。。"></a>此处暂时省略一万字。。。</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：带着浅尝基本的Java诊断工具就这样把《深入理解Java虚拟机》的调优部分看完了，似懂非懂，我想待自己经历过一次性能调优，结合自身经历再来好好总结一番吧。
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="jvm" scheme="http://bestlixiang.site/tags/jvm/"/>
    
      <category term="jdk" scheme="http://bestlixiang.site/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_5_内存分配策略</title>
    <link href="http://bestlixiang.site/2017/11/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-5-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://bestlixiang.site/2017/11/30/深入理解JVM-5-内存分配策略/</id>
    <published>2017-11-30T06:31:15.000Z</published>
    <updated>2017-11-30T06:33:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：一直在说Java的垃圾回收，既然有回收，那么当然会有分配。<a id="more"></a></p>
<p>Java技术体系中所提倡的自动内存管理可以归结为自动化地解决了两个问题：</p>
<ol>
<li>给对象分配内存</li>
<li>回收分配给对象的内存</li>
</ol>
<p>之前垃圾回收已经讲了很多，接下来我们详细地来看看内存分配</p>
<h1 id="内存分配总说"><a href="#内存分配总说" class="headerlink" title="内存分配总说"></a>内存分配总说</h1><p>对象的内存分配，主要是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程的分配缓冲，将按线程优先在TLAB上分配，少数情况下（大对象）也可能直接分配在老年代中，分配的规则不是百分百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p>
<h1 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h1><ol>
<li>大多数情况，对象在新生代Eden区分配。当Eden区没有足够空间进行分配时，虚拟机会发起一次MinorGC。</li>
<li>当MinorGC发现复制的对象大于Survivor区时，会通过分配担保机制提前转移到老年代中。</li>
</ol>
<h1 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h1><p>所谓大对象是指需要大量连续内存空间的Java对象，如数组。</p>
<p>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配，避免了在Eden区及Survivor区之间发生大量的内存复制。（新生代采用复制算法收集内存）</p>
<h1 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h1><p>虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设置为1.对象在Survivor中每度过一次MinorGC，年龄就增加一岁，当他的年龄达到一定程度（默认15岁），就将被晋升到老年代中。对象的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。</p>
<h1 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h1><p>虚拟机不是永远要求对象的年龄必须达到MaxTenuringThreshold才晋升到老年代，如果Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入老年代。</p>
<h1 id="空间分配担保策略"><a href="#空间分配担保策略" class="headerlink" title="空间分配担保策略"></a>空间分配担保策略</h1><p>虽然有空间分配担保，但是也需要考虑老年代能否装下由于担保转存的内存大小，所以这个空间分配担保也需要一定的策略。</p>
<ol>
<li>在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间</li>
<li>如果上面条件成立，那么MinorGC就是安全的，可以进行</li>
<li>如果上面条件不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。</li>
<li>如果允许担保失败，就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小</li>
<li>如果大于，将尝试进行一次MinorGC</li>
<li>如果小于，或者HandlePromotionFailure设置为不允许冒险，那这时需要进行一次FullGC</li>
</ol>
<p>在jdk 6 update 24之后的规则是只要老年代的连续空间大于新生代对象的总大小或者历次晋升平均大小就会进行MinorGC，否则进行FullGC。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面我们可以知道JAVA虚拟机是怎么自动进行内存分配的，然后在进行GC之后，内存是怎么转换的。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入理解JAVA虚拟机》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：一直在说Java的垃圾回收，既然有回收，那么当然会有分配。
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="jvm" scheme="http://bestlixiang.site/tags/jvm/"/>
    
      <category term="jdk" scheme="http://bestlixiang.site/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_4_垃圾收集策略</title>
    <link href="http://bestlixiang.site/2017/11/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-4-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AD%96%E7%95%A5/"/>
    <id>http://bestlixiang.site/2017/11/29/深入理解JVM-4-垃圾收集策略/</id>
    <published>2017-11-29T11:33:14.000Z</published>
    <updated>2017-11-29T11:35:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：Java与C++之间有一堵内存动态分配与垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。那我们就先来看看JVM到底是怎么进行垃圾收集的？<a id="more"></a></p>
<h1 id="垃圾回收，回收哪里？"><a href="#垃圾回收，回收哪里？" class="headerlink" title="垃圾回收，回收哪里？"></a>垃圾回收，回收哪里？</h1><p>之前介绍过Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，这几个区域的内存分配和回收都具有确定性，方法结束或者线程结束，内存自然就跟着回收了，但是Java堆和方法区（元空间）则不一样，我们只有在运行期间才知道会创建哪些对象，这部分内存的分配和回收都是动态的，所有垃圾回收就是回收这里。</p>
<h1 id="对象已死么？"><a href="#对象已死么？" class="headerlink" title="对象已死么？"></a>对象已死么？</h1><p>垃圾收集器在对堆进行回收前，第一件事就是要确定这些对象之中还有那些还“存活”者，哪些已经“死去”（即不可能再被任何途径使用的对象）。</p>
<ol>
<li><p>引用计数算法</p>
<p> 给每个对象添加一个引用计数器，每当有一个地方引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器为0的对象就是不可能再被使用的。</p>
</li>
<li><p>可达性分析算法（Java使用）</p>
<p> 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径被称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p>
<p> 在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性应用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
</li>
</ol>
<h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><ol>
<li>强引用：类似”Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用：用来描述还有用但非必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。它是通过SoftReference类来实现软引用的。</li>
<li>弱引用：用来描述非必需对象的，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象，它是通过WeakReference类来实现弱引用的。</li>
<li>虚引用：只要发生垃圾回收，它就会被收集，它唯一的目的就是能在这个对象被收集器回收时收到一个系统通知，它是用过PhantomReference类来实现虚引用。</li>
</ol>
<h1 id="方法区（元空间）的回收"><a href="#方法区（元空间）的回收" class="headerlink" title="方法区（元空间）的回收"></a>方法区（元空间）的回收</h1><p>类和其元数据的生命周期和其对应的类加载器是相同的。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。准确的来说，每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。</p>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>流程：</p>
<ol>
<li>标记出所有需要回收的对象</li>
<li>在标记完成后统一回收所有被标记的对象</li>
</ol>
<p>不足：</p>
<ol>
<li><p>效率问题</p>
<p> 标记和清除两个过程效率都不高</p>
</li>
<li><p>空间问题</p>
<p> 标记清除以后会产生大量不连续的空间碎片，无法存储大对象</p>
</li>
</ol>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>流程：</p>
<ol>
<li>将可用内存按容量分为大小相同的两块</li>
<li>在第一块分配内存，并标记出所有需要回收的对象</li>
<li>当第一块内存用完了，将所有活着的对象复制到另外一块上</li>
<li>将第一块所使用过的内存空间一次性清除</li>
</ol>
<p>好处：解决了空间碎片问题</p>
<p>不足：降低了空间利用率</p>
<p>现在的商业虚拟机都用这种收集算法来回收新生代，因为新生代中的对象98%是“朝生夕死”的，所以不需要1:1划分空间,而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还活着的对象那个一次性复制到另一块Survivor空间上，最后清理掉前两块空间。HotSpot虚拟机默认Eden和Survivor的大小比例为8:1，所以只有10%的内存会被“浪费”，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。</p>
<p>内存的分配担保是指如果放着存活对象的Survivor空间没有足够空间放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>适合老年代</p>
<p>流程：</p>
<ol>
<li>标记出所有需要回收的对象</li>
<li>让所有存活的对象都向一端移动</li>
<li>直接清理掉端边界以外的内存</li>
</ol>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>将内存划分为老年代和新生代。老年代中存放寿命较长的对象，新生代中存放“朝生夕死”的对象。然后在不同的区域使用不同的垃圾收集算法。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从上面我们了解了对象存活判定算法和垃圾回收算法，但是不同虚拟机的具体实现还是不同的，而且不同的垃圾收集器的内存回收的具体实现也是不同的，我们要因机而议。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入理解Java虚拟机》</li>
<li><a href="http://blog.csdn.net/qq_16681169/article/details/70471010" target="_blank" rel="external">JDK8 从永久代到元空间</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：Java与C++之间有一堵内存动态分配与垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。那我们就先来看看JVM到底是怎么进行垃圾收集的？
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://bestlixiang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_3_OutOfMemoryError异常现场</title>
    <link href="http://bestlixiang.site/2017/11/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-3-OutOfMemoryError%E5%BC%82%E5%B8%B8%E7%8E%B0%E5%9C%BA/"/>
    <id>http://bestlixiang.site/2017/11/29/深入理解JVM-3-OutOfMemoryError异常现场/</id>
    <published>2017-11-29T07:24:08.000Z</published>
    <updated>2017-11-29T07:26:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：之前面对JVM运行内存的分析，总会提到出现OutMemoryError异常，接下来我们详细看下常出现这种异常的现场。<a id="more"></a></p>
<h1 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h1><p>我们通过限制Java堆得大小为20MB,不可扩张（将堆得最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX：+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump（备份）出当前的内存堆转储快照以便时候分析处理。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">OOMobject</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;OOMobject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            list.add(<span class="keyword">new</span> OOMobject());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">java.lang.OutOfMemoryError: Java heap space</div><div class="line">Dumping heap to java_pid81611.hprof ...</div><div class="line">Heap dump file created [27573572 bytes in 0.121 secs]</div><div class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</div><div class="line">	at java.util.Arrays.copyOf(Arrays.java:3210)...</div></pre></td></tr></table></figure></p>
<p>我们很容易在输出结果中看到Java heap space OOM出现在堆中。我们要解决这个区域的异常主要是通过内存映像分析工具（很多）对Dump出来的堆转储快照进行分析，重点确认是<strong>内存泄漏（Memory leak）</strong>还是<strong>内存溢出（Memory Overflow</strong>）。</p>
<ol>
<li><p>内存泄漏：被分配的内存的对象不会被回收，永久占据内存。</p>
<p> 解决方法：通过工具查看泄漏对象到GC Roots的引用链。</p>
</li>
<li><p>内存溢出：无法申请到内存。</p>
<p> 解决方法：检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长的情况，尝试减少程序运行期的内存消耗。</p>
</li>
</ol>
<h1 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h1><p>我们说过HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，所以设置本地方法栈大小是无效的，栈容量只由-Xss参数设定，在Java虚拟机规范中描述了两种异常</p>
<ol>
<li>StackOverflowError异常：如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出此异常。</li>
<li>OutOfMemoryError异常：如果虚拟机在扩展栈使无法申请到足够的内存空间，将抛出此异常。</li>
</ol>
<p>我个人想如果单线程中栈的内存大小等于总内存大小，那么上面两种异常应该是等价的吧，但是基本上是不可能的。所以单线程中出现得基本上都是StackOverflowError异常。</p>
<p>单线程代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// VM args: -Xss128k</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">OOMobject</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;OOMobject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            list.add(<span class="keyword">new</span> OOMobject());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">stack lenth:18855</div><div class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</div><div class="line">	at com.todorex.demo.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:10)</div></pre></td></tr></table></figure></p>
<p>这里抄一下书的结论：在单个线程下，无论是由于栈帧太大还是虚拟机容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。</p>
<p>多线程代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// VM args: -Xss2M</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    dontStop();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            thread.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        JavaVMStackOOM javaVMStackOOM = <span class="keyword">new</span> JavaVMStackOOM();</div><div class="line">        javaVMStackOOM.stackLeakByThread();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我在自己的机器上没有运行出来，可能需要点时间，不过机器变卡了，我想其实这里解释一下就好，它应该会抛出OutOfMemoryError异常。</p>
<p>解释：首先操作系统分给每个进程的内存是有限制的，所以总的方法栈的大小也是有限制的，但是每个线程都需要方法栈，所以线程建立的越多，剩余的方法栈内存就越小，一直创建线程，进程所拥有的内存终将被耗尽，到最后就会抛出OutOfMemoryError异常。</p>
<p>注意：线程数和方法栈大小是成反比的，所以在开发多线程的应用时应该特别注意，如果不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程了。</p>
<h1 id="方法区（元空间）和运行时常量池溢出"><a href="#方法区（元空间）和运行时常量池溢出" class="headerlink" title="方法区（元空间）和运行时常量池溢出"></a>方法区（元空间）和运行时常量池溢出</h1><h2 id="运行时常量池溢出"><a href="#运行时常量池溢出" class="headerlink" title="运行时常量池溢出"></a>运行时常量池溢出</h2><p>在之前的博客也提到过在jdk1.6以及之前运行时常量池是放在方法区中的，存的是对象，所以可以设置虚拟机参数-XX:PermSize和-XX:MaxPermSize来限制方法区的大小，来模拟常量池溢出，但是jdk1.7及以后运行时常量池被移除了方法区，常量池存储的不再是对象，而是对象的引用，真正的对象存储在堆中，我们改变虚拟机参数为：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError运行下面程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// VM args:-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            list.add(String.valueOf(i++).intern());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java.lang.OutOfMemoryError: GC overhead limit exceeded</div><div class="line">Dumping heap to java_pid10818.hprof ...</div><div class="line">Heap dump file created [25172419 bytes in 0.251 secs]</div></pre></td></tr></table></figure></p>
<p>上面结果提示GC开销超过限制，默认的话，如果你98%的时间都花在GC上并且回收了才不到2%的空间的话，虚拟机就会抛这个异常。</p>
<p>其实我们之前也提起过在JDK1.8及以后，字符串常量池从永久代移到到元空间中，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整，如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集，-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集，具体验证代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// VM args: -XX:MetaspaceSize=4M -XX:MaxMetaspaceSize=4M</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            list.add(String.valueOf(i++).intern());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Error occurred during initialization of VM</div><div class="line">OutOfMemoryError: Metaspace</div></pre></td></tr></table></figure></p>
<p>关于这个字符串常量池的实现问题，还真的会出现一个很意思的问题或者说是一个很奇怪的问题。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// jdk:1.8</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"软件"</span>).toString();</div><div class="line">        System.out.println(str1.intern() == str1);</div><div class="line"></div><div class="line">        String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</div><div class="line">        System.out.println(str2.intern() == str2);</div><div class="line"></div><div class="line">        String str3 = <span class="keyword">new</span> StringBuilder(<span class="string">"ma"</span>).append(<span class="string">"in"</span>).toString();</div><div class="line">        System.out.println(str3.intern() == str3);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">false</div><div class="line">false</div></pre></td></tr></table></figure></p>
<p>jdk1.6中，intern()方法会把首次遇到的字符串实例复制在永久代，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用。而在jdk1.7及以后，intern()的实现不会再复制实例，只是在常量池中记录首次出现得实例的引用，因此intern()返回的由StringBuilder创建的那个字符串是同一个实例，而关于上面的运行结果，我想java和main之前都是在字符串常量池中都有他的引用了，所以返回的都是false。</p>
<h2 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h2><p>方法区用于存放Class的相关信息，如类名，访问修饰符，常量池，字段描述，方法描述等，基本的思路是运行时产生大量的类去填充方法区，下面是借助CGLib（cglib和asm的依赖有个坑，选择cglib2.2,asm3.1亲测可用）来操作字节码运行时生成大量的动态类，这种场景在Spring，Hibernate中经常出现，需要多注意，本人使用的JDK1.8，所以测试的是方法区的变迁元空间，代码实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// VM args:-XX:MetaspaceSize=4M -XX:MaxMetaspaceSize=4M</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">            enhancer.setSuperclass(OOMObject.class);</div><div class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</div><div class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            OOMObject oomObject = (OOMObject) enhancer.create();</div><div class="line">            oomObject.sayHi();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</div><div class="line">            System.out.println(<span class="string">"hi"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Error occurred during initialization of VM</div><div class="line">OutOfMemoryError: Metaspace</div></pre></td></tr></table></figure></p>
<p>这类异常经常出现在web应用中，需要多注意。</p>
<h1 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h1><p>DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样，在《深入理解Java虚拟机》中用了以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// VM args:-Xmx20M -XX:MaxDirectMemorySize=10M</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span>*<span class="number">1024</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</div><div class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</div><div class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            unsafe.allocateMemory(_1MB);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是在自己电脑中没有运行成功，反而让自己的电脑死机了，这个地方还是没有弄懂？？？？？？，希望懂的大佬给我点支持。</p>
<p>这个异常在使用NIO中可能会出现，所以在使用的时候需要多注意。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在总结得过程中，知道了各个内存区域可能会出现OOM的情况，重要的是了解了方法区在jdk1.6到1.7到1.8的变迁，有兴趣的人可以深入了解。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入理解Java虚拟机》</li>
<li><a href="http://blog.csdn.net/zghwaicsdn/article/details/50957474" target="_blank" rel="external">CGLIB介绍与原理</a></li>
<li><a href="http://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="external">Java8内存模型—永久代(PermGen)和元空间(Metaspace)</a></li>
<li><a href="http://www.sczyh30.com/posts/Java/jvm-metaspace/" target="_blank" rel="external">深入探究JVM | 探秘Metaspace</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：之前面对JVM运行内存的分析，总会提到出现OutMemoryError异常，接下来我们详细看下常出现这种异常的现场。
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://bestlixiang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_2_HotSpot对象揭秘</title>
    <link href="http://bestlixiang.site/2017/11/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-2-HotSpot%E5%AF%B9%E8%B1%A1%E6%8F%AD%E7%A7%98/"/>
    <id>http://bestlixiang.site/2017/11/21/深入理解JVM-2-HotSpot对象揭秘/</id>
    <published>2017-11-21T03:11:05.000Z</published>
    <updated>2017-11-21T03:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：总有些人会思考对象是如果创建、如何布局、以及如何访问的？对于这些问题，我们必须把讨论范围限定在具体的虚拟机和集中在某一个内存区域才有意义。基于实用原则，我们以常用的虚拟机HotSpot和常用的内存区域Java堆为例。<a id="more"></a></p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>Java程序创建对象不过是一个new关键字而已，而在虚拟机中，创建了一个对象却经历了一系列过程。</p>
<ol>
<li>虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，如果没有就会抛出ClassNotFoundException，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，那必须先执行相应的类加载过程。</li>
<li><p>类加载检查通过后，虚拟机为新生对象分配内存，对象所需内存的大小在类加载完成后便可以完全确定。</p>
<p> 这里有两种内存分配方式：（由采用的垃圾收集器是否带有压缩整理的功能决定）</p>
<ul>
<li><p>指针碰撞</p>
<p>  假设Java堆的内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</p>
</li>
<li><p>空闲列表</p>
<p>  假如Java堆中的内存并不是完整的，已使用的内存和空闲的内存相互交错，虚拟机就必须维护一个列表，记录那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给实例，并更新列表上的记录。</p>
<p>解决在并发情况下不安全的方案:</p>
</li>
<li><p>对分配内存空间的动作进行同步处理——虚拟机采用CAS配上失败重试的方式保证更新操作的原子性</p>
</li>
<li><p>把内存分配的动作按线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲，只有需要重新分配的时候才同步锁定</p>
</li>
</ul>
</li>
<li><p>虚拟机将分配到的内存空间都初始化为零值（默认初始化），保证了对象实例在Java代码中可以不赋初始值就可以使用。</p>
</li>
<li>设置对象头</li>
<li>利用构造函数进行初始化</li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><ol>
<li>存储对象自身的运行时数据（哈希码，GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等），官方称为“Mark Word”，它被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，他会根据对象的状态复用自己的存储空间，具体见《深入理解Java虚拟机》。</li>
<li>类型指针（可选）<br>即对象指向它的元数据（方法区）的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
<li>数组长度（可选）<br>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通java对象元数据信息确定Java对象的大小，但是从数组数据无法确定数据大小</li>
</ol>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>存储所有成员变量，无论是父类继承下来的，还是在子类定义的。</p>
<p>存储顺序会受到虚拟机分配策略参数和字段在源码定义的顺序的影响。<br>HotSpot默认的分配策略为相同狂赌的字段总是被分配到一起（如long和double），在这个前提下，父类先于子类，若CompactFields参数为true，那么子类之中较窄的变量也可能插入到父类变量的空隙中（是因为一个slot太大）</p>
<h3 id="对齐填充（可选）"><a href="#对齐填充（可选）" class="headerlink" title="对齐填充（可选）"></a>对齐填充（可选）</h3><p>起到占位符的作用，确保对象的长度为8字节的整数倍</p>
<p>HotSpot VM的自动内存管理系统要求对象起始位置必须是8字节的整数倍，由于对象头一定是8字节的整数倍，所以利用占位符可以达到数据部分也是8字节的整数倍。从而达到对象的长度是8字节的整数倍。（有点绕口啊，哈哈）</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>我们通常都会使用Java对象，我们基本上都是通过虚拟机栈上的reference数据来操作堆上的具体对象，而栈上只是一个指向对象的引用，对象的具体访问方式取决于虚拟机，目前有以下两种访问方式：</p>
<h3 id="通过句柄访问对象"><a href="#通过句柄访问对象" class="headerlink" title="通过句柄访问对象"></a>通过句柄访问对象</h3><p>可以看下面的图：<br><img src="http://ozp5jl6m4.bkt.clouddn.com/image/jpg/JavaHandlerInvite.jpg" alt="通过句柄访问对象"><br>使用句柄访问，Java堆中会划分出一块内存来作为句柄池，reference存储的就是对象的句柄地址，而句柄包含了对象实例数据与类型数据各自的具体地址信息。</p>
<h3 id="通过直接指针访问对象"><a href="#通过直接指针访问对象" class="headerlink" title="通过直接指针访问对象"></a>通过直接指针访问对象</h3><p>可以看下面的图：<br><img src="http://ozp5jl6m4.bkt.clouddn.com/image/jpg/JavaHandlerInvite.jpg" alt="JavaHandlerInvite"><br>使用直接指针访问，<strong>Java堆对象的布局</strong>中就要考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。</p>
<h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><ol>
<li>通过句柄访问对象可以当对象被移动之后只会改变句柄中的实例数据指针，而reference本身不需要改变。</li>
<li>使用直接指针访问可以加快Java对象的访问，HotSpot就是使用直接指针访问对象的方式。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里讲的对象重点还是在虚拟机执行部分，关于Class文件的讲解没有涉及到，但它却是十分重要的，日后会提及。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/u010425776/article/details/51190801" target="_blank" rel="external">深入理解JVM(二)——揭开HotSpot对象创建的奥秘</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：总有些人会思考对象是如果创建、如何布局、以及如何访问的？对于这些问题，我们必须把讨论范围限定在具体的虚拟机和集中在某一个内存区域才有意义。基于实用原则，我们以常用的虚拟机HotSpot和常用的内存区域Java堆为例。
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://bestlixiang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_1_JVM内存模型</title>
    <link href="http://bestlixiang.site/2017/11/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-1-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://bestlixiang.site/2017/11/20/深入理解JVM-1-JVM内存模型/</id>
    <published>2017-11-20T10:41:36.000Z</published>
    <updated>2017-11-20T10:55:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：总是提到堆呀，栈呀，常量池呀，但是Java虚拟机内的Java模型却总是理解不清楚，这次就总结一下。<a id="more"></a></p>
<h1 id="Java内存模型组成"><a href="#Java内存模型组成" class="headerlink" title="Java内存模型组成"></a>Java内存模型组成</h1><p>这里讲的是Java虚拟机在执行Java程序的过程中会把它所管理的内存划分五大区域。</p>
<ol>
<li>程序计算器</li>
<li>Java虚拟机栈</li>
<li>本地方法栈</li>
<li>Java堆</li>
<li>方法区</li>
</ol>
<p>下面也把来自深入理解Java虚拟机的图片贴一下：</p>
<p><img src="http://ozp5jl6m4.bkt.clouddn.com/image/jpg/JavaRunningDataModel.jpg" alt="image"></p>
<p>接着我们重点理解一下这五大区域。</p>
<h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><h2 id="什么是程序计数器"><a href="#什么是程序计数器" class="headerlink" title="什么是程序计数器"></a>什么是程序计数器</h2><ol>
<li>程序计数器是一块较小的内存空间，他可以看做当前<strong>线程</strong>所执行的字节码的行号指示器。</li>
<li>如果<strong>线程</strong>在执行一个Java方法的时候，这个计数器记录的是正在执行的虚拟机字节码指令地址，如果正在执行的是Native方法，这个计数器值则为空。</li>
</ol>
<h2 id="程序计数器的作用"><a href="#程序计数器的作用" class="headerlink" title="程序计数器的作用"></a>程序计数器的作用</h2><ol>
<li>单线程的时候：通过改变这个计数器的值来选取下一条需要执行的字节码指令，从而实现分支、循环、跳转、异常处理、线程回复等基础功能。</li>
<li>多线程的时候：当每个线程都有独立的程序计数器，则线程切换后就能回复到正确的执行位置。<br><strong>PS：</strong> Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。</li>
</ol>
<h2 id="程序计数器的特点"><a href="#程序计数器的特点" class="headerlink" title="程序计数器的特点"></a>程序计数器的特点</h2><ol>
<li>存储空间较小</li>
<li>线程私有，每个线程都有一个程序计数器</li>
<li>唯一一个没有规定任何OutOfMemoryError情况的区域</li>
<li>生命周期与线程相同</li>
</ol>
<h1 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h1><h2 id="什么是Java虚拟机栈"><a href="#什么是Java虚拟机栈" class="headerlink" title="什么是Java虚拟机栈"></a>什么是Java虚拟机栈</h2><p>Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个<strong>栈帧</strong>用于存储局部变量表（包括基本数据类型，对象引用和returnAddress,其中long和double会占据2个局部变量空间，其他只占用一个）、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个<strong>栈帧</strong>在虚拟机栈中入栈到出栈的过程。</p>
<p><strong>Ps：</strong> 人们常说的Java内存区分为“堆”和“栈”，“堆”存放对象（可以），“栈”只是值其中的局部变量表（不可以），这是不正确的。</p>
<h2 id="Java虚拟机栈的特点"><a href="#Java虚拟机栈的特点" class="headerlink" title="Java虚拟机栈的特点"></a>Java虚拟机栈的特点</h2><ol>
<li>线程私有，生命周期与线程相同</li>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常</li>
<li>虚拟机栈可以动态扩展，也可以固定长度，在动态扩展的时候如果无法申请到足够的内存，就会抛出OutOfMemoryError异常</li>
</ol>
<h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><h2 id="什么是本地方法栈"><a href="#什么是本地方法栈" class="headerlink" title="什么是本地方法栈"></a>什么是本地方法栈</h2><p>本地方法栈描述的是本地方法执行的内存模型，它发挥的作用与虚拟机栈发挥的作用是非常相似的，如Sun HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一，它与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h1 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h1><h2 id="什么是Java堆"><a href="#什么是Java堆" class="headerlink" title="什么是Java堆"></a>什么是Java堆</h2><ol>
<li>Java堆是存放对象实例的内存区域</li>
<li><strong>几乎所有</strong>对象实例都在这里分配内存</li>
</ol>
<h2 id="Java堆的特点"><a href="#Java堆的特点" class="headerlink" title="Java堆的特点"></a>Java堆的特点</h2><ol>
<li>Java虚拟机管理的内存中最大的一块</li>
<li>线程共享，在虚拟机启动时创建</li>
<li>垃圾收集器管理的主要区域，从内存回收的角度来看，由于现在收集器都采用分代收集算法，所以可分为新生代和老年代，再细致一点可以分为Eden空间、From Survivor空间和To Survivor空间等。从内存分配来看，线程共享的Java堆可能划分出多个线程私有的分配缓存区TLAB,进一步划分的目的是为了更好地回收内存，或者更快的分配内存</li>
<li>实现中可以固定大小，也可以是可扩展的，如果在堆中没有内存完成实例的分配，并且堆也无法再扩展时，就会抛出OutOfMemoryError异常</li>
</ol>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="什么是方法区"><a href="#什么是方法区" class="headerlink" title="什么是方法区"></a>什么是方法区</h2><ol>
<li>Java虚拟机规范把方法区描述为堆的一个逻辑部分。</li>
<li>他用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</li>
</ol>
<h2 id="方法区的特点"><a href="#方法区的特点" class="headerlink" title="方法区的特点"></a>方法区的特点</h2><ol>
<li>线程共享，在虚拟机启动时创建</li>
<li>永久代是因为HotSpot选择将GC分代收集器扩展到方法区，或者使用永久代来实现方法区，对于HotSpot官方发布的路线图信息，现在也有放弃永久代逐步采用Native Memory来实现方法区的规划了，并且已经把原本放在永久代的字符串常量池移除</li>
<li>不需要连续的内存，可以选择固定大小或者可扩展，还可以选择不实现垃圾回收</li>
<li>内存回收的主要目标主要是针对常量池的回收和对类型的卸载，但是回收效率低</li>
<li>当方法区无法满足内存分配的需求的时候，将抛出OutOfMemoryError的异常</li>
</ol>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><ol>
<li>Class文件除了包含类的版本<br>字段、方法、接口等描述信息外，还有一项信息是常量池</li>
<li>常量池用于存放编译期间生成的各种字面量和符号引用，这部分内容在类加载后进入运行时常量池中存放</li>
<li>运行时常量池相对于Class文件常量池具有动态性，Java语言不要求只有Class文件中的常量池的内容才能进入运行时常量池，运行时也可能将新的常量放入池中，如String类的intern方法</li>
<li>当常量池无法再申请内存时将会抛出OutOfMemoryError异常</li>
</ol>
<p><strong>PS：</strong> jdk1.7的常量池移到了堆中，同时在jdk1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域</p>
<h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><ol>
<li>通过一个存储在Java堆中的DirectByteBuffer对象最为这块内存的引用进行操作，这个可以显著提高性能，因为避免了在Java堆和Native堆中来回复制数据</li>
<li>案例是NIO类引入一种基于通道与缓存区的I/O方式，它可以使用Native函数库直接分配对外内存，然后通过DirectByteBuffer进行操作</li>
<li>本机直接内存的分配不会受到Java堆大小的限制，但是会受到本机总内存大小和处理器寻址空间的限制，也可能会抛出OutOfMemoryError异常</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章是参考《深入理解Java虚拟机》第二版所写，当时作者用的是jdk1.7，结果现在jdk1.9都出了，最大的改变就是方法区了，目前还没有能力改正，也就将就了，望作者早日更新，或者自己成为大牛，将这部分重新整理。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://blog.csdn.net/u010425776/article/details/51170118" target="_blank" rel="external">深入理解JVM(一)——JVM内存模型</a></li>
<li><a href="http://blog.csdn.net/zhyhang/article/details/17246223/" target="_blank" rel="external">Java 8: 从永久代（PermGen）到元空间（Metaspace）
</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：总是提到堆呀，栈呀，常量池呀，但是Java虚拟机内的Java模型却总是理解不清楚，这次就总结一下。
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>springboot静态资源的处理</title>
    <link href="http://bestlixiang.site/2017/10/20/springboot%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://bestlixiang.site/2017/10/20/springboot静态资源的处理/</id>
    <published>2017-10-20T08:42:58.000Z</published>
    <updated>2017-10-20T09:04:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：由于springboot架构遇到了图片的上传处理，以及之后的前台显示，所以就理解了一下其中关于静态资源的处理。<a id="more"></a></p>
<h2 id="默认的静态资源处理"><a href="#默认的静态资源处理" class="headerlink" title="默认的静态资源处理"></a>默认的静态资源处理</h2><p>在每次启动springboot的项目的时候，我们都可以在控制台看见下面的语句输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2017-10-20 16:06:50.540  INFO 36443 --- [  restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]</div><div class="line">2017-10-20 16:06:50.540  INFO 36443 --- [  restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]</div><div class="line">2017-10-20 16:06:50.569  INFO 36443 --- [  restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]</div></pre></td></tr></table></figure></p>
<p>这里面就用到了springboot默认的静态资源处理。</p>
<p>其中默认配置的/**映射到/static（或/public、/resources、/META-INF/resources） </p>
<p>其中默认配置的/webjars/**映射到classpath:/META-INF/resources/webjars/ </p>
<p>PS：上面的 static、public、resources 等目录都在 classpath: 下面（如 src/main/resources/static）</p>
<p>在访问静态资源的时候，这些目录也会有一个查找顺序（优先级）：这里测试过发现他们的优先级是：META/resources &gt; resources &gt; static &gt; public </p>
<h2 id="自定义静态资源处理"><a href="#自定义静态资源处理" class="headerlink" title="自定义静态资源处理"></a>自定义静态资源处理</h2><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><ol>
<li>通过配置文件（application.properties）配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 默认值为 /**</div><div class="line">spring.mvc.static-path-pattern=</div><div class="line"># 默认值为 classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ </div><div class="line">spring.resources.static-locations=这里设置要指向的路径，多个使用英文逗号隔开，</div></pre></td></tr></table></figure>
</li>
</ol>
<p>当我们要设置成我们的目录：/myresource/**，我们需要这样设置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">spring.mvc.static-path-pattern=/**</div><div class="line">spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/,classpath:/myresource/</div></pre></td></tr></table></figure></p>
<p>当我们设置过映射路径时候，如果还是/**,那么默认的映射就失效了，我们需要重新把原来的路径也添加上。这里的配置路径只可以设置一个。</p>
<ol>
<li>通过配置类配置<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppConfigurer</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</div><div class="line">        registry.addResourceHandler(<span class="string">"/myresource/**"</span>).addResourceLocations(<span class="string">"file:/var/alldata/image/"</span>);</div><div class="line">        <span class="keyword">super</span>.addResourceHandlers(registry);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>可以通过这个方式设置多个配置路径。</p>
<h3 id="配置内外目录"><a href="#配置内外目录" class="headerlink" title="配置内外目录"></a>配置内外目录</h3><ol>
<li>内部目录</li>
</ol>
<p>做法是添加映射路径  classpath:/路径</p>
<p>方式见通过配置文件配置</p>
<ol>
<li>外部目录</li>
</ol>
<p>想一想如果将上传的图片继续存在jar包中会有那些问题？</p>
<ul>
<li>网络数据与程序代码不能分离</li>
<li>数据传到jar里速度慢</li>
<li>数据备份麻烦</li>
</ul>
<p>有了以上的考虑我们会想到将上传的数据放在磁盘的目录上。</p>
<p>做法是添加映射路径  file:/var/alldata/images</p>
<p>方式见通过配置类配置</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>springboot倡导的是习惯优于配置，大部分时候我们用他默认的配置就好了，但是他也提供了方便的配置类，需要我们好好学习。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/catoop/article/details/50501706" target="_blank" rel="external">Spring Boot 静态资源处理</a></li>
<li><a href="http://blog.csdn.net/kilua_way/article/details/54601195" target="_blank" rel="external">Springboot 之 静态资源路径配置</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：由于springboot架构遇到了图片的上传处理，以及之后的前台显示，所以就理解了一下其中关于静态资源的处理。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="springboot" scheme="http://bestlixiang.site/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>mac中环境变量的配置</title>
    <link href="http://bestlixiang.site/2017/09/21/mac%E4%B8%AD%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://bestlixiang.site/2017/09/21/mac中环境变量的配置/</id>
    <published>2017-09-21T01:46:33.000Z</published>
    <updated>2017-09-21T01:56:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在使用ubuntu和mac这么久之后，环境变量的几个文件还弄不清楚，真是汗颜，这里记录一下，下次不会乱改。<a id="more"></a></p>
<h2 id="环境变量的作用"><a href="#环境变量的作用" class="headerlink" title="环境变量的作用"></a>环境变量的作用</h2><ol>
<li>使用场景<br>在命令行直接通过命令执行程序，这些程序就多了，最常见就有java，npm，maven，git,如果我们不配置环境变量的话，就需要到程序的安装目录去执行相关命令，大家都会感觉超级麻烦，加入要使用多个程序的话，要么去切换目录，要么就多开几个命令行窗口。顿时就会感觉超级无奈有么有？</li>
<li>具体作用<br>配置完程序的环境变量之后就可以无所欲为了，可以在任何目录下直接执行我们所要的程序了，是不是顿时感觉方便许多，基本上所有人都知道吧。</li>
</ol>
<h2 id="环境变量的配置"><a href="#环境变量的配置" class="headerlink" title="环境变量的配置"></a>环境变量的配置</h2><h3 id="单次环境变量配置"><a href="#单次环境变量配置" class="headerlink" title="单次环境变量配置"></a>单次环境变量配置</h3><p>假如你出了个意外，在命令行中突然不能使用各种命令了，也没事，至少接下来可以让你短暂的使用一些命令，命令行窗口关闭之后就失效了，我们要做的只是直接在命令行中输入：</p>
<pre><code>export PATH=/usr/bin:/usr/sbin:/bin:/sbin
</code></pre><p>当然后面你也能够添加一些你自己想要使用的程序命令。</p>
<h3 id="环境变量文件配置"><a href="#环境变量文件配置" class="headerlink" title="环境变量文件配置"></a>环境变量文件配置</h3><ol>
<li><p>环境变量的写法</p>
<pre><code>export PATH=JAVA_HOME/bin:$PATH
</code></pre></li>
<li><p>环境变量文件优先级</p>
<p> /etc/profile  /etc/bashrc /etc/paths  ~/.bash_profile ~/.bash_login  ~/.profile  ~/.bashrc<br>其实后三个文件我也没怎么看到过，主要讲一下前面三个</p>
</li>
<li>环境变量文件详解</li>
</ol>
<ul>
<li>/etc/profile：全局配置文件，不管是哪一个用户登录，都会读取该文件（但是超级不建议修改，容易出现大问题，想试试什么大问题，自己体会）</li>
<li>/etc/bashrc 全局配置文件，bash shell执行时，不管是何种方式，都会读取此文件（一般在这个文件中添加系统级环境变量）</li>
<li>~/.bash_profile：每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!（一般在这个文件中添加用户级环境变量）</li>
</ul>
<ol>
<li><p>立即生效环境变量配置</p>
<pre><code>source ~/.bash_profile
</code></pre></li>
</ol>
<h2 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h2><p>自己一开始也会特别的惊讶，自己在mac上没有设置环境变量有的时候也可以直接就访问到了某些文件。这个是为什么呢？答案是用了软连接。</p>
<h3 id="查看加载文件"><a href="#查看加载文件" class="headerlink" title="查看加载文件"></a>查看加载文件</h3><pre><code>rexdeMacBook-Pro:etc rex$ cat /etc/paths
/usr/local/bin
/usr/bin
/bin
/usr/sbin
/sbin
</code></pre><p>然后就可以去看这些文件夹下面的东西了，弄不清楚也没关系，其实就是软链接。开机后，mac会自动加载paths文件下面的这些目录。在这些文件夹下面建立软连接，可以达到同样的效果（日后学习）。</p>
<h3 id="软连接查看"><a href="#软连接查看" class="headerlink" title="软连接查看"></a>软连接查看</h3><p>在拥有软连接的目录下使用下面命令</p>
<pre><code>ls -li


406876 lrwxr-xr-x   1 root   wheel        73  7  9  2016 jar -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/jar
406877 lrwxr-xr-x   1 root   wheel        79  7  9  2016 jarsigner -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/jarsigner
406878 lrwxr-xr-x   1 root   wheel        74  7  9  2016 java -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java
406879 lrwxr-xr-x   1 root   wheel        75  7  9  2016 javac -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javac
406880 lrwxr-xr-x   1 root   wheel        77  7  9  2016 javadoc -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javadoc
</code></pre><h3 id="建立软连接"><a href="#建立软连接" class="headerlink" title="建立软连接"></a>建立软连接</h3><p>等自己看了linux的相关知识再来说吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望下次自己再也不要因为环境变量配置错出各种问题了，thanks god！</p>
<p>参考：<a href="http://blog.csdn.net/u010416101/article/details/54618621" target="_blank" rel="external">Mac 中环境变量的配置和理解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在使用ubuntu和mac这么久之后，环境变量的几个文件还弄不清楚，真是汗颜，这里记录一下，下次不会乱改。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="mac" scheme="http://bestlixiang.site/tags/mac/"/>
    
      <category term="环境变量" scheme="http://bestlixiang.site/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Github Pages+Hexo SEO引擎优化</title>
    <link href="http://bestlixiang.site/2017/07/16/Github-Pages-Hexo-SEO%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://bestlixiang.site/2017/07/16/Github-Pages-Hexo-SEO引擎优化/</id>
    <published>2017-07-16T07:28:51.000Z</published>
    <updated>2017-07-16T07:34:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：写的博客自然想让人看到，<strong>但是但是</strong>自己为了想独立管理（冠冕堂皇）选择了GIthub Pages+Hexo来搭建自己的博客，结果发现自己的博客在百度，谷歌都无法搜到，那时候我才知道自己缺少了SEO。<a id="more"></a></p>
<h2 id="百度优化"><a href="#百度优化" class="headerlink" title="百度优化"></a>百度优化</h2><p><a href="http://zhanzhang.baidu.com/" target="_blank" rel="external">登录百度站长</a></p>
<p>在里面我们可以发现各种向百度提交的方法，这一切都是为了让百度的爬虫更好的爬取我们的网页。</p>
<ul>
<li><p>通过baidumapsite.xml自动提交</p>
<p>这里推荐一个博文：<a href="http://www.jianshu.com/p/0d54a590b81a" target="_blank" rel="external">Hexo NexT 主题SEO优化指南</a></p>
</li>
<li><p>通过主动提交</p>
<p>这里推荐一个自动化工具：<a href="http://hui-wang.info/2016/10/23/Hexo%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%99%BE%E5%BA%A6%E4%B8%BB%E5%8A%A8%E6%8F%90%E4%BA%A4%E9%93%BE%E6%8E%A5/" target="_blank" rel="external">exo插件之百度主动提交链接</a></p>
</li>
</ul>
<h2 id="谷歌优化"><a href="#谷歌优化" class="headerlink" title="谷歌优化"></a>谷歌优化</h2><p><a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="external">登录谷歌站长</a></p>
<ul>
<li><p>通过map.site自动提交</p>
<p>  这里面推荐一个博文：<a href="http://www.jianshu.com/p/9c2d6db2f855" target="_blank" rel="external">生成sitemap站点地图</a></p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自己在谷歌配置是成功的，但是在百度并没有成功，可能是因为<strong>github真的把百度给干了</strong>。自己还是等开学转到自己的服务器上吧。慢慢<strong>SEO</strong>！！！！</p>
<p>PS:Hexo博客的搭建的可以参考这一篇</p>
<p><a href="http://www.jianshu.com/p/a2fe56d11c4f" target="_blank" rel="external">搭建Hexo博客中碰到的坑</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：写的博客自然想让人看到，&lt;strong&gt;但是但是&lt;/strong&gt;自己为了想独立管理（冠冕堂皇）选择了GIthub Pages+Hexo来搭建自己的博客，结果发现自己的博客在百度，谷歌都无法搜到，那时候我才知道自己缺少了SEO。
    
    </summary>
    
      <category term="工具" scheme="http://bestlixiang.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hexo" scheme="http://bestlixiang.site/tags/hexo/"/>
    
      <category term="seo" scheme="http://bestlixiang.site/tags/seo/"/>
    
  </entry>
  
  <entry>
    <title>新系统开发环境的一系列配置</title>
    <link href="http://bestlixiang.site/2017/07/15/%E6%96%B0%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%85%8D%E7%BD%AE/"/>
    <id>http://bestlixiang.site/2017/07/15/新系统开发环境的一系列配置/</id>
    <published>2017-07-15T13:35:54.000Z</published>
    <updated>2017-07-15T13:37:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：总是不可避免的重装系统，人的脑子不可能那么好记住所有的操作，既然不想自己自己用博客记下所有操作，那么就把别人的博客（自己踩过）记录下来，以后备用。<a id="more"></a></p>
<h2 id="window篇"><a href="#window篇" class="headerlink" title="window篇"></a>window篇</h2><ol>
<li>JDK——java开发者起步</li>
</ol>
<p><a href="http://www.jianshu.com/p/ac13e424e950" target="_blank" rel="external">JDK的安装与环境变量的配置</a></p>
<ol>
<li>Node——前端好基友</li>
</ol>
<p><a href="http://www.jianshu.com/p/03a76b2e7e00" target="_blank" rel="external">Node.js安装及环境配置之Windows篇</a></p>
<ol>
<li>Sublime3——轻量级编辑器</li>
</ol>
<p><a href="http://www.jianshu.com/p/0e12a06c4578" target="_blank" rel="external">Sublime Text3安装与插件配置</a></p>
<ol>
<li>git——分布式版本控制工具</li>
</ol>
<p><a href="http://www.jianshu.com/p/dc90b9aac18c" target="_blank" rel="external">Git安装教程</a></p>
<ol>
<li>Idea——java开发利器</li>
</ol>
<p><a href="http://idea.lanyus.com/" target="_blank" rel="external">IntelliJ IDEA注册码</a></p>
<ol>
<li>Maven——项目依赖管理利器</li>
</ol>
<p><a href="http://www.jianshu.com/p/26fa41427a55" target="_blank" rel="external">Maven Windows10安装</a></p>
<h2 id="Mac篇"><a href="#Mac篇" class="headerlink" title="Mac篇"></a>Mac篇</h2><p>待写</p>
<h2 id="Ubuntu篇"><a href="#Ubuntu篇" class="headerlink" title="Ubuntu篇"></a>Ubuntu篇</h2><p>待写</p>
<h2 id="双系统"><a href="#双系统" class="headerlink" title="双系统"></a>双系统</h2><p><a href="http://www.jianshu.com/p/16b36b912b02" target="_blank" rel="external">Win10和Ubuntu16.04双系统安装详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：总是不可避免的重装系统，人的脑子不可能那么好记住所有的操作，既然不想自己自己用博客记下所有操作，那么就把别人的博客（自己踩过）记录下来，以后备用。
    
    </summary>
    
      <category term="生活" scheme="http://bestlixiang.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="系统" scheme="http://bestlixiang.site/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>浅尝Apache Camel</title>
    <link href="http://bestlixiang.site/2017/07/15/%E6%B5%85%E5%B0%9DApache-Camel/"/>
    <id>http://bestlixiang.site/2017/07/15/浅尝Apache-Camel/</id>
    <published>2017-07-15T01:38:42.000Z</published>
    <updated>2017-07-15T01:40:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：最近项目有一个需求就是定时将一台服务器的文件传到另一个服务器，一开始想的竟然想的是用http去下载，后来在万老师的指点下，采取用ftp服务器（源文件所在地）与ftp客户端（源文件去向）的形式来处理，自己小试了一下，还不错！<a id="more"></a></p>
<h2 id="Apache-Camel简介"><a href="#Apache-Camel简介" class="headerlink" title="Apache Camel简介"></a>Apache Camel简介</h2><p>Apache Camel是Apache基金会下的一个开源项目,它是一个基于规则路由和处理的引擎，提供企业集成模式的Java对象的实现，通过应用程序接口 或称为陈述式的Java领域特定语言(DSL)来配置路由和处理的规则。其核心的思想就是从一个from源头得到数据,通过processor处理,再发到一个to目的的。</p>
<p>这个from和to可以是我们在项目集成中经常碰到的类型:一个FTP文件夹中的文件,一个MQ的queue（jms）,一个HTTP request/response,一个webservice等等.</p>
<h2 id="Apache-Camel架构"><a href="#Apache-Camel架构" class="headerlink" title="Apache Camel架构"></a>Apache Camel架构</h2><p><img src="http://o6plzvjf2.bkt.clouddn.com/camel.png" alt="架构图"></p>
<p>其实理解起来很简单：始端》（过滤器+路由处理器）》终端</p>
<h2 id="Apache-Camel核心概念"><a href="#Apache-Camel核心概念" class="headerlink" title="Apache Camel核心概念"></a>Apache Camel核心概念</h2><ol>
<li><p>endpoint,所谓的endpoint,就是一种可以接收或发送数据的组件。可以支持多种协议，如jms,http,file等。</p>
</li>
<li><p>processor,它是用来处理具体业务逻辑的组件。</p>
</li>
<li><p>route,用来路由，指示数据从哪里来到哪里去，中间用哪个processor处理。</p>
</li>
<li><p>exchange,processor之间用exchange对象来传送数据，有点像jms,通俗一点就像上学时传的小纸条,所以：exchange对象就是processor，endpoint所有camel组件之间传送数据的小纸条:)。</p>
</li>
<li><p>filter，用来确定哪些东西可以传递，哪些东西不可以传递。 </p>
</li>
</ol>
<h2 id="Apache-Camel例子（以ftp为例）"><a href="#Apache-Camel例子（以ftp为例）" class="headerlink" title="Apache Camel例子（以ftp为例）"></a>Apache Camel例子（以ftp为例）</h2><p>老师指导的例子，是结合Springboot的，放在github上了。<br><a href="https://github.com/todorex/ApacheCamel" target="_blank" rel="external">ApacheCamleDemo</a></p>
<p>里面包括了动态路由和单路由的例子，稍微结合Springboot就可以理解并改成自己的代码。</p>
<h2 id="什么时候用Apache-Camel"><a href="#什么时候用Apache-Camel" class="headerlink" title="什么时候用Apache Camel"></a>什么时候用Apache Camel</h2><p>参考网上的说法：camel就是企业信息集成框架，它提供了很多简单好用而又强大的组件，用户可以根据场景来选择不同的EIP（企业集成模式）来实现自己的需求，以响应快速变化的业务。可以把它当成企业信息总线（ESB）的轻量级实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：最近项目有一个需求就是定时将一台服务器的文件传到另一个服务器，一开始想的竟然想的是用http去下载，后来在万老师的指点下，采取用ftp服务器（源文件所在地）与ftp客户端（源文件去向）的形式来处理，自己小试了一下，还不错！
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Springboot" scheme="http://bestlixiang.site/tags/Springboot/"/>
    
      <category term="ApacheCamel" scheme="http://bestlixiang.site/tags/ApacheCamel/"/>
    
  </entry>
  
  <entry>
    <title>java ftp 上传下载的坑 </title>
    <link href="http://bestlixiang.site/2017/07/15/java-ftp-%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%9D%91/"/>
    <id>http://bestlixiang.site/2017/07/15/java-ftp-上传下载的坑/</id>
    <published>2017-07-15T01:04:43.000Z</published>
    <updated>2017-07-15T04:41:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：还是项目需要，要定时执行一个文件下载业务，一开始方向有点错，但是还好纠正过来了，采用ftp下载，但是ftp下载也有各种坑！<a id="more"></a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>jar包：commons-net</p>
<h2 id="ftp上传"><a href="#ftp上传" class="headerlink" title="ftp上传"></a>ftp上传</h2><p>程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">uploadFile</span><span class="params">(</span></span></div><div class="line">	String url,//服务器主机号</div><div class="line">	<span class="keyword">int</span> port,//服务器端口</div><div class="line">	String username,//用户名</div><div class="line">	String password,//密码</div><div class="line">	String path, //上传路径Mar</div><div class="line">	String filename,//上传为服务器上的文件名</div><div class="line">	InputStream //input本地上传的文件流</div><div class="line">) &#123;</div><div class="line">	<span class="keyword">boolean</span> success = <span class="keyword">false</span>;</div><div class="line">	FTPClient ftp = <span class="keyword">new</span> FTPClient();</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">int</span> reply;MarkDown</div><div class="line">		ftp.connect(url, port);<span class="comment">//连接FTP服务器</span></div><div class="line">		<span class="comment">//如果采用默认端口，可以使用ftp.connect(url)的方式直接连接FTP服务器</span></div><div class="line">		ftp.login(username, password);<span class="comment">//登录</span></div><div class="line">		reply = ftp.getReplyCode();</div><div class="line">		<span class="keyword">if</span> (!FTPReply.isPositiveCompletion(reply)) &#123;</div><div class="line">			ftp.disconnect();</div><div class="line">			<span class="keyword">return</span> success;</div><div class="line">		&#125;</div><div class="line">		ftp.changeWorkingDirectory(path);</div><div class="line">		ftp.storeFile(filename, input);</div><div class="line">		input.close();</div><div class="line">		ftp.logout();</div><div class="line">		success = <span class="keyword">true</span>;</div><div class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		<span class="keyword">if</span> (ftp.isConnected()) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				ftp.disconnect();</div><div class="line">			&#125; <span class="keyword">catch</span> (IOException ioe) &#123;</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> success;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">File file = new File(&quot;/var/test.txt&quot;);</div><div class="line">InputStream is = new FileInputStream(file);</div><div class="line">uploadFile(&quot;127.0.0.1&quot;,21,&quot;test&quot;,&quot;123456&quot;,&quot;/var/data/test&quot;,&quot;testdemo.txt&quot;,is);</div></pre></td></tr></table></figure></p>
<h2 id="ftp下载"><a href="#ftp下载" class="headerlink" title="ftp下载"></a>ftp下载</h2><p>程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">downFile</span><span class="params">(</span></span></div><div class="line">String url, //FTP服务器hostname</div><div class="line"><span class="keyword">int</span> port,//FTP服务器端口</div><div class="line">String username, //FTP登录账号</div><div class="line">String password, //FTP登录密码</div><div class="line">String remotePath,//FTP服务器上的相对路径</div><div class="line">String fileName,//要下载文件关键字</div><div class="line">String localPath//下载后保存到本地的路径</div><div class="line"></div><div class="line">)  &#123;</div><div class="line">	FTPClient ftpClient = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">boolean</span> success = <span class="keyword">false</span>;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		ftpClient = <span class="keyword">new</span> FTPClient();</div><div class="line">		ftpClient.connect(url, port);<span class="comment">// 连接FTP服务器</span></div><div class="line">		ftpClient.login(username, password);<span class="comment">// 登陆FTP服务器</span></div><div class="line">		ftpClient.setControlEncoding(<span class="string">"gb2312"</span>); <span class="comment">// 中文支持</span></div><div class="line">		ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);<span class="comment">//设置文件格式</span></div><div class="line">		ftpClient.enterLocalPassiveMode();</div><div class="line">		logger.info(ftpClient.getReplyCode());</div><div class="line">		<span class="keyword">if</span> (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) &#123;</div><div class="line">			logger.warn(<span class="string">"未连接到FTP，用户名或密码错误。"</span>);</div><div class="line">			ftpClient.disconnect();</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			logger.info(<span class="string">"FTP连接成功。"</span>);</div><div class="line">		&#125;</div><div class="line">		ftpClient.changeWorkingDirectory(remotePath);</div><div class="line">		FTPFile[] fs = ftpClient.listFiles();</div><div class="line">		File file = <span class="keyword">new</span> File(localPath);</div><div class="line">		<span class="keyword">if</span>(!file.exists())&#123;</div><div class="line">			file.mkdirs();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(FTPFile ff:fs)&#123;</div><div class="line">		<span class="keyword">if</span>(ff.getName().contains(fileName))&#123;</div><div class="line">			File localFile = <span class="keyword">new</span> File(localPath+<span class="string">"/"</span>+ff.getName());</div><div class="line">			<span class="keyword">if</span> (localFile.exists())&#123;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">		OutputStream os = <span class="keyword">new</span> FileOutputStream(localFile);</div><div class="line">		<span class="keyword">long</span> time1 = System.currentTimeMillis();</div><div class="line">		<span class="keyword">boolean</span> b = ftpClient.retrieveFile(<span class="keyword">new</span> String(ff.getName().getBytes(<span class="string">"gb2312"</span>),<span class="string">"ISO8859-1"</span>), os);      </div><div class="line">		os.flush();</div><div class="line">		os.close();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		ftpClient.logout();</div><div class="line">		success = <span class="keyword">true</span>;</div><div class="line">	&#125; <span class="keyword">catch</span> (SocketException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">		logger.warn(<span class="string">"FTP的IP地址可能错误，请正确配置。"</span>);</div><div class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">		logger.warn(<span class="string">"FTP的端口错误,请正确配置。"</span>);</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		<span class="keyword">if</span> (ftpClient.isConnected()) &#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			ftpClient.disconnect();</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException ioe) &#123;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> success;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">downFile(&quot;127.0.0.1&quot;,21,&quot;test&quot;,&quot;123456&quot;,&quot;、var/data/test&quot;,&quot;demo&quot;,&quot;/var/alldata&quot;);</div></pre></td></tr></table></figure></p>
<h2 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h2><ol>
<li><p>客户端接受的编码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ftpClient.setControlEncoding(&quot;gb2312&quot;); // 中文支持</div></pre></td></tr></table></figure>
<p> 如果服务器上的文件名有中文，一定要加上这一句，具体编码要根据服务器的编码。</p>
</li>
<li><p>客户端接受的文件类型</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);//设置文件格式</div></pre></td></tr></table></figure>
<p> 文件类型要根据下载的文件格式来定</p>
</li>
<li><p>服务器端口设置</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ftpClient.enterLocalPassiveMode();</div></pre></td></tr></table></figure>
<p> 调用FTPClient.enterLocalPassiveMode();这个方法的意思就是每次数据连接之前，ftp client告诉ftp server开通一个端口来传输数据，防止在新端口对外部不通，因为ftp server可能每次开启不同的端口来传输数据，但是在linux上，由于安全限制，可能某些端口没有开启，所以就出现阻塞。</p>
</li>
<li><p>最大的坑（下载出0kb的文件：实质就是retrieveFile方法执行失败）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ftpClient.retrieveFile(new String(ff.getName().getBytes(&quot;gb2312&quot;),&quot;ISO8859-1&quot;), os)</div></pre></td></tr></table></figure>
<p> 一定要给文件名换编码，让它识别中文，具体编码也是根据实际情况而定。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ftp客户端的速度也是要根据网速来的，可能比一般http快，但是面对网速慢的情况也是无可奈何！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：还是项目需要，要定时执行一个文件下载业务，一开始方向有点错，但是还好纠正过来了，采用ftp下载，但是ftp下载也有各种坑！
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="ftp" scheme="http://bestlixiang.site/tags/ftp/"/>
    
  </entry>
  
  <entry>
    <title>js原型和原型链</title>
    <link href="http://bestlixiang.site/2017/07/13/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://bestlixiang.site/2017/07/13/js原型和原型链/</id>
    <published>2017-07-13T00:26:14.000Z</published>
    <updated>2017-07-13T00:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：刚刚说了闭包，那就不放过js的另一大难点了——js原型以及原型链。<a id="more"></a></p>
<h2 id="谈谈"><a href="#谈谈" class="headerlink" title="谈谈"></a>谈谈</h2><p>神图镇楼：<br><img src="http://o6plzvjf2.bkt.clouddn.com/prototype.jpg" alt="原型链图"><br>自己写了好几遍内容，但是自己发现还是不能系统的理解，自己也写不了多好，看来要到自己安心写前端的时候，再来补上了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.jianshu.com/p/dee9f8b14771" target="_blank" rel="external">最详尽的 JS 原型与原型链终极详解（一）</a></li>
<li><a href="http://www.jianshu.com/p/652991a67186" target="_blank" rel="external">最详尽的 JS 原型与原型链终极详解（二）</a></li>
<li><a href="http://www.jianshu.com/p/a4e1e7b6f4f8" target="_blank" rel="external">最详尽的 JS 原型与原型链终极详解（三）</a></li>
</ol>
<p>个人感觉上面的文章还不错，可能还缺了继承那块的讲解，等自己再来的时候一起补上吧！！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：刚刚说了闭包，那就不放过js的另一大难点了——js原型以及原型链。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="javascript" scheme="http://bestlixiang.site/tags/javascript/"/>
    
      <category term="原型" scheme="http://bestlixiang.site/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>浅谈js闭包</title>
    <link href="http://bestlixiang.site/2017/07/12/%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85/"/>
    <id>http://bestlixiang.site/2017/07/12/浅谈js闭包/</id>
    <published>2017-07-12T01:21:01.000Z</published>
    <updated>2017-07-15T01:08:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：最近项目前端用了angular2，里面使用的TypeScript,其实很多和Java挺像的，学起来还是挺快的。但是里面的很多变量的原理都是根据闭包来实现的，那就好好了解一下闭包。<a id="more"></a></p>
<h2 id="闭包定义"><a href="#闭包定义" class="headerlink" title="闭包定义"></a>闭包定义</h2><p>根据Mozilla开发者文档定义：</p>
<p>闭包是指向独立变量的“函数”,用通俗的话说就是会“记住”它创建时的环境。</p>
<h2 id="闭包涉及的主要概念"><a href="#闭包涉及的主要概念" class="headerlink" title="闭包涉及的主要概念"></a>闭包涉及的主要概念</h2><ol>
<li>作用域链</li>
</ol>
<p>作用域链是函数在定义的时候创建的,用于寻找使用到的变量的值的一个索引。它内部的规则是,把函数自身的本地变量放在最前面,把自身的父级函数中的变量放在其次,把再高一级函数中的变量放在更后面,以此类推直至全局对象为止.当函数中需要查询一个变量的值的时候,js解释器会去作用域链去查找,从最前面的本地变量中先找,如果没有找到对应的变量,则到下一级的链上找,一旦找到了变量,则不再继续.如果找到最后也没找到需要的变量,则解释器返回undefined.</p>
<ol>
<li>内存回收机制</li>
</ol>
<p>一个函数在执行开始的时候,会给其中定义的变量划分内存空间保存,以备后面的语句所用,等到函数执行完毕返回了,这些变量就被认为是无用的了.对应的内存空间也就被回收了.下次再执行此函数的时候,所有的变量又回到最初的状态,重新赋值使用.但是如果这个函数内部又嵌套了另一个函数,而这个函数是有可能在外部被调用到的.并且这个内部函数又使用了外部函数的某些变量的话.这种内存回收机制就会出现问题.如果在外部函数返回后,又直接调用了内部函数,那么内部函数就无法读取到他所需要的外部函数中变量的值了.所以js解释器在遇到函数定义的时候,会自动把函数和他可能使用的变量(包括本地变量和父级和祖先级函数的变量(自由变量))一起保存起来.也就是构建一个闭包,这些变量将不会被内存回收器所回收,只有当内部的函数不可能被调用以后(例如被删除了,或者没有了指针),才会销毁这个闭包,而没有任何一个闭包引用的变量才会被下一次内存回收启动时所回收.</p>
<h2 id="闭包现象"><a href="#闭包现象" class="headerlink" title="闭包现象"></a>闭包现象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var results = [];</div><div class="line">for (var i = 0; i &lt;3; i++) &#123;</div><div class="line">results[i] = function() &#123;</div><div class="line">console.log(i);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">results[0](); //3</div><div class="line">results[1](); //3</div><div class="line">results[2](); //3</div></pre></td></tr></table></figure>
<p>解析：其实这里return出来的是一个function（我们可以理解为他是一个字符串，还没有执行），等到我们去执行他的时候，只保存了他上一级的作用域链里面的i的索引,那个时候i已经是3了。</p>
<h2 id="闭包解决"><a href="#闭包解决" class="headerlink" title="闭包解决"></a>闭包解决</h2><p>让内部函数在循环创建的时候立即执行,并且捕捉当前的索引值,然后记录在自己的一个本地变量里.然后利用返回函数的方法,重写内部函数,让下一次调用的时候,返回本地变量的值,改进后的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var results = [];</div><div class="line">for (var i = 0; i &lt;3; i++) &#123;</div><div class="line">results[i] = (function(j) &#123;</div><div class="line">return function()&#123;</div><div class="line">console.log(j);</div><div class="line">&#125;</div><div class="line">&#125;)(i);</div><div class="line">&#125;</div><div class="line">results[0](); //0</div><div class="line">results[1](); //1</div><div class="line">results[2](); //2</div></pre></td></tr></table></figure></p>
<p>我们发现通过立即执行表达式就可以解决闭包的现象得到我们想要得到的现象。</p>
<h2 id="闭包应用"><a href="#闭包应用" class="headerlink" title="闭包应用"></a>闭包应用</h2><h3 id="闭包与静态变量"><a href="#闭包与静态变量" class="headerlink" title="闭包与静态变量"></a>闭包与静态变量</h3><p>前面就说TypeScript与Java很像，所以类中的静态变量也是有的。</p>
<p>TypeScript代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Counter &#123;</div><div class="line">private static COUNTER = 0;</div><div class="line">constructor() &#123;&#125;</div><div class="line">private changeBy(val) &#123;</div><div class="line">Counter.COUNTER +=val;</div><div class="line">&#125;</div><div class="line">public increment() &#123;</div><div class="line">this.changeBy(1);</div><div class="line">&#125;</div><div class="line">public decrement() &#123;</div><div class="line">this.changeBy(-1);</div><div class="line">&#125;</div><div class="line">public value() &#123;</div><div class="line">return Counter.COUNTER;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译之后的js代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var Counter = (function () &#123;</div><div class="line">function Counter() &#123;</div><div class="line">&#125;</div><div class="line">Counter.prototype.changeBy = function (val) &#123;</div><div class="line">Counter.COUNTER += val;</div><div class="line">&#125;;</div><div class="line">Counter.prototype.increment = function () &#123;</div><div class="line">this.changeBy(1);</div><div class="line">&#125;;</div><div class="line">Counter.prototype.decrement = function () &#123;</div><div class="line">this.changeBy(-1);</div><div class="line">&#125;;</div><div class="line">Counter.prototype.value = function () &#123;</div><div class="line">return Counter.COUNTER;</div><div class="line">&#125;;</div><div class="line">Counter.COUNTER = 0;</div><div class="line">return Counter;</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<p>从js代码可以看书静态变量COUNTER是属于Counter类的，并不属于对象原型。所有Counter实例都共享Counter的同一个闭包上下文环境（COUNTER）。所以COUNTER会表现像单例一样。</p>
<h3 id="闭包和私有成员"><a href="#闭包和私有成员" class="headerlink" title="闭包和私有成员"></a>闭包和私有成员</h3><p>TypeScript由于性能原因并没有使用闭包来模拟私有变量，他使用过编译检查机制来形成私有变量的特性。但是我们可以使用闭包来实现私有变量。</p>
<p>js代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function makeCounter() &#123;</div><div class="line">var COUNTERR = 0;</div><div class="line">function Counter() &#123;</div><div class="line">&#125;</div><div class="line">function changeBy(val) &#123;</div><div class="line">COUNTER += val;</div><div class="line">&#125;;</div><div class="line">Counter.prototype.increment = function () &#123;</div><div class="line">this.changeBy(1);</div><div class="line">&#125;;</div><div class="line">Counter.prototype.decrement = function () &#123;</div><div class="line">this.changeBy(-1);</div><div class="line">&#125;;</div><div class="line">Counter.prototype.value = function () &#123;</div><div class="line">return COUNTER;</div><div class="line">&#125;;</div><div class="line">return new Counter();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出，每一个新的makeCounter实例都拥有自己的上下文环境，其他实例访问不了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习这么久的js发现，其实闭包真的无处不在，需要好好学习，好好总结，如有不对，也希望大家能够指出。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>链接：<a href="http://blog.csdn.net/u011411356/article/details/50208433" target="_blank" rel="external">js中闭包原理谈和原型及例子</a></p>
<p>书籍：Learning TypeScript中文版</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：最近项目前端用了angular2，里面使用的TypeScript,其实很多和Java挺像的，学起来还是挺快的。但是里面的很多变量的原理都是根据闭包来实现的，那就好好了解一下闭包。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="javascript" scheme="http://bestlixiang.site/tags/javascript/"/>
    
      <category term="闭包" scheme="http://bestlixiang.site/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Java日志那些事</title>
    <link href="http://bestlixiang.site/2017/07/12/Java%E6%97%A5%E5%BF%97%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://bestlixiang.site/2017/07/12/Java日志那些事/</id>
    <published>2017-07-12T01:14:19.000Z</published>
    <updated>2017-07-12T01:16:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：一直都知道日志文件很重要，可以记录一些相关信息，但是可能是程序需要调试的内容太少，也或者是项目太小，所以看看控制台的信息就够了，但是这次接触的项目越来越大，控制台额信息越来越多，经常会看不到自己想要看到的信息时，这个时候使用日志就发现十分得有必要了！<a id="more"></a></p>
<h2 id="日志的好处"><a href="#日志的好处" class="headerlink" title="日志的好处"></a>日志的好处</h2><ol>
<li>方便调试(如上)</li>
<li>方便发现系统运行中的错误</li>
<li>存储业务数据，便于日后分析</li>
</ol>
<h2 id="日志实现方式"><a href="#日志实现方式" class="headerlink" title="日志实现方式"></a>日志实现方式</h2><ol>
<li>自己实现类通过io存储到文件中</li>
<li>使用log4j将日志输入到控制台，文本文件，一集数据库中。</li>
<li>使用jdk自带的logging.jar包中方法（同一作者还有lognback）</li>
<li>使用slfj，它提供了上述两种方法的接口。</li>
</ol>
<h2 id="日志的输出-以log4j为例"><a href="#日志的输出-以log4j为例" class="headerlink" title="日志的输出(以log4j为例)"></a>日志的输出(以log4j为例)</h2><ol>
<li>输入到控制台</li>
</ol>
<p>运行程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class LoggerTest &#123;</div><div class="line">public static Logger logger1 = Logger.getLogger(LoggerTest.class);</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">logger1.trace(&quot;我是logger1，trace&quot;);</div><div class="line">logger1.debug(&quot;我是logger1，debug&quot;);</div><div class="line">logger1.info(&quot;我是logger1，info&quot;);</div><div class="line">logger1.warn(&quot;我是logger1，warn&quot;);</div><div class="line">logger1.error(&quot;我是logger1，error&quot;);</div><div class="line">logger1.fatal(&quot;我是logger1，fatal&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">### 设置级别和目的地(这里多个目的地) ###</div><div class="line">log4j.rootLogger = DEBUG,CONSOLE</div><div class="line">### 这里的com.todorex是包，也就是在这个包记录日志时，是只记录debug及以上级别的日志</div><div class="line">log4j.logger.com.todorex=DEBUG</div><div class="line">### 输出到控制台 ###</div><div class="line">log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppender</div><div class="line">log4j.appender.CONSOLE.Target = System.out</div><div class="line">log4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.CONSOLE.layout.ConversionPattern =  %d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</div></pre></td></tr></table></figure></p>
<p>控制台输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">11:35:09,969 DEBUG LoggerTest:12 [main:0]- 我是logger1，debug</div><div class="line">11:35:09,972  INFO LoggerTest:13 [main:3]- 我是logger1，info</div><div class="line">11:35:09,972  WARN LoggerTest:14 [main:3]- 我是logger1，warn</div><div class="line">11:35:09,972 ERROR LoggerTest:15 [main:3]- 我是logger1，error</div><div class="line">11:35:09,972 FATAL LoggerTest:16 [main:3]- 我是logger1，fatal</div></pre></td></tr></table></figure></p>
<ol>
<li>输入到日志文件<br>运行程序同上；<br>配置文件如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">### 设置级别和目的地(这里可以多个目的地) ###</div><div class="line">log4j.rootLogger = trace,demoLog</div><div class="line">log4j.logger.com.todorex=DEBUG</div><div class="line"></div><div class="line">### 输出到控制台 ###</div><div class="line">log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppender</div><div class="line">log4j.appender.CONSOLE.Target = System.out</div><div class="line">log4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.CONSOLE.layout.ConversionPattern =  %d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L [%t:%r]- %m%n</div><div class="line"></div><div class="line">### 输出到日志文件（文件目录一定要是绝对路径且存在） ###</div><div class="line">log4j.appender.demoLog = org.apache.log4j.DailyRollingFileAppender</div><div class="line">log4j.appender.demoLog.File =/var/alldata/mylog.log</div><div class="line">log4j.appender.demoLog.Append = true</div><div class="line">## 只输出DEBUG级别以上的日志</div><div class="line">log4j.appender.demoLog.Threshold = DEBUG</div><div class="line">#&apos;.&apos;yyyy-MM-dd: 每天产生一个新的文件</div><div class="line">log4j.appender.demoLog.DatePattern = &apos;.&apos;yyyy-MM-dd</div><div class="line">log4j.appender.demoLog.layout = org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.demoLog.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%t:%r] - [%p] [%c&#123;1&#125;:%L] [%M] %m%n</div></pre></td></tr></table></figure>
</li>
</ol>
<p>文件内容同控制台输出，但是却比控制台清楚得多，不会被乱七八糟的信息给遮盖。</p>
<ol>
<li>输入到数据库</li>
</ol>
<p>运行程序:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class LoggerTest &#123;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">Logger logger = Logger.getLogger(LoggerTest.class);</div><div class="line">logger.info(&quot;good&quot;);</div><div class="line">logger.debug(&quot;success&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">log4j.rootLogger=trace,CONSOLE,demoLog</div><div class="line"># com.todorex包下面所有的日志输出的级别设为DEBUG</div><div class="line">log4j.logger.com.todorex=DEBUG</div><div class="line"># 数据库输出</div><div class="line">log4j.appender.demoLog=org.apache.log4j.jdbc.JDBCAppender</div><div class="line">log4j.appender.demoLog.driver=com.mysql.jdbc.Driver</div><div class="line">log4j.appender.demoLog.URL=jdbc:mysql://127.0.0.1:3306/test</div><div class="line">log4j.appender.demoLog.user=root</div><div class="line">log4j.appender.demoLog.password=root</div><div class="line"># 在数据库对应的位置建一个对应的log表</div><div class="line">log4j.appender.demoLog.sql=insert into log(level,category,thread,time,location,note) values(&apos;%p&apos;,&apos;%c&apos;,&apos;%t&apos;,&apos;%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;&apos;,&apos;%l&apos;,&apos;%m&apos;)</div></pre></td></tr></table></figure></p>
<p>数据库的具体内容就不贴出来了，和普通看到的一样。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实日志用几次就知道它的好了，自己也是在慢慢学习！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：一直都知道日志文件很重要，可以记录一些相关信息，但是可能是程序需要调试的内容太少，也或者是项目太小，所以看看控制台的信息就够了，但是这次接触的项目越来越大，控制台额信息越来越多，经常会看不到自己想要看到的信息时，这个时候使用日志就发现十分得有必要了！
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="日志" scheme="http://bestlixiang.site/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>jpa实体映射关系</title>
    <link href="http://bestlixiang.site/2017/06/15/jpa%E5%AE%9E%E4%BD%93%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://bestlixiang.site/2017/06/15/jpa实体映射关系/</id>
    <published>2017-06-15T00:47:03.000Z</published>
    <updated>2017-06-15T00:51:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：其实距离自己上次写数据库操作已经1个多月了，之前接触的就是Hibernate，这次接触jpa，就把几种对应关系理清。<a id="more"></a></p>
<h1 id="映射策略"><a href="#映射策略" class="headerlink" title="映射策略"></a>映射策略</h1><p>注：这次举的例子都是User和Car的</p>
<h2 id="外键关联"><a href="#外键关联" class="headerlink" title="外键关联"></a>外键关联</h2><p>简介：两个表的关系定义在其中一个表中</p>
<h3 id="OneToOne"><a href="#OneToOne" class="headerlink" title="@OneToOne"></a>@OneToOne</h3><p>方法一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@OneToOne(cascade=CascadeType.ALL, fetch=FetchType.EAGER)</div><div class="line">@JoinColumn(name = &quot;user_id&quot;)</div><div class="line">private Car car;</div></pre></td></tr></table></figure></p>
<p>通过在Car表中加入一个外键，实现两者关系。<br>方法二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@OneToOne(cascade = CascadeType.ALL,fetch = FetchType.EAGER,mappedBy = &quot;Car&quot;)</div><div class="line">private User user;</div></pre></td></tr></table></figure></p>
<p>通过在Car类中用MappedBy声明让User进行维护。</p>
<h3 id="OneToMany"><a href="#OneToMany" class="headerlink" title="@OneToMany"></a>@OneToMany</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)</div><div class="line">@JoinColumn(name = &quot;user_id&quot;)</div><div class="line">private Set&lt;Car&gt; cars;</div></pre></td></tr></table></figure>
<p>通过在Car表中加入一个外键，实现一对多关系。</p>
<h3 id="ManyToMany"><a href="#ManyToMany" class="headerlink" title="@ManyToMany"></a>@ManyToMany</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)</div><div class="line">private Set&lt;Car&gt; cars;</div></pre></td></tr></table></figure>
<p>这个是采用默认的表关联</p>
<h2 id="表关联"><a href="#表关联" class="headerlink" title="表关联"></a>表关联</h2><p>简介：两个表的关系通过一张中间表来来关联</p>
<h3 id="OneToMany-1"><a href="#OneToMany-1" class="headerlink" title="@OneToMany"></a>@OneToMany</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)</div><div class="line">@JoinTable(name = &quot;user_car&quot;,</div><div class="line">joinColumns=&#123;@JoinColumn(name = &quot;user_id&quot;)&#125;,</div><div class="line">inverseJoinColumns = &#123;@JoinColumn(name = &quot;car_id&quot;)&#125;)</div><div class="line">private Set&lt;Car&gt; cars;</div></pre></td></tr></table></figure>
<p>通过JoinTable来确定一张中间表，joinColumns里面放父表的属性，inverseJoinColumns放子表的属性</p>
<h3 id="ManyToMany-1"><a href="#ManyToMany-1" class="headerlink" title="@ManyToMany"></a>@ManyToMany</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@ManyToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)</div><div class="line">@JoinTable(name = &quot;user_car&quot;,</div><div class="line">joinColumns=&#123;@JoinColumn(name = &quot;user_id&quot;)&#125;,</div><div class="line">inverseJoinColumns = &#123;@JoinColumn(name = &quot;car_id&quot;)&#125;)</div><div class="line">private Set&lt;Car&gt; cars;</div></pre></td></tr></table></figure>
<p>解释如@OneToMany</p>
<h2 id="一些属性"><a href="#一些属性" class="headerlink" title="一些属性"></a>一些属性</h2><h3 id="cascade属性"><a href="#cascade属性" class="headerlink" title="cascade属性"></a>cascade属性</h3><ol>
<li>CascadeType.PERSIST：级联新建</li>
<li>CascadeType.REMOVE：级联删除</li>
<li>CascadeType.REFRESH：级联刷新</li>
<li>CascadeType.MERGE：级联更新</li>
<li>CascadeType.ALL：包括上面四项</li>
</ol>
<h3 id="fetch属性"><a href="#fetch属性" class="headerlink" title="fetch属性"></a>fetch属性</h3><ol>
<li>FetchType.EAGER：相当于禁用懒加载，推荐开发使用</li>
<li>FetchType.LAZY：懒加载，默认值，推荐部署使用</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>父表是提供主键的，子表是利用父表的主键来设置外键的，维护方是Owner，被维护方是Owned。提示自己一个傻逼的问题，插入数据要先往两张表中插入数据，在往中间表插入数据，不然会报错~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：其实距离自己上次写数据库操作已经1个多月了，之前接触的就是Hibernate，这次接触jpa，就把几种对应关系理清。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="sping" scheme="http://bestlixiang.site/tags/sping/"/>
    
      <category term="jpa" scheme="http://bestlixiang.site/tags/jpa/"/>
    
  </entry>
  
  <entry>
    <title>springboot项目调试angular2</title>
    <link href="http://bestlixiang.site/2017/06/01/springboot%E9%A1%B9%E7%9B%AE%E8%B0%83%E8%AF%95angular2/"/>
    <id>http://bestlixiang.site/2017/06/01/springboot项目调试angular2/</id>
    <published>2017-06-01T01:43:33.000Z</published>
    <updated>2017-06-01T01:45:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在接触 springboot和angular2的前后端项目的时候，我发现自己会先把angular2的项目编译好之后放在springboot的resource目录下的static文件夹下运行，虽然这样可以，但是对于前端来调试代码实在不方便。在百度网上的<a href="http://note.youdao.com/" target="_blank" rel="external">方法</a>之后可以采用如下代理的方式。<a id="more"></a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>angular2启动的服务默认为<a href="http://localhost:4200" target="_blank" rel="external">http://localhost:4200</a></li>
<li>springboot启动的服务默认为<a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a></li>
</ol>
<p>如果我们直接设置angular2访问的路径为<a href="http://localhost:8080就会出现跨域访问的问题。请求不到数据。" target="_blank" rel="external">http://localhost:8080就会出现跨域访问的问题。请求不到数据。</a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>在angular2项目的根目录下面新建一个proxy.config.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;/api&quot;: &#123;</div><div class="line">&quot;target&quot;: &quot;http://localhost:8081&quot;,</div><div class="line">&quot;secure&quot;: false</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在启动项目的时候采用下面的命令</p>
<p>ng serve –proxy-config proxy.config.json</p>
<p>通过这样的代理访问就能能够实现跨域访问请求数据。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的方法方便了开发调试，不错，终于要开始写代码了！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在接触 springboot和angular2的前后端项目的时候，我发现自己会先把angular2的项目编译好之后放在springboot的resource目录下的static文件夹下运行，虽然这样可以，但是对于前端来调试代码实在不方便。在百度网上的&lt;a href=&quot;http://note.youdao.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;方法&lt;/a&gt;之后可以采用如下代理的方式。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="springboot" scheme="http://bestlixiang.site/tags/springboot/"/>
    
      <category term="angular2" scheme="http://bestlixiang.site/tags/angular2/"/>
    
  </entry>
  
</feed>
