<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rex note</title>
  <subtitle>雨过，云过</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bestlixiang.site/"/>
  <updated>2018-04-09T04:42:10.000Z</updated>
  <id>http://bestlixiang.site/</id>
  
  <author>
    <name>rex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>走进Linux_防火墙配置</title>
    <link href="http://bestlixiang.site/2018/04/09/%E8%B5%B0%E8%BF%9BLinux-%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"/>
    <id>http://bestlixiang.site/2018/04/09/走进Linux-防火墙配置/</id>
    <published>2018-04-09T04:41:43.000Z</published>
    <updated>2018-04-09T04:42:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：保障数据的安全性是继保障数据的可用性之后最为重要的一项工作。防火墙作为公网与内网之间的保护屏障，在保障数据的安全性方面起着至关重要的作用。<a id="more"></a></p>
<h1 id="防火墙管理工具"><a href="#防火墙管理工具" class="headerlink" title="防火墙管理工具"></a>防火墙管理工具</h1><p>在公网与企业内网之间充当保护屏障的防火墙虽然有软件或硬件之分，但主要功能都是 <strong>依据策略对穿越防火墙自身的流量进行过滤。</strong> 防火墙策略可以基于流量的源目地址、端口号、协议、应用等信息来定制，然后防火墙使用预先定制的策略规则监控出入的流量，若流量与某一条策略规则相匹配，则执行相应的处理，反之则丢弃。这样一来，就可以保证仅有合法的流量在企业内网和外部公网之间流动了。</p>
<p>在Centos 7系统中，firewalld防火墙取代了iptables防火墙。但是 <strong>iptables与firewalld都不是真正的防火墙</strong> ，它们都只是用来定义防火墙策略的 <strong>防火墙管理工具</strong> 而已，或者说，它们只是一种 <strong>服务</strong> 。iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。虽然这些工具各有优劣，但它们在防火墙策略的配置思路上是保持一致的。</p>
<h1 id="Iptables"><a href="#Iptables" class="headerlink" title="Iptables"></a>Iptables</h1><p>在早期的Linux系统中，默认使用的是iptables防火墙管理服务来配置防火墙。尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables。</p>
<h2 id="策略与规则链"><a href="#策略与规则链" class="headerlink" title="策略与规则链"></a>策略与规则链</h2><p>防火墙会从上至下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。<strong>一般而言，防火墙策略规则的设置有两种：一种是“通”（即放行），一种是“堵”（即阻止）。当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否则谁都进不来；如果防火墙的默认策略为允许时，就要设置拒绝规则，否则谁都能进来，</strong> 防火墙也就失去了防范的作用。</p>
<p>iptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下：</p>
<ul>
<li>在进行路由选择前处理数据包（PREROUTING）</li>
<li>处理流入的数据包（INPUT）</li>
<li>处理流出的数据包（OUTPUT）</li>
<li>处理转发的数据包（FORWARD）</li>
<li>在进行路由选择后处理数据包（POSTROUTING）</li>
</ul>
<p>一般来说，从内网向外网发送的流量一般都是可控且良性的，<strong>因此我们使用最多的就是INPUT规则链</strong>， 该规则链可以增大黑客人员从外网入侵内网的难度。</p>
<p>iptables还可以选择采用什么样的动作来处理这些匹配的流量，比如“允许”、“拒绝”、“登记”、“不理它”。这些动作对应到iptables服务的术语中分别是</p>
<ul>
<li>ACCEPT（允许流量通过）</li>
<li>REJECT（拒绝流量通过）：</li>
<li>LOG（记录日志信息）</li>
<li>DROP（拒绝流量通过）。</li>
</ul>
<p>“允许流量通过”和“记录日志信息”都比较好理解，这里需要着重讲解的是REJECT和DROP的不同点。就DROP来说，它是直接将流量丢弃而且不响应；REJECT则会在拒绝流量后再回复一条“您的信息已经收到，但是被扔掉了”信息，从而让流量发送方清晰地看到数据被拒绝的响应信息。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>iptables是一款基于命令行的防火墙策略管理工具，对于日常的防火墙策略配置来讲，只需要掌握常用的参数并做到灵活搭配即可，这就足以应对日常工作了。</p>
<p>iptables命令可以根据<strong>流量的源地址、目的地址、传输协议、服务类型等信息进行匹配</strong>，一旦匹配成功，iptables就会根据策略规则所预设的动作来处理这些流量。另外，再次提醒一下，<strong>防火墙策略规则的匹配顺序是从上至下的，因此要把较为严格、优先级较高的策略规则放到前面，以免发生错误</strong>。下表总结归纳了常用的iptables命令参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-P</td>
<td>设置默认策略</td>
</tr>
<tr>
<td>-F</td>
<td>清空规则链</td>
</tr>
<tr>
<td>-L</td>
<td>查看规则链</td>
</tr>
<tr>
<td>-A</td>
<td>在规则链的末尾加入新规则</td>
</tr>
<tr>
<td>-I num</td>
<td>在规则链的头部加入新规则</td>
</tr>
<tr>
<td>-D num</td>
<td>删除某一条规则</td>
</tr>
<tr>
<td>-s</td>
<td>匹配来源地址IP/MASK，加叹号“!”表示除这个IP外</td>
</tr>
<tr>
<td>-d</td>
<td>匹配目标地址</td>
</tr>
<tr>
<td>-i</td>
<td>网卡名称    匹配从这块网卡流入的数据</td>
</tr>
<tr>
<td>-o</td>
<td>网卡名称    匹配从这块网卡流出的数据</td>
</tr>
<tr>
<td>-p</td>
<td>匹配协议，如TCP、UDP、ICMP</td>
</tr>
<tr>
<td>–dport num</td>
<td>匹配目标端口号</td>
</tr>
<tr>
<td>–sport num</td>
<td>匹配来源端口号</td>
</tr>
</tbody>
</table>
<p>范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 1. 查看已有的防火墙规则链</div><div class="line">iptables -L</div><div class="line"></div><div class="line">// 2. 清空已有的防火墙规则链</div><div class="line">iptables -F</div><div class="line"></div><div class="line">// 3. 把INPUT规则链的默认策略设置为拒绝(规则链的默认策略拒绝动作只能是DROP，而不能是REJECT)</div><div class="line">// 特别注意，如果你是在云服务上做实验，千万不要这样做，因为它会由于防火墙断开你的ssh连接，只能到控制台登录修改。</div><div class="line">iptables -P INPUT DROP</div><div class="line"></div><div class="line">// 4. 向INPUT链中添加拒绝ICMP流量进入的策略规则</div><div class="line">iptables -I INPUT -p icmp -j DROP</div><div class="line"></div><div class="line">// 5. 删除INPUT规则链中刚刚加入的那条策略（允许ICMP流量）</div><div class="line">iptables -D INPUT 1</div><div class="line"></div><div class="line">// 6. 将INPUT规则链设置为只允许指定网段的主机访问本机的22端口，拒绝来自其他所有主机的流量</div><div class="line">iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPT</div><div class="line"></div><div class="line">// 7. 向INPUT规则链中添加拒绝所有人访问本机12345端口的策略规则</div><div class="line">iptables -I INPUT -p tcp --dport 12345 -j REJECT</div><div class="line"></div><div class="line">// 8. 向INPUT规则链中添加拒绝192.168.10.5主机访问本机80端口（Web服务）的策略规则</div><div class="line">iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT</div><div class="line"></div><div class="line">// 9. 向INPUT规则链中添加拒绝所有主机访问本机1000～1024端口的策略规则</div><div class="line">iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT</div><div class="line"></div><div class="line">// 10. 使用iptables命令配置的防火墙规则默认会在系统下一次重启时失效，如果想让配置的防火墙策略永久生效，还要执行</div><div class="line">// 保存命令：</div><div class="line">service iptables save</div><div class="line">// 如果出现</div><div class="line">The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.</div><div class="line">需要如下操作：</div><div class="line">yum install iptables-services // 安装服务</div><div class="line">systemctl enable iptables // 设置开机启动iptables</div><div class="line">systemctl start iptables //打开iptables</div><div class="line">然后执行就可以了</div></pre></td></tr></table></figure></p>
<h1 id="Firewalld"><a href="#Firewalld" class="headerlink" title="Firewalld"></a>Firewalld</h1><p>Centos7系统中集成了多款防火墙管理工具，其中firewalld（Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器）服务是默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式。但是我们只介绍命令行界面。</p>
<h2 id="区域Zone"><a href="#区域Zone" class="headerlink" title="区域Zone"></a>区域Zone</h2><p>相较于传统的防火墙管理配置工具，<strong>firewalld支持动态更新技术并加入了区域（zone）的概念</strong>。简单来说，区域就是firewalld预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。从而极大地提升了防火墙策略的应用效率。firewalld中常见的区域名称（默认为public）以及相应的策略规则如下表所示：</p>
<table>
<thead>
<tr>
<th>区域</th>
<th>默认规则策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>trusted</td>
<td>允许所有的数据包</td>
</tr>
<tr>
<td>home</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>internal</td>
<td>等同于home区域</td>
</tr>
<tr>
<td>work</td>
<td>拒绝流入的流量，除非与流出的流量数相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>public</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>external</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>dmz</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>block</td>
<td>拒绝流入的流量，除非与流出的流量相关</td>
</tr>
<tr>
<td>drop</td>
<td>拒绝流入的流量，除非与流出的流量相关</td>
</tr>
</tbody>
</table>
<h2 id="基本使用：firewall-cmd"><a href="#基本使用：firewall-cmd" class="headerlink" title="基本使用：firewall-cmd"></a>基本使用：firewall-cmd</h2><p>firewall-cmd是firewalld防火墙配置管理工具的CLI（命令行界面）版本。它的参数一般都是以“长格式”来提供的，但是Centos7支持部分命令的参数补齐，其中就包含这条命令，美滋滋。也就是说，现在除了能用Tab键自动补齐命令或文件名等内容之外，还可以用Tab键来补齐下表中所示的长格式参数了：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>–get-default-zone</td>
<td>查询默认的区域名称</td>
</tr>
<tr>
<td>–set-default-zone=&lt;区域名称&gt;</td>
<td>设置默认的区域，使其永久生效</td>
</tr>
<tr>
<td>–get-zones</td>
<td>显示可用的区域</td>
</tr>
<tr>
<td>–get-services</td>
<td>显示预先定义的服务</td>
</tr>
<tr>
<td>–get-active-zones</td>
<td>显示当前正在使用的区域与网卡名称</td>
</tr>
<tr>
<td>–remove-source=</td>
<td>将源自此IP或子网的流量导向指定的区域</td>
</tr>
<tr>
<td>–remove-source=</td>
<td>不再将源自此IP或子网的流量导向某个指定区域</td>
</tr>
<tr>
<td>–add-interface=&lt;网卡名称&gt;</td>
<td>将源自该网卡的所有流量都导向某个指定区域</td>
</tr>
<tr>
<td>–change-interface=&lt;网卡名称&gt;</td>
<td>将某个网卡与区域进行关联</td>
</tr>
<tr>
<td>–list-all</td>
<td>显示当前区域的网卡配置参数、资源、端口以及服务等信息</td>
</tr>
<tr>
<td>–list-all-zones</td>
<td>显示所有区域的网卡配置参数、资源、端口以及服务等信息</td>
</tr>
<tr>
<td>–add-service=&lt;服务名&gt;</td>
<td>设置默认区域允许该服务的流量</td>
</tr>
<tr>
<td>–add-port=&lt;端口号/协议&gt;</td>
<td>设置默认区域允许该端口的流量</td>
</tr>
<tr>
<td>–remove-service=&lt;服务名&gt;</td>
<td>设置默认区域不再允许该服务的流量</td>
</tr>
<tr>
<td>–remove-port=&lt;端口号/协议&gt;</td>
<td>设置默认区域不再允许该端口的流量</td>
</tr>
<tr>
<td>–reload</td>
<td>让“永久生效”的配置规则立即生效，并覆盖当前的配置规则</td>
</tr>
<tr>
<td>–panic-on</td>
<td>开启应急状况模式</td>
</tr>
<tr>
<td>–panic-off</td>
<td>关闭应急状况模式</td>
</tr>
</tbody>
</table>
<p>与Linux系统中其他的防火墙策略配置工具一样，<strong>使用firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且随着系统的重启会失效。如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd命令正常设置防火墙策略时添加–permanent参数，这样配置的防火墙策略就可以永久生效了。但是使用永久生效模式设置的策略只有在系统重启之后才能自动生效。如果想让配置的策略立即生效，需要手动执行firewall-cmd –reload命令。</strong></p>
<p>使用范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">// 1. 查看firewalld服务当前所使用的区域</div><div class="line">firewall-cmd --get-default-zone</div><div class="line"></div><div class="line">// 2. 查询eth0网卡在firewalld服务中的区域</div><div class="line">firewall-cmd --get-zone-of-interface=eth0</div><div class="line"></div><div class="line">// 3. 把firewalld服务中eth0网卡的默认区域修改为external，并在系统重启后生效。</div><div class="line">// 分别查看当前与永久模式下的区域名称：</div><div class="line">firewall-cmd --permanent --zone=external --change-interface=eth0</div><div class="line">firewall-cmd --get-zone-of-interface=eth0</div><div class="line">firewall-cmd --permanent --get-zone-of-interface=eth0</div><div class="line"></div><div class="line">// 4. 把firewalld服务的当前默认区域设置为public</div><div class="line">firewall-cmd --set-default-zone=public</div><div class="line"></div><div class="line">// 5. 启动/关闭firewalld防火墙服务的应急状况模式，阻断一切网络连接（当远程控制服务器时请慎用）</div><div class="line">firewall-cmd --panic-on</div><div class="line">firewall-cmd --panic-off</div><div class="line"></div><div class="line">// 6. 查询public区域是否允许请求SSH和HTTPS协议的流量</div><div class="line">firewall-cmd --zone=public --query-service=ssh</div><div class="line">firewall-cmd --zone=public --query-service=https</div><div class="line"></div><div class="line">// 7. 把firewalld服务中请求HTTPS协议的流量设置为永久允许，并立即生效</div><div class="line">firewall-cmd --zone=public --add-service=https</div><div class="line">firewall-cmd --permanent --zone=public --add-service=https</div><div class="line">firewall-cmd --reload</div><div class="line"></div><div class="line">// 8. 把firewalld服务中请求HTTP协议的流量设置为永久拒绝，并立即生效</div><div class="line">firewall-cmd --permanent --zone=public --remove-service=http</div><div class="line">firewall-cmd --reload</div><div class="line"></div><div class="line">// 9. 把在firewalld服务中访问8080和8081端口的流量策略设置为允许，但仅限当前生效</div><div class="line">firewall-cmd --zone=public --add-port=8080-8081/tcp</div><div class="line"></div><div class="line">// 10. 把原本访问本机888端口的流量转发到22端口，要且求当前和长期均有效</div><div class="line">firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.10.10(目标地址)</div><div class="line">firewall-cmd --reload</div><div class="line"></div><div class="line">// 11. firewalld中的富规则表示更细致、更详细的防火墙策略配置，</div><div class="line">// 它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置。</div><div class="line">// 它的优先级在所有的防火墙策略中也是最高的。比如，我们可以在firewalld服务中配置一条富规则，使其拒绝192.168.10.0/24网段的所有用户访问本机的ssh服务（22端口）：</div><div class="line">firewall-cmd --permanent --zone=public --add-rich-rule=&quot;rule family=&quot;ipv4&quot; \</div><div class="line">source address=&quot;192.168.10.0/24&quot; service name=&quot;ssh&quot; reject&quot;</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.linuxprobe.com/chapter-08.html" target="_blank" rel="external">iptables与firewalld防火墙</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：保障数据的安全性是继保障数据的可用性之后最为重要的一项工作。防火墙作为公网与内网之间的保护屏障，在保障数据的安全性方面起着至关重要的作用。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_Linux中常用的网络命令</title>
    <link href="http://bestlixiang.site/2018/04/08/%E8%B5%B0%E8%BF%9BLinux_Linux%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://bestlixiang.site/2018/04/08/走进Linux_Linux中常用的网络命令/</id>
    <published>2018-04-08T12:51:27.000Z</published>
    <updated>2018-04-09T04:31:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：Linux的网络功能是相当强大的。所以我们必须要好好了解它，这里我们只是介绍一下常用的命令。<a id="more"></a></p>
<h1 id="设置网络参数的命令"><a href="#设置网络参数的命令" class="headerlink" title="设置网络参数的命令"></a>设置网络参数的命令</h1><h2 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h2><p>ifconfig主要是可以都手动启动、查看与修改网络接口的相关参数，范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 1. 查看所有网络接口</div><div class="line">ifconfig</div><div class="line">// 2. 查看eth0网卡</div><div class="line">ifconfig eth0</div><div class="line"></div><div class="line">输出：</div><div class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</div><div class="line">        inet 172.16.0.9  netmask 255.255.240.0  broadcast 172.16.15.255</div><div class="line">        ether 52:54:00:1c:91:2a  txqueuelen 1000  (Ethernet)</div><div class="line">        RX packets 15979545  bytes 1741444280 (1.6 GiB)</div><div class="line">        RX errors 0  dropped 0  overruns 0  frame 0</div><div class="line">        TX packets 15811187  bytes 2149680103 (2.0 GiB)</div><div class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</div><div class="line"></div><div class="line">* eth0：就是网络卡的代号，也有 lo 这个 loopback</div><div class="line">* mtu：网络接口的最大传输单元</div><div class="line">* inet：IPv4 的 IP 地址，后续是子网掩码和广播地址</div><div class="line">* RX：那一行代表的是网络由启动到目前为止的封包接收情况， packets 代表封包数、errors 代表封包发生错误的数量、 dropped 代表封包由于有问题而遭丢弃的数量等等</div><div class="line">* TX：与 RX 相反，为网络由启动到目前为止的传送情况；collisions：代表封包碰撞的情况，如果发生太多次， 表示您的网络状况不太好</div><div class="line"></div><div class="line">// 3. 暂时修改网络接口，给予eth0一个192.168.100.100/24的参数</div><div class="line">ifconfig eth0 192.168.100.100</div><div class="line"></div><div class="line">// 4. 将手动的处理全部取消，使用原有的设置值重置网络参数</div><div class="line">/etc/init.d/network restart</div></pre></td></tr></table></figure></p>
<h1 id="网络排错与查看命令"><a href="#网络排错与查看命令" class="headerlink" title="网络排错与查看命令"></a>网络排错与查看命令</h1><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>这个 ping 是很重要的指令，ping 主要透过 ICMP（Internet控制报文协议） 封包来进行整个网络的状况报告。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 1. 检测一下168.95.1.1这部DNS主机是否存在(存在于网络环境中)</div><div class="line">ping -c 3 168.95.1.1</div><div class="line"></div><div class="line">输出：</div><div class="line">PING 168.95.1.1 (168.95.1.1) 56(84) bytes of data.</div><div class="line">64 bytes from 168.95.1.1: icmp_seq=1 ttl=239 time=69.9 ms</div><div class="line">64 bytes from 168.95.1.1: icmp_seq=2 ttl=239 time=70.4 ms</div><div class="line">64 bytes from 168.95.1.1: icmp_seq=3 ttl=239 time=69.9 ms</div><div class="line"></div><div class="line">--- 168.95.1.1 ping statistics ---</div><div class="line">3 packets transmitted, 3 received, 0% packet loss, time 2002ms</div><div class="line">rtt min/avg/max/mdev = 69.920/70.119/70.467/0.328 ms</div><div class="line"></div><div class="line"></div><div class="line">// 2. 找出最大的MTU数值(如果有响应，那就是可以接受这个数据包，如果无响应，就表示这个MTU太大了)</div><div class="line">ping -c 2 -s 1000 -M do 192.168.1.254</div></pre></td></tr></table></figure></p>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>如果你觉得你的某个网络服务明明就启动了，但是就是无法造成联机的话，要查询一下自己的网络接口所监听的端口 (port) 来看看是否真的有启动。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 1. 列出当前路由表状态，且以IP及port number进行系那是</div><div class="line">netstat -rn</div><div class="line"></div><div class="line">// 2. 列出当前的所有网络连接状态，使用IP与port number</div><div class="line">netstat -an</div><div class="line"></div><div class="line">// 3. 显示目前已经启动的网络服务</div><div class="line">netstat -tulnp</div><div class="line"></div><div class="line">// 4. 查看本机上所有的网络连接状态</div><div class="line">netstat -atunp</div></pre></td></tr></table></figure></p>
<h2 id="host"><a href="#host" class="headerlink" title="host"></a>host</h2><p>这个命令可以用来查出某个主机名的IP，范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 列出www.yahoo.com的IP(向/etc/resolv.conf里面记录的DNS服务器查询IP)</div><div class="line">host www.yohoo.com</div></pre></td></tr></table></figure></p>
<h2 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h2><p>功能和host一样，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. 查询www.google.com的IP</div><div class="line">nslookup www.google.com</div><div class="line"></div><div class="line">// 2. 找出168.95.1.1的主机名   (建议使用dig)</div><div class="line">nslookup 168.95.1.1</div></pre></td></tr></table></figure>
<h1 id="远程连接命令与即时通信软件"><a href="#远程连接命令与即时通信软件" class="headerlink" title="远程连接命令与即时通信软件"></a>远程连接命令与即时通信软件</h1><h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p>telnet本身数据的在传输过程中使用的是明文，所以数据在Internet上面传输的时候，会比较危险。使用范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 1. 连接到当前热门的PTT BBS站点ptt.cc</div><div class="line">yum install telnet // 默认没有安装（自己未成功）</div><div class="line"></div><div class="line">// 2. 检测本地主机的110这个port是否正确启动,</div><div class="line">// 如果出现telnet: connect to address 127.0.0.1: Connection refused，代表这个port没有启动或者这个连接有问题</div><div class="line">telnet localhost 22</div></pre></td></tr></table></figure></p>
<h2 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h2><p>用于处理ftp服务器的下载数据，范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 连接到一个ftp服务器</div><div class="line">ftp ip //之后可以利用help来帮助操作</div></pre></td></tr></table></figure></p>
<h1 id="文字接口网页浏览"><a href="#文字接口网页浏览" class="headerlink" title="文字接口网页浏览"></a>文字接口网页浏览</h1><h2 id="links"><a href="#links" class="headerlink" title="links"></a>links</h2><p>最大的功能就是查阅Linux本机上面以html语法写成的文件数据。具体效果自己看吧，范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 浏览Linux kernel网站</div><div class="line">links http://www.kernel.org</div></pre></td></tr></table></figure></p>
<h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p>主要的功能是取得网页数据。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 1. 下载 2.6.17 版的linux内核</div><div class="line">wget \</div><div class="line">http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.17.tar.gz</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：Linux的网络功能是相当强大的。所以我们必须要好好了解它，这里我们只是介绍一下常用的命令。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_软件安装</title>
    <link href="http://bestlixiang.site/2018/04/08/Linux%E7%A7%81%E6%88%BF%E8%8F%9C-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://bestlixiang.site/2018/04/08/Linux私房菜-软件安装/</id>
    <published>2018-04-08T09:14:14.000Z</published>
    <updated>2018-04-09T04:34:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：当你拿到一台新电脑的第一反应是什么，当然是装软件，然后好好玩呀！服务器也是如此，所以你必须掌握软件的安装。<a id="more"></a></p>
<h1 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h1><h2 id="开放源码的软件安装相关概念"><a href="#开放源码的软件安装相关概念" class="headerlink" title="开放源码的软件安装相关概念"></a>开放源码的软件安装相关概念</h2><p>Linux上几乎所有的软件都经过了GPL授权，因此几乎所有的软件都会提供源码。<br>而一个软件要在Linux上执行，必须是二进制文件，因此当我们拿到软件源码后，需要将它编译成二进制文件才能在Linux上运行。</p>
<h3 id="开放源码、编译程序、可执行文件"><a href="#开放源码、编译程序、可执行文件" class="headerlink" title="开放源码、编译程序、可执行文件"></a>开放源码、编译程序、可执行文件</h3><ol>
<li>开放源码：就是程序代码，写给人类看的语言，但机器并不认识，所以无法执行。</li>
<li>编译程序：将程序代码转译称为机器看得懂的语言。</li>
<li>可执行文件：经过编译程序变成二进制程序后，机器看得懂所以可执行的文件。</li>
</ol>
<h3 id="函式库"><a href="#函式库" class="headerlink" title="函式库"></a>函式库</h3><p>类似子程序的角色，可以被呼叫来执行的一段功能函数。</p>
<h3 id="make与configure"><a href="#make与configure" class="headerlink" title="make与configure"></a>make与configure</h3><ol>
<li>configure:侦测用户操作环境，是否支持软件的运行，侦测完毕生成makefile文件<ul>
<li>是否有适合的编译程序可以编译本软件的程序代码</li>
<li>是否已经存在本软件所需要的函数库，或其他需要的相依软件</li>
<li>操作系统平台是否适合本软件，包括 Linux 的核心版本</li>
<li>核心的头文件定义档 (header include) 是否存在 (驱动程序必须要的侦测)。</li>
</ul>
</li>
<li>make:make是一个程序，会去找makefile文件，然后执行编译。</li>
</ol>
<h3 id="tarball软件"><a href="#tarball软件" class="headerlink" title="tarball软件"></a>tarball软件</h3><p>tarball文件其实就是将软件的源码先以tar打包，然后再压缩。其实就是一个<strong>软件包</strong>。通常解压缩之后会存在源代码文件、侦测程序文件（configure）、本软件的简易说明与安装说明（README）。</p>
<h2 id="Tarball的安装的基本步骤"><a href="#Tarball的安装的基本步骤" class="headerlink" title="Tarball的安装的基本步骤"></a>Tarball的安装的基本步骤</h2><ol>
<li>取得源文件：将tarball文件在/usr/local/src目录解压缩</li>
<li>取得步骤流程：进入新建立的目录下面，去查阅INSTALL与README等相关文件内容（很重要）</li>
<li>相关属性软件安装：根据INSTALL/README的内容查看并安装好一些相关的软件</li>
<li>建立makefile文件：以自动检测程序（configure）检测操作环境，并建立Makefile文件</li>
<li>编译：以make这个程序并使用该目录下得Makefile作为它的参数配置文件，来进行make的操作</li>
<li>安装：以make这个程序，并以Makefile这个参数配置文件，依据install这个目标（在Makefile文件中会有多个操作目标，如clean）的指定来安装到正确地路径。</li>
</ol>
<h2 id="Tarball软件安装的建议事项"><a href="#Tarball软件安装的建议事项" class="headerlink" title="Tarball软件安装的建议事项"></a>Tarball软件安装的建议事项</h2><p>在默认情况下，原本的Linux distribution发布安装的软件大多是在/usr里面的，而自行安装的软件则建议放置在/usr/local里面。</p>
<ul>
<li>linux distribution默认的安装软件的路径如下，以httpd为例：<ul>
<li>/etc/httpd（配置文件）</li>
<li>/usr/lib（函数库）</li>
<li>/usr/bin（可执行文件）</li>
<li>/usr/share/man（在线帮助文档）</li>
</ul>
</li>
<li>tarball安装，默认放在/usr/local，如下目录：（升级，删除不方便）<ul>
<li>/usr/local/etc</li>
<li>/usr/local/bin</li>
<li>/usr/local/lib</li>
<li>/usr/local/man</li>
</ul>
</li>
<li>tarball安装，但是单一软件都在同一个目录下，以apache为例：（利于删除，升级）<ul>
<li>/usr/local/apache/etc</li>
<li>/usr/local/apache/bin</li>
<li>/usr/local/apache/lib</li>
<li>/usr/local/apache/man</li>
</ul>
</li>
</ul>
<p>当然，<strong>实际安装的时候还是得视该软件的Makefile里头的install目标信息才能知道安装路径情况。</strong></p>
<p>为了方便Tarball的管理，这样建议：</p>
<ol>
<li>最好将tarball的原始数据解压缩到/usr/local/src当中</li>
<li>安装时，最好安装到/usr/local这个默认路径下</li>
<li>考虑将来的删除，最好可以将每个软件<strong>单独</strong>安装在/usr/local下面</li>
<li>为安装到单独目录的软件的man page加入到man path搜索，即在/etc/man.config增加一行。</li>
</ol>
<h2 id="简单安装范例（ntp时间服务器）"><a href="#简单安装范例（ntp时间服务器）" class="headerlink" title="简单安装范例（ntp时间服务器）"></a>简单安装范例（ntp时间服务器）</h2><p>假设这个软件在/opt下，解压到/usr/local/src，并安装到/usr/local/ntp目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/src //切换目录</div><div class="line"></div><div class="line">tar -zxvf /opt/ntp-4.2.4p7.tar.gz //解压缩到此目录</div><div class="line"></div><div class="line">cd ntp-4.2.4p7/</div><div class="line"></div><div class="line">vi INSTALL // 查阅安装信息</div><div class="line"></div><div class="line">// 检查configure支持参数，并实际生成makefile规则文件(很重要)</div><div class="line">./configure --help | more</div><div class="line"></div><div class="line">./configure --prefix=/usr/local/ntp \</div><div class="line">--enable-all-clocks --enable-parse-clocks //开始建立makefile（设置了安装目录等）</div><div class="line"></div><div class="line"></div><div class="line">// 开始编译并安装</div><div class="line">make clean; make</div><div class="line">make check</div><div class="line">make install</div></pre></td></tr></table></figure></p>
<h2 id="利用patch更新源码"><a href="#利用patch更新源码" class="headerlink" title="利用patch更新源码"></a>利用patch更新源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 基本语法</div><div class="line">1. patch -p 数字 &lt; patch_file  更新</div><div class="line">2. patch -R &lt; patch_file 还原更新</div><div class="line"></div><div class="line">假如patch_file第一行是***/home/guest/example/expatch.old，</div><div class="line">如果执行patch -p0  &lt; patch_file，则更新的文件是/home/guest/example/expatch.old，</div><div class="line">如果执行patch -p4  &lt; patch_file，则更新的文件是expatch.old，</div><div class="line">基本语法中数字是指拿掉第几个下划线之前的东西（包括下划线）。</div><div class="line"></div><div class="line">在更新之后，还是需要重新编辑，这才是最终的正确的软件。</div></pre></td></tr></table></figure>
<h1 id="RPM安装"><a href="#RPM安装" class="headerlink" title="RPM安装"></a>RPM安装</h1><h2 id="RPM和DPKG"><a href="#RPM和DPKG" class="headerlink" title="RPM和DPKG"></a>RPM和DPKG</h2><p>当前Linux上有两款主流的软件管理程序，分别是：RPM和DPKG。<br>这两款软件均提供在线升级机制。</p>
<ul>
<li><p>RPM</p>
<p>  RPM全称为Red Hat Package Manager，是Red Hat公司研发的Linux软件管理程序。目前CentOS、SuSE、Fedora等操作系统使用它。<br>  RPM使用YUM进行在线升级。</p>
</li>
<li><p>DPKG<br>  dpkg由Debian Linux开发，目前使用该软件的操作系统有Ubuntu、B2D等。<br>  dpkg使用apt-get进行在线升级。</p>
</li>
</ul>
<p>PS：什么是“在线升级机制”？<br>一个软件往往会依赖其他软件的一些功能，那么在安装过程中，只有确保一个软件所依赖的所有软件都被安装后，该软件才能被正确安装。<br>而在线升级机制能够在软件安装过程中，若发现该软件的依赖软件尚未安装，则会自动从互联网中下载所依赖的软件。这就是在线升级机制</p>
<h2 id="RPM默认安装的路径"><a href="#RPM默认安装的路径" class="headerlink" title="RPM默认安装的路径"></a>RPM默认安装的路径</h2><table>
<thead>
<tr>
<th>/etc</th>
<th>一些设置文件放置的目录，例如/etc/crontab</th>
</tr>
</thead>
<tbody>
<tr>
<td>/usr/bin</td>
<td>一些可执行文件</td>
</tr>
<tr>
<td>/usr/lib</td>
<td>一些程序使用的动态函数库</td>
</tr>
<tr>
<td>/usr/share/doc</td>
<td>一些基本的软件使用手册与帮助文档</td>
</tr>
<tr>
<td>/usr/share/man</td>
<td>一些man page文件</td>
</tr>
</tbody>
</table>
<h2 id="RPM安装-1"><a href="#RPM安装-1" class="headerlink" title="RPM安装"></a>RPM安装</h2><p>因为安装软件是root的工作，所以你必须是root用户才能使用rpm命令，使用范例如下(例子为安装rp-pppoe-3.5-32.1.i386.rpm)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 安装软件是，显示安装信息与进度</div><div class="line">rpm -ivh rp-pppoe-3.5-32.1.i386.rpm</div></pre></td></tr></table></figure></p>
<h2 id="RPM的升级与更新"><a href="#RPM的升级与更新" class="headerlink" title="RPM的升级与更新"></a>RPM的升级与更新</h2><p>范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rpm -Uvh 需要升级的软件名</div><div class="line"></div><div class="line">-Uvh:若待升级的软件尚未安装，则直接安装</div><div class="line"></div><div class="line">rpm -Fvh 需要升级的软件名</div><div class="line"></div><div class="line">-Fvh:若待升级的软件尚未安装，则该软件不会被安装</div></pre></td></tr></table></figure></p>
<h2 id="RPM查询"><a href="#RPM查询" class="headerlink" title="RPM查询"></a>RPM查询</h2><p>查询的信息分为两类，一类是查询已被安装的软件的信息(由/var/lib/rpm提供)，另一类是查询尚未被安装的软件安装包的信息。 第一类信息通过rpm -q查询，第二类信息通过rpm -qp查询。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 1. 找出你的Linux是否安装logrotate这个软件</div><div class="line">rpm -q logrorate</div><div class="line"></div><div class="line">// 2. 列出logrotate这个软件所提供的所有目录与文件</div><div class="line">rpm -ql logrorate</div><div class="line"></div><div class="line">// 3. 列出logrotate这个软件的相关文件说明</div><div class="line">rpm -qi logrorate</div><div class="line"></div><div class="line">// 4. 列出logrotate这个软件的设置文件与帮助文件</div><div class="line">rpm -qc logrorate</div><div class="line">rpm -qd logrorate</div><div class="line"></div><div class="line">// 5. 列出logrotate这个软件所依赖软件的文件</div><div class="line">rpm -qR logrorate</div><div class="line"></div><div class="line">// 6. 列出该文件属于哪一个软件</div><div class="line">rpm -qf /bin/sh</div></pre></td></tr></table></figure></p>
<h2 id="卸载RPM与重建数据库"><a href="#卸载RPM与重建数据库" class="headerlink" title="卸载RPM与重建数据库"></a>卸载RPM与重建数据库</h2><p>卸载一个软件非常方便，通过-e即可删除。但一个软件所提供的动态函数库被其他软件引用，那么该软件将无法卸载，除非将引用该函数库的所有软件都卸载后才能卸载。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 找出与pam有关的软件名称，并尝试删除pam这个软件</div><div class="line">rpm -qa | grep pam</div><div class="line">rpm -e pam（出错，因为你需要先删除依赖它的软件）</div><div class="line"></div><div class="line">2. 删除pam-devel软件</div><div class="line">rpm -e pam-devel (成功)</div></pre></td></tr></table></figure></p>
<p>当/var/lib/rpm内的文件发生损坏时，可以通过如下命令重建数据库修复：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm --rebuilddb</div></pre></td></tr></table></figure></p>
<h1 id="YUM安装"><a href="#YUM安装" class="headerlink" title="YUM安装"></a>YUM安装</h1><p>RPM虽然省去了编译过程，并且提供数据库存储软件的信息，但仍然需要我们手动下载RPM安装包，而YUM的出现解决了这一问题。较多软件的RPM安装包都存放在了YUM Server上，只要我们的计算机能连互联网，就能使用yum自动下载RPM安装包并安装软件。</p>
<h2 id="yum功能"><a href="#yum功能" class="headerlink" title="yum功能"></a>yum功能</h2><p>yum的使用非常简单，就是通过yum这个命令，用法范例如下：</p>
<ol>
<li><p>查询功能</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 1. 搜索磁盘阵列相关的软件</div><div class="line">yum search raid</div><div class="line"></div><div class="line">// 2. 找出mdadm这个软件的功能如何</div><div class="line">yum info mdadm</div><div class="line"></div><div class="line">// 3. 列出yum服务器上面提供的所有软件名称</div><div class="line">yum list</div><div class="line"></div><div class="line">// 4. 列出目前服务器上可供本机升级的软件有哪些</div><div class="line">yum list updates</div><div class="line"></div><div class="line">// 5. 列出提供passwd这个文件的软件有哪些</div><div class="line">yum provides passwd</div></pre></td></tr></table></figure>
</li>
<li><p>安装/升级功能</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 安装/升级pam-devel</div><div class="line">yum install/update pam-devel</div></pre></td></tr></table></figure>
</li>
<li><p>删除功能</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 删除pam-devel</div><div class="line">yum remove pam-devel</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="管理的选择：RPM-or-Tarball"><a href="#管理的选择：RPM-or-Tarball" class="headerlink" title="管理的选择：RPM or Tarball"></a>管理的选择：RPM or Tarball</h1><p>建议如下：</p>
<ol>
<li>优先选择原厂的RPM功能</li>
<li>选择软件官方网站发布的RPM或者是提供的容器网址（yum server）</li>
<li>利用Tabball安装特殊软件（没有RPM）</li>
<li>用Tarball测试新版软件</li>
</ol>
<p>RPM与Tarball各有优点，但是如果有RPM的话，优先选择RPM。如果无法解决依赖性问题，那就选tarball。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：当你拿到一台新电脑的第一反应是什么，当然是装软件，然后好好玩呀！服务器也是如此，所以你必须掌握软件的安装。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_daemon为服务(service)保驾护航</title>
    <link href="http://bestlixiang.site/2018/04/03/%E8%B5%B0%E8%BF%9BLinux_daemon%E4%B8%BA%E6%9C%8D%E5%8A%A1(service)%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA/"/>
    <id>http://bestlixiang.site/2018/04/03/走进Linux_daemon为服务(service)保驾护航/</id>
    <published>2018-04-03T08:59:47.000Z</published>
    <updated>2018-04-09T04:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：我们进程会听到daemon，但是却不知道其义，其实就是一个守护进程，作用是支持其他服务(service)的运行。我们下面可以好好看看linux中的daemon与service！<a id="more"></a></p>
<h1 id="什么是daemon与服务"><a href="#什么是daemon与服务" class="headerlink" title="什么是daemon与服务"></a>什么是daemon与服务</h1><p>系统为了某些功能必须要提供一些服务，这个服务就称为<strong>service</strong>。但是service的提供总是需要进程的运行，所以实现这个service的程序我们就称它为<strong>daemon</strong>。</p>
<h2 id="daemon的分类"><a href="#daemon的分类" class="headerlink" title="daemon的分类"></a>daemon的分类</h2><p>分类方式一：按照“是否可以独立启动”分类</p>
<ol>
<li>stand alone类型的daemon：这种类型的daemon可以自行启动，启动之后可以常驻内存，直到手动关闭该daemon才释放资源。如www。</li>
<li>由super daemon管理的daemon：这种类型的daemon由super daemon统一管理，当请求到来时，由super daemon启动请求的服务，请求完成后便释放内存资源。如telnet。</li>
</ol>
<p>分类方式二：按照“请求到来时是否能够立即运行”分类</p>
<ol>
<li><p>signal-control类型的daemon<br>这种类型的daemon当有请求到来时便能立即执行。如打印机服务。</p>
</li>
<li><p>interval-control类型的daemon<br>这种类型的daemon会周期性地执行某项工作，因此它没有请求一说，它会周期性地读取配置文件，并执行配置文件中要求的功能。如crond、atd都属于interval-control类型的daemon。</p>
</li>
</ol>
<p>通常在服务的名称的之后都会加一个d。</p>
<h2 id="网络服务与端口的对应"><a href="#网络服务与端口的对应" class="headerlink" title="网络服务与端口的对应"></a>网络服务与端口的对应</h2><p>当系统提供了网络服务，就会涉及到端口的问题，这些服务与端口的定义文件在/etc/services。大家可以自己查看一下。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tcpmux          1/tcp                           # TCP port service multiplexer</div><div class="line">tcpmux          1/udp                           # TCP port service multiplexer</div></pre></td></tr></table></figure></p>
<p>第一列为daemon的名称，第二列为该daemon所使用的端口号与网络数据包协议。</p>
<h2 id="daemon的启动脚本与启动方式"><a href="#daemon的启动脚本与启动方式" class="headerlink" title="daemon的启动脚本与启动方式"></a>daemon的启动脚本与启动方式</h2><p>stand-alone类型的daemon和super daemon类型的daemon有各自的启动方式</p>
<h3 id="stand-alone型Daemon的启动方式"><a href="#stand-alone型Daemon的启动方式" class="headerlink" title="stand alone型Daemon的启动方式"></a>stand alone型Daemon的启动方式</h3><ol>
<li><p>通过/etc/init.d/xxx启动。启动一个服务是一个繁琐的过程，你需要进行一系列启动前的操作，为了避免这些麻烦，服务提供商把这些繁琐的过程封装在一个shell srcipt中，我们只需执行一个shell script即可启动一个daemon。几乎所有的stand alone型daemon的启动脚本都放在/etc/init.d/下，所以我们只需执行 <strong>/etc/init.d/xxx start</strong> 即可启动xxx服务。</p>
</li>
<li><p>通过service命令启动。若每次启动一个命令都要写/etc/init.d/略微有些麻烦，service命令将其进行了封装，我们只要执行 <strong>“service xxx start/status/restart/stop”</strong> 即可开启/查看/重启/关闭xxx服务。</p>
</li>
</ol>
<h3 id="super-daemon型Daemon的启动方式"><a href="#super-daemon型Daemon的启动方式" class="headerlink" title="super daemon型Daemon的启动方式"></a>super daemon型Daemon的启动方式</h3><ol>
<li><p>设置daemon的配置文件，每一个被super daemon管理的daemon都有一个配置文件，在/etc/xinetd.d/目录下。每个daemon的开启或关闭均在该daemon对应的配置文件中设置。</p>
</li>
<li><p>启动super daemon，super daemon是一个stand alone型daemon，因此在daemon的配置文件设置好后可通过<strong>service xinetd start</strong>启动所有由super daemon管理的daemon。</p>
</li>
</ol>
<h1 id="解析super-daemon的配置文件"><a href="#解析super-daemon的配置文件" class="headerlink" title="解析super daemon的配置文件"></a>解析super daemon的配置文件</h1><h2 id="默认值配置文件：xinetd-conf"><a href="#默认值配置文件：xinetd-conf" class="headerlink" title="默认值配置文件：xinetd.conf"></a>默认值配置文件：xinetd.conf</h2><p>高版本的contos可能没有该文件，是因为没有安装，所以要先用“yum install xinetd”安装之后，就可以看见了。</p>
<p>super daemon的默认配置文件为:/etc/xinetd.conf，它为它所管理的所有daemon做了一些默认的配置。<br>从最后一行的includedir /etc/xinetd.d可以看出，它加载了它所管理的所有daemon的配置。</p>
<p>下面来看一下具体的某个daemon的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">service rsync #service后为daemon的名字</div><div class="line">&#123;</div><div class="line">        disable = yes  # yes表示关闭此daemon，no表示开启此daemon</div><div class="line">        socket_type     = stream #stream表示使用TCP、dgram表示使用UDP、raw表示直接与IP交互</div><div class="line">        wait            = no</div><div class="line">        user            = root #以什么用户的身份启动这个daemon</div><div class="line">        server          = /usr/bin/rsync #这个daemon的启动程序</div><div class="line">        server_args     = --daemon #启动时所需的参数</div><div class="line">        log_on_failure  += USERID # 登录失败时需要记录用户</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>=：表示将某个参数设为等号右侧的值，若先前设置中已设置过该参数，则直接覆盖</li>
<li>+=：表示保留先前设置的这个参数，再给这个参数增加个值。</li>
<li>-和-=的含义同上。</li>
</ul>
<h1 id="super-deamon的防火墙管理"><a href="#super-deamon的防火墙管理" class="headerlink" title="super deamon的防火墙管理"></a>super deamon的防火墙管理</h1><p>由于受super daemon管理的daemon的请求都首先需要经过super daemon，因此super daemon可以充当防火墙的角色，拒绝一些不安全的请求。<br>super daemon提供了两种防火墙机制，第一种方式提供较多详细的安全设置，而第二种方式只能阻挡或允许指定的IP，具体见下：</p>
<ol>
<li><p>使用受super daemon管理的daemon的配置文件实现防火墙机制</p>
<p> 在某个具体的daemon配置文件中添加如下参数，即可为daemon配置防火墙：</p>
<ul>
<li>instance=数字/UNLIMITED：设置该daemon能够承受的最大连接数。`  </li>
<li>per_source=数字/UNLIMITED：每个IP的最大连接数。</li>
<li>Cps=数字1 数字2：该daemon在一秒内的连接数超过数字1，则暂时关闭该da* emon数字2的秒数。</li>
<li>log_on_success/failure=PID/HOST/USERID/EXIT/DURATION：当登录成功/* 失败时记录的信息。HOST：连接者的IP、EXIT：离开时间、DURATION：为该用户服务的时间。</li>
<li>redirect=IP：将用户的请求转至指定服务器。</li>
<li>bind=IP：允许用户用哪个IP访问本服务。<br>only_from=[0.0.0.0,192.168.1.0:24]：只允许指定IP的用户访问。0.0.0.0表示允许所有用户，192.168.1.0:24表示只允许192.168.1.1－192.168.1.255之间的用户访问。<br>access_time=00:00-12:00：只允许该时间段内访问。</li>
</ul>
</li>
<li><p>使用xinetd提供的/etc/hosts.allow和/etc/hosts.deny实现防火墙机制</p>
<ul>
<li><p>/etc/hosts.allow ：我们可以在该文件中设置允许访问的IP</p>
</li>
<li><p>/etc/hosts.deny ：我们可以在该文件中设置不允许访问的IP</p>
</li>
</ul>
</li>
</ol>
<h1 id="系统开启的服务"><a href="#系统开启的服务" class="headerlink" title="系统开启的服务"></a>系统开启的服务</h1><h2 id="查看系统启动的服务"><a href="#查看系统启动的服务" class="headerlink" title="查看系统启动的服务"></a>查看系统启动的服务</h2><p>一般情况下，我们会比较关心网络监听的服务，所以都会使用netstat命令(之前也提到过)，这里再次说明几个范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 1. 找出目前系统开启的网络服务</div><div class="line">netstat -tulp</div><div class="line"></div><div class="line">// 2. 找出所有有监听网络的服务</div><div class="line">netstat -lnp</div><div class="line"></div><div class="line">// 3. 查看所有的服务状态</div><div class="line"> service --status-all</div></pre></td></tr></table></figure></p>
<h2 id="设置Daemon开启启动"><a href="#设置Daemon开启启动" class="headerlink" title="设置Daemon开启启动"></a>设置Daemon开启启动</h2><p>在设置Daemon开机启动之前，最好先了解一下Linux主机是怎么开机的？</p>
<ol>
<li>打开计算机电源，开始读取BIOS并进行主机的自我测试</li>
<li>通过BIOS取得第一个可开机设备，读取主要开机区(MBR)取得启动装载程序</li>
<li>通过启动装载程序的设置，取得kernel并加载内存且检测系统硬件</li>
<li>内核主动调用init进程</li>
<li>init进程开始执行系统初始化(/etc/rc.d/rec.sysinit)</li>
<li>依据init的设置进行daemonstart(/etc/rc.d/rc[0-6].d/*)</li>
<li>加载本机设置</li>
</ol>
<p>在启动Linux系统时，可以进入不同的模式，这模式我们称为执行等级(run level)，不同执行等级有不同的功能与服务。图型界面为run level5，纯文本界面为run level3。当我们想要知道哪些服务默认可以启动，这就需要下面的命令来查询:</p>
<ol>
<li><p>chkconfig：管理系统服务<strong>默认开机启动与否</strong>，范例如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 1. 列出目前系统上面所有被chkconfig管理的服务</div><div class="line">chkconfig --list | more // 分为两个块，分别为两种启动方式的daemon</div><div class="line"></div><div class="line">// 2. 显示目前在run level 3 启动的服务</div><div class="line">chkconfig --list | grep &apos;2:on&apos;</div><div class="line"></div><div class="line">// 3. 让atd这个服务在run level 3，4，5时启动</div><div class="line">chkconfig --level 345 atd on</div><div class="line"></div><div class="line">// 4. 查看httpd，再查看默认有无启动，之后以chkconfig设置为默认启动</div><div class="line">/etc/init.d/httpd status // 查看本身</div><div class="line">chkconfig --list httpd // 查看是否默认启动</div><div class="line">chconfig httpd on; //设置为开机启动</div></pre></td></tr></table></figure>
<ol>
<li>chkconfig：设置自己的系统服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig [--add|--del] [服务名称] // 该服务必须在/etc/init.d/内</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h1 id="RHEL7的sytemctl（代替service和chkconfig）"><a href="#RHEL7的sytemctl（代替service和chkconfig）" class="headerlink" title="RHEL7的sytemctl（代替service和chkconfig）"></a>RHEL7的sytemctl（代替service和chkconfig）</h1><p>centos7版本中使用了systemd，systemd同时兼容service,对应的命令就是systemctl 。systemctl是RHEL 7 的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。可以使用它永久性或只在当前会话中启用/禁用服务。</p>
<p>systemd把不同的资源称为Unit<br>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit<br>存放目录：/etc/systemd/system和/usr/lib/systemd/system。</p>
<p>使用范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// 1. 以树形列出正在运行的进程，它可以递归显示控制组内容</div><div class="line">systemd-cgls</div><div class="line"></div><div class="line">// 2. 启动一个服务</div><div class="line">systemctl start firewalld.service</div><div class="line"></div><div class="line">// 3. 关闭一个服务</div><div class="line">systemctl stop firewalld.service</div><div class="line"></div><div class="line">// 4. 重启一个服务</div><div class="line">systemctl restart firewalld.service</div><div class="line"></div><div class="line">// 5. 显示一个服务的状态</div><div class="line">systemctl status firewalld.service</div><div class="line"></div><div class="line">// 6. 在开机时启动一个服务</div><div class="line">systemctl enable firewalld.service</div><div class="line"></div><div class="line">// 7. 在开机时禁用一个服务</div><div class="line">systemctl disable firewalld.service</div><div class="line"></div><div class="line">// 8. 查看服务是否开机启动</div><div class="line">systemctl is-enabled  firewalld.service</div><div class="line"></div><div class="line">// 9. 查看已启动的服务列表</div><div class="line">systemctl list-unit-files | grep enabled</div><div class="line"></div><div class="line">// 10. 查看启动失败的服务列表</div><div class="line">systemctl --failed</div><div class="line"></div><div class="line">PS：</div><div class="line">1. 使用命令 systemctl is-enabled firewalld.service 得到的值可以是enable、disable或static，</div><div class="line">     这里的 static 它是指对应的 Unit 文件中没有定义[Install]区域，因此无法配置为开机启动服务。</div><div class="line">2. 启用服务就是在当前“runlevel”的配置文件目录/etc/systemd/system/multi-user.target.wants/里，建立/usr/lib/systemd/system里面对应服务配置文件的软链接；</div><div class="line">  禁用服务就是删除此软链接，添加服务就是添加软连接。</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
<li><a href="https://blog.csdn.net/catoop/article/details/47318225" target="_blank" rel="external">RHEL7的sytemctl（代替service和chkconfig）</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：我们进程会听到daemon，但是却不知道其义，其实就是一个守护进程，作用是支持其他服务(service)的运行。我们下面可以好好看看linux中的daemon与service！
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_认识你的进程</title>
    <link href="http://bestlixiang.site/2018/04/02/%E8%B5%B0%E8%BF%9BLinux_%E8%AE%A4%E8%AF%86%E4%BD%A0%E7%9A%84%E8%BF%9B%E7%A8%8B/"/>
    <id>http://bestlixiang.site/2018/04/02/走进Linux_认识你的进程/</id>
    <published>2018-04-02T04:58:22.000Z</published>
    <updated>2018-04-09T04:33:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：linux服务器上可以跑很多很多的程序，当然也会遇到很多的问题，所以我们需要学会去管理好它。尤其像ps，top这些命令，你一定会很想去了解它吧！<a id="more"></a></p>
<h1 id="理解进程"><a href="#理解进程" class="headerlink" title="理解进程"></a>理解进程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p><strong>进程：</strong> 一个程序被加载到内存当中运行，那么在内存中的那个数据就被称为进程。</p>
<p>系统也会给予这个进程一个ID，称为<strong>PID</strong>。同时触发这个进程的用户与相关属性关系，给予这个PID一组有效的权限设置。</p>
<h2 id="进程与程序"><a href="#进程与程序" class="headerlink" title="进程与程序"></a>进程与程序</h2><h3 id="程序和进程概念"><a href="#程序和进程概念" class="headerlink" title="程序和进程概念"></a>程序和进程概念</h3><ol>
<li>程序：通常为二进制程序，放置在存储媒介中，以物理文件的形式存在。</li>
<li>进程：程序在触发后，执行者的权限与属性、程序的程序代码与所需数据等都会被加载到内存中，操作系统给予这个内存中的单元一个标识符（PID），可以说，进程就是一个正在运行的程序。</li>
</ol>
<h3 id="子进程与父进程"><a href="#子进程与父进程" class="headerlink" title="子进程与父进程"></a>子进程与父进程</h3><p>举个栗子：当我们登录系统后，会取得一个bash的shell，然后，我们用这个bash提供的接口去执行另一个命令，那些另外执行的命令也会被触发称为PID，那个后来执行命令才产生的PID就是“子进程”，而在我们原本在bash环境下，就称为“父进程”。子进程会具有PPID(父PID)。</p>
<h3 id="fork-and-exec：过程调用的流程"><a href="#fork-and-exec：过程调用的流程" class="headerlink" title="fork and exec：过程调用的流程"></a>fork and exec：过程调用的流程</h3><p>在Linux的过程调用中通常被称为fork and exec的流程，进程都会父进程以复制(fork)的方式产生一个一模一样的子进程（PID不一样），然后被复制出来的子进程再以exec的方式来执行实际要进行的进程，最终称为一个子进程的存在。</p>
<h1 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h1><h2 id="什么是工作管理"><a href="#什么是工作管理" class="headerlink" title="什么是工作管理"></a>什么是工作管理</h2><p><strong>工作管理：</strong> 当我们登录系统取得bash shell之后，在<strong>单一终端机下</strong>同时进行多个工作的行为管理。</p>
<p>下面是前台和后台定义:</p>
<p><strong>前台:</strong> 你可以控制与执行命令的环境</p>
<p><strong>后台：</strong> 可以自行运行的工作，你无法用ctrl + c终止它，但是可以用bg/fg调用该工作的环境</p>
<p>要进行bash的工作管理必须要注意的限制是：</p>
<ul>
<li>这些工作所触发的进程必须要来自你的shell子进程（只管理自己的bash）</li>
<li>后台中“执行”的进程不能等待terminal/shell的输入。</li>
</ul>
<h2 id="job管理"><a href="#job管理" class="headerlink" title="job管理"></a>job管理</h2><p>实际中使用的job控制主要有下面的命令：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 直接将命令丢到后台中“执行”的 &amp;</span></div><div class="line">tar -zpcf /tmp/tec/tar.gz /etc &amp;</div><div class="line"><span class="comment">/*</span></div><div class="line">会出现[1]（工作好） 13456（进程号）</div><div class="line">完成后会输出： [1]   完成                  tar -zpcf /tmp/etc.tar.gz /etc */</div><div class="line"><span class="comment">/*</span></div><div class="line">但是需要注意的是，运行的信息还是会出现在屏幕上，会影响我们正常继续使用，</div><div class="line">所以我们需要利用数据流重定向输入到文件中。*/</div><div class="line"></div><div class="line"><span class="comment">// 2. 将目前的工作丢到后台中“暂停”：ctrl + z</span></div><div class="line">vim ~/.bashrc 按ctrl+z</div><div class="line"><span class="comment">/*</span></div><div class="line">会输出 [2]+  已停止               vim ~/.bashrc */</div><div class="line"></div><div class="line"><span class="comment">// 3. 查看目前的后台工作状态：jobs</span></div><div class="line"></div><div class="line"><span class="comment">// 4. 将后台工作拿到前台来处理：fg</span></div><div class="line">fg %<span class="number">2</span> <span class="comment">//拿出刚刚vim的工作</span></div><div class="line"></div><div class="line"><span class="comment">// 5. 让工作在后台下得状态变成运行中：bg</span></div><div class="line">bg %<span class="number">2</span></div><div class="line"></div><div class="line"><span class="comment">// 6. 管理后台当中的工作：kill</span></div><div class="line">kill -signal %jobnumber/PID/命令</div><div class="line"><span class="comment">/* signal</span></div><div class="line">-1：重新读取一次参数的配置文件</div><div class="line">-2：与ctrl + c一样</div><div class="line">-9：立刻强制删除一个工作，不会删除过程文件</div><div class="line">-15(默认值)：以正常的程序方式终止一项工作，会删除过程文件 */</div></pre></td></tr></table></figure></p>
<h2 id="脱机管理"><a href="#脱机管理" class="headerlink" title="脱机管理"></a>脱机管理</h2><p>如果你是使用&amp;来放置后台工作，当你断开与终端机的连接（脱机），那么后台工作就会被中断掉。如果我们不想这样就可以使用at或者nohup命令，我们主要讲一下nohup的这个命令，这个命令可以让你在脱机或注销系统后，还能够让工作继续进行。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. 在终端机前台中工作</div><div class="line">nohup 命令</div><div class="line"></div><div class="line">// 1. 在终端机后台工作</div><div class="line">nohup 命令 &amp;</div></pre></td></tr></table></figure></p>
<p>当你使用这个命令之后，你会发现会出现一个nohup.out文件，这个文件其实就是将原本前台显示的东西重定向到这个文件中。</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程的查看"><a href="#进程的查看" class="headerlink" title="进程的查看"></a>进程的查看</h2><h3 id="静态的ps"><a href="#静态的ps" class="headerlink" title="静态的ps"></a>静态的ps</h3><p>PS：如果man page不好查阅，最好是直接被几个常用的参数。</p>
<p>这个命令是将某个时间点的进程运行情况选取下来，主要的范例如下：</p>
<ol>
<li><p>仅查看自己的bash的相关进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">ps -l</div><div class="line"></div><div class="line">/* 输出列子如下：</div><div class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</div><div class="line">4 S     0 10573 10567  0  80   0 - 29064 wait   pts/0    00:00:00 bash</div><div class="line"></div><div class="line">含义如下：</div><div class="line">F：程序标识（process flags），说明程序的权限，4代表root，1代表子程序仅能fork不能exec</div><div class="line"></div><div class="line">S：程序状态（state），主要有R(running)、S(sleep)、D(不可唤醒)、T(stop)、Z（僵尸，命令位会跟&lt;defunct&gt;）</div><div class="line"></div><div class="line">UID/PID/PPID  ：PPID指父程序的PID</div><div class="line"></div><div class="line">C：代表CPU使用率，单位为百分比</div><div class="line"></div><div class="line">PRI/NI：此程序被CPU执行优先级，数值越小程序优先级越高</div><div class="line"></div><div class="line">ADDR/SZ/WCHAN：ADDR代表在内存哪个部分，SZ代表用掉多少内存，WCHAN表示程序是否正在运作</div><div class="line"></div><div class="line">TTY：登陆者的终端机位置，远程登录时为 pts/n</div><div class="line"></div><div class="line">TIME：使用掉的CPU时间，程序实际花费CPU运作时间</div><div class="line"></div><div class="line">CMD：触发程序的指令 */</div></pre></td></tr></table></figure>
</li>
<li><p>查看系统所有进程：ps aux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">ps aux</div><div class="line"></div><div class="line">/* 输出列子如下：</div><div class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</div><div class="line">root         1  0.0  0.1  43156  3136 ?        Ss   3月10   1:27 /usr/lib/systemd/systemd --swi</div><div class="line"></div><div class="line">含义如下：</div><div class="line">USER：该进程属于哪个用户账号</div><div class="line"></div><div class="line">PID  ：进程ID</div><div class="line"></div><div class="line">%CPU：该进程使用掉的CPU资源内存百分比</div><div class="line"></div><div class="line">%MEM：该进程所占用的物理内存百分比</div><div class="line"></div><div class="line">VSZ：该进程使用掉的虚拟内存量（KB）</div><div class="line"></div><div class="line">RSS：该进程占用的固定的内存量（KB）</div><div class="line"></div><div class="line">TTY：登陆者的终端机位置，远程登录时为 pts/n</div><div class="line"></div><div class="line">STAT：与ps -l的S表示相同</div><div class="line"></div><div class="line">START：该进程被触发启动的时间</div><div class="line"></div><div class="line">TIME：程序实际花费CPU运作时间</div><div class="line"></div><div class="line">CMD：该进程的实际命令 */</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="动态的top"><a href="#动态的top" class="headerlink" title="动态的top"></a>动态的top</h3><p>这个命令可以持续的检测进程运行的状态，主要范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 1. 每两秒更新一次top，查看整体信息，默认5秒</div><div class="line">top -d 2</div><div class="line"></div><div class="line">/* 输出例子：</div><div class="line">top - 10:54:10 up 22 days, 19:25,  1 user,  load average: 0.13, 0.07, 0.06</div><div class="line">Tasks:  69 total,   2 running,  66 sleeping,   1 stopped,   0 zombie</div><div class="line">%Cpu(s):  0.5 us,  0.0 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</div><div class="line">KiB Mem :  1883844 total,    77012 free,   356884 used,  1449948 buff/cache</div><div class="line">KiB Swap:        0 total,        0 free,        0 used.  1328820 avail Mem</div><div class="line"></div><div class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                     </div><div class="line"> 1861 root      20   0  608356  12236   1788 S  0.5  0.6  60:48.59 barad_agent</div><div class="line"></div><div class="line"> top见界面主要分为两个界面：</div><div class="line"></div><div class="line"> 上面为整个系统的资源使用状态，基本上总共有六行，显示的内容依次是：</div><div class="line"> 1. 目前的时间，开机到目前为止所经过的时间，已经登录系统的的用户数,系统在1，5，15分钟的平均工作负载</div><div class="line"> 2. 目前进程的总量与各个累呗进程的总量，注意zombie僵尸进程的数量</div><div class="line"> 3. CPU的整体负载，注意wa（I/Owait）</div><div class="line"> 4. 物理内存的使用情况</div><div class="line"> 5. 虚拟内存的使用情况，swap的是用来一定要小</div><div class="line"> 6. 这个是当在top进程中输入命令时显示状态的地方，输入r可修改nice值</div><div class="line"></div><div class="line"> 下面为每个进程使用资源情况，各个参数含义可参照ps。</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<h3 id="进程树pstree"><a href="#进程树pstree" class="headerlink" title="进程树pstree"></a>进程树pstree</h3><p>如果想找到进程之间的相关性，这个pstree就能够很好的帮助我们，它会使用线段将相关性进程连接起来，范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 1.列出目前系统上面所有的进程数的相关性</div><div class="line">pstree -A</div><div class="line">输入如下：</div><div class="line">systemd-+-acpid</div><div class="line">        |-2*[agetty]</div><div class="line">        |-atd</div><div class="line">        |-auditd---&#123;auditd&#125;</div><div class="line">        ...</div><div class="line"></div><div class="line">// 2. 在1的基础上，同时显示出PID与users</div><div class="line">pstree -Aup</div></pre></td></tr></table></figure></p>
<h2 id="进程的执行顺序"><a href="#进程的执行顺序" class="headerlink" title="进程的执行顺序"></a>进程的执行顺序</h2><p>CPU优先处理哪个进程，这就需要考虑到程序的优先执行序(priority)与CPU的调度。具体到值来说就是要考虑到PRI和nice值（之前用top和ps显示过）。<strong>PRI值越低代表越优先</strong>，不过这个PRI值是由内核动态调整的，具有无法调整，但是Nice值我们可以改变。下面的PRI值改变的公式：</p>
<pre><code>PRI(new) = PRI(old) + nice
</code></pre><p>下面是关于nice值的使用范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. 在使用命令的时候设置nice值，给nice值为-5去执行vi</div><div class="line">nice -n vi &amp;</div><div class="line"></div><div class="line">// 2. 已存在进程的nice重新分配，将PID为18625的进程nice值调整到10</div><div class="line">renice 10 18625</div></pre></td></tr></table></figure></p>
<h2 id="系统资源的查看"><a href="#系统资源的查看" class="headerlink" title="系统资源的查看"></a>系统资源的查看</h2><ol>
<li><p>查看内存的使用情况，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 查看目前系统的内存容量</div><div class="line">free -m</div></pre></td></tr></table></figure>
</li>
<li><p>查看系统与内核相关信息，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 输出系统的基本信息</div><div class="line">uname -a</div></pre></td></tr></table></figure>
</li>
<li><p>查看系统启动时间与内存负载，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uptime</div></pre></td></tr></table></figure>
</li>
<li><p>跟踪网络(很重要)，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. 列出目前系统以及新建的网络连接与unix socket状态</div><div class="line">netstat</div><div class="line"></div><div class="line">// 2. 找出目前系统上已在监听的网络连接机及其PID(很重要)</div><div class="line">netstat -tlnp</div></pre></td></tr></table></figure>
</li>
<li><p>分析内核产生的信息，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. 输出所有的内核开机时的信息</div><div class="line">dmesg | more</div><div class="line"></div><div class="line">// 2. 查找开机的时候硬盘的相关信息</div><div class="line">dmesg | grep i hd</div></pre></td></tr></table></figure>
</li>
<li><p>检测系统资源变化，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 1. 统计目前主机CPU状态，每秒一次，共计三次</div><div class="line">vmstat 1 3</div><div class="line"></div><div class="line">// 2. 系统上面所有磁盘的读写状态</div><div class="line">vmstat -d</div><div class="line"></div><div class="line">PS：详细的各个字段的含义，大家就自己查询man vmstat好了，习惯就好。</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：linux服务器上可以跑很多很多的程序，当然也会遇到很多的问题，所以我们需要学会去管理好它。尤其像ps，top这些命令，你一定会很想去了解它吧！
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_例行性工作(crontab)</title>
    <link href="http://bestlixiang.site/2018/03/31/%E8%B5%B0%E8%BF%9BLinux_%E4%BE%8B%E8%A1%8C%E6%80%A7%E5%B7%A5%E4%BD%9C(crontab)/"/>
    <id>http://bestlixiang.site/2018/03/31/走进Linux_例行性工作(crontab)/</id>
    <published>2018-03-31T12:35:07.000Z</published>
    <updated>2018-04-09T04:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：系统常常会主动进行一些任务，这依靠的就是设置了例行性工作。<a id="more"></a></p>
<h1 id="什么是例行性工作（定时任务crontab）"><a href="#什么是例行性工作（定时任务crontab）" class="headerlink" title="什么是例行性工作（定时任务crontab）"></a>什么是例行性工作（定时任务crontab）</h1><p>根据单词crontab（定时任务）就可以知道 <strong>例行性工作</strong> 其实就是每天都会干的事。</p>
<h2 id="Linux工作调度的种类"><a href="#Linux工作调度的种类" class="headerlink" title="Linux工作调度的种类"></a>Linux工作调度的种类</h2><ol>
<li>例行性的，就是每隔一定的周期要来办的事，利用crontab实现，这个命令所设置的工作将会循环一直进行下去，可循环的时间为分钟，小时，每周，每月或每年等，crontab除了可以使用命令执行外，也可编辑/etc/crontab来支持。至于让crontab可以生效的后台服务是crond这个服务。</li>
<li>突发性的，就是这次做完以后就没有的事，利用at实现，但是这个必须要有atd后台服务支持才行。</li>
</ol>
<h2 id="Linux上常见的例行性工作"><a href="#Linux上常见的例行性工作" class="headerlink" title="Linux上常见的例行性工作"></a>Linux上常见的例行性工作</h2><ol>
<li>进行日志文件的轮替，让旧的数据和新的数据分开存放</li>
<li>日志文件分析logwatch的任务</li>
<li>新建locate的数据库，系统会主动进行updatedb</li>
<li>whatis数据库的建立</li>
<li>删除临时文件</li>
</ol>
<h1 id="仅执行一次的工作调度：at"><a href="#仅执行一次的工作调度：at" class="headerlink" title="仅执行一次的工作调度：at"></a>仅执行一次的工作调度：at</h1><h2 id="at的运行方式"><a href="#at的运行方式" class="headerlink" title="at的运行方式"></a>at的运行方式</h2><p>我们使用at这个命令来生成所要进行的工作，并将这个工作以文本文件的方式写入/var/spool/at目录中，该工作便能等待atd这个服务的取用与执行了。但是并不是所有的人都可以进行at工作调度工作的，因为安全。我们可以利用/etc/at.allow与/etc/at.deny这两个文件进行at的使用限制，加上这两个文件后，at的工作情况其实是这样的：</p>
<ol>
<li>先寻找/etc/at.allow这个文件，写在这个文件中的用户才能使用at，没有在这个文件中的用户则不能使用at(即时没有写在at.deny当中)</li>
<li>如果/etc/at.allow不存在，就寻找/etc/at.deny这个文件，若卸载这个at.deny的用户则不能使用at，而没有在这个文件中的用户就可以使用at了</li>
<li>如果这两个文件都不存在，那么就只有root可以使用at这个命令</li>
</ol>
<h2 id="实际运行单一工作调度"><a href="#实际运行单一工作调度" class="headerlink" title="实际运行单一工作调度"></a>实际运行单一工作调度</h2><p>单一工作调度的进行就使用at这个命令，这个命令的运行十分简单！将at加上一个时间即可！范例入下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. at [-mldv] TIME</div><div class="line">at noe + 5 minutes // 再过五分钟执行，接下来输入执行的命令，使用ctrl  + d 结束。</div><div class="line"></div><div class="line">// 2. at -c 工作号码 // 将第几号工作调出来查看</div><div class="line">at -c 1 // 将第一号工作调出来</div></pre></td></tr></table></figure></p>
<p>事实上，当我们使用at时会进入一个at shell的环境来让用户执行工作命令，此时，建议你最好使用绝对路径来执行你的命令，比较不会有问题。</p>
<p>at还有一个很棒的优点就是<strong>后台执行的功能</strong>，和nohup类似。</p>
<p><strong>at的工作管理</strong> 主要是利用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 查询目前主机上面有多少的at工作调度</div><div class="line">atq</div><div class="line"></div><div class="line"># 将第3个工作删除</div><div class="line">atrm 3</div></pre></td></tr></table></figure></p>
<h1 id="循环执行的例行性工作调度"><a href="#循环执行的例行性工作调度" class="headerlink" title="循环执行的例行性工作调度"></a>循环执行的例行性工作调度</h1><p>相对于at是仅执行一次的工作，循环执行的例行性工作调度室友crond这个系统服务来控制的，由于Linux系统上原本就有很多的例行性工作，所以这个系统服务是默认开启的。另外，由于用户自己也可以进行例行性工作调度，所以，Linux可提供用户控制例行性工作调度的命令（crontab）。</p>
<h2 id="用户的设置与使用"><a href="#用户的设置与使用" class="headerlink" title="用户的设置与使用"></a>用户的设置与使用</h2><p>为了安全性的问题，与at类似，我们可以限制使用crontab的用户账号。使用的限制数据有：</p>
<ul>
<li>/etc/cron.allow：将可以使用crontab的账号写入其中，若不在这个文件内的用户则不可使用crontab。</li>
<li>/etc/cron.deny：将不可以使用crontab的账号写入其中，若为记录到这个文件中的用户，就可以使用crontab。</li>
</ul>
<p>以优先级来说，/etc/cron.allow比/etc/cron.deny要优先，而判断上面，两个文件只选择一个来限制而已，因此，建议你只要保留一个即可。</p>
<p>当用户使用crontab这个命令来新建工作调度之后，该项工作就会被记录/var/spool/cron/里面，而且是以账号来区分的。另外，cron执行的每一项工作都会被记录到/var/log/cron这个日志文件中，所以，如果你的Linux不知道是否被植入密码，也可以查询一下这个日志文件。</p>
<p>下面是它的使用范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 1. 用root的身份在每天的12:00和14:00查看主文件夹目录ß</div><div class="line"># 编辑crontab的工作内容</div><div class="line">crontab -e</div><div class="line"># 进入vi界面，每项工作都是一行</div><div class="line">0 12,14 * * * ls /  // 解释各列含义：</div><div class="line">// 1. 分；2. 小时；3. 日期；4. 月份; 5. 周； 6. 命令</div><div class="line">// 其中“,”表示分割时段，“-”表示一段时间范围，/n 表示每隔n单位间隔</div><div class="line"></div><div class="line">// 2. 查询crontab任务</div><div class="line">crontab -l</div><div class="line"></div><div class="line">// 3. 若要删除一项工作，必须要用crontab -e去编辑，如果想要删除全部工作，如下：</div><div class="line">crontab -r</div></pre></td></tr></table></figure></p>
<h2 id="系统的配置文件：-etc-crontab"><a href="#系统的配置文件：-etc-crontab" class="headerlink" title="系统的配置文件：/etc/crontab"></a>系统的配置文件：/etc/crontab</h2><p>crontab -e是针对用户的例行性工作来设计的，如果我们要修改系统的例行性任务，就需要编辑/etc/crontab了。</p>
<p>基本上，cron这个服务的最低检测限制是“分钟”，所以cron会每分钟去读取一次/etc/crontab与/var/spool/cron里面的数据内容。</p>
<h1 id="可唤醒停机期间的工作任务"><a href="#可唤醒停机期间的工作任务" class="headerlink" title="可唤醒停机期间的工作任务"></a>可唤醒停机期间的工作任务</h1><p>如果例行性工作是在凌晨4点运行的，但是刚好关机了， 你7点开机了，你总不能不管它吧，这就需要用到anacron。</p>
<h2 id="什么是anacron"><a href="#什么是anacron" class="headerlink" title="什么是anacron"></a>什么是anacron</h2><p><strong>anacron存在的目的</strong> 是处理非24小时一直启动的linux系统的crontab的执行。</p>
<p>anacron也是通过crontab来运行的，因此anacron的运行的时间通常有两个，一是系统开机期间运行，一个是写入crontab的调度中。</p>
<h2 id="anacron使用"><a href="#anacron使用" class="headerlink" title="anacron使用"></a>anacron使用</h2><p>anacron的语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">anacron [-sfn] [job]</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：系统常常会主动进行一些任务，这依靠的就是设置了例行性工作。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_账号管理</title>
    <link href="http://bestlixiang.site/2018/03/31/%E8%B5%B0%E8%BF%9BLinux_%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/"/>
    <id>http://bestlixiang.site/2018/03/31/走进Linux_账号管理/</id>
    <published>2018-03-31T05:15:52.000Z</published>
    <updated>2018-04-09T04:34:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：管理员的工作中，相对重要的一环就是“账号管理”。因为整个系统都是你在管理，并且所有的一般用户的账号申请必须要通过你的协助才行。所以我们必须要知道如果管理好一个服务器主机的账号！<a id="more"></a></p>
<h1 id="账号与用户组"><a href="#账号与用户组" class="headerlink" title="账号与用户组"></a>账号与用户组</h1><p>在管理Linux账号时，我们必须要先了解一下Linux到底是如何辨别每一个用户的。</p>
<h2 id="用户表示符：UID与GID"><a href="#用户表示符：UID与GID" class="headerlink" title="用户表示符：UID与GID"></a>用户表示符：UID与GID</h2><p>虽然我们登录Linux主机的时候，输入的是我们的账号，但是其实Linux主机并不会直接认识你的账号，它仅认识ID，而你的ID域账号的对应关系就在/etc/passwd当中。</p>
<p>每一个文件都具有<strong>所有者与所属用户组</strong>的属性，所以每个登录的用户至少会取得两个ID，一个是用户ID(UID)，一个是用户组ID(GID)。</p>
<h2 id="用户账号"><a href="#用户账号" class="headerlink" title="用户账号"></a>用户账号</h2><p>Linyx系统上面的用户如果需要登录主机以取得shell的工作环境，它必须要在计算机前面利用tty1~tty7的终端机提供的login接口，并输入账号与密码后才能登录。当我们输入账号密码后，系统主要做了如下工作：</p>
<ol>
<li>先寻找/etc/passwd里面是否有你输入的帐号？如果没有则跳出，如果有的话则将该帐号对应的UID与GID（在/etc/group中）读出来，另外，该帐号的主文件夹与shell设定也一并读出。</li>
<li>再来则是核对密码表啦！这是Linux会进入/etc/shadow里面找出对应的帐号与UID，然后核对一下你刚刚输入的密码与里面的密码是否相符。</li>
<li>如果一切都OK的话，就进入Shell控管的阶段咯！</li>
</ol>
<ul>
<li><p>/etc/passwd文件结构如下：</p>
<p>  这个文件的构造是这样的：每一行代表一个帐号，有几行就代表有几个帐号在你的系统中！不过需要特别留意的是，里头很多帐号本身就是系统正常运作所必须要的，我们可以简称为<strong>系统帐号</strong>，如bin，daemon，adm，nobody等。</p>
<p>  我们先来看一下每个Linux系统都会有的第一行，就是root这个系统管理员那一行好了，你可以明显的看出来，每一行使用：分隔，共有七个字段，分别是</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>字段号</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>    1</td>
<td>账号名称</td>
</tr>
<tr>
<td>    2</td>
<td>密码，被该放到/etc/shadow文件中，以x代替</td>
</tr>
<tr>
<td>    3</td>
<td>UID，0为系统管理员，可以多个账号的UID为0，但不建议。1~99为发现版自建系统账号，100~499为用户使用的系统账号，500~*为一般用户可登录账号</td>
</tr>
<tr>
<td>    4</td>
<td>密码，GID，与/etc/group有关</td>
</tr>
<tr>
<td>    5</td>
<td>用户信息说明</td>
</tr>
<tr>
<td>    6</td>
<td>主文件夹</td>
</tr>
<tr>
<td>    7</td>
<td>shell</td>
</tr>
</tbody>
</table>
<ul>
<li><p>/etc/shadow文件结构如下：</p>
<p>  文件构造基本与/etc/passwd一样，但是它有9个字段，分别是：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>字段号</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>    1</td>
<td>账号名称，需要与/etc/passwd对应</td>
</tr>
<tr>
<td>    2</td>
<td>密码，但是被加密过的</td>
</tr>
<tr>
<td>    3</td>
<td>最近更改密码的日期，以1970年1月1号作为1而累加的日期</td>
</tr>
<tr>
<td>    4</td>
<td>密码不可被更动的日期</td>
</tr>
<tr>
<td>    5</td>
<td>密码需要重新更改的天数</td>
</tr>
<tr>
<td>    6</td>
<td>密码需要更改期限前的警告天数</td>
</tr>
<tr>
<td>    7</td>
<td>密码过期后的账号宽限时间（密码失效日）</td>
</tr>
<tr>
<td>    8</td>
<td>账号失效日期</td>
</tr>
<tr>
<td>    9</td>
<td>保留，用于以后扩展</td>
</tr>
</tbody>
</table>
<h2 id="有效与初始用户组：groups，newgrp"><a href="#有效与初始用户组：groups，newgrp" class="headerlink" title="有效与初始用户组：groups，newgrp"></a>有效与初始用户组：groups，newgrp</h2><ul>
<li><p>/etc/group文件结构如下：</p>
<p>  文件构造基本与/etc/passwd一样，但是它有4个字段，分别是：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>字段号</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>    1</td>
<td>用户组名称</td>
</tr>
<tr>
<td>    2</td>
<td>用户组密码，以x代替</td>
</tr>
<tr>
<td>    3</td>
<td>GID，/etc/passwd第四个字段使用的GID对应的用户组名就是由这里来的</td>
</tr>
<tr>
<td>    4</td>
<td>用户组支持的账号名称，多用户以”,”分割</td>
</tr>
</tbody>
</table>
<pre><code>我们知道用户可以同时加入多个用户组，那么我们在执行工作时，到底是以哪个用户组为准呢？，这就需要引入有效用户组的概念。    
</code></pre><ul>
<li><p>/etc/gshadow文件结构如下：</p>
<p>  文件构造基本与/etc/group一样，它有4个字段，分别是：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>字段号</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>    1</td>
<td>用户组名称</td>
</tr>
<tr>
<td>    2</td>
<td>用户组密码,开头为!表示无合法密码，所以无用户组管理员</td>
</tr>
<tr>
<td>    3</td>
<td>用户组管理员的账号，用户组管理员能够将账号添加到自己管理的用户组中</td>
</tr>
<tr>
<td>    4</td>
<td>该用户组的所属账号（与/etc/group内容相同）</td>
</tr>
</tbody>
</table>
<ul>
<li>有效用户组与初始用户组<ul>
<li>初始用户组：就是/etc/passwd里面的第四列的GID，当用户登录系统，立刻就拥有这个用户组的相关权限。</li>
<li>有效用户组：就是利用groups命令看到的第一个用户组，可以利用newgrp命令更改有效用户组，newgrp命令更改目前用户的有效用户组是以另一个shell来提供这个功能的，如果要回到原来的用户组只要输入exit即可。</li>
</ul>
</li>
</ul>
<h1 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h1><p>管理账号主要是新增、删除与更改用户的相关信息。</p>
<h2 id="新增与删除用户"><a href="#新增与删除用户" class="headerlink" title="新增与删除用户"></a>新增与删除用户</h2><p>账号可以使用useradd命令来新建用户，密码的给予则是使用passwd命令。下面是范例：（里面有很多参数，自己可以去了解）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 新增</div><div class="line">useradd leonard</div><div class="line">ll -d /home/leonard/</div><div class="line"><span class="meta">#</span> 默认会创建用户主文件夹，且权限为700，这是重点</div><div class="line"><span class="meta">#</span> drwx------ 2 leonard leonard 4096 3月  31 09:36 /home/leonard/</div><div class="line"></div><div class="line">grep leonard /etc/passwd /etc/shadow /etc/group</div><div class="line"><span class="meta">#</span> /etc/passwd:leonard:x:1001:1001::/home/leonard:/bin/bash</div><div class="line"><span class="meta">#</span> /etc/shadow:leonard:!!:17621:0:99999:7:::</div><div class="line"><span class="meta">#</span> /etc/group:leonard:x:1001:</div><div class="line"><span class="meta"></span></div><div class="line"># 不加账号，默认修改自己的密码</div><div class="line">passwd leonard</div><div class="line"><span class="meta"></span></div><div class="line"># 显示账号的相关信息</div><div class="line">chage leonard</div><div class="line"><span class="meta"></span></div><div class="line"># 修改账号的相关信息</div><div class="line">usermod leonard</div><div class="line"><span class="meta"></span></div><div class="line"># 删除账号，-r：连主文件夹一起删除</div><div class="line">userdel leonard</div></pre></td></tr></table></figure></p>
<p>其实系统已经帮我们设置好了非常多的默认值，所以我们可以简单的使用“useradd 账号”来创建用户，Centos这些默认值主要会帮我们处理下面几个项目：</p>
<ul>
<li>在/etc/passwd 里面创建一行与账号相关的数据，包括创建UID/GID/主文件夹等；</li>
<li>在/etc/shadow里面将此账号的密码相关参数填入，但是尚未有密码；</li>
<li>在/etc/group里面加入一个与账号名称一模一样的组名；</li>
<li>在/home下面创建一个与账号同名的目录作为用户的主文件夹，且权限为700</li>
</ul>
<h2 id="用户功能"><a href="#用户功能" class="headerlink" title="用户功能"></a>用户功能</h2><p>不论是useradd、usermod还是userdel，那都是系统管理员能够使用的命令，下面我们就介绍一些一般身份用户常用的账号数据更改与查询命令</p>
<ul>
<li><p>finger，可以查阅很多用户相关的信息，大部分都是/etc/passwd这个文件的信息。范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 我的linux默认没有装finger，可以利用下面的命令安装</div><div class="line">yum install finger</div><div class="line"></div><div class="line">// 查阅用户信息，若不跟没有用户，则查询当前用户</div><div class="line">finger rex</div></pre></td></tr></table></figure>
</li>
<li><p>chfn(change finger)，用于修改一些相关信息,范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">chfn rex</div><div class="line">Changing finger information for rex.</div><div class="line">名称 []: rex</div><div class="line">办公 []: 123456</div><div class="line">办公电话 []: 123456</div><div class="line">住宅电话 []: 123456</div></pre></td></tr></table></figure>
</li>
<li><p>chsh(change shell)，用于修改shell。</p>
</li>
<li>id，用于查询自己或某人的相关UID/GID等信息。</li>
</ul>
<h2 id="新增与删除用户组"><a href="#新增与删除用户组" class="headerlink" title="新增与删除用户组"></a>新增与删除用户组</h2><p>基本上，用户组的内容都与这两个文件有关：/etc/group,/etc/gshadow。下面是一些相关命令使用的范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># 新建一个用户组，名称为hd</div><div class="line">groupadd hd</div><div class="line"></div><div class="line"># 修改用户组的相关参数 -g：修改既有GID，-n：修改既有组名</div><div class="line">groupmod -g 201 -n myhd hd</div><div class="line"></div><div class="line"># 删除用户组名</div><div class="line">groupdel myhd</div><div class="line"></div><div class="line"># 用户组管理员相关命令</div><div class="line"># 给用户组设置一个密码</div><div class="line">gpasswd hd</div><div class="line"># 加入用户组管理员为rex</div><div class="line">gpasswd -A rex hd</div><div class="line"># 让rex登录系统，增加leonard为hd成员</div><div class="line">gpasswd -a leonard hd</div></pre></td></tr></table></figure></p>
<h1 id="主机的具体权限规划：ACL的使用"><a href="#主机的具体权限规划：ACL的使用" class="headerlink" title="主机的具体权限规划：ACL的使用"></a>主机的具体权限规划：ACL的使用</h1><h2 id="什么是ACL"><a href="#什么是ACL" class="headerlink" title="什么是ACL"></a>什么是ACL</h2><p>ACL是Access Control List的缩写，主要的目的是提供传统的owner、group、others的read、write、execute权限之外的具体权限设置。ACL可以针对单一用户、单一文件或目录进行r、w、x的权限设置，对于需要特殊权限的使用状况非常有帮助。</p>
<p>ACL主要可以针对下面几方面来设置控制权限：</p>
<ul>
<li>用户：可以针对用户来设置权限</li>
<li>用户组：可以针对用户组来设置权限</li>
<li>默认属性（mask）：还可以在该目录下新建文件目录设置新数据的权限、</li>
</ul>
<h2 id="ACL的设置技巧"><a href="#ACL的设置技巧" class="headerlink" title="ACL的设置技巧"></a>ACL的设置技巧</h2><ol>
<li>getfacl：取得某个文件/目录的ACL设置项目</li>
<li>setfacl：设置某个文件/目录的ACL规定</li>
</ol>
<p>下面是范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 取得某个文件/目录的ACL设置项目</div><div class="line">getfacl rootfile</div><div class="line"></div><div class="line">// 输出</div><div class="line"># file: rootfile</div><div class="line"># owner: root</div><div class="line"># group: root</div><div class="line">user::rw-</div><div class="line">group::r--</div><div class="line">other::r--</div><div class="line"></div><div class="line">// 设置某个文件/目录的ACL规定</div><div class="line">setfacl -m u:rex:rwx rootfile</div></pre></td></tr></table></figure></p>
<h1 id="用户身份切换"><a href="#用户身份切换" class="headerlink" title="用户身份切换"></a>用户身份切换</h1><p>在Linux系统中是需要做身份的变换的，主要有以下几个原因：</p>
<ul>
<li>使用一般账号：系统平日操作的好习惯（不然你就有机会从删库到跑路了）</li>
<li>用较低的权限启动系统服务</li>
<li>软件本身的限制</li>
</ul>
<p>根据上面的考虑，我们都是使用一般账号登录系统的，等有需要进行系统维护或软件更新时才转为root身份来操作。从一般用户转变为root主要有下面两种方式：</p>
<ul>
<li>“su -”：需要root用户密码</li>
<li>“sudo命令”：sudo需要输入用户自己的密码</li>
</ul>
<h2 id="su"><a href="#su" class="headerlink" title="su"></a>su</h2><p>su是最简单的身份切换命令了，它可以进行任何身份的切换。但是下面有几点比较重要：</p>
<ol>
<li>若要完整切换到新用户的环境，必须要使用“su -username” 或 “su -|username”，才会连同PATH/USER/MAIL等变量都转成新用户的环境。如果只是使用“su”切换到root用户，PATH/USER/MAIL等变量都没有变，会导致很多命令执行不了。</li>
<li>如果仅想执行一次root命令，可以利用“su - -c “命令串””d的方式来处理。</li>
<li>使用root切换成为任何用户时，并不需要输入新用户的密码。</li>
</ol>
<p>虽然使用su很方便，但是会导致root密码外流。所以很多情况下我们通过sudo来处理。</p>
<h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h2><p>sudo的执行仅需要自己的密码即可！甚至可以设置不需要密码即可执行sudo，由于sudo可以让你以其他用户身份执行命令（通常是使用root的身份来执行命令），因此不是所有人都能够执行sudo，而是仅有/etc/sudoers内的用户才能够执行sudo这个命令。</p>
<ol>
<li><p>sudo的命令用法</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo [-u 新用户账号]</div><div class="line"></div><div class="line">// 范例，以sshd的身份在/tmp下面新建一个名为mysshd的文件</div><div class="line">sudo -u sshd touch /tmp/mysshd</div></pre></td></tr></table></figure>
</li>
<li><p>sudo的执行流程</p>
<ul>
<li>当用户执行sudo时，系统在/etc/sudoers文件中查找该用户是否有执行sudo的权限；</li>
<li>若用户具有可执行sudo的权限后，便让用户输入用户自己的密码来确认；</li>
<li>若密码输入成功，便开始进行sudo后面接的命令（root执行sudo不需要输入密码）</li>
<li>若欲切换的身份与执行者的身份相同，也不需要输入密码</li>
</ul>
</li>
<li><p>visudo与/etc/sudoers</p>
<p> 我们一般不直接去修改/etc/sudoers文件，而是利用visudo命令去修改，因为这个命令会在结束离开的时候去检验/etc/sudoers的语法，下面是他的用法案例：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 1. 单一用户可以执行root的所有命令与sudoers文件语法</div><div class="line">// 四个参数含义为(1).用户账号，(2).登陆者的来源主机，(3).(可切换的身份)，(4).可执行的命令</div><div class="line">root    ALL=(ALL)       ALL //文件中原有</div><div class="line">rex     ALL=(ALL)       ALL //新增</div><div class="line"></div><div class="line">// 2. 利用用户组以及免密码的功能处理visudo</div><div class="line"># %wheel        ALL=(ALL)       NOPASSWD: ALL //文件中原有，需要将#去掉，文件中的%表示后面接一个用户组</div><div class="line">usermod -a -G wheel rex //将rex加入wheel组中</div><div class="line"></div><div class="line">// 3. 有限制的命令操作，通过更改可执行的命令一栏的数据，就可以控制具体操作的安全性</div><div class="line">rex ALL=(ALL) !/usr/bin/passed //不让rex可以修改密码</div><div class="line"></div><div class="line">// 4. 通过别名设置visudo</div><div class="line">User_Alias ADMPW(大写) = rex1,rex2</div><div class="line">Cmnd_Alias ADMPWCOM(大写) = !/usr/bin/passwd, /usr/bin/passed [A-Za-z]</div><div class="line">ADMPW     ALL=(root)       ADMPWCOM</div><div class="line"></div><div class="line">// 5. sudo搭配su的使用方式,让用户用自己的密码变成root</div><div class="line">User_Alias ADMPW(大写) = rex1,rex2</div><div class="line">ADMPW     ALL=(root)       /bin/su -</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：管理员的工作中，相对重要的一环就是“账号管理”。因为整个系统都是你在管理，并且所有的一般用户的账号申请必须要通过你的协助才行。所以我们必须要知道如果管理好一个服务器主机的账号！
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_shell script 入门</title>
    <link href="http://bestlixiang.site/2018/03/30/%E8%B5%B0%E8%BF%9BLinux_shell%20script%20%E5%85%A5%E9%97%A8/"/>
    <id>http://bestlixiang.site/2018/03/30/走进Linux_shell script 入门/</id>
    <published>2018-03-30T10:01:49.000Z</published>
    <updated>2018-04-09T04:32:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：要想管理好自己的主机，自动化管理系统的好工具——shell script，这个家伙是真的需要好好学习学习的！<a id="more"></a></p>
<h1 id="什么是shell-script"><a href="#什么是shell-script" class="headerlink" title="什么是shell script"></a>什么是shell script</h1><p><strong>shell script</strong> 是利用shell的功能所写的一个“程序”，这个程序是使用纯文本文件，将一些shell的语法与命令（含外部命令）写在里面，搭配正则表达式，管道命令与数据重定向等功能，以达到我们所想要的处理目的。</p>
<h2 id="为什么要学习shell-script"><a href="#为什么要学习shell-script" class="headerlink" title="为什么要学习shell script"></a>为什么要学习shell script</h2><ol>
<li>自动化管理的重要依据</li>
<li>追踪与管理系统的重要工作</li>
<li>简单入侵检测功能</li>
<li>连续命令单一化</li>
<li>简易的数据处理</li>
<li>跨平台与学习历程较短</li>
</ol>
<h2 id="shell-script编写的注意事项"><a href="#shell-script编写的注意事项" class="headerlink" title="shell script编写的注意事项"></a>shell script编写的注意事项</h2><ol>
<li>命令的执行是从上而下，从左往右地分析与执行；</li>
<li>命令、参数间的多个空白都会被忽视掉；</li>
<li>空白行也将被忽略掉，并且tab按键所得的空白同样视为空格键；</li>
<li>如果读到一个enter符号（CR），就尝试开始结束该行（或该串）命令</li>
<li>至于如果一行的内容太多，则可以使用“\enter”来扩展至下一行；</li>
<li>“#”可作为批注，任何加在#后面的数据将全部被视为批注文件而被忽略。</li>
</ol>
<h2 id="shell-script的执行"><a href="#shell-script的执行" class="headerlink" title="shell script的执行"></a>shell script的执行</h2><p>假设你的程序文件名是/home/rex/shell.sh</p>
<ol>
<li>直接执行命令：shell.sh文件必须具备可读可执行(rx)的权限，然后：<ul>
<li>绝对路径：使用/home/rex/shell.sh</li>
<li>相对路径：假设工作目录在/home/rex/,则使用./shell.sh来执行</li>
<li>变量“PATH”功能：将shell.sh放在PATH指定的目录内，例如：~/bin/。</li>
</ul>
</li>
<li>以bash进程来执行：通过“bash shell.sh”或“sh shell.sh”来执行</li>
<li>利用source来执行：这样这个脚本将在父进程中执行，各项操作都会在原本的bash内生效。如果直接执行，script是在子进程中的bash内执行的，当子进程完成后，子进程的各项变量或操作将会结束而不会传回到父进程中。</li>
</ol>
<h2 id="良好的-script-撰写习惯"><a href="#良好的-script-撰写习惯" class="headerlink" title="良好的 script 撰写习惯"></a>良好的 script 撰写习惯</h2><p>在每个 script 的档头处记录好：</p>
<ol>
<li>script 的功能；</li>
<li>script 的版本资讯；</li>
<li>script 的作者与联络方式；</li>
<li>script 的版权宣告方式；</li>
<li>script 的 History (历史纪录)；<br>6。script 内较特殊的命令，使用绝对路径的方式来下达；</li>
<li>script 运行时需要的环境变量预先宣告与配置。</li>
</ol>
<h2 id="Hello-Word程序"><a href="#Hello-Word程序" class="headerlink" title="Hello Word程序"></a>Hello Word程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash // 声明这个script使用的shell名称</div><div class="line"># Program:</div><div class="line">#       This program shows &quot;Hello World!&quot; in your screen.</div><div class="line"># History:</div><div class="line"># 2015/11/03    Jiange First release</div><div class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</div><div class="line">export PATH</div><div class="line">echo -e &quot;Hello World! \a \n&quot;</div><div class="line">exit 0</div></pre></td></tr></table></figure>
<h1 id="善用判断式"><a href="#善用判断式" class="headerlink" title="善用判断式"></a>善用判断式</h1><h2 id="利用test命令的测试功能"><a href="#利用test命令的测试功能" class="headerlink" title="利用test命令的测试功能"></a>利用test命令的测试功能</h2><p>如下面的例子，用于检测文件夹是否存在：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test -e /dmtsai &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</div></pre></td></tr></table></figure></p>
<h2 id="利用判断符号"><a href="#利用判断符号" class="headerlink" title="利用判断符号[]"></a>利用判断符号[]</h2><p>如果我想要知道 $HOME 这个变量是否为空的，可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ -z &quot;$HOME&quot; ] ; echo $?</div></pre></td></tr></table></figure></p>
<p>对于判断符号我们一定要注意：</p>
<ol>
<li>在中括号 [] 内的每个组件都需要有空白键来分隔；</li>
<li>在中括号内的变量，最好都以双引号括号起来；</li>
<li>在中括号内的常数，最好都以单或双引号括号起来。</li>
</ol>
<h2 id="shell-script-的默认变量-0-1…"><a href="#shell-script-的默认变量-0-1…" class="headerlink" title="shell script 的默认变量($0, $1…)"></a>shell script 的默认变量($0, $1…)</h2><p>运行的脚本档名为 $0 变量，第一个接的参数就是 $1，依次类推。其他特殊变量：</p>
<ol>
<li>$# ：代表后接的参数个数；</li>
<li>$@ ：代表”$1” “$2” “$3” “$4” …之意，每个变量是独立的(用双引号括起来)；</li>
<li>$* ：代表『”$1c$2c$3c$4…” ，其中 c 为分隔字节，默认为空白键。</li>
</ol>
<h1 id="条件判断式"><a href="#条件判断式" class="headerlink" title="条件判断式"></a>条件判断式</h1><h2 id="利用-if-…-then"><a href="#利用-if-…-then" class="headerlink" title="利用 if …. then"></a>利用 if …. then</h2><p>如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if [ &quot;$1&quot; == &quot;hello&quot; ]; then</div><div class="line">    echo &quot;Hello, how are you ?&quot;</div><div class="line">elif [ &quot;$1&quot; == &quot;&quot; ]; then</div><div class="line">    echo &quot;You MUST input parameters, ex&gt; &#123;$0 someword&#125;&quot;</div><div class="line">else</div><div class="line">    echo &quot;The only parameter is &apos;hello&apos;, ex&gt; &#123;$0 hello&#125;&quot;</div><div class="line">fi</div></pre></td></tr></table></figure></p>
<h2 id="利用-case-…-esac-判断"><a href="#利用-case-…-esac-判断" class="headerlink" title="利用 case ….. esac 判断"></a>利用 case ….. esac 判断</h2><p>如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">case $1 in                             </div><div class="line">&quot;one&quot;)</div><div class="line">    echo &quot;Your choice is ONE&quot;</div><div class="line">    ;;</div><div class="line">&quot;two&quot;)</div><div class="line">    echo &quot;Your choice is TWO&quot;</div><div class="line">    ;;</div><div class="line">&quot;three&quot;)</div><div class="line">    echo &quot;Your choice is THREE&quot;</div><div class="line">    ;;</div><div class="line">*)</div><div class="line">    echo &quot;Usage $0 &#123;one|two|three&#125;&quot;</div><div class="line">    ;;</div><div class="line">esac</div></pre></td></tr></table></figure></p>
<h2 id="利用-function-功能"><a href="#利用-function-功能" class="headerlink" title="利用 function 功能"></a>利用 function 功能</h2><p>如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function printit()&#123;</div><div class="line">    echo &quot;Your choice is $1&quot;   # 这个 $1 必须要参考底下命令的下达</div><div class="line">&#125;</div><div class="line"></div><div class="line">echo &quot;This program will print your selection !&quot;</div><div class="line">case $1 in</div><div class="line"> &quot;one&quot;)</div><div class="line">    printit 1  # 请注意， printit 命令后面还有接参数！</div><div class="line">    ;;</div><div class="line">&quot;two&quot;)</div><div class="line">    printit 2</div><div class="line">    ;;</div><div class="line">&quot;three&quot;)</div><div class="line">    printit 3</div><div class="line">    ;;</div><div class="line"> *)</div><div class="line">    echo &quot;Usage $0 &#123;one|two|three&#125;&quot;</div><div class="line">    ;;</div><div class="line">esac</div></pre></td></tr></table></figure></p>
<h1 id="循环（loop）"><a href="#循环（loop）" class="headerlink" title="循环（loop）"></a>循环（loop）</h1><h2 id="while-do-done-until-do-done-不定次数循环"><a href="#while-do-done-until-do-done-不定次数循环" class="headerlink" title="while do done, until do done (不定次数循环)"></a>while do done, until do done (不定次数循环)</h2><p>如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">while [ condition ]  &lt;==中括号内的状态就是判断式</div><div class="line">do            &lt;==do 是循环的开始！</div><div class="line">    程序段落</div><div class="line">done          &lt;==done 是循环的结束</div><div class="line"></div><div class="line">until [ condition ]</div><div class="line">do     </div><div class="line">    程序段落</div><div class="line">done</div></pre></td></tr></table></figure></p>
<h2 id="for…do…done-固定次数循环"><a href="#for…do…done-固定次数循环" class="headerlink" title="for…do…done (固定次数循环)"></a>for…do…done (固定次数循环)</h2><p>如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for var in con1 con2 con3 ...</div><div class="line">do</div><div class="line">    程序段</div><div class="line">done</div></pre></td></tr></table></figure></p>
<h2 id="for…do…done-的数值处理"><a href="#for…do…done-的数值处理" class="headerlink" title="for…do…done 的数值处理"></a>for…do…done 的数值处理</h2><p>如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">read -p &quot;Please input a number, I will count for 1+2+...+your_input: &quot; nu</div><div class="line"></div><div class="line">s=0</div><div class="line">for (( i=1; i&lt;=$nu; i=i+1 ))</div><div class="line">do</div><div class="line">    s=$(($s+$i))</div><div class="line">done</div><div class="line">echo &quot;The result of &apos;1+2+3+...+$nu&apos; is ==&gt; $s&quot;</div></pre></td></tr></table></figure></p>
<h1 id="shell-script-的追踪与调试"><a href="#shell-script-的追踪与调试" class="headerlink" title="shell script 的追踪与调试"></a>shell script 的追踪与调试</h1><p>可以使用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sh [-nvx] scripts.sh</div><div class="line"></div><div class="line">选项与参数：</div><div class="line">-n  ：不要运行 script，仅查询语法的问题；</div><div class="line">-v  ：在运行 sccript 前，先将 scripts 的内容输出到屏幕上；</div><div class="line">-x  ：将使用到的 script 内容显示到萤幕上，这是很有用的参数！</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：要想管理好自己的主机，自动化管理系统的好工具——shell script，这个家伙是真的需要好好学习学习的！
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_深入bash数据操作</title>
    <link href="http://bestlixiang.site/2018/03/30/%E8%B5%B0%E8%BF%9BLinux_%E6%B7%B1%E5%85%A5bash%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
    <id>http://bestlixiang.site/2018/03/30/走进Linux_深入bash数据操作/</id>
    <published>2018-03-30T07:12:54.000Z</published>
    <updated>2018-04-09T04:32:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在这里有一切你想要的bash数据操作知识，比如数据流重定向，管道命令，正则表达式的使用，大家可以快快进来！<a id="more"></a></p>
<h1 id="数据流的重定向"><a href="#数据流的重定向" class="headerlink" title="数据流的重定向"></a>数据流的重定向</h1><h2 id="什么是数据流重定向"><a href="#什么是数据流重定向" class="headerlink" title="什么是数据流重定向"></a>什么是数据流重定向</h2><p>一般来说，如果你要执行一个命令，通常它会是这样的：</p>
<ol>
<li>文件 -&gt; 标准输入 -&gt;命令</li>
<li>如果执行正确，命令 -&gt; 标准输出 -&gt; 文件/设备；如果执行错误，命令 -&gt; 标准错误输出 -&gt; 文件或设备</li>
</ol>
<h3 id="标准输出，标准错误输出，标准输入"><a href="#标准输出，标准错误输出，标准输入" class="headerlink" title="标准输出，标准错误输出，标准输入"></a>标准输出，标准错误输出，标准输入</h3><ol>
<li>标准输出：指的是命令执行所回传的正确信息，代码为1，使用&gt; 或 &gt;&gt;;</li>
<li>标准错误输出：指的是命令执行错误失败后，所回传的错误信息，代码为12，使用2&gt; 或 2&gt;&gt;;</li>
<li>标准输入：将原本需要键盘输入的数据改由文件内容来替代，代码为0，使用&lt; 或 &lt;&lt;;</li>
</ol>
<p>如下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ll / &gt; ~/rootfile // 显示文件名信息到rootfile文件中</div></pre></td></tr></table></figure></p>
<p>关于重定向输出文件的创建方式如下：</p>
<ol>
<li>该文件如果不存在，系统会自动将它创建起来</li>
<li>当这个文件存在，那么系统就会将这个文件内容清空，然后再将数据写入</li>
<li>若以&gt;输入到一个以存在的文件中，那个文件就会被覆盖，如果不想被覆盖，可以使用 &gt;&gt;</li>
</ol>
<h3 id="dev-null-垃圾桶黑洞设备与特殊写法"><a href="#dev-null-垃圾桶黑洞设备与特殊写法" class="headerlink" title="/dev/null 垃圾桶黑洞设备与特殊写法"></a>/dev/null 垃圾桶黑洞设备与特殊写法</h3><ol>
<li><p>/dev/null 垃圾桶黑洞设备，如果我们知道错误信息会发生，所以要讲错误信息忽略掉而不显示或存储，我们就需要使用/dev/null这个黑洞设备了。写法如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ll /  2&gt; /dev/null</div></pre></td></tr></table></figure>
</li>
<li><p>如果我们要将正确地与错误数据都写入同一个文件中去，这个时候就需要使用特殊写法了，如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ll / &gt; ~/rootfile 2&gt;&amp;1  </div><div class="line">ll / &amp;&gt; ~/rootfile</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="为什么要使用命令输出重定向"><a href="#为什么要使用命令输出重定向" class="headerlink" title="为什么要使用命令输出重定向"></a>为什么要使用命令输出重定向</h3><ol>
<li>屏幕输出的信息很重要，而且我们需要将它存下来的时候</li>
<li>后台执行中的程序，不希望它干扰屏幕正常的输出结果时</li>
<li>一些系统的例行命令的执行结果，希望它可以存下来时</li>
<li>一些执行命令的可能已知信息时，想以“2&gt;/dev/null”将它丢掉时</li>
<li>错误信息与正确信息需要分别输出时</li>
</ol>
<h2 id="命令执行的判断依据：；，-amp-amp-，"><a href="#命令执行的判断依据：；，-amp-amp-，" class="headerlink" title="命令执行的判断依据：；， &amp;&amp;，||"></a>命令执行的判断依据：；， &amp;&amp;，||</h2><p>在某些情况下，很多命令我们需要一次输入去执行，而不像分开执行，基本有两个选择，一个是通过shell script编写脚本去执行，一种是听过下面的介绍来一直输入多重命令。</p>
<ol>
<li>cmd ; cmd (不考虑命令相关性的连续命令执行，第一个命令执行结束后便会执行第二个命令)</li>
<li>cmd &amp;&amp; cmd (若第一个命令执行成功才会执行第二个命令；若第一个命令执行失败，则不会执行第二个命令。)</li>
<li>cmd || cmd (若第一个命令执行成功，则不执行第二个命令；若第一个命令执行失败，才会执行第二个命令。)</li>
</ol>
<h1 id="管道命令-pipe"><a href="#管道命令-pipe" class="headerlink" title="管道命令(pipe)"></a>管道命令(pipe)</h1><h2 id="什么是管道命令"><a href="#什么是管道命令" class="headerlink" title="什么是管道命令"></a>什么是管道命令</h2><p><strong>管道命令</strong> 能够将一个命令的执行结果经过<strong>筛选</strong>，只保留我们需要的信息。 它的符号是 <strong>“ | ”</strong>。</p>
<p>管道命令有下面两个比较需要注意的地方：</p>
<ol>
<li>管道命令仅会处理标准输出，对于标准错误输出会予以忽略</li>
<li>管道命令必须要能够接收来自前一个命令的数据成为标准输人继续处理才行。</li>
</ol>
<h2 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h2><h3 id="选取指定列：cut"><a href="#选取指定列：cut" class="headerlink" title="选取指定列：cut"></a>选取指定列：cut</h3><p>cut为剪切的意思，它能将一行行的数据按照指定的分隔符切成一列列，然后只显示特定列的数据。 cut有两种使用方式：</p>
<ul>
<li><p>按照指定字符分隔，这个命令会按照特定的分隔符将数据切分，并只显示第n列的数据。如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cut -d &apos;分隔符&apos; -f n(第几列)</div></pre></td></tr></table></figure>
</li>
<li><p>选择特定范围内的数据，如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cut -c 起始字符的下标-结束字符的下标</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="关键词搜索指定行：grep"><a href="#关键词搜索指定行：grep" class="headerlink" title="关键词搜索指定行：grep"></a>关键词搜索指定行：grep</h3><p>grep用于进行关键词查找，它会将文件中含有关键词的那一整行输出来。grep的两种使用方式如下：</p>
<ul>
<li><p>从指定文件中将符合关键词的行搜索出来，如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep [-参数] ‘关键词’ 文件</div></pre></td></tr></table></figure>
</li>
<li><p>采用管道，将前一个命令的执行结果输出给grep，并通过grep的关键词搜索将符合条件的行搜索出来，如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">命令 | grep [-参数] ‘关键词’</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="排序：sort"><a href="#排序：sort" class="headerlink" title="排序：sort"></a>排序：sort</h3><p>sort命令能够将指定文件 或 前一个命令的结果数据 按照指定字段进行排序。sort两种使用方式与grep基本一样，一种是将文件中的数据按照指定字段排序。另一种是使用管道，将前一个命令执行的结果按照指定字段进行排序。。</p>
<h3 id="去除重复行：uniq"><a href="#去除重复行：uniq" class="headerlink" title="去除重复行：uniq"></a>去除重复行：uniq</h3><p>该命令只能用于管道，如统计当前系统所有用户的登录次数：如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">last | cut -d &apos; &apos; -f 1 | uniq -c</div></pre></td></tr></table></figure></p>
<h3 id="统计字数、行数、字符数：wc"><a href="#统计字数、行数、字符数：wc" class="headerlink" title="统计字数、行数、字符数：wc"></a>统计字数、行数、字符数：wc</h3><p>wc只能通过管道使用，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">命令 | wc [-参数]</div></pre></td></tr></table></figure></p>
<h3 id="双向重定向：tee"><a href="#双向重定向：tee" class="headerlink" title="双向重定向：tee"></a>双向重定向：tee</h3><p>tee只能和管道结合使用，如将last中的信息输出指文件并显示在屏幕上,指令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">last | tee -a lastfile | cut -d &apos; &apos; f 1</div></pre></td></tr></table></figure></p>
<h3 id="切割文件：split"><a href="#切割文件：split" class="headerlink" title="切割文件：split"></a>切割文件：split</h3><p>该命令能将一个大文件切分成若干个小文件。用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">split [-bl] 大文件 小文件名字前缀</div></pre></td></tr></table></figure></p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h2><p><strong>正则表达式</strong> 就是处理字符串的方法，它是行为单位来进行字符串的处理行为<br>正则表达式通过一些特殊符号的辅助，可以让用户轻易达到查找、删除、替换某特定字符串的处理程序。</p>
<p>正则表达式基本上就是一种“表示法”，只要工具支持这种表示法，那么工具程序就可以用来作为正则表达式的字符串处理之用。比如vi、grep、awk、sed等工具。</p>
<p>正则表达式的字符串表达方式依照不同的严谨度可以分为<strong>基本正则表达式</strong>与<strong>扩展正则表达式</strong>。</p>
<h2 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h2><h3 id="基础正则表达式字符"><a href="#基础正则表达式字符" class="headerlink" title="基础正则表达式字符"></a>基础正则表达式字符</h3><table>
<thead>
<tr>
<th>RE字符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>^word</td>
<td>待查找的字符串(word)在行首</td>
</tr>
<tr>
<td>word$</td>
<td>待查找的字符串(word)在行尾</td>
</tr>
<tr>
<td>.</td>
<td>代表一定有一个任意字符的字符</td>
</tr>
<tr>
<td>\/</td>
<td>转义字符,将特殊符号的特殊意义去除</td>
</tr>
<tr>
<td>*</td>
<td>重复0个或多个的前一个字符</td>
</tr>
<tr>
<td>[list]</td>
<td>从字符集合的RE字符里面找出想要选取的字符</td>
</tr>
<tr>
<td>[n1-n2]</td>
<td>从字符集合的RE字符里面找出想要选取的字符范围</td>
</tr>
<tr>
<td>[^list]</td>
<td>从字符集合的RE字符里面找出不要的字符串或范围</td>
</tr>
<tr>
<td>/{n,m/}</td>
<td>连续n到m个的前一个RE字符,/{n/}表示连续n个,/{n,/}表示连续n个及以上</td>
</tr>
</tbody>
</table>
<p>PS：正则表达式的特殊字符与一般在命令行输入的“通配符”并不相同，通配符的*代表的是零到无限多个字符的意思，但是在正则表达式中*是表示重复0到无穷多个前一个RE字符的意思。</p>
<h3 id="基础正则表达式练习-以grep工具为例"><a href="#基础正则表达式练习-以grep工具为例" class="headerlink" title="基础正则表达式练习(以grep工具为例)"></a>基础正则表达式练习(以grep工具为例)</h3><ol>
<li><p>查找特定字符串</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep -n ‘the’ regular_express.txt</div><div class="line"></div><div class="line">grep -vn &apos;the&apos; regular_express.txt  (-v反向选择)</div></pre></td></tr></table></figure>
</li>
<li><p>利用中括号[]来查找集合字符</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">grep -n &apos;t[ae]st&apos; regular_express.txt (可匹配test或tast)</div><div class="line"></div><div class="line">grep -n &apos;[^g]oo&apos; regular_express.txt (oo前不能有g的字符)</div><div class="line"></div><div class="line">grep -n &apos;[^[:lower:]]oo&apos; regular_express.txt   ([:lower:]代表a-z的意思)</div></pre></td></tr></table></figure>
</li>
<li><p>行首和行尾字符</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep -n &apos;^test&apos; regular_express.txt (注:^在[]内表示“反向选择”,在[]外表示定位在行首)</div><div class="line"></div><div class="line">grep -n &apos;/.$&apos; regular_express.txt  (找出行尾结束为小数点的那一行)</div></pre></td></tr></table></figure>
</li>
<li><p>任意一个字符.与重复字符*</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">grep -n ‘g..d’ regular_express.txt (可匹配good,glad等字符)</div><div class="line"></div><div class="line">grep -n &apos;ooo*&apos; regular_express.txt  (匹配至少两个o以上的字符)</div><div class="line"></div><div class="line">grep -n &apos;g.*g&apos; regular_express.txt (找出g开头与g结尾的字符串,.*表示o个或多个任意字符的意思)</div></pre></td></tr></table></figure>
</li>
<li><p>限定连续RE(Regular Expression)字符范围{}</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">grep -n &apos;o/&#123;2/&#125;&apos; regular_express.txt (找出两个o的字符串)</div><div class="line"></div><div class="line">grep -n ‘go/&#123;2,5/&#125;g’ regular_express.txt (g后有两个到5个o,然后接一个g的字符串)</div><div class="line"></div><div class="line">grep -n ‘go/&#123;2,/&#125;g’ regular_express.txt (g后有两个及以上的o,然后接一个g的字符串)</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="sed工具"><a href="#sed工具" class="headerlink" title="sed工具"></a>sed工具</h3><p>sed本身是一个管道命令，它可以将数据进行替换、删除、新增、选取特定行等功能。使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed [-nefr] [动作]</div></pre></td></tr></table></figure></p>
<h2 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h2><p>一般情况下只需要基础正则表达式即可，但是有时候还需要一些扩展功能，比如整合两条管道命令，这就需要用到扩展正则表达式，如果是grep，它基本使用命令是egrep，基本的符号如下：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>意义与范例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>重复一个或多个的前一个RE字符，如：egrep -n ‘go+d’ regular_express.txt</td>
</tr>
<tr>
<td>?</td>
<td>0个或一个的前一个RE字符，如：egrep -n ‘go?d’ regular_express.txt</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>用或的方式找出字符串，如：egrep -n ‘gd\</td>
<td>good’ regular_express.txt</td>
</tr>
<tr>
<td>()</td>
<td>找出“组”的字符串 (如:egrep -n ‘g(la \</td>
<td>oo)d’ regular_express.txt  表示找出glad或good字符串)</td>
</tr>
<tr>
<td>()+</td>
<td>多个重复组的判别  (如echo ‘AxyzxyzxyzxyzC’ \</td>
<td>egrep ‘A(xyz)+C’  找出开头是A结尾是C,中间有一个以上的“xyz”字符串)</td>
</tr>
</tbody>
</table>
<h1 id="文件的格式化处理"><a href="#文件的格式化处理" class="headerlink" title="文件的格式化处理"></a>文件的格式化处理</h1><h2 id="文件格式化：printf"><a href="#文件格式化：printf" class="headerlink" title="文件格式化：printf"></a>文件格式化：printf</h2><p>如果我们需要将自己的数据给它格式化输出，我们就需要一个好的样式，输出的方式其实和C语言的格式化输出差不多，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">printf &apos;打印格式&apos; 实际内容</div></pre></td></tr></table></figure></p>
<h2 id="好用的数据处理工具：awk"><a href="#好用的数据处理工具：awk" class="headerlink" title="好用的数据处理工具：awk"></a>好用的数据处理工具：awk</h2><p>awk相当适合处理小型的数据，它的基本用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">awk ‘条件类型1&#123;动作1&#125; 条件类型2&#123;动作2&#125; ...’ filename</div><div class="line"></div><div class="line">// 例子</div><div class="line">last -n 5 | awk &apos;&#123;print $1 &quot;\t&quot; $3&#125;&apos; // 取出登录者账号和ip</div></pre></td></tr></table></figure></p>
<p>这个awk的处理流程如下：</p>
<ol>
<li>读入第一行，并将第一行的填入$0,$1等变量中</li>
<li>依据条件类型的限制，判断是否需要进行后面的动作</li>
<li>做完所有的动作与条件类型</li>
<li>若还有后续行，就重复上面1~3的步骤，直到所有数据都读完为止。</li>
</ol>
<h2 id="文件比较工具：diff"><a href="#文件比较工具：diff" class="headerlink" title="文件比较工具：diff"></a>文件比较工具：diff</h2><p>diff用于比较两个文件之间的区别,并且是以行为单位的,diff也可以比较两个目录。用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">diff [-bBi] from-file to-file</div></pre></td></tr></table></figure></p>
<p>patch这个命令与diff有密不可分的联系，将旧的文件升级成为新的文件的方法是先比较新旧版本的区别，将将区别文件制作成为补丁文件，再有补丁问价更新旧文件即可。例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 范例:以/tmp/test内的passwd.old 与passwd.new 制作补丁文件,并更新旧版数据</div><div class="line"></div><div class="line">diff -Naur passwd.old passwd.new &gt;passwd.patch</div><div class="line"></div><div class="line">// 更新旧文件,变成和新文件一样</div><div class="line"></div><div class="line">patch -p0 &lt; passwd.patch</div><div class="line"></div><div class="line">// 恢复旧文件的内容</div><div class="line"></div><div class="line">patch -R -p0 &lt; passwd.patch</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在这里有一切你想要的bash数据操作知识，比如数据流重定向，管道命令，正则表达式的使用，大家可以快快进来！
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_初探shell步入bash</title>
    <link href="http://bestlixiang.site/2018/03/28/%E8%B5%B0%E8%BF%9BLinux_%E5%88%9D%E6%8E%A2shell%E6%AD%A5%E5%85%A5bash/"/>
    <id>http://bestlixiang.site/2018/03/28/走进Linux_初探shell步入bash/</id>
    <published>2018-03-28T05:44:19.000Z</published>
    <updated>2018-04-09T04:32:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在Linux的环境下，如果你不懂bash是什么，那么其他的东西就不用学了！<a id="more"></a></p>
<h1 id="认识bash这个shell"><a href="#认识bash这个shell" class="headerlink" title="认识bash这个shell"></a>认识bash这个shell</h1><p>管理整个计算机硬件的其实是操作系统的内核，这个内核是需要保护的，所以我们一般用户就只能通过shell来跟内核通信，以让内核达到我们所想要达到的工作，那么系统。</p>
<h2 id="硬件、内核与shell"><a href="#硬件、内核与shell" class="headerlink" title="硬件、内核与shell"></a>硬件、内核与shell</h2><p>下面是硬件、内核与shell的关系：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/linux/png/relation_shell.png" alt="shell"></p>
<p>我们必须要通过“shell”将我们输入的命令与内核通信，好让内核可以控制硬件来正确无误地工作。</p>
<p>其实shell的功能只是提供用户操作系统的一个接口，因此这个shell需要可以调用其他软件才好。<strong>只要能够操作应用程序的接口都能够称为shell。</strong> <strong>狭义的shell</strong>指的是命令行方面的软件，包括bash等。<strong>广义的shell</strong>包括图形界面的软件，因为图形界面也能够操作各种应用程序来调用内核工作。</p>
<h2 id="为什么要学命令行界面的shell"><a href="#为什么要学命令行界面的shell" class="headerlink" title="为什么要学命令行界面的shell"></a>为什么要学命令行界面的shell</h2><ol>
<li>命令行界面的shell：大家（几乎所有发行版）都一样</li>
<li>远程管理：命令行界面就是比较快，而且较不容易出现断线或者信息外流的问题。</li>
<li>Linux的任督二脉：shell是也。因为要想将自己的主机管理好，良好的shell程序编写是必须的。</li>
</ol>
<h2 id="系统合法与-etc-shells功能"><a href="#系统合法与-etc-shells功能" class="headerlink" title="系统合法与/etc/shells功能"></a>系统合法与/etc/shells功能</h2><p>目前我们的Linux有下面几个可以用的shell，我们可以通过查看/etc/shells这个文件，可以看到如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/bin/sh   (已经被/bin/bash所替代)</div><div class="line">/bin/bash  (Linux默认的shell)</div><div class="line">/sbin/nologin</div><div class="line">/usr/bin/sh</div><div class="line">/usr/bin/bash</div><div class="line">/usr/sbin/nologin</div><div class="line">/bin/tcsh   (整合C shell，提供了更多的功能)</div><div class="line">/bin/csh  (已经被/bin/tcsh所替代)</div></pre></td></tr></table></figure></p>
<p>Linux默认的就是bash。系统上合法的shell都要写入/etc/shells这个文件中，因为系统某些服务在运行过程中，会去检查用户能够使用的shells，而这些shell的查询就是借助/etc/shells这个文件。</p>
<p>用户默认取得的shell可以通过查看/etc/passwd文件，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">bin:x:1:1:bin:/bin:/sbin/nologin</div><div class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</div></pre></td></tr></table></figure></p>
<h2 id="bash-shell的功能"><a href="#bash-shell的功能" class="headerlink" title="bash shell的功能"></a>bash shell的功能</h2><p>bash的优点如下：</p>
<ol>
<li>命令记忆能力，~/.bash_history里面会记录前一次登录所执行过的命令，而这一次登录都被暂存在临时内存中，成功注销后，本次执行的命令会记录到文件中。最大的好处就是可以查询曾经做过的操作，利于排错。</li>
<li>命令与文件补全功能（Tab键的好处）</li>
<li>命令别名设置功能（alias）执行如下得命令：<blockquote>
<p>alias 简化命令=’实际命令’ （设置别名）; unalias 简化命令（解除别名）</p>
</blockquote>
</li>
<li>作业控制、前台、后台控制</li>
<li>程序脚本</li>
<li>通配符（*）</li>
</ol>
<h1 id="shell的变量功能"><a href="#shell的变量功能" class="headerlink" title="shell的变量功能"></a>shell的变量功能</h1><p>变量是bash环境中非常重要的一个玩意儿。</p>
<h2 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h2><p><strong>变量：</strong> 就是以一组文字或符号等，来替代一些设置或者一串保留的数据。</p>
<p>变量的方便性在于：</p>
<ol>
<li>变量的可变性与方便性</li>
<li>简化bash环境操作</li>
<li>脚本程序设计的好帮手</li>
</ol>
<h2 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h2><p>在Linux中，变量分为环境变量(全局变量) 和 局部变量。<br>环境变量能被子进程继承，而局部变量只能在当前进程中使用。</p>
<p>不论是环境变量还是局部变量。他们又都可以分为系统变量 和 自定义变量。系统变量是系统启动时自动创建的变量，往往为系统运行提供支持；而自定义变量是用户自己定义的。一般而言，系统变量全为大写，自定义变量全为小写。</p>
<h2 id="变量的显示与设置：echo，unset"><a href="#变量的显示与设置：echo，unset" class="headerlink" title="变量的显示与设置：echo，unset"></a>变量的显示与设置：echo，unset</h2><ol>
<li><p>变量的显示：echo</p>
<p> 读变量，只需要在变量名称前面加上$，或者是以${变量}的方式来显示就可以。</p>
</li>
<li><p>变量的修改：“=”</p>
<p> 只需要用等号连接变量与它的内容就好了。它具有如下设置规则：</p>
<ul>
<li>等号两边不能直接接空格符</li>
<li>变量名称只能是英文字母与数字，但是开头字符不能是数字</li>
<li>变量内容若有空格可使用双引号或单引号将变量的内容结合起来</li>
<li>可以用转义字符”\”将特殊符号（如enter、$、\、空格符、！等）变成一般字符。</li>
<li>在一串命令中，还需要其他的命令提供的信息，可以使用反单引号“`命令`”或“$(命令)”</li>
<li>若该变量为了增加变量内容时，则可用“$变量名称”或${变量}累加内容，后用冒号连接。</li>
<li>若该变量需要在其他自进程执行，则需要以export来使变量变成环境变量。</li>
<li>通常大写字符为系统默认变量，自行设置变量可以使用小写字符，方便判断。</li>
<li><p>取消变量的方法为使用“unset 变量名称”</p>
<p>什么是<strong>子进程：</strong> 在一个bash中开启一个新的bash，那么原本的bash称为父进程，新的bash称为子进程。 子进程会继承父进程的所有环境变量，而父进程的局部变量只能在父进程中使用。</p>
</li>
</ul>
</li>
</ol>
<h2 id="环境变量的功能"><a href="#环境变量的功能" class="headerlink" title="环境变量的功能"></a>环境变量的功能</h2><p><strong>环境变量</strong>可以帮我们达到很多功能，包括主文件夹的变换、提示符的显示、执行文件查找的路径等。在shell环境下，可以通过env与export查看环境变量。下面主要介绍一下主要的环境变量：</p>
<ul>
<li>HOME：用户主目录，当我们使用cd 或cd ~时就会调用这个环境变量找到用户主目录</li>
<li>SHELL：当前使用的SHELL，默认使用/bin/bash</li>
<li>HISTSIZE：历史命令的最大条数</li>
<li>PATH：可执行文件的查找路径。这是一个非常重要的环境变量，当我们直接写一个命令时，系统就会在PATH路径中寻找这个命令，这样我们在执行命令的时候就不用输命令完整的路径了。多个路径之间用:分隔</li>
<li>LANG：当前系统的语言</li>
<li>RANDOM：随机数生成器的路径。该路径默认指向/dev/random这个文件，这个文件是一个随机数生成器，当我们使用$RANDOM时就能获得一个0-32767之间的随机整数</li>
</ul>
<p>当然我们还可以通过set来查看所有变量（含环境变量和自定义变量）：这里也解释几个比较重要的变量：</p>
<ul>
<li>PS1：命令提示符，在命令输入光标前有一串用中括号括起来的信息，这就是命令提示符。命令提示符究竟需要显示哪些信息，这就是由PS1这个局部变量决定的。由于它是局部变量，因此子进程中无法继承这个变量，子进程拥有自己的PS1。</li>
<li><p>$：当前shell的PID，可以通过如下命令查看当前shell的PID：</p>
<blockquote>
<p>echo $$</p>
</blockquote>
</li>
<li><p>?：上个命令的执行结果,上个命令若执行成功，则echo $?就会返回0；若上个命令执行失败，则该值为一个非0整数。</p>
</li>
</ul>
<h2 id="变量内容的删除与替换"><a href="#变量内容的删除与替换" class="headerlink" title="变量内容的删除与替换"></a>变量内容的删除与替换</h2><table>
<thead>
<tr>
<th>操作方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>${变量名#关键词}</td>
<td>从变量值的头部开始，依次向后删除到关键词第一次出现的位置为止</td>
</tr>
<tr>
<td>${变量名##关键词}</td>
<td>从变量值的头部开始，依次向后删除到关键词最后一次出现的位置为止</td>
</tr>
<tr>
<td>${变量名%关键词}</td>
<td>从变量值的尾部开始，依次向前删除到关键词第一次出现的位置为止</td>
</tr>
<tr>
<td>${变量名%%关键词}</td>
<td>从变量值的尾部开始，依次向前删除到关键词最后一次出现的位置为止</td>
</tr>
<tr>
<td>${变量名/旧字符串/新字符串}</td>
<td>从变量值的头部开始，依次向后找到第一个旧字符串，并将其替换</td>
</tr>
<tr>
<td>${变量名//旧字符串/新字符串}</td>
<td>将变量值中所有的旧字符串替换成新字符串</td>
</tr>
</tbody>
</table>
<h1 id="Bash-Shell的操作环境"><a href="#Bash-Shell的操作环境" class="headerlink" title="Bash Shell的操作环境"></a>Bash Shell的操作环境</h1><h2 id="路径与命令的查找顺序"><a href="#路径与命令的查找顺序" class="headerlink" title="路径与命令的查找顺序"></a>路径与命令的查找顺序</h2><p>基本上，命令运行的顺序可以这样看：</p>
<ol>
<li>以相对/绝对路径执行命令，例如：“/bin/ls”或“./ls”</li>
<li>由alias找到该命令来执行</li>
<li>有bash内置的(builtin)命令来执行</li>
<li>通过$PATH这个变量的顺序找到的第一个命令来执行</li>
</ol>
<h2 id="bash的登录与欢迎环境：-etc-issue-etc-motd"><a href="#bash的登录与欢迎环境：-etc-issue-etc-motd" class="headerlink" title="bash的登录与欢迎环境：/etc/issue,/etc/motd"></a>bash的登录与欢迎环境：/etc/issue,/etc/motd</h2><ol>
<li>/etc/issue：放置终端机接口登录成功的界面提示的字符。</li>
<li>/etc/issue.net：放置telnet远程登录成功的界面提示的字符。</li>
<li>/etc/motd：如果你想让用户登录后取得一些信息，可以将信息加入其中。比如告知登录者系统将在什么时候维护。</li>
</ol>
<h2 id="bash的环境配置文件"><a href="#bash的环境配置文件" class="headerlink" title="bash的环境配置文件"></a>bash的环境配置文件</h2><p>由于系统有一些环境配置文件的存在，让bash在启动时直接读取这些配置文件，所有已进入bash就能够取得一堆有用的变量。而这些配置文件又可以分为全体系统的配置文件以及用户个人偏好配置文件。要注意的是，之前我们说的命令别名、自定义的变量在你注销bash后就会失效。所以你想要保留你的设置，就得要讲这些设置写入配置文件才行。，下面就看看这些东西：</p>
<ol>
<li><p>login shell与non-login shell</p>
<p> login shell和non-login shell是两种shell登录的方式，它们登录后加载的环境配置文件有所不同。</p>
<ul>
<li>login shell在获取bash前需要进行一套完整的登录过程，这个登录过程就称为login shell。所谓“完整的登录过程”指需要输入用户名和密码。login shell其实只会读取这两个配置文件：/etc/profile和(~/.bash_profile或 ~/.bash\_login或~/.profile)</li>
<li>non-login shell获取bash不需要输入密码的登录过程称为non-login shell。如在bash中直接输入bash，从而打开一个子bash，这个过程不需要输入密码，因此称为non-login shell。比如在图形界面中。</li>
</ul>
</li>
<li>/etc/profile：系统级的环境变量(login shell才会读) 。<br>该文件存放系统级环境变量，所有的用户都会拥有，一般不建议修改这个文件。</li>
<li>~/.bash_profile：用户个人的环境变量(login shell才会读)<br>当/etc/profile中的环境变量加载完毕后就会加载本文件，本文件中定义了当前用户的环境变量。</li>
<li>~/.bashrc：non-login shell会读取的环境配置文件<br>当用户以non-login方式登录后，只会加载这个文件，该文件会对一些操作加上安全询问。这个文件不管哪种登录方式都会被加载，因此这里可以存放别名。</li>
<li>/etc/man.conf：设置man的存放路径<br>如果使用源码安装软件的话(非rpm、yum)，一般软件会安装在自定义的目录中(一般为/usr/local/软件名)。那么软件中的man文件就无法被系统找到，从而无法通过“man+命令”找到这个软件的命令帮助文档。我们需要手动将该软件的man目录添加到/etc/man.conf中去，从而执行“man+命令”就能找到这个目录的帮助文档。</li>
<li>~/.bash_history：存储用户历史命令</li>
<li>~/.bash_logout：记录注销后系统执行的操作</li>
</ol>
<h2 id="通配符和特殊字符"><a href="#通配符和特殊字符" class="headerlink" title="通配符和特殊字符"></a>通配符和特殊字符</h2><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>在bash的操作环境中还有一个非常有用的功能，那就是通配符。下面是一些常用的通配符：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>代表任意多个字符</td>
</tr>
<tr>
<td>?</td>
<td>代表一个字符</td>
</tr>
<tr>
<td>[]</td>
<td>[abcd]：代表该范围内的一个字符</td>
</tr>
<tr>
<td>[-]</td>
<td>[a-z]：代表a-z之间的一个字符</td>
</tr>
<tr>
<td>[^]</td>
<td>[^a-z]：代表除了a-z以外的所有字符</td>
</tr>
</tbody>
</table>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>下面是bash环境中的特殊符号：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>#</td>
<td>注释</td>
</tr>
<tr>
<td>\</td>
<td>转移字符，将特殊字符转为普通字符</td>
</tr>
<tr>
<td>;</td>
<td>分隔多个目录，使得依次执行</td>
</tr>
<tr>
<td>~</td>
<td>用户主目录</td>
</tr>
<tr>
<td>$</td>
<td>变量的起始符</td>
</tr>
<tr>
<td>&amp;</td>
<td>将目录置于后台执行</td>
</tr>
<tr>
<td>!</td>
<td>非</td>
</tr>
<tr>
<td>/</td>
<td>目录分隔符</td>
</tr>
<tr>
<td>&gt;,&gt;&gt;</td>
<td>数据流重定向，输出导向</td>
</tr>
<tr>
<td>&lt;,&lt;&lt;</td>
<td>数据流重定向，输入导向</td>
</tr>
<tr>
<td>‘’</td>
<td>不含变量置换功能</td>
</tr>
<tr>
<td>“”</td>
<td>含有变量置换功能</td>
</tr>
<tr>
<td>``</td>
<td>中间为待执行的命令，和$()一致</td>
</tr>
<tr>
<td>()</td>
<td>中间为子shell的起始和结束</td>
</tr>
<tr>
<td>{}</td>
<td>中间为命令块</td>
</tr>
</tbody>
</table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在Linux的环境下，如果你不懂bash是什么，那么其他的东西就不用学了！
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_学会使用vim程序编辑器</title>
    <link href="http://bestlixiang.site/2018/03/26/%E8%B5%B0%E8%BF%9BLinux_%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://bestlixiang.site/2018/03/26/走进Linux_学会使用vim程序编辑器/</id>
    <published>2018-03-26T09:06:33.000Z</published>
    <updated>2018-04-09T04:32:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：系统管理员的重要工作就是修改与设置某些重要软件的配置文件，因此至少得到学会一种以上的命令行界面的文本编辑器。在所有的Linux发行版中都具有vi这款编辑器，我们这次学的它的高级版vim。<a id="more"></a></p>
<h1 id="vi与vim"><a href="#vi与vim" class="headerlink" title="vi与vim"></a>vi与vim</h1><p>虽然在Linux在命令行界面下的文本编辑器有很多，比如Emacs，pico，nano，joe与vim等。但是我们却一定要学会vi或者说vim，vim相当于vi的高级版。</p>
<h2 id="为什么要学vim"><a href="#为什么要学vim" class="headerlink" title="为什么要学vim"></a>为什么要学vim</h2><ol>
<li>所有的UNIX Like系统都会内置vi文本编辑器，其他文本编辑器不一定存在。</li>
<li>所有软件的编辑结构都会主动调用vi（例如crontab，visudo,edquota等）<strong>很重要</strong></li>
<li>vim具有程序编辑能力，可以主动以字体颜色辨别语法的正确性，方便程序设计。</li>
<li>程序简单，编辑速度相当快速。</li>
</ol>
<h1 id="vi的使用"><a href="#vi的使用" class="headerlink" title="vi的使用"></a>vi的使用</h1><p>vi分为3种模式，分别是一般模式、编辑模式与命令行模式。它们的作用如下：</p>
<ol>
<li>一般模式：以vi打开一个文件就直接进入一般模式了。在这个模式中，你可以使用左右按键来移动光标，你可以删除字符或删除整行，也可以复制，粘贴你的文件数据。</li>
<li>编辑模式：在一般模式中是无法编辑文件内容的。要等到你按下“i,l,o,O,a,A,r,R”等任何一个字母之后才会进入编辑模式。通常在Linux中，按下这些按键时，在界面的左下方会出现INSERT或REPLACE的字样，此时才可以编辑，如果要回到一般模式，必须要按下ESC才可以退出编辑模式。</li>
<li>命令行模式：在一般模式中，输入“:、/、?”3个中的任何一个按钮，就可以将光标移动到最下面的那一行。在这个模式当中，可以提供你查找数据的操作，而读取、保存、大量替换字符、离开vi、显示行号等操作就是在此模式中完成的。</li>
</ol>
<h2 id="vi按键说明"><a href="#vi按键说明" class="headerlink" title="vi按键说明"></a>vi按键说明</h2><p>这个按键说明大部分人都会有总结，所以这里也就不再做无用功了，所以贴出下面的链接，遇到问题去查就好了，但是需要保证所有按键都亲自去试一遍！</p>
<p><strong><a href="https://blog.csdn.net/zyq522376829/article/details/47321739" target="_blank" rel="external">Linux - vim按键说明</a></strong></p>
<p>但是这里我还是想把<strong>常用的命令</strong>在这里再贴出来，希望能够记住：</p>
<ol>
<li>一般模式可用的按钮说明，光标移动、复制粘贴、查找替换等</li>
</ol>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + f</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键</td>
</tr>
<tr>
<td>Ctrl + b</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键</td>
</tr>
<tr>
<td>0 或功能键Home</td>
<td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td>
</tr>
<tr>
<td>$ 或功能键End</td>
<td>移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td>G</td>
<td>移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td>gg</td>
<td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td>
</tr>
<tr>
<td>nEnter</td>
<td>n为数字。光标向下移动 n 行(常用)</td>
</tr>
<tr>
<td>/word</td>
<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 server这个字符串，就输入 /vbird 即可！ (常用)</td>
</tr>
<tr>
<td>:n1,n2s/word1/word2/g</td>
<td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2</td>
</tr>
<tr>
<td>:1,$s/word1/word2/g</td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2</td>
</tr>
<tr>
<td>:1,$s/word1/word2/gc</td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代</td>
</tr>
<tr>
<td>x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键)</td>
</tr>
<tr>
<td>dd</td>
<td>删除游标所在的那一整列</td>
</tr>
<tr>
<td>ndd</td>
<td>n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列</td>
</tr>
<tr>
<td>yy</td>
<td>复制游标所在的那一行</td>
</tr>
<tr>
<td>nyy</td>
<td>n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列</td>
</tr>
<tr>
<td>p, P</td>
<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。</td>
</tr>
<tr>
<td>u</td>
<td>复原前一个动作</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>重做上一个动作</td>
</tr>
<tr>
<td>.</td>
<td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点“.”就好了！</td>
</tr>
</tbody>
</table>
<ol>
<li>一般模式切换到编辑模式的可用的按钮说明</li>
</ol>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>i, I</td>
<td>进入插入模式(Insert mode)：i 为从目前光标所在处插入， I 为在目前所在行的第一个非空格符处开始插入。</td>
</tr>
<tr>
<td>a, A</td>
<td>进入插入模式(Insert mode)：a为从目前光标所在的下一个字符处开始插入， A 为从光标所在行的最后一个字符处开始插入。</td>
</tr>
<tr>
<td>o, O</td>
<td>进入插入模式(Insert mode)：这是英文字母 o 的大小写。o 为在目前光标所在的下一行处插入新的一』； O 为在目前光标所在处的上一行插入新的一行！</td>
</tr>
<tr>
<td>r, R</td>
<td>进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止。</td>
</tr>
<tr>
<td>Esc</td>
<td>退出编辑模式，回到一般模式中</td>
</tr>
</tbody>
</table>
<ol>
<li>一般模式切换到指令列模式的可用的按钮说明</li>
</ol>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:w</td>
<td>将编辑的数据写入硬盘档案中</td>
</tr>
<tr>
<td>:q</td>
<td>离开 vi</td>
</tr>
<tr>
<td>:wq</td>
<td>储存后离开，若为 :wq! 则为强制储存后离开</td>
</tr>
</tbody>
</table>
<h1 id="vim的功能"><a href="#vim的功能" class="headerlink" title="vim的功能"></a>vim的功能</h1><p>目前大部分的发行版都以vim替代vi的功能了，如果你使用vi后，却看到界面的右下角有显示目前光标的行列号码，那么你的vi已经被vim替代了，vim相比于vi有许多新的功能。</p>
<h2 id="块操作"><a href="#块操作" class="headerlink" title="块操作"></a>块操作</h2><p>vi的操作基本上都是以行为单位的操作，但是vim具有块操作的功能，具体的按键说明如下：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>v</td>
<td>字符选择，将光标经过的地方反白选择</td>
</tr>
<tr>
<td>V</td>
<td>行选择，将光标经过的行反白选择</td>
</tr>
<tr>
<td>Ctrl + v</td>
<td>块选择，可以用长方形选择数据</td>
</tr>
<tr>
<td>y</td>
<td>将反白的地方复制</td>
</tr>
<tr>
<td>d</td>
<td>删除反白的地方</td>
</tr>
</tbody>
</table>
<h2 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h2><p>有事我们需要在一个vim内编辑多个文件，这个时候我们就需要多文件编辑功能，具体按键如下：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:n</td>
<td>编辑下一个文件</td>
</tr>
<tr>
<td>:N</td>
<td>编辑上一个文件</td>
</tr>
<tr>
<td>:files</td>
<td>列出目前这个vim打开的所有文件</td>
</tr>
</tbody>
</table>
<h2 id="多窗口功能"><a href="#多窗口功能" class="headerlink" title="多窗口功能"></a>多窗口功能</h2><p>很多时候我们需要对比文件，但是情况是在同一个vim窗口，这时候也就需要用到多窗口功能，具体按键如下：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>：sp filename</td>
<td>打开新窗口，如果有加filename,新窗口打开新文件，否则打开相同文件</td>
</tr>
<tr>
<td>Ctrl + w + j/↓</td>
<td>按键的按法是：先按下Ctrl不放，再按下w后放开所有的按键，然后再按下j或箭头，则光标可移动到下方的窗口</td>
</tr>
<tr>
<td>Ctrl + w + k/↑</td>
<td>同上，但是光标移动到上面的窗口</td>
</tr>
</tbody>
</table>
<h2 id="vim常用命令示意图"><a href="#vim常用命令示意图" class="headerlink" title="vim常用命令示意图"></a>vim常用命令示意图</h2><p><img src="http://o6plzvjf2.bkt.clouddn.com/linux/jpg/vim.jpg" alt="vim"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
<li><a href="https://blog.csdn.net/zyq522376829/article/details/47321739" target="_blank" rel="external">Linux - vim按键说明</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：系统管理员的重要工作就是修改与设置某些重要软件的配置文件，因此至少得到学会一种以上的命令行界面的文本编辑器。在所有的Linux发行版中都具有vi这款编辑器，我们这次学的它的高级版vim。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_Linux磁盘与文件系统管理</title>
    <link href="http://bestlixiang.site/2018/03/25/%E8%B5%B0%E8%BF%9BLinux_Linux%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    <id>http://bestlixiang.site/2018/03/25/走进Linux_Linux磁盘与文件系统管理/</id>
    <published>2018-03-25T12:02:04.000Z</published>
    <updated>2018-04-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：系统管理员最重要的任务之一就是管理好自己的磁盘文件系统，所以本文的知识对于那些需要规划自己磁盘文件系统的人群特别重要，有些内容可能不太详细，所以日后自己亲身实践过后，希望能再开一篇详细的文章。<a id="more"></a></p>
<h1 id="认识文件系统"><a href="#认识文件系统" class="headerlink" title="认识文件系统"></a>认识文件系统</h1><p>Linux最传统的磁盘文件系统使用的是EXT2（索引式文件系统）。所以要了解文件系统就得要又认识EXT2开始。</p>
<p>在Linux中，需要记录文件权限与文件属性，所以文件系统通常会将这两部分的数据分别存放在不同的块，权限和属性放置到inode中，至于实际数据则放置到data block块中，另外还有一个超级块（superblock）会记录整体文件系统的整体信息。<br>每个inode，block都有编号，下面简略说明上面三个数据的意义：</p>
<ol>
<li>super block：记录此文件系统的整体信息，包括inode/block的总量、使用量、以及文件系统的格式与相关信息。</li>
<li>inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block号码。</li>
<li>block：实际记录文件的内容，若文件太大时，会占用多个block。</li>
</ol>
<h1 id="Linux的Ext2文件系统"><a href="#Linux的Ext2文件系统" class="headerlink" title="Linux的Ext2文件系统"></a>Linux的Ext2文件系统</h1><ol>
<li>Ext2文件系统主要有boot sector，superblock，inode bitmap，block bitmap，inode table，data block六大部分。</li>
<li>data block是用来放置文件内容数据的地方，在Ext2文件系统中所支持的block大小有1KB、2KB及4KB三种。</li>
<li>inode记录文件的属性/权限等数据，每个inode大小均固定为128bytes；每个文件都仅占有一个inode而已；因此文件系统能够新建的文件数量，与inode数量有关。</li>
<li>文件的block记录文件的实际数据，目录的block则记录该目录下面文件名与其inode号码的对照表。</li>
<li>日志文件系统会多出一块记录区，随时记载文件系统的主要活动，可加快恢复时间。</li>
<li>Linux文件系统为增加其性能，会让主存储器作为大量的磁盘高速缓存。</li>
</ol>
<h1 id="文件系统的简单操作"><a href="#文件系统的简单操作" class="headerlink" title="文件系统的简单操作"></a>文件系统的简单操作</h1><h2 id="磁盘与目录的容量：df，du"><a href="#磁盘与目录的容量：df，du" class="headerlink" title="磁盘与目录的容量：df，du"></a>磁盘与目录的容量：df，du</h2><ol>
<li><p>df：列出文件系统的整体磁盘使用量</p>
<p> 在执行df命令之后，会出现如下信息：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">文件系统          1K-块    已用     可用 已用% 挂载点</div><div class="line">/dev/vda1      51474044 6759800 42092876   14% /</div><div class="line">devtmpfs         932632       0   932632    0% /dev</div><div class="line">tmpfs            941920      24   941896    1% /dev/shm</div><div class="line">tmpfs            941920     316   941604    1% /run</div><div class="line">tmpfs            941920       0   941920    0% /sys/fs/cgroup</div><div class="line">tmpfs            188388       0   188388    0% /run/user/0</div></pre></td></tr></table></figure>
</li>
<li><p>du：评估文件系统的磁盘使用量（常用于评估目录所占容量）</p>
<p> 可以看看下面的案例：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 1. 列出目前目录下的所有文件容量</div><div class="line">du</div><div class="line">// 2. 同范例一，但是将文件的容量也列出来</div><div class="line">du -a</div><div class="line">// 3. 检查根目录下面每个目录所占用的容量</div><div class="line">du -sm /*</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="连接文件"><a href="#连接文件" class="headerlink" title="连接文件"></a>连接文件</h2><ol>
<li><p>hard link (硬连接或实际连接)</p>
<p> hard link只是在某个目录下新建一条文件名连接到某inode号码的管理记录。它的命令如下：</p>
<blockquote>
<p>ln</p>
</blockquote>
<p> hard link是有如下限制的：</p>
<ul>
<li>不能跨文件系统</li>
<li>不能连接到目录</li>
</ul>
</li>
<li><p>symbolic link (符号连接，也即是快捷方式)</p>
<p> symbolic link就是在创建一个独立的文件，而这个文件会让数据的读取指向它连接的按个文件的文件名。它的命令如下：</p>
<blockquote>
<p>ls -s</p>
</blockquote>
<p> symbolic link与Windows的快捷方式可以画上等号，如果原文件被删除了，那symbolic link也就不能用了。</p>
</li>
</ol>
<h1 id="磁盘的分区、格式化、校验与挂载"><a href="#磁盘的分区、格式化、校验与挂载" class="headerlink" title="磁盘的分区、格式化、校验与挂载"></a>磁盘的分区、格式化、校验与挂载</h1><p>对于一个系统管理者(root)而言，磁盘的管理是相对重要的一环，如果我们想要在系统里面新增一块硬盘，应该有哪些动作需要做？</p>
<ol>
<li>对磁盘进行分区，以新建可用的分区</li>
<li>对该分区进行格式化，以创建系统可用的文件系统</li>
<li>若想要仔细一点，则可对刚才新建好的文件系统进行校验</li>
<li>在Linux系统上，需要创建挂载点（也即是目录），并将它挂载上来</li>
</ol>
<h2 id="磁盘分区：fdisk"><a href="#磁盘分区：fdisk" class="headerlink" title="磁盘分区：fdisk"></a>磁盘分区：fdisk</h2><p>输入如下命令，进入磁盘分区操作：</p>
<blockquote>
<p>fdisk /dev/hdc(磁盘名)</p>
</blockquote>
<p>接下来就是按照提示新增或者删除分区了。</p>
<h2 id="磁盘格式化：mkfs"><a href="#磁盘格式化：mkfs" class="headerlink" title="磁盘格式化：mkfs"></a>磁盘格式化：mkfs</h2><p>分区完毕之后就要进行格式化，格式化非常简单，使用mkfs（make file system）即可。命令如下：</p>
<blockquote>
<p>mkfs [-t 文件系统格式] 磁盘设备的文件名</p>
</blockquote>
<p>-t后的文件系统格式就是让你指定将文件系统格式化成哪种文件系统。如ext2、ext3、vfat等。</p>
<h2 id="磁盘检验：fsck"><a href="#磁盘检验：fsck" class="headerlink" title="磁盘检验：fsck"></a>磁盘检验：fsck</h2><p>当系统运行出现问题导致文件系统发生错乱，此时就需要磁盘的检验。命令如下：</p>
<blockquote>
<p>fsck [-t 文件系统] [-ACay] 设备名称</p>
</blockquote>
<p>通常只有root用户，而且在文件系统有问题的时候才能进行这个操作，因为在正常情况下使用这个命令会对系统伤害很大。 此外，fsck在扫描的时候，有问题的数据会被放在lost＋found这个文件夹中。所以正常情况下这个文件夹中是不应该有数据的。</p>
<h2 id="磁盘挂载与卸载：mount，umount"><a href="#磁盘挂载与卸载：mount，umount" class="headerlink" title="磁盘挂载与卸载：mount，umount"></a>磁盘挂载与卸载：mount，umount</h2><p>在挂载前需要确定下面几件事：</p>
<ol>
<li>单一文件系统不应该被重复挂载在不同的挂载点（目录）中</li>
<li>单一目录不应该重复挂载多个文件系统</li>
<li>作为挂载带你的目录理论上应该都是空目录</li>
</ol>
<p>具体命令如下</p>
<ul>
<li><p>挂载：</p>
<blockquote>
<p>mount [-t 文件系统] [-L 文件系统的卷标名称] [-o 额外选项] [-n] 设备文件名 挂载点  </p>
</blockquote>
</li>
<li><p>卸载</p>
<blockquote>
<p>umount [-fn] 设备文件名或挂载点</p>
</blockquote>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：系统管理员最重要的任务之一就是管理好自己的磁盘文件系统，所以本文的知识对于那些需要规划自己磁盘文件系统的人群特别重要，有些内容可能不太详细，所以日后自己亲身实践过后，希望能再开一篇详细的文章。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_Linux文件与目录管理大全解</title>
    <link href="http://bestlixiang.site/2018/03/25/%E8%B5%B0%E8%BF%9BLinux_Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E5%A4%A7%E5%85%A8%E8%A7%A3/"/>
    <id>http://bestlixiang.site/2018/03/25/走进Linux_Linux文件与目录管理大全解/</id>
    <published>2018-03-25T01:40:30.000Z</published>
    <updated>2018-04-09T04:31:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在使用Linux的过程中，最多的命令莫过于在操作文件与目录，所以通过本文，能让你大概率熟悉所有关于文件与目录的命令与知识，但是参数方面就需要自己去查询了。<a id="more"></a></p>
<h1 id="目录与路径"><a href="#目录与路径" class="headerlink" title="目录与路径"></a>目录与路径</h1><h2 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h2><ol>
<li>绝对路径：路径的写法<strong>一定由根目录/写起</strong>。</li>
<li>相对路径：路径的写法是相对于当前工作目录写的。</li>
</ol>
<h2 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h2><ol>
<li><p>特殊目录列表</p>
<ul>
<li>. ：当前目录</li>
<li>.. ：上层目录</li>
<li>- ：前一个工作目录</li>
<li>~ ：登陆用户的主文件夹</li>
<li>~account ：这个用户的主文件夹 （account是个账号名称）</li>
</ul>
</li>
<li><p>常见目录处理的命令</p>
<ul>
<li>cd：切换目录</li>
<li>pwd：显示当前目录</li>
<li>mkdir：新建一个新的目录</li>
<li>rmdir：删除一个空的目录，删除非空目录需要使用rm -r</li>
<li>好习惯：经常利用Tab键快速完整地输入目录或命令</li>
</ul>
</li>
<li><p>环境变量PATH</p>
<p> 当我们执行命令：ls －al的时候，系统会按照PATH设置的路径，去这些路径中寻找ls这个文件，并执行。如果PATH路径中有多个ls文件，那么先找到的那个ls文件被执行。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 查看PATH</span></div><div class="line">echo $PATH</div><div class="line"><span class="comment">// 在PATH中添加路径/demo</span></div><div class="line">PATH=<span class="string">"$PATH"</span>:/demo</div></pre></td></tr></table></figure>
<p> 对于PATH我们有几点需要清楚：</p>
<ul>
<li>不同身份用户默认的PATH不同，默认能够随意执行的命令也不同，差异较大的地方在于/sbin和/usr/sbin。</li>
<li>PATH是可以修改的，所以一般用户还是可以通过修改PATH来执行某些位于/sbin或/usr/sbin下的命令来查询。</li>
<li>使用绝对路径或相对路径直接指定某个命令的文件名来执行。</li>
<li>命令应该要放在正确的目录下，执行才会比较方便。</li>
<li>本目录（.）最好不要放到PATH当中，因为本目录会变化。</li>
</ul>
</li>
</ol>
<h1 id="文件和目录管理"><a href="#文件和目录管理" class="headerlink" title="文件和目录管理"></a>文件和目录管理</h1><p>在文件与目录的管理上，不外乎“显示属性”、“复制”、“删除文件”、“移动目录或文件”等。下面这这种管理动作的具体指令：</p>
<ol>
<li>显示属性<blockquote>
<p>ls</p>
</blockquote>
</li>
<li>复制<blockquote>
<p>cp</p>
</blockquote>
</li>
<li>删除<blockquote>
<p>rm</p>
</blockquote>
</li>
<li>移动(重命名)<blockquote>
<p>mv</p>
</blockquote>
</li>
</ol>
<p>这些指令的具体参数，希望大家能够通过man info去熟悉。</p>
<p>我们可以通过下面的命令去取得路径的文件名与目录名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 取得文件名称</div><div class="line">basename /etc/sysconfig/network</div><div class="line">// 取得文件目录</div><div class="line">dirname /etc/sysconfig/network</div></pre></td></tr></table></figure></p>
<h1 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h1><p>主要有下面一些命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>cat</td>
<td>由第一行开始显示文件内容</td>
</tr>
<tr>
<td>tac</td>
<td>从最后一行开始显示，可以看出tac是cat的到写形式</td>
</tr>
<tr>
<td>nl</td>
<td>显示的时候，顺便输出符号</td>
</tr>
<tr>
<td>more</td>
<td>一页一页显示文件内容</td>
</tr>
<tr>
<td>less</td>
<td>与more类似，但是比more更好的是，它可以往前翻页</td>
</tr>
<tr>
<td>head</td>
<td>只看头几行</td>
</tr>
<tr>
<td>tail</td>
<td>只看尾几行</td>
</tr>
<tr>
<td>od</td>
<td>以二进制的方式读取文件内容</td>
</tr>
</tbody>
</table>
<h1 id="文件与目录的默认权限和隐藏权限"><a href="#文件与目录的默认权限和隐藏权限" class="headerlink" title="文件与目录的默认权限和隐藏权限"></a>文件与目录的默认权限和隐藏权限</h1><p>除了基本的rwx权限之外，Linux的ext2/ext3文件系统下，我们还可以设置系统隐藏属性，它可以用chattr来设置，用lsattr来查看。最重要的属性就是可以设置文件/目录为不可修改，这可以让文件所有者都不能进行修改，这对于安全性方面是非常重要的。</p>
<h2 id="文件的默认权限：umask"><a href="#文件的默认权限：umask" class="headerlink" title="文件的默认权限：umask"></a>文件的默认权限：umask</h2><p>umask指定了目前用户在新建文件或目录时候的权限默认值。</p>
<p>指定了以下面的方式来指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@VM_0_9_centos ~]# umask</div><div class="line">0022 // 与一般权限有关的是后面是三个数字(表示不拥有该数值的权限，此例就表示group不拥有w，others不拥有w)</div><div class="line">[root@VM_0_9_centos ~]# umask -S</div><div class="line">u=rwx,g=rx,o=rx</div><div class="line"></div><div class="line">// 设置默认权限</div><div class="line">umask 002</div></pre></td></tr></table></figure></p>
<p>在默认权限的属性上，目录与文件是不一样的，x权限对于目录是非常重要的，但是一般文件的创建则不应该拥有执行权限。所以默认情况下：</p>
<ul>
<li>若用户创建“文件”则默认没有可执行权限，默认权限为666，即-rw-rw-rw-</li>
<li>若用户创建“目录”则默认拥有可执行权限，默认权限为777，即drwxrwxrwx</li>
</ul>
<h2 id="文件隐藏属性chattr，lsattr"><a href="#文件隐藏属性chattr，lsattr" class="headerlink" title="文件隐藏属性chattr，lsattr"></a>文件隐藏属性chattr，lsattr</h2><ol>
<li><p>chattr 设置文件的隐藏属性</p>
<p> 注意参数a（文件只能增加数据，不能删除也不能修改数据）和i(不能 删除，修改)</p>
</li>
<li>lsattr 显示文件隐藏属性</li>
</ol>
<h2 id="文件的特殊权限SUID-SGID-SBIT"><a href="#文件的特殊权限SUID-SGID-SBIT" class="headerlink" title="文件的特殊权限SUID,SGID,SBIT"></a>文件的特殊权限SUID,SGID,SBIT</h2><ol>
<li>SUID(u+s,如x为空，则出现大S)，限制与功能如下：<ul>
<li>SUID权限仅对二进制程序有效</li>
<li>执行者对于该程序需要x的可执行权限</li>
<li>本权限仅在执行该程序的过程中有效</li>
<li>执行者将具有该程序所有者的权限</li>
</ul>
</li>
<li>SGID（g+s,如x为空，则出现大S），对于文件功能与SUID类似，但是对于目录有如下功能：<ul>
<li>用户若对于此目录具有r与x的权限时，该用户能够进入此目录</li>
<li>用户在此目录下得有效用户组将变成该目录的用户组</li>
<li>若用户在此目录下具有w的权限（可以新建文件），则用户所创建的新文件的用户组与此目录的用户组相同</li>
</ul>
</li>
<li>SBIT（o+t,如x为空，则出现大T），目前只针对目录有效，它的作用如下：<ul>
<li>当用户对于此目录具有w，x权限，即具有写入的权限时，当用户在该目录下创建文件或目录时，仅有自己与root才有权利删除该文件。</li>
</ul>
</li>
</ol>
<h2 id="查看文件类型：file"><a href="#查看文件类型：file" class="headerlink" title="查看文件类型：file"></a>查看文件类型：file</h2><p>如果想知道某个文件的基本数据，就可以使用file这个命令查看。</p>
<h1 id="文件与命令的查询"><a href="#文件与命令的查询" class="headerlink" title="文件与命令的查询"></a>文件与命令的查询</h1><h2 id="脚本文件名的查询"><a href="#脚本文件名的查询" class="headerlink" title="脚本文件名的查询"></a>脚本文件名的查询</h2><p>如果你想知道类似ls这种命令的脚本放在哪里，就通过which或type来找寻。</p>
<p>which命令是根据PATH这个环境变量所规范的路径去查询“执行文件”的文件名。</p>
<h2 id="文件名的查找"><a href="#文件名的查找" class="headerlink" title="文件名的查找"></a>文件名的查找</h2><p>通常find不很常用，因为速度慢，通常我们都是先使用whereis或者是locate来检查，如果真的找不到了，才以find来查找，因为whereis与loacate是利用数据库来查询数据的，而find是直接查找硬盘的。</p>
<ol>
<li>whereis：寻找特定文件</li>
<li>locate：根据文件的部分名称查找，由于是查询数据库的，而数据库是当晚更新，所以你新建文件是查找不到的，可以利用updatedb手动更新，但是较慢。</li>
<li>find：参数很多，自己用的时候需要使用man page自行了解。</li>
</ol>
<h1 id="文件与文件系统的压缩与打包"><a href="#文件与文件系统的压缩与打包" class="headerlink" title="文件与文件系统的压缩与打包"></a>文件与文件系统的压缩与打包</h1><h2 id="常见的压缩命令"><a href="#常见的压缩命令" class="headerlink" title="常见的压缩命令"></a>常见的压缩命令</h2><p>不同的压缩打包技术，对应着不同的解压缩拆包技术，所以在Linux中用后缀名来分辨压缩打包技术，如下表：</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>压缩打包技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>*.Z</td>
<td>compress程序压缩</td>
</tr>
<tr>
<td>*.gz</td>
<td>gzip程序压缩</td>
</tr>
<tr>
<td>*.bz2</td>
<td>bzip2程序压缩</td>
</tr>
<tr>
<td>*.tar</td>
<td>tar程序打包，未压缩</td>
</tr>
<tr>
<td>*.tar.gz</td>
<td>tar程序打包,gzip程序压缩</td>
</tr>
<tr>
<td>*.tar.bz2</td>
<td>tar程序打包,bzip2程序压缩</td>
</tr>
</tbody>
</table>
<p>由于compress已经不再流行，所有我们主要讲解gzip和gzip2:</p>
<ol>
<li><p>gzip,zcat（用来替代compress）</p>
<p> 目前gzip可以解开compress、zip与gzip等软件压缩的文件。可以看一下下面的案例：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 1. 压缩文件</div><div class="line">gzip -v 文件名 // 参数v显示压缩比</div><div class="line">// 2. 查看压缩文件内容</div><div class="line">zcat 压缩文件</div><div class="line">// 3. 解压缩</div><div class="line">gzip -d 压缩文件名 // 参数d表示解压缩</div></pre></td></tr></table></figure>
</li>
<li><p>bzip2,bzcat（用来替代gzip）</p>
<p> 使用方法与gzip基本相同，不再赘述。</p>
</li>
</ol>
<h2 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h2><p>在压缩文件夹之前需要打包，然后我们就需要用到大名鼎鼎的tar，下面通过命令来具体介绍他的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 1. 压缩，参数的含义自己去用man page查看</div><div class="line">tar -jcv -f filename.tar.bz2 // 要被压缩的文件或目录名称，tar并不会主动产生创建的文件名</div><div class="line">// 2. 查询</div><div class="line">tar -jtv -f filename.tar.bz2</div><div class="line">// 3. 解压缩</div><div class="line">tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录（如：/tmp）</div></pre></td></tr></table></figure></p>
<p>对于只是打包没有压缩的文件叫做tarfile</p>
<p>对于打包了并且压缩的文件叫做tarball</p>
<h2 id="完整备份工具"><a href="#完整备份工具" class="headerlink" title="完整备份工具"></a>完整备份工具</h2><ol>
<li>dump 备份</li>
<li>restore 恢复</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在使用Linux的过程中，最多的命令莫过于在操作文件与目录，所以通过本文，能让你大概率熟悉所有关于文件与目录的命令与知识，但是参数方面就需要自己去查询了。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_Linux的文件权限与目录配置</title>
    <link href="http://bestlixiang.site/2018/03/22/%E8%B5%B0%E8%BF%9BLinux_Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://bestlixiang.site/2018/03/22/走进Linux_Linux的文件权限与目录配置/</id>
    <published>2018-03-22T09:03:13.000Z</published>
    <updated>2018-04-09T04:31:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：了解好文件权限和目录的具体含义才能更好的操作Linux，所以理解好文件权限与目录配置才至关重要。<a id="more"></a></p>
<h1 id="用户与用户组"><a href="#用户与用户组" class="headerlink" title="用户与用户组"></a>用户与用户组</h1><h2 id="用户（User）"><a href="#用户（User）" class="headerlink" title="用户（User）"></a>用户（User）</h2><ol>
<li>用户可以随意改变自己所拥有的文件</li>
<li>root用户就是最大的大佬，可以干任何事。</li>
</ol>
<h2 id="用户组（Group）"><a href="#用户组（Group）" class="headerlink" title="用户组（Group）"></a>用户组（Group）</h2><ol>
<li>同一个用户组的用户可以访问该用户组的文件</li>
<li>每个账号可以加入多个用户组</li>
<li>在同一个用户组的文件也可以设置不同的权限，可以不让本组用户查看</li>
</ol>
<h2 id="其他人（Others）"><a href="#其他人（Others）" class="headerlink" title="其他人（Others）"></a>其他人（Others）</h2><p>除了文件用户、同组用户以外的人就是其他人。</p>
<h2 id="Linux用户身份与用户组记录的文件"><a href="#Linux用户身份与用户组记录的文件" class="headerlink" title="Linux用户身份与用户组记录的文件"></a>Linux用户身份与用户组记录的文件</h2><ol>
<li>系统上的账号与一般身份用户以及root的相关信息都记录在/etc/passwd文件中</li>
<li>个人的密码都记录在/etc/shadow文件中</li>
<li>Linux所有的组名都记录在/etc/group文件中</li>
</ol>
<h1 id="文件权限概念"><a href="#文件权限概念" class="headerlink" title="文件权限概念"></a>文件权限概念</h1><h2 id="Linux文件属性"><a href="#Linux文件属性" class="headerlink" title="Linux文件属性"></a>Linux文件属性</h2><p>我们可以利用下面的命令来查看文件属性：</p>
<blockquote>
<p>ls -al  // 列出所有文件详细的权限和属性（包含隐藏文件）</p>
</blockquote>
<p>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">总用量 92</div><div class="line">drwxr-xr-x. 22 root root 4096 3月  17 12:33 .</div><div class="line">dr-xr-xr-x. 20 root root 4096 3月  22 09:14 ..</div><div class="line">drwxr-xr-x.  2 root root 4096 11月  5 2016 adm</div><div class="line">drwxr-xr-x   2 root root 4096 3月  12 10:27 alldata</div><div class="line">... 省略</div></pre></td></tr></table></figure></p>
<p>解释一下上面7列的意思：</p>
<ol>
<li><p>第一列：文件的类型与权限</p>
<p> 第一个字符代表这个文件是“目录、文件或链接文件等”。</p>
<ul>
<li>d：目录文件</li>
<li>-：普通文件</li>
<li>l：链接文件</li>
<li>b：用于存储数据的设备文件</li>
<li><p>c：用于传输数据的设备文件：鼠标、键盘</p>
<p>接下来都是三个字符为一组，分别表示文件所有者的权限、同组用户的权限、其他用户的权限，而且r（读）、w（写）、x（执行）的顺序是固定不变的。</p>
</li>
</ul>
</li>
<li>第二列：有多少文件名连接到此节点</li>
<li>第三列：这个文件（或目录）的所有者账号</li>
<li>第四列：这个文件所属的用户组</li>
<li>第五列：这个文件的大小，单位是B</li>
<li>第六列：这个文件的创建日期或修改日期</li>
<li>第七列：文件名</li>
</ol>
<h2 id="改变文件属性与权限的命令"><a href="#改变文件属性与权限的命令" class="headerlink" title="改变文件属性与权限的命令"></a>改变文件属性与权限的命令</h2><ol>
<li>chgrp：改变文件所属的用户组 （注意-R 参数，递归更改）</li>
<li>chown：改变文件所有者 （注意-R 参数，递归更改）</li>
<li><p>chmod：改变文件的权限 （注意-R 参数，递归更改）</p>
<p> 改变文件的权限有两种办法，分别是：用数字进行权限的修改、用符号进行权限的修改。</p>
<ul>
<li><p>用数字进行权限的修改：权限有9个字母组成，并且每三个为一组，分别表示：文件主的权限、同组用户的权限、其他人的权限。在这种方式中，r＝4、w＝2、x＝1，将每一组的三个值加起来，组成一个三位数即可。实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod -R 754 文件或目录</div></pre></td></tr></table></figure>
</li>
<li><p>用符号进行权限的修改：我们通过u(user)，g(group)，o(others)，a(all)来表示身份权限，通过<br>r（读）,w（写）,x（执行）来表示读写的权限，通过+（加入），-（除去），=（设置）来表示修改操作，实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod u/g/o/a  +/-/=  r/w/x  文件/目录</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="目录与文件的权限意义"><a href="#目录与文件的权限意义" class="headerlink" title="目录与文件的权限意义"></a>目录与文件的权限意义</h2><ol>
<li>权限对文件的重要性：<ul>
<li>r：可读取此文件的实际内容。</li>
<li>w：可以编辑、新增或者修改该文件的内容（单不含删除该文件）</li>
<li>x：该文件具有可以被系统执行的权限。</li>
</ul>
</li>
<li>权限对目录的重要性<ul>
<li>r：表示具有读取目录结构的权限，即可以执行ls命令</li>
<li>w：表示具有更改该目录结构列表的权限，比如新建新的文件与目录、删除已经存在的文件与目录、将已存在或目录进行重命名、转移该目录内的文件和目录位置</li>
<li>x：表示用户能否进入该目录，即可以使用cd进入该目录</li>
</ul>
</li>
</ol>
<h2 id="文件种类与扩展名"><a href="#文件种类与扩展名" class="headerlink" title="文件种类与扩展名"></a>文件种类与扩展名</h2><ol>
<li>文件种类<ul>
<li>普通文件<ul>
<li>纯文本文件（ASCII），可以用cat命令读取</li>
<li>二进制文件（binary），Linux中的可执行文件</li>
<li>数据格式文件（data），就是程序运行时会被读取的具有特定格式的文件，如配置文件，需要用last命令去读取，用cat读取会乱码</li>
</ul>
</li>
<li>目录</li>
<li>连接文件，类似Windows下的快捷方式</li>
<li>设备与设备文件<ul>
<li>块设备文件，用于存储数据的设备文件，如：硬盘、软盘</li>
<li>字符设备文件，用于数据传输的设备文件，如：键盘、鼠标</li>
<li>套接字，这个设备文件在/var/run中</li>
<li>管道，用于解决多个程序同时访问一个文件所造成的错误问题</li>
</ul>
</li>
</ul>
</li>
<li><p>文件扩展名</p>
<p> Linux并没有扩展名，一个Linux的文件是否可以执行，取决于这个文件的属性中是否有x这个权限（也要真的可以执行）。<br> 但是为了增强文件的可读性，我们还是给文件增加了“扩展名“。如下面几种（等）：</p>
<ul>
<li>＊.sh表示脚本或批处理文件</li>
<li>＊Z、＊.tar、＊.tar.gz、＊.zip、＊.tgz他们都是压缩文件</li>
<li><p>注意：从网上下载的文件的权限是有可能发生改变的，所以当我们下载的文件无法运行时查看一下它的权限是否有x。</p>
<p>Linux对文件的限制：Linxu默认采用Ext2/Ext3文件系统，对文件名的长度限制为，单个文件名或目录名最大长度255个字符；完整的文件或目录名最大长度为4096个字符。</p>
</li>
</ul>
</li>
</ol>
<h1 id="Linux目录配置"><a href="#Linux目录配置" class="headerlink" title="Linux目录配置"></a>Linux目录配置</h1><h2 id="Linux目录配置标准"><a href="#Linux目录配置标准" class="headerlink" title="Linux目录配置标准"></a>Linux目录配置标准</h2><p>FHS一句文件系统使用的频繁与否与是否允许用户随意改动，而将目录定义为四中交互的形态，如下：</p>
<table>
<thead>
<tr>
<th>/</th>
<th>可分享的(shareable)</th>
<th>不可分享的(unshareable)</th>
</tr>
</thead>
<tbody>
<tr>
<td>不变的(static)</td>
<td>/usr (软件放置处)</td>
<td>/etc (配置文件)</td>
</tr>
<tr>
<td>不变的(static)</td>
<td>/opt (第三方软件)</td>
<td>/boot(开机与内核文件)</td>
</tr>
<tr>
<td>可变动的(variable)</td>
<td>/var/mail (用户邮箱信件)</td>
<td>/var/run (程序相关)</td>
</tr>
<tr>
<td>可变动的(variable)</td>
<td>/var/spool/news (新闻组)</td>
<td>/var/lock (程序相关)</td>
</tr>
</tbody>
</table>
<p>解释一下四个类型的意思：</p>
<ul>
<li>可分享的：可以分享给网络上的其他主机挂载使用</li>
<li>不可分享的：只与自己的机器有关，所以自然就不能分享给其他主机</li>
<li>不变的：不管什么样的distributions，这些数据基本不发生变化。一般这些目录中存放函数库、系统配置文件等</li>
<li>可变的：经常改变的数据，如登录文件、新闻组等</li>
</ul>
<p><strong>根目录是整个系统最重要的目录，其他所有的子目录都是由根目录衍生而来的，同时根目录也与开机、还原、系统修复等操作有关。</strong></p>
<p>FHS建议：根目录要足够的小，而且应用程序不要和根目录放在同一个分区中。同时，FHS建议根目录下应该要有这些目录：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin</td>
<td>在bin目录下的命令可以被所有账号使用，一般的命令是：cat、chmod、chown、date、mv、mkdir、cp、bash</td>
</tr>
<tr>
<td>/boot</td>
<td>主要放置开机会使用到的文件</td>
</tr>
<tr>
<td>/dev</td>
<td>任何设备都是以文件的形式存放在这个目录当中</td>
</tr>
<tr>
<td>/etc</td>
<td>统主要的配置文件都放在这个目录中。这个目录下的文件属性是可以给一般用户查阅的，但只有root才可以修改，FHS建议：这个目录下不要放置可执行文件</td>
</tr>
<tr>
<td>/home</td>
<td>系统默认的用户主文件夹,～表示当前登陆用户的主文件夹 ，～rex表示指定用户的主文件夹</td>
</tr>
<tr>
<td>/lib</td>
<td>存放开机时用到的库函数及/bin、/sbin目录下的命令会使用到的库函数</td>
</tr>
<tr>
<td>/media</td>
<td>放置可删除的设备文件。如：软盘、光盘</td>
</tr>
<tr>
<td>/mnt</td>
<td>如果要临时挂载一些额外的设备就放在这个文件夹下</td>
</tr>
<tr>
<td>/opt</td>
<td>放置第三方软件的目录</td>
</tr>
<tr>
<td>/root</td>
<td>系统管理员的主文件夹</td>
</tr>
<tr>
<td>/sbin</td>
<td>放置开机过程中需要的，包括开机、修复、还原系统所需要的命令</td>
</tr>
<tr>
<td>/srv</td>
<td>是service的缩写，存放网络服务所需的一些数据</td>
</tr>
<tr>
<td>/tmp</td>
<td>一般用户执行程序暂时存放数据的地方。任何人都可以访问，所以要定时清理一下。FHS建议distributions开机时要将这个目录清空</td>
</tr>
</tbody>
</table>
<p>其他重要的目录：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>/lost+found</td>
<td>使用ext2/ext3文件系统才会产生的一个目录。当文件系统发生错误时，一些丢失的片段就会放在这个目录中</td>
</tr>
<tr>
<td>/proc</td>
<td>是一个虚拟文件系统，也就是它的数据都是存放在内存中的，不占用硬盘空间</td>
</tr>
<tr>
<td>/sys</td>
<td>也是一个虚拟文件系统，记录内核相关信息</td>
</tr>
</tbody>
</table>
<p>开机的时候只有根目录被挂载了，其他的目录所在的分区都是在系统启动完成之后才被挂载的。因此与开机过程有关的目录就必须要和根目录放在同一个分区中。必须与根目录放在同一个分区中的目录有下面这些目录：</p>
<ul>
<li>/etc：配置文件</li>
<li>/bin：重要的执行文件</li>
<li>/dev：所需要的设备文件</li>
<li>/lib：执行文件所需要的库函数与内核所需要的模块</li>
<li>/sbin：重要的系统执行文件</li>
</ul>
<p>/usr目录：＝UNIX Software Resource，是操作系统关键资源放置的目录。<br>FHS建议：所有软件开发者都应将数据放置在这个目录的子目录下，而不要自行创建独立的目录。<br>这个目录就相当于Windows下的c:\program files</p>
<p>/var目录：/usr放置安装程序时所需要的较大容量的文件，而/var下存放系统运行后才会渐渐占用硬盘的目录。如：缓存、日志、Mysql数据库的文件等。</p>
<h2 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h2><p>在Linux里面，所有的文件与目录都是由根目录开始的，那是所有目录与文件的源头，然后在一个一个分支下来，我们称这种目录配置为<strong>目录树</strong>。</p>
<p>目录树主要有以下特征：</p>
<ol>
<li>目录树的起始点为根目录（/，root）</li>
<li>每个目录不只能使用本地端的文件系统，也可以使用网络上的文件系统，例如可以利用NFS服务器挂载某特定目录等</li>
<li>米格文件在此目录树的文件名（包含完整路径）都是独一无二的。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：了解好文件权限和目录的具体含义才能更好的操作Linux，所以理解好文件权限与目录配置才至关重要。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_Linux命令使用与查询</title>
    <link href="http://bestlixiang.site/2018/03/21/%E8%B5%B0%E8%BF%9BLinux_Linux%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%9F%A5%E8%AF%A2/"/>
    <id>http://bestlixiang.site/2018/03/21/走进Linux_Linux命令使用与查询/</id>
    <published>2018-03-21T08:55:52.000Z</published>
    <updated>2018-04-09T04:31:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：从浅入深，我们也从基础命令开始。学会基本命令的使用，学会怎么去查命令的使用，最后学会一丢丢维护（开关机）。<br><a id="more"></a></p>
<h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><h2 id="开始执行命令"><a href="#开始执行命令" class="headerlink" title="开始执行命令"></a>开始执行命令</h2><p>首先我们要了解命令的格式：</p>
<blockquote>
<p>command(命令或可执行文件) <a href="选项">-options</a> parameter1(参数1) parameter2(参数2)</p>
</blockquote>
<p>如果命令太长，我们可以使用反斜杠(\)来转义[enter符号]，注意反斜杠必须立刻接特殊字符，才能转义。</p>
<p>在linux下面是区分大小写的。</p>
<h2 id="基础命令的操作"><a href="#基础命令的操作" class="headerlink" title="基础命令的操作"></a>基础命令的操作</h2><ol>
<li>显示日期与时间的命令：date</li>
<li>显示日历的命令：cal</li>
<li>简单好用的计算器：bc，使用quit停止</li>
</ol>
<h2 id="重要的热键"><a href="#重要的热键" class="headerlink" title="重要的热键"></a>重要的热键</h2><ol>
<li>Tab按键：具有命令补全，文件补齐的功能</li>
<li>ctrl + c：可以让程序立刻停下来</li>
<li>ctrl + d：通常代码键盘输入结束，相当于exit</li>
</ol>
<h1 id="在线求助man-page-与info-page"><a href="#在线求助man-page-与info-page" class="headerlink" title="在线求助man page 与info page"></a>在线求助man page 与info page</h1><h2 id="man-page"><a href="#man-page" class="headerlink" title="man page"></a>man page</h2><p>man其实是manual（操作说明）的简写，只要通过（man + 命令） 就会有详细的说明出现。</p>
<p>如 man date可以得到下面的文本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">DATE(1)                                  User Commands                                  DATE(1)</div><div class="line"></div><div class="line">NAME</div><div class="line">       date - print or set the system date and time</div><div class="line"></div><div class="line">SYNOPSIS</div><div class="line">       date [OPTION]... [+FORMAT]</div><div class="line">       date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</div><div class="line"></div><div class="line">DESCRIPTION</div><div class="line">       Display the current time in the given FORMAT, or set the system date.</div><div class="line"></div><div class="line">       Mandatory arguments to long options are mandatory for short options too.</div><div class="line"></div><div class="line">       -d, --date=STRING</div><div class="line">              display time described by STRING, not &apos;now&apos;</div><div class="line"></div><div class="line">        ...省略其他参数</div><div class="line"></div><div class="line">ENVIRONMENT</div><div class="line"></div><div class="line">EXAMPLES</div><div class="line"></div><div class="line">DATE STRING</div><div class="line"></div><div class="line">AUTHOR</div><div class="line">       Written by David MacKenzie.</div><div class="line"></div><div class="line">COPYRIGHT</div><div class="line"></div><div class="line">SEE ALSO</div><div class="line"></div><div class="line">GNU coreutils 8.22                       November 2016                                  DATE(1)</div></pre></td></tr></table></figure></p>
<p>我们首先看到的是“DATE(1)”，这个(1)是有特殊含义的，如下表：</p>
<table>
<thead>
<tr>
<th>代号</th>
<th>代表内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>用户在shell环境中可以操作的命令或可执行的文件</td>
</tr>
<tr>
<td>2</td>
<td>系统内核可调用的函数与工具等</td>
</tr>
<tr>
<td>3</td>
<td>一些常用的函数与函数库，大部分为C的函数库</td>
</tr>
<tr>
<td>4</td>
<td>设备文件的说明，通常在/dev的文件</td>
</tr>
<tr>
<td>5</td>
<td>配置文件或者某些文件的格式</td>
</tr>
<tr>
<td>6</td>
<td>游戏</td>
</tr>
<tr>
<td>7</td>
<td>惯例与协议等，例如Linux文件系统，网络协议、ASCII code等说明</td>
</tr>
<tr>
<td>8</td>
<td>系统管理员与可用的管理命令</td>
</tr>
<tr>
<td>9</td>
<td>跟kernel有关的文件</td>
</tr>
</tbody>
</table>
<p>我们要特别注意1，5，8这三个号码，尽量背下来。</p>
<p>在上面的man page中，以NAME作为开始介绍，最后还有个SEE ALSO来作为结束。基本上，man page大致分为以下几个部分：</p>
<table>
<thead>
<tr>
<th>代号</th>
<th>内容说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME</td>
<td>简短的命令、数据名称说明</td>
</tr>
<tr>
<td>SYNOPSIS</td>
<td>简短的命令执行语法（syntax）简介</td>
</tr>
<tr>
<td>DESCRIPTION</td>
<td>较为完整的说明，最好仔细看看</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>针对SYNNPSIS部分中，有列举的所有可用的选项说明</td>
</tr>
<tr>
<td>COMMANDS</td>
<td>在这个程序在执行的时候，可以在此程序中执行的命令</td>
</tr>
<tr>
<td>FILES</td>
<td>这个程序或数据所使用或参考或连接到的某些文件</td>
</tr>
<tr>
<td>SEE ALSO</td>
<td>这个命令或数据有相关的其他说明</td>
</tr>
<tr>
<td>EXAMPLES</td>
<td>一些可以参考的范例</td>
</tr>
<tr>
<td>BUGS</td>
<td>是否有相关的错误</td>
</tr>
</tbody>
</table>
<p>通常在查询某些数据是这样来查阅的：</p>
<ol>
<li>先看NAME的项目，略微看一下数据的意思</li>
<li>再仔细看一下DESCRIPTION，这个部分会提到很多相关的资料和用法。</li>
<li>如果这个命令其实很熟悉了，那么主要就是查询OPTIONS的部分了。</li>
<li>最后会看一下和这个资料有关的还有哪些东西可以使用。</li>
<li>某些说明内容还会列举有关的文件（FILES）来提供我们参考。</li>
</ol>
<p>man page 常用的按键：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>进行工作</th>
</tr>
</thead>
<tbody>
<tr>
<td>空格键</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>Page Down</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>Page Up</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>Home</td>
<td>去到第一页</td>
</tr>
<tr>
<td>End</td>
<td>在去到最后一页</td>
</tr>
<tr>
<td>/string</td>
<td>向下查询string字符串</td>
</tr>
<tr>
<td>?string</td>
<td>向上查询string字符串</td>
</tr>
<tr>
<td>n,N</td>
<td>利用/或？来查询字符串时，可以用n来继续查询下一个查询，可以利用N来进行反向查询</td>
</tr>
<tr>
<td>q</td>
<td>结束这次man page</td>
</tr>
</tbody>
</table>
<p>下面还有两个man的用途：</p>
<ol>
<li>man -f command （= whatis）：查询和command这个命令有关的说明文件</li>
<li>man -k data（= apropos）：查询包含data这个数据有关的文件</li>
</ol>
<h2 id="info-page"><a href="#info-page" class="headerlink" title="info page"></a>info page</h2><p>info与man的用途差不多，都是用来查询命令的用法或者文件的格式，但是与man page一下子输出一堆信息不同的是，info page则是将文件数据拆成一个一个段落，每个段落用自己的页面来撰写，并且在各个页面中还有类似网页的“超链接”来调到各个页面，每个独立的页面也被称为一个节点（node）。</p>
<p>这里这里不多说，有兴趣者可以自己去看看使用。</p>
<h2 id="其他有用的文件"><a href="#其他有用的文件" class="headerlink" title="其他有用的文件"></a>其他有用的文件</h2><p>一般而言，命令或者软件开发者都会将自己的命令或者是软件的说明制作成“在线帮助文件”，但是毕竟不是什么都需要做成在线帮助文件的，在/usr/share/doc中我们会发现会有很多说明文件文档，这些会告诉我们怎么做，以及一些相关的原理。</p>
<h1 id="开机与关机"><a href="#开机与关机" class="headerlink" title="开机与关机"></a>开机与关机</h1><h2 id="开机与登录"><a href="#开机与登录" class="headerlink" title="开机与登录"></a>开机与登录</h2><p>一般服务器都不怎么重启，我们在登录服务器的时候，基本上都是使用ssh来登录，我们可以使用下面的命令：</p>
<blockquote>
<p>ssh ip</p>
</blockquote>
<p>在这个命令之后会要求与你输入密码即可成功。</p>
<h2 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h2><p>在Linux中，由于每个程序都是在后台运行的，因此你看不到屏幕后面其实可能有很多人同时在你的主机上面工作，所以我们不能随意关机。所以在正常情况下，要关机时要注意下面几件事：</p>
<ol>
<li>查看系统的使用状态<ul>
<li>如果要看目前有谁在线：执行“who”这个命令</li>
<li>如果要看网络的联机状态：执行“netstat -a”这个命令</li>
<li>如果要看后台执行的程序：执行“ps -aux”这个命令</li>
</ul>
</li>
<li>通知在线用户关机的时刻</li>
<li>正确地关机命令使用：shutdown与reboot</li>
<li>将数据同步写入硬盘的命令：sync</li>
<li>惯用的关机命令：shutdown</li>
<li>重启、关机：reboot,halt,poweroff</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一章最为基础，灰常重要，就像地基，只有有了地基，我们才能好好造下面的房子。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：从浅入深，我们也从基础命令开始。学会基本命令的使用，学会怎么去查命令的使用，最后学会一丢丢维护（开关机）。&lt;br&gt;
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_Linux磁盘分区</title>
    <link href="http://bestlixiang.site/2018/03/21/%E8%B5%B0%E8%BF%9BLinux_Linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"/>
    <id>http://bestlixiang.site/2018/03/21/走进Linux_Linux磁盘分区/</id>
    <published>2018-03-21T05:49:21.000Z</published>
    <updated>2018-04-09T04:32:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：Linux在我印象中最大的特点就是它把所有的硬件都当做一个文件，然后还是以/为根节点的目录树，简洁明了，相信大家一定会爱上它的。因为涉及到文件的存储，所以我们要重视磁盘分区。<a id="more"></a></p>
<h1 id="硬件设备在linux中的文件名"><a href="#硬件设备在linux中的文件名" class="headerlink" title="硬件设备在linux中的文件名"></a>硬件设备在linux中的文件名</h1><p>Linux中每一个设备都被当成文件，所有的设备文件都在/dev这个目录下。下面列出几个常见设备与其在Linux当中的文件名，如下表：</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>设备在Linux内的文件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE硬盘</td>
<td>/dev/hd[a-d]</td>
</tr>
<tr>
<td>SATA/USB/SCSI硬盘</td>
<td>/dev/sd[a-p]</td>
</tr>
<tr>
<td>U盘</td>
<td>/dev/sd[a-p]（与SATA相同）</td>
</tr>
<tr>
<td>软驱</td>
<td>/dev/fd[0－1]</td>
</tr>
<tr>
<td>打印机</td>
<td>25针：/dev/lp[0－2] usb：/dev/usb/lp[0-15]</td>
</tr>
<tr>
<td>鼠标</td>
<td>usb:/dev/usb/mouse[0－15] ps2:/dev/psaux</td>
</tr>
<tr>
<td>当前CD/DVD ROM</td>
<td>/dev/cdrom</td>
</tr>
<tr>
<td>当前鼠标</td>
<td>/dev/mouse</td>
</tr>
<tr>
<td>磁带机</td>
<td>IDE:/dev/ht0 SCSI:/dev/st0</td>
</tr>
</tbody>
</table>
<h1 id="硬盘分区"><a href="#硬盘分区" class="headerlink" title="硬盘分区"></a>硬盘分区</h1><h2 id="磁盘的文件命名规则"><a href="#磁盘的文件命名规则" class="headerlink" title="磁盘的文件命名规则"></a>磁盘的文件命名规则</h2><p>磁盘的接口有两种，分别是IDE接口、SATA接口。目前主流的接口是SATA接口。<br>使用IDE接口的设备我们称为IDE设备。</p>
<ol>
<li>IDE设备：一个IDE接口可以连接两个IDE设备，主机中一般用两个IDE接口，因此最多可以连接四个IDE设备。这两个IDE接口通常被称为IDE1、IDE2，而每个IDE接口连接的两个IDE设备又被分为主设备和从设备。这四个IDE设备的文件名如下表：</li>
</ol>
<table>
<thead>
<tr>
<th>IDE接口</th>
<th>主设备</th>
<th>从设备</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE1</td>
<td>/dev/hda</td>
<td>/dev/hdb</td>
</tr>
<tr>
<td>IDE2</td>
<td>/dev/hdc</td>
<td>/dev/hdd</td>
</tr>
</tbody>
</table>
<ol>
<li>SATA设备：以SATA/USB/SCSI为接口的磁盘使用的都是SCSI模块来驱动的，因此他们的设备文件名都是/dev/sd[a-p]。但是与IDE设备不同的是，他们的文件名没有一定的顺序，谁先插上去，谁就是a，以此类推。</li>
</ol>
<h2 id="磁盘的组成"><a href="#磁盘的组成" class="headerlink" title="磁盘的组成"></a>磁盘的组成</h2><p>整个磁盘的第一个扇区非常重要，因为他记录了下面的重要的信息：</p>
<ol>
<li>主引导分区Master Boot Record,MBR：可以安装“引导加载程序”的地方。有446bytes。</li>
<li>分区表：记录整块硬盘的分区状况，有64bytes。</li>
</ol>
<h2 id="磁盘分区表"><a href="#磁盘分区表" class="headerlink" title="磁盘分区表"></a>磁盘分区表</h2><p>对磁盘进行分区时，采用柱面作为基本单位。分区表有64bytes，被分成四个区域，每个区域记录当前磁盘的所有分区的起始和结束柱面号。例如：一块IDE硬盘被分成四个区域： P1：/dev/hda1 ，P2：/dev/hda2 ，P3：/dev/hda3 ，P4：/dev/hda4。每个磁盘的分区表只能被分成四个区域，这四个区域被称为<strong>主分区或扩展分区</strong>。当系统进行数据的读写时，一定要参考分区表才能进行。</p>
<h3 id="分区的原因"><a href="#分区的原因" class="headerlink" title="分区的原因"></a>分区的原因</h3><p>保证数据的安全性（分区不会影响）；提升系统的性能（只在自己的分区查找）。</p>
<h3 id="扩展分区"><a href="#扩展分区" class="headerlink" title="扩展分区"></a>扩展分区</h3><p>主分区和扩展分区都是分区表中的一条记录，主分区中存放通过直接索引就能到达的分区的开始和结束的柱面号；而扩展分区中存放的是逻辑分区表的开始和结束柱面号，这张逻辑分区表中才存放分区的开始和结束柱面号。</p>
<p>由于一张分区表只能存放四条记录，也就是四个分区，当我们想要多一些分区的时候就必须要通过扩展分区来实现。 分区表中的四条记录对应的设备文件名是不会变的。如上面的四个名字，所以逻辑分区的文件名一定是从5开始的。如：/dev/hda5。</p>
<h3 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h3><ol>
<li>扩展分区最多只能有1个。</li>
<li>Linux中，IDE硬盘最多有59个逻辑分区，5号－63号；SATA硬盘最多有11个逻辑分区，5号－15号。</li>
<li>在Windows中若D、E盘都是扩展分区中的逻辑分区，那么他们可以整合成一个分区；若两个盘一个是逻辑分区，一个是主分区，那他们是不能合并的。</li>
<li>一块硬盘的第一个扇区记录了MBR和分区表，非常的重要，如果第一个扇区坏了，那么整个硬盘就报废了。</li>
</ol>
<h1 id="开机流程"><a href="#开机流程" class="headerlink" title="开机流程"></a>开机流程</h1><p>整个开机流程到操作系统之前的动作应该是这样的：</p>
<ol>
<li>BIOS：开机主动执行的韧体，会认识第一个可开机的对象。</li>
<li>MBR：第一个可开机设备的第一个扇区的主引导分区块，内包含引导加载程序。</li>
<li>引导加载程序：一支可读取内核文件来执行的软件。（可多个不同系统的加载程序对应了不同的操作系统）</li>
<li>内核文件：开始操作系统的功能。</li>
</ol>
<p>PS：为什么如果安装多重引导，最好先安装Windows在安装Linux？——因为Linux在安装的时候可以选择将引导加载程序安装在MBR或个别分区的启动扇区，而且在linnux的loader可以手动设置菜单，所以你可以在Linux的boot loader里面加入Windows开机的选项。Windows在安装的时候，它的安装程序会主动覆盖掉MBR以及自己所在分区的启动扇区，你没有选择的机会，而且没有让我们选择菜单的功能。</p>
<h1 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h1><h2 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h2><p>在Linux中，整个文件系统呈一棵以/为根目录的树。</p>
<h2 id="文件系统与目录树的关系（挂载）"><a href="#文件系统与目录树的关系（挂载）" class="headerlink" title="文件系统与目录树的关系（挂载）"></a>文件系统与目录树的关系（挂载）</h2><p><strong>挂载</strong>就是把一个目录当作磁盘中某一个分区的进入点，也就是说，进入了这个目录，就进入了这个磁盘的这个分区。这个进入的目录我们就称为挂载点。<br>根目录一定要挂载到某个分区。</p>
<p>如何寻找挂载点（判断某个在文件在哪个分区下）？答：通过反向追踪即可，当我们想要知道/home/rex/test文件在那个分区时，只要逆向寻找第一个挂载点就是这个文件的挂载点。 可以使用下面的命令：</p>
<blockquote>
<p>df /home/rex/test</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>了解分区，了解开机流程，了解挂载，ok，就这些！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：Linux在我印象中最大的特点就是它把所有的硬件都当做一个文件，然后还是以/为根节点的目录树，简洁明了，相信大家一定会爱上它的。因为涉及到文件的存储，所以我们要重视磁盘分区。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_初识Linux</title>
    <link href="http://bestlixiang.site/2018/03/20/%E8%B5%B0%E8%BF%9BLinux_%E5%88%9D%E8%AF%86Linux/"/>
    <id>http://bestlixiang.site/2018/03/20/走进Linux_初识Linux/</id>
    <published>2018-03-20T12:13:05.000Z</published>
    <updated>2018-04-09T04:31:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：了解Linux，学习Linux，深入Linux。<a id="more"></a></p>
<h1 id="Linux是什么"><a href="#Linux是什么" class="headerlink" title="Linux是什么"></a>Linux是什么</h1><p><strong>Linux就是一套操作系统，它的内核是Linux Torvalds在1991年开发出来的。</strong></p>
<h2 id="Linux的内核版本"><a href="#Linux的内核版本" class="headerlink" title="Linux的内核版本"></a>Linux的内核版本</h2><p>看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2.6.18-92.e15</div><div class="line">主版本.次版本.释出版本-修改版本</div></pre></td></tr></table></figure></p>
<ol>
<li>主、次版本为奇数：开发中版本，如2.5.xx，这种版本仅内核开发工程师使用。</li>
<li>主、次版本为偶数：稳定版本，如2.6.xx ，家庭、企业使用。</li>
</ol>
<p>我们可以通过下面的命令查看自己的linux的版本号：</p>
<pre><code>uname -r
</code></pre><h2 id="Linux发行版"><a href="#Linux发行版" class="headerlink" title="Linux发行版"></a>Linux发行版</h2><p>Linux其实就是Linux Kernel（内核）＋内核工具。他是GNU GPL授权模式，任何人都可以获取源代码并进行修改。因此Linux的全名是：GNU/Linux。<br>Linux ditribution是由各个商业公司开发，本质上是LinuxKernel＋内核工具＋软件，让普通用户都能使用的操作系统。 基本上Linux distributions并无太大区别，可以根据自己的喜好选择。他们的内核都是从www.kernel.org上下载的。</p>
<h2 id="Linux的特色"><a href="#Linux的特色" class="headerlink" title="Linux的特色"></a>Linux的特色</h2><ol>
<li>自由与开放的使用与学习环境</li>
<li>配置需求低廉</li>
<li>内核功能强大而稳定</li>
<li>独立作业</li>
</ol>
<h2 id="Linux优点"><a href="#Linux优点" class="headerlink" title="Linux优点"></a>Linux优点</h2><ol>
<li>稳定的系统</li>
<li>免费或少许费用</li>
<li>安全性、漏洞的快速修补</li>
<li>多任务、多用户</li>
<li>用户与用户组的规划</li>
<li>相对比较不耗资源的系统</li>
<li>整合度佳且多样的图形用户界面</li>
</ol>
<h2 id="Linux缺点"><a href="#Linux缺点" class="headerlink" title="Linux缺点"></a>Linux缺点</h2><ol>
<li>没有特定的支持产商</li>
<li>游戏的支持度不足</li>
<li>专业软件的支持度不足</li>
</ol>
<h1 id="Linux当前的角色"><a href="#Linux当前的角色" class="headerlink" title="Linux当前的角色"></a>Linux当前的角色</h1><h2 id="企业环境的应用"><a href="#企业环境的应用" class="headerlink" title="企业环境的应用"></a>企业环境的应用</h2><ol>
<li>网络服务器（当今最热门的运用）</li>
<li>关键任务的应用（金融数据库、大型企业）</li>
<li>学术机构的高性能运算任务</li>
</ol>
<h2 id="个人环境的使用"><a href="#个人环境的使用" class="headerlink" title="个人环境的使用"></a>个人环境的使用</h2><ol>
<li>桌面计算机(在Linux系统上装一个X Window System软件之后，就能有桌面了)</li>
<li>手持设备（PAD、手机）</li>
<li>嵌入式系统</li>
</ol>
<h1 id="Linux的学习路线"><a href="#Linux的学习路线" class="headerlink" title="Linux的学习路线"></a>Linux的学习路线</h1><ol>
<li>学习计算机概论及硬件相关知识</li>
<li>从Linux的安装开始学起</li>
<li>学会使用Linux的基本技能</li>
<li>学会vi编辑器</li>
<li>shell与shell脚本的学习</li>
<li>一定要会软件管理员</li>
<li>了解网络基础</li>
<li>使用Linux架设网站</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在使用Linux之前请学会Linux！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：了解Linux，学习Linux，深入Linux。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_计算机基础</title>
    <link href="http://bestlixiang.site/2018/03/20/%E8%B5%B0%E8%BF%9BLinux_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://bestlixiang.site/2018/03/20/走进Linux_计算机基础/</id>
    <published>2018-03-20T10:29:00.000Z</published>
    <updated>2018-04-09T04:33:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：我也算是从通信专业转到计算机的，所以当然对计算机专业课知识不太了解，所以也想简单掌握以下计算机基础知识。<a id="more"></a></p>
<p>计算机其实是：<strong>接收用户输入指令和数据，经过中央处理器的数据欲逻辑单元运算处理后，以产生或存储成有用的信息。</strong></p>
<h1 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h1><h2 id="计算机硬件的五大单元"><a href="#计算机硬件的五大单元" class="headerlink" title="计算机硬件的五大单元"></a>计算机硬件的五大单元</h2><ol>
<li>输入单元</li>
<li>输出单元</li>
<li>CPU内部的控制单元</li>
<li>CPU内部的算术逻辑单元</li>
<li>内存</li>
</ol>
<h2 id="CPU的种类"><a href="#CPU的种类" class="headerlink" title="CPU的种类"></a>CPU的种类</h2><p>CPU内部已经含有一些小指令集，我们所使用的软件都要经过CPU内部的微指令集来完成才行。这些指令集的设计主要被分为两种设计理念，如下：</p>
<ol>
<li><p>精简指令集（RISC）</p>
<p> 采用精简指令集的cpu的指令较为精简，每条指令的执行时间很短，完成的操作也很单纯，指令的执行性能较好；但是如果要做一些复杂的操作，则需要多个指令来协同完成。</p>
<p> 常见的精简指令集CPU有：</p>
<ul>
<li>sun公司的SPARC系列，常应用于学术领域的大型工作站</li>
<li>IBM公司的Power Architecture（包括Power PC），如索尼的PS3</li>
<li>IBM公司的ARM系列，常用于手机、pda、导航系统、网络设备等 （使用最广泛）</li>
</ul>
</li>
<li><p>复杂指令集（CISC）</p>
<p> 每一条指令较为复杂，因为执行的时间比较长，但是每条指令处理的工作较为丰富。</p>
<p> 常见的复杂指令集的CPU：AMD、Intel、VIA等x86架构的cpu。由于这些采用了复杂指令集的x86架构的cpu常常被用在个人计算机上，所以个人计算机常常就被称为x86计算机。x86架构的CPU最早由因特尔开发，并且它将CPU从8位提升为16位、32位。后来，AMD公司基于x86架构开发出了64位的CPU。所以64位CPUu的架构叫做x86_64，非64位cpu的架构仍然叫做x86。</p>
</li>
</ol>
<h2 id="接口设备"><a href="#接口设备" class="headerlink" title="接口设备"></a>接口设备</h2><ol>
<li>存储设备：包括硬盘，软盘等</li>
<li>显示设备：显卡等</li>
<li>网络设备：网卡等</li>
</ol>
<h2 id="计算机分类"><a href="#计算机分类" class="headerlink" title="计算机分类"></a>计算机分类</h2><ol>
<li>超级计算机：运算速度最快的计算机，主要是用于需要有高速计算的项目中。</li>
<li>大型计算机：功能上不及超级计算机，但也可以用来处理大量数据与复杂计算。</li>
<li>迷你计算机：主机可以放在一般场所，无需像大型计算机一样需要特殊的空调场所。</li>
<li>工作站：工作站的价格比迷你计算机便宜许多，。是针对特殊用途而设计的计算机。</li>
<li>微电脑：个人计算机（PC）。</li>
</ol>
<h2 id="计算机上面的常用的计算单位（大小、速度等）"><a href="#计算机上面的常用的计算单位（大小、速度等）" class="headerlink" title="计算机上面的常用的计算单位（大小、速度等）"></a>计算机上面的常用的计算单位（大小、速度等）</h2><ol>
<li>文件大小：1GB=1024*1024*1024Byte；1Byte=8bit</li>
<li>CPU运算速度：MHz或者GHz，Hz为秒分之一</li>
<li>网络传输：Mbit/s或者MB/s，注意bit还是Byte</li>
</ol>
<h1 id="个人计算机架构与接口设备"><a href="#个人计算机架构与接口设备" class="headerlink" title="个人计算机架构与接口设备"></a>个人计算机架构与接口设备</h1><p>在计算机主板上的芯片组通常又分为两个桥接器来控制各组件的通信：</p>
<ul>
<li>北桥负责连接速度较快的CPU、内存与显卡等组件。北桥的总线称为系统总线。因为是内存传输的主要通道，所以速度快。</li>
<li>南桥负责链接速度较慢的周边接口，包括硬盘、USB、网卡等。南桥的总线称为输入输出(I/O)总线。</li>
</ul>
<p>AMD和Intel的芯片组架构最主要的区别是AMD的内存是直接与CPU通信而不通过北桥。</p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="外频与内屏"><a href="#外频与内屏" class="headerlink" title="外频与内屏"></a>外频与内屏</h3><ol>
<li>外频：CPU与外部组件进行数据传输/运算时的速度。</li>
<li>倍频：CPU内部用来加速工作性能的一个倍速，两者相乘才是cpu 的频率。</li>
</ol>
<h3 id="32位与64位"><a href="#32位与64位" class="headerlink" title="32位与64位"></a>32位与64位</h3><ol>
<li>北桥所支持的频率称为前端总线速（FSB）度，而每次传送的位数则是总线宽度，所谓总线频宽则是“FSB*总线宽度”，业技术每秒钟可以传送的最大数据量。</li>
<li>CPU每次能处理的数据量称为字组大小(word size)，字组大小依据cpu的设计有32／64位。我们现在称计算机是32／64位是根据CPU解析的字组大小来的。</li>
</ol>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>我们平时所说的内存的全名叫做动态随机访问存储器（DRAM）。DRAM是一种挥发性内存，只有它通电的时候才能被使用，断电数据就消失。DRAM分为：</p>
<ol>
<li>SDRAM</li>
<li>DDR SDRAM，DDR=Double Data Rate 所以他的传输速度比SDRAM要快。</li>
</ol>
<p>对服务器而言，内存的容量比CPU的速度更加重要。CPU与内存的外频应该相同才好。</p>
<h3 id="双通道设计"><a href="#双通道设计" class="headerlink" title="双通道设计"></a>双通道设计</h3><p>总线宽度一般是64位，也就是每次总线从内存中读写64位数据，若在主板上插两根内存条，那么总线宽度就达到128位，从而提升了内存的读写速度。在主板上插两根内存条的设计就叫做双通道设计。<br>但是要启动双通道功能，安插的两根内存条必须型号一样，大小一样，这样才能整体上提升内存的读写速度。</p>
<h3 id="DRAM与SRAM"><a href="#DRAM与SRAM" class="headerlink" title="DRAM与SRAM"></a>DRAM与SRAM</h3><p>DRAM就是我们平时所说的内存，它的全称叫做动态随机访问存储器。而SRAM的全程叫做静态随机访问存储器。SRAM可以用在很多不同的地方，而CPU中的第二层高速缓存就是选择SRAM作为存储器。由于L2 Cache集成在CPU内部，CPU读取数据无需再经过北桥从内存中获取，直接从L2 Cache中获取，从而能提升性能。</p>
<h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><p>显卡又叫做VGA（Video Graphics Array）。图形影响的显示质量的好坏重点在于分辨率和色彩深度。<br>由于显示的每一个像素都会占用内存，因此显卡上面也有个存储器，而这个存储器的大小直接影响显示的效果。早期时候3D的运算是交给CPU去处理的，为了减少CPU的负担，所以在显卡上设置一个处理器，这个处理器就是GPU。</p>
<p>PS: 如果你的主机是用来打3D游戏，那么显卡的选购非常重要，如果你的主机是用来作为网络服务器，那么简单的入门级显卡对你的主机来说就非常够用了。</p>
<h2 id="硬盘与存储设备"><a href="#硬盘与存储设备" class="headerlink" title="硬盘与存储设备"></a>硬盘与存储设备</h2><p>计算机系统上的存储设备包括硬盘、软盘、U盘等，我们主要介绍硬盘：</p>
<ol>
<li>硬盘主要是由许多的盘片、机械手臂、磁头与主轴马达所组成。实际的数据都是写在具有磁性物质的盘片上，硬盘运行时，主轴马达让盘片转动，机械手臂可以伸缩，让读取头在盘片上面进行读写操作。</li>
<li>硬盘的最小存储单位是扇区，每个扇区的大小是512bytes，这个值是不可改变的。扇区组成的环叫做磁道。上下的所有磁道构成柱面。柱面是分割硬盘的最小单位。一般硬盘制造商杂显示硬盘容量时，大多是以十进制来编号，所有500GB的硬盘，理论上仅会有460GB左右的容量。</li>
<li>传输接口主要有以下几种：<ul>
<li>IDE接口：每秒传输可达133MB。</li>
<li>SATA接口：SATA－1每秒传输150MB，SATA－2每秒传输300MB，目前个人计算机都已使用SATA。</li>
<li>SCSI接口：这个接口含有一个处理器，硬盘的读写操作由这个处理器完成，从而提升计算机整体性能。</li>
</ul>
</li>
</ol>
<p>PS：硬盘很脆弱，千万别让它摔了还是怎样，血的教训。</p>
<h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><p>主板可以说是整台主机相当重要的地方，因为重要的组件都是安插在主板上面的，而主板上面负责通信各个组件的就是芯片组。下面说说主板我们常用的东西：</p>
<ol>
<li>CMOS与BIOS：CMOS主要的功能是记录主板上面的重要参数，如系统时间等。BIOS为写入到主板上某一块闪存或EEPROM的程序，它可以在开机的时候执行，已加载CMOS当中的参数，并尝试调用存储设备中的开机程序，进一步进入操作系统当中。</li>
<li>连接接口设备：主板与各项输出/输入设备的链接主要都是在主机箱的后方，如USB接口RJ-45接口等。</li>
</ol>
<h1 id="计算机编码"><a href="#计算机编码" class="headerlink" title="计算机编码"></a>计算机编码</h1><ol>
<li>常用的英文编码表是ASKII，每个字符占1B，因此总共有2的8次方种变化。</li>
<li>中文编码表常用gb2312，每个字符占2B，定义了一万三千多个字。但是，这个编码表对于数据库存储有问题，从数据库读出数据的时候有些字会被读错。</li>
<li>为了解决上面的问题，出现了Unicode编码表，就是UTF-8。</li>
</ol>
<h1 id="软件程序运行"><a href="#软件程序运行" class="headerlink" title="软件程序运行"></a>软件程序运行</h1><p>一般来说目前的计算机系统将软件分为两大类：一是系统软件（内核），一个是应用程序（日常所说的软件）。</p>
<h2 id="机器程序与编译程序"><a href="#机器程序与编译程序" class="headerlink" title="机器程序与编译程序"></a>机器程序与编译程序</h2><ol>
<li>机器程序：都是机器码，可以直接给机器识别。</li>
<li>编译程序：能够将高级语言编译成机器程序。</li>
</ol>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>先看看操作系统的角色，从底层到高层：硬件-&gt;内核-&gt;系统调用-&gt;应用程序。其中内核以及系统调用被称为操作系统。</p>
<ol>
<li>操作系统内核：操作系统其实也是一组程序，这组程序的重点在于管理计算机的所有活动以及驱动系统的所有硬件。</li>
<li>系统调用：操作系统提供的一组开发接口。</li>
<li>内核功能：<ul>
<li>系统调用接口</li>
<li>程序管理</li>
<li>内存管理</li>
<li>文件系统管理</li>
<li>设备驱动</li>
</ul>
</li>
<li>操作系统与驱动程序：操作系统通常会提供一个开发接口给硬件商，让他们可以根据这个接口色合计可以驱动他们硬件的驱动程序。</li>
</ol>
<h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><p>应用程序是参考操作系统提供的开发接口所开发出来的软件，这些软件可以让用户操作，以达到某些计算机的功能利用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>了解好计算机的基础知道，我们对计算机里面的硬件以及程序的实现有了一个大概的了解，有利于我们学习下面的知识。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：我也算是从通信专业转到计算机的，所以当然对计算机专业课知识不太了解，所以也想简单掌握以下计算机基础知识。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——桥梁模式</title>
    <link href="http://bestlixiang.site/2018/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/19/设计模式之禅——桥梁模式/</id>
    <published>2018-03-19T01:32:24.000Z</published>
    <updated>2018-03-19T01:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：不变的部分用继承来实现，变得部分放在外部，并通过<strong>桥梁模式</strong>抽象耦合进来，这样就解决了继承的弊端。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>桥梁模式也叫做桥接模式，其定义如下：</p>
<p><strong>将抽象和实现解耦，使得两者可以独立变化。——结构类</strong></p>
<p>下面是桥梁模式的通用类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/bridge.png" alt="bridge"></p>
<p>我们看看桥梁模式类图中的4个角色：</p>
<ol>
<li>Abstraction抽象化角色：主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。</li>
<li>Implementor实现化角色：定义角色必须的行为和属性。</li>
<li>RefinedAbstraction修正抽象化角色：它引用实现化角色对抽象化角色进行修正。</li>
<li>ConcreteImplementor具体实现化角色：实现接口或抽象类定义的方法和属性。</li>
</ol>
<p>它的通用源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</div><div class="line">    <span class="comment">// 基本方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体实现化角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementor1</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementor2</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象化角色</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义对实现化角色的引用</span></div><div class="line">    <span class="keyword">private</span> Implementor imp;</div><div class="line">    <span class="comment">// 约束子类必须实现该构造函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Abstraction</span><span class="params">(Implementor _imp)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.imp = _imp;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 自身的行为和属性</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.imp.doSomething();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 获得实现化角色</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Implementor <span class="title">getImp</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> imp;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体抽象化角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</div><div class="line">    <span class="comment">// 覆写构造函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor _imp)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(_imp);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 修正父类的行为</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.request();</div><div class="line">        <span class="keyword">super</span>.getImp().doAnything();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 定义一个实现化角色</span></div><div class="line">        Implementor imp = <span class="keyword">new</span> ConcreteImplementor1();</div><div class="line">        <span class="comment">// 定义一个抽象化角色</span></div><div class="line">        Abstraction abs = <span class="keyword">new</span> RefinedAbstraction(imp);</div><div class="line">        <span class="comment">// 执行</span></div><div class="line">        abs.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>抽象和实现分离。</li>
<li>优秀的扩充能力。</li>
<li>实现细节对客户透明。</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>不希望或不合适使用继承的场景。</li>
<li>接口或抽象类不稳定的场景。</li>
<li>重用性要求较高的场景。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>使用桥梁模式主要考虑如何拆分抽象和实现。桥梁模式的意图还是对变化的封装，尽量把可能变化的因素封装到最细、最小的逻辑单元，避免风险扩散。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>继承非常好，但是有缺点。我们可以扬长避短，对于比较明确不发生变化的，则通过继承来完成；若不能确定是否会发生变化的，那就认为会发生变化，则通过桥梁模式来搭建一个桥梁将变化的的东西放在外部和本体进行连接。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：不变的部分用继承来实现，变得部分放在外部，并通过&lt;strong&gt;桥梁模式&lt;/strong&gt;抽象耦合进来，这样就解决了继承的弊端。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——享元模式</title>
    <link href="http://bestlixiang.site/2018/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/03/18/设计模式之禅——享元模式/</id>
    <published>2018-03-18T12:03:02.000Z</published>
    <updated>2018-03-18T12:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：对象多了，而且还都是处于有用状态，那一定会出现内存溢出的问题，我们可以通过<strong>享元模式</strong>来实现对象的复用，以达到减少的目的，从而解决内存溢出的问题。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>享元模式是<strong>池技术</strong>的重要实现方式，其定义如下：</p>
<p><strong>使用”共享对象”可有效地支持大量的”细粒度的对象”。——结构类</strong></p>
<p>享元模式的定义为我们提出了两个要求：细粒度对象和共享对象。我们知道分配太多的对象到应用程序中将有损程序的性能，同时还容易造成内存溢出，那怎么避免呢？就是享元模式提到的共享技术。我们先来了解一下对象的内部状态和外部状态：</p>
<ul>
<li>内部状态：内部状态是对象可共享出来的信息，存储在享元对象并且不会随环境改变而改变，不必存储在具体某个对象中，属于可以共享的部分。</li>
<li>外部状态：外部状态是对象得以依赖的一个标记，是随环境改变而改变的，不可以共享的状态，他是一批对象的统一标识，是唯一的索引值。</li>
</ul>
<p>下面是享元模式的通用类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/flyweight.png" alt="flyweight"></p>
<p>简单介绍类图中的角色：</p>
<ol>
<li>Flyweight抽象享元角色：产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现。</li>
<li>ConcreteFlyWeight具体享元角色：具体的一个产品类，实现抽象角色定义的业务。该角色中需要注意的是内部状态处理应该与环境无关，不应该出现一个操作改变了内部状态，同时修改了外部状态，这是绝对不允许的。</li>
<li>UnsharedConcreteFlyWeight不可共享的享元角色：不存在外部状态或者安全要求（如线程安全）不能够使用共享技术的对象，该对象一般不会出现享元工厂中。（有点不太理解）</li>
<li>FlyWeightFactory享元工厂：职责非常简单，就是构造一个池容器，同时提供从池中获取对象的方法。</li>
</ol>
<p>享元模式的目的在于运用共享技术，使得一些细粒度的对象可以共享，多使用细粒度的对象，便于重构或重用，下面是它的通用代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  抽象享元角色</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span> </span>&#123;</div><div class="line">    <span class="comment">// 内部状态</span></div><div class="line">    <span class="keyword">private</span> String intrinsic;</div><div class="line">    <span class="comment">// 外部状态 注意final</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String extrinsic;</div><div class="line">    <span class="comment">// 要求享元角色必须接受外部状态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Flyweight</span><span class="params">(String _extrinsic)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.extrinsic = _extrinsic;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 定义业务操作</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> vid <span class="title">operate</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 内部状态的getter/setter</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIntrinsic</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> intrinsic;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntrinsic</span><span class="params">(String intrinsic)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.intrinsic = intrinsic;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体享元角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight1</span> <span class="keyword">extends</span> <span class="title">Flyweight</span> </span>&#123;</div><div class="line">    <span class="comment">// 接受外部状态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight1</span><span class="params">(String _extrinsic)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(_extrinsic)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 根据外部状态进行逻辑处理</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight2</span> <span class="keyword">extends</span> <span class="title">Flyweight</span> </span>&#123;</div><div class="line">    <span class="comment">// 接受外部状态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight2</span><span class="params">(String _extrinsic)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(_extrinsic)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 根据外部状态进行逻辑处理</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 享元工厂</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义一个池容器</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String,Flyweight&gt; pool = <span class="keyword">new</span> HashMap&lt;String,Flyweight&gt;();</div><div class="line">    <span class="comment">// 享元工厂</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String extrinsic)</span> </span>&#123;</div><div class="line">        <span class="comment">// 需要返回的对象</span></div><div class="line">        Flyweight flyweight = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 在池中没有该对象</span></div><div class="line">        <span class="keyword">if</span>(pool.containKey(extrinsic)) &#123;</div><div class="line">            flyweight = pool.get(extrinsic);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 根据外部状态创建享元对象</span></div><div class="line">            flyweight = <span class="keyword">new</span> ConcreteFlyweight1(extrinsic);</div><div class="line">            <span class="comment">// 放置到池中</span></div><div class="line">            pool.put(extrinsic,flyweight);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> flyweight;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>可以大大减少应用程序创建的对象，降低程序内存的占用，增强程序对的性能。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>提高了系统的复杂性，需要分离出外部状态和内部状态，而且外部状态具有固化特性（加fianl关键字），不应该随内部改变而改变，否则导致系统的逻辑混乱。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>系统中存在大量的相似对象。</li>
<li>细粒度的对象都具有较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</li>
<li>需要缓冲池的场景。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>当对象池的对象太少时，会出现线程不安全的现象。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>享元模式在Java API中也是随处可见的，比如String类的intern方法就是利用了String的对象池。当然对象池主要解决复用，而享元模式主要解决对象的共享问题，如果建立多个可共享的细粒度对象是其关注的重点。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：对象多了，而且还都是处于有用状态，那一定会出现内存溢出的问题，我们可以通过&lt;strong&gt;享元模式&lt;/strong&gt;来实现对象的复用，以达到减少的目的，从而解决内存溢出的问题。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
