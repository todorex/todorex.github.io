<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rex note</title>
  <subtitle>雨过，云过</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bestlixiang.site/"/>
  <updated>2018-12-26T10:16:24.213Z</updated>
  <id>http://bestlixiang.site/</id>
  
  <author>
    <name>rex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Raft算法</title>
    <link href="http://bestlixiang.site/2018/12/26/%E5%88%86%E5%B8%83%E5%BC%8F/Raft%E7%AE%97%E6%B3%95/"/>
    <id>http://bestlixiang.site/2018/12/26/分布式/Raft算法/</id>
    <published>2018-12-26T13:14:13.000Z</published>
    <updated>2018-12-26T10:16:24.213Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="分布式" scheme="http://bestlixiang.site/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Raft" scheme="http://bestlixiang.site/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>Paxos算法</title>
    <link href="http://bestlixiang.site/2018/12/26/%E5%88%86%E5%B8%83%E5%BC%8F/Paxos%E7%AE%97%E6%B3%95/"/>
    <id>http://bestlixiang.site/2018/12/26/分布式/Paxos算法/</id>
    <published>2018-12-26T10:14:13.000Z</published>
    <updated>2018-12-26T10:17:51.929Z</updated>
    
    <content type="html"><![CDATA[<p>引：占坑！！！！ Paxos算法在分布式领域具有非常重要的地位。Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。自己理解得还不透彻，所以留下链接，待后续加深理解之后再做整理。<a id="more"></a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>倪超. 从 Paxos 到 ZooKeeper : 分布式一致性原理与实践 [M]. 电子工业出版社, 2015.</li>
<li><a href="https://angus.nyc/2012/paxos-by-example/" target="_blank" rel="external">Paxos By Example</a></li>
<li><a href="https://www.cnblogs.com/linbingdong/p/6253479.html" target="_blank" rel="external">分布式系列文章——Paxos算法原理与推导</a></li>
<li><a href="https://github.com/luohaha/MyPaxos" target="_blank" rel="external">MyPaxos</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：占坑！！！！ Paxos算法在分布式领域具有非常重要的地位。Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。自己理解得还不透彻，所以留下链接，待后续加深理解之后再做整理。
    
    </summary>
    
      <category term="分布式" scheme="http://bestlixiang.site/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Paxos" scheme="http://bestlixiang.site/tags/Paxos/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统基础</title>
    <link href="http://bestlixiang.site/2018/12/26/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <id>http://bestlixiang.site/2018/12/26/分布式/分布式系统基础/</id>
    <published>2018-12-26T02:25:37.000Z</published>
    <updated>2018-12-26T06:08:14.367Z</updated>
    
    <content type="html"><![CDATA[<p>引：自己这一段时间都在学习分布式系统相关的东西，但是都不成系统，所以这里将会总结目前学习的分布式系统相关内容，这里讲会总结分布式系统的相关概念，持续更新…。<a id="more"></a></p>
<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p>2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。</p>
<p>CAP理论为：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p>
<p>下面举个例子：</p>
<p>假设有两台机器A、B，两者之间互相同步保持数据的一致性。现在B由于网络原因不能与A通信(Network Partition)，假设某个client向A写入数据，现在有两种选择：</p>
<ul>
<li>A拒绝写入，这样能保证与B的一致性，但是牺牲了可用性</li>
<li>A允许写入，但是这样就不能保证与B的一致性了</li>
</ul>
<p>Network Partition是必然的，网络非常可能出现问题（断线、超时），因此CAP理论一般只能AP或CP，而CA一般较难实现。</p>
<ul>
<li>CP: 要实现一致性，则需要一定的一致性算法，一般是基于多数派表决的，如Paxos和Raft</li>
<li>AP: 要实现可用性，则要有一定的策略决议到底用哪个数据，并且数据一般要进行冗余备份(replication)</li>
</ul>
<p>当然，在上面的例子中，A可以先允许写入，等B的网络恢复以后再同步至B（根据CAP原理这样不能保证强一致性了，但是可以考虑实现<strong>最终一致性</strong>）。</p>
<p>下图刚好展示了CA,CP,AP系统是如何实现的：</p>
<p><img src="http://book.mixu.net/distsys/images/CAP.png" alt="CAP"></p>
<ul>
<li>利用2PC协议属于CA，如，mysql等，他们主要通过复制的方式来保证数据的安全性。</li>
<li>利用Gossip协议属于AP，如，redis-cluster、cassandra，Eureka他们是通过实现“最终一致性”来保证AP。</li>
<li>利用Paxos协议属于CP，如redis（多master），hbase，这些数据库集群，节点有可能会因为无法确保数据的一致性而拒绝提供服务。</li>
</ul>
<h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><p>BASE理论是由eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。</p>
<p>BASE理论为：基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。</p>
<h2 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h2><p>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</p>
<p>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</p>
<h2 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h2><p>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。</p>
<p>分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。</p>
<h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p>
<h2 id="ACID和BASE的区别与联系"><a href="#ACID和BASE的区别与联系" class="headerlink" title="ACID和BASE的区别与联系"></a>ACID和BASE的区别与联系</h2><p>ACID是传统数据库常用的设计理念，追求<strong>强一致性模型</strong>。</p>
<p>BASE支持的是大型分布式系统，牺牲掉对一致性的约束（但实现<strong>最终一致性</strong>），来换取一定的可用性。</p>
<p>ACID和BASE代表了两种截然相反的设计哲学。</p>
<p>在英文中，ACID和BASE分别是“酸”和“碱”，看似对立，实则是分别对CAP三特性的不同取舍。在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此ACID和BASE又会结合使用。</p>
<h1 id="FLP-Impossibility"><a href="#FLP-Impossibility" class="headerlink" title="FLP Impossibility"></a>FLP Impossibility</h1><h1 id="Lease机制"><a href="#Lease机制" class="headerlink" title="Lease机制"></a>Lease机制</h1><h1 id="Quorum机制"><a href="#Quorum机制" class="headerlink" title="Quorum机制"></a>Quorum机制</h1><h1 id="Consensus问题"><a href="#Consensus问题" class="headerlink" title="Consensus问题"></a>Consensus问题</h1><h1 id="时序问题"><a href="#时序问题" class="headerlink" title="时序问题"></a>时序问题</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.sczyh30.com/posts/Distributed-System/distributed-system-base/#%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98" target="_blank" rel="external">分布式系统基础总结</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/35608244" target="_blank" rel="external">分布式系统中的FLP不可能原理、CAP理论与BASE理论</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：自己这一段时间都在学习分布式系统相关的东西，但是都不成系统，所以这里将会总结目前学习的分布式系统相关内容，这里讲会总结分布式系统的相关概念，持续更新…。
    
    </summary>
    
      <category term="分布式" scheme="http://bestlixiang.site/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://bestlixiang.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mac版百度网盘飞速下载</title>
    <link href="http://bestlixiang.site/2018/10/31/%E5%B7%A5%E5%85%B7/Mac%E7%89%88%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E9%A3%9E%E9%80%9F%E4%B8%8B%E8%BD%BD/"/>
    <id>http://bestlixiang.site/2018/10/31/工具/Mac版百度网盘飞速下载/</id>
    <published>2018-10-31T00:17:46.000Z</published>
    <updated>2018-10-31T00:21:36.636Z</updated>
    
    <content type="html"><![CDATA[<p>引：百度网盘上有很多资源，之前在Mac上一直没有找到好的加速方法或者破解软件，这次终于找到了，请速速戳进来！！<a id="more"></a></p>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/proxyee-down-org/proxyee-down" target="_blank" rel="external">Proxyee Down</a></p>
<p>Proxyee Down 是一款开源的免费 HTTP 高速下载器，底层使用<code>netty</code>开发，支持自定义 HTTP 请求下载且支持扩展功能，可以通过安装扩展实现特殊的下载需求。</p>
<h1 id="最近视频教程"><a href="#最近视频教程" class="headerlink" title="最近视频教程"></a>最近视频教程</h1><p>以后也可能就不新了！！</p>
<p><a href="https://www.youtube.com/watch?v=ecZqKGaKIck" target="_blank" rel="external">快快保存，2018最新百度云不限制方法proxyee down-2018.9.19，亲测速度达10M</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：百度网盘上有很多资源，之前在Mac上一直没有找到好的加速方法或者破解软件，这次终于找到了，请速速戳进来！！
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JDK源码分析——ReentrantReadWriteLock</title>
    <link href="http://bestlixiang.site/2018/09/13/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ReentrantReadWriteLock/"/>
    <id>http://bestlixiang.site/2018/09/13/JDK源码分析/JDK源码分析——ReentrantReadWriteLock/</id>
    <published>2018-09-13T06:51:39.000Z</published>
    <updated>2018-09-13T10:15:06.003Z</updated>
    
    <content type="html"><![CDATA[<p>引：读写分离是解决并发瓶颈的常用策略，在Java中也有其实现——ReentrantReadWriteLock，它能够有效的提高读比写多的场景下的程序性能。<a id="more"></a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>ReentrantReadWriteLock是通过两把锁实现读写分离的，分别是读锁和写锁。它的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 读锁</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</div><div class="line">    <span class="comment">// 写锁</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</div><div class="line">    <span class="comment">// 同步器</span></div><div class="line">    <span class="keyword">final</span> Sync sync;</div></pre></td></tr></table></figure></p>
<h1 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h1><p>写锁主要是通过重写同步器的tryAcquire和tryRelease实现，其他逻辑都可以参考AQS的解析。</p>
<h2 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Sync</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</div><div class="line"><span class="comment">// 重入最大次数</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</div><div class="line"><span class="comment">// 独占锁（写锁）掩码</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line"></div><div class="line">    Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="comment">// 用 state &amp; 65535 得到低 16 位的值</span></div><div class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</div><div class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></div><div class="line">        <span class="comment">// 如果 state 不是0，且低16位是0，说明写锁是空闲的，读锁被霸占了。那么也不能拿锁，返回 fasle。保证了读的时候不能写。</span></div><div class="line">        <span class="comment">// 如果低 16 位不是0，说明写锁被霸占了，此时如果持有锁的不是当前线程，那么这次拿锁是失败的。返回 fasle。</span></div><div class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="comment">// 这里时候应该是写重入锁，如果写重入次数超过最大值 65535，就会溢出</span></div><div class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        <span class="comment">// Reentrant acquire</span></div><div class="line">        setState(c + acquires);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// writerShouldBlock 判断是否应该阻塞</span></div><div class="line">    <span class="comment">// 1. 公平锁情况下，如果队列中有等待锁的线程，则返回ture，应该阻塞</span></div><div class="line">    <span class="comment">// 2. 非公平锁情况下，返回false，不应该阻塞，直接参与竞争</span></div><div class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</div><div class="line">        !compareAndSetState(c, c + acquires))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 竞争到锁，设置独占线程</span></div><div class="line">    setExclusiveOwnerThread(current);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="comment">// 是否持有锁</span></div><div class="line">    <span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    <span class="comment">// 设置state状态</span></div><div class="line">    <span class="keyword">int</span> nextc = getState() - releases;</div><div class="line">    <span class="comment">// 计算写锁的状态（低16位），如果是0，说明是否成功</span></div><div class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (free)</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">    setState(nextc);</div><div class="line">    <span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h1><p>写锁主要是通过重写同步器的tryAcquireShared和tryReleaseShared实现，其他逻辑都可以参考AQS的解析。</p>
<h2 id="tryAcquireShared"><a href="#tryAcquireShared" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Sync</span></div><div class="line"><span class="comment">// 共享（读锁）重入次数基数</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</div><div class="line"><span class="comment">// 第一个获得读锁的线程</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</div><div class="line"><span class="comment">// 第一个获得读锁的线程的重入次数计数器</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</div><div class="line"><span class="comment">// 最后一个获取读锁的线程的计数器，存放在ThreadLocal中</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</div><div class="line"></div><div class="line">    Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="comment">// 用 state &amp; 65535 得到低 16 位的值 不等于0，写锁被霸占了</span></div><div class="line">    <span class="comment">// 且</span></div><div class="line">    <span class="comment">// 持有锁的不是当前线程</span></div><div class="line">    <span class="comment">// 保证了写的时候不能读</span></div><div class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</div><div class="line">        getExclusiveOwnerThread() != current)</div><div class="line">        <span class="comment">// 获取锁失败</span></div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="comment">// 如果写锁没有被霸占，则将高16位移到低16位</span></div><div class="line">    <span class="keyword">int</span> r = sharedCount(c);</div><div class="line">    <span class="comment">// readerShouldBlock判断是否应该阻塞 和写锁逻辑一致</span></div><div class="line">    <span class="comment">// 写锁重入次数不超过最大值 65535</span></div><div class="line">    <span class="comment">// 设置state成功 (相当于高16位加1)</span></div><div class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</div><div class="line">        r &lt; MAX_COUNT &amp;&amp;</div><div class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</div><div class="line">        <span class="comment">// 读锁空闲</span></div><div class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</div><div class="line">            firstReader = current;</div><div class="line">            <span class="comment">// 计数器为1</span></div><div class="line">            firstReaderHoldCount = <span class="number">1</span>;</div><div class="line">            <span class="comment">// 第一个读线程是当前线程</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</div><div class="line">            <span class="comment">// 计数器加1</span></div><div class="line">            firstReaderHoldCount++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            HoldCounter rh = cachedHoldCounter;</div><div class="line">            <span class="comment">// 如果最后一个线程计数器是 null 或者不是当前线程</span></div><div class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</div><div class="line">                <span class="comment">// 新建一个 HoldCounter 对象</span></div><div class="line">                cachedHoldCounter = rh = readHolds.get();</div><div class="line">            <span class="comment">// 如果不是 null，且 count 是 0</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</div><div class="line">                <span class="comment">// 就将上个线程的 HoldCounter 覆盖本地的（性能考虑，相当于缓存）</span></div><div class="line">                readHolds.set(rh);</div><div class="line">            <span class="comment">// 计数器加1</span></div><div class="line">            rh.count++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获得锁成功</span></div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 死循环获取读锁，和tryReleaseShared逻辑类似，只有多了死循环</span></div><div class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>在tryAcquireShared还体现了锁降级的概念。概念如下：</p>
<p><strong><br>重入还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不可能的。</strong></p>
<p>体现在代码中如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tryAcquireShared 或者 fullTryAcquireShared中</span></div><div class="line"><span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div></pre></td></tr></table></figure></p>
<p>上面的代码就体现出：当写锁被持有的时候，如果当前是线程是持有写锁的那个线程，可以继续获得读锁。</p>
<p>总得来说就提高了性能。</p>
<h2 id="tryReleaseShared"><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当前线程重入次数计数器</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</div><div class="line">    Thread current = Thread.currentThread();</div><div class="line">    <span class="comment">// 如果是第一个线程</span></div><div class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</div><div class="line">        <span class="comment">// 如果是 1，将第一个线程设置成 null</span></div><div class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</div><div class="line">            firstReader = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 如果不是 1，减一操作</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            firstReaderHoldCount--;</div><div class="line">    <span class="comment">// 如果不是当前线程</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        HoldCounter rh = cachedHoldCounter;</div><div class="line">        <span class="comment">// 如果最后一个线程计数器是 null 或者缓存所属线程不是当前线程</span></div><div class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</div><div class="line">            <span class="comment">// 获取当前线程的计数器</span></div><div class="line">            rh = readHolds.get();</div><div class="line">        <span class="keyword">int</span> count = rh.count;</div><div class="line">        <span class="comment">// 如果计数器小于等于一，就直接删除计数器</span></div><div class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</div><div class="line">            readHolds.remove();</div><div class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</div><div class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 对计数器减一</span></div><div class="line">        --rh.count;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 死循环使用 CAS 修改状态</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = getState();</div><div class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">            <span class="comment">// 修改成功后，如果是 0，表示读锁和写锁都空闲，则可以唤醒后面的等待线程</span></div><div class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于读写锁，它其实就是一个读锁一个写锁，读锁是共享的，写锁是独占的。然后我们再理解锁降级的相关概念就行了，当然这一切都是需要建立在读AQS的理解之上。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://todorex.com/2018/09/11/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94AbstractQueuedSynchronizer/" target="_blank" rel="external">JDK源码分析——AbstractQueuedSynchronizer</a></li>
<li><a href="https://www.jianshu.com/p/6221746fc777" target="_blank" rel="external">并发编程之——写锁源码分析</a></li>
<li><a href="https://www.jianshu.com/p/cd485e16456e" target="_blank" rel="external">并发编程之——读锁源码分析(解释关于锁降级的争议)</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：读写分离是解决并发瓶颈的常用策略，在Java中也有其实现——ReentrantReadWriteLock，它能够有效的提高读比写多的场景下的程序性能。
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="锁" scheme="http://bestlixiang.site/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析——ReentrantLock</title>
    <link href="http://bestlixiang.site/2018/09/13/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ReentrantLock/"/>
    <id>http://bestlixiang.site/2018/09/13/JDK源码分析/JDK源码分析——ReentrantLock/</id>
    <published>2018-09-13T02:13:39.000Z</published>
    <updated>2018-09-13T06:15:42.266Z</updated>
    
    <content type="html"><![CDATA[<p>引：虽然有了synchronized这种内置的锁功能，但是在JDK5之后又新增了Lock接口，它的实现类可比内置的锁强大多了。今天我们主要看看它的实现类之一ReentrantLock。<a id="more"></a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>在看之前，我们一定要对AbstractQueuedSynchronizer熟悉，不熟悉的可以参考我这篇文章——<a href="http://todorex.com/2018/09/11/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94AbstractQueuedSynchronizer/" target="_blank" rel="external">JDK源码分析——AbstractQueuedSynchronizer</a></p>
<p>我们先看看他的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="comment">// 同步器(可选择公平同步器或者非公平同步器)</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</div><div class="line"></div><div class="line">    <span class="comment">// 默认非公平锁</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</div><div class="line">        sync = <span class="keyword">new</span> NonfairSync();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// fair为true时，采用公平锁策略</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;    </div><div class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">        sync.lock();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;    </div><div class="line">        sync.release(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同步器抽象类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 非公平的TryAcquire</span></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">        <span class="keyword">int</span> c = getState();</div><div class="line">        <span class="comment">// 为0，则可获得锁，进行CAS操作设置state，并设置当前线程为独占线程</span></div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">                setExclusiveOwnerThread(current);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 重入锁的体现</span></div><div class="line">        <span class="comment">// 如果当前线程为独占线程，则可重入</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">            <span class="comment">// 重入次数增加</span></div><div class="line">            <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">            setState(nextc);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获取失败</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 释放锁</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">        <span class="comment">// 截取释放次数</span></div><div class="line">        <span class="keyword">int</span> c = getState() - releases;</div><div class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">// 重入次数要减到0，才是真正得释放了锁</span></div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">            free = <span class="keyword">true</span>;</div><div class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">        setState(c);</div><div class="line">        <span class="keyword">return</span> free;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 维护了一个条件队列</span></div><div class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h1><p>公平锁是指如果同步器的队列中有线程在等待，后来的线程则直接加入到队列中<br>公平同步器实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">// AQS分析逻辑</span></div><div class="line">      acquire(<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 公平实现</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">      <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">      <span class="keyword">int</span> c = getState();</div><div class="line">      <span class="comment">// 可获得锁</span></div><div class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">          <span class="comment">// 如果同步器的队列中没有线程在等待 或者 CAS成功 或者设置独占线程成功</span></div><div class="line">          <span class="comment">// 公平的体现</span></div><div class="line">          <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">              compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">              setExclusiveOwnerThread(current);</div><div class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 可重入</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">          <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">          <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">          setState(nextc);</div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h1><p>非公平锁是指后来的线程也有同样的优先级。</p>
<p>非公平同步器实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 利用CAS把state从0设置为1</span></div><div class="line">        <span class="comment">// 成功则获得锁</span></div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">            setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="comment">// 进入AQS分析逻辑</span></div><div class="line">            acquire(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="comment">// 非公平获取</span></div><div class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="条件变量Condition"><a href="#条件变量Condition" class="headerlink" title="条件变量Condition"></a>条件变量Condition</h1><p>Synchronized中，所有的线程都在同一个object的条件队列上等待。而ReentrantLock中，每个condition都维护了一个条件队列。我们先看看在同步器定义的ConditionObject对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="comment">// 条件队列的头节点</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</div><div class="line">    <span class="comment">// 条件队列的尾节点</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们关注它的两个核心方法(条件变量Condition为了解决Object.wait/notify/notifyAll难以使用的问题)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>阻塞线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="comment">// 如果线程被中断，则抛出异常</span></div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">    <span class="comment">// 1. 将线程添加到条件等待队列</span></div><div class="line">    Node node = addConditionWaiter();</div><div class="line">    <span class="comment">// 2. 释放持有的锁</span></div><div class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</div><div class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 是否在AQS的同步队列中</span></div><div class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">        <span class="comment">// 3. 不是则挂起该线程</span></div><div class="line">        LockSupport.park(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 4. 被唤醒后，通过acquireQueued方法重新竞争锁，参考AQS</span></div><div class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">        interruptMode = REINTERRUPT;</div><div class="line">    <span class="comment">// 清理取消节点</span></div><div class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</div><div class="line">        unlinkCancelledWaiters();</div><div class="line">    <span class="comment">// 报告中断信息</span></div><div class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</div><div class="line">        reportInterruptAfterWait(interruptMode);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 1. 将线程添加到条件等待队列</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node t = lastWaiter;</div><div class="line">    <span class="comment">// 如果最后一个节点是取消状态</span></div><div class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</div><div class="line">        <span class="comment">// 从队列删除取消节点</span></div><div class="line">        unlinkCancelledWaiters();</div><div class="line">        t = lastWaiter;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 线程包装成节点</span></div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</div><div class="line">        firstWaiter = node;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        t.nextWaiter = node;</div><div class="line">    lastWaiter = node;</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 释放持有的锁</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">// 标记是否失败，失败则将节点设为取消状态</span></div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> savedState = getState();</div><div class="line">        <span class="comment">// release可以参考AQS的解析</span></div><div class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</div><div class="line">            failed = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">return</span> savedState;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            node.waitStatus = Node.CANCELLED;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h2><p>唤醒线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 当前线程是否持有锁</span></div><div class="line">    <span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    Node first = firstWaiter;</div><div class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</div><div class="line">        doSignal(first);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</div><div class="line">            lastWaiter = <span class="keyword">null</span>;</div><div class="line">        first.nextWaiter = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 找到底部个非取消节点，遇到取消节点就进行删除</span></div><div class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</div><div class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将状态设置为0，不行就取消该节点</span></div><div class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 将节点放入到同步队列中</span></div><div class="line">    Node p = enq(node);</div><div class="line">    <span class="keyword">int</span> ws = p.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</div><div class="line">        <span class="comment">// 唤醒线程</span></div><div class="line">        LockSupport.unpark(node.thread);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ReetrantLock还提供了其它功能，包括定时的锁等待、可中断的锁等待、公平性、以及实现非块结构的加锁、Condition，对线程的等待和唤醒等操作更加灵活。但是内置锁（Synchronized）与ReentrantLock相比有例外一个优点就是在线程转储中能给出在哪些调用帧中获得了哪些锁，并能够检测和识别发生死锁的线程。因为Reentrant的非块状特性意味着获取锁的操作不能与特定的栈帧关联起来。相比之下内置锁是JVM的内置属性，所以未来更可能提升synchronized而不是ReentrantLock的性能，而照目前的趋势来看确实如此。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://todorex.com/2018/09/11/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94AbstractQueuedSynchronizer/" target="_blank" rel="external">JDK源码分析——AbstractQueuedSynchronizer</a></li>
<li><a href="https://www.jianshu.com/p/4358b1466ec9" target="_blank" rel="external">深入浅出ReentrantLock</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：虽然有了synchronized这种内置的锁功能，但是在JDK5之后又新增了Lock接口，它的实现类可比内置的锁强大多了。今天我们主要看看它的实现类之一ReentrantLock。
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="锁" scheme="http://bestlixiang.site/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析——AbstractQueuedSynchronizer</title>
    <link href="http://bestlixiang.site/2018/09/11/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94AbstractQueuedSynchronizer/"/>
    <id>http://bestlixiang.site/2018/09/11/JDK源码分析/JDK源码分析——AbstractQueuedSynchronizer/</id>
    <published>2018-09-11T01:16:36.000Z</published>
    <updated>2018-09-13T02:42:29.110Z</updated>
    
    <content type="html"><![CDATA[<p>引：java.util.concurrent.locks包中有很多Lock的实现类，内部实现都依赖AbstractQueuedSynchronizer（AQS）类，今天我们就看看AQS如何完成代码块的并发访问控制。<a id="more"></a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>抽象队列同步器AQS是用来构建锁或其他同步组件的基础框架，内部使用一个int成员变量state表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，其中内部同步状态state，等待队列的头节点head和尾节点head，都是通过volatile修饰，保证了多线程之间的可见，同时这些状态上的操作都用通过CAS操作来保持同步。</p>
<p>核心成员变量如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 等待队列头节点，懒加载</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</div><div class="line"><span class="comment">// 等待队列尾节点，懒加载</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</div><div class="line"><span class="comment">// 同步状态</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div></pre></td></tr></table></figure></p>
<p>整个AQS的示意图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com//juc/aqs.png" alt="aqs"></p>
<h1 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h1><p>上面说到AQS是通过内置的队列(LH lock实现，不懂的在后面参考中找到解释)来完成同步的，我们就先看看队列的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  *      +------+  prev +-----+       +-----+</div><div class="line">  * head |      | &lt;---- |     | &lt;---- |     |  tail</div><div class="line">  *      +------+       +-----+       +-----+</div><div class="line">  */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">    <span class="comment">// 标记表示节点正在共享模式中等待</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</div><div class="line">    <span class="comment">// 标记表示节点正在独占模式下等待</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// waitStatus值表示线程取消</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</div><div class="line">    <span class="comment">// waitStatus值表示当前线程的后继线程需要被唤醒</span></div><div class="line">    <span class="comment">// 一般发生情况是：当前线程的后继线程处于阻塞状态，而当前线程被release或cancel</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</div><div class="line">    <span class="comment">// waitStatus值表示线程等待Condition唤醒</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</div><div class="line">    <span class="comment">// waitStatus值表示下一个acquireShared应该无条件传播,都获得共享锁</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</div><div class="line">    <span class="comment">// 表示节点状态值，SIGNAL，CANCELLED，CONDITION，PROPAGATE，0</span></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</div><div class="line">    <span class="comment">// 前驱节点</span></div><div class="line">    <span class="keyword">volatile</span> Node prev;</div><div class="line">    <span class="comment">// 后继节点</span></div><div class="line">    <span class="keyword">volatile</span> Node next;</div><div class="line">    <span class="comment">// 对应线程</span></div><div class="line">    <span class="keyword">volatile</span> Thread thread;</div><div class="line">    <span class="comment">// 资源共享方式：SHARED、独占模式</span></div><div class="line">    Node nextWaiter;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>不同的自定义同步器(后面会挑几种进行源码分析)争用共享资源的方式也不同。自定义同步器在实现时只需要<strong>实现共享资源state的获取与释放方式</strong>即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 该线程是否正在独占资源。只有用到condition才需要去实现它</span></div><div class="line">isHeldExclusively();</div><div class="line"><span class="comment">// 独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></div><div class="line">tryAcquire(<span class="keyword">int</span> arg);</div><div class="line"><span class="comment">// 独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></div><div class="line">tryRelease(<span class="keyword">int</span> arg);</div><div class="line"><span class="comment">// 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源</span></div><div class="line">tryAcquireShared(<span class="keyword">int</span> arg);</div><div class="line"><span class="comment">// 共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></div><div class="line">tryReleaseShared(<span class="keyword">int</span> arg)</div></pre></td></tr></table></figure>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。下面我将分别对独占锁的管理流程 acquire-release 和 共享锁管理流程 acquireShared-releaseShare 进行分析。</p>
<h1 id="acquire-release"><a href="#acquire-release" class="headerlink" title="acquire-release"></a>acquire-release</h1><h2 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h2><p>acquire方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。它将被Lock接口的lock方法调用。源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 1. 当前线程通过tryAcquire()尝试获取锁。获取成功的话，直接返回；尝试失败的话，进入到等待队列排序等待。</span></div><div class="line"><span class="comment">// 交由自定义同步器去实现，主要是设置同步State，获取成功返回true，失败返回false</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2. 当前线程在尝试失败的情况下，先通过addWaiter(Node.EXCLUSIVE)来将当前线程加入到CLH队列末尾。</span></div><div class="line"><span class="comment">// 根据当前线程和模式创建节点并入队</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">    <span class="comment">// 根据当前线程和模式创建节点</span></div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line">    <span class="comment">// tail节点不为空，尝试快速方式直接放到队尾</span></div><div class="line">    Node pred = tail;</div><div class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</div><div class="line">        node.prev = pred;</div><div class="line">        <span class="comment">// 利用Unsafe的CAS操作，下面将不再提</span></div><div class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class="line">            pred.next = node;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// tail节点为空，调用enq方法</span></div><div class="line">    enq(node);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 将节点入队，如果有必要初始化队列</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">// CAS自旋，直到成功加入队尾</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node t = tail;</div><div class="line">        <span class="comment">// 末端节点为空</span></div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></div><div class="line">            <span class="comment">// 创建头节点，并利用CAS操作设置头节点</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</div><div class="line">                <span class="comment">// 将尾节点指针也指向头节点</span></div><div class="line">                tail = head;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 正常入队</span></div><div class="line">            node.prev = t;</div><div class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</div><div class="line">                t.next = node;</div><div class="line">                <span class="keyword">return</span> t;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 3. 当前线程执行完addWaiter(Node.EXCLUSIVE)之后，调用acquireQueued()来获取锁，因为这个时候可能前面的线程已经释放了锁。</span></div><div class="line"><span class="comment">// 如果当前线程获取到了锁，则返回；否则，当前线程被挂起，直到唤醒并重新获取锁了才返回。</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="comment">//标记是否成功拿到资源</span></div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//标记等待过程中是否被中断过</span></div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">// 自旋</span></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="comment">// 拿到前驱节点</span></div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="comment">// 如果前驱节点是head节点 并且 获取锁成功</span></div><div class="line">            <span class="comment">// 这里涉及到锁的公平性问题，体现了非公平性</span></div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                <span class="comment">// 将当前节点设置为head节点</span></div><div class="line">                <span class="comment">// head所指的结点，就是当前获取到锁的那个结点或null(初始化时)</span></div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="comment">// 返回等待过程中是否被中断过</span></div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果上面的条件不成立，则挂起当前线程，等待被唤醒或者中断</span></div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// 如果获取锁出错，则设置为取消状态</span></div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在获取锁失败之后检查和更新节点的状态，返回当前线程是否应该阻塞(被唤醒)</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">// 拿到前驱节点的等待状态</span></div><div class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">    <span class="comment">// 等待状态为SIGNAL（-1）</span></div><div class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">// 等待状态为CANCELLED(1)</span></div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 往前找到最近有效的节点</span></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">        pred.next = node;</div><div class="line">    <span class="comment">// 等待状态为其他情况</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 将状态设置为SIGNAL</span></div><div class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 4. 当前线程在执行acquireQueued()时，会进入到CLH队列中休眠等待，直到获取锁了才返回！</span></div><div class="line"><span class="comment">// 阻塞并检查是否中断，直到当前线程被唤醒才从parkAndCheckInterrupt()中返回</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="comment">// 返回中断状态，并清除中断标志，中断并不会取消锁，如果中断会再次被阻塞</span></div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 5. 如果当前线程在休眠等待过程中被中断过，acquireQueued会返回true，此时当前线程会调用selfInterrupt()来自己给自己产生一个中断。</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 记录中断标志</span></div><div class="line">    Thread.currentThread().interrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="release"><a href="#release" class="headerlink" title="release"></a>release</h2><p>release方法是独占模式线程释放资源的入口。它将被Lock接口的release方法调用。源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">        <span class="comment">// 找到头节点</span></div><div class="line">        Node h = head;</div><div class="line">        <span class="comment">// 头节点不为空 且 头节点等待状态不为0</span></div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">            <span class="comment">// 唤醒等待队列的下一个线程</span></div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1. 当前线程通过tryRelease(arg)尝试释放锁，成功则返回true，失败则返回false。</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2. 当前线程释放锁成功后，唤醒等待队列的下一个线程</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取当前线程状态</span></div><div class="line">    <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">    <span class="comment">// 如果状态 &lt; 0，则设置状态为0</span></div><div class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line">    Node s = node.next;</div><div class="line">    <span class="comment">// 节点为空 或者 waitStatus &gt; 0 ，从最后开始向前寻找，找到waitStatus小于等于0的节点</span></div><div class="line">    <span class="comment">// 涉及到了弱一致性的问题（next指针在有个短暂瞬间不一定存在）</span></div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">        s = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                s = t;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 唤醒后继节点对应的线程</span></div><div class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">        LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="acquireShared-releaseShare"><a href="#acquireShared-releaseShare" class="headerlink" title="acquireShared-releaseShare"></a>acquireShared-releaseShare</h1><h2 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h2><p>acquireShared(int arg)是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">        doAcquireShared(arg);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 1. 当前线程通过tryAcquireShared(int arg)尝试获取锁，负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取</span></div><div class="line"><span class="comment">// 交由自定义同步器去实现，主要是设置同步State</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 当前线程通过doAcquireShared(int arg)将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="comment">// 加入队列尾部</span></div><div class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</div><div class="line">    <span class="comment">// 标记是否成功</span></div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 标记是否被中断</span></div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">// 自旋</span></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="comment">// 拿到前驱节点</span></div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="comment">// 此时node节点被唤醒</span></div><div class="line">            <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                <span class="comment">// 尝试获得资源</span></div><div class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</div><div class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">//将head指向自己，还有剩余资源可以再唤醒之后的线程</span></div><div class="line">                    setHeadAndPropagate(node, r);</div><div class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                    <span class="comment">// 如果等待过程中被中断过，记录中断标记</span></div><div class="line">                    <span class="keyword">if</span> (interrupted)</div><div class="line">                        selfInterrupt();</div><div class="line">                    failed = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 与独占模式类似</span></div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将head指针指向自己</span></div><div class="line">    Node h = head;</div><div class="line">    setHead(node);</div><div class="line">    <span class="comment">// 唤醒后继节点</span></div><div class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</div><div class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</div><div class="line">        Node s = node.next;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</div><div class="line">            <span class="comment">// 关注这里</span></div><div class="line">            doReleaseShared();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="releaseShare"><a href="#releaseShare" class="headerlink" title="releaseShare"></a>releaseShare</h2><p>doReleaseShared()是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">        doReleaseShared();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 1. 当前线程通过tryReleaseShared(int arg)尝试释放锁，成功返回true，失败返回false</span></div><div class="line"><span class="comment">// 交由自定义同步器去实现，主要是设置同步State</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 当前线程通过doReleaseShared()唤醒后继节点</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</div><div class="line">            <span class="keyword">int</span> ws = h.waitStatus;</div><div class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</div><div class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                <span class="comment">// 唤醒线程</span></div><div class="line">                unparkSuccessor(h);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</div><div class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</div><div class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>知道了AQS的原理，锁的原理应该也就不难了。这次我们再一次见到CAS的威力。当然这次有些还是有一点迷惑，后面有机会再来补充！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnblogs.com/yuyutianxia/p/4296220.html" target="_blank" rel="external">CLH锁 、MCS锁</a></li>
<li><a href="https://www.cnblogs.com/2015110615L/p/6754529.html" target="_blank" rel="external">Java多线程：AQS源码分析</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：java.util.concurrent.locks包中有很多Lock的实现类，内部实现都依赖AbstractQueuedSynchronizer（AQS）类，今天我们就看看AQS如何完成代码块的并发访问控制。
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="锁" scheme="http://bestlixiang.site/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析——ThreadPoolExecutor</title>
    <link href="http://bestlixiang.site/2018/09/07/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ThreadPoolExecutor/"/>
    <id>http://bestlixiang.site/2018/09/07/JDK源码分析/JDK源码分析——ThreadPoolExecutor/</id>
    <published>2018-09-07T13:23:15.000Z</published>
    <updated>2018-09-08T09:44:01.053Z</updated>
    
    <content type="html"><![CDATA[<p>引：相信大家已经收到了Executor框架以及线程池带来的好处，它有着神奇的能力，那我们来看看它是怎么实现这种神奇的能力的！<a id="more"></a></p>
<p>详细注释：<a href="https://github.com/todorex/JDK" target="_blank" rel="external">源码分析地址</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>用过的人应该都很熟悉了，不过还想回顾一下的还是可以看看自己之前看《Java并发实战编程》总结的几章笔记：</p>
<ol>
<li><a href="http://todorex.com/2018/01/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/Java%E5%B9%B6%E5%8F%91-5-%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/" target="_blank" rel="external">Java并发<em>5</em>任务执行</a></li>
<li><a href="http://todorex.com/2018/01/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/Java%E5%B9%B6%E5%8F%91-7-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">Java并发<em>7</em>线程池的使用</a></li>
</ol>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>JDK自带的哪几种线程池类型，就不多展示了，这里我们来看看自定义线程池。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,<span class="number">20</span>, <span class="number">0</span>, TimeUnit.MILLISECONDS</div><div class="line">                ,<span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">1024</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            executorService.execute(<span class="keyword">new</span> MyTask());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Thread ID："</span> + Thread.currentThread().getId());</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Thread ID：10</div><div class="line">Thread ID：12</div><div class="line">Thread ID：11</div><div class="line">Thread ID：14</div><div class="line">Thread ID：13</div><div class="line">Thread ID：10</div><div class="line">Thread ID：11</div><div class="line">Thread ID：12</div><div class="line">Thread ID：14</div><div class="line">Thread ID：13</div></pre></td></tr></table></figure></p>
<p>结合设置的参数，大家是不是隐隐发现了什么？模糊的请往下看。</p>
<h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>我们主要还是记住这7个参数的含义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 保障线程池运行的最少的线程数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</div><div class="line"><span class="comment">// 最大线程数，它收到CAPACITY((2^29)-1)的限制</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</div><div class="line"><span class="comment">// 当线程总数超多corePoolSize时，如果线程空闲超过这个时间(结合unit时间单位)，将被回收</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</div><div class="line"><span class="comment">// 当线程池来不及执行任务时，会将任务暂时放在队列中，等待后续处理</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</div><div class="line"><span class="comment">// 线程工厂</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</div><div class="line"><span class="comment">// 当线程池饱和或者优雅关闭的时候调用</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                          <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                          <span class="keyword">long</span> keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory,</div><div class="line">                          RejectedExecutionHandler handler) &#123;</div><div class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</div><div class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</div><div class="line">    <span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">    <span class="keyword">this</span>.handler = handler;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h1><p>最为一个Executor，execute是他最核心的方法，我们看看它是如何实现的？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * ctl（线程池控制状态）包含了两个概念</div><div class="line"> * 1. workerCount：代表有效的线程数</div><div class="line"> * 2. runState：代表了运行状态</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</div><div class="line"><span class="comment">// 保存工作线程</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 主要有下面三个步骤:</div><div class="line">     *</div><div class="line">     * 1. 判断当前的线程数是否小于corePoolSize</div><div class="line">     *    如果是，使用传进来的任务通过addWord方法创建一个新线程，如果能完成新线程创建exexute方法结束，成功提交任务</div><div class="line">     *</div><div class="line">     * 2. 在第一步没有完成任务提交；状态为运行并且能否成功加入任务到工作队列后，再进行一次check</div><div class="line">     * 如果状态在任务加入队列后变为了非运行（有可能是在执行到这里线程池shutdown了），非运行状态下当然是需要reject；然后再判断当前线程数是否为0（有可能这个时候线程数变为了0），如是，新增一个线程；</div><div class="line">     *</div><div class="line">     * 3. 如果不能加入任务到工作队列，将尝试使用任务新增一个线程</div><div class="line">     * 如果失败，则是线程池已经shutdown或者线程池已经达到饱和状态，所以reject这个他任务</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line">    <span class="comment">// 实际线程数小于核心线程数</span></div><div class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">        <span class="comment">// 增加一个线程</span></div><div class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="comment">// 更新线程池状态</span></div><div class="line">        c = ctl.get();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 当线程池处于运行状态 且 添加进队列成功</span></div><div class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        <span class="comment">// 再次对线程池状态检查</span></div><div class="line">        <span class="keyword">int</span> recheck = ctl.get();</div><div class="line">        <span class="comment">// 线程池状态不是运行状态，且从队列删除该任务成功</span></div><div class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            <span class="comment">// 拒绝任务</span></div><div class="line">            reject(command);</div><div class="line">        <span class="comment">// 如果当前工作线程数量为0（线程池已关闭）</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">            <span class="comment">// 添加一个 null 到队列中</span></div><div class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果添加队列失败，则创建一个任务线程</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</div><div class="line">        <span class="comment">// 如果失败（饱和），则拒绝</span></div><div class="line">        reject(command);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 新增线程</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</div><div class="line">    <span class="comment">// Java标签</span></div><div class="line">    retry:</div><div class="line">    <span class="comment">// 死循环</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="comment">// 获取当前线程池状态</span></div><div class="line">        <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">        <span class="comment">// Check if queue empty only if necessary.</span></div><div class="line">        <span class="comment">// 下面的逻辑可以改为这样</span></div><div class="line">        <span class="comment">// rs &gt;= shutdown &amp;&amp; (rs != shutdown || firstTask != null || workQueue.isEmpty())</span></div><div class="line">        <span class="comment">// 表示下面这几种情况均不接受新任务</span></div><div class="line">        <span class="comment">// 1. rs &gt; shutdown</span></div><div class="line">        <span class="comment">// 2. rs &gt;= shutdown &amp;&amp; firstTask != null</span></div><div class="line">        <span class="comment">// 3. rs &gt;= shutdown &amp;&amp; workQueue.isEmppty</span></div><div class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">            ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</div><div class="line">               ! workQueue.isEmpty()))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="comment">// 获取线程池中线程数量</span></div><div class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line">            <span class="comment">// 如果超出容量或者超出核心线程数或最大线程数(由core决定)</span></div><div class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</div><div class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="comment">// 线程安全增加工作线程数</span></div><div class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</div><div class="line">                <span class="comment">// / 跳出retry</span></div><div class="line">                <span class="keyword">break</span> retry;</div><div class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></div><div class="line">            <span class="comment">// 如果线程池状态发生变化，重新循环</span></div><div class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</div><div class="line">                <span class="keyword">continue</span> retry;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 线程添加成功</span></div><div class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</div><div class="line">    Worker w = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// Worker代理了任务对象，可以看其构造方法</span></div><div class="line">        w = <span class="keyword">new</span> Worker(firstTask);</div><div class="line">        <span class="keyword">final</span> Thread t = w.thread;</div><div class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">            mainLock.lock();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 拿到线程池状态</span></div><div class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</div><div class="line">                <span class="comment">// RUNNING状态 || SHUTDONW状态下清理队列中剩余的任务</span></div><div class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</div><div class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</div><div class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line">                    <span class="comment">// 将新创建的线程放进线程Set里</span></div><div class="line">                    workers.add(w);</div><div class="line">                    <span class="comment">// 更新线程池线程数且不超过最大值</span></div><div class="line">                    <span class="keyword">int</span> s = workers.size();</div><div class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</div><div class="line">                        largestPoolSize = s;</div><div class="line">                    workerAdded = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                mainLock.unlock();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 启动新添加的线程，这个线程首先执行firstTask，然后不停的从队列中取任务执行</span></div><div class="line">            <span class="keyword">if</span> (workerAdded) &#123;</div><div class="line">                <span class="comment">// 在下一节worker中分析</span></div><div class="line">                t.start();</div><div class="line">                workerStarted = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// 线程启动失败，则从wokers中移除w并递减wokerCount</span></div><div class="line">        <span class="keyword">if</span> (! workerStarted)</div><div class="line">            <span class="comment">// 递减wokerCount会触发tryTerminate方法</span></div><div class="line">            addWorkerFailed(w);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> workerStarted;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h1><p>worker对象代理了任务，我们看看它的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 代理任务执行的线程</span></div><div class="line"><span class="keyword">final</span> Thread thread;</div><div class="line"><span class="comment">// 第一个任务</span></div><div class="line">Runnable firstTask;</div><div class="line">Worker(Runnable firstTask) &#123;</div><div class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></div><div class="line">    <span class="keyword">this</span>.firstTask = firstTask;</div><div class="line">    <span class="comment">// 这里就用到我们在例子中的传入的工厂（注意是这个this，将worker自己作为一个Runnabel）</span></div><div class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DefaultThreadFactory</span></div><div class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">    <span class="comment">// 创建一个线程，后面就是线程名了，在构造工厂的时候就确定了</span></div><div class="line">    Thread t = <span class="keyword">new</span> Thread(group, r,</div><div class="line">                          namePrefix + threadNumber.getAndIncrement(),</div><div class="line">                          <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (t.isDaemon())</div><div class="line">        t.setDaemon(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</div><div class="line">        t.setPriority(Thread.NORM_PRIORITY);</div><div class="line">    <span class="keyword">return</span> t;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// work执行任务</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 这个方法太核心，单独拿出来</span></div><div class="line">    runWorker(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h1><p>主要的工作就是第一次启动会执行初始化传进来的任务firstTask；然后会循环从workQueue中取任务执行，如果队列为空则等待keepAliveTime这么长时间。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</div><div class="line">    Thread wt = Thread.currentThread();</div><div class="line">    <span class="comment">// 拿到firstTask</span></div><div class="line">    Runnable task = w.firstTask;</div><div class="line">    <span class="comment">// 等待gc</span></div><div class="line">    w.firstTask = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 允许中断</span></div><div class="line">    w.unlock(); <span class="comment">// allow interrupts</span></div><div class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// task不为空 或 队列不为空 关注getTask方法解析</span></div><div class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask方法解析()) != <span class="keyword">null</span>) &#123;</div><div class="line">            w.lock();</div><div class="line">            <span class="comment">// 中断处理</span></div><div class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                 (Thread.interrupted() &amp;&amp;</div><div class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                !wt.isInterrupted())</div><div class="line">                wt.interrupt();</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 执行前钩子</span></div><div class="line">                beforeExecute(wt, task);</div><div class="line">                Throwable thrown = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// 调用任务的run方法</span></div><div class="line">                    task.run();</div><div class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    <span class="comment">// 执行后钩子</span></div><div class="line">                    afterExecute(task, thrown);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="comment">// 等待gc</span></div><div class="line">                task = <span class="keyword">null</span>;</div><div class="line">                w.completedTasks++;</div><div class="line">                w.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        completedAbruptly = <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// Worker的善后，从线程池中移除超时或者出现异常的线程</span></div><div class="line">        processWorkerExit(w, completedAbruptly);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 取任务，这里关注超时问题以及keepAliveTime起作用的代码段</span></div><div class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 超时标志位</span></div><div class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="comment">// 获取线程池状态</span></div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">        <span class="comment">// Check if queue empty only if necessary.</span></div><div class="line">        <span class="comment">// 有下面两种情况成立</span></div><div class="line">        <span class="comment">// 1. rs &gt; SHUTDOWN 所以rs至少等于STOP,这时不再处理队列中的任务</span></div><div class="line">        <span class="comment">// 2. rs = SHUTDOWN 所以rs&gt;=STOP肯定不成立，这时还需要处理队列中的任务除非队列为空</span></div><div class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">            <span class="comment">// 介绍之前，递减workerCount值</span></div><div class="line">            decrementWorkerCount();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line"></div><div class="line">        <span class="comment">// 标记从队列中取任务时是否设置超时时间</span></div><div class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line"></div><div class="line">        <span class="comment">// 1. 如果运行线程数超过了最大线程数，但是缓存队列已经空了，这时递减worker数量</span></div><div class="line">        <span class="comment">// 2. 如果设置有核心线程有超时时间要求或者线程数远大于核心线程数 且 缓存队列已经空了这时递减worker数量</span></div><div class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</div><div class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 没有设置核心线程有超时时间要求或者线程数远小于核心线程数就take，否则就带keepAliveTime得poll</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Runnable r = timed ?</div><div class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                workQueue.take();</div><div class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> r;</div><div class="line">            <span class="comment">// 超时</span></div><div class="line">            timedOut = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</div><div class="line">            <span class="comment">// 线程被中断重试</span></div><div class="line">            timedOut = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="submit"><a href="#submit" class="headerlink" title="submit"></a>submit</h1><p>当我们对于线程执行不需要返回结果时，直接调用线程的execute方法来提交任务就好了。然而很多时候我们需要线程执行的返回结果，这个时候就需要调用submit方法来提交任务。虽然它最后也会调用到execute方法，但是他们具体不同在哪里，我们来看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// submit方法来自于AbstractExecutorService</span></div><div class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</div><div class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="comment">// 将task进行了封装</span></div><div class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</div><div class="line">    <span class="comment">// 剩下的就一样了</span></div><div class="line">    execute(ftask);</div><div class="line">    <span class="keyword">return</span> ftask;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AbstractExecutorService</span></div><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将Runnable封装成FutureTask</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// FutureTask</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将Runnable封装成callable</span></div><div class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</div><div class="line">    <span class="comment">// 确保callable的可见性</span></div><div class="line">    <span class="keyword">this</span>.state = NEW;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 根据前面的execute方法的分析，我们知道最后的执行会调用到FutureTask的run方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 状态不为NEW或者UNSAFE不成功，则运行失败</span></div><div class="line">    <span class="keyword">if</span> (state != NEW ||</div><div class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</div><div class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 最终又调用到了FutureTask保证的Callable对象</span></div><div class="line">        Callable&lt;V&gt; c = callable;</div><div class="line">        <span class="comment">// callable不为空且状态为NEW</span></div><div class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</div><div class="line">            V result;</div><div class="line">            <span class="keyword">boolean</span> ran;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 得到返回值</span></div><div class="line">                result = c.call();</div><div class="line">                ran = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">                result = <span class="keyword">null</span>;</div><div class="line">                ran = <span class="keyword">false</span>;</div><div class="line">                <span class="comment">// 如果有异常，设置异常</span></div><div class="line">                setException(ex);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (ran)</div><div class="line">                <span class="comment">// 设置返回值，</span></div><div class="line">                set(result);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        runner = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">int</span> s = state;</div><div class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</div><div class="line">            handlePossibleCancellationInterrupt(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</div><div class="line">    <span class="comment">// 设置返回值，也将状态NEW变为COMPLETING</span></div><div class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</div><div class="line">        outcome = v;</div><div class="line">        <span class="comment">// 完成之后将状态设置为NORMAl</span></div><div class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></div><div class="line">        <span class="comment">// 进行变量清理工作</span></div><div class="line">        finishCompletion();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在我们submit之后会得到一个Future，我们要想到返回值，我们只要调用get方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">    <span class="comment">// 拿到状态</span></div><div class="line">    <span class="keyword">int</span> s = state;</div><div class="line">    <span class="comment">// 未完成，则阻塞等待完成，这里可以设置超时时间</span></div><div class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</div><div class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</div><div class="line">    <span class="comment">// 还需要根据状态判断是否返回值</span></div><div class="line">    <span class="keyword">return</span> report(s);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</div><div class="line">    Object x = outcome;</div><div class="line">    <span class="comment">// 如果状态为NORMAL，则返回值</span></div><div class="line">    <span class="keyword">if</span> (s == NORMAL)</div><div class="line">        <span class="keyword">return</span> (V)x;</div><div class="line">    <span class="comment">// 如果状态为CACELLED，则代表任务呗取消，抛出异常</span></div><div class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里基本就覆盖了运行时的过程，我们就可以很好得理解我们，当任务未完成的时候，会发生阻塞等待的情况。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面我们基本知道了线程池的实现原理。然后就是运用这些原理对线程池进行调优了。这里关键还是调整哪些构造时的参数。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://todorex.com/2018/01/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/Java%E5%B9%B6%E5%8F%91-5-%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/" target="_blank" rel="external">Java并发<em>5</em>任务执行</a></li>
<li><a href="http://todorex.com/2018/01/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/Java%E5%B9%B6%E5%8F%91-7-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">Java并发<em>7</em>线程池的使用</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：相信大家已经收到了Executor框架以及线程池带来的好处，它有着神奇的能力，那我们来看看它是怎么实现这种神奇的能力的！
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="http://bestlixiang.site/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析——ThreadLocal</title>
    <link href="http://bestlixiang.site/2018/09/07/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ThreadLocal/"/>
    <id>http://bestlixiang.site/2018/09/07/JDK源码分析/JDK源码分析——ThreadLocal/</id>
    <published>2018-09-07T02:18:38.000Z</published>
    <updated>2018-09-07T13:25:37.434Z</updated>
    
    <content type="html"><![CDATA[<p>引：可能大家对ThreadLocal这个类既熟悉又陌生，看到得多用到得少。<a id="more"></a></p>
<p>详细注释：<a href="https://github.com/todorex/JDK" target="_blank" rel="external">源码分析地址</a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>该类提供了线程局部 (thread-local) 变量。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</p>
<p>每个线程都保持对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收（除非存在对这些副本的其他引用）</p>
<p><strong>应用</strong>：在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都要传递一个Connection对象。由于JDBC的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将JDBC的连接保存到ThreadLocal对象中，每个线程都会拥有属于自己的连接。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ThreadLocal&lt;String&gt; myThreadLocal = <span class="keyword">new</span> MyThreadLocal&lt;String&gt;();</div><div class="line"></div><div class="line">        <span class="comment">// 输出leonard</span></div><div class="line">        System.out.println(myThreadLocal.get());</div><div class="line"></div><div class="line">        myThreadLocal.set(<span class="string">"rex"</span>);</div><div class="line">        <span class="comment">// 输出rex</span></div><div class="line">        System.out.println(myThreadLocal.get());</div><div class="line"></div><div class="line">        myThreadLocal.remove();</div><div class="line">        <span class="comment">// 输出leonard</span></div><div class="line">        System.out.println(myThreadLocal.get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (T) <span class="string">"leonard"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="get"><a href="#get" class="headerlink" title="get"></a>get</h1><p>返回线程局部变量的当前线程副本中的值。如果当前线程中保存的变量副本没有值，则先将调用 initialValue() 方法初始化然后返回值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 拿到当前线程</span></div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    <span class="comment">// 拿到 ThreadLocalMap 这个Map</span></div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 拿到节点</span></div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            <span class="comment">// 返回保存的值</span></div><div class="line">            T result = (T)e.value;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 不存在这样的map，则设置初始化，然后返回值</span></div><div class="line">    <span class="keyword">return</span> setInitialValue();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 拿到与ThreadLocal关联的Map</span></div><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="comment">// 与当前线程绑定</span></div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div><div class="line"><span class="comment">// ThreadLocal的数据结构是一个HashMap</span></div><div class="line"><span class="comment">// 节点是继承了 WeakReference(弱引用)</span></div><div class="line"><span class="comment">// 如果一个对象具有弱引用，在GC线程扫描内存区域的过程中，不管当前内存空间足够与否，都会回收内存</span></div><div class="line"><span class="comment">// 我们关注getEntry方法</span></div><div class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    <span class="comment">// 拿到数组下标</span></div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</div><div class="line">    Entry e = table[i];</div><div class="line">    <span class="comment">// Hash值没有冲突</span></div><div class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    <span class="comment">// Hash值冲突</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 拿到节点对应的ThreadLocal(key) 弱引用</span></div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">        <span class="keyword">if</span> (k == key)</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</div><div class="line">            <span class="comment">// 清理数组</span></div><div class="line">            expungeStaleEntry(i);</div><div class="line">        <span class="comment">// 存储到下一个下标里（处理Hash冲突采用的是线性探测法）</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            i = nextIndex(i, len);</div><div class="line">        e = tab[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 设置初始化的值，然后返回</span></div><div class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 拿到初始值</span></div><div class="line">    T value = initialValue();</div><div class="line">    <span class="comment">// 拿到当前线程</span></div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    <span class="comment">// 拿到当前线程的ThreadLocalMap</span></div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="comment">// Map已经存在</span></div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        <span class="comment">// 设置ThreadLocal对应的值</span></div><div class="line">        map.set(<span class="keyword">this</span>, value);</div><div class="line">    <span class="comment">// Map不存在，创建Map</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">    <span class="comment">// 返回该值</span></div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>将线程局部变量在当前线程副本中的值设置为指定值。大部分子类不需要重写此方法，它们只依靠 initialValue() 方法来设置线程局部变量的值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    <span class="comment">// 拿到当前线程</span></div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    <span class="comment">// 拿到当前线程的ThreadLocalMap</span></div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="comment">// 如果Map不为空，则直接设置值</span></div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);</div><div class="line">    <span class="comment">// 如果Map为空，则创建Map，然后设置值</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</div><div class="line">    <span class="comment">// 设置初始容量，默认16</span></div><div class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</div><div class="line">    <span class="comment">// 找到下标</span></div><div class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</div><div class="line">    <span class="comment">// 设置值</span></div><div class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</div><div class="line">    <span class="comment">// 设置size</span></div><div class="line">    size = <span class="number">1</span>;</div><div class="line">    <span class="comment">// 设置阈值</span></div><div class="line">    setThreshold(INITIAL_CAPACITY);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">    <span class="comment">// 设置阈值为 16 * 2 / 3 = 10</span></div><div class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们再来看看Map的set方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</div><div class="line"></div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    <span class="comment">// 根据 ThreadLocal 的 HashCode 得到对应的下标</span></div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</div><div class="line">    <span class="comment">// 首先通过下标找对应的entry对象</span></div><div class="line">    <span class="keyword">for</span> (Entry e = tab[i];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">        <span class="comment">// 改变其值</span></div><div class="line">        <span class="keyword">if</span> (k == key) &#123;</div><div class="line">            e.value = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果key被 GC 回收了，就会变为null（因为是软引用），则创建一个新的 entry 对象填充该槽</span></div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 这个方法可以好好看看</span></div><div class="line">            replaceStaleEntry(key, value, i);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 对象不存在，则创建一个新的 entry对象</span></div><div class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</div><div class="line">    <span class="comment">// size + 1</span></div><div class="line">    <span class="keyword">int</span> sz = ++size;</div><div class="line">    <span class="comment">// 如果没有清除多余的entry 并且数组长度达到了阀值，则扩容</span></div><div class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</div><div class="line">        <span class="comment">// 扩容</span></div><div class="line">        rehash();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 清楚陈旧的节点</span></div><div class="line">    expungeStaleEntries();</div><div class="line"></div><div class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></div><div class="line">    <span class="comment">// 如果size大于0.75倍阈值。原来是2/3， 则负载因子相当于为0.5，这是在第一次的时候</span></div><div class="line">    <span class="comment">// 在首次扩容之后，负载因子还是0.75</span></div><div class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</div><div class="line">        resize();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entry[] oldTab = table;</div><div class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</div><div class="line">    <span class="comment">// 扩容为原来的两倍</span></div><div class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</div><div class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</div><div class="line">        Entry e = oldTab[j];</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</div><div class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</div><div class="line">                    h = nextIndex(h, newLen);</div><div class="line">                newTab[h] = e;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setThreshold(newLen);</div><div class="line">    size = count;</div><div class="line">    table = newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="romove"><a href="#romove" class="headerlink" title="romove"></a>romove</h1><p>移除此线程局部变量在当前线程的值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 得到当前线程的Map</span></div><div class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</div><div class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</div><div class="line">        m.remove(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用ThreadLocalMap的remove方法</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</div><div class="line">    <span class="comment">// 通过线性探测法找到 key 对应的 entry</span></div><div class="line">    <span class="keyword">for</span> (Entry e = tab[i];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</div><div class="line">            <span class="comment">// 将ThreadLocal设置为null</span></div><div class="line">            e.clear();</div><div class="line">            <span class="comment">// 清理所有的 key 为 null 的 entry</span></div><div class="line">            expungeStaleEntry(i);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ThreadLocal无限好，但是也会有问题，比如内存泄漏的问题（可以在后面的参考理解这个问题），为了防止这个问题，我们需要每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/80284438bb97" target="_blank" rel="external">并发编程之 ThreadLocal 源码剖析</a></li>
<li><a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/" target="_blank" rel="external">深入分析 ThreadLocal 内存泄漏问题</a></li>
<li><a href="http://ifeve.com/%E4%BD%BF%E7%94%A8threadlocal%E4%B8%8D%E5%BD%93%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/" target="_blank" rel="external">使用ThreadLocal不当可能会导致内存泄露</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：可能大家对ThreadLocal这个类既熟悉又陌生，看到得多用到得少。
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="http://bestlixiang.site/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析——LinkedHashMap</title>
    <link href="http://bestlixiang.site/2018/09/06/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94LinkedHashMap/"/>
    <id>http://bestlixiang.site/2018/09/06/JDK源码分析/JDK源码分析——LinkedHashMap/</id>
    <published>2018-09-06T01:40:43.000Z</published>
    <updated>2018-09-07T13:25:42.605Z</updated>
    
    <content type="html"><![CDATA[<p>引：如果有这样一种情形，我们需要按照元素插入的顺序来访问元素，这个时候LinkedHashMap大展身手了，它保存着元素插入的顺序，并且可以按照我们插入的顺序进行访问。<a id="more"></a></p>
<p>详细注释：<a href="https://github.com/todorex/JDK" target="_blank" rel="external">源码分析地址</a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>LinkedHashMap 继承自 HashMap，在 HashMap 基础上，通过维护一条双向链表，解决了 HashMap 不能随时保持遍历顺序和插入顺序一致的问题。除此之外，LinkedHashMap 对访问顺序也提供了相关支持。在一些场景下，该特性很有用，比如缓存。在实现上，LinkedHashMap 很多方法直接继承自 HashMap，仅为维护双向链表覆写了部分方法。</p>
<p>它的结构示意图如下：<br><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166338955699.jpg" alt="LinkedHashMap"></p>
<h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>主要就是设置初始容量、负载因子和迭代顺序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 双向链表的头，最久访问的</span></div><div class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</div><div class="line"><span class="comment">// 双向链表的尾，最新访问的</span></div><div class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</div><div class="line"><span class="comment">// 默认为false，迭代顺序是按照插入顺序，当为true时，迭代顺序是按照访问信息，最近访问在尾部</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></div><div class="line">                     <span class="keyword">float</span> loadFactor,</div><div class="line">                     <span class="keyword">boolean</span> accessOrder) &#123;</div><div class="line">    <span class="comment">// 后面和HashMap一样</span></div><div class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><p>LinkedHashMap 本身并没有覆写父类的 put 方法，而是直接使用了父类的实现。但在 HashMap 中，put 方法插入的是 HashMap 内部类 Node 类型的节点，该类型的节点并不具备与 LinkedHashMap 内部类 Entry 及其子类型节点组成链表的能力。下面将展示建立链表的逻辑，其中和HashMap相同的代码这里就不多说，不知道的可以在先阅读在后面参考提到的HashMap解析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 调用HashMap的put方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 调用HashMap的putVal方法</span></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">                   <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// 关键就在这里，这里会触发多态，去调用LinkedHashMap的方法</span></div><div class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 3. 多态调用LinkedHashMap的newNode方法</span></div><div class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</div><div class="line">    <span class="comment">// 生成LinkedHashMap需要的节点</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</div><div class="line">    <span class="comment">// 将 Entry 接在双向链表的尾部</span></div><div class="line">    linkNodeLast(p);</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 我们可以看一下这种节点的数据结构</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 拥有前后指针</span></div><div class="line">    Entry&lt;K,V&gt; before, after;</div><div class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">super</span>(hash, key, value, next);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 4. 将新建的节点接在双向链表的尾部</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</div><div class="line">    <span class="comment">// 拿到为节点</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</div><div class="line">    tail = p;</div><div class="line">    <span class="comment">// 如果尾节点不存在，则代表了链表未生成</span></div><div class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</div><div class="line">        head = p;</div><div class="line">    <span class="comment">// 设置指针</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        p.before = last;</div><div class="line">        last.after = p;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 5. 后面的内容就和HashMap一毛一样了</span></div></pre></td></tr></table></figure></p>
<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><p>与插入操作一样，LinkedHashMap 删除操作相关的代码也是直接用父类的实现。在删除节点时，父类的删除逻辑并不会修复 LinkedHashMap 所维护的双向链表。维护操作都在删除及节点后的回调方法 afterNodeRemoval 中。LinkedHashMap 覆写该方法，并在该方法中完成了移除被删除节点的操作。分析方法同上。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 调用HashMap的remove方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 调用HashMap的removeNode方法</span></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></div><div class="line">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// 对应各种类型的节点删除。这些都不会改变链表的结构</span></div><div class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</div><div class="line">                     (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</div><div class="line">    <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</div><div class="line">        ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</div><div class="line">        tab[index] = node.next;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        p.next = node.next;</div><div class="line">    ++modCount;</div><div class="line">    --size;</div><div class="line">    <span class="comment">// 关键的来了，这个操作在HashMap是没有实现的，但是在LinkedHashMap中实现了</span></div><div class="line">    afterNodeRemoval(node);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 3. 调用LinkedHashMap方法的afterNodeRemoval操作来调整链表结构</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></div><div class="line">    <span class="comment">// 拿到删除节点以及它的前驱节点和后继节点</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">    <span class="comment">// 将这两个指针置空</span></div><div class="line">    p.before = p.after = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 如果前驱节点为空，则为头节点</span></div><div class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</div><div class="line">        head = a;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="comment">// 连接前后两个界定啊</span></div><div class="line">        b.after = a;</div><div class="line">    <span class="comment">// 如果前驱节点为空，则为尾节点</span></div><div class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</div><div class="line">        tail = b;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        a.before = b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="改"><a href="#改" class="headerlink" title="改"></a>改</h1><p>与插入操作一样，LinkedHashMap 改操作相关的代码也是直接用父类的实现。分析方法同上。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 调用HashMap的replace方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="comment">// 前面的操作都和HashMap一致</span></div><div class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</div><div class="line">        V oldValue = e.value;</div><div class="line">        e.value = value;</div><div class="line">        <span class="comment">// 重点在修改之后会执行这样一个回调操作</span></div><div class="line">        afterNodeAccess(e);</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 调用LinkedHashMap的afterNodeAccess访问回调方法来调整链表位置</span></div><div class="line"><span class="comment">// 将最近访问的节点，放在链表最后</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</div><div class="line">    <span class="comment">// 当accessOrder为ture 且 访问的不是尾部节点时才进行下面的一顿操作</span></div><div class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</div><div class="line">        <span class="comment">// 拿到访问节点以及它的前驱节点和后继节点</span></div><div class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">        <span class="comment">// 后继节点置空</span></div><div class="line">        p.after = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 前驱节点为头节点</span></div><div class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</div><div class="line">            head = a;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            b.after = a;</div><div class="line">        <span class="comment">// 这里的if/else感觉也都没用，因为都确定不是尾节点了</span></div><div class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</div><div class="line">            a.before = b;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            last = b;</div><div class="line">        <span class="comment">// 表示不会会空，因为都访问到元素了</span></div><div class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</div><div class="line">            head = p;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            p.before = last;</div><div class="line">            last.after = p;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 将访问节点放到尾部</span></div><div class="line">        tail = p;</div><div class="line">        ++modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><p>查操作覆盖了HashMap的方法，但是也只是添加afterNodeAccess操作判断。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 唯一不同的地方，当accessOrder为true时，则调整链表，和在改操作的分析一样</span></div><div class="line">    <span class="keyword">if</span> (accessOrder)</div><div class="line">        afterNodeAccess(e);</div><div class="line">    <span class="keyword">return</span> e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="实现-LRU-缓存"><a href="#实现-LRU-缓存" class="headerlink" title="实现 LRU 缓存"></a>实现 LRU 缓存</h1><p><strong>LRU 缓存</strong>：LRU（Least Recently Used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
<p>大家看到上面的定义就能想到就是在一定条件下删除Head节点嘛，因为最近访问过的都会被放在链表尾部，最近最少使用的一定是投节点。那么LinkedHashMap在哪里为我们留下了实现的接口，我们看看下面的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 可用于实现LRU缓存，evict就表示删除的意思</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</div><div class="line">    <span class="comment">// 根据条件判断是否移除最近最少被访问的节点，主要就是removeEldestEntry方法</span></div><div class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</div><div class="line">        K key = first.key;</div><div class="line">        <span class="comment">// 删除节点</span></div><div class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 默认返会false，就是不删除</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 当然在源码注释中也为我们重写提供了例子</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</div><div class="line">  <span class="comment">// 当大于某个阈值，就移除最老的</span></div><div class="line">  <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://segmentfault.com/a/1190000012964859" target="_blank" rel="external">LinkedHashMap 源码详细分析（JDK1.8）</a></li>
<li><a href="http://todorex.com/2018/09/03/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94HashMap/" target="_blank" rel="external">JDK源码分析——HashMap</a></li>
<li><a href="https://www.jianshu.com/p/06a0fd962e0b" target="_blank" rel="external">Java 中最大的数据结构：LinkedHashMap 了解一下？</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：如果有这样一种情形，我们需要按照元素插入的顺序来访问元素，这个时候LinkedHashMap大展身手了，它保存着元素插入的顺序，并且可以按照我们插入的顺序进行访问。
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="LinkedHashMap" scheme="http://bestlixiang.site/tags/LinkedHashMap/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析——TreeMap</title>
    <link href="http://bestlixiang.site/2018/09/06/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94TreeMap/"/>
    <id>http://bestlixiang.site/2018/09/06/JDK源码分析/JDK源码分析——TreeMap/</id>
    <published>2018-09-06T00:32:02.000Z</published>
    <updated>2018-09-07T02:19:19.435Z</updated>
    
    <content type="html"><![CDATA[<p>引：你想利用的Map高效的查找效率，又想拥有一个有序的Map，这个时候就需要用到TreeMap了!<a id="more"></a></p>
<p>详细注释：<a href="https://github.com/todorex/JDK" target="_blank" rel="external">源码分析地址</a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>TreeMap集合是基于红黑树（Red-Black tree）的 NavigableMap实现。该Map根据其键的自然顺序进行排序，或者根据创建Map时提供的 Comparator 进行排序，具体取决于使用的构造方法。你可以根据自己的需要选择排序的方式。</p>
<p>关于不同步都和之前解析的非同步容器类似。</p>
<h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>在概览中说到我们可以在它构造时传递Comparator来决定排序的方法，所以我们就看看这个构造方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 比较器</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</div><div class="line"><span class="comment">// 根节点</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</div><div class="line"><span class="comment">// 集合大小</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.comparator = comparator;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><p>我们看出在构造方法中只是设置了属性，并没有真正构建红黑树，那么它一定在第一次put操作里。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取根节点</span></div><div class="line">    Entry&lt;K,V&gt; t = root;</div><div class="line">    <span class="comment">// 如果根节点为空，则该元素置为根节点</span></div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</div><div class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></div><div class="line">        <span class="comment">// 新建节点</span></div><div class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</div><div class="line">        <span class="comment">// 改变集合大小和修改次数</span></div><div class="line">        size = <span class="number">1</span>;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cmp;</div><div class="line">    Entry&lt;K,V&gt; parent;</div><div class="line">    <span class="comment">// split comparator and comparable paths</span></div><div class="line">    <span class="comment">// 获得key比较器</span></div><div class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</div><div class="line">    <span class="comment">// 如果比较器对象不为空，也就是自定义了比较器</span></div><div class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="comment">// 循环比较并确定元素应插入的位置(也就是找到该元素的父节点)</span></div><div class="line">            parent = t;</div><div class="line">            cmp = cpr.compare(key, t.key);</div><div class="line">            <span class="comment">// 待插入元素的key小于当前位置元素的key，则查询左子树</span></div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="comment">// 待插入元素的key大于当前位置元素的key，则查询右子树</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                t = t.right;</div><div class="line">            <span class="comment">// 相等则替换其value</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果比较器对象为空，使用默认的比较机制</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 默认机制下不允许设置 null key</span></div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">        <span class="comment">// 和上面的循环做同样的事</span></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            parent = t;</div><div class="line">            cmp = k.compareTo(t.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                t = t.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 根据key找到父节点后新建一个节点</span></div><div class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</div><div class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">        parent.left = e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        parent.right = e;</div><div class="line">    <span class="comment">// 调整红黑树</span></div><div class="line">    fixAfterInsertion(e);</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大概的流程如下：</p>
<ol>
<li>判断根节点是否为空，为空，则该节点就是根节点</li>
<li>根据比较器(可能是外部传进来的，也可能是默认的)，找到父节点。</li>
<li>插入节点之后，就需要用红黑树的修正了。</li>
</ol>
<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">// 利用比较器二分查找</span></div><div class="line">    Entry&lt;K,V&gt; p = getEntry(key);</div><div class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    V oldValue = p.value;</div><div class="line"></div><div class="line">    <span class="comment">// 红黑树删除</span></div><div class="line">    deleteEntry(p);</div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></div><div class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="comment">// 普通的二分查找</span></div><div class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">            p = p.left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">            p = p.right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        K k = (K) key;</div><div class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</div><div class="line">    <span class="comment">// 普通的二分查找</span></div><div class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</div><div class="line">        Entry&lt;K,V&gt; p = root;</div><div class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                p = p.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                p = p.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="改"><a href="#改" class="headerlink" title="改"></a>改</h1><p>找到该key对应的节点，然后替换该值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">// 找到节点</span></div><div class="line">    Entry&lt;K,V&gt; p = getEntry(key);</div><div class="line">    <span class="comment">// 替换值</span></div><div class="line">    <span class="keyword">if</span> (p!=<span class="keyword">null</span>) &#123;</div><div class="line">        V oldValue = p.value;</div><div class="line">        p.value = value;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><p>一批以getFirstEntry()，getLastEntry()为基础的获取头和尾元素的方法，其中包括：firstKey()，lastKey()；firstEntry()，lastEntry()；pollFirstEntry()，pollLastEntry()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  返回第一个节点(值最小的节点)</span></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getFirstEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</div><div class="line">        <span class="comment">// 一直遍历左子树</span></div><div class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</div><div class="line">            p = p.left;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 返回最后一个节点(值最大的节点)</span></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getLastEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</div><div class="line">        <span class="comment">// 一直遍历右子树</span></div><div class="line">        <span class="keyword">while</span> (p.right != <span class="keyword">null</span>)</div><div class="line">            p = p.right;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：你想利用的Map高效的查找效率，又想拥有一个有序的Map，这个时候就需要用到TreeMap了!
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="HashMap" scheme="http://bestlixiang.site/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析——HashSet</title>
    <link href="http://bestlixiang.site/2018/09/06/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94HashSet/"/>
    <id>http://bestlixiang.site/2018/09/06/JDK源码分析/JDK源码分析——HashSet/</id>
    <published>2018-09-06T00:04:49.000Z</published>
    <updated>2018-09-06T00:24:30.281Z</updated>
    
    <content type="html"><![CDATA[<p>引：如果用来有个去重的需求，你肯定会想到用HashSet，那我们看看它的实现！<a id="more"></a></p>
<p>详细注释：<a href="https://github.com/todorex/JDK" target="_blank" rel="external">源码分析地址</a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>它是由哈希表（实际上是一个<strong>HashMap</strong>实例）支持，是不是有点意思？它不保证set的迭代顺序，有且只允许一个null元素，当然其他元素不能重复。</p>
<p>它不是同步容器。如果多个线程同时访问一个哈希set，而其中至少一个线程修改了该 set，那么它必须保持外部同步。这通常是通过对自然封装该set的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” set。最好在创建时完成这一操作，以防止对该set进行意外的不同步访问。</p>
<p>所有这个类的方法返回的迭代器都是快速失败的 ：如果映射在迭代器创建之后的任何时间被结构地修改，除了通过迭代器自己的remove方法之外，迭代器将抛出一个ConcurrentModificationException。（老生长谈）</p>
<h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>关于HashSet的操作(下面都是)，基本上都是直接调用底层HashMap的相关方法来完成。所以在后面参考找到自己关于HashMap的文章。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 真的操作的执行者</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</div><div class="line"><span class="comment">// 定义一个"虚拟"的Object对象作为HashMap的value</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line"><span class="comment">// 构造HashMap</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><p>在HashMap新增一个键值对<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><p>在HashMap删除一个键值对<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><p>在HashMap查找key是否存在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.containsKey(o);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>水文一篇，只要记住一点，就是只要理解了HashMap，HashSet is so easy！！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://todorex.com/2018/09/03/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94HashMap/" target="_blank" rel="external">JDK源码分析——HashMap</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：如果用来有个去重的需求，你肯定会想到用HashSet，那我们看看它的实现！
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="HashSet" scheme="http://bestlixiang.site/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析——ConcurrentHashMap</title>
    <link href="http://bestlixiang.site/2018/09/04/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ConcurrentHashMap/"/>
    <id>http://bestlixiang.site/2018/09/04/JDK源码分析/JDK源码分析——ConcurrentHashMap/</id>
    <published>2018-09-04T05:08:53.000Z</published>
    <updated>2018-09-04T13:02:09.721Z</updated>
    
    <content type="html"><![CDATA[<p>引：HashMap是我们平时开发过程中用的比较多的集合，但它是非线程安全的。解决方案有Hashtable和Collections.synchronizedMap(hashMap)，不过这两个方案基本上是对读写进行加锁操作，性能可想而知。所以感谢<strong>Doug Lea</strong>给我们带来了并发安全的ConcurrentHashMap。<a id="more"></a></p>
<p>详细注释：<a href="https://github.com/todorex/JDK" target="_blank" rel="external">源码分析地址</a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。它采用CAS操作和内置锁synchronized来实现同步</p>
<h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>主要就是设置初始容量和负载因子。（很多在HashMap中介绍过的变量和常量，这里就不再次介绍了）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认为null，初始化发生在第一次插入操作，默认大小为16的数组，用来存储Node节点数据，扩容时大小总是2的幂次方</span></div><div class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</div><div class="line"><span class="comment">// 默认为null，扩容时新生成的数组，其大小为原数组的两倍</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</div><div class="line"><span class="comment">// 默认为0，用来控制table的初始化和扩容操作</span></div><div class="line"><span class="comment">// -1：表示table正在初始化</span></div><div class="line"><span class="comment">// -N：表示有N-1个线程正在进行扩容操作</span></div><div class="line"><span class="comment">// 非负情况</span></div><div class="line"><span class="comment">// 如果table未初始化，表示table需要初始化的大小</span></div><div class="line"><span class="comment">// 如果table初始化完成，表示table的阈值，默认是table大小的0.75倍</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</div><div class="line"></div><div class="line"><span class="comment">// 根据initialCapacity初始化</span></div><div class="line"><span class="comment">// initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)没看懂，知道的请call me（难道和0.75有关系？）</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</div><div class="line">               MAXIMUM_CAPACITY :</div><div class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</div><div class="line">    <span class="comment">// 复制给 sizeCtl</span></div><div class="line">    <span class="keyword">this</span>.sizeCtl = cap;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><p>新增节点，可能会（并发）扩容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过Unsafe拿到sizeCtl的地址</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SIZECTL;</div><div class="line"><span class="comment">// 通过Unsafe拿到baseCount的地址</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASECOUNT;</div><div class="line"><span class="comment">// 移动节点的hash值，只在transfer(扩容方法中)新建ForwardingNode设置</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="comment">// 对hashCode进行再散列</span></div><div class="line">    <span class="comment">// 算法为(h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS(0x7fffffff)</span></div><div class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</div><div class="line">    <span class="comment">// 准备遍历table</span></div><div class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 这边加了一个循环，就是不断的尝试</span></div><div class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</div><div class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">            <span class="comment">// 初始化table</span></div><div class="line">            tab = initTable();</div><div class="line">        <span class="comment">// 获取对应下标节点，如果是空，直接插入</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// CAS 进行插入</span></div><div class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</div><div class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</div><div class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果 hash 冲突了</span></div><div class="line">        <span class="comment">// 且 hash 值为 -1(MOVED)，说明是 ForwardingNode 对象（这是一个占位符对象，保存了扩容后的容器）</span></div><div class="line">        <span class="comment">// 表示了正在扩容，需要帮助 Map 进行扩容，以加快速度</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</div><div class="line">            tab = helpTransfer(tab, f);</div><div class="line">        <span class="comment">// 如果 hash 冲突了，且 hash 值不为 -1</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            V oldVal = <span class="keyword">null</span>;</div><div class="line">            <span class="comment">// 同步 f 节点，防止增加链表的时候导致链表成环(会出现死循环)</span></div><div class="line">            <span class="keyword">synchronized</span> (f) &#123;</div><div class="line">                <span class="comment">// 如果对应的下标位置 的节点没有改变</span></div><div class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                    <span class="comment">// 并且 f 节点的hash 值 大于0</span></div><div class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        <span class="comment">// 链表长度</span></div><div class="line">                        binCount = <span class="number">1</span>;</div><div class="line">                        <span class="comment">// 死循环，直到将值添加到链表尾部，并计算链表的长度</span></div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                            K ek;</div><div class="line">                            <span class="comment">// 遇到重复的key，根据标志位覆盖</span></div><div class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                                ((ek = e.key) == key ||</div><div class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                oldVal = e.val;</div><div class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                    e.val = value;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                            Node&lt;K,V&gt; pred = e;</div><div class="line">                            <span class="comment">// 尾部插入</span></div><div class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                          value, <span class="keyword">null</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 如果 f 节点的 has 小于0 并且f 是 树类型</span></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                        Node&lt;K,V&gt; p;</div><div class="line">                        binCount = <span class="number">2</span>;</div><div class="line">                        <span class="comment">// 插入树中</span></div><div class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</div><div class="line">                            oldVal = p.val;</div><div class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                p.val = value;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 链表长度大于等于8时，将该节点改成红黑树树</span></div><div class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                    treeifyBin(tab, i);</div><div class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> oldVal;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 判断是否需要扩容CAS</span></div><div class="line">    addCount(<span class="number">1L</span>, binCount);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 初始化table</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</div><div class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 如果一个线程发现sizeCtl&lt;0，意味着另外的线程执行CAS操作成功</span></div><div class="line">        <span class="comment">// 当前线程只需要让出cpu时间片</span></div><div class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</div><div class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></div><div class="line">        <span class="comment">// CAS 修改 sizeCtl 的值为-1</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// sc 在初始化的时候用户可能会自定义，如果没有自定义，则是默认的16</span></div><div class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</div><div class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</div><div class="line">                    table = tab = nt;</div><div class="line">                    <span class="comment">// 计算后作为扩容的阀值(相当于乘以0.75)</span></div><div class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                sizeCtl = sc;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tab;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Helps transfer if a resize is in progress.</div><div class="line"> * 如果正在扩容，则帮助扩容</div><div class="line"> */</div><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</div><div class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</div><div class="line">    <span class="comment">// 如果 table 不是空 且 node 节点是转移节点</span></div><div class="line">    <span class="comment">// // 且 node 节点的 nextTable（新 table） 不是空</span></div><div class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</div><div class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 根据 length 得到一个标识符号</span></div><div class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</div><div class="line">        <span class="comment">// 如果 nextTab 没有被并发修改 且 tab 也没有被并发修改 且 sizeCtl  &lt; 0 （说明还在扩容）</span></div><div class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</div><div class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</div><div class="line">             <span class="comment">// 如果 sizeCtl 无符号右移  16 不等于 rs （ sc前 16 位如果不等于标识符，则标识符变化了）</span></div><div class="line">             <span class="comment">// 或者 sizeCtl == rs + 1  （扩容结束了，不再有线程进行扩容）（默认第一个线程设置 sc ==rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。这个时候，sc 就等于 rs + 1）</span></div><div class="line">             <span class="comment">// 或者 sizeCtl == rs + 65535  （如果达到最大帮助线程的数量，即 65535）</span></div><div class="line">             <span class="comment">// 或者转移下标正在调整 （扩容结束）</span></div><div class="line">             <span class="comment">// 结束循环，返回 table</span></div><div class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</div><div class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="comment">// 如果以上都不是, 将 sizeCtl + 1, （表示增加了一个线程帮助其扩容）</span></div><div class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</div><div class="line">                <span class="comment">// 扩容</span></div><div class="line">                transfer(tab, nextTab);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nextTab;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> table;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 判断是否需要扩容，需要则进行扩容</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</div><div class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</div><div class="line">    <span class="comment">// 如果计数盒子不是空 或者 修改 baseCount 失败</span></div><div class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</div><div class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</div><div class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</div><div class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">// 如果计数盒子是空（尚未出现并发）或者 随机取余一个数组位置为空</span></div><div class="line">        <span class="comment">// 或者 修改这个槽位的变量失败（出现并发了）</span></div><div class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</div><div class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</div><div class="line">            !(uncontended =</div><div class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</div><div class="line">            <span class="comment">// CAS增加</span></div><div class="line">            fullAddCount(x, uncontended);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="comment">// 统计size</span></div><div class="line">        s = sumCount();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果需要检查,检查是否需要扩容，在 putVal 方法调用时，默认就是要检查的。</span></div><div class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</div><div class="line">        <span class="comment">// 如果map.size() 大于 sizeCtl（达到扩容阈值需要扩容）</span></div><div class="line">        <span class="comment">// 且table 不是空；且 table 的长度小于 1 &lt;&lt; 30。（可以扩容）</span></div><div class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</div><div class="line">            <span class="keyword">int</span> rs = resizeStamp(n</div><div class="line">            <span class="comment">// 如果正在扩容</span></div><div class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 如果 sc 的低 16 位不等于 标识符（校验异常 sizeCtl 变化了）</span></div><div class="line">                <span class="comment">// 如果 sc == 标识符 + 1 （扩容结束了，不再有线程进行扩容）（默认第一个线程设置 sc ==rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。这个时候，sc 就等于 rs + 1）</span></div><div class="line">                <span class="comment">// 如果 sc == 标识符 + 65535（帮助线程数已经达到最大）</span></div><div class="line">                <span class="comment">// 如果 nextTable == null（结束扩容了）</span></div><div class="line">                <span class="comment">// 如果 transferIndex &lt;= 0 (转移状态变化了)</span></div><div class="line">                <span class="comment">// 结束循环</span></div><div class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</div><div class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</div><div class="line">                    transferIndex &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="comment">// 如果可以帮助扩容，那么将 sc 加 1. 表示多了一个线程在帮助扩容</span></div><div class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</div><div class="line">                    <span class="comment">// 扩容(有点复杂，设计到并发扩容，可以在后面的参考找到文章，这里就不分析了)</span></div><div class="line">                    transfer(tab, nt);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果不在扩容，将 sc 更新：标识符左移 16 位 然后 + 2. 也就是变成一个负数。高 16 位是标识符，低 16 位初始是 2.</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</div><div class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</div><div class="line">                <span class="comment">// 更新 sizeCtl 为负数后，开始扩容。</span></div><div class="line">                transfer(tab, <span class="keyword">null</span>);</div><div class="line">            <span class="comment">// 统计size</span></div><div class="line">            s = sumCount();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><p>根据key删除键值对，如果key不存在，什么也不做<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 用新cv取代原来的value，如果value是null，就代表删除</span></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</div><div class="line">    <span class="comment">// 计算key的hash值</span></div><div class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</div><div class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</div><div class="line">        <span class="comment">// table为空 或 容量为0 或 不存在</span></div><div class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</div><div class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">// 正在扩容</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</div><div class="line">            <span class="comment">// 协助扩容</span></div><div class="line">            tab = helpTransfer(tab, f);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            V oldVal = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">// 同步删除</span></div><div class="line">            <span class="keyword">synchronized</span> (f) &#123;</div><div class="line">                <span class="comment">// 桶中的第一个结点没有发生变化</span></div><div class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                    <span class="comment">// 替换链表中的节点</span></div><div class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        validated = <span class="keyword">true</span>;</div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;;) &#123;</div><div class="line">                            K ek;</div><div class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                                ((ek = e.key) == key ||</div><div class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                V ev = e.val;</div><div class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</div><div class="line">                                    (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</div><div class="line">                                    oldVal = ev;</div><div class="line">                                    <span class="comment">// value不为null，替换</span></div><div class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</div><div class="line">                                        e.val = value;</div><div class="line">                                    <span class="comment">// value为null，删除</span></div><div class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</div><div class="line">                                        <span class="comment">// 前驱的后继为e的后继，即删除了e结点</span></div><div class="line">                                        pred.next = e.next;</div><div class="line">                                    <span class="keyword">else</span></div><div class="line">                                        setTabAt(tab, i, e.next);</div><div class="line">                                &#125;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                            pred = e;</div><div class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 替换红黑树中的节点</span></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                        validated = <span class="keyword">true</span>;</div><div class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class="line">                        TreeNode&lt;K,V&gt; r, p;</div><div class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                            (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</div><div class="line">                            V pv = p.val;</div><div class="line">                            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</div><div class="line">                                (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</div><div class="line">                                oldVal = pv;</div><div class="line">                                <span class="comment">// value不为null，替换</span></div><div class="line">                                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</div><div class="line">                                    p.val = value;</div><div class="line">                                <span class="comment">// value为null，删除</span></div><div class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</div><div class="line">                                    <span class="comment">// 返回为true，去树化</span></div><div class="line">                                    setTabAt(tab, i, untreeify(t.first));</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (validated) &#123;</div><div class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</div><div class="line">                        <span class="comment">// 总数-1</span></div><div class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</div><div class="line">                    <span class="keyword">return</span> oldVal;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="改"><a href="#改" class="headerlink" title="改"></a>改</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || oldValue == <span class="keyword">null</span> || newValue == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="comment">// 对于replaceNode方法在删除操作中已经解析过了</span></div><div class="line">    <span class="keyword">return</span> replaceNode(key, newValue, oldValue) != <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><p>根据key获取value<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</div><div class="line">    <span class="comment">// 计算key的hash</span></div><div class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</div><div class="line">    <span class="comment">// table不为空</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 判断头节点是否符合</span></div><div class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</div><div class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</div><div class="line">                <span class="keyword">return</span> e.val;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 在树中查找，小于0的代表了树的根节点，因为树的根节点的哈希值为TREEBIN（-2）</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</div><div class="line">            <span class="comment">// 调用红黑树的查找方法</span></div><div class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 在链表中查找</span></div><div class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</div><div class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</div><div class="line">                <span class="keyword">return</span> e.val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ConcurrentHashMap 是 Doug Lea 的神作，可以说是精彩绝伦，总的来说，使用了 CAS（扩容并发） 和 synchronized 来保证了 put 操作并发时的危险（特别是链表，防止了死循环的发生），在读方法完全没有锁，完全并发，相比其他线程安全的Map，它的性能真是杠杠滴。写完才发现自己只是打了注释，还没有概括性的话语，缺少了总结，以后需要注意。除此之外，ConcurrentHashMap肯定不是一遍文章就能说完了，以后还需要基础回顾，继续补充。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/d3fda02d4cae" target="_blank" rel="external">java内存模型</a></li>
<li><a href="https://www.jianshu.com/p/a16d638bc921" target="_blank" rel="external">java中的Unsafe</a></li>
<li><a href="https://www.jianshu.com/p/fb6e91b013cc" target="_blank" rel="external">深入浅出CAS</a></li>
<li><a href="https://www.jianshu.com/p/d8eeb31bee5c" target="_blank" rel="external">深入浅出java同步器AQS</a></li>
<li><a href="https://www.jianshu.com/p/4358b1466ec9" target="_blank" rel="external">深入浅出ReentrantLock</a></li>
<li><a href="https://blog.csdn.net/u010771890/article/details/73732648" target="_blank" rel="external">Java并发容器ConcurrentHashMap原理及HashMap死循环原因的分析</a></li>
<li><a href="https://www.jianshu.com/p/29d8e66bc3bf" target="_blank" rel="external">ConcurrentHashMap 源码阅读小结</a></li>
<li><a href="https://www.jianshu.com/p/c0642afe03e0" target="_blank" rel="external">深入浅出ConcurrentHashMap1.8</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：HashMap是我们平时开发过程中用的比较多的集合，但它是非线程安全的。解决方案有Hashtable和Collections.synchronizedMap(hashMap)，不过这两个方案基本上是对读写进行加锁操作，性能可想而知。所以感谢&lt;strong&gt;Doug Lea&lt;/strong&gt;给我们带来了并发安全的ConcurrentHashMap。
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="ConcurrentHashMap" scheme="http://bestlixiang.site/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析——HashMap</title>
    <link href="http://bestlixiang.site/2018/09/03/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94HashMap/"/>
    <id>http://bestlixiang.site/2018/09/03/JDK源码分析/JDK源码分析——HashMap/</id>
    <published>2018-09-03T04:01:02.000Z</published>
    <updated>2018-09-04T01:24:17.118Z</updated>
    
    <content type="html"><![CDATA[<p>引：在Collection接口中用的最多的是ArrayList，在Map接口中用的最多的一定是HashMap，我们今天就来看看HashMap！<a id="more"></a></p>
<p>详细注释：<a href="https://github.com/todorex/JDK" target="_blank" rel="external">源码分析地址</a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>它是基于哈希表实现的Map接口，允许null的值和null键。</p>
<p>HashMap的一个实例有两个影响其性能的参数： 初始容量和负载因子。容量是哈希表中的桶数，初始容量只是创建哈希表时的容量。 负载因子是在容量自动增加之前允许哈希表充满程度的度量。 当在散列表中的条目的数量超过了负载因数和容量的乘积，哈希表将被重新散列 （即内部数据结构被重建），使得哈希表具有桶的大约两倍。</p>
<p>作为一般规则，默认负载因子（0.75）提供了时间和空间成本之间的良好折中。 更高的值会降低空间开销，但会增加查找成本（反映在HashMap类的大部分操作中，包括get和put ）。 在设置其初始容量时，应考虑Map中预期的条目数及其负载因子，以便最小化重新散列操作的数量。 如果初始容量大于最大条目数除以负载因子，则不会发生重新散列操作。</p>
<p>注意，HashMap不同步。 如果多个线程同时访问哈希映射，并且至少有一个线程在结构上修改了映射，那么它必须在外部进行同步。 （结构修改是添加或删除一个或多个映射的任何操作;仅改变与实例已经包含的Key相关联的值不是结构修改。）这通常通过对自然地封装映射的一些对象（ConcurrentMap等）进行同步来实现。 如果没有这样的对象存在，应该使用Collections.synchronizedMap方法“包装”。</p>
<p>所有这个类的方法返回的迭代器都是快速失败的 ：如果映射在迭代器创建之后的任何时间被结构地修改，除了通过迭代器自己的remove方法之外，迭代器将抛出一个ConcurrentModificationException 。</p>
<h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>在构造方法中主要就是设置初始容量和负载因子，如下面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 最大容量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"><span class="comment">// 默认初始容量，一定是2的n次方，这里是16</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</div><div class="line"><span class="comment">// 默认负载因子，这里是0.75</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"><span class="comment">// 这里是Map存放条目的阈值</span></div><div class="line"><span class="keyword">int</span> threshold;</div><div class="line"><span class="comment">// 初始的节点数组，这里Node是个双向节点链表（下面注释中会直接说table）</span></div><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...                                  </span></div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    <span class="comment">// 可能大家觉得阈值应该需要乘以负载因子，先别急，往后看</span></div><div class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 根据所给的目标容量返回大于或等于2的幂次方</span></div><div class="line"><span class="comment">// 感觉这里吊炸天，看不懂的可以看后面参考的博客</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">    <span class="comment">// 这里一定要减1，不然对于本来就是2的幂次方的数，会变成原来的两倍</span></div><div class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里解答一下为什么要是2的幂次方？首先提一个东西就是散列到HashMap中是通过下面的公式：<br><code>hash &amp;(cap-1)</code></p>
<p>假设cap容量为15、16，那么他们减1之后的二进制表达为1110、1111，那么0001、0011、0101、0111, 1001、1011、1101这些桶将永远不会被用到。所以我们需要2的幂次方。</p>
<p>这里既然看到了hash我们就看一下HashMap的hash函数优化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="comment">// 这里叫扰动函数(加入高位特征)，减少hash碰撞，具体的可以看后面参考里的文章</span></div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><p>这里会有很多细节，需要耐心慢慢看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// hash冲突的链表树化阈值（至少为8）</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</div><div class="line"><span class="comment">// 从树还原为链表阈值（小于6）</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</div><div class="line"></div><div class="line"><span class="comment">// 增加键值对，如果key已存在，则覆盖</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">// 返回生成的节点</span></div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="comment">// 初始节点数组table为空或者长度为0</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        <span class="comment">// 生成节点数组（这里会涉及到初始化table或扩容，下面会说），并返回长度</span></div><div class="line">        n = (tab = resize()).length;</div><div class="line">    <span class="comment">// //如果新存放的hash值没有冲突，则放入tab</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 否则就是产生了hash冲突</span></div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="comment">// 如果hash值相等且key值相等, 则令e指向冲突的头节点</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        <span class="comment">// 如果头节点的key值与新插入的key值不等, 并且头结点是TreeNode类型,说明该hash值冲突是采用红黑树进行处理</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">            <span class="comment">// 强转为TreeNode，插入黑红树(本篇文章不谈黑红树的操作，具体的黑红树操作看后续博文，下同)</span></div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="comment">// 否则就是采用链表处理hash值冲突</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 遍历冲突链表, binCount记录hash值冲突链表中节点个数</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="comment">// //当遍历到冲突链表的尾部时</span></div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">// 冲突链表节点大于8个</span></div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        <span class="comment">// 红黑树化</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果在冲突链表中找到相同key值的节点，直接用新的value覆盖原来的value值即可</span></div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="comment">// 判断onlyIfAbsent是否覆盖</span></div><div class="line">            <span class="comment">// true表示仅当&lt;key,value&gt;不存在时进行插入, 为false表示强制覆盖</span></div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            <span class="comment">// 处理访问回调动作</span></div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 修改次数自增</span></div><div class="line">    ++modCount;</div><div class="line">    <span class="comment">// 当键值对数量size达到临界值threhold后, 需要进行扩容操作</span></div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    <span class="comment">// 处理插入回调动作</span></div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>初始化table或者对table进行扩容(默认2倍)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    <span class="comment">// //oldTab变量指向原来的数组</span></div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    <span class="comment">// 用来判断是扩容还是初始化</span></div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line">    <span class="comment">// oldThr变量保存原来数组的阈值</span></div><div class="line">    <span class="keyword">int</span> oldThr = threshold;</div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 如果原来就有东西，就进行扩容操作</span></div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 当大于最大容量时，不扩容，只是改变阈值</span></div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span> oldTab;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// &lt;&lt; 表示乘以2，变为原来的2倍（在操作默认大小的情况下）</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            <span class="comment">// 新阈值也变为原来的2倍</span></div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// oldCap=0, 说明原来的table数组为null，开始初始化</span></div><div class="line">    <span class="comment">// 新创建的容器容量为原来容器中设定的临界值（16）</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line">        newCap = oldThr;</div><div class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line">        <span class="comment">// 在没有设置阈值的情况下</span></div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        <span class="comment">// 初始阈值=默认负载因子*默认初始化容量</span></div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 这里对应的设置了阈值的情况下的初始化，设置阈值</span></div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 给threshold复制，这里应该也就解答了再构造那节提出的疑问了</span></div><div class="line">    threshold = newThr;</div><div class="line">    <span class="comment">// 创建新数组</span></div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 如果原来的数组中存在值, 需要将原来数组中的值保存到新数组中</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;、</div><div class="line">                <span class="comment">// 释放的对象及时置空，等待gc回收</span></div><div class="line">                oldTab[j] = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                    <span class="comment">// 重新hash进入新的数组</span></div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">                    <span class="comment">//如果原来这个节点已经转化为红黑树了，</span></div><div class="line">                    <span class="comment">//那么我们去将树上的节点rehash之后根据hash值放到新地方</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">                    <span class="comment">// 这说明原来数组中保存的hash值存在冲突, 但是并没有采用红黑树对冲突的Hash值进行管理, 而是采用Node链表进行管理</span></div><div class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        <span class="comment">// 如果为真，表明在扩容后(e.hash &amp; (newCap - 1))还会和e.hash &amp; (oldCap - 1)一样</span></div><div class="line">                        <span class="comment">// 如果为假，表名这些节点将hash在（当前下标 + oldCap）下</span></div><div class="line">                        <span class="comment">// 不懂的可以在思考🤔一下,使用这种操作，可以减少重新Hash计算</span></div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                loHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                hiHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        loTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        hiTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// //返回新数组的引用</span></div><div class="line">    <span class="keyword">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//删除key对应的键值对</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</div><div class="line">        <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 删除节点</span></div><div class="line"><span class="comment">// 参数hash为key的hash值;</span></div><div class="line"><span class="comment">// 参数key为要删除的key键;</span></div><div class="line"><span class="comment">// 参数value为key对应的value;</span></div><div class="line"><span class="comment">// 参数matchValue为true表明只有key在HashMap中对应值为value时才删除; 为false表示强制删除;</span></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></div><div class="line">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</div><div class="line">    <span class="comment">// 在table中查找对应hash值</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</div><div class="line">        <span class="comment">// 当头节点就匹配到了</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            node = p;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 如果头节点是个树节点</span></div><div class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                <span class="comment">// 从红黑树中找取节点</span></div><div class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 从链表中找取节点</span></div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key ||</div><div class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">                        node = e;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    p = e;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 匹配找到的节点的值</span></div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</div><div class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</div><div class="line">            <span class="comment">// 树中</span></div><div class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</div><div class="line">                <span class="comment">// 首节点</span></div><div class="line">                tab[index] = node.next;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="comment">// 链表中</span></div><div class="line">                p.next = node.next;</div><div class="line">            ++modCount;</div><div class="line">            --size;</div><div class="line">            afterNodeRemoval(node);</div><div class="line">            <span class="comment">// 返回删除的节点</span></div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="改"><a href="#改" class="headerlink" title="改"></a>改</h1><p>改变对应key的值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e; V v;</div><div class="line">    <span class="comment">// 根据key找出节点</span></div><div class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">        ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</div><div class="line">        e.value = newValue;</div><div class="line">        afterNodeAccess(e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">    <span class="comment">// 找出桶的头结点</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 判断头节点</span></div><div class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 在树中找</span></div><div class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">            <span class="comment">// 在链表中找</span></div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><p>根据key查找值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="comment">// 这里的getNode和上面解析的一样</span></div><div class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="external">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）</a></li>
<li><a href="https://www.cnblogs.com/zhengwang/p/8136164.html" target="_blank" rel="external">HashMap中的hash函数</a></li>
<li><a href="https://blog.csdn.net/carson_ho/article/details/79373134" target="_blank" rel="external">强推👍：Java源码分析：关于 HashMap 1.8 的重大更新</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在Collection接口中用的最多的是ArrayList，在Map接口中用的最多的一定是HashMap，我们今天就来看看HashMap！
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="HashMap" scheme="http://bestlixiang.site/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析——ArrayList</title>
    <link href="http://bestlixiang.site/2018/09/02/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ArrayList/"/>
    <id>http://bestlixiang.site/2018/09/02/JDK源码分析/JDK源码分析——ArrayList/</id>
    <published>2018-09-02T02:16:31.000Z</published>
    <updated>2018-09-02T05:03:20.174Z</updated>
    
    <content type="html"><![CDATA[<p>引：大家在集合框架中用的最多一定是ArrayList吧，今天我们就来一探究竟！<a id="more"></a></p>
<p>详细注释：<a href="https://github.com/todorex/JDK" target="_blank" rel="external">源码分析地址</a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>ArrayList是基于可变数组实现了，允许包括 null 在内的所有元素。</p>
<p>每个 ArrayList 实例都有一个容量。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向 ArrayList 中不断添加元素，其容量也自动增长。</p>
<p>在添加大量元素前，应用程序可以使用 ensureCapacity 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。</p>
<p><strong>注意：</strong> 此实现不是同步的。如果多个线程同时访问一个 ArrayList 实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。（结构上的修改是指任何添加或删除一个或多个元素的操作，或者显式调整底层数组的大小；仅仅设置元素的值不是结构上的修改。）这一般通过对自然封装该列表的对象进行同步操作来完成。如果不存在这样的对象，则应该使用 Collections.synchronizedList 方法将该列表“包装”起来。这最好在创建时完成，以防止意外对列表进行不同步的访问。</p>
<p>此类的 iterator 和 listIterator 方法返回的迭代器是快速失败的：在创建迭代器之后，除非通过迭代器自身的 remove 或 add 方法从结构上对列表进行修改，否则在任何时间以任何方式对列表进行修改，迭代器都会抛出 ConcurrentModificationException。</p>
<p>ArrayList从类 java.util.AbstractList 继承了字段 modCount，在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。</p>
<h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认数组初始大小为10</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 返回空数组</span></div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 新增元素</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="comment">// 确保容量足够</span></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// 如果是默认创建的数组，则和容量默认值比较</span></div><div class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 确保容量足够</span></div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// 修改操作加1</span></div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="comment">// 如果需要的容量比数组长度大，则进行扩容</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>) grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="comment">// 新容量将使原来的1.5倍</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">    <span class="comment">// 1.5倍还不够的话，就将容量设置为需要的大小</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) newCapacity = minCapacity;</div><div class="line">    <span class="comment">// 如果新容量比最大的数组容量（Integer.MAX_VALUE - 8;）还要大，则创建更大的容量（Integer.MAX_VALUE）</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">    <span class="comment">// Arrays.copyOf() 是把原数组整个复制到新数组，这个代价很高</span></div><div class="line">    <span class="comment">// 因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">        Integer.MAX_VALUE :</div><div class="line">        MAX_ARRAY_SIZE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><p>删除需要将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，所以ArrayList 删除元素的代价是非常高的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// 验证index是否超出size大小</span></div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// 拿到值</span></div><div class="line">    E oldValue = elementData(index);</div><div class="line">    <span class="comment">// 统计要移动的位数</span></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        <span class="comment">// 调用系统方法开始拷贝</span></div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    <span class="comment">// 即时放开引用，等待GC</span></div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line">    <span class="comment">// 返回被删除的元素</span></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="改"><a href="#改" class="headerlink" title="改"></a>改</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    <span class="comment">// 验证index是否超出size大小</span></div><div class="line">    rangeCheck(index);</div><div class="line">    <span class="comment">// 拿出原值</span></div><div class="line">    E oldValue = elementData(index);</div><div class="line">    <span class="comment">// 设置新值</span></div><div class="line">    elementData[index] = element;</div><div class="line">    <span class="comment">// 返回被替换的值</span></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// 验证index是否超出size大小</span></div><div class="line">    rangeCheck(index);</div><div class="line">    <span class="keyword">return</span> elementData(index);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// 拿出值</span></div><div class="line">    <span class="keyword">return</span> (E) elementData[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化</span></div><div class="line"><span class="keyword">transient</span> Object[] elementData;</div><div class="line"></div><div class="line"><span class="comment">// 序列化</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></div><div class="line">    <span class="keyword">throws</span> java.io.IOException&#123;</div><div class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></div><div class="line">    <span class="comment">// 记录修改次数，后面可以根据他判断结构是否发生了变化</span></div><div class="line">    <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line">    <span class="comment">// 写入非静态，非暂时数据到流中</span></div><div class="line">    s.defaultWriteObject();</div><div class="line"></div><div class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></div><div class="line">    <span class="comment">// 写入元素个数</span></div><div class="line">    s.writeInt(size);</div><div class="line"></div><div class="line">    <span class="comment">// Write out all elements in the proper order.</span></div><div class="line">    <span class="comment">// 写入元素</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">        s.writeObject(elementData[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。</span></div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 反序列化</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></div><div class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</div><div class="line">    elementData = EMPTY_ELEMENTDATA;</div><div class="line"></div><div class="line">    <span class="comment">// Read in size, and any hidden stuff</span></div><div class="line">    s.defaultReadObject();</div><div class="line"></div><div class="line">    <span class="comment">// Read in capacity</span></div><div class="line">    s.readInt(); <span class="comment">// ignored</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></div><div class="line">        ensureCapacityInternal(size);</div><div class="line"></div><div class="line">        Object[] a = elementData;</div><div class="line">        <span class="comment">// Read in all elements in the proper order.</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">            a[i] = s.readObject();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：大家在集合框架中用的最多一定是ArrayList吧，今天我们就来一探究竟！
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="ArrayList" scheme="http://bestlixiang.site/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>RPC知识</title>
    <link href="http://bestlixiang.site/2018/08/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1/RPC%E7%9F%A5%E8%AF%86/"/>
    <id>http://bestlixiang.site/2018/08/10/微服务/RPC知识/</id>
    <published>2018-08-10T06:17:52.000Z</published>
    <updated>2018-08-10T06:22:16.009Z</updated>
    
    <content type="html"><![CDATA[<p>引：转自<a href="https://www.cnkirito.moe" target="_blank" rel="external">徐靖峰|个人博客</a>的<a href="https://www.cnkirito.moe/categories/RPC/" target="_blank" rel="external">RPC专栏</a>，了解这些才能去看看RPC框架！！！<a id="more"></a></p>
<h1 id="RPC系列博客"><a href="#RPC系列博客" class="headerlink" title="RPC系列博客"></a>RPC系列博客</h1><ol>
<li><a href="https://www.cnkirito.moe/easy-know-rpc/" target="_blank" rel="external">简单了解RPC实现原理</a></li>
<li><a href="https://www.cnkirito.moe/rpc-serialize-1/" target="_blank" rel="external">深入理解RPC之序列化篇–Kryo</a></li>
<li><a href="深入理解RPC之序列化篇--总结篇">深入理解RPC之序列化篇–总结篇</a></li>
<li><a href="https://www.cnkirito.moe/rpc-dynamic-proxy/" target="_blank" rel="external">深入理解RPC之动态代理篇</a></li>
<li><a href="https://www.cnkirito.moe/rpc-transport/" target="_blank" rel="external">深入理解 RPC 之传输篇</a></li>
<li><a href="https://www.cnkirito.moe/motan-async/" target="_blank" rel="external">Motan中使用异步RPC接口</a></li>
<li><a href="https://www.cnkirito.moe/rpc-protocol/" target="_blank" rel="external">深入理解RPC之协议篇</a></li>
<li><a href="https://www.cnkirito.moe/rpc-registry/" target="_blank" rel="external">深入理解RPC之服务注册与发现篇</a></li>
<li><a href="https://www.cnkirito.moe/rpc-cluster/" target="_blank" rel="external">深入理解 RPC 之集群篇</a></li>
<li><a href="https://www.cnkirito.moe/rpc-interface-design/" target="_blank" rel="external">设计RPC接口时，你有考虑过这些吗？</a></li>
</ol>
<h1 id="简单RPC"><a href="#简单RPC" class="headerlink" title="简单RPC"></a>简单RPC</h1><p>可以参考<a href="https://github.com/todorex/rex_rpc" target="_blank" rel="external">todorex/rex_rpc</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：转自&lt;a href=&quot;https://www.cnkirito.moe&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;徐靖峰|个人博客&lt;/a&gt;的&lt;a href=&quot;https://www.cnkirito.moe/categories/RPC/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RPC专栏&lt;/a&gt;，了解这些才能去看看RPC框架！！！
    
    </summary>
    
      <category term="微服务" scheme="http://bestlixiang.site/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="rpc" scheme="http://bestlixiang.site/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码之编码器</title>
    <link href="http://bestlixiang.site/2018/08/06/Netty%E6%BA%90%E7%A0%81/Netty%E6%BA%90%E7%A0%81%E4%B9%8B%E7%BC%96%E7%A0%81%E5%99%A8/"/>
    <id>http://bestlixiang.site/2018/08/06/Netty源码/Netty源码之编码器/</id>
    <published>2018-08-06T08:07:52.000Z</published>
    <updated>2018-08-06T08:19:22.107Z</updated>
    
    <content type="html"><![CDATA[<p>引：上一篇博文讲了解码器对应了读事件，这次就讲一下编码器，对应了写事件。<a id="more"></a></p>
<h1 id="编码器基类"><a href="#编码器基类" class="headerlink" title="编码器基类"></a>编码器基类</h1><p>在Netty中解码器的基类是<strong>MessageToByteEncoder<i> </i></strong>，然后我们要明白的是MessageToByteEncoder其实是一个ChannelOutboundHandlerAdapter。</p>
<p>我们在使用的过程中主要就是覆写它的encode方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, I msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception</span>;</div></pre></td></tr></table></figure>
<p>一个编码器编码的过程主要有如下6个步骤：</p>
<ol>
<li>匹配对象</li>
<li>分配内存</li>
<li>编码实现</li>
<li>释放对象</li>
<li>传播数据</li>
<li>释放内存</li>
</ol>
<p>当我们知道MessageToByteEncoder是一个Handler的时候，我们就会去找它对事件的处理方法，主要是写事件，所以我们找到写事件处理方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    ByteBuf buf = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 判断是否能够处理该对象</span></div><div class="line">        <span class="comment">// step 2</span></div><div class="line">        <span class="keyword">if</span> (acceptOutboundMessage(msg)) &#123;</div><div class="line">            <span class="comment">// 能处理</span></div><div class="line">            I cast = (I) msg;</div><div class="line">            <span class="comment">// 内存分配(默认分配堆外内存 )</span></div><div class="line">            buf = allocateBuffer(ctx, cast, preferDirect);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 开始调用我们覆写的encode方法了</span></div><div class="line">                encode(ctx, cast, buf);</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="comment">// 释放对象</span></div><div class="line">                ReferenceCountUtil.release(cast);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (buf.isReadable()) &#123;</div><div class="line">                <span class="comment">// 传播数据，一直传播到head节点处理</span></div><div class="line">                ctx.write(buf, promise);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 如果编码没有成功，则是否内存</span></div><div class="line">                buf.release();</div><div class="line">                ctx.write(Unpooled.EMPTY_BUFFER, promise);</div><div class="line">            &#125;</div><div class="line">            buf = <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 不能处理，则继续传播</span></div><div class="line">            ctx.write(msg, promise);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span>(EncoderException e) &#123;</div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125; <span class="keyword">catch</span>(Throwable e) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EncoderException(e);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</div><div class="line">            buf.release();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> TypeParameterMatcher matcher;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acceptOutboundMessage</span><span class="params">(Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    <span class="keyword">return</span> matcher.match(msg);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// 主要就是判断msg是否是MessageToByteEncoder&lt;I&gt;中的I类型</span></div><div class="line">    <span class="keyword">return</span> type.isInstance(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h1><p>之前自己在ChannelPipeline那章分析到HeadContext的write方法，没有继续往下分析，我们在这里分析：</p>
<p>它主要有这么几个过程：</p>
<ol>
<li>direct化ByteBuf</li>
<li>插入写链表</li>
<li>设置写状态</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    unsafe.write(msg, promise);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</div><div class="line">	<span class="comment">// 该对象负责缓冲写进来的数据</span></div><div class="line">    估算出需要写入的ByteBuf的size outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">    <span class="keyword">int</span> size;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 将待写入的对象过滤,把所有的非直接内存转换成直接内存DirectBuffer</span></div><div class="line">        <span class="comment">// step 3</span></div><div class="line">        msg = filterOutboundMessage(msg);</div><div class="line">        <span class="comment">// 估算出需要写入的ByteBuf的size</span></div><div class="line">        size = pipeline.estimatorHandle().size(msg);</div><div class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</div><div class="line">            size = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span>(Throwable t) &#123;</div><div class="line">        safeSetFailure(promise, t);</div><div class="line">        ReferenceCountUtil.release(msg);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 将信息添加到估算出需要写入的ByteBuf的size</span></div><div class="line">    <span class="comment">// step 4</span></div><div class="line">    outboundBuffer.addMessage(msg, size, promise);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">filterOutboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</div><div class="line">        ByteBuf buf = (ByteBuf) msg;</div><div class="line">        <span class="keyword">if</span> (buf.isDirect()) &#123;</div><div class="line">            <span class="keyword">return</span> msg;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 转换成直接内存DirectBuffer</span></div><div class="line">        <span class="keyword">return</span> newDirectBuffer(buf);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FileRegion) &#123;</div><div class="line">        <span class="keyword">return</span> msg;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4 ChannelOutboundBuffer</span></div><div class="line"><span class="comment">// 一个链表</span></div><div class="line"><span class="comment">// Entry(flushedEntry) --&gt; ... Entry(unflushedEntry) --&gt; ... Entry(tailEntry)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 指向第一个已经flush的节点</span></div><div class="line"><span class="keyword">private</span> Entry flushedEntry;</div><div class="line"><span class="comment">// 指向第一个未flush的节点</span></div><div class="line"><span class="keyword">private</span> Entry unflushedEntry;</div><div class="line"><span class="comment">// 指向末尾节点</span></div><div class="line"><span class="keyword">private</span> Entry tailEntry;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMessage</span><span class="params">(Object msg, <span class="keyword">int</span> size, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 关注这三个指针tailEntry、tailEntry、unflushedEntry</span></div><div class="line">    <span class="comment">// 先包装成一个Entry</span></div><div class="line">    Entry entry = Entry.newInstance(msg, size, total(msg), promise);</div><div class="line">    <span class="comment">// 插入链表</span></div><div class="line">    <span class="keyword">if</span> (tailEntry == <span class="keyword">null</span>) &#123;</div><div class="line">        flushedEntry = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Entry tail = tailEntry;</div><div class="line">        tail.next = entry;</div><div class="line">    &#125;</div><div class="line">    tailEntry = entry;</div><div class="line">    <span class="keyword">if</span> (unflushedEntry == <span class="keyword">null</span>) &#123;</div><div class="line">        unflushedEntry = entry;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 统计当前需要写入到Socket缓存区的字节</span></div><div class="line">    <span class="comment">// step 5</span></div><div class="line">    incrementPendingOutboundBytes(entry.pendingSize, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 5</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">incrementPendingOutboundBytes</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">boolean</span> invokeLater)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(<span class="keyword">this</span>, size);</div><div class="line">    <span class="comment">// 默认缓冲区不能超过64个字节</span></div><div class="line">    <span class="keyword">if</span> (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) &#123;</div><div class="line">        <span class="comment">// 设置写状态</span></div><div class="line">        setUnwritable(invokeLater);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 6</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUnwritable</span><span class="params">(<span class="keyword">boolean</span> invokeLater)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldValue = unwritable;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newValue = oldValue | <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (UNWRITABLE_UPDATER.compareAndSet(<span class="keyword">this</span>, oldValue, newValue)) &#123;</div><div class="line">            <span class="keyword">if</span> (oldValue == <span class="number">0</span> &amp;&amp; newValue != <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 传播不能写事件</span></div><div class="line">                fireChannelWritabilityChanged(invokeLater);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="flush"><a href="#flush" class="headerlink" title="flush()"></a>flush()</h1><p>write不能写了就需要flush了，我们同样也从HeadContext的flush方法开始分析：</p>
<p>它主要有这么几个步骤：</p>
<ol>
<li>添加刷新标志并设置写状态</li>
<li>遍历buffer队列，过滤ByteBuf</li>
<li>调用JDK底层的API进行自旋写</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    unsafe.flush();</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</div><div class="line">    ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    outboundBuffer.addFlush();</div><div class="line">    <span class="comment">// step 5</span></div><div class="line">    flush0();</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFlush</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 指向unflushedEntry</span></div><div class="line">    Entry entry = unflushedEntry;</div><div class="line">    <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (flushedEntry == <span class="keyword">null</span>) &#123;</div><div class="line">            flushedEntry = entry;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="comment">// 设置flush的数量</span></div><div class="line">            flushed++;</div><div class="line">            <span class="keyword">if</span> (!entry.promise.setUncancellable()) &#123;</div><div class="line">                <span class="keyword">int</span> pending = entry.cancel();</div><div class="line">                <span class="comment">// step 4</span></div><div class="line">                decrementPendingOutboundBytes(pending, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">            &#125;</div><div class="line">            entry = entry.next;</div><div class="line">        &#125; <span class="keyword">while</span> ( entry != <span class="keyword">null</span> );</div><div class="line">		<span class="comment">// 将unflushedEntry设置为null</span></div><div class="line">        unflushedEntry = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementPendingOutboundBytes</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">boolean</span> invokeLater, <span class="keyword">boolean</span> notifyWritability)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(<span class="keyword">this</span>, -size);</div><div class="line">    <span class="comment">// 默认缓冲区低于32个字节，则可设置可写</span></div><div class="line">    <span class="keyword">if</span> (notifyWritability &amp;&amp; newWriteBufferSize &lt; channel.config().getWriteBufferLowWaterMark()) &#123;</div><div class="line">        <span class="comment">// 设置可写状态</span></div><div class="line">        setWritable(invokeLater);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 5</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">flush0</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</div><div class="line">    <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span> || outboundBuffer.isEmpty()) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">    <span class="comment">// step 6</span></div><div class="line">    doWrite(outboundBuffer);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 6 NioSocketChannel</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 拿到底层的SocketChannel准备开始底层的操作</span></div><div class="line">    SocketChannel ch = javaChannel();</div><div class="line">    <span class="comment">// 获取循环次数，相当于一个自旋锁，默认16</span></div><div class="line">    <span class="keyword">int</span> writeSpinCount = config().getWriteSpinCount();</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="comment">// 如果buffer里空的</span></div><div class="line">        <span class="keyword">if</span> ( in .isEmpty()) &#123;</div><div class="line">            <span class="comment">// 清理OP_WRITE，防止Reacotr线程再次处理这个Channel</span></div><div class="line">            clearOpWrite();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获取聚合写的最大字节数，默认Integer.MAX_VALUE</span></div><div class="line">        <span class="keyword">int</span> maxBytesPerGatheringWrite = ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();</div><div class="line">        <span class="comment">// 把ByteBuf里的数据写到原生Buffer里</span></div><div class="line">        <span class="comment">// step 7</span></div><div class="line">        ByteBuffer[] nioBuffers = in.nioBuffers(<span class="number">1024</span>, maxBytesPerGatheringWrite);</div><div class="line">        <span class="keyword">int</span> nioBufferCnt = in.nioBufferCount();</div><div class="line">        <span class="comment">// 对非Buffer对象（FileRegion）的数据进行普通的读写</span></div><div class="line">        <span class="keyword">switch</span> (nioBufferCnt) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">0</span>:    </div><div class="line">            <span class="comment">// 没成功，自旋一次</span></div><div class="line">            writeSpinCount -= doWrite0( in );</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">                <span class="comment">// JDK NIO 支持一次写单个ByteBuffer 以及 一次写多个ByteBuffer的聚集写模式</span></div><div class="line">                <span class="comment">// 如果只有一个buffer的情况下，直接把这个buffer写进去</span></div><div class="line">                ByteBuffer buffer = nioBuffers[<span class="number">0</span>];</div><div class="line">                <span class="keyword">int</span> attemptedBytes = buffer.remaining();</div><div class="line">                <span class="comment">// 调用JDK底层的API进行写，完毕</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> localWrittenBytes = ch.write(buffer);</div><div class="line">                <span class="keyword">if</span> (localWrittenBytes &lt;= <span class="number">0</span>) &#123;</div><div class="line">                    incompleteWrite(<span class="keyword">true</span>);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);</div><div class="line">                <span class="comment">// 释放缓存对象</span></div><div class="line">                in.removeBytes(localWrittenBytes);</div><div class="line">                --writeSpinCount;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            &#123;</div><div class="line">                 <span class="comment">// 多个buffer的情况下，写nioBufferCnt个buffer进去</span></div><div class="line">                <span class="keyword">long</span> attemptedBytes = in.nioBufferSize();</div><div class="line">                <span class="keyword">final</span> <span class="keyword">long</span> localWrittenBytes = ch.write(nioBuffers, <span class="number">0</span>, nioBufferCnt);</div><div class="line">                <span class="keyword">if</span> (localWrittenBytes &lt;= <span class="number">0</span>) &#123;</div><div class="line">                    incompleteWrite(<span class="keyword">true</span>);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                adjustMaxBytesPerGatheringWrite((<span class="keyword">int</span>) attemptedBytes, (<span class="keyword">int</span>) localWrittenBytes, maxBytesPerGatheringWrite); in .removeBytes(localWrittenBytes); --writeSpinCount;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">while</span> ( writeSpinCount &gt; <span class="number">0</span> );</div><div class="line"></div><div class="line">    incompleteWrite(writeSpinCount &lt; <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>知道write和flush那么就很容易理解writeAndFlush啦！！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/feaeaab2ce56" target="_blank" rel="external">etty源码分析之writeAndFlush全解析</a></li>
<li><a href="http://wyj.shiwuliang.com/2018/06/28/Netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94flush%E6%B5%81%E7%A8%8B/" target="_blank" rel="external">Netty源码分析——flush流程</a></li>
<li><a href="https://www.jianshu.com/p/a3443cacd081" target="_blank" rel="external">Netty 源码解析 ——— writeAndFlush流程分析</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：上一篇博文讲了解码器对应了读事件，这次就讲一下编码器，对应了写事件。
    
    </summary>
    
      <category term="Netty源码" scheme="http://bestlixiang.site/categories/Netty%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Netty" scheme="http://bestlixiang.site/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码之解码器</title>
    <link href="http://bestlixiang.site/2018/08/06/Netty%E6%BA%90%E7%A0%81/Netty%E6%BA%90%E7%A0%81%E4%B9%8B%E8%A7%A3%E7%A0%81%E5%99%A8/"/>
    <id>http://bestlixiang.site/2018/08/06/Netty源码/Netty源码之解码器/</id>
    <published>2018-08-06T08:07:37.000Z</published>
    <updated>2018-08-06T08:14:29.964Z</updated>
    
    <content type="html"><![CDATA[<p>引：Netty在帮我们解决性能的同时，也提供了丰富的编解码器来为我们业务上提供便利，这次我们就来看看Netty的解码器。<a id="more"></a></p>
<h1 id="解码器基类"><a href="#解码器基类" class="headerlink" title="解码器基类"></a>解码器基类</h1><p><strong>解码：</strong>就是将二进制数据流解码为自定义数据包。</p>
<p>在Netty中解码器的基类是<strong>ByteToMessageDecoder</strong>，然后我们要明白的是ByteToMessageDecoder其实是一个ChannelInboundHandlerAdapter。</p>
<p>一个解码器解码的过程主要有如下三个步骤：</p>
<ol>
<li>累加字节流</li>
<li>调用子类的decode方法进行解析</li>
<li>将解析到的ByteBuf向下传播</li>
</ol>
<p>当我们知道ByteToMessageDecoder是一个Handler的时候，我们就会去找它对事件的处理方法，主要是读事件，所以我们找到读事件处理方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line">ByteBuf cumulation;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 解码器是相对于ByteBuf进行解码的(在入站的时候已经封装好了，可以参考自己之前关于Pipeline的博文)</span></div><div class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</div><div class="line">        <span class="comment">// 存储解码后的数据 List</span></div><div class="line">        CodecOutputList out = CodecOutputList.newInstance();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ByteBuf data = (ByteBuf) msg;</div><div class="line">            <span class="comment">// 是否是第一次累加</span></div><div class="line">            first = cumulation == <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (first) &#123;</div><div class="line">                <span class="comment">// 第一次</span></div><div class="line">                cumulation = data;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 不是第一次，则进行累加</span></div><div class="line">                <span class="comment">// 我们看看这个累加器的cumulate方法 step 2</span></div><div class="line">                cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 调用子类的decode方法进行解析</span></div><div class="line">            <span class="comment">// step 3</span></div><div class="line">            callDecode(ctx, cumulation, out);</div><div class="line">        &#125; <span class="keyword">catch</span>(DecoderException e) &#123;</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(e);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">int</span> size = out.size();</div><div class="line">            decodeWasNull = !out.insertSinceRecycled();</div><div class="line">            <span class="comment">// 将解析到的对象向下继续传播</span></div><div class="line">            <span class="comment">// step 5</span></div><div class="line">            fireChannelRead(ctx, out, size);</div><div class="line">            <span class="comment">// 回收list</span></div><div class="line">            out.recycle();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 不是ByteBuf就直接向下传播</span></div><div class="line">        ctx.fireChannelRead(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">cumulate</span><span class="params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in )</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ByteBuf buffer;</div><div class="line">    <span class="comment">// 当buf的数据大于cumulation的剩余容量时</span></div><div class="line">    <span class="keyword">if</span> (cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes() || cumulation.refCnt() &gt; <span class="number">1</span> || cumulation.isReadOnly()) &#123;</div><div class="line">		<span class="comment">// 进行扩容(扩容其实就是一个内存拷贝操作)</span></div><div class="line">        buffer = expandCumulation(alloc, cumulation, in.readableBytes());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 不然就不扩容</span></div><div class="line">        buffer = cumulation;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将数据写入buf</span></div><div class="line">    buffer.writeBytes(in);</div><div class="line">    <span class="comment">// 释放传入的buf</span></div><div class="line">    in.release();</div><div class="line">    <span class="keyword">return</span> buffer;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">callDecode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in , List &lt; Object &gt; out)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> ( in .isReadable()) &#123;</div><div class="line">        <span class="keyword">int</span> outSize = out.size();</div><div class="line">        <span class="comment">// 看list是否有对象</span></div><div class="line">        <span class="keyword">if</span> (outSize &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 有对象则将list传播出去</span></div><div class="line">            fireChannelRead(ctx, out, outSize);</div><div class="line">            <span class="comment">// 并清空list</span></div><div class="line">            out.clear();</div><div class="line">            outSize = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 记录可读长度</span></div><div class="line">        <span class="keyword">int</span> oldInputLength = in.readableBytes();</div><div class="line">        <span class="comment">// 开始调用decode方法了</span></div><div class="line">        <span class="comment">// step 4</span></div><div class="line">        decodeRemovalReentryProtection(ctx, in, out);</div><div class="line">        <span class="comment">// 什么都没有解析出来时</span></div><div class="line">        <span class="keyword">if</span> (outSize == out.size()) &#123;</div><div class="line">            <span class="comment">// 代表当前的数据不能拼装成一个完整的数据包，break准备等待下一次数据包</span></div><div class="line">            <span class="keyword">if</span> (oldInputLength == in.readableBytes()) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">decodeRemovalReentryProtection</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in , List &lt; Object &gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">    <span class="comment">// 开始调用解码器子类的decode方法了</span></div><div class="line">    decode(ctx, in, out);</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// step 5</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fireChannelRead</span><span class="params">(ChannelHandlerContext ctx, CodecOutputList msgs, <span class="keyword">int</span> numElements)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements; i++) &#123;</div><div class="line">        <span class="comment">// msgs.getUnsafe(i)保证成byteBuf</span></div><div class="line">        <span class="comment">// 这里可能就会传播到业务的处理器</span></div><div class="line">        ctx.fireChannelRead(msgs.getUnsafe(i));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="LineBasedFrameDecoder"><a href="#LineBasedFrameDecoder" class="headerlink" title="LineBasedFrameDecoder"></a>LineBasedFrameDecoder</h1><p>我们挑选了基于分隔符解码器LineBasedFrameDecoder来分析，它可以同时处理 \n以及\r\n两种类型的行分隔符，我们看看它的decode方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1 (解码器模板)</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in , List &lt; Object &gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    Object decoded = decode(ctx, in);</div><div class="line">    <span class="keyword">if</span> (decoded != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 拆除一个数据包就放进List里</span></div><div class="line">        out.add(decoded);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2 LineBasedFrameDecoder</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> discarding;</div><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf buffer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 找到换行符位置</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> eol = findEndOfLine(buffer);</div><div class="line">    <span class="comment">// 第一次拆包不在丢弃模式下</span></div><div class="line">    <span class="keyword">if</span> (!discarding) &#123;</div><div class="line">        <span class="comment">// 非丢弃模式下</span></div><div class="line">        <span class="comment">// 找到分隔符</span></div><div class="line">        <span class="keyword">if</span> (eol &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">final</span> ByteBuf frame;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> length = eol - buffer.readerIndex();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> delimLength = buffer.getByte(eol) == <span class="string">'\r'</span> ? <span class="number">2</span> : <span class="number">1</span>;</div><div class="line">			<span class="comment">// 判断拆包的长度是否大于允许的最大长度，maxLength构造时传入</span></div><div class="line">            <span class="keyword">if</span> (length &gt; maxLength) &#123;</div><div class="line">                <span class="comment">// 超出最大长度则丢弃这段数据，抛出异常</span></div><div class="line">                buffer.readerIndex(eol + delimLength);</div><div class="line">                fail(ctx, length);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">			<span class="comment">// 解码数据是否要包含分隔符</span></div><div class="line">            <span class="keyword">if</span> (stripDelimiter) &#123;</div><div class="line">                <span class="comment">// 不包含</span></div><div class="line">                frame = buffer.readRetainedSlice(length);</div><div class="line">                buffer.skipBytes(delimLength);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 包含</span></div><div class="line">                frame = buffer.readRetainedSlice(length + delimLength);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 返回拆包后封装成的帧</span></div><div class="line">            <span class="keyword">return</span> frame;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 没找到分隔符</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> length = buffer.readableBytes();</div><div class="line">            <span class="keyword">if</span> (length &gt; maxLength) &#123;</div><div class="line">                <span class="comment">// 如果大于最大长度，进入丢弃模式</span></div><div class="line">                <span class="comment">// 保存丢弃长度</span></div><div class="line">                discardedBytes = length;</div><div class="line">                buffer.readerIndex(buffer.writerIndex());</div><div class="line">                discarding = <span class="keyword">true</span>;</div><div class="line">                offset = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span> (failFast) &#123;</div><div class="line">                    fail(ctx, <span class="string">"over "</span> + discardedBytes);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 不大于，则返回null</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 丢弃模式下</span></div><div class="line">        <span class="keyword">if</span> (eol &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 找到分割符</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> length = discardedBytes + eol - buffer.readerIndex();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> delimLength = buffer.getByte(eol) == <span class="string">'\r'</span> ? <span class="number">2</span> : <span class="number">1</span>;</div><div class="line">            buffer.readerIndex(eol + delimLength);</div><div class="line">            discardedBytes = <span class="number">0</span>;</div><div class="line">            discarding = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (!failFast) &#123;</div><div class="line">                fail(ctx, length);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 保存丢弃长度</span></div><div class="line">            discardedBytes += buffer.readableBytes();</div><div class="line">            <span class="comment">// 改变读指针位置</span></div><div class="line">            buffer.readerIndex(buffer.writerIndex());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其他的解码器也可以根据LineBasedFrameDecoder的思路去分析。当然我们最需要关注的还是整个解码器的设计思想。学会去抽象一类东西。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/dc26e944da95" target="_blank" rel="external">netty源码分析之拆包器的奥秘</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：Netty在帮我们解决性能的同时，也提供了丰富的编解码器来为我们业务上提供便利，这次我们就来看看Netty的解码器。
    
    </summary>
    
      <category term="Netty源码" scheme="http://bestlixiang.site/categories/Netty%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Netty" scheme="http://bestlixiang.site/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码之ChannelPipeline</title>
    <link href="http://bestlixiang.site/2018/08/06/Netty%E6%BA%90%E7%A0%81/Netty%E6%BA%90%E7%A0%81%E4%B9%8BChannelPipeline/"/>
    <id>http://bestlixiang.site/2018/08/06/Netty源码/Netty源码之ChannelPipeline/</id>
    <published>2018-08-06T08:07:14.000Z</published>
    <updated>2018-08-06T08:13:59.182Z</updated>
    
    <content type="html"><![CDATA[<p>引：其实前面就多次提到了ChannelPipeline，但是都没有详细说明ChannelPipeline是如何工作的，这里我们就具体看看这个管理处理逻辑的抽象以及处理逻辑的抽象ChannelHandler。<a id="more"></a></p>
<h1 id="ChannelPipeline的创建"><a href="#ChannelPipeline的创建" class="headerlink" title="ChannelPipeline的创建"></a>ChannelPipeline的创建</h1><p>通过前面的讲解，我们应该还记得一个Channel对应了一个ChannelPipeline，而ChannelPipeline也就是在创建Channel的时候随之创建的。我们就从那里开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1 AbstractChannel的创建</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.parent = parent;</div><div class="line">    id = newId();</div><div class="line">    unsafe = newUnsafe();</div><div class="line">    <span class="comment">// step 2 ChannelPipeline的创建</span></div><div class="line">    pipeline = newChannelPipeline();</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</div><div class="line">    <span class="comment">// 绑定channel</span></div><div class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</div><div class="line">    <span class="comment">// 默认创建一个由头尾节点的双向链表，我们可以看一下节点的类型</span></div><div class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</div><div class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</div><div class="line">    head.next = tail;</div><div class="line">    tail.prev = head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ChannelPipeline创建完毕！！</p>
<h1 id="节点的添加"><a href="#节点的添加" class="headerlink" title="节点的添加"></a>节点的添加</h1><p>节点的添加我们必然要从我们见过的ChannelPipeline的addLast(handler)方法开始分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    <span class="keyword">return</span> addLast(<span class="keyword">null</span>, handler);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(String name, ChannelHandler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    <span class="keyword">return</span> addLast(<span class="keyword">null</span>, name, handler);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</div><div class="line">    <span class="comment">// 同步</span></div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="comment">// 检查是否有重复节点</span></div><div class="line">        checkMultiplicity(handler);</div><div class="line">        <span class="comment">// 将handler包装成节点上下文 DefaultChannelHandlerContext</span></div><div class="line">        <span class="comment">// step 4</span></div><div class="line">        newCtx = newContext(group, filterName(name, handler), handler);</div><div class="line">        <span class="comment">// 添加节点 step 7</span></div><div class="line">        addLast0(newCtx);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 回调处理器被添加的方法</span></div><div class="line">    callHandlerAdded0(newCtx);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">newContext</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 5</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelHandlerContext(<span class="keyword">this</span>, childExecutor(group), name, handler);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 5</span></div><div class="line">DefaultChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) &#123;</div><div class="line">    <span class="comment">// step 6 isInBound,isOutBount已经确定了</span></div><div class="line">    <span class="keyword">super</span>(pipeline, executor, name, isInbound(handler), isOutbound(handler));</div><div class="line">	<span class="comment">// 绑定handler</span></div><div class="line">    <span class="keyword">this</span>.handler = handler;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 6</span></div><div class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name, <span class="keyword">boolean</span> inbound, <span class="keyword">boolean</span> outbound) &#123;</div><div class="line">    <span class="comment">// 设定名字</span></div><div class="line">    <span class="keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">"name"</span>);</div><div class="line">    <span class="comment">// 绑定pipeline</span></div><div class="line">    <span class="keyword">this</span>.pipeline = pipeline;</div><div class="line">    <span class="comment">// 绑定NioEventLoop</span></div><div class="line">    <span class="keyword">this</span>.executor = executor;</div><div class="line">    <span class="comment">// 表示自己是inbound处理器还是outbound处理器，后面根据这个值来判断</span></div><div class="line">    <span class="keyword">this</span>.inbound = inbound;</div><div class="line">    <span class="keyword">this</span>.outbound = outbound;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 7</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLast0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</div><div class="line">    <span class="comment">// 添加到Pipeline的那个双向链表中</span></div><div class="line">    AbstractChannelHandlerContext prev = tail.prev;</div><div class="line">    newCtx.prev = prev;</div><div class="line">    newCtx.next = tail;</div><div class="line">    prev.next = newCtx;</div><div class="line">    tail.prev = newCtx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="节点的删除"><a href="#节点的删除" class="headerlink" title="节点的删除"></a>节点的删除</h1><p>和ChannelPipeline的addLast(handler)一样，我们可以找到ChannelPipeline的remove(handler)方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">remove</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">// 我们知道节点是保证了handler的AbstractChannelHandlerContext</span></div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    remove(getContextOrDie(handler));</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">remove</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> ctx != head &amp;&amp; ctx != tail;</div><div class="line">	<span class="comment">// 同步</span></div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="comment">// step 3</span></div><div class="line">        remove0(ctx);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 回调节点的删除方法</span></div><div class="line">    callHandlerRemoved0(ctx);</div><div class="line">    <span class="keyword">return</span> ctx;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove0</span><span class="params">(AbstractChannelHandlerContext ctx)</span> </span>&#123;</div><div class="line">    <span class="comment">// 就是双向链表的删除</span></div><div class="line">    AbstractChannelHandlerContext prev = ctx.prev;</div><div class="line">    AbstractChannelHandlerContext next = ctx.next;</div><div class="line">    prev.next = next;</div><div class="line">    next.prev = prev;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="入站事件的传播"><a href="#入站事件的传播" class="headerlink" title="入站事件的传播"></a>入站事件的传播</h1><p>其实我们应该已经经历过了，源头都是在从Unsafe对象(它负责最底层的IO操作)出发的，所以我们从NioEventLoop的这一段代码出发：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">    <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 接受IO事件，这里需要注意的是在SeverSocketChannel和SocketChannel处理的事件是不一样的</span></div><div class="line">        <span class="comment">// 我们主要分析SocketChannel的读事件，对应的Unsafe对象是NioByteUnSafe</span></div><div class="line">        <span class="comment">// step 2</span></div><div class="line">        unsafe.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2 AbstractNioByteChannel的NioByteUnSafe</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ChannelConfig config = config();</div><div class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</div><div class="line">    <span class="comment">// 创建ByteBuf分配器</span></div><div class="line">    <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</div><div class="line">    <span class="comment">// 控制连接数</span></div><div class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</div><div class="line">    allocHandle.reset(config);</div><div class="line"></div><div class="line">    ByteBuf byteBuf = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="comment">// 分配一个byteBuf</span></div><div class="line">        byteBuf = allocHandle.allocate(allocator);</div><div class="line">        <span class="comment">// 读数据</span></div><div class="line">        allocHandle.lastBytesRead(doReadBytes(byteBuf));</div><div class="line">        allocHandle.incMessagesRead(<span class="number">1</span>);</div><div class="line">        readPending = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">// 触发读事件，这是我们要关注的重点</span></div><div class="line">        <span class="comment">// step 3</span></div><div class="line">        pipeline.fireChannelRead(byteBuf);</div><div class="line">        byteBuf = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">while</span> ( allocHandle . continueReading ());</div><div class="line"></div><div class="line">    allocHandle.readComplete();</div><div class="line">    <span class="comment">// 触发读完成事件</span></div><div class="line">    pipeline.fireChannelReadComplete();</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// 出发头节点的读事件</span></div><div class="line">    <span class="comment">// step 4</span></div><div class="line">    AbstractChannelHandlerContext.invokeChannelRead(head, msg);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">"msg"</span>), next);</div><div class="line">    <span class="comment">// 调用头节点的channelRead方法</span></div><div class="line">    <span class="comment">// step 5</span></div><div class="line">    next.invokeChannelRead(m);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 5</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// 调用头节点的channelRead方法</span></div><div class="line">    <span class="comment">// step 6</span></div><div class="line">    ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 6</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 继续传递读事件</span></div><div class="line">    <span class="comment">// step 7</span></div><div class="line">    ctx.fireChannelRead(msg);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 7</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// 找到下一个入站节点</span></div><div class="line">    <span class="comment">// step 8 findContextInbound</span></div><div class="line">    <span class="comment">// step 9 会重复这个过程，如果消息没有被释放，那么将一直传递到tail节点(最后一个inbound节点public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span></div><div class="line">    onUnhandledInboundMessage(msg);</div><div class="line">&#125;)</div><div class="line">    invokeChannelRead(findContextInbound(), msg);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 8</span></div><div class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">()</span> </span>&#123;</div><div class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        ctx = ctx.next;</div><div class="line">        <span class="comment">// 可以看到是根据标志位来判定的</span></div><div class="line">    &#125; <span class="keyword">while</span> (! ctx . inbound );</div><div class="line">    <span class="keyword">return</span> ctx;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 9 DefaultChannelPipeline的TailContext</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// step 10</span></div><div class="line">    onUnhandledInboundMessage(msg);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// 如果消息一直没有被释放，将在tail节点被释放</span></div><div class="line">    ReferenceCountUtil.release(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="出站事件的传播"><a href="#出站事件的传播" class="headerlink" title="出站事件的传播"></a>出站事件的传播</h1><p>出站事件一般是写事件，有两种写需要区别一下：（来自netty源码中telnet例子）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ChannelFuture future = ctx.channel().write(response);   <span class="comment">// 1</span></div><div class="line">ChannelFuture future = ctx.write(response); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>我们先看第一种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String request)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    ChannelFuture future = ctx.channel().write(response);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2 AbstractChannel</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    <span class="keyword">return</span> pipeline.write(msg);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3 DefaultChannelPipeline</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">write</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// 直接调用tail的写方法</span></div><div class="line">    <span class="comment">// step 4</span></div><div class="line">    <span class="keyword">return</span> tail.write(msg);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 5 AbstractChannelHandlerContext</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 6</span></div><div class="line">    <span class="keyword">return</span> write(msg, newPromise());</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 6 AbstractChannelHandlerContext</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(<span class="keyword">final</span> Object msg, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 加上是否flush的信息</span></div><div class="line">    <span class="comment">// step 7</span></div><div class="line">    write(msg, <span class="keyword">false</span>, promise);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 7</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 和进站相识，这里找的出站节点</span></div><div class="line">    AbstractChannelHandlerContext next = findContextOutbound();</div><div class="line">    <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</div><div class="line">    EventExecutor executor = next.executor();</div><div class="line">    <span class="keyword">if</span> (flush) &#123;</div><div class="line">        next.invokeWriteAndFlush(m, promise);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 调用下一个出站节点的写方法</span></div><div class="line">        next.invokeWrite(m, promise);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 7</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWrite</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 8    </span></div><div class="line">    invokeWrite0(msg, promise);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 8</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWrite0</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 9 会直接调用到HeadContext的write方法</span></div><div class="line">    ((ChannelOutboundHandler) handler()).write(<span class="keyword">this</span>, msg, promise);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 9</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 利用unsafe写入(明白流程就好，关于具体怎么写入将放到编码器的博文上)</span></div><div class="line">    unsafe.write(msg, promise);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String request)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    ChannelFuture future = ctx.write(response);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(<span class="keyword">final</span> Object msg, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">	<span class="comment">// 直接从当前节点写，后面就和第一种情况一样了</span></div><div class="line">    write(msg, <span class="keyword">false</span>, promise);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/6efa9c5fa702" target="_blank" rel="external">netty源码分析之pipeline(一)</a></li>
<li><a href="https://www.jianshu.com/p/087b7e9a27a2" target="_blank" rel="external">netty源码分析之pipeline(二)</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：其实前面就多次提到了ChannelPipeline，但是都没有详细说明ChannelPipeline是如何工作的，这里我们就具体看看这个管理处理逻辑的抽象以及处理逻辑的抽象ChannelHandler。
    
    </summary>
    
      <category term="Netty源码" scheme="http://bestlixiang.site/categories/Netty%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Netty" scheme="http://bestlixiang.site/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码之新连接接入</title>
    <link href="http://bestlixiang.site/2018/08/06/Netty%E6%BA%90%E7%A0%81/Netty%E6%BA%90%E7%A0%81%E4%B9%8B%E6%96%B0%E8%BF%9E%E6%8E%A5%E6%8E%A5%E5%85%A5/"/>
    <id>http://bestlixiang.site/2018/08/06/Netty源码/Netty源码之新连接接入/</id>
    <published>2018-08-06T08:06:57.000Z</published>
    <updated>2018-08-06T08:13:39.319Z</updated>
    
    <content type="html"><![CDATA[<p>引：之前对服务端和NioEventLoop都有了一定的分析，相信大家的服务端应该已经虚位以待了。好的，我们现在就开始分析<strong>新连接接入</strong>。<a id="more"></a></p>
<h1 id="新连接检测"><a href="#新连接检测" class="headerlink" title="新连接检测"></a>新连接检测</h1><p>用过NIO的人都会知道新连接检测应该在处理select出来的SelectedKey中出现，所以我们就从这开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</div><div class="line">    eventLoop = ch.eventLoop();</div><div class="line">    <span class="keyword">int</span> readyOps = k.readyOps();</div><div class="line">    <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> ops = k.interestOps();</div><div class="line">        ops &amp;= ~SelectionKey.OP_CONNECT;</div><div class="line">        k.interestOps(ops);</div><div class="line">        unsafe.finishConnect();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</div><div class="line">        ch.unsafe().forceFlush();</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 会进入到这里(接收连接)</span></div><div class="line">    <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// step 2</span></div><div class="line">        unsafe.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2 AbstractNioMessageChannel</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ChannelConfig config = config();</div><div class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</div><div class="line">    <span class="comment">// 控制读取连接的速率，默认一次读取16个连接</span></div><div class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</div><div class="line">    allocHandle.reset(config);</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="comment">// step 3</span></div><div class="line">        <span class="keyword">int</span> localRead = doReadMessages(readBuf);</div><div class="line">        <span class="comment">// 对连接数增加</span></div><div class="line">        allocHandle.incMessagesRead(localRead);</div><div class="line">    &#125; <span class="keyword">while</span> ( allocHandle . continueReading ());</div><div class="line"></div><div class="line">    <span class="keyword">int</span> size = readBuf.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        readPending = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">// 触发读事件，绑定到NioEventLoop</span></div><div class="line">        pipeline.fireChannelRead(readBuf.get(i));</div><div class="line">    &#125;</div><div class="line">    readBuf.clear();</div><div class="line">    allocHandle.readComplete();</div><div class="line">    pipeline.fireChannelReadComplete();</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List &lt; Object &gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 熟悉的accept方法，熟悉的javaChannel()拿到serverSocketChannel</span></div><div class="line">    <span class="comment">// step 4</span></div><div class="line">    SocketChannel ch = SocketUtils.accept(javaChannel());</div><div class="line">    <span class="comment">// 封装成NioSocketChannel，进入创建部分</span></div><div class="line">    buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">accept</span><span class="params">(<span class="keyword">final</span> ServerSocketChannel serverSocketChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    	<span class="comment">// 返回SocketChannel(新出来的AccessController还需要研究)</span></div><div class="line">        <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction &lt; SocketChannel &gt; () &#123;<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> SocketChannel <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">                <span class="keyword">return</span> serverSocketChannel.accept();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>检测完毕！！！</p>
<h1 id="创建Channel"><a href="#创建Channel" class="headerlink" title="创建Channel"></a>创建Channel</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1 NioSocketChannel</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(Channel parent, SocketChannel socket)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(parent, socket);</div><div class="line">    <span class="comment">// 同样创建一个config，这里设置了禁止Nagle算法(让数据尽快发出去，而不是让小数据包变大再发)</span></div><div class="line">    config = <span class="keyword">new</span> NioSocketChannelConfig(<span class="keyword">this</span>, socket.socket());</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2 AbstractNioByteChannel</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioByteChannel</span><span class="params">(Channel parent, SelectableChannel ch)</span> </span>&#123;</div><div class="line">    <span class="comment">// 这里要准备绑定读事件了</span></div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    <span class="keyword">super</span>(parent, ch, SelectionKey.OP_READ);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 4</span></div><div class="line">    <span class="keyword">super</span>(parent);</div><div class="line">    <span class="keyword">this</span>.ch = ch;</div><div class="line">    <span class="comment">// 设定为对读事件感兴趣</span></div><div class="line">    <span class="keyword">this</span>.readInterestOp = readInterestOp;</div><div class="line">	<span class="comment">// 设置为非阻塞</span></div><div class="line">    ch.configureBlocking(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.parent = parent;</div><div class="line">    <span class="comment">// 也给自己分配这些东西</span></div><div class="line">    id = newId();</div><div class="line">    unsafe = newUnsafe();</div><div class="line">    pipeline = newChannelPipeline();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Channel注册绑定"><a href="#Channel注册绑定" class="headerlink" title="Channel注册绑定"></a>Channel注册绑定</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1 DefaultChannelPipeline</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    AbstractChannelHandlerContext.invokeChannelRead(head, msg);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">"msg"</span>), next);</div><div class="line">    <span class="comment">// 还是那个线程生成器</span></div><div class="line">    EventExecutor executor = next.executor();</div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    next.invokeChannelRead(m);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 4 它会一直讲事件传播到再服务端启动过程中添加到Pipeline的ServerBootstrapAcceptor</span></div><div class="line">    ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4 ServerBootstrap里的ServerBootstrapAcceptor</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Channel child = (Channel) msg;</div><div class="line">	<span class="comment">// 设置一系列信息</span></div><div class="line">    child.pipeline().addLast(childHandler);</div><div class="line">    setChannelOptions(child, childOptions, logger);</div><div class="line">    <span class="keyword">for</span> (Entry &lt; AttributeKey &lt; ?&gt;, Object &gt; e: childAttrs) &#123;</div><div class="line">        child.attr((AttributeKey &lt; Object &gt; ) e.getKey()).set(e.getValue());</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 忽略细节，关注register方法(这里是childGroup)</span></div><div class="line">    <span class="comment">// step 5</span></div><div class="line">    childGroup.register(child);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 5 MultithreadEventLoopGroup</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</div><div class="line">    <span class="comment">// 这里的next方法会去拿到之前ServerChannel初始化的EventLoop数组的一个</span></div><div class="line">    <span class="comment">// step 6</span></div><div class="line">    <span class="keyword">return</span> next().register(channel);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 6 SingleThreadEventLoop</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</div><div class="line">    <span class="comment">// 看到这里会发现注册流程基本和ServerSocketChanne是一样的</span></div><div class="line">    <span class="comment">// step 7</span></div><div class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 7</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 看到这里，剩下的基本上就可以参考服务端启动流程了</span></div><div class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><code>ServerSocketChannel</code>绑定的EventLoop轮询到有新的连接进入</li>
<li>通过封装jdk底层的channel创建 <code>NioSocketChannel</code>以及一系列的netty核心组件</li>
<li>将该cahnnel通过chooser，选择一个EventLoop绑定上去</li>
<li>注册读事件，开始新连接的读写（可以参考服务端启动流程）</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/0242b1d4dd21" target="_blank" rel="external">netty源码分析之新连接接入全解析</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：之前对服务端和NioEventLoop都有了一定的分析，相信大家的服务端应该已经虚位以待了。好的，我们现在就开始分析&lt;strong&gt;新连接接入&lt;/strong&gt;。
    
    </summary>
    
      <category term="Netty源码" scheme="http://bestlixiang.site/categories/Netty%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Netty" scheme="http://bestlixiang.site/tags/Netty/"/>
    
  </entry>
  
</feed>
