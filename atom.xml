<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rex note</title>
  <subtitle>雨过，云过</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bestlixiang.site/"/>
  <updated>2020-10-21T16:10:02.086Z</updated>
  <id>http://bestlixiang.site/</id>
  
  <author>
    <name>rex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《领域驱动设计》读书笔记</title>
    <link href="http://bestlixiang.site/2020/10/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>http://bestlixiang.site/2020/10/22/读书笔记/领域驱动设计/</id>
    <published>2020-10-21T16:09:41.000Z</published>
    <updated>2020-10-21T16:10:02.086Z</updated>
    
    <content type="html"><![CDATA[<p>引：业务开发必不可少！！<a id="more"></a></p>
<p>本书<strong>为设计决策提供了一个框架</strong>，并且为讨论领域设计提供了一个<strong>技术词汇库</strong>。</p>
<p>很多应用程序最主要的复杂性并不在技术上，而是来源于领域本身、用户的活动和业务（后续逻辑）。</p>
<p>本书有两个前提：</p>
<ol>
<li>在大多数软件项目中，主要的焦点应该是领域和领域逻辑</li>
<li>复杂的领域设计应该基于模型</li>
</ol>
<p>领域驱动设计的实质就是消化吸收大量知识、最后产生一个<strong>反应深层次领域支持</strong>，并聚焦关键概念的<strong>模型</strong>。</p>
<h1 id="运用领域模型"><a href="#运用领域模型" class="headerlink" title="运用领域模型"></a>运用领域模型</h1><p><strong>提出领域驱动开发的基本目标</strong>， 这些目标是后面讨论的实践的驱动因素。</p>
<p>用户应用软件的<strong>问题区域</strong>就是软件的<strong>领域</strong>，有些领域是无形的，比如会计程序的金融领域，源代码控制系统的领域是软件开发本身，领域驱动设计，让我们主动寻找领域模型，然后进行设计，然后形成解决某个领域的软件产品，<strong>软件的核心就是其为用户解决领域相关的问题的能力</strong>。</p>
<p><strong>模型</strong>在领域驱动设计中的作用</p>
<ol>
<li>模型和设计相互影响</li>
<li>模型是通用语言</li>
<li>模型是浓缩的知识</li>
</ol>
<h2 id="消化知识，形成模型"><a href="#消化知识，形成模型" class="headerlink" title="消化知识，形成模型"></a>消化知识，形成模型</h2><p>领域知识，这是从领域专家或者领域用户来的，而不是开发脑子想的，我们需要不断用用户获取知识，完善开发的领域知识，更好的建模。</p>
<p><strong>对于开发人员既要完善技术知识，也要培养一般的领域建模技巧。</strong></p>
<p><strong>模型用于不是“发现名词”， 业务活动(Usecase)以及规则（domain service）和实体同样重要</strong></p>
<p>关于一些规则不能放在业务活动的一个判断里，更应该将一些规则放到领域服务里</p>
<p>领域知识 -》 领域建模技术 -》领域模型</p>
<h2 id="模型对应了通用语言"><a href="#模型对应了通用语言" class="headerlink" title="模型对应了通用语言"></a>模型对应了通用语言</h2><p>领域模型可称为软件项目通用语言的核心</p>
<p>通用语言的词汇包括类（领域对象）和主要操作（领域服务）的名称</p>
<p><strong>对于通用语言的修改，就是对模型的修改，就是对代码的修改</strong></p>
<p>对于不同的系统，模型可能是不同的，虽然他们对于现实的东西是一样的，所以我们需要定义不同系统和模型之间关系的<strong>界限上下文</strong></p>
<p>讨论系统要结合模型，并使用模型进行交流，就会将这些模型和想法记录到图和代码中。</p>
<p>关于文档和图，在讨论完模型（包括类和操作）之后，我们总是会以文档或图来展现，我们倾向于展现一些简单的小图（不是所以的编码对象），设计的重要谢姐应该在代码中体现出来。</p>
<p>对于解释性模型，不一定是UML图，但是是有关联的，解释性模型是为了让人更好理解。</p>
<h2 id="绑定领域模型和实现"><a href="#绑定领域模型和实现" class="headerlink" title="绑定领域模型和实现"></a>绑定领域模型和实现</h2><p><strong>领域模型驱动设计</strong> 要求模型不仅能够知道早期的分析工作（面向领域专家、面向产品），还应该成为设计的基础（面向开发）</p>
<p>为了实现在模型和设计对应关系，所以我们一般会使用<strong>面向对象语言</strong> ，哈哈哈哈哈哈，所以<strong>面向对象设计就是目前大多数项目所使用的建模范式</strong></p>
<p>软件开发就是一个不断净化模型、设计、和代码的统一的迭代过程</p>
<p>将建模和编程过程完全分离是行不通的。</p>
<h1 id="模型驱动设计的构造块"><a href="#模型驱动设计的构造块" class="headerlink" title="模型驱动设计的构造块"></a>模型驱动设计的构造块</h1><p><strong>将面向对象领域建模中的一些核心最佳实践提炼为一组基本的构造块</strong>，消除模型和实际运行的软件（实现）之间的鸿沟，同时可作为一些基本术语。</p>
<p><strong>将领域设计与软件系统中的其他关注点分离</strong>会使设计与模型之间的关系更加清晰，根据不同的特征来定义模型元素则会使元素的意义更加鲜明。</p>
<p>下面是在领域设计中基本元素的导航图：</p>
<p><img src="https://i.imgur.com/WF7LSrD.jpg" alt="领域驱动设计读书笔记PART I &amp; II | El Psy Congroo"></p>
<h2 id="分离领域"><a href="#分离领域" class="headerlink" title="分离领域"></a>分离领域</h2><p>我们需要将<strong>领域对象与系统中的其他功能分离</strong>，这样才能避免将领域概念和其他的软件技术相关概念搞混了。</p>
<p><img src="https://yyang.io/2015/12/31/DDD-and-Layered-Architecture/layered-architecture.png" alt="DDD与分层架构| 秋水逍遥"></p>
<p>要想创建能够处理复杂任务的程序，需要做到<strong>关注点分离</strong> ，使设计中的每个部分都得到单独的关注，在分离的同时，也需要维持系统内部复杂的交互关系。</p>
<p>为了实现关注点分离，一般会采用上图的<strong>分层架构</strong> （整洁架构也是其中一种）， <strong>分层架构的基本原则是层汇总的任何元素都仅依赖于本层的其他元素或其下层的元素，向上的通信必须通过间接的方式进行</strong>。（间接的方式是什么？？？回调模式或观察者模式？？这是不还是直接调用？？）</p>
<p>上图的四层主要是：</p>
<ol>
<li>用户界面层（表示层）：负责向用户显示信息和解释用户的指令，这里的用户可是另一个计算机系统（RPC调用）对于我们现在的微服务架构，就是<strong>服务接口层</strong>。</li>
<li>应用层：<strong>定义软件要完成的任务</strong>，并且指挥表达领域概念的对象来解决问题，<strong>具有商业价值的一层</strong></li>
<li>领域层（模型层）：<strong>负责表达业务的概念，业务的状态信息以及业务规则（特别是业务规则）</strong> 尽管保存业务状态的技术细节是由基础设施层完成的，但是反应业务情况的状态是由本层控制并且使用的。<strong>领域层是业务软件的核心</strong></li>
<li>基础设置层：为上面各层提供通用的技术能力：为应用层传递消息，为领域层提供持久化机制等等，基础设置层还能够通过<strong>架构框架</strong>来支持4个层次的交互模式。不过不对具体的基础设置产生依赖，一般会采用<strong>依赖导致</strong>，让基础设施层去依赖领域层。</li>
</ol>
<p>SMART_UI模式：就是将应用程序分成小的功能模块，分别将他们实现成用户界面，并嵌入业务规则。用关系数据库作为共享的数据存储库。一对一，没有任务复用，优点：简单，能快速实现程序，在原型简单可以使用，维护程序员你可以迅速重写他们不明白的代码端，因为修改代码只会影响到代码所在的用户界面。缺点：不通过数据库很难继承模块，没有对行为的重用，也没有对业务问题的抽象，每当操作用到业务规则时，都必须重复这些规则。</p>
<h2 id="软件中使用的模型"><a href="#软件中使用的模型" class="headerlink" title="软件中使用的模型"></a>软件中使用的模型</h2><p>为了不削弱模型驱动设计能力，我们需要将模型和实现个各个细节意义联系起来。</p>
<p>对象之间的<strong>关联</strong>很容易想象出来，也很容易画出来，但是实现他们却存在很多潜在的麻烦，<strong>关联</strong>也表明了具体的<strong>实现决策</strong>在模型驱动设计中的重要性。</p>
<p>在模型驱动设计中，用于表示模型的三个元素：</p>
<ol>
<li>Entity(实体)：具有连续性和标识的实物（可能就有不同的状态）</li>
<li>Value Object(值对象)：描述某种状态的属性</li>
<li>Service(服务，业务规则)：描述某项<strong>无状态</strong>的活动</li>
</ol>
<p>对象之间的<strong>关联</strong>是的建模和实现之间的交互更加复杂，如果一对多，多对一，多对多等等，为了使关联更易于控制，有下面这样的规定：</p>
<ol>
<li>规定一个遍历方向（虽然可以双向遍历的，但是从使用角度只保留一个方向）</li>
<li>添加一个限定符（美国在1970年（1970就是限定符）的总统是乔治*华盛顿，把1对多，变成了一对一），通过增加限定条件（可以理解成一个查询条件）变成一对一</li>
<li>消除不必要的关联 （识别出不重要的关联）</li>
</ol>
<h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>很多对象不是通过属性定义的，而是通过连续性（虽然属性变化，但是本质没有变）和<strong>标识</strong>（人的身份证号）定义的。</p>
<p><strong>Entity</strong>：主要由<strong>标识</strong>定义的对象，这个标识是领域中的标识，而不是技术上的表示，比如对象的ID，地址等，对于标识的定义，有时需要根据应用的上下文来确定。</p>
<h4 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h4><p>抓住Entity定义的最本质的特征，尤其是那些用于识别、查找或匹配对象的特征，只添加对概念至关重要的<strong>行为</strong>和这些行为所必须的<strong>属性</strong>，此外还应该将行为和属性转移到与核心实体关联的对象中。</p>
<p>除了标识问题外，实体往往通过协调其关联对象的操作来完成自己的职责</p>
<h4 id="设计标识操作"><a href="#设计标识操作" class="headerlink" title="设计标识操作"></a>设计标识操作</h4><p>需要理解领域，可能是一个属性唯一键，也可能是多个属性组成的唯一键，当都没有的时候就需要为对象增加一个唯一符号（系统生成的一个数字或者字符串）作为属性，如订单号</p>
<h3 id="Value-Object"><a href="#Value-Object" class="headerlink" title="Value Object"></a>Value Object</h3><p><strong>value object</strong>: 用于描述领域的某个方面二本身<strong>没有概念标识</strong>的对象，识别还是要更具上下文来看的。</p>
<p>值对象经常作为参数在对象之间传递消息，往往是临时对象，同时它也用作Entity的一个属性。Value Object应该是不可变的，如果变了就是另外一个Value Object。</p>
<p>Value Object可以是用于复制，也可以是共享（如果可变则不能共享），看实现性能需求。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>有些重要的<strong>领域操作</strong> 无法放到Entity或者Value Object中，这当中有些操作从本质上讲是一些活动或者操作，而不是事物。</p>
<p>一些领域该你啊你不合适被建模为对象，如果勉强吧这些重要的<strong>领域功能</strong>归为Entity或Value Object的职责，就会破坏真正的对象。</p>
<p><strong>Service</strong> 是作为借口提供的一种操作，他在模型是独立的，并且不像Entity和Value Object那样具有封装的<strong>状态</strong> 他强调的是与其他对象关系，往往是以一个活动动词来命名，Service应该有定义的职责，这种职责以及履行它的接口也应该给作为模型的一部分来加以定义。操作名称应该来源于统一语言，没有则加入统一语言，<strong>参数和结果都应该是领域对象</strong></p>
<p>好的Service有以下三个特征：</p>
<ol>
<li>与领域概念相关的操作不是Entity或ValueObject的一个自然组成部分，如果是，更应该放到Entity或Value Object当中</li>
<li>接口是更具模型领域的其他元素定义的</li>
<li>操作是无状态 的</li>
</ol>
<p>由于<strong>Service</strong>太过常见，有应用层的Service，领域层的Service，基础设施层的Service，所以我们要认真识别，只将有领域概念的Service当做领域层的Service，具体的例子可以参考书本。<strong>除了表示领域操作，很多时候领域层的Service也用来防止领域组件粒度过细，将领域信息外泄，将细粒度的对象包装为中等粒度的对象传递出去。</strong></p>
<p>关于Service访问：我们很多时候会使用依赖注入的方式来利用接口访问，但是要考虑业务的复杂性，如果简单，可以直接使用单例，而不使用依赖注入框架，但是现在感觉大部分都挺复杂的，还是用了好。</p>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>module之间是低耦合的，module之内是高内聚的，我们要联系紧密的领域元素放在一个module里面。可以理解为模块。领域层不可分割，至少作为一个单独的module</p>
<p>这个要站在更好的维度去思考！他也算是一个统一语言，group模块，org模块</p>
<h3 id="建模范式"><a href="#建模范式" class="headerlink" title="建模范式"></a>建模范式</h3><p><strong>模型驱动设计</strong>要求使员工一种与<strong>建模范式</strong>协调的实现技术</p>
<p>主流的范式是<strong>面向对象设计</strong></p>
<p>对于不适合使用面向对象范式的部分，可以使用其他范式，但是要通过<strong>统一语言</strong>来保持上下文</p>
<p>规则引擎、工作流引擎不适合用对象方式来建模？？？（不太理解意思？？？？），然后是核心模型不应该包括业务信息，关于工作流引擎，业务信息变化太快，所以要抽离处理，还是不太懂</p>
<h2 id="领域对象的生命周期"><a href="#领域对象的生命周期" class="headerlink" title="领域对象的生命周期"></a>领域对象的生命周期</h2><p>每个对象都有生命周期，对象自创建后，可能会经历各种不同的状态，直到最终消亡——要么存档，要么删除、对于临时对象来说，就是通过构造函数创建，做一些计算，然后由垃圾收集器回收。对于一些对象，比如Entity对象，他的生命周期更长，会经历一些状态变化，变化会遵守一些固定规则。大部分对象会经历下面的流程：</p>
<p><img src="https://img2020.cnblogs.com/blog/702098/202003/702098-20200321120427928-2072921799.png" alt="六领域驱动设计-领域对象的生命周期- fingersnow - 博客园"></p>
<p>管理这些对象主要的挑战如下：</p>
<ol>
<li>在整个生命周期维护完整性（完整性是指删除一个对象，也要删除属于它的对象）</li>
<li>防止模型陷入管理生命周期复杂性造成的困境（应对不同的基础设施以及对象转换）</li>
</ol>
<p>为了解决上面的挑战，会使用到下面3中模式：</p>
<ol>
<li>聚合根（Aggregate）：定义清晰的所属关系和边界，并避免混乱、错综复杂的对象关系网，这对于维护生命周期哥各个阶段的完整性很有效果</li>
<li>工厂（Factory）：使用工厂创建和重建复杂对象和聚合根，从而封装他们的内部结构，（主要是做数据库表示到领域对象的转换）</li>
<li>存储库（Repository）：用来提供查找和检索持久化对象并封装庞大的基础设施</li>
</ol>
<h3 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h3><p>在具有复杂关联的模型中，要想保证对象的更改的一致性是苦难的，不仅互不关联的对象需要遵守一些固定规则，而且紧密联系的各组对象也要遵守一些固定规则，然而国语谨慎的<strong>锁定机制</strong>又会导致多个用户之间毫无意义的相互干扰（顺序加锁），从而使系统不可用。</p>
<p>要想找到解决上面的方法，需要对领域有更加深刻的理解，比如要了解特定类实例之间的<strong>更改频率</strong>这样的深层次因素，我们需要找到一个<strong>使对象间冲突较少而固定规则联系更紧密</strong>的模型。</p>
<p>我们需要一个抽象来封装模型中的引用。<strong>Aggregate</strong>就是一组相关对象的集合，我们把它作为数据修改的单元。每个<strong>Aggregate</strong>都有一个<strong>根</strong>（root）和一个<strong>边界</strong>（boundary），边界定义了Aggregate内部都有什么。根则是Aggregate所包含的一个特定的Entity。对Aggregate而言，外部对象只可以引用根，而边界内部的对象之间则可以互相引用。除了根以后的其他Enttiy都有本地标识。</p>
<p><strong>固定规则</strong> 是指在数据变化时必须保持一致性的规则，其涉及Aggregate成员之内的内部关系。而跨越Aggregate的骨子额将不要求每时每刻都保持最终状态，通过事件处理或其他更新机制，保持最终一致性就好了。但是<strong>在每个事务完成时，Aggregate内部所应用的固定规则必须得到满足</strong>。</p>
<p>为了实现上诉概念的Aggregate，我们需要所有事务应用一组规则：</p>
<ul>
<li>根Entity具有全局标识，他复杂检查固定规则</li>
<li>根Enttiy具有全局标识，边界内的Entitty具有本地表示，这些表示只在Aggregate内部才是唯一的。</li>
<li>Aggregate外部的对象不能引用除根Entity之外的任何内部对象，根Entity可以吧对内部Entity引用传递给他们，但是这些对象只能临时使用这些引用，而不能保持引用。（不太理解保持引用的意思，是指不能单独修改？？？？），根可以吧一个Value Object的副本传递给另一个对象，而不必关心他们发生什么变化。</li>
<li>只有Aggregate的根才能直接通过数据库查询获取，其他对象必须通过遍历关联来发现。</li>
<li>Aggregate内部的对象可以保持队其他Aggregate根的引用。</li>
<li>删除操作必须一次删除Aggregate边界之内的所有对象（垃圾收集机制会自动实现，对于数据库要删除所有记录）</li>
<li>当提交对Aggregate边界内部的任何对象的修改是，整个Aggregate的所有固定规则都必须被满足。</li>
</ul>
<p><strong>我们要通过合理改变模型，可减少数据库锁的争用</strong></p>
<h3 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h3><p>对象的功能主要体现在其<strong>复杂的配置以及关联</strong>方面。一个对象在他的生命周期中药承担大量职责，如果再让复杂的对象负责自身的创建，那么<strong>职责过载</strong>将导致问题。<strong>我们需要将装配复杂的复合对象的工作和对象要执行的工作分开</strong>。</p>
<p>Factory通常不表示模型的任何部分，但是他们是领域设计的一部分，能使对象更明确地表示除模型。</p>
<p>复杂对象的创建和装配对应于领域中的重要事件（开立银行账户），对于这种具有领域概念的创建，我们需要一种新的元素，就是<strong>Factory</strong></p>
<p><strong>Factory</strong>封装了创建复杂对象或Aggregate所需的知识，他提供了反应客户目标的接口，以及被创建对象的抽象视图。</p>
<p>从设计模式角度考虑主要下面三种3种创建模式：1. 工厂方法（Factory Method）；2. 抽象工厂（Abstract Factory）；3. 构建器（Builder）</p>
<p>任何好的工厂都需要满足两个基础要求：</p>
<ol>
<li>每个创建方法都是原子的，而且要保证被创建对象或Aggregate的所有固定规则。Factory生成的对象要处于一致的状态。如果无法创建，需要抛出Exception或error</li>
<li>Factroy应用被抽象为所需的类型，而不是所要创建的具体类（？？？？）</li>
</ol>
<h4 id="Factory的应用位置"><a href="#Factory的应用位置" class="headerlink" title="Factory的应用位置"></a>Factory的应用位置</h4><p>Factory的作用是隐藏创建对象的细节，而且我们把Factory用在那些需要隐藏细节的地方，这些决定通常与<strong>Aggregate</strong>有关。</p>
<p>两个常见应用位置：</p>
<ol>
<li>如果需要向一个已存在的Aggregate添加元素，可以在Aggregate的根上创建一个工厂方法，这样就可以把Aggregate的内部实现细节隐藏起来</li>
<li>通过一个对象的创建主要使用另一个对象的数据时，前者不属于后者，可以在后者的对象上创建一个工厂方法，这样就不必将后者的信息提取到其他地方来创建前者。</li>
</ol>
<p>当有些细节需要隐藏而又找不到合适的地方来隐藏他们时，必须创建一个专用的<strong>Factory对象或Service</strong>。整个Aggreate通常需要一个独立的Factory来创建，Factory负责把根对应的引用传递出去，并确保创建出的Aggregate满足特定规则。</p>
<h4 id="直接使用构造函数的位置"><a href="#直接使用构造函数的位置" class="headerlink" title="直接使用构造函数的位置"></a>直接使用构造函数的位置</h4><p>Factory会使那些不具有多态性的简单对象复杂化。在以下情况下最好使用简单、公共的构造函数：</p>
<ol>
<li>没有通过接口实现多态的类</li>
<li>客户关心的实现，可能是将其作为选择策略的一种方式（？？？？不懂）</li>
<li>客户可以访问对象的所有属性，因此<strong>向客户公开的构造函数中没有嵌套的对象创建</strong></li>
<li>构造不复杂</li>
<li>公共构造函数必须遵守Factory的相同规则：它必须是原子操作，而且要满足被创建对象的所有固定规则</li>
</ol>
<p>不要在构造函数中调用其他类的构造函数，如果需要，则使用Aggregate，使用Factory</p>
<p><strong>构造函数和Factory可以共存，比如Java集合类库</strong></p>
<h4 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h4><p>在设计Factory的方法签名时，无论是独立的Factory还是Factory Method，都要记住下面两点：</p>
<ol>
<li>每个操作必须是原子的</li>
<li>Factory将与其参数发生耦合，所以尽量依赖其抽象类，而不依赖其具体类</li>
</ol>
<h4 id="固定规则的相关逻辑放在哪里"><a href="#固定规则的相关逻辑放在哪里" class="headerlink" title="固定规则的相关逻辑放在哪里"></a>固定规则的相关逻辑放在哪里</h4><p>Factory复杂确保他所创建的对象或Aggregate满足所有固定规则。Factroy可以将固定规则的检查工作委托给被穿件对象，这通常是最佳选择。</p>
<p>对于聚合根，将固定规则相关逻辑放在Factory是比较好，可以让被创建的对象的职责更加清晰。</p>
<p>固定规则不适合放到那些与其他领域对象关联的Factroy Method中 （？？？？）</p>
<p>对于Entity Factory，需要在Factory来分配标识符ID</p>
<h4 id="重建已存储的对象"><a href="#重建已存储的对象" class="headerlink" title="重建已存储的对象"></a>重建已存储的对象</h4><p>用于重建对象的Factory与用于创建对象的Factroy很类似，但是有以下两点不同：</p>
<ol>
<li>用于重建对象的Entity Factory不会分配新的标识ID，标识属性必须是输入参数的一部分</li>
<li>当规则未被满足时，重建的Factory采用不同的处理方式，创建Factory时直接报错，对于重建，我们还需修复数据（这肯定是有脏数据了）</li>
</ol>
<h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><p>无论要用对象执行什么操作，都需要保持一个对它的应用，如果获得引用，一个方法是<strong>创建</strong>对象，另一个方法是<strong>遍历关联</strong>，从一个已知对象作为起点，向他请求一个关联的对象。还有第三种方案，基于对象的属性执行查询来找到对象，或者找到对象的组成部分，然后<strong>重建</strong>它。</p>
<p><strong>如果基础设施提供了一种简单的方式获取已存在的领域对象的引用，那么开发人员就会增加很多遍历关系的关联，那么模型就会混乱。另一方面，如果开发人员直接从数据库提取他们所需的对象，而不是通过Aggregate来获取对象，那么会使模型变得不重要，我们需要很好的折中。</strong></p>
<p>下面是一些原则：</p>
<p>在所有持久化的对象中，有一<strong>小部分</strong>必须通过对象属性的搜索来<strong>全局访问</strong>，当很难通过遍历方式来访问某些Aggregate根的时候，就需使用这种方式。他们通常是Entity，有时候是具有复杂结构的Value Object，还有可能是枚举值（这个不懂）。而其他对象不宜还是员工这种访问方式。</p>
<p>有大量的技术可以用来解决数据库访问的技术难题，如将SQL封装到Query Object中或者利用ORM进行对象和表之前的转换等。而<strong>Repository</strong>是一个概念框架，用于封装这些解决方案，让我们把注意力重新拉回到模型上。</p>
<p><strong>Repository</strong> 将某种类型的所有对象表示为一个概念集合，他具有CRUD功能。这些功能提供了对Aggregate根的整个生命周期的全称访问。</p>
<h4 id="Repository查询"><a href="#Repository查询" class="headerlink" title="Repository查询"></a>Repository查询</h4><p>大多数查询都返回一个对象或对象集合，但返回某些类型的汇总计算也符合Repository的概念，如对象数据，或者属性求和</p>
<p><strong>一般我们需要一个支持灵活查询的Repository框架。基于Specification（规格）的查询是将Repository的好方法。但是很多框架不提供，需要自己实现，或者全都使用硬编码的方式</strong></p>
<h4 id="Repository实现"><a href="#Repository实现" class="headerlink" title="Repository实现"></a>Repository实现</h4><p>将存储、检索和查询机制封装起来是Repository实现最基本的特征，客户不管先数据是存在数据库还是文件还是内存当中。</p>
<p>在Repository实现的注意事项：</p>
<ol>
<li>对类型进行抽象</li>
<li>充分利用与客户解耦的优点 ，这让我们可以很容易更改Repository的实现</li>
<li><strong>将事务的控制权留给客户</strong>   （这个怎么做？？？？）</li>
</ol>
<p>这里还需要处理一点，<strong>Repository的对象和数据库的对象有时候会不同，这个时候我们需要进行一层转化</strong></p>
<h4 id="Repository和Factory的关系"><a href="#Repository和Factory的关系" class="headerlink" title="Repository和Factory的关系"></a>Repository和Factory的关系</h4><p>Factory负责处理对象生命周期的开始（是创建，不包括重建），Repository帮助管理生命周期的中间和结束。Factroy负责制造新对象，Repository负责查找重建已有对象。同时Repository也可以委托Factroy来创建一个对象（这种情况很少很少，我还没想到？？？？）</p>
<h3 id="为数据库设计对象"><a href="#为数据库设计对象" class="headerlink" title="为数据库设计对象"></a>为数据库设计对象</h3><p><strong>最常用的非对象组件就是关系数据库</strong> 他不是一个对象，他是用来描述一系列CRUD操作</p>
<p>数据库对象和领域对象存在不一致，所以需要映射，对于映射来说，映射要保持透明，并且易于理解</p>
<p>大多数情况下关系数据库是面向对象领域中的持久化存储形式，因此简单的对应关系是最好的，表中的一行包含一个对象，也可能还包含Aggregate的一些附属项。表中的外键应该转化为对另外一个Entity对象的引用。</p>
<p>但是事与愿违，领域对象和数据库对象往往存在不一致，这样会失去透明性，这样会增加处理的复杂度。</p>
<h2 id="一个扩展的示例"><a href="#一个扩展的示例" class="headerlink" title="一个扩展的示例"></a>一个扩展的示例</h2><p><strong>这是在已有领域模型的基础，通过构造块来绑定实现的示例</strong></p>
<ol>
<li>隔离领域：引入应用层</li>
<li>将Entity和Value Object区别开</li>
<li>设计领域中的关联，关联（遍历方向）能反应出领域的馆观察，尽量使用单向关联，因为单向关联可以减少另一个方向遍历带来的理解和实现成为，当然也是会有双向关联的，这是业务所决定的</li>
<li>确定Aggregate边界，共享的Entity一般都是聚合根，拥有共同生命周期的一般是一个聚合根边界，关于聚合根的边界还要考虑锁竞争的问题，减少锁竞争就要缩小边界</li>
<li>选择Repository，在聚合根内部的Entity不能拥有Repository</li>
<li>对象的创建——Factory和构造函数</li>
<li>重构，按照业务需求和性能考虑，重新梳理构造块</li>
<li>module化，找出紧密联系的概念分成Module，虽然被划分成不同的模块，但是还是在同一个领域中，统一语言还是可以用的</li>
<li>引用新系统时，如何处理<ul>
<li>做一个反腐层，处理本领域到另外一个系统领域的翻译</li>
<li>业务规则必须在领域层执行，不应该放在应用层，如果业务规则属于另外一个系统则需要在另外一个系统执行</li>
<li>性能优化，如果另外一个系统的数据，可以使用缓存，避免多次请求，但是这又要维护缓存的一致性问题</li>
</ul>
</li>
</ol>
<p><strong>留了一个坑：分析模式——Enterprise Segment</strong></p>
<h1 id="通过重构来加深理解"><a href="#通过重构来加深理解" class="headerlink" title="通过重构来加深理解"></a>通过重构来加深理解</h1><p><strong>提供一些建模指导原则，将构造块装配为实用的模型</strong>，这是一个逐步的过程。</p>
<p><strong>真正的挑战是找到深层次的模型，这个模型不但能捕捉到领域专家的关注点，还可驱动切实可行的设计，这是一个需要不断重构的过程。</strong></p>
<p><strong>重构</strong>分为两种：</p>
<ol>
<li>代码本身重构：分为设计模式重构和代码细节重构，细节重构可以看看《重构》</li>
<li>代码模型重构：这里不是代码细节重构，但是也会用到一些设计模式，我们这里主要关注这个重构</li>
</ol>
<p>下面都会讨论一些<strong>改进领域模型</strong>的具体<strong>思考方式</strong>以及可<strong>实现这些领域模型</strong>的<strong>设计方法</strong>。</p>
<p>模型驱动设计，设计改进模型，达成一个闭环。</p>
<h2 id="突破"><a href="#突破" class="headerlink" title="突破"></a>突破</h2><p>如果有对了更深层理解，有了更深层次的模型请重构它，完成质的飞跃。</p>
<p>没太看懂文中的例子？？？</p>
<h2 id="将隐式概念转变成现实概念"><a href="#将隐式概念转变成现实概念" class="headerlink" title="将隐式概念转变成现实概念"></a>将隐式概念转变成现实概念</h2><p>深层建模听起来不错，因为他包含了领域的核心概念和抽象，能够以简单灵活的方式表达出基本的用户活动、问题以及解决方案。如何得到深层模型，我们需要一个思考过程。可是是下面这样的思考方式。</p>
<h3 id="概念挖掘"><a href="#概念挖掘" class="headerlink" title="概念挖掘"></a>概念挖掘</h3><p>一般开发设计都是”名词即对象”，但是我们要清楚理解这个名词真实含义，并转为为设计中的模型，形成统一语言。</p>
<p>概念怎么挖掘，通过与领域专家的交流以及查阅专业知识书籍等方式，还有就是阅读在此领域中有过开发经验的软件专业人员编写的资料，如《分析模式》</p>
<ol>
<li>与领域专家交流（靠谱的产品）</li>
<li>查阅专业知识书籍，主动了解领域概念以及领域约束</li>
<li>向做过的这个东西的人学习（经验丰富的同事）</li>
</ol>
<h3 id="为不太明显的概念建模"><a href="#为不太明显的概念建模" class="headerlink" title="为不太明显的概念建模"></a>为不太明显的概念建模</h3><h4 id="显示的约束"><a href="#显示的约束" class="headerlink" title="显示的约束"></a>显示的约束</h4><p>约束是概念模型中非常重要的类型。他们通常是隐含的，将他们显示的表现出来可以极大提高设计质量。</p>
<p>简单方法：将这种约束作为领域对象的一个方法，而不是通过一个if-else 来做，防止他的丢失。</p>
<p>如果约束的存在掩盖了对象的基本职责，或者如果约束在领域中非常突出但是在模型中却不明显，那么就可以将其提取到一个显示的对象中（约束类）。</p>
<h4 id="将过程建模为领域对象"><a href="#将过程建模为领域对象" class="headerlink" title="将过程建模为领域对象"></a>将过程建模为领域对象</h4><p>一般不希望将过程建模为模型的<strong>主要部分</strong>，但是将像算法这样的计算过程封装成对象，或者说策略能够让我们的设计更加清晰。上面说过将约束建模为对象，这里讲过程也可以建模为对象。</p>
<h4 id="Specification-规格"><a href="#Specification-规格" class="headerlink" title="Specification(规格)"></a>Specification(规格)</h4><p>将一些特定的规则（理解为谓词，表示真的，假的）表达为一个对象，可用来明确对象是否满足某些标准。这种规则的实现都有助于写出可测试的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvoiceDeliquency</span></span>&#123;</span><br><span class="line">	test(Invoice): <span class="keyword">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种规则就有扩展性，将几个规则组成一个规则，就可以用来描述复杂的规则。</p>
<p>这个规则可以有属性，属于值对象。</p>
<h4 id="Specification的应用和实现"><a href="#Specification的应用和实现" class="headerlink" title="Specification的应用和实现"></a>Specification的应用和实现</h4><p>有如下几种使用方式：</p>
<ol>
<li>验证对象，检查他是否能满足某些需求</li>
<li>对象选择，从集合中选择一个对象  （可以用来对通用查询做一次转化）</li>
<li>对象创建，创建的新对象必须满足某种需求</li>
</ol>
<h2 id="柔性设计"><a href="#柔性设计" class="headerlink" title="柔性设计"></a>柔性设计</h2><p><strong>软件的最终目的是为用户服务。但他首先必须为开发人员服务。在强调重构的软件开发过程中尤其如此。</strong></p>
<p>为了使项目能够随着开发工作的进行加速前进，而不会由于他自己的老化停滞不前，设计必须要让人们乐于使用，而且易于做出修改，这就是<strong>柔性设计</strong>。</p>
<p>为了获得柔性设计，我们需要采用一些方法（模式）</p>
<p><img src="https://oscimg.oschina.net/oscnet/3397ed64af078ec42bb40e6ab31d8f19202.png" alt="领域驱动设计》学习笔记- osc_ymlf86ez的个人空间- OSCHINA"></p>
<h3 id="Intention-Revealing-interfaces-意图明显的接口"><a href="#Intention-Revealing-interfaces-意图明显的接口" class="headerlink" title="Intention-Revealing interfaces (意图明显的接口)"></a>Intention-Revealing interfaces (意图明显的接口)</h3><p><strong>清楚表明了用途</strong></p>
<p><strong>这里的接口不是特别指<code>interface</code>,它可能指一个方法，一个类，一个接口</strong></p>
<p>如果开发人员为了使用一个组件而必须去去研究他的实现，那么就是去了封装的价值。</p>
<p><strong>在命名类和操作时要描述他们的效果和目的，而不要表露他们是通过何种方式达到目的的</strong>，这样可以使客户开发人员必去去理解内部细节，这些名词应该与统一语言一直。</p>
<p>对于命名困难的，一定要加好注释</p>
<h3 id="Side-Effect-Free-Function-无副作用函数"><a href="#Side-Effect-Free-Function-无副作用函数" class="headerlink" title="Side-Effect-Free Function(无副作用函数)"></a>Side-Effect-Free Function(无副作用函数)</h3><p>我们可以宽泛得把操作分为两个大的类别：命令和查询。查询是从系统获取信息，查询的方式可能只是简单访问变量中的数据，也可能是用这些数据进行计算得到返回值。命令（也称修改器）是修改系统的操作（如设置变量）。</p>
<p><strong>PS：</strong> “Side-Effect（副作用）”在标准英语中，这个词暗示着”意外的结果”，在计算机科学中，任何对系统状态产生印象的都叫做副作用。本书缩小含义：任何对未来操作产生印象的系统状态改变都可以成为副作用。</p>
<p>返回结果，而不产生副作用的操作成为<strong>无副作用函数</strong>，这个函数可以被多次调用，每次调用都返回相同的值。</p>
<p>在大多数软件系统中，命令的使用都是不可避免的，但是有两种方法可以减少命令产生的问题：</p>
<ol>
<li><p><strong>将命令和查询严格放在不同的操作中</strong>，确保导致状态改变的方法不返回领域数据，并尽可能保持简单。</p>
</li>
<li><p>使用新的模型和设计，他不要求对现有对象做任何修改，相反，他们创建并返回一个Value Object，用于表示计算结果。因为Value Object是不可变的，所以不会产生副作用。</p>
</li>
</ol>
<h3 id="Assertion-断言"><a href="#Assertion-断言" class="headerlink" title="Assertion(断言)"></a>Assertion(断言)</h3><p>把复杂的计算封装到无副作用的函数中可以简化问题，但实体仍然会留有一些有副作用的命令，使用这些Entity的人必须了解使用这些命令的后果，在这种情况下，使用<strong>Assertion（断言）</strong>可以把副作用明确的表示出来，使他们更易于处理。</p>
<p><strong>把操作的后置条件和类及Aggregate的固定规则描述清楚。如果在你的编程语言中不能直接编写Assertion(C++可以)，那么就把他们编写成自动的单元测试</strong></p>
<p>一个单元测试包括：前置条件，固定规则，后置条件</p>
<h3 id="Conceptual-Contour-概念轮廓"><a href="#Conceptual-Contour-概念轮廓" class="headerlink" title="Conceptual Contour(概念轮廓)"></a>Conceptual Contour(概念轮廓)</h3><p>把设计元素（操作、接口、类和Aggregate）分解为<strong>内聚单元</strong>，在这个过程中，你对领域中一切重要划分的直观认识也要考虑在内，在连续的重构过程中观察发送变化和<strong>保证稳定的规律性</strong>，并<strong>寻找能够解释这些变化的底层Conceptual contour</strong>（比如调度类？？？）。使模型与领域中那些一致的方面相匹配。</p>
<p>这个不太懂？？？</p>
<h3 id="Standalone-Class-独立的类"><a href="#Standalone-Class-独立的类" class="headerlink" title="Standalone Class(独立的类)"></a>Standalone Class(独立的类)</h3><p>互相依赖的模型和设计变得难以理解、测试和维护。而且，互相依赖很容易越积越多。</p>
<p>每个关联都是一种依赖，每个方法的类型也是一个依赖，每个返回值也是一个依赖。</p>
<p>Module和Aggregate的目的都是为了限制互相依赖的关系网。当我们识别出一个高度内聚的子领域并把他们提取到一个Module中的时候，一组对象也随着与系统其它部分解除了联系。</p>
<p>低耦合是对象设计一个基本要素，尽一切可能保持低耦合，把其他所有无关概念提取到对象之外，这样类就变得完全独立了。</p>
<p><strong>尽力最复杂的计算提取到独立的类中，实现此目的的一种方法就是存在大量依赖的类中将Value Object建模出来。 （可以看看例子）</strong></p>
<p>低耦合是减少概念过载最基本的方法。独立的类是低耦合的极致。</p>
<h3 id="Closure-Of-Operation-闭合操作"><a href="#Closure-Of-Operation-闭合操作" class="headerlink" title="Closure Of Operation(闭合操作)"></a>Closure Of Operation(闭合操作)</h3><p>依赖是必然存在的，当依赖是概念的一个基本属性时，他就不是坏事。</p>
<p>在适当的情况下，在定义操作时让他的返回类型与其参数的类型相同。如果实现者的状态在计算中会被用到，那么是实现者实际上就是操作的一个参数（底层也是这样实现的），因此参数和返回值应该与实现者有相同的类型。这样的操作就是在该类型的实例集合中的<strong>闭合操作</strong>，闭合操作提供了一个高层接口，同时又不会引入对其他概念的依赖。</p>
<p>这种模式更常用于Value Object的操作。</p>
<h3 id="声明式设计以及风格"><a href="#声明式设计以及风格" class="headerlink" title="声明式设计以及风格"></a>声明式设计以及风格</h3><p>声明式设计通常值一种编程方式——吧程序或程序的一部分写成一种可执行的规格（Specification），有点像元编程呀。</p>
<p>柔性设计能让我们的代码具有声明式风格。</p>
<p>实现声明式风格很难！！！</p>
<h3 id="切入问题的角度"><a href="#切入问题的角度" class="headerlink" title="切入问题的角度"></a>切入问题的角度</h3><p>下面是几种方法，让我们将上面的模式都结合起来使用</p>
<h4 id="分割子领域"><a href="#分割子领域" class="headerlink" title="分割子领域"></a>分割子领域</h4><p>将模型的某个部分看做单独子模块。重点突出某个部分</p>
<h4 id="尽可能利用已有的形式"><a href="#尽可能利用已有的形式" class="headerlink" title="尽可能利用已有的形式"></a>尽可能利用已有的形式</h4><p>对于不同的领域，如果有建立已久的概念系统，在复用的基础上，修改</p>
<h2 id="应用分析模式"><a href="#应用分析模式" class="headerlink" title="应用分析模式"></a>应用分析模式</h2><p>直接从一个已经具有良好的表达力和易实现的模型开始工作开始工作。</p>
<p>在《分析模式》一书中，martin fowler这样定义分析模式：</p>
<p><strong>分析模式一种概念集合</strong>，用来表示业务建模中的常见结构，他可能只与一个领域有关，也可能跨越多个领域。</p>
<p>分析模式最大的作用就是借鉴其他项目的经验。</p>
<h2 id="将设计模式应用于模型"><a href="#将设计模式应用于模型" class="headerlink" title="将设计模式应用于模型"></a>将设计模式应用于模型</h2><p>《设计模式》：设计模式是对一些交互的对象和类的描述，我们通过定制这些对象和类来解决特定上下文中的一半设计问题。</p>
<p>在《设计模式中》中，有些（但并非所有）模式可用作领域模式，但是这样使用的时候，需要变换一下重点。为了在<strong>领域驱动设计</strong>中重充分利用这些模式，我们必须从两个角度看待他们：<strong>从代码角度来看他们是技术设计模式，从模型的角度看他们是概念模式</strong></p>
<h3 id="Strategy-Policy-策略模式"><a href="#Strategy-Policy-策略模式" class="headerlink" title="Strategy/Policy (策略模式)"></a>Strategy/Policy (策略模式)</h3><p><img src="http://gdut_yy.gitee.io/doc-ddd/figures/ch12/12inf01.jpg" alt="img"></p>
<p>《设计模式》——策略模式：定义一组算法，将每个算法封装起来，并使他们可以互换。策略允许算法独立使用他的客户端而变化。</p>
<p>领域模型包含了一些并非用于解决技术问题的过程，将他们包含进来是因为他们对处理问题领域具有实际的价值。当必须从多个过程中进行选择是，选择的复杂性加上多个过程的复杂性会使局面失去控制。</p>
<p>我们需要的过程的<strong>易变部分</strong>提取到模型的一个单独策略对象中。将规则与它所控制的行为区分开来。按照策略模式来实现规则或可替换的过程。</p>
<p><strong>通常，作为设计模式的策略侧重于替换不同的算法的能力，而当其作为领域模式时，其侧重点是表示概念的能力，这里的概念通常是指过程或者策略规则</strong></p>
<h3 id="Composite-组合模式"><a href="#Composite-组合模式" class="headerlink" title="Composite(组合模式)"></a>Composite(组合模式)</h3><p><img src="http://gdut_yy.gitee.io/doc-ddd/figures/ch12/12inf02.jpg" alt="img"></p>
<p>《设计模式》——组合模式：将对象组织为数表示部分——整体的层次结构，利用组合，客户可以对单独的对象和对象的组合进行同样的处理。</p>
<p>定义一个把Composite的所有成员都包含在内抽象模型。在容器上实现那些查询信息的方法时，这些方法返回由容器内容所汇总的信息。而”叶“节点则基于他们自己的值来实现这些方法。客户只需要使用抽象类型，而无需区分”叶“和容器。</p>
<p>我感觉还是一个”技术模式”，做了一个很好的抽象。但是告诉我们在学会在领域模式里进行抽象组合。</p>
<h2 id="通过重构得到更深层的理解"><a href="#通过重构得到更深层的理解" class="headerlink" title="通过重构得到更深层的理解"></a>通过重构得到更深层的理解</h2><p>在做项目的过程中，我们总会随着理解的加深而去重构代码，下面重构时需要关注的点：</p>
<ol>
<li>以领域为本</li>
<li>用一种不同的方式来看待事务</li>
<li>始终坚持与领域专家对话</li>
</ol>
<h1 id="战略设计"><a href="#战略设计" class="headerlink" title="战略设计"></a>战略设计</h1><p><strong>站在更高维度，作为一个项目存在于一个大型系统时的设计原则（上下文、提炼、大型结构）</strong>，一般都是由多个团队共同设计。</p>
<p>当我们无法通过分析对象来理解系统的时候，就需要掌握一些<strong>操纵和理解大模型的技术</strong>了</p>
<p>有时，企业系统会继承各种不同来源的子系统，或者包含诸多不同的应用程序，以至于无法从同一个角度来看待领域。要把这些不同部分中隐含的模型统一起来可能要求过高了，通过为每个模型显示定义一个<strong>Bounded Context（界限上下文）</strong>，然后在必要的情况下定义它与<strong>其他上下文</strong>的关系，建模人员就可以避免模型变得混乱。</p>
<p>通过<strong>精炼</strong>可以减少混乱，并且把注意力集中到正确的地方。战略（系统的远景）精炼可以使大的模型保持清晰。有了更清晰的视图后，<strong>Core Domain</strong>的设计就会发挥更大的作用。</p>
<h2 id="保持模型的完整性"><a href="#保持模型的完整性" class="headerlink" title="保持模型的完整性"></a>保持模型的完整性</h2><p><strong>模型最基本的要求是保持内部的统一，不包含互相矛盾的规则。</strong>大型系统领域模型的完全统一既不可行，也不划算。</p>
<p>我们需要一种方式来标记处不同模型之间的边界和关系。下面将会介绍一些<strong>识别、沟通和选择模型边界和关系</strong>的技术。</p>
<p><img src="http://gdut_yy.gitee.io/doc-ddd/figures/ch14/fg14-1.jpg" alt="img"></p>
<p>Overlap: 重叠</p>
<p>Allied: 联盟</p>
<p>Unilaterally : 单方面的</p>
<p>insulate：隔离</p>
<h3 id="Bound-Context-界限上下文"><a href="#Bound-Context-界限上下文" class="headerlink" title="Bound Context(界限上下文)"></a>Bound Context(界限上下文)</h3><p><strong>明确定义模型所应用的上下文</strong>。根据团队的组织、软件系统的各个部分的用法以及物理表现（代码和数据库模式等）来设置<strong>模型的边界</strong>。在这些边界内严格保持模型的一致性，而不要收到边界之外的问题的干扰和混淆。</p>
<p>在一个系统中，系统的具体模型驱动的所有方方面面构成了其对应的<strong>Bouned Context</strong>，上下文包括模型对象、用于模型对象持久化的数据库模式以及应用程序。</p>
<p><strong>PS:</strong> Module不是上下文，多个Module可能是同一个上下文。</p>
<h3 id="Continuous-Intergration-持续集成"><a href="#Continuous-Intergration-持续集成" class="headerlink" title="Continuous Intergration (持续集成)"></a>Continuous Intergration (持续集成)</h3><p>当很多人在同一个上下文工作时，模型很容易发生分裂，团队越多，问题就越大，但是如果将系统分解为更小的上下文，又难以保持集成度和一致性。</p>
<p>持续集成是指把上下文中的所有工作<strong>足够频繁的合并咋一起</strong>，并使他们保持一致，以便当模型发生分裂时，可以迅速发现并纠正。在领域驱动设计中持续集成分成两个级别的操作：</p>
<ol>
<li>模型概念的集成</li>
<li>实现的集成</li>
</ol>
<h3 id="ContextMap-上下文地图"><a href="#ContextMap-上下文地图" class="headerlink" title="ContextMap(上下文地图)"></a>ContextMap(上下文地图)</h3><p>只有一个Bound Context并不能提供全局的视图，其他模型的上下文可能仍不清楚而且还在不断变化。这个时候需要一个<strong>ContextMap上下文地图</strong>。</p>
<p>上下文之间的代码重用是很危险的，应该避免。功能和数据的集成必须通过转换去实现。</p>
<p><strong>描述模型之间的联系点，明确所有通信需要做的转换，并突出任何共享的内容</strong></p>
<h4 id="测试Context的边界"><a href="#测试Context的边界" class="headerlink" title="测试Context的边界"></a>测试Context的边界</h4><p>通过测试有租户解决转换时所存在的一些细微问题以及弥补沟通上存在的不足。</p>
<h4 id="ContextMap的组织和文档化"><a href="#ContextMap的组织和文档化" class="headerlink" title="ContextMap的组织和文档化"></a>ContextMap的组织和文档化</h4><p>两个重点：</p>
<ol>
<li>Bounded Context 应该有名称，以便可以讨论他们，同时这些名称应该加入统一语言中</li>
<li>每个人都知道边界在哪里，而且应该能够分辨出任何代码端的Context，或者任何情况的Context中</li>
</ol>
<h3 id="Bounded-Context之间的关系"><a href="#Bounded-Context之间的关系" class="headerlink" title="Bounded Context之间的关系"></a>Bounded Context之间的关系</h3><p>把模型联系在一起之后，就能把整个企业包含在一起，下面有放多方法将两个模型关联起来</p>
<p>开发一个紧密集成的产品的优秀团队可以部署一个<strong>大的、统一的模型</strong>、如果团队需要为不同的用户群提供服务，或者团队的协调能力有限，可能就需要采用<strong>Share Kernel（共享内核）或Customer/Supplier（客户/供应商）关系</strong>。有时仔细研究需求之后可能发现集成并不重要，而系统最好采用<strong>Separate Way(各行其道)模式</strong>。当然，大多数项目都需要与遗留系统或外部系统进行一定程度的集成，这就需要使用<strong>Open Host Service（开放主机服务）或者Anticorruption Layer（防护层/防腐层）</strong></p>
<h3 id="Shared-Kernel（内核模式）"><a href="#Shared-Kernel（内核模式）" class="headerlink" title="Shared Kernel（内核模式）"></a>Shared Kernel（内核模式）</h3><p><strong>从领域模型中选出两个团队都统一共享的子集，除了这个模型子集以外，还包括与该模型部分相关的代码子集，或数据设计的子集</strong>。这部分明确共享的内容具有特殊的地位，一个团队在没与另一个团队商量的情况下不应擅自更改它。</p>
<p>如果这个共享子集发生修改是，两个团队都要运行测试。</p>
<p><strong>Shared Kernel通常是Core Domain、或是一组Generic SubDomain（通用子领域）。他可以是两个团队都需要的任何一部分模型。</strong></p>
<p><strong>使用Shared Kernel的目的是减少重复（并不是消除重复，因为只有在一个Bounded Context才能消除重复），并使两个子系统之间的集成变得相对容易一些。</strong></p>
<h3 id="Customer-Supplier-Development-Team"><a href="#Customer-Supplier-Development-Team" class="headerlink" title="Customer/Supplier Development Team"></a>Customer/Supplier Development Team</h3><p><strong>这里上下游和调用的上下游好像是相反的，这里的上下游更像是数据的流向</strong></p>
<p>这里是让下游成为”客户”，上游成为”服务者”；下游团队要参加上游团队的计划会议，上游团队直接与他们的”客户”讨论和权衡其所需的任务。</p>
<p><strong>在两个团队之间建立一种明确额客户/供应商关系，在计划会议汇总，下游团队相当于团队的客户。根据下游团队的需求来协商需要执行的任务并未这些任务做预算，以便每个人都知道双方的约定和进度。</strong></p>
<p><strong>两个团队都需要自动化测试。</strong></p>
<p><strong>当下游不能完全使用上游的完整的Bounded Context，就不能把把上游当做Shared Kernel</strong></p>
<h3 id="Conformist-跟随者"><a href="#Conformist-跟随者" class="headerlink" title="Conformist(跟随者)"></a>Conformist(跟随者)</h3><p>当两个具有上游/下游关系的团队不归一个管理者指挥时，Costomer/Supplier Development Team这种合作模式就不容易奏效。哈哈哈哈哈哈哈。</p>
<p>如果上游不能很好的支持下游，那么有以下三种解决方式：</p>
<ol>
<li>完全放弃对上游的依赖，使用Separate Way（各行其道）的方式开发</li>
<li>必须要依赖，而且上游的设计很难使用，那么下游团队仍然需要自己开发自己的模型，而且还要担负起转化层的全部责任，这就是Anticorruption layer</li>
<li>必须要依赖，而且上游的设计还行，而且对上游依赖很大的情况下，使用Comfirmist（跟随者）模式</li>
</ol>
<p><strong>通过严格遵守上游团队的模型，可以消除在Bouned Context之间的转换的复杂性。尽管这会限制下游设计人员的风格，但选择Conformits可以极大简化集成</strong></p>
<p>这个有点像Shared Kernel模式，都有一个重叠区域模型是相同的。但区别是Shared Kernel是两个合作模式，Comformist是一个团队依附另一个团队。</p>
<h3 id="Anticorruption-Layer"><a href="#Anticorruption-Layer" class="headerlink" title="Anticorruption Layer"></a>Anticorruption Layer</h3><p>新系统与老系统集成是很常见的。但边界发生渗透时，转化层就要承担更多的防护责任。</p>
<p><strong>创建一个隔离层，以便根据自己的领域模型来为客户提供相关的功能，这个层主要通过另一个系统现有接口与其对话，而只需对那个系统做出很少的修改，甚至无需修改，在内部，这个层在两个模型之间进行必要的双向转化。</strong></p>
<h4 id="设计Anticorruption-Layer接口"><a href="#设计Anticorruption-Layer接口" class="headerlink" title="设计Anticorruption Layer接口"></a>设计Anticorruption Layer接口</h4><p><strong>Anticorruption Layer的公共接口通常以一组Service的形式出现</strong>，但偶尔也会采用Entity的形式。</p>
<p>构建一个全新的层来负责两个系统之间的语义转化使我们能够重新对另外一个系统的行为进行抽象，并<strong>按照我们的模型一致</strong>的方式把服务和信息提供给我们的系统。</p>
<h4 id="实现Anticorruption-Layer"><a href="#实现Anticorruption-Layer" class="headerlink" title="实现Anticorruption Layer"></a>实现Anticorruption Layer</h4><p>对Anticorruption Layer 进行组织的一种方法是把他实现为<strong>Facade、Adapter和转换器的组合</strong>。外加两个之间进行对话对话所需的通信和传输机制。</p>
<p><strong>Facade</strong>是一个子系统的一个可供替换的接口。Facade并不改变底层系统的模型，他应该严格按照另一个系统的模型来编写。Facade应该属于另外一个系统Bounded Context。他只是为了满足你的专门需要而呈现出的一个更友好的外观。一般Facade在另外一个子系统里面，如果另外一个子系统很简单或者有一个整洁的额接口，可能就需要Facade。</p>
<p><strong>Adapter</strong>是一个包装器。当客户向适配器发送一条消息是，Adapter把消息转为一条语义上等同的消息，并将其发送给”被适配者“。之后Adapter对响应消息进行转换，并将其发挥。</p>
<p><strong>Service</strong>都需要一个支持其接口的Adapter，这个适配器还需要怎么样才能向其他系统及其Facade发送相应的请求。</p>
<p><strong>Translator</strong>是一个转换器，他值属于它服务的Adapter，不需要用状态，他是负责将概念对象转为实际需要发送的对象。</p>
<h3 id="Separate-Way-各行其道"><a href="#Separate-Way-各行其道" class="headerlink" title="Separate Way(各行其道)"></a>Separate Way(各行其道)</h3><p>如果两组功能之间的关系并不必不可少，那么两者完全可以彼此独立。</p>
<p><strong>集成总是代价高昂，而有时收益却很小，此时声明一个与其他上下文毫无关联的Bounded Context，使开发人员在这个小范围内找到简单、专用的解决方案。</strong></p>
<h3 id="Open-Host-Service（开放主机）"><a href="#Open-Host-Service（开放主机）" class="headerlink" title="Open Host Service（开放主机）"></a>Open Host Service（开放主机）</h3><p><strong>定义一个协议，把你的子系统作为一组Service，供其他系统访问，开放这个协议，以便所有需要与你子系统集成的人都可以使用它，当有新的集成需求时，就增强并扩展这个协议，但个别团队的特殊需求除外。满足这种特殊需求方法是使用一次性的转换器来扩充协议，以便使共享协议简单而内聚。</strong></p>
<p>通过一种协议开放能力出去</p>
<h3 id="Published-Language"><a href="#Published-Language" class="headerlink" title="Published Language"></a>Published Language</h3><p><strong>把一个良好文档化的、能够表达出所需领域信息的公共语言作为公共的通信媒介，必要时在其他信息与该语言进行转换。</strong></p>
<p>XML、IDL？？</p>
<h3 id="选择你模型上下文策略"><a href="#选择你模型上下文策略" class="headerlink" title="选择你模型上下文策略"></a>选择你模型上下文策略</h3><p>在任何事件、绘制出Context Map来反应当前情况都是很重要的。但是，一旦绘制好Context Map之后，你很可能改变现状。现在，你可以开始有意识地选择<strong>Context的边界和关系</strong>，以下是一些指导原则。</p>
<ol>
<li>团队决策或更高层的决策：在实践中，团队之间的行政关系往往决定了系统的集成方式。</li>
<li>置身上下文中：自己根据所设计中系统，感受边界。</li>
<li>转换边界：是选择较大的Bouned Context(任务更流畅)，还是选择较小的Bouned Context(沟通更流畅)</li>
<li>接受那些我们无法更改的事务：描述外部系统，保持边界</li>
<li>与外部系统的关系：三种模式（Separate way（不需要集成）、Confirmist（外部系统很重要）、Anticorruption layer（另外的系统设计很糟））</li>
<li>设计中的系统：在自己设计的系统的Bouned Context，持续集成，保持统一，如果团队扩大，就要考虑Shared Kernel、Customer/Supplier Development team、Separate way。（一般一个团队对一个Bouned Context）</li>
<li>用不同的模型满足不同的需求</li>
<li>部署：不同的上下文关系，部署不一样</li>
<li>权衡：我们需要在<strong>无缝功能集成的溢出和额外的协调和沟通</strong>成为做出权衡 ，不同关系对系统的控制程度以及团队的交流能力要求不同。</li>
</ol>
<h3 id="项目进行时"><a href="#项目进行时" class="headerlink" title="项目进行时"></a>项目进行时</h3><p>先确定一个ContextMap和组织架构。及时调整ContextMap，并及时调整团队组织架构。</p>
<h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>一般而言，分割Context是很容易的，但合并他们或者改变他们之间的关系是比较难的。下面是几种有代表性的修改。</p>
<ol>
<li>合并Context：Separate Way -》 Shared Kernel</li>
<li>合并Context：Shared Kernel -》 Continue Integration （单Context）</li>
<li>逐步淘汰遗留系统</li>
<li>Open Host Service -》 Publish Language （解决通信问题）</li>
</ol>
<h2 id="精炼"><a href="#精炼" class="headerlink" title="精炼"></a>精炼</h2><p><strong>精炼</strong>是把一堆混杂在一起的组件分开的过程，以便通过某种形式从中提取出最重要的内容。</p>
<p><img src="http://gdut_yy.gitee.io/doc-ddd/figures/ch15/fg15-1.jpg" alt="img"></p>
<h3 id="Core-Domain（核心领域）"><a href="#Core-Domain（核心领域）" class="headerlink" title="Core Domain（核心领域）"></a>Core Domain（核心领域）</h3><p><strong>为了使领域模型成为有价值的资产，必须整齐地梳理出模型的真正核心，并完全更具这个核心来创建应用程序的功能。</strong></p>
<p><strong>如果软件的核心模型实现的很差，那么无论技术基础设施有多好，无论支持功能有多完善，应用程序都不会为用户提供真正有吸引力的功能。</strong></p>
<p><strong>对模型进行精炼，找到Core Domain并提供一种易于区分的方法把他与那些起辅佐作用的模型和代码分开。最有价值和最专业的概念要轮廓分明。尽量压缩Core Domain。</strong></p>
<p>下面是方法能够让我们更容易发现、使用、修改Core Domain</p>
<h4 id="发现核心"><a href="#发现核心" class="headerlink" title="发现核心"></a>发现核心</h4><p>如果某个设计部分需要保密以便保持竞争优势，那么他就是你的<strong>Core Domain。</strong></p>
<p>我们需要关注的是那些能够表示业务领域并解决业务问题的模型问题部分。</p>
<h4 id="工作分配"><a href="#工作分配" class="headerlink" title="工作分配"></a>工作分配</h4><p>建立一支有核心开发人员和以为或多维领域专家组成的团队。</p>
<h3 id="Generic-SubDomain-通用子领域"><a href="#Generic-SubDomain-通用子领域" class="headerlink" title="Generic SubDomain (通用子领域)"></a>Generic SubDomain (通用子领域)</h3><p>模型中充斥着大量周知的<strong>一般原则</strong>，或者是<strong>专门的细节</strong>，这些细节不是我们的主要关注点，而只是起到支持作用。然而无论他们是多么通用的元素，他们对实现系统功能和充分表达模型都是极为重要的，这就是<strong>Generic SubDomain。</strong></p>
<p>识别出那些与<strong>项目意图无关</strong>的内聚子领域。把这些子领域的通用模型提取出来，并放到单独的Module中。任何专有的东西都不应用放在这些模块中。 比如调度中心、比如工作流？</p>
<p>把他们分离出来，在继续开发的过程中，他们的优先级应低于Core Domain的优先级，并且不要分配核心开发人员来完成这些任务，此外，还可以考虑为这些Generic SubDomain使用现成的解决方案或者”公开发布的模型”。</p>
<h4 id="通用不等于不可重用"><a href="#通用不等于不可重用" class="headerlink" title="通用不等于不可重用"></a>通用不等于不可重用</h4><p><strong>通用不一定是代码的重用，模型的重用是更高级的重用。</strong></p>
<h3 id="Domain-Version-Statement（愿景说明）"><a href="#Domain-Version-Statement（愿景说明）" class="headerlink" title="Domain Version Statement（愿景说明）"></a>Domain Version Statement（愿景说明）</h3><p>Domain Version Statement：<strong>写一份Core Domain的简短描述以及它将创造的价值，展示出领域模型是如何实现和均衡各方利益的</strong>。它可以用来作为一个指南，帮助开发团队在精炼模型和代码的过程中保持统一的方向。</p>
<h3 id="Highlighted-Core（突出核心）"><a href="#Highlighted-Core（突出核心）" class="headerlink" title="Highlighted Core（突出核心）"></a>Highlighted Core（突出核心）</h3><p>有了Domain Version Statement，团队成员大体上知道核心领域是什么构成的。但却不知道Core Domain到底包含哪些元素。</p>
<p><strong>对代码所做的重大结构性改变是识别Core Domain的理想方式，但这些改动往往无法再短期完成，</strong> 这个时候我们需要其他方式。</p>
<h4 id="精炼文档"><a href="#精炼文档" class="headerlink" title="精炼文档"></a>精炼文档</h4><p>创建一个单独的文档来描述和解释Core Domain。这个文档可能会很简单，只是最核心的概念对象的清单。它可能是一组描述这些对象的图、显示了他们最重要的关系（<strong>核心模型</strong>）、他可能在抽象层次上火通过示例来描述基本的交互过程（<strong>核心用例</strong>）。</p>
<h3 id="Cohesive-Mechanism-封装机制"><a href="#Cohesive-Mechanism-封装机制" class="headerlink" title="Cohesive Mechanism (封装机制)"></a>Cohesive Mechanism (封装机制)</h3><p><strong>把算法计算封装到一个单独的轻量级的框架中，然后用Intention-Revealing interface接口暴露出来</strong></p>
<p>比如组织架构相关问题变成图的计算、还有构造一个Specification框架，提供基本的组合操作</p>
<p>Generic SubDomain 还是以模型为主，只是没有Core Domain 重要，而Cohesive Mecheanism是为了提出来解决一些复杂的计算问题。</p>
<p>Cohesive Mecheanism可以是Core Domain的一部分，因为他很重要，在合适的时候也可以从新纳入Core Domain中。</p>
<h3 id="Segregated-Core（分离核心）"><a href="#Segregated-Core（分离核心）" class="headerlink" title="Segregated Core（分离核心）"></a>Segregated Core（分离核心）</h3><p>通过重构得到Segregated Core的一般步骤如下所示：</p>
<ol>
<li>识别出一个Core子领域（可能是从精炼文档中得到的）</li>
<li>把相关的类移到新的Module当中，并为模块命名</li>
<li>对代码进行重构，吧哪些不直接表示概念的数据和功能分离出来，</li>
<li>对新的Segregated Core Module进行重构，使其中的关系和交互变得交单</li>
<li>对另一个Core子领域重复这个过程</li>
</ol>
<p>如果当系统有一个很大的、非常重要的Bouned Context时，但模型的关键部分被大量支持特性功能掩盖了，那么就需要创建Segregated Core了</p>
<p><strong>看书上的例子， 很重要</strong></p>
<h3 id="Abstract-Core-（抽象核心）"><a href="#Abstract-Core-（抽象核心）" class="headerlink" title="Abstract Core （抽象核心）"></a>Abstract Core （抽象核心）</h3><p><strong>把模型中最基本的概念识别出来，并分离到不同的类、抽象类、或接口中。设计这个抽象模型使之能够表达出重要组件之间的大部分交互。把这个完整的抽象模型放到他自己的Module中。而专用的、详细的实现类则留在各个子领域定义的Module中。</strong> （多态）</p>
<p>现在，大部分专用的类都将应用Abstract Core Module，而不是其他专用的Module。Abstract Core提供了主要概念及其交互的简化视图。</p>
<p>应用是啥，SPI ？？？</p>
<h3 id="选择重构目标"><a href="#选择重构目标" class="headerlink" title="选择重构目标"></a>选择重构目标</h3><p>如果能重构Core Domain一定要接受挑战重构他。然后把支持性的子领域提炼成通用子领域。</p>
<h2 id="大型架构"><a href="#大型架构" class="headerlink" title="大型架构"></a>大型架构</h2><p><strong>在一个大的系统中，如果因为缺少一个全局性的原则而使人们无法根据元素在Bounded Context的角色来解释这些元素，那么就容易陷入”只见树木，不见森林”的境地。</strong></p>
<p>设计一种应用功能与整个系统的规则（或角色和关系）方法，使人们可以通过它在一定程度上了解各个部分在整理中所处的位置。这些方法如下：</p>
<p><img src="http://gdut_yy.gitee.io/doc-ddd/figures/ch16/fg16-1.jpg" alt="img"></p>
<p>大部分大型结构都无法用UML来表示，这些大型结构是用来勾画和解释模型和设计的。</p>
<h3 id="Evolving-Order-演变的顺序"><a href="#Evolving-Order-演变的顺序" class="headerlink" title="Evolving Order(演变的顺序)"></a>Evolving Order(演变的顺序)</h3><p>让概念上的大型架构随着应用程序一起演变。在选择大型架构的时候，应该侧重于整体模型的管理。</p>
<p>下面是几种常见的大型架构：</p>
<h3 id="System-MetaPhor（系统隐喻）"><a href="#System-MetaPhor（系统隐喻）" class="headerlink" title="System MetaPhor（系统隐喻）"></a>System MetaPhor（系统隐喻）</h3><p>System Metaphor是一种松散的、抑郁理解的大型架构。</p>
<p>完全看不懂，这到底是啥、？？</p>
<h3 id="Repsonsibility-Layer（职责层）最常用"><a href="#Repsonsibility-Layer（职责层）最常用" class="headerlink" title="Repsonsibility Layer（职责层）最常用"></a>Repsonsibility Layer（职责层）最常用</h3><p><strong>如果每个对象的职责都是人为分配的，将没有统一的指导原则和一致性，也无法把领域作为一个整体来处理，为了保持大模型的一致，有必要再职责上分配一定的结构化控制。</strong></p>
<p><strong>注意观察模型中的概念依赖性，以及领域中不同部分的变化频率和变化的原因。如果在领域中发现了自然的层次结构，就把他们转化为宽泛的抽象职责。这些职责应该描述系统的高层目标。对模型进行重构，使每个领域怼、Aggregate和Module的职责都清晰地位于一个职责层当中。</strong></p>
<p>主要观察依赖，依赖总是从上往下。</p>
<p>在为每个新模型定义层是不一定总是要从头开始。在一系列的相关领域中，有些层是固定的。</p>
<ol>
<li>潜能层。我们能做什么 （基础服务）</li>
<li>作业做。我们在做什么（领域能力）</li>
<li>决策支持层。应该采用什么行动或指定什么策略 ？？？</li>
<li>策略层。规则和目标是什么？？</li>
</ol>
<p>没太看懂为什么一般从策略层依赖到潜能层？？？</p>
<h3 id="Knowledge-Level（知识层）"><a href="#Knowledge-Level（知识层）" class="headerlink" title="Knowledge Level（知识层）"></a>Knowledge Level（知识层）</h3><p>Knowledge level是reflection（反射）模型在领域层的一种应用。</p>
<p><strong>创建一组不同的对象，用他们来描述和约束基本模型的结构和行为。并把这些对象分层两个”级别“，一个是非常具体的级别，另外一个级别则提供了一些可供用户或超级用户定制的规则和知识。</strong></p>
<p>看不太懂？？？大概就是提供一些可配置的规则层（知识层），然后另外是一个具体的类型，我也感觉知识层和策略层很像。</p>
<h3 id="Pluggable-Component-Framework（可插入组件框架）"><a href="#Pluggable-Component-Framework（可插入组件框架）" class="headerlink" title="Pluggable Component Framework（可插入组件框架）"></a>Pluggable Component Framework（可插入组件框架）</h3><p>通常只有在同一个领域中实现了多个应用程序，才有机会使用可插入式组件框架。</p>
<p>从结构和交互中提炼出一个Abstract Core，并创建一个框架，这个框架要允许这些接口的各种不同实现被自由替换。</p>
<p>他的缺点是它是一种非常难以使用的模式，他需要高精度的接口设计和一个非常深入的模型，以便把一些必要的行为捕获到Abstract Core中。另外一个缺点是它只为应用程序提供了优先的选择。</p>
<p>感觉很像大量使用SPI的框架。</p>
<h2 id="领域设计的综合运用"><a href="#领域设计的综合运用" class="headerlink" title="领域设计的综合运用"></a>领域设计的综合运用</h2><p>战略设计的3个基本原则（上下文、精炼、和大型架构）并不是可以互相代替的，而是互为补充的，并且以多种方式进行互动。</p>
<h3 id="大型结构和Bounded-Context结合"><a href="#大型结构和Bounded-Context结合" class="headerlink" title="大型结构和Bounded Context结合"></a>大型结构和Bounded Context结合</h3><p>例如，一种大型架构可以存在于一个Bounded Context中，也可以跨域多个Bounded Context存在，并用于组织Context Map。</p>
<h3 id="大型结构与精炼结合起来使用"><a href="#大型结构与精炼结合起来使用" class="headerlink" title="大型结构与精炼结合起来使用"></a>大型结构与精炼结合起来使用</h3><p>例如，大型架构可以帮助解释Core Domain内部的关系以及Generic SubDomain之间的关系</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>保持持续迭代</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：业务开发必不可少！！
    
    </summary>
    
      <category term="读书笔记" scheme="http://bestlixiang.site/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DDD" scheme="http://bestlixiang.site/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>一段时间的思考</title>
    <link href="http://bestlixiang.site/2020/04/04/%E7%94%9F%E6%B4%BB/%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://bestlixiang.site/2020/04/04/生活/一段时间的思考/</id>
    <published>2020-04-04T06:14:41.000Z</published>
    <updated>2020-04-04T09:07:58.549Z</updated>
    
    <content type="html"><![CDATA[<p>引：每次实习的时间都不是特别长，以为实习就是有活干，把自己手上的东西弄清楚就完事了，但是总感觉现在这样是不行的，我们总需要额外做一些事情，我想只有这样才能更好的进步吧。所以这里也就简单梳理一下自己理解的方向，找出一点先干下去！<a id="more"></a></p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>基础这个，自己是应该好好继续务实的，毕竟基础不牢，地动山摇！每次在深入研究一个东西的时候，就会感觉到自己对基础的不熟，导致自己“被迫”放弃，这种感觉实属打击，希望以后“被迫”放弃来的少一些。</p>
<p>所谓基础也就是大家公认的基础：</p>
<ul>
<li><p>计算机组成原理</p>
</li>
<li><p>计算机网络</p>
</li>
<li><p>数据结构</p>
</li>
<li><p>操作系统</p>
</li>
<li><p>编译原理</p>
</li>
</ul>
<p><strong>不求快，但求实</strong></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>自己也算经历过js、java、python、go等语言，可能真正熟悉的也只有java，其次是go。虽然go也支持oop，但是真正写时，还是会感觉有很大的不同。</p>
<p>上面提到基础也是为了让我们写出更适合计算机运行的代码，除此之后好的代码更找到是给人看的，最近也参加了很多code review，其实会发现其实真正能写出”代码自译”的代码是很难的，但是我们不能放弃，我们要以此为目标。</p>
<p>不同语言写出来的代码风格是不一样的（这个要多写，多看，写总结），但是前人总结出的设计模式是不会错的。说到设计模式，大家一定能到大名鼎鼎的23种设计模式，但是我们现实中说到的设计模式是包含但不仅包含这23种。但是认真去看会发现这些设计模式都在传递一个概念”<strong>高内聚，低耦合</strong>“。按照这个概念写出来的代码一定是质量比较高的。</p>
<p>最近，身边的人经常提到单元测试，想到自己现在写的代码测试，基本属于单个”集成测试”，哈哈，只是为了避免点点点。这个需要尽力改正。之前也看到过一篇文章，大意就是：当你写出了<strong>可测试的代码</strong>，基本代码也就符合了”<strong>高内聚，低耦合</strong>“。很多概念总是环环相扣。</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>关于架构，我想的是主要分为技术架构和业务架构，这里简单说说，在下菜鸡。</p>
<ul>
<li>技术架构：可能又要分为IO密集型架构和CPU密集型架构<ul>
<li>IO密集型架构：我想主要在数据处理，比如如何减少rpc时间，多机房容灾，利用mq异步处理，数据库的选型等等</li>
<li>CPU密集型架构：我想主要利用AI算力，了解微乎其微</li>
</ul>
</li>
<li>业务架构：我想最重要的就是分析问题（常见case），整理出需求，抽象出能力，然后划分为业务领域(服务)，最后在各个服务细化。这里再划分出业务利用我们可以有效的利用DDD来帮助我们确定服务边界。DDD在具体实现上，我个人觉得是比较难完全落地的，但是对于确定业务边界是很有帮助的。最后再多个产品的实现过程中，我们要抽离出通用的基础服务，以便更好地在有新产品需求的时候，能快速落地。当然在利用DDD划分业务领域的时候需要强大的业务背景，这是需要不断积累的。这也是业务背景带来的价值。</li>
</ul>
<h1 id="SRE"><a href="#SRE" class="headerlink" title="SRE"></a>SRE</h1><p>前面讲的是从在接到需求之后，我们确定技术架构，业务架构，语言选型，以及代码书写等方面。但是我们在写完代码之后，这不是项目的结束，而是新的开始，如何保证代码的质量，以及后续的迭代开发，以及保证服务的稳定性都是一个好的产品，一个质量高的软件项目需要考虑的事情，这里需要很多很多工具来支持。下面也简单说说我遇到的一些内容。</p>
<ul>
<li><p>日志系统：这里很重要，毕竟我们查问题，第一想到的就是利用日志，每家公司都有自己的日志系统，日志系统的实现都是基础都是利用ES等技术，比如graylog。在打日志的时候我们也需要在合适的位置，打上合适的日志，不要多，不要少。这个要根据自己的需要，带上合适的信息。</p>
</li>
<li><p>监控系统：我们不能保证系统一直不出问题，但是我们要及时发现问题，这里就需要监控，监控又会分为业务监控和系统监控，系统监控主要包含运行软件的物理设施状态，比如cpu、内存、磁盘等等的报警，业务监控主要包含业务系统定义的错误，这些业务错误需要上报，主要利用时序数据库来存储这些信息，最后我们可以利用grafana来可视化这些数据，利用sentry来进行业务报警通知。</p>
</li>
<li><p>代码质量：这里可能需要从代码源头开始，比如在IDE上加上一个lint来保证编写时的代码质量，然后用比如sonar之类的软件来监控代码质量，还有在发布前我们可能需要像tesla质量的软件来跑一些主要流程的集成测试，关于这里测试我们又可以用jenkins之类的CI工具来帮助我们来自动化执行我们这些流程。最后关于代码这里的底线就要是做到利用git之类的工具做到版本控制。</p>
</li>
<li><p>部署：这一块我们主要是利用docker和k8s来进行CD，在k8s的帮助下，我们可以做到动态的扩容或者缩容，当然要是能做到自动扩容是最好的。然后在发布的时候我们也要支持灰度发布，蓝绿发布等等，这样能保证在升级的时候遇到问题尽可能做到影响最小。</p>
</li>
</ul>
<p>上面都是自己的理解的理解，问题可能会很多，也有错误的地方，自己以后感觉到不会的时候，或者有补充的时候也会来及时打补丁。</p>
<h1 id="技术之外"><a href="#技术之外" class="headerlink" title="技术之外"></a>技术之外</h1><p>之前讲的都是技术相关，这里想讲一下技术之外的事情， 比如自己薄弱的沟通能力。</p>
<p>加粗：<strong>所有将不清楚的事情都是因为自己没理解</strong></p>
<p>这里只能对自己说：自己需要在理解事情之后主动沟通，尽早暴露出问题，尽早解决问题。手动狗头！！</p>
<p>太难了，我！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：每次实习的时间都不是特别长，以为实习就是有活干，把自己手上的东西弄清楚就完事了，但是总感觉现在这样是不行的，我们总需要额外做一些事情，我想只有这样才能更好的进步吧。所以这里也就简单梳理一下自己理解的方向，找出一点先干下去！
    
    </summary>
    
      <category term="生活" scheme="http://bestlixiang.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="思考" scheme="http://bestlixiang.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>JVM问题解决思路总结</title>
    <link href="http://bestlixiang.site/2019/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://bestlixiang.site/2019/07/11/深入理解Java虚拟机/JVM问题解决思路总结/</id>
    <published>2019-07-11T00:41:21.000Z</published>
    <updated>2019-07-11T00:40:16.174Z</updated>
    
    <content type="html"><![CDATA[<p>引：JVM对于大部分没有看过源码的人(包括我)来说是抽象的，自然也就看不见真相。此时我们所谓的”真相”更多是来自于博客和别人的话语，当这些抽象的概念被重复多次之后也就变成了我们所理解的”真相”，下面我们就来看看这些”真相”！并理解这些”真相”去解决问题。<a id="more"></a></p>
<h1 id="前置真相"><a href="#前置真相" class="headerlink" title="前置真相"></a>前置真相</h1><ol>
<li><p>JVM运行时内存结构，重点是<strong>堆的结构</strong>(最基础的，这里就不多说了)</p>
</li>
<li><p>Java垃圾收集器，重点是<strong>CMS收集器</strong>(看参考的那边文章就够啦)</p>
</li>
<li><p>对象<strong>从内存分配到垃圾回收</strong>，下面是自己的总结：</p>
<ul>
<li><p>内存分配</p>
<ol>
<li><p>对象如果开启TLAB先分配在TLAB(Thread Local Allocation Buffer)，不然分配在Eden区</p>
</li>
<li><p>大对象直接配置在老年代(具体参数为PretenureSizeThreshold)</p>
</li>
</ol>
</li>
<li><p>垃圾收集</p>
<p>发生MinorGC，会将没死的对象复制在Survivor区，这里有两种情况：</p>
<ol>
<li>如果有相同年龄的对象大于Survivor区的一半，则进入老年代</li>
<li>如果survivior区的对象年龄超过默认15（具体参数为MaxTenuringThreshold，这里可能会动态调整），进入老年代</li>
</ol>
<p>在进行MinorGC之前，有个空间担保的概念（老年代要放得下新生代的对象）的判断：</p>
<p>如果老年代连续空间的大小 <strong>大于</strong> 新生代总大小或者历次晋升到老年代的平均大小 就会进行Minor GC，否则将进行Full GC</p>
<p>进行FullGC还有下面几种情况：</p>
<ol>
<li>发生concurrent mode failure（由于并发清除阶段，用户线程产生的对象进入老年代）会引起Full GC，这种情况下会使用Serial Old收集器</li>
<li>Minor GC后发生的担保失败（promotion failed）会触发FullGC</li>
<li>永久代空间（Metaspace）不足会触发Full GC</li>
<li>System.gc()引起的Full GC(一般会禁掉)</li>
<li>老年代不足会触发FullGC</li>
</ol>
<p>这里再说一点，所谓的Full GC其实很多时候是和MajorGC相等的，只有在CMS的时候才有会MajorGC，因为只有它需要在老年代达到一定大小的时候会触发MajorGC(对应参数CMSInitiatingOccupancyFraction，默认92%)，其他都是发送在老年代满的时候发生FullGC，这时候包括MajorGC和MinorGC。</p>
</li>
</ul>
</li>
</ol>
<p>上面这些”真相”对我们来说是解决问题的基础。</p>
<h1 id="实践工具"><a href="#实践工具" class="headerlink" title="实践工具"></a>实践工具</h1><p>JDK的bin目录下提供了很多工具，我们可以利用这些工具来处理数据，这些<strong>数据</strong> 包括： 运行日志、异常堆栈、GC日志、线程快照(threaddump/javacore文件)、堆转储快照(heapdump/hprof文件)等。</p>
<p>简单介绍几个工具：</p>
<ol>
<li>jps ：虚拟机进程状况工具，获得java进程</li>
<li>jstat：虚拟机信息监控工具，可以获得类装载、内存、垃圾收集、JIT编译参数</li>
<li>jinfo：配置信息工具，实时查看和调整虚拟机的各项参数</li>
<li>jmap：内存映像工具，可以获得堆内存信息以及获得堆转储快照</li>
<li>jstack：堆栈跟踪工具，可以获得线程快照</li>
</ol>
<p>上面都是命令行工具，下面说两个图形界面工具：</p>
<ol>
<li>VisualVM：多合一故障处理工具，通过插件扩展可以做到：<ul>
<li>显示虚拟机进程以及配置信息(jps、jinfo)</li>
<li>监控应用程序的CPU、GC、堆、方法区(Metaspace)、以及现场的信息(jstat、jstack)</li>
<li>dump以及分析堆转储快照(jmap、jhat)</li>
</ul>
</li>
<li>GC easy：图形化GC 日志</li>
</ol>
<h1 id="问题探索"><a href="#问题探索" class="headerlink" title="问题探索"></a>问题探索</h1><p>在我们拥有了相关”真相”知识和数据，还有工具，我们就可以解决很多问题，如下：</p>
<h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><p>调优一般步骤可以概括为：确定目标、优化参数、验收结果</p>
<p>明确应用程序的系统需求是性能优化的基础，系统的需求是指应用程序运行时某方面的要求，譬如： </p>
<ul>
<li>高可用，可用性达到几个9</li>
<li>低延迟，请求必须多少毫秒内完成响应</li>
<li>高吞吐，每秒完成多少次事务</li>
</ul>
<p>对于大部分应用来说，主要考虑两点：<strong>高可用和低延迟</strong>，其他再小一点就是<strong>低延迟</strong>，这也是我们为什么会使用<strong>ParNew+CMS</strong>的原因。</p>
<p>对于低延迟，主要有两个考量：<strong>GC的次数和GC的时间 </strong>，所以下面列举几个需要优化的点：</p>
<h3 id="MajorGC"><a href="#MajorGC" class="headerlink" title="MajorGC"></a>MajorGC</h3><p>虽然MajorGC 发生STW(stop the world)的时候比较短，但是次数多了影响也比价大，这里我们主要是减少它的次数，为了减少它的次数直接方法就是增加Eden区的大小，但是增加Eden区的大小会增加STW的时间，所以我们这里需要做一个权衡。下面是一个例子：</p>
<ul>
<li>扩容前：新生代容量为R ，假设对象A的存活时间为750ms，Minor GC间隔500ms，那么本次Minor GC时间= T1（扫描新生代R）+T2（复制对象A到S）。</li>
<li>扩容后：新生代容量为2R ，对象A的生命周期为750ms，那么Minor GC间隔增加为1000ms，此时Minor GC对象A已不再存活，不需要把它复制到Survivor区，那么本次GC时间 = 2 × T1（扫描新生代R），没有T2复制时间。</li>
</ul>
<p>对于虚拟机来说，复制对象的成本要远高于扫描成本。因此如果堆<strong>短期对象很多</strong>，那么扩容新生代，单次Minor GC时间不会显著增加。关于这个周期就需要观察自己的应用代码以及GC日志或者利用Visual VM直接看扩容后MinorGC之后新生代内存的变化。增加了Eden的大小，还有一个好处就是老年代的对象也会减少。在《Java性能优化指南》的指导下，我们一般设置新生代的初始化为堆的3/8。</p>
<h3 id="CMS的Remark"><a href="#CMS的Remark" class="headerlink" title="CMS的Remark"></a>CMS的Remark</h3><p>CMS垃圾收集器在Remark阶段是STW的，所以我们要尽力减少这段时间，由于新生代对象持有老年代中对象的引用，所以会扫描新生代和老年代，这个时候如果<strong>新生代的对象很多</strong>，会严重影响Remark阶段的耗时。由于新生代中对象的生命周期很短，这样如果在Remark前执行一次Minor GC，大部分对象就会被回收，可以很好的减少Remark阶段的耗时。<strong>为此CMS在Remark前增加了一个可中断的并发预清理阶段</strong>，该阶段主要工作仍然是并发标记对象是否存活，只是这个过程可被中断。此阶段在Eden区使用超过2M时启动，当然2M是默认的阈值，可以通过参数修改（在参考中CMS那边博客有详细说明）。如果此阶段执行时等到了Minor GC，那么新生代的部分对象将被回收，Reamark阶段需要扫描的对象就少了。除此之外CMS为了避免这个阶段没有等到Minor GC而陷入无限等待，提供了参数<strong>CMSMaxAbortablePrecleanTime </strong>，默认为5s，含义是如果可中断的预清理执行超过5s，不管发没发生Minor GC，都会中止此阶段，进入Remark阶段。 这个时候如果Remark时新生代中仍然有很多对象，耗时还是会很长，CMS提供<strong>CMSScavengeBeforeRemark</strong>参数，用来保证Remark前强制进行一次Minor GC。</p>
<h3 id="FullGC"><a href="#FullGC" class="headerlink" title="FullGC"></a>FullGC</h3><p>对于CMS来说，FullGC的STW时间主要集中在Remark阶段，上面也只是减少GC时间，我们还有另外一个考量：GC次数。这次要用到我们刚开始说的”真相”了——FullGC发生的情况。通过GC日志，我们很容易确定发生FullGC的原因。我们可以根据具体的原因来调整参数。这里有一点就是如果是<strong>老年代不足会触发FullGC</strong>，我们就需要分析是否有<strong>内存泄漏</strong>，我们放在下面说。</p>
<h2 id="内存溢出异常"><a href="#内存溢出异常" class="headerlink" title="内存溢出异常"></a>内存溢出异常</h2><p>这个会分为以下几种情况：</p>
<ol>
<li>堆溢出：这里我们需要分析代码中是否有大对象没有即时置空或者是否有内存泄漏，一般在堆溢出的时候我们会dump出堆转储快照，我们可以利用工具进行分析，具体分析可以在参考中找到，如果我们两次dump出文件对比发现有同样的对象都没有被回收，我们就需要看看是否有内存泄漏的可能性。</li>
<li>栈溢出：栈溢出一般会在<strong>运行日志</strong>中输出异常堆栈，我们可以从异常堆栈中找到提示信息，最近我就遇到过一次，原因是下游系统提供的api中打印了利用fastjson序列化的一个SpringBean🤣，fastjson是递归去序列化的，而这个bean层级太深 ，也就到导致了栈溢出。这里也告诉我们一定要注意<strong>递归深度</strong>。</li>
<li>Metaspace溢出：Metaspace主要是存一些类信息，在JDK8中它已经移动到直接内存中，这也表明了它受限于系统内存，一般情况下是不会溢出的。</li>
<li>直接内存溢出：直接内存的溢出基本是由于DirectByteBuffer类和MappedByteBuffer类，堆外内存在VisualVM的Buffer Pools插件也可以监控得到。在参考中也有一篇文章是分析直接内存溢出的。</li>
</ol>
<h2 id="CPU飚高"><a href="#CPU飚高" class="headerlink" title="CPU飚高"></a>CPU飚高</h2><p>Java应用导致CPU飚高的有下面几种情况：</p>
<ol>
<li><p>程序计算比较密集，如FullGC频繁</p>
</li>
<li><p>程序死循环</p>
</li>
<li><p>程序逻请求堵塞，自旋</p>
</li>
<li>IO读写太高 </li>
</ol>
<p>有了上面的”真相”，我们解决问题起来也很好办了。主要是先找出cpu使用率高的线程(利用top命令)，然后利用jstack或者Visual VM找到相应的堆栈信息，根据堆栈信息定位代码，解决问题。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnblogs.com/littleLord/p/5380624.html" target="_blank" rel="noopener">详解CMS垃圾回收机制</a></li>
<li><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">从实际案例聊聊Java应用的GC优化</a></li>
<li><a href="https://blog.csdn.net/kl28978113/article/details/53817827" target="_blank" rel="noopener">JVisualVM简介与内存泄漏实战分析</a></li>
<li>《深入理解Java虚拟机》</li>
<li>《Java性能优化指南》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：JVM对于大部分没有看过源码的人(包括我)来说是抽象的，自然也就看不见真相。此时我们所谓的”真相”更多是来自于博客和别人的话语，当这些抽象的概念被重复多次之后也就变成了我们所理解的”真相”，下面我们就来看看这些”真相”！并理解这些”真相”去解决问题。
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>文件读写哪家强？</title>
    <link href="http://bestlixiang.site/2019/07/07/Java%E5%9F%BA%E7%A1%80/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E5%93%AA%E5%AE%B6%E5%BC%BA%EF%BC%9F/"/>
    <id>http://bestlixiang.site/2019/07/07/Java基础/文件读写哪家强？/</id>
    <published>2019-07-07T11:11:27.000Z</published>
    <updated>2019-07-07T06:51:32.351Z</updated>
    
    <content type="html"><![CDATA[<p>引：最近看了零拷贝相关的内容，自然而然就会引申到文件的读写，文件读写无处不在，因为数据很重要，需要持久化。刚好最近也看看RocketMq，里面也有关于消息文件的读写，想狠狠了解一番，但是最终结果是只知道了性能结果，但是却不明白为什么，留下一些线索，等待回头<strong>证明</strong> ！徐大佬说要去看linux源码可能才有了解，先溜了！渴望c大神带我看一遍！<a id="more"></a></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>Java 中的文件读写接口大致可以分为三类：</p>
<ol>
<li>标准 IO 读写，位于 java.io 包下，相关类：FileInputStream，FileOuputStream，RandomAccessFile</li>
<li>NIO 读写，位于 java.nio 包下，相关类：FileChannel，ByteBuffer</li>
<li>Mmap 内存映射，位于 java.nio 包下，相关类：FileChannel，MappedByteBuffer</li>
</ol>
<p>标准 IO 读写这里就不说，毕竟大家一开始学的都是这个，下面说说其他两种。</p>
<h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得FileChannel</span></span><br><span class="line">FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"data"</span>), <span class="string">"rw"</span>).getChannel();</span><br><span class="line"><span class="comment">// 写</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">1024L</span>;</span><br><span class="line"><span class="comment">//指定 position 写入 4kb 的数据</span></span><br><span class="line">fileChannel.write(ByteBuffer.wrap(data), position);</span><br><span class="line"><span class="comment">//从当前文件指针的位置写入 4kb 的数据</span></span><br><span class="line">fileChannel.write(ByteBuffer.wrap(data));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读 </span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">1024L</span>;</span><br><span class="line"><span class="comment">//指定 position 读取 4kb 的数据</span></span><br><span class="line">fileChannel.read(buffer,position)；</span><br><span class="line"><span class="comment">//从当前文件指针的位置读取 4kb 的数据</span></span><br><span class="line">fileChannel.read(buffer);</span><br></pre></td></tr></table></figure>
<p>上面的<code>ByteBuffer</code> 也可以替换为<code>DirectByteBuffer</code>，这里不替换，在最后写入的时候也会替换，具体为什么，可以参考徐大佬的博客。</p>
<h2 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得MappedByteBuffer</span></span><br><span class="line">FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"data"</span>), <span class="string">"rw"</span>).getChannel();</span><br><span class="line">MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, filechannel.size());</span><br><span class="line"><span class="comment">// 写</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> position = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//从当前 mmap 指针的位置写入 4b 的数据</span></span><br><span class="line">mappedByteBuffer.put(data);</span><br><span class="line"><span class="comment">//指定 position 写入 4b 的数据</span></span><br><span class="line">MappedByteBuffer subBuffer = mappedByteBuffer.slice();</span><br><span class="line">subBuffer.position(position);</span><br><span class="line">subBuffer.put(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> position = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//从当前 mmap 指针的位置读取 4b 的数据</span></span><br><span class="line">mappedByteBuffer.get(data)；</span><br><span class="line"><span class="comment">//指定 position 读取 4b 的数据</span></span><br><span class="line">MappedByteBuffer subBuffer = mappedByteBuffer.slice();</span><br><span class="line">subBuffer.position(position);</span><br><span class="line">subBuffer.get(data);</span><br></pre></td></tr></table></figure>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>自己跟着@莫那——鲁道的benchmark过了一遍，结论统一(原因不知)：</p>
<table>
<thead>
<tr>
<th>数据包大小</th>
<th>读</th>
<th>写</th>
<th>force写</th>
</tr>
</thead>
<tbody>
<tr>
<td>小于4kb</td>
<td>mmap</td>
<td></td>
<td></td>
</tr>
<tr>
<td>大于4kb</td>
<td>FileChannel</td>
<td></td>
<td></td>
</tr>
<tr>
<td>小于64b</td>
<td></td>
<td>FileChannel</td>
<td>FileChannel</td>
</tr>
<tr>
<td>大于64b</td>
<td></td>
<td>Mmap</td>
<td>FileChannel</td>
</tr>
</tbody>
</table>
<h1 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h1><p>普通人一生必经的四个阶段：</p>
<p>心比天高的无知与快乐</p>
<p>愧不如人的奋斗与煎熬</p>
<p>毫无回报的愤懑与失望</p>
<p>坦然自若的平凡与颓废</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/d0b4ac90dbcb" target="_blank" rel="noopener">MappedByteBuffer VS FileChannel 孰强孰弱？</a></li>
<li><a href="https://www.cnkirito.moe/mq-million-queue/" target="_blank" rel="noopener">天池中间件大赛百万队列存储设计总结【复赛】</a></li>
<li><a href="https://www.cnkirito.moe/file-io-best-practise/" target="_blank" rel="noopener">文件IO操作的一些最佳实践</a></li>
<li><a href="https://www.cnkirito.moe/nio-buffer-recycle/" target="_blank" rel="noopener">一文探讨堆外内存的监控与回收</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：最近看了零拷贝相关的内容，自然而然就会引申到文件的读写，文件读写无处不在，因为数据很重要，需要持久化。刚好最近也看看RocketMq，里面也有关于消息文件的读写，想狠狠了解一番，但是最终结果是只知道了性能结果，但是却不明白为什么，留下一些线索，等待回头&lt;strong&gt;证明&lt;/strong&gt; ！徐大佬说要去看linux源码可能才有了解，先溜了！渴望c大神带我看一遍！
    
    </summary>
    
      <category term="Java基础" scheme="http://bestlixiang.site/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="IO" scheme="http://bestlixiang.site/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>零拷贝</title>
    <link href="http://bestlixiang.site/2019/07/07/Java%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <id>http://bestlixiang.site/2019/07/07/Java基础/零拷贝/</id>
    <published>2019-07-07T03:19:21.000Z</published>
    <updated>2019-07-07T03:21:14.647Z</updated>
    
    <content type="html"><![CDATA[<p>引：<strong>零拷贝</strong>是在文件读写以及数据传输中必须了解的优化措施。在 Java 程序员的世界，常用的零拷贝有 mmap 和 sendFile。自己之前也总是模模糊糊的了解，这次看到一篇文章让自己印象很深刻，下面我将会是翻译一下并加以引申！<a id="more"></a></p>
<h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><p><a href="https://www.linuxjournal.com/article/6345" target="_blank" rel="noopener">Zero Copy I: User-Mode Perspective</a></p>
<h1 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h1><p>如今几乎每个人都听说过在Linux下的零拷贝功能，但是我经常遇到人没有充分理解这个问题的。因此，我决定写一些文章深入研究得深一些,希望能解开这个有用的功能。在本文中，我们将从用户空间应用程序的角度来看看<strong>零拷贝</strong>,所以复杂的内核级细节是故意省略了的。</p>
<p><strong>零拷贝是什么? </strong>　　</p>
<p>为了更好地理解一个问题的解决方案，我们首先需要了解问题本身。让我们来看看数据存储在一个文件中通过网络发送应用简单过程。这里有一些示例代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>
<p>看起来很简单，你会认为没有多少开销，只有这两个系统调用。在现实中，这两个系统调用数据被复制至少四次，而且做了很多的用户/内核执行上下文切换(实际上这个过程要复杂得多,但我想保持它简单)。看看下图。顶部显示上下文切换，底部显示复制操作。</p>
<p><img src="https://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/063/6345/6345f1.jpg" alt="系统调用"></p>
<p>第一步: read系统调用会导致从用户模式到内核模式的上下文切换。第一次复制是利用DMA从磁盘读取文件内容，并将它们存储到一个内核地址空间缓冲区。</p>
<p>第二步：数据从内核缓冲区拷贝到用户缓冲区。同时read系统调用返回，该调用的返回引发了内核模式到用户模式的上下文切换。现在数据被储存在用户地址空间缓冲区,</p>
<p>第三步：write系统调用会导致用户模式到内核模式的上下文切换。同时将数据复制到内核地址空间缓冲区。这一次,数据放入不同的缓冲，这个缓冲与套接字相关联。</p>
<p>第四步：系统调用返回，发生了第4次上下文切换。同时DMA独立且异步将数据从内核缓冲区复制到网卡。你可能会问自己，”独立和异步?不是在返回用户模式之前调用吗？”，事实上，这里并不保证传输，它甚至不保证传输的开始。这仅仅意味着以太网驱动程序的队列有空位，并接受了我们的数据传输。可能会有众多的数据排在我们的数据之前。(分叉的DMA复制在图中说明了这个事实，最后复制可以延迟)。</p>
<p>正如您可以看到的，大量的数据复制并不是必需的东西。某些冗余可以被消除，以减少开销和提高性能。作为硬件驱动程序开发人员，有一些很高级的特性。一些硬件可以完全绕开内存,将数据直接传送给另一个设备。这个特性消除了系统内存复制，是一个好事，但并不是所有的硬件支持。为了减少开销，我们可以从消除内核和用户缓冲区之间的复制。</p>
<p>消除一个复制的一个方法是调用<strong>mmap系统调用</strong>读。例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmp_buf = mmap(file, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>
<p><img src="https://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/063/6345/6345f2.jpg" alt="系统调用读"></p>
<p>第一步：mmap系统调用会利用DMA将文件内容复制到内核缓冲区的。内核缓冲去与用户缓存区共享一个空间，没有任何复制内存在内核和用户空间之间进行。</p>
<p>第二步：write系统调用会导致内核数据从原来的内核缓冲区复制到与套接字相关联的内核缓冲区。</p>
<p>第三步：DMA将数据从内核套接字缓冲区复制到网卡。</p>
<p>用mmap而不是read，我们可以减少一半内核复制的数据量。当拷贝数据量很大时，无疑提升了效率。但是使用mmap是有代价的。当你使用mmap时，你可能会遇到一些隐藏的陷阱。例如，当你的程序map了一个文件，但是当这个文件被另一个进程截断(truncate)时, write系统调用会因为访问非法地址而被SIGBUS信号终止。SIGBUS信号默认会杀死你的进程并产生一个coredump,如果你的服务器这样被中止了，那会产生一笔损失。 通常我们使用以下两种解决方案避免这种问题：</p>
<p>第一种方式是<strong>为SIGBUS信号建立信号处理程序 </strong>。当遇到SIGBUS信号时，信号处理程序简单地返回，write系统调用在被中断之前会返回已经写入的字节数，并且errno会被设置成success,但是这是一种糟糕的处理办法，因为你并没有解决问题的实质核心。 </p>
<p>第二种方式是<strong>使用文件租借锁</strong> 通常我们使用这种方法，在文件描述符上使用租借锁，我们为文件向内核申请一个租借锁，当其它进程想要截断这个文件时，内核会向我们发送一个实时的RT_SIGNAL_LEASE信号，告诉我们内核正在破坏你加持在文件上的读写锁。这样在程序访问非法内存并且被SIGBUS杀死之前，你的write系统调用会被中断。write会返回已经写入的字节数，并且置errno为success。 我们应该在mmap文件之前加锁，并且在操作完文件后解锁。下面是一些示例代码显示如何从内核:获得租借锁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fcntl(fd, F_SETSIG, RT_SIGNAL_LEASE) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"kernel lease set signal"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* l_type can be F_RDLCK F_WRLCK */</span></span><br><span class="line"><span class="keyword">if</span>(fcntl(fd, F_SETLEASE, l_type))&#123;</span><br><span class="line">    perror(<span class="string">"kernel lease set type"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消除一个复制的一个方法是<strong>Sendfile</strong></p>
<p>在内核版本2.1中，介绍了sendfile系统调用来简化数据的传输。引入sendfile不仅降低了数据复制，它还可以减少上下文切换。使用它是这样的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendfile(socket, file, len);</span><br></pre></td></tr></table></figure>
<p><img src="https://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/063/6345/6345f3.jpg" alt="sendfile"></p>
<p>第一步：sendfile系统调用会利用DMA让文件内容复制到内核缓冲区。然后由内核的数据复制到与套接字相关联的内核缓冲区。</p>
<p>第二步：第三次复制发生在DMA将数据从内核套接字缓冲区复制到网卡。</p>
<p>你可能会好奇，在我们调用sendfile时，如果有其它进程截断了文件会发生什么呢？假设我们没有设置任何信号处理程序，sendfile调用仅仅返回它在被中断之前已经传输的字节数，errno会被置为success。如果我们在调用sendfile之前给文件加了锁，sendfile的行为仍然和之前相同，我们还会收到RT_SIGNAL_LEASE的信号。</p>
<p>目前为止，我们已经减少了数据拷贝的次数了，但是仍然存在一次CPU拷贝，就是内核缓冲去到socket缓冲区的拷贝。那么能不能把这个拷贝也省略呢？借助于硬件上的帮助，我们是可以办到的。之前我们是把页缓存的数据拷贝到socket缓存中，实际上，我们仅仅需要把缓冲区描述符传到socket缓冲区，再把数据长度传过去，这样DMA可以直接将内核缓存区中的数据打包发送到网络中就可以了。如下图：</p>
<p><img src="https://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/063/6345/6345f4.jpg" alt="零拷贝"></p>
<p>这种是需要硬件的支持。步骤如下：<br>第一步：sendfile系统调用会利用DMA让文件内容复制到内核缓冲区。</p>
<p>第二步：没有内核缓冲区和与套接字相关联的内核缓冲区之间的复制，而是把缓冲区描述符和数据长度传到socket缓冲区。DMA会直接将内核缓存区的数据复制到网卡，这样就减少了最后一次CPU复制。</p>
<p>由于数据仍然存在是从磁盘复制到内存和从内存复制到网卡，有些人可能会认为这不是一个真正的零拷贝。但是从操作系统的角度来看,这是零拷，,因为内核缓冲区之间的数据不重复。使用零拷贝时，不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 CPU 缓存伪共享以及无 CPU 校验和计算。</p>
<p><strong>后面的实践部分就不翻译了</strong></p>
<h1 id="Java的应用"><a href="#Java的应用" class="headerlink" title="Java的应用"></a>Java的应用</h1><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>在Java不支持mmap的用法，但是提供一个<code>MappedByteBuffer</code> 文件内存映射，它可以加快读写，强行使用来文件拷贝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mmapTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String dir = <span class="string">"/Users/rex/data/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RandomAccessFile memoryMappedFileIn = <span class="keyword">new</span> RandomAccessFile(dir + <span class="string">"testIn.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        RandomAccessFile memoryMappedFileOut = <span class="keyword">new</span> RandomAccessFile(dir + <span class="string">"testOut.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        MappedByteBuffer mappedByteBufferOut = memoryMappedFileOut.getChannel().map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">byte</span>[] temp = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">        memoryMappedFileIn.read(temp);</span><br><span class="line">        mappedByteBufferOut.put(temp);</span><br><span class="line">        mappedByteBufferOut.force();</span><br><span class="line">        memoryMappedFileIn.close();</span><br><span class="line">        memoryMappedFileOut.close();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"mmap时间："</span> + (end - start));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sendFile"><a href="#sendFile" class="headerlink" title="sendFile"></a>sendFile</h2><p>在Java很好的实现了sendFile，其对应的实现是<code>FileChannel#transferTo()</code>，（有兴趣的可以去看对应的native实现）可以对应于文件拷贝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendFileTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String dir = <span class="string">"/Users/rex/data/"</span>;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RandomAccessFile memoryMappedFileIn = <span class="keyword">new</span> RandomAccessFile(dir + <span class="string">"testMmapIn.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        RandomAccessFile memoryMappedFileOut = <span class="keyword">new</span> RandomAccessFile(dir + <span class="string">"testMmapOut.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel fileChannelIn = memoryMappedFileIn.getChannel();</span><br><span class="line">        FileChannel fileChannelOut = memoryMappedFileOut.getChannel();</span><br><span class="line">        fileChannelIn.transferTo(<span class="number">0</span>, memoryMappedFileIn.length(), fileChannelOut);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"sendFile时间："</span> + (end - start));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间来说必然是下面的快，所以我们很多工具包中都能看到<code>FileChannel#transferTo()</code>的身影。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>个人觉得只要减少了拷贝都属于零拷贝！请大佬们指正！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.linuxjournal.com/article/6345" target="_blank" rel="noopener">Zero Copy I: User-Mode Perspective</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：&lt;strong&gt;零拷贝&lt;/strong&gt;是在文件读写以及数据传输中必须了解的优化措施。在 Java 程序员的世界，常用的零拷贝有 mmap 和 sendFile。自己之前也总是模模糊糊的了解，这次看到一篇文章让自己印象很深刻，下面我将会是翻译一下并加以引申！
    
    </summary>
    
      <category term="Java基础" scheme="http://bestlixiang.site/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="零拷贝" scheme="http://bestlixiang.site/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>Java应用的优雅停机</title>
    <link href="http://bestlixiang.site/2019/07/06/Java%E5%9F%BA%E7%A1%80/Java%E5%BA%94%E7%94%A8%E7%9A%84%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA/"/>
    <id>http://bestlixiang.site/2019/07/06/Java基础/Java应用的优雅停机/</id>
    <published>2019-07-06T02:00:19.000Z</published>
    <updated>2019-07-06T02:05:54.553Z</updated>
    
    <content type="html"><![CDATA[<p>引：对于一个鲁棒的Java应用来说，<strong>优雅停机</strong> 必不可少的。下面我将先介绍Java优雅停机的实现方式，然后介绍在Dubbo中的服务是如何实现优雅停机的。<a id="more"></a></p>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>在Linux中，信号是进程间通讯的一种方式，它采用的是异步机制。当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行。</p>
<h2 id="信号的响应动作"><a href="#信号的响应动作" class="headerlink" title="信号的响应动作"></a>信号的响应动作</h2><p>每个信号都有自己的响应动作，当接收到信号时，进程会根据信号的响应动作执行相应的操作，信号的响应动作有以下几种：</p>
<ul>
<li>中止进程(Term)</li>
<li>忽略信号(Ign)</li>
<li>中止进程并保存内存信息(Core)</li>
<li>停止进程(Stop)</li>
<li>继续运行进程(Cont)</li>
</ul>
<h2 id="停机信号"><a href="#停机信号" class="headerlink" title="停机信号"></a>停机信号</h2><p>在linux上，我们停机主要是使用 kill 的方式。关于停机对应的信号主要有下面两个，也是我们平时经常使用的两种：</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>值</th>
<th>动作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>Term</td>
<td>结束程序(可以被捕获、阻塞或忽略) kill的默认信号</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>Term</td>
<td>无条件结束程序(不能被捕获、阻塞或忽略)</td>
</tr>
</tbody>
</table>
<h1 id="Java停机方式"><a href="#Java停机方式" class="headerlink" title="Java停机方式"></a>Java停机方式</h1><p><strong>优雅停机</strong>：指的是在应用关闭时能够处理一下“善后”的逻辑，比如</p>
<ol>
<li>关闭 socket 链接</li>
<li>清理临时文件</li>
<li>发送消息通知给订阅方，告知自己下线</li>
<li>将自己将要被销毁的消息通知给子进程</li>
<li>各种资源的释放</li>
</ol>
<p>我们知道在执行<code>kill -9 pid</code>时是无条件结束程序的，所以在这种情况下我们无法优雅停机，只有在执行<code>kill -15 pid</code> 或者<code>kill pid</code>时才能实现。但是如果发现：<code>kill -15 pid</code> 无法关闭应用，则可以考虑使用<code>kill -9 pid</code>，但请事后务必排查出是什么原因导致<code>kill -15 pid</code> 无法关闭。所以在编写停机脚本时也要先<code>kill -15 pid</code> ，如果关闭失败，再执行<code>kill -9 pid</code>。</p>
<h2 id="Shutdown-Hook"><a href="#Shutdown-Hook" class="headerlink" title="Shutdown Hook"></a>Shutdown Hook</h2><p>先看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> DbShutdownWork());</span><br><span class="line">        System.out.println(<span class="string">"JVM 已启动"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DbShutdownWork</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭数据库连接"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们执行<code>kill pid</code>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JVM 已启动</span><br><span class="line">关闭数据库连接</span><br></pre></td></tr></table></figure>
<p>Shutdown Hook 会保证 JVM 一直运行，直到 hook 终止。</p>
<h2 id="SignalHandler"><a href="#SignalHandler" class="headerlink" title="SignalHandler"></a>SignalHandler</h2><p>先看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 信号处理实例</span></span><br><span class="line">        DbSignalHandler mySignalHandler = <span class="keyword">new</span> DbSignalHandler();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册对指定信号的处理</span></span><br><span class="line">        Signal.handle(<span class="keyword">new</span> Signal(<span class="string">"TERM"</span>) ,mySignalHandler);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"JVM 已启动"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DbSignalHandler</span> <span class="keyword">implements</span> <span class="title">SignalHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Signal signal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 信号量名称</span></span><br><span class="line">        String name = signal.getName();</span><br><span class="line">        <span class="comment">// 信号量数值</span></span><br><span class="line">        <span class="keyword">int</span> number = signal.getNumber();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(name.equals(<span class="string">"TERM"</span>) &amp;&amp; number == <span class="number">15</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭数据库连接"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SignalHandler是在<code>sun.misc</code>下的，就是JDK提供的各种后面啦。</p>
<p>看了上面两种方法，其实实质都是一样的，都是利用信用，在捕获终止信号的时候做一些操作来实现优雅停机。</p>
<h1 id="Dubbo优雅停机"><a href="#Dubbo优雅停机" class="headerlink" title="Dubbo优雅停机"></a>Dubbo优雅停机</h1><p>先引入官方文档：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 原理</span></span><br><span class="line"><span class="section">## 服务提供方</span></span><br><span class="line"><span class="bullet">* </span>停止时，先标记为不接收新请求，新请求过来时直接报错，让客户端重试其它机器。</span><br><span class="line"><span class="bullet">* </span>然后，检测线程池中的线程是否正在运行，如果有，等待所有线程执行完成，除非超时，则强制关闭。</span><br><span class="line"></span><br><span class="line"><span class="section">## 服务消费方</span></span><br><span class="line"><span class="bullet">* </span>停止时，不再发起新的调用请求，所有新的调用在客户端即报错。</span><br><span class="line"><span class="bullet">* </span>然后，检测有没有请求的响应还没有返回，等待响应返回，除非超时，则强制关闭。</span><br><span class="line"></span><br><span class="line"><span class="section">## 设置方式</span></span><br><span class="line">设置优雅停机超时时间，缺省超时时间是 10 秒，如果超时则强制关闭。</span><br><span class="line">dubbo.properties</span><br><span class="line">dubbo.service.shutdown.wait=15000</span><br><span class="line">如果 ShutdownHook 不能生效，可以自行调用，使用tomcat等容器部署的場景，建议通过扩展ContextListener等自行调用以下代码实现优雅停机：</span><br><span class="line">ProtocolConfig.destroyAll();</span><br></pre></td></tr></table></figure>
<p>我们看到了熟悉的ShutdownHook，所以下面我们需要去找ShutdownHook是在哪添加的？</p>
<h2 id="ShutdownHook"><a href="#ShutdownHook" class="headerlink" title="ShutdownHook"></a>ShutdownHook</h2><p>Dubbo 的优雅停机 <strong>ShutdownHook</strong> 在 <code>AbstractConfig</code> 的静态代码块初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到<code>DubboShutdownHook</code>继承于<code>Thread</code>，所以我们需要去看的run方法，就能知道在停机时需要干什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    destroyAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!destroyed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭注册中心</span></span><br><span class="line">    AbstractRegistryFactory.destroyAll();</span><br><span class="line">    <span class="comment">// 标记为不接收新请求，同时不再发起新的调用请求</span></span><br><span class="line">    destroyProtocols();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RegistryDestroy"><a href="#RegistryDestroy" class="headerlink" title="RegistryDestroy"></a>RegistryDestroy</h2><p>上面我们看到停机之后主要做了两件事情，我们先来看第一件事情，关闭注册中心连接，，取消服务中的服务提供者和消费者的<strong>订阅</strong>与<strong>注册</strong>。 我们以<code>Zookeeper</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.dubbo.registry.zookeeper.ZookeeperRegistry</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 调用父类FailbackRegistry的destroy方法</span></span><br><span class="line">      <span class="keyword">super</span>.destroy();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">// 关闭zkClient的连接</span></span><br><span class="line">          zkClient.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          logger.warn(<span class="string">"Failed to close zookeeper client "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.dubbo.registry.support.FailbackRegistry</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 调用父类AbstractRegistry的destroy方法</span></span><br><span class="line">      <span class="keyword">super</span>.destroy();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">// 关闭心跳重试任务</span></span><br><span class="line">          retryFuture.cancel(<span class="keyword">true</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          logger.warn(t.getMessage(), t);</span><br><span class="line">      &#125;</span><br><span class="line">    	<span class="comment">// 待会解析</span></span><br><span class="line">      ExecutorUtil.gracefulShutdown(retryExecutor, retryPeriod);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.dubbo.registry.support.AbstractRegistry</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 取消注册</span></span><br><span class="line">      Set&lt;URL&gt; destroyRegistered = <span class="keyword">new</span> HashSet&lt;URL&gt;(getRegistered());</span><br><span class="line">      <span class="keyword">if</span> (!destroyRegistered.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">for</span> (URL url : <span class="keyword">new</span> HashSet&lt;URL&gt;(getRegistered())) &#123;</span><br><span class="line">              <span class="keyword">if</span> (url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">// 取消注册</span></span><br><span class="line">                      unregister(url);</span><br><span class="line">                      <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                          logger.info(<span class="string">"Destroy unregister url "</span> + url);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                      logger.warn(<span class="string">"Failed to unregister url "</span> + url + <span class="string">" to registry "</span> + getUrl() + <span class="string">" on destroy, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 取消订阅</span></span><br><span class="line">      Map&lt;URL, Set&lt;NotifyListener&gt;&gt; destroySubscribed = <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed());</span><br><span class="line">      <span class="keyword">if</span> (!destroySubscribed.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : destroySubscribed.entrySet()) &#123;</span><br><span class="line">              URL url = entry.getKey();</span><br><span class="line">              <span class="keyword">for</span> (NotifyListener listener : entry.getValue()) &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">// 取消订阅</span></span><br><span class="line">                      unsubscribe(url, listener);</span><br><span class="line">                      <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                          logger.info(<span class="string">"Destroy unsubscribe url "</span> + url);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                      logger.warn(<span class="string">"Failed to unsubscribe url "</span> + url + <span class="string">" to registry "</span> + getUrl() + <span class="string">" on destroy, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="ProtocolDestroy"><a href="#ProtocolDestroy" class="headerlink" title="ProtocolDestroy"></a>ProtocolDestroy</h2><p>现在我们来看第二件事：标记为不接收新请求，同时不再发起新的调用请求，即销毁所有通信 ExchangeClient 和 ExchangeServer，其实最终就是关闭NettyServer和Client，这里以Dubbo协议为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destroyProtocols</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ExtensionLoader&lt;Protocol&gt; loader = ExtensionLoader.getExtensionLoader(Protocol.class);</span><br><span class="line">      <span class="keyword">for</span> (String protocolName : loader.getLoadedExtensions()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Protocol protocol = loader.getLoadedExtension(protocolName);</span><br><span class="line">              <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) &#123;</span><br><span class="line">                	<span class="comment">// 关闭服务</span></span><br><span class="line">                  protocol.destroy();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">              logger.warn(t.getMessage(), t);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 销毁所有 ExchangeServer</span></span><br><span class="line">      <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(serverMap.keySet())) &#123;</span><br><span class="line">          ExchangeServer server = serverMap.remove(key);</span><br><span class="line">          <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                      logger.info(<span class="string">"Close dubbo server: "</span> + server.getLocalAddress());</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 调用 HeaderExchangeServer#close</span></span><br><span class="line">                  server.close(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                  logger.warn(t.getMessage(), t);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 销毁所有 ExchangeClient</span></span><br><span class="line">      <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(referenceClientMap.keySet())) &#123;</span><br><span class="line">          ExchangeClient client = referenceClientMap.remove(key);</span><br><span class="line">          <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                      logger.info(<span class="string">"Close dubbo connect: "</span> + client.getLocalAddress() + <span class="string">"--&gt;"</span> + client.getRemoteAddress());</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 调用 ReferenceCountExchangeClient#close</span></span><br><span class="line">                  client.close(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                  logger.warn(t.getMessage(), t);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 销毁所有幽灵 ExchangeClient</span></span><br><span class="line">      <span class="comment">// 幽灵Client，是指在获取链接的时候，链接为空或者已经被关闭了</span></span><br><span class="line">      <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(ghostClientMap.keySet())) &#123;</span><br><span class="line">          ExchangeClient client = ghostClientMap.remove(key);</span><br><span class="line">          <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                      logger.info(<span class="string">"Close dubbo connect: "</span> + client.getLocalAddress() + <span class="string">"--&gt;"</span> + client.getRemoteAddress());</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 调用 LazyConnectExchangeClient#close</span></span><br><span class="line">                  client.close(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                  logger.warn(t.getMessage(), t);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      stubServiceMethodsMap.clear();</span><br><span class="line">      <span class="comment">// 调用父类AbstractProtocol的destroy方法</span></span><br><span class="line">      <span class="keyword">super</span>.destroy();</span><br><span class="line">  &#125;	</span><br><span class="line"><span class="comment">// org.apache.dubbo.rpc.protocol.AbstractProtocol</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 不再发起新的调用请求</span></span><br><span class="line">      <span class="keyword">for</span> (Invoker&lt;?&gt; invoker : invokers) &#123;</span><br><span class="line">          <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">              invokers.remove(invoker);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                      logger.info(<span class="string">"Destroy reference: "</span> + invoker.getUrl());</span><br><span class="line">                  &#125;</span><br><span class="line">                  invoker.destroy();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                  logger.warn(t.getMessage(), t);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    	<span class="comment">// 标记为不接收新请求</span></span><br><span class="line">      <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(exporterMap.keySet())) &#123;</span><br><span class="line">          Exporter&lt;?&gt; exporter = exporterMap.remove(key);</span><br><span class="line">          <span class="keyword">if</span> (exporter != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                      logger.info(<span class="string">"Unexport service: "</span> + exporter.getInvoker().getUrl());</span><br><span class="line">                  &#125;</span><br><span class="line">                  exporter.unexport();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                  logger.warn(t.getMessage(), t);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="ExecutorUtil"><a href="#ExecutorUtil" class="headerlink" title="ExecutorUtil"></a>ExecutorUtil</h2><p>其实我们在分析中会看到<code>ExecutorUtil#gracefulShutdown()</code>这样一个方法，它其实对应的是<strong>检测线程池中的线程是否正在运行，如果有，等待所有线程执行完成，除非超时，则强制关闭</strong>。文档说它用的是Java自带的线程池关闭策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gracefulShutdown</span><span class="params">(Executor executor, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不是 ExecutorService ，或者已经关闭，忽略</span></span><br><span class="line">    <span class="keyword">if</span> (!(executor <span class="keyword">instanceof</span> ExecutorService) || isTerminated(executor)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ExecutorService es = (ExecutorService) executor;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 禁止新的任务提交，将原有任务执行完，这些都是自带线程池的机制</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex2) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException ex2) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 等待原有任务执行完。若等待超时，强制结束所有任务，默认为10秒</span></span><br><span class="line">        <span class="keyword">if</span> (!es.awaitTermination(timeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">          	<span class="comment">// 抛弃队列中的任务，并中断所有工作线程</span></span><br><span class="line">            es.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">        <span class="comment">// 发生 InterruptedException 异常，也强制结束所有任务</span></span><br><span class="line">        es.shutdownNow();</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若未关闭成功，新开线程去关闭</span></span><br><span class="line">    <span class="keyword">if</span> (!isTerminated(es)) &#123;</span><br><span class="line">        newThreadToCloseExecutor(es);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="https://www.cnblogs.com/3me-linux/p/3927221.html" target="_blank" rel="noopener">linux信号调用机制</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/1110765" target="_blank" rel="noopener">研究优雅停机时的一点思考</a></p>
</li>
<li>精尽 Dubbo 源码解析 —— 优雅停机</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：对于一个鲁棒的Java应用来说，&lt;strong&gt;优雅停机&lt;/strong&gt; 必不可少的。下面我将先介绍Java优雅停机的实现方式，然后介绍在Dubbo中的服务是如何实现优雅停机的。
    
    </summary>
    
      <category term="Java基础" scheme="http://bestlixiang.site/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="优雅停机" scheme="http://bestlixiang.site/tags/%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA/"/>
    
      <category term="Dubbo" scheme="http://bestlixiang.site/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat源码分析——类加载机制</title>
    <link href="http://bestlixiang.site/2019/07/02/Tomcat%E6%BA%90%E7%A0%81/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://bestlixiang.site/2019/07/02/Tomcat源码/Tomcat源码分析——类加载机制/</id>
    <published>2019-07-02T07:32:48.000Z</published>
    <updated>2019-07-02T10:23:43.354Z</updated>
    
    <content type="html"><![CDATA[<p>引：相信大家对于Java类加载的认识最开始都是来自于《深入理解Java虚拟机》，可能觉得就一个<strong>双亲委派机制</strong>嘛，没什么东西！但是具体到实际应用，对于类加载器却有所不同，今天我们就跟着Tomcat源码来分析一下它的类加载机制！<a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个说到Tomcat源码，在看源码之前，我们都需要先理解它的架构与一些设计原理，如果图快，可以从最后的参考中快速消化一下Tomcat的架构，但是如果是想系统看一下看Tomcat的全貌，我建议可以好好去看看《深入剖析Tomcat》，虽然他对应的版本对于现在来说有点老了，但是核心思想是不变的，相信很多人看完之后会和我一样有一种恍然大悟的感觉。关于怎么看Tomcat源码也可以在最后的参考中找到相关链接。</p>
<h1 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h1><p>在说Tomcat的类加载机制之前，我们一定要先看看Java自己的类加载机制，之前自己对《深入理解Java虚拟机》中描述的Java类加载机制一篇总结文章，可以先看看：<a href="http://todorex.com/2017/12/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-9-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" target="_blank" rel="noopener">深入理解JVM<em>9</em>类加载器</a></p>
<h1 id="Tomcat类加载机制"><a href="#Tomcat类加载机制" class="headerlink" title="Tomcat类加载机制"></a>Tomcat类加载机制</h1><p>Tomcat使用类加载器的原因有3条：(待会会在源码中看出)</p>
<ol>
<li>为了在载入类指定某些规则</li>
<li>为了缓存已经载入的类</li>
<li>为了实现类的预加载，方便使用</li>
</ol>
<h2 id="设计图"><a href="#设计图" class="headerlink" title="设计图"></a>设计图</h2><p><img src="https://upload-images.jianshu.io/upload_images/10354196-fff334f481929cad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/462/format/webp" alt="Tomcat类加载机制设计"></p>
<ul>
<li>commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；</li>
<li>catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；</li>
<li>sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；</li>
<li>WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；</li>
<li>JasperLoader: 每一个JSP文件对应一个Jsp类加载器，实现热加载；</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Tomcat启动"><a href="#Tomcat启动" class="headerlink" title="Tomcat启动"></a>Tomcat启动</h3><p>如果看过Tomcat的架构和设计，就应该知道Tomcat的启动时运行<code>main</code>方法作为入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// daemon就是bootstrap，当初始化完成之后会赋值给daemon</span></span><br><span class="line">    <span class="keyword">if</span> (daemon == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化</span></span><br><span class="line">            bootstrap.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleThrowable(t);</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        daemon = bootstrap;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 设置线程上下文类加载器继续加载，保持一致</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要知道daemon初始化干了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// Tomcat 自己的类加载器结构</span></span><br><span class="line">      initClassLoaders();</span><br><span class="line">      <span class="comment">// 将 catalinaLoader 类加载器设置为当前线程上下文类加载器.</span></span><br><span class="line">      Thread.currentThread().setContextClassLoader(catalinaLoader);</span><br><span class="line">      <span class="comment">// 并设置线程安全类加载器进行类加载</span></span><br><span class="line">      SecurityClassLoad.securityClassLoad(catalinaLoader);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Load our startup class and call its process() method</span></span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">          log.debug(<span class="string">"Loading startup class"</span>);</span><br><span class="line">      <span class="comment">// 加载启动对象</span></span><br><span class="line">      Class&lt;?&gt; startupClass = catalinaLoader.loadClass(<span class="string">"org.apache.catalina.startup.Catalina"</span>);</span><br><span class="line">      Object startupInstance = startupClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set the shared extensions class loader</span></span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">          log.debug(<span class="string">"Setting startup class properties"</span>);</span><br><span class="line">      <span class="comment">// 使用反射调用该实例的setParentClassLoader 方法, 参数为 sharedLoader</span></span><br><span class="line">      <span class="comment">// 表示该实例的父类加载器为 sharedLoader. </span></span><br><span class="line">    	<span class="comment">// 这里暗含了后面生成的WebappClassLoader的parent就是sharedLoader</span></span><br><span class="line">      String methodName = <span class="string">"setParentClassLoader"</span>;</span><br><span class="line">      Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">      paramTypes[<span class="number">0</span>] = Class.forName(<span class="string">"java.lang.ClassLoader"</span>);</span><br><span class="line">      Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">      paramValues[<span class="number">0</span>] = sharedLoader;</span><br><span class="line">      Method method =</span><br><span class="line">          startupInstance.getClass().getMethod(methodName, paramTypes);</span><br><span class="line">      method.invoke(startupInstance, paramValues);</span><br><span class="line">      <span class="comment">// 设置 catalinaDaemon 为该实例</span></span><br><span class="line">      catalinaDaemon = startupInstance;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键来了</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initClassLoaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// tomcat公用的类加载器 parent为null 违背了java自己的类加载机制</span></span><br><span class="line">          commonLoader = createClassLoader(<span class="string">"common"</span>, <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span>( commonLoader == <span class="keyword">null</span> ) &#123;</span><br><span class="line">              <span class="comment">// no config file, default to this loader - we might be in a 'single' env.</span></span><br><span class="line">              <span class="comment">// 找不到配置文件中的 key 的时候或者 key 对应的 value 为空的时候回返回 null</span></span><br><span class="line">              <span class="comment">// 如果返回 null, 那么就设置默认的类加载器为 common 类加载器.</span></span><br><span class="line">              commonLoader=<span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 调试可知：</span></span><br><span class="line">          <span class="comment">// 可以找不到配置文件中的 key, 所以他们直接返回父类加载器, 也就是说(默认情况下), 他们三个使用的是同一个类加载器.</span></span><br><span class="line">          catalinaLoader = createClassLoader(<span class="string">"server"</span>, commonLoader);</span><br><span class="line">          sharedLoader = createClassLoader(<span class="string">"shared"</span>, commonLoader);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          handleThrowable(t);</span><br><span class="line">          log.error(<span class="string">"Class loader creation threw exception"</span>, t);</span><br><span class="line">          System.exit(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建commonLoader</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(String name, ClassLoader parent)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 拿到资源（要加载类的路径）</span></span><br><span class="line">      <span class="comment">// common.loader 对应的 Value=$&#123;catalina.base&#125;/lib,$&#123;catalina.base&#125;/lib/*.jar,$&#123;catalina.home&#125;/lib,$&#123;catalina.home&#125;/lib/*.jar</span></span><br><span class="line">      String value = CatalinaProperties.getProperty(name + <span class="string">".loader"</span>);</span><br><span class="line">      <span class="comment">// 如果不存在, 返回 null</span></span><br><span class="line">      <span class="keyword">if</span> ((value == <span class="keyword">null</span>) || (value.equals(<span class="string">""</span>)))</span><br><span class="line">          <span class="keyword">return</span> parent;</span><br><span class="line">      <span class="comment">// 使用环境变量对应的目录替换字符串</span></span><br><span class="line">      value = replace(value);</span><br><span class="line">      <span class="comment">// Repository是ClassLoaderFactory 中的一个静态内部类</span></span><br><span class="line">      <span class="comment">// 有2个属性, location, type, 表示某个位置的某种类型的文件</span></span><br><span class="line">      List&lt;Repository&gt; repositories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">// 将路径变成一个数组</span></span><br><span class="line">      String[] repositoryPaths = getPaths(value);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (String repository : repositoryPaths) &#123;</span><br><span class="line">          <span class="comment">// Check for a JAR URL repository</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">              URL url = <span class="keyword">new</span> URL(repository);</span><br><span class="line">              repositories.add(</span><br><span class="line">                      <span class="keyword">new</span> Repository(repository, RepositoryType.URL));</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">              <span class="comment">// Ignore</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Local repository</span></span><br><span class="line">          <span class="keyword">if</span> (repository.endsWith(<span class="string">"*.jar"</span>)) &#123;</span><br><span class="line">              repository = repository.substring</span><br><span class="line">                  (<span class="number">0</span>, repository.length() - <span class="string">"*.jar"</span>.length());</span><br><span class="line">              repositories.add(</span><br><span class="line">                      <span class="keyword">new</span> Repository(repository, RepositoryType.GLOB));</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (repository.endsWith(<span class="string">".jar"</span>)) &#123;</span><br><span class="line">              repositories.add(</span><br><span class="line">                      <span class="keyword">new</span> Repository(repository, RepositoryType.JAR));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              repositories.add(</span><br><span class="line">                      <span class="keyword">new</span> Repository(repository, RepositoryType.DIR));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据给定的路径数组前去加载给定的 class 文件，生成URLClassLoader</span></span><br><span class="line">      <span class="keyword">return</span> ClassLoaderFactory.createClassLoader(repositories, parent);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>初始化完三个类加载之后，上面就会让catalinaLoader加载Tomcat所需要的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">securityClassLoad</span><span class="params">(ClassLoader loader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    securityClassLoad(loader, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">securityClassLoad</span><span class="params">(ClassLoader loader, <span class="keyword">boolean</span> requireSecurityManager)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requireSecurityManager &amp;&amp; System.getSecurityManager() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// securityClassLoad方法主要加载Tomcat容器所需的class</span></span><br><span class="line">    <span class="comment">// Tomcat核心class，即org.apache.catalina.core路径下的class</span></span><br><span class="line">    loadCorePackage(loader);</span><br><span class="line">    <span class="comment">// Tomcat连接器，即org.apache.coyote路径下的class</span></span><br><span class="line">    loadCoyotePackage(loader);</span><br><span class="line">    <span class="comment">// Tomcat应用类加载器, org.apache.catalina.loader.WebappClassLoader</span></span><br><span class="line">    loadLoaderPackage(loader);</span><br><span class="line">    <span class="comment">// org.apache.catalina.realm下的class</span></span><br><span class="line">    loadRealmPackage(loader);</span><br><span class="line">    <span class="comment">// org.apache.catalina.servlets下的class</span></span><br><span class="line">    loadServletsPackage(loader);</span><br><span class="line">    <span class="comment">// org.apache.catalina.session下的class；</span></span><br><span class="line">    loadSessionPackage(loader);</span><br><span class="line">    <span class="comment">// org.apache.catalina.util下的class</span></span><br><span class="line">    loadUtilPackage(loader);</span><br><span class="line">    <span class="comment">// org.apache.catalina.valves下的class</span></span><br><span class="line">    loadValvesPackage(loader);</span><br><span class="line">    <span class="comment">// javax.servlet.http.Cookie</span></span><br><span class="line">    loadJavaxPackage(loader);</span><br><span class="line">    <span class="comment">// org.apache.catalina.connector的class</span></span><br><span class="line">    loadConnectorPackage(loader);</span><br><span class="line">    <span class="comment">// org.apache.catalina.util路径下的class</span></span><br><span class="line">    loadTomcatPackage(loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里daemon就被创建完成了，启动也就结束了！</p>
<h3 id="WebappClassLoader创建"><a href="#WebappClassLoader创建" class="headerlink" title="WebappClassLoader创建"></a>WebappClassLoader创建</h3><p>上面说了Tomcat类加载机制中的三大加载器，但是对于Tomcat来说WebappClassLoader或许是最关键的，因为应用里的类都靠它加载。看过Tomcat架构的都知道WebappClassLoader是和容器StandardContext绑定在一起的。所以我们跟StandardContext生命周期的启动方法<code>startInternal</code>进去看看（该方法比较长，省略很多内容，只看关键）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getLoader() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 生成一个WebappLoader，parent为sharedClassLoader一直传递下去</span></span><br><span class="line">        WebappLoader webappLoader = <span class="keyword">new</span> WebappLoader(getParentClassLoader());</span><br><span class="line">        webappLoader.setDelegate(getDelegate());</span><br><span class="line">      	<span class="comment">// 绑定 StandardContext容器</span></span><br><span class="line">        setLoader(webappLoader);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            <span class="comment">// Start our subordinate components, if any</span></span><br><span class="line">            Loader loader = getLoader();</span><br><span class="line">            <span class="keyword">if</span> (loader <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">              	<span class="comment">// 这里执行生命的周期的start方法，最后会回调到WebappLoader的startInternal方法</span></span><br><span class="line">                ((Lifecycle) loader).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// org.apache.catalina.loader.WebappLoader </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建WebAppClassLoader，跟进去</span></span><br><span class="line">        classLoader = createClassLoader();</span><br><span class="line">        <span class="comment">// 设置其资源路径为当前Webapp下某个context的类资源</span></span><br><span class="line">        classLoader.setResources(context.getResources());</span><br><span class="line">        classLoader.setDelegate(<span class="keyword">this</span>.delegate);</span><br><span class="line">		<span class="comment">// 生命周期钩子</span></span><br><span class="line">        ((Lifecycle) classLoader).start();</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">private</span> WebappClassLoaderBase <span class="title">createClassLoader</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 通过反射实例化classLoader</span></span><br><span class="line">    <span class="comment">// 这里是ParallelWebappClassLoader</span></span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(loaderClass);</span><br><span class="line">    WebappClassLoaderBase classLoader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 这里父类加载器是Catalina实例中的sharedClassLoader</span></span><br><span class="line">    <span class="keyword">if</span> (parentClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        parentClassLoader = context.getParentClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt;[] argTypes = &#123; ClassLoader.class &#125;;</span><br><span class="line">    Object[] args = &#123; parentClassLoader &#125;;</span><br><span class="line">    Constructor&lt;?&gt; constr = clazz.getConstructor(argTypes);</span><br><span class="line">    classLoader = (WebappClassLoaderBase) constr.newInstance(args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> classLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，WebappClassLoader就被实例化完成了。</p>
<h3 id="WebappClassLoader类加载"><a href="#WebappClassLoader类加载" class="headerlink" title="WebappClassLoader类加载"></a>WebappClassLoader类加载</h3><p><code>WebappClassLoader</code>就被实例化完成了，接下来我们就需要看看它是如何加载类的？找到他的<code>loaderClass</code>方法，<code>ParallelWebappClassLoader</code>的<code>loadClass</code>是在其父类<code>WebappClassLoaderBase</code>中实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">      	</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (0) Check our previously loaded local class cache</span></span><br><span class="line">        <span class="comment">// 检查WebappClassLoader中是否加载过此类</span></span><br><span class="line">        <span class="comment">// 类中维护了一个resourceEntries的ConcurrentHashMap</span></span><br><span class="line">        clazz = findLoadedClass0(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                log.debug(<span class="string">"  Returning class from cache"</span>);</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (0.1) Check our previously loaded class cache</span></span><br><span class="line">        <span class="comment">// 检查JVM虚拟机中是否加载过该类</span></span><br><span class="line">        clazz = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                log.debug(<span class="string">"  Returning class from cache"</span>);</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (0.2) Try loading the class with the system class loader, to prevent</span></span><br><span class="line">        <span class="comment">//       the webapp from overriding Java SE classes. This implements</span></span><br><span class="line">        <span class="comment">//       SRV.10.7.2</span></span><br><span class="line">        <span class="comment">// 用应用类加载器加载该类（也就是当前JVM的ClassPath），为了防止覆盖基础类实现</span></span><br><span class="line">        String resourceName = binaryNameToPath(name, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        ClassLoader javaseLoader = getJavaseClassLoader();</span><br><span class="line">        <span class="keyword">boolean</span> tryLoadingFromJavaseLoader;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (tryLoadingFromJavaseLoader) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = javaseLoader.loadClass(name);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (resolve)</span><br><span class="line">                        resolveClass(clazz);</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先判断是否设置了delegate属性，设置为true，那么就会完全按照JVM的"双亲委托"机制流程加载类</span></span><br><span class="line">        <span class="keyword">boolean</span> delegateLoad = delegate || filter(name, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (1) Delegate to our parent if requested</span></span><br><span class="line">      	<span class="comment">// 双亲委派模式，从上到下加载</span></span><br><span class="line">        <span class="keyword">if</span> (delegateLoad) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                log.debug(<span class="string">"  Delegating to parent classloader1 "</span> + parent);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = Class.forName(name, <span class="keyword">false</span>, parent);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                        log.debug(<span class="string">"  Loading class from parent"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (resolve)</span><br><span class="line">                        resolveClass(clazz);</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (2) Search local repositories</span></span><br><span class="line">        <span class="comment">// 若是默认的话，是先使用WebappClassLoader自己处理加载类的</span></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">            log.debug(<span class="string">"  Searching local repositories"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过自定义findClass定义处理类加载规则</span></span><br><span class="line">            clazz = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                    log.debug(<span class="string">"  Loading class from local repository"</span>);</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (3) Delegate to parent unconditionally</span></span><br><span class="line">        <span class="comment">// 若是WebappClassLoader在/WEB-INF/classes、/WEB-INF/lib下还是查找不到class</span></span><br><span class="line">        <span class="comment">// 那么委托给Common类加载器去查找该类 ，这里满足双亲委派原则</span></span><br><span class="line">        <span class="keyword">if</span> (!delegateLoad) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                log.debug(<span class="string">"  Delegating to parent classloader at end: "</span> + parent);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = Class.forName(name, <span class="keyword">false</span>, parent);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                        log.debug(<span class="string">"  Loading class from parent"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (resolve)</span><br><span class="line">                        resolveClass(clazz);</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里总结一下delegate属性为false，即默认的情况下的加载顺序：</p>
<ol>
<li>检查本地缓存</li>
<li>如果没有，检查虚拟机缓存</li>
<li>如果没有，从AppClassLoader加载，这里会使用Java自己的类加载体系</li>
<li>如果没有，则从WebappClassLoader加载（按照WEB-INF/classes、WEB-INF/lib的顺序）</li>
<li>如果没有，则从父类加载器加载，由于父类加载器采用默认的委派模式，所以加载顺序是Common、Shared</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里用一到面试题结束：Tomcat的类加载机制是否违反了双亲委托原则？</p>
<p>答案：是，具体怎么破坏了看本文理解。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p>《深入剖析Tomcat》</p>
</li>
<li><p><a href="https://blog.csdn.net/qq_38245537/article/details/79009448" target="_blank" rel="noopener">四张图带你了解Tomcat系统架构</a></p>
</li>
<li><a href="https://yq.aliyun.com/articles/663198" target="_blank" rel="noopener">怎么读 Tomcat 源码？</a></li>
<li><a href="http://todorex.com/2017/12/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-9-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" target="_blank" rel="noopener">深入理解JVM<em>9</em>类加载器</a></li>
<li><a href="https://www.cnblogs.com/aspirant/p/8991830.html" target="_blank" rel="noopener">图解Tomcat类加载机制(阿里面试题)</a></li>
<li><a href="https://www.jianshu.com/p/69c4526b843d" target="_blank" rel="noopener">Tomcat源码分析 – Tomcat类加载器</a></li>
<li><a href="https://blog.csdn.net/yangcheng33/article/details/52631940" target="_blank" rel="noopener">真正理解线程上下文类加载器（多案例分析）</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：相信大家对于Java类加载的认识最开始都是来自于《深入理解Java虚拟机》，可能觉得就一个&lt;strong&gt;双亲委派机制&lt;/strong&gt;嘛，没什么东西！但是具体到实际应用，对于类加载器却有所不同，今天我们就跟着Tomcat源码来分析一下它的类加载机制！
    
    </summary>
    
      <category term="Tomcat源码" scheme="http://bestlixiang.site/categories/Tomcat%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Tomcat" scheme="http://bestlixiang.site/tags/Tomcat/"/>
    
      <category term="ClassLoader" scheme="http://bestlixiang.site/tags/ClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——事务消息</title>
    <link href="http://bestlixiang.site/2019/07/02/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/"/>
    <id>http://bestlixiang.site/2019/07/02/RocketMQ源码/RocketMQ源码分析——事务消息/</id>
    <published>2019-07-01T23:21:45.000Z</published>
    <updated>2019-07-02T02:38:28.274Z</updated>
    
    <content type="html"><![CDATA[<p>引：在前面的源码分析中，我们总是能在很多地方看到对于事务消息特别的逻辑，这次我们终于可以讲一下啦！同时对利用消息队列来实现分布式事务感兴趣的同学也是不可错过的！<a id="more"></a></p>
<h1 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h1><p>例子：通过购物车进行下单的流程中，用户入口在购物车系统，交易下单入口在交易系统，两个系统之间的数据需要保持最终一致，这时可以通过事务消息进行处理。交易系统下单之后，发送一条交易下单的消息到消息队列 RocketMQ，购物车系统订阅消息队列 RocketMQ 的交易下单消息，做相应的业务处理，更新购物车数据。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>消息队列 RocketMQ 事务消息交互流程如下所示：</p>
<p><img src="http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/43348/cn_zh/1557378341241/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.PNG" alt="交互流程"></p>
<ol>
<li>发送方向消息队列 RocketMQ 服务端发送消息。</li>
<li>服务端将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功，此时消息为半消息。</li>
<li>发送方开始执行本地事务逻辑。</li>
<li>发送方根据本地事务执行结果向服务端提交二次确认（Commit 或是 Rollback），服务端收到 Commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；服务端收到 Rollback 状态则删除半消息，订阅方将不会接受该消息。</li>
<li>在断网或者是应用重启的特殊情况下，上述步骤 4 提交的二次确认最终未到达服务端，经过固定时间后服务端将对该消息发起消息回查。</li>
<li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>发送方根据检查得到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤 4 对半消息进行操作。</li>
</ol>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>NameServer还是按照之前<code>环境搭建</code>篇启动，但是Broker不行，因为我们运行的test包下的broker，为了单元测试，官方利用<code>SPI</code></p>
<p>注入了<code>org.apache.rocketmq.broker.util.TransactionalMessageServiceImpl</code> ，这个不是我们想要的<code>TransactionalMessageService</code>，所以我们找到<code>rocketmq/broker/src/test/resources/META-INF/service/org.apache.rocketmq.broker.transaction.TransactionalMessageService</code> 这个文件把里面的东西删了就好了。对于生成者，自己魔改了官方事务消息的例子，因为我感觉不太好理解。对于消费者，我们可以直接使用<code>quickstart</code>包的例子。</p>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>核心在于实现一个<code>TransactionListener</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">        TransactionListener transactionListener = <span class="keyword">new</span> TransactionListenerImpl();</span><br><span class="line">        TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2000</span>), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">                thread.setName(<span class="string">"client-transaction-msg-check-thread"</span>);</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.setExecutorService(executorService);</span><br><span class="line">        producer.setTransactionListener(transactionListener);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Message msg =</span><br><span class="line">                    <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>, <span class="string">"KEY"</span> + i,</span><br><span class="line">                        (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                SendResult sendResult = producer.sendMessageInTransaction(msg, <span class="keyword">null</span>);</span><br><span class="line">                System.out.println(<span class="string">"发送: "</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger transactionIndex = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger checktimes = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Integer&gt; localTrans = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = transactionIndex.getAndIncrement();</span><br><span class="line">        <span class="keyword">int</span> status = value % <span class="number">3</span>;</span><br><span class="line">        localTrans.put(msg.getTransactionId(), status);</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">        Integer status = localTrans.get(msg.getTransactionId());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(msg.getBody())+<span class="string">" 回查"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != status) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(msg.getBody())+<span class="string">" 回查次数: "</span> + checktimes.incrementAndGet());</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="comment">// 消费者应该只能收到这一条消息</span></span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_4"</span>);</span><br><span class="line">        <span class="comment">// 指明Namesrv</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line"></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">              </span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h3><p><img src="https://upload-images.jianshu.io/upload_images/10354196-683c967f4c72ae62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tansaction-message-producer.png"></p>
<h3 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h3><p><img src="https://upload-images.jianshu.io/upload_images/10354196-612b0775065ab230.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="transaction-message-consumerpng.png"></p>
<p>根据我们代码逻辑，我们第一次发送本地事务都是执行失败的，所以所有消息都要进行回查，但是标识为0的消息回查会一直返回失败，所以会一直回查，这里因为时间问题只看到两次，最多默认回查15次，标识为1的消息回查之后会返回Commit，所以我们在消费者端看到了这条消息，标识为2的消息在回查之后返回Rollback，所以消费者端看不到了。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>我们的分析就是就是按照上面实现原理的交互流程走一遍，现在就来看看吧！</p>
<h2 id="TransactionMQProducer启动"><a href="#TransactionMQProducer启动" class="headerlink" title="TransactionMQProducer启动"></a>TransactionMQProducer启动</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// org.apache.rocketmq.client.producer.TransactionMQProducer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.defaultMQProducerImpl.initTransactionEnv();</span><br><span class="line">  		<span class="comment">// 其他和普通消息没有什么区别</span></span><br><span class="line">      <span class="keyword">super</span>.start();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 创建回查线程池</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initTransactionEnv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      TransactionMQProducer producer = (TransactionMQProducer) <span class="keyword">this</span>.defaultMQProducer;</span><br><span class="line">      <span class="keyword">if</span> (producer.getExecutorService() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.checkExecutor = producer.getExecutorService();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.checkRequestQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(producer.getCheckRequestHoldMax());</span><br><span class="line">          <span class="keyword">this</span>.checkExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">              producer.getCheckThreadPoolMinSize(),</span><br><span class="line">              producer.getCheckThreadPoolMaxSize(),</span><br><span class="line">              <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">              TimeUnit.MILLISECONDS,</span><br><span class="line">              <span class="keyword">this</span>.checkRequestQueue);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="TransactionMQProducer发送事务消息"><a href="#TransactionMQProducer发送事务消息" class="headerlink" title="TransactionMQProducer发送事务消息"></a>TransactionMQProducer发送事务消息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.producer.TransactionMQProducer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionSendResult <span class="title">sendMessageInTransaction</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> Object arg)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    	<span class="comment">// 事务监听器必须有，因为要提供Broker回查</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.transactionListener) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"TransactionListener is null"</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.defaultMQProducerImpl.sendMessageInTransaction(msg, <span class="keyword">null</span>, arg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TransactionSendResult <span class="title">sendMessageInTransaction</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        <span class="keyword">final</span> LocalTransactionExecuter localTransactionExecuter, <span class="keyword">final</span> Object arg)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">      <span class="comment">// 检查TransactionListener和回查线程池是否存在</span></span><br><span class="line">      TransactionListener transactionListener = getCheckListener();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == localTransactionExecuter &amp;&amp; <span class="keyword">null</span> == transactionListener) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"tranExecutor is null"</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 消息校验，校验topic和body长度</span></span><br><span class="line">      Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">      SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 设置消息的事务属性,为PREPARED消息以及发送的ProducerGroup</span></span><br><span class="line">      MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, <span class="string">"true"</span>);</span><br><span class="line">      MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, <span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 发送消息，和发送普通消息一样</span></span><br><span class="line">          sendResult = <span class="keyword">this</span>.send(msg);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"send message Exception"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">		</span><br><span class="line">      LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">      Throwable localException = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">switch</span> (sendResult.getSendStatus()) &#123;</span><br><span class="line">          <span class="comment">// 发送成功</span></span><br><span class="line">          <span class="keyword">case</span> SEND_OK: &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 当前Broker不会返回这个值</span></span><br><span class="line">                  <span class="keyword">if</span> (sendResult.getTransactionId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      msg.putUserProperty(<span class="string">"__transactionId__"</span>, sendResult.getTransactionId());</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 使用客户端生成的唯一id作为事务ID</span></span><br><span class="line">                  String transactionId = msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</span><br><span class="line">                  <span class="keyword">if</span> (<span class="keyword">null</span> != transactionId &amp;&amp; !<span class="string">""</span>.equals(transactionId)) &#123;</span><br><span class="line">                      msg.setTransactionId(transactionId);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 默认为空, 官方已标注为 @deprecated</span></span><br><span class="line">                  <span class="keyword">if</span> (<span class="keyword">null</span> != localTransactionExecuter) &#123;</span><br><span class="line">                      localTransactionState = localTransactionExecuter.executeLocalTransactionBranch(msg, arg);</span><br><span class="line">                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transactionListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      log.debug(<span class="string">"Used new transaction API"</span>);</span><br><span class="line">                      <span class="comment">// 调用transactionListener执行本地事务</span></span><br><span class="line">                      localTransactionState = transactionListener.executeLocalTransaction(msg, arg);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="keyword">null</span> == localTransactionState) &#123;</span><br><span class="line">                      localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) &#123;</span><br><span class="line">                      log.info(<span class="string">"executeLocalTransactionBranch return &#123;&#125;"</span>, localTransactionState);</span><br><span class="line">                      log.info(msg.toString());</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                  log.info(<span class="string">"executeLocalTransactionBranch exception"</span>, e);</span><br><span class="line">                  log.info(msg.toString());</span><br><span class="line">                  localException = e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 消息持久化失败，则事务回滚</span></span><br><span class="line">          <span class="keyword">case</span> FLUSH_DISK_TIMEOUT:</span><br><span class="line">          <span class="keyword">case</span> FLUSH_SLAVE_TIMEOUT:</span><br><span class="line">          <span class="keyword">case</span> SLAVE_NOT_AVAILABLE:</span><br><span class="line">              localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 发送结束事务消息（Commit/Rollback）</span></span><br><span class="line">          <span class="keyword">this</span>.endTransaction(sendResult, localTransactionState, localException);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          log.warn(<span class="string">"local transaction execute "</span> + localTransactionState + <span class="string">", but end broker transaction failed"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回事务发送结果</span></span><br><span class="line">      TransactionSendResult transactionSendResult = <span class="keyword">new</span> TransactionSendResult();</span><br><span class="line">      transactionSendResult.setSendStatus(sendResult.getSendStatus());</span><br><span class="line">      transactionSendResult.setMessageQueue(sendResult.getMessageQueue());</span><br><span class="line">      transactionSendResult.setMsgId(sendResult.getMsgId());</span><br><span class="line">      transactionSendResult.setQueueOffset(sendResult.getQueueOffset());</span><br><span class="line">      transactionSendResult.setTransactionId(sendResult.getTransactionId());</span><br><span class="line">      transactionSendResult.setLocalTransactionState(localTransactionState);</span><br><span class="line">      <span class="keyword">return</span> transactionSendResult;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送结束事务消息（Commit/Rollback）</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endTransaction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> SendResult sendResult,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> LocalTransactionState localTransactionState,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> Throwable localException)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException, UnknownHostException </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> MessageId id;</span><br><span class="line">      <span class="comment">// 获取消息在commitLog的offset</span></span><br><span class="line">      <span class="keyword">if</span> (sendResult.getOffsetMsgId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          id = MessageDecoder.decodeMessageId(sendResult.getMsgId());</span><br><span class="line">      &#125;</span><br><span class="line">      String transactionId = sendResult.getTransactionId();</span><br><span class="line">      <span class="comment">// 获取接收prepared消息的Broker地址</span></span><br><span class="line">      <span class="keyword">final</span> String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(sendResult.getMessageQueue().getBrokerName());</span><br><span class="line">      EndTransactionRequestHeader requestHeader = <span class="keyword">new</span> EndTransactionRequestHeader();</span><br><span class="line">      requestHeader.setTransactionId(transactionId);</span><br><span class="line">      requestHeader.setCommitLogOffset(id.getOffset());</span><br><span class="line">      <span class="comment">// 根据本地执行结果设置提交或回滚</span></span><br><span class="line">      <span class="keyword">switch</span> (localTransactionState) &#123;</span><br><span class="line">          <span class="keyword">case</span> COMMIT_MESSAGE:</span><br><span class="line">              requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> ROLLBACK_MESSAGE:</span><br><span class="line">              requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> UNKNOW:</span><br><span class="line">              requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">      <span class="comment">// 设置消息在broker上的queueOffset</span></span><br><span class="line">      requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());</span><br><span class="line">      requestHeader.setMsgId(sendResult.getMsgId());</span><br><span class="line">      String remark = localException != <span class="keyword">null</span> ? (<span class="string">"executeLocalTransactionBranch exception: "</span> + localException.toString()) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 使用Oneway方式发送结束事务消息RequestCode.END_TRANSACTION</span></span><br><span class="line">      <span class="comment">// Broker处理无论成功还是失败，Producer不会再做处理</span></span><br><span class="line">      <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark,</span><br><span class="line">          <span class="keyword">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Broker处理Prepared消息"><a href="#Broker处理Prepared消息" class="headerlink" title="Broker处理Prepared消息"></a>Broker处理Prepared消息</h2><p><strong>Broker处理Prepared消息</strong>是和普通消息用的同一个<code>SendMessageProcessor</code>，所以我们在之前的分析中看到很多穿插事务消息的代码，下面我们就看下针对事务消息的特殊处理逻辑（没有看过<code>SendMessageProcessor</code>，可以看看我之前的文章）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.broker.processor.SendMessageProcessor</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">final</span> RemotingCommand request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">final</span> SendMessageContext sendMessageContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">final</span> SendMessageRequestHeader requestHeader)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">      Map&lt;String, String&gt; oriProps = MessageDecoder.string2messageProperties(requestHeader.getProperties());</span><br><span class="line">      String traFlag = oriProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">      <span class="keyword">if</span> (traFlag != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(traFlag)) &#123;</span><br><span class="line">          <span class="comment">// 根据Broker是否支持事务消息判断是否拒绝事务消息</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</span><br><span class="line">              response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">              response.setRemark(</span><br><span class="line">                  <span class="string">"the broker["</span> + <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1()</span><br><span class="line">                      + <span class="string">"] sending transaction message is forbidden"</span>);</span><br><span class="line">              <span class="keyword">return</span> response;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 存储prepare消息</span></span><br><span class="line">          putMessageResult = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().prepareMessage(msgInner);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据存储结果设置repsonse状态，更新broker统计信息，成功则回复producer，更新context上下文</span></span><br><span class="line">      <span class="keyword">return</span> handlePutMessageResult(putMessageResult, response, request, msgInner, responseHeader, sendMessageContext, ctx, queueIdInt);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上面我们看到存储prepare消息和存储正常的消息走的不一样的路径，prepare消息调用了<code>TransactionalMessageService#prepareMessage()</code>，我们可以看一下，但是相信最终也只是存入CommitLog中而已：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImpl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">prepareMessage</span><span class="params">(MessageExtBrokerInner messageInner)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> transactionalMessageBridge.putHalfMessage(messageInner);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putHalfMessage</span><span class="params">(MessageExtBrokerInner messageInner)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 进行消息的转换</span></span><br><span class="line">      <span class="keyword">return</span> store.putMessage(parseHalfMessageInner(messageInner));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> MessageExtBrokerInner <span class="title">parseHalfMessageInner</span><span class="params">(MessageExtBrokerInner msgInner)</span> </span>&#123;</span><br><span class="line">      MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic());</span><br><span class="line">      MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID,</span><br><span class="line">          String.valueOf(msgInner.getQueueId()));</span><br><span class="line">      <span class="comment">// 清除sysFlag中的事务消息状态位</span></span><br><span class="line">      msgInner.setSysFlag(</span><br><span class="line">          MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), MessageSysFlag.TRANSACTION_NOT_TYPE));</span><br><span class="line">      <span class="comment">// 事务prepare消息放入统一的topic: RMQ_SYS_TRANS_HALF_TOPIC</span></span><br><span class="line">    	<span class="comment">// 这个topic是系统内置的，consumer不会订阅这个topic的消息</span></span><br><span class="line">      msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic());</span><br><span class="line">      <span class="comment">// queueId统一设置成0</span></span><br><span class="line">      msgInner.setQueueId(<span class="number">0</span>);</span><br><span class="line">      msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));</span><br><span class="line">      <span class="keyword">return</span> msgInner;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Broker处理Commit-Rollback消息"><a href="#Broker处理Commit-Rollback消息" class="headerlink" title="Broker处理Commit/Rollback消息"></a>Broker处理Commit/Rollback消息</h2><p><strong>Broker处理Commit/Rollback消息</strong>不再使用<code>SendMessageProcessor</code>，而是使用了<code>EndTransactionProcessor</code>来处理<code>Commit/Rollback</code> 消息，但是分析思路是不变的，先找到<code>org.apache.rocketmq.broker.processor.EndTransactionProcessor#processRequest()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">    RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> EndTransactionRequestHeader requestHeader =</span><br><span class="line">        (EndTransactionRequestHeader)request.decodeCommandCustomHeader(EndTransactionRequestHeader.class);</span><br><span class="line">    LOGGER.info(<span class="string">"Transaction request:&#123;&#125;"</span>, requestHeader);</span><br><span class="line">    <span class="keyword">if</span> (BrokerRole.SLAVE == brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SLAVE_NOT_AVAILABLE);</span><br><span class="line">        LOGGER.warn(<span class="string">"Message store is slave mode, so end transaction is forbidden. "</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 省略日志相关...</span></span><br><span class="line">  </span><br><span class="line">    OperationResult result = <span class="keyword">new</span> OperationResult();</span><br><span class="line">    <span class="comment">// 如果收到的是Commit事务消息</span></span><br><span class="line">    <span class="keyword">if</span> (MessageSysFlag.TRANSACTION_COMMIT_TYPE == requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">        <span class="comment">// 从commitLog中查出原始的prepared消息</span></span><br><span class="line">        <span class="comment">// 这要求了Producer在发送最终的Commit消息的时候一定要指定是同一个Broker</span></span><br><span class="line">        result = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().commitMessage(requestHeader);</span><br><span class="line">        <span class="keyword">if</span> (result.getResponseCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">            <span class="comment">// 检查获取到的消息是否和当前消息匹配</span></span><br><span class="line">            RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);</span><br><span class="line">            <span class="keyword">if</span> (res.getCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                <span class="comment">// 使用原始的prepared消息属性，构建最终发给consumer的消息</span></span><br><span class="line">                MessageExtBrokerInner msgInner = endMessageTransaction(result.getPrepareMessage());</span><br><span class="line">                msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback()));</span><br><span class="line">                msgInner.setQueueOffset(requestHeader.getTranStateTableOffset());</span><br><span class="line">                msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset());</span><br><span class="line">                msgInner.setStoreTimestamp(result.getPrepareMessage().getStoreTimestamp());</span><br><span class="line">                <span class="comment">// 调用MessageStore的消息存储接口提交消息，使用真正的topic和queueId</span></span><br><span class="line">                RemotingCommand sendResult = sendFinalMessage(msgInner);</span><br><span class="line">                <span class="keyword">if</span> (sendResult.getCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                    <span class="comment">// 设置Prepared消息的标记位为delete</span></span><br><span class="line">                    <span class="keyword">this</span>.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sendResult;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">        <span class="comment">// 如果收到的是Rollback事务消息</span></span><br><span class="line">        result = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().rollbackMessage(requestHeader);</span><br><span class="line">        <span class="keyword">if</span> (result.getResponseCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">            RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);</span><br><span class="line">            <span class="keyword">if</span> (res.getCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                <span class="comment">// 设置Prepared消息的标记位为delete</span></span><br><span class="line">                <span class="keyword">this</span>.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    response.setCode(result.getResponseCode());</span><br><span class="line">    response.setRemark(result.getResponseRemark());</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息Commit/Rollback后，理论上需要将原来的Prepared消息删除，这样Broker就能知道哪些消息一直没收到Commit/Rollback，需要去<code>Producer</code>回查状态。但是如果直接修改<code>CommitLog</code>文件，这个代价是很大的，所以<code>RocketMQ</code>是通过生成一个新的delete消息来标记的。这样，<code>Broker</code>在检查的时候只需要看下<code>Prepared</code>消息有没有对应的<code>delete</code>消息就可以了，我们看看这个这个操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImpl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deletePrepareMessage</span><span class="params">(MessageExt msgExt)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.transactionalMessageBridge.putOpMessage(msgExt, TransactionalMessageUtil.REMOVETAG)) &#123;</span><br><span class="line">          log.info(<span class="string">"Transaction op message write successfully. messageId=&#123;&#125;, queueId=&#123;&#125; msgExt:&#123;&#125;"</span>, msgExt.getMsgId(), msgExt.getQueueId(), msgExt);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.error(<span class="string">"Transaction op message write failed. messageId is &#123;&#125;, queueId is &#123;&#125;"</span>, msgExt.getMsgId(), msgExt.getQueueId());</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// org.apache.rocketmq.broker.transaction.queue.TransactionalMessageBridge</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putOpMessage</span><span class="params">(MessageExt messageExt, String opType)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//选择和Prepared消息相同的queue</span></span><br><span class="line">      MessageQueue messageQueue = <span class="keyword">new</span> MessageQueue(messageExt.getTopic(),</span><br><span class="line">          <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerName(), messageExt.getQueueId());</span><br><span class="line">      <span class="keyword">if</span> (TransactionalMessageUtil.REMOVETAG.equals(opType)) &#123;</span><br><span class="line">          <span class="keyword">return</span> addRemoveTagInTransactionOp(messageExt, messageQueue);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addRemoveTagInTransactionOp</span><span class="params">(MessageExt messageExt, MessageQueue messageQueue)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// message的topic为RMQ_SYS_TRANS_OP_HALF_TOPIC</span></span><br><span class="line">      <span class="comment">// 消息的tags值是d，body中存储的是prepared消息的queueOffset</span></span><br><span class="line">      Message message = <span class="keyword">new</span> Message(TransactionalMessageUtil.buildOpTopic(), TransactionalMessageUtil.REMOVETAG,</span><br><span class="line">          String.valueOf(messageExt.getQueueOffset()).getBytes(TransactionalMessageUtil.charset));</span><br><span class="line">      <span class="comment">// 写入CommitLog</span></span><br><span class="line">      writeOp(message, messageQueue);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Broker回查事务状态"><a href="#Broker回查事务状态" class="headerlink" title="Broker回查事务状态"></a>Broker回查事务状态</h2><p>在我们最开始展示的图中，当Broker未收到Commit/Rollback的消息时，会进行事务状态的回查。我们接下就看看这个逻辑，不知道大家还记得我们在<code>Broker启动</code>分析一文中提到了<code>transactionalMessageCheckService</code>这个类的启动，回查逻辑就在这里，这个类也继承<code>ServiceThread</code>，所以它也是一个线程，我们可以直接去看他的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      log.info(<span class="string">"Start transaction check service thread!"</span>);</span><br><span class="line">    	<span class="comment">// 默认1分钟，可配置</span></span><br><span class="line">      <span class="keyword">long</span> checkInterval = brokerController.getBrokerConfig().getTransactionCheckInterval();</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.waitForRunning(checkInterval);</span><br><span class="line">      &#125;</span><br><span class="line">      log.info(<span class="string">"End transaction check service thread!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">waitForRunning</span><span class="params">(<span class="keyword">long</span> interval)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 如果被通知了，就不等了</span></span><br><span class="line">      <span class="keyword">if</span> (hasNotified.compareAndSet(<span class="keyword">true</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">          <span class="keyword">this</span>.onWaitEnd();</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//entry to wait</span></span><br><span class="line">      waitPoint.reset();</span><br><span class="line">      <span class="comment">// 不然，就等待一段时间</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          waitPoint.await(interval, TimeUnit.MILLISECONDS);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          log.error(<span class="string">"Interrupted"</span>, e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          hasNotified.set(<span class="keyword">false</span>);</span><br><span class="line">        	<span class="comment">// 等待结束</span></span><br><span class="line">          <span class="keyword">this</span>.onWaitEnd();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onWaitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 事务检查超时时间 默认6s</span></span><br><span class="line">      <span class="keyword">long</span> timeout = brokerController.getBrokerConfig().getTransactionTimeOut();</span><br><span class="line">      <span class="comment">// 默认最大回查次数 默认15次</span></span><br><span class="line">      <span class="keyword">int</span> checkMax = brokerController.getBrokerConfig().getTransactionCheckMax();</span><br><span class="line">      <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">      log.info(<span class="string">"Begin to check prepare message, begin time:&#123;&#125;"</span>, begin);</span><br><span class="line">      <span class="comment">// 回查</span></span><br><span class="line">      <span class="keyword">this</span>.brokerController.getTransactionalMessageService().check(timeout, checkMax, <span class="keyword">this</span>.brokerController.getTransactionalMessageCheckListener());</span><br><span class="line">      log.info(<span class="string">"End to check prepare message, consumed time:&#123;&#125;"</span>, System.currentTimeMillis() - begin);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImpl</span></span><br><span class="line"><span class="comment">// 核心preparequeue 和 opqueue</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> transactionTimeout, <span class="keyword">int</span> transactionCheckMax,</span></span></span><br><span class="line"><span class="function"><span class="params">      AbstractTransactionalMessageCheckListener listener)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          String topic = MixAll.RMQ_SYS_TRANS_HALF_TOPIC;</span><br><span class="line">          <span class="comment">// 获取所有prepare消息队列，之前说过prepare消息的Topic为RMQ_SYS_TRANS_HALF_TOPIC</span></span><br><span class="line">          Set&lt;MessageQueue&gt; msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);</span><br><span class="line">          <span class="keyword">if</span> (msgQueues == <span class="keyword">null</span> || msgQueues.size() == <span class="number">0</span>) &#123;</span><br><span class="line">              log.warn(<span class="string">"The queue of topic is empty :"</span> + topic);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          log.info(<span class="string">"Check topic=&#123;&#125;, queues=&#123;&#125;"</span>, topic, msgQueues);</span><br><span class="line">          <span class="keyword">for</span> (MessageQueue messageQueue : msgQueues) &#123;</span><br><span class="line">              <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">              <span class="comment">// 拿到对应的opQueue</span></span><br><span class="line">              MessageQueue opQueue = getOpQueue(messageQueue);</span><br><span class="line">              <span class="comment">// 拿到prepare消息的offset</span></span><br><span class="line">              <span class="keyword">long</span> halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue);</span><br><span class="line">              <span class="comment">// 拿到对应的op消息的offset</span></span><br><span class="line">              <span class="keyword">long</span> opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue);</span><br><span class="line">              log.info(<span class="string">"Before check, the queue=&#123;&#125; msgOffset=&#123;&#125; opOffset=&#123;&#125;"</span>, messageQueue, halfOffset, opOffset);</span><br><span class="line">              <span class="keyword">if</span> (halfOffset &lt; <span class="number">0</span> || opOffset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                  log.error(<span class="string">"MessageQueue: &#123;&#125; illegal offset read: &#123;&#125;, op offset: &#123;&#125;,skip this queue"</span>, messageQueue,</span><br><span class="line">                      halfOffset, opOffset);</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              List&lt;Long&gt; doneOpOffset = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">              <span class="comment">// 将标记位delete的消息组成map进行优化</span></span><br><span class="line">              HashMap&lt;Long, Long&gt; removeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">              PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">null</span> == pullResult) &#123;</span><br><span class="line">                  log.error(<span class="string">"The queue=&#123;&#125; check msgOffset=&#123;&#125; with opOffset=&#123;&#125; failed, pullResult is null"</span>,</span><br><span class="line">                      messageQueue, halfOffset, opOffset);</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// single thread</span></span><br><span class="line">              <span class="keyword">int</span> getMessageNullCount = <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">long</span> newOffset = halfOffset;</span><br><span class="line">              <span class="keyword">long</span> i = halfOffset;</span><br><span class="line">              <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (System.currentTimeMillis() - startTime &gt; MAX_PROCESS_TIME_LIMIT) &#123;</span><br><span class="line">                      log.info(<span class="string">"Queue=&#123;&#125; process time reach max=&#123;&#125;"</span>, messageQueue, MAX_PROCESS_TIME_LIMIT);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 事务消息完成</span></span><br><span class="line">                  <span class="keyword">if</span> (removeMap.containsKey(i)) &#123;</span><br><span class="line">                      log.info(<span class="string">"Half offset &#123;&#125; has been committed/rolled back"</span>, i);</span><br><span class="line">                      removeMap.remove(i);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="comment">// 事务消息未完成，拿到prepare消息</span></span><br><span class="line">                      GetResult getResult = getHalfMsg(messageQueue, i);</span><br><span class="line">                      MessageExt msgExt = getResult.getMsg();</span><br><span class="line">                      <span class="comment">// ... </span></span><br><span class="line">                      <span class="comment">// 如果超过最大回查次数或者消息达到最大保留时间，默认3天</span></span><br><span class="line">                      <span class="keyword">if</span> (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) &#123;</span><br><span class="line">                          <span class="comment">// 报错提醒</span></span><br><span class="line">                          listener.resolveDiscardMsg(msgExt);</span><br><span class="line">                          newOffset = i + <span class="number">1</span>;</span><br><span class="line">                          i++;</span><br><span class="line">                          <span class="keyword">continue</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">										<span class="comment">//... 各种判断逻辑，比如prepare消息是否失效等，表示是否需要回查</span></span><br><span class="line">                      <span class="keyword">boolean</span> isNeedCheck = (opMsg == <span class="keyword">null</span> &amp;&amp; valueOfCurrentMinusBorn &gt; checkImmunityTime)</span><br><span class="line">                          || (opMsg != <span class="keyword">null</span> &amp;&amp; (opMsg.get(opMsg.size() - <span class="number">1</span>).getBornTimestamp() - startTime &gt; transactionTimeout))</span><br><span class="line">                          || (valueOfCurrentMinusBorn &lt;= -<span class="number">1</span>);</span><br><span class="line">                      <span class="comment">// 需要回查</span></span><br><span class="line">                      <span class="keyword">if</span> (isNeedCheck) &#123;</span><br><span class="line">                          <span class="comment">// 写入消息成功</span></span><br><span class="line">                          <span class="keyword">if</span> (!putBackHalfMsgQueue(msgExt, i)) &#123;</span><br><span class="line">                              <span class="keyword">continue</span>;</span><br><span class="line">                          &#125;</span><br><span class="line">                        	<span class="comment">// 调用相关发送逻辑</span></span><br><span class="line">                          listener.resolveHalfMsg(msgExt);</span><br><span class="line">                      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                          pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);</span><br><span class="line">                          log.info(<span class="string">"The miss offset:&#123;&#125; in messageQueue:&#123;&#125; need to get more opMsg, result is:&#123;&#125;"</span>, i,</span><br><span class="line">                              messageQueue, pullResult);</span><br><span class="line">                          <span class="keyword">continue</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  newOffset = i + <span class="number">1</span>;</span><br><span class="line">                  i++;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (newOffset != halfOffset) &#123;</span><br><span class="line">                  transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">long</span> newOpOffset = calculateOpOffset(doneOpOffset, opOffset);</span><br><span class="line">              <span class="keyword">if</span> (newOpOffset != opOffset) &#123;</span><br><span class="line">                  transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          log.error(<span class="string">"Check error"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.broker.transaction.AbstractTransactionalMessageCheckListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resolveHalfMsg</span><span class="params">(<span class="keyword">final</span> MessageExt msgExt)</span> </span>&#123;</span><br><span class="line">      executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 发送回查消息</span></span><br><span class="line">                  sendCheckMessage(msgExt);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  LOGGER.error(<span class="string">"Send check message error!"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>OK~到这里我们我们就介绍啦！！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="https://help.aliyun.com/document_detail/43348.html?spm=5176.doc43490.6.566.Zd5Bl7" target="_blank" rel="noopener">阿里云——事务消息</a></p>
</li>
<li><p><a href="[http://silence.work/2018/08/22/RocketMQ-4-3%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/](http://silence.work/2018/08/22/RocketMQ-4-3事务使用与分析/">RocketMQ 事务消息的使用与原理分析</a>)</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在前面的源码分析中，我们总是能在很多地方看到对于事务消息特别的逻辑，这次我们终于可以讲一下啦！同时对利用消息队列来实现分布式事务感兴趣的同学也是不可错过的！
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——顺序消息</title>
    <link href="http://bestlixiang.site/2019/07/01/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF/"/>
    <id>http://bestlixiang.site/2019/07/01/RocketMQ源码/RocketMQ源码分析——顺序消息/</id>
    <published>2019-07-01T00:13:12.000Z</published>
    <updated>2019-07-01T00:13:40.937Z</updated>
    
    <content type="html"><![CDATA[<p>引：在前面的源码分析中，我们总是能在很多地方看到对于顺序消息特别的逻辑，这次我们终于可以讲一下啦！<a id="more"></a></p>
<h1 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h1><h2 id="全局顺序"><a href="#全局顺序" class="headerlink" title="全局顺序"></a>全局顺序</h2><p>对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。</p>
<p><img src="http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/49319/cn_zh/1534917028902/%E5%85%A8%E5%B1%80%E9%A1%BA%E5%BA%8F.png" alt="全局顺序"></p>
<p>适用场景：性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景。</p>
<p>例子：数据库 <code>binlog</code> 同步</p>
<h2 id="局部顺序"><a href="#局部顺序" class="headerlink" title="局部顺序"></a>局部顺序</h2><p>对于指定的一个 Topic，所有消息根据 sharding key 进行区块分区。 同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念。</p>
<p><img src="http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/49319/cn_zh/1534917248438/%E5%88%86%E5%8C%BA%E9%A1%BA%E5%BA%8F2.png" alt="局部顺序"></p>
<p>适用场景：性能要求高，以 sharding key 作为分区字段，在<strong>同一个区块中严格的按照 FIFO 原则</strong>进行消息发布和消费的场景。</p>
<p>例子：假设有个下单场景，每个阶段需要发邮件通知用户订单状态变化。用户付款完成时系统给用户发送订单已付款邮件，订单已发货时给用户发送订单已发货邮件，订单完成时给用户发送订单已完成邮件。假设订单A的消息为A1，A2，A3，发送顺序也如此。订单B的消息为B1，B2，B3，A订单消息先发送，B订单消息后发送。我们不要求消费顺序一定A1，A2，A3，B1，B2，B3这样的全局顺序消息，因为严重降低了系统的并发度。</p>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>NameServer和Broker还是按照之前<code>环境搭建</code>篇启动，但是自己魔改了官方顺序消息的例子，因为我感觉不太好理解。</p>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">            producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">            producer.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> orderId = i % <span class="number">2</span>;</span><br><span class="line">                Message msg =</span><br><span class="line">                    <span class="keyword">new</span> Message(<span class="string">"TopicTestjjj"</span>,</span><br><span class="line">                        (<span class="string">"Hello RocketMQ "</span> + i + <span class="string">" in order "</span> + orderId).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 同一个订单号，使用同一个队列(分区)</span></span><br><span class="line">                      	Integer id = (Integer) arg;</span><br><span class="line">                        <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">                        <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, orderId);</span><br><span class="line"></span><br><span class="line">                System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            producer.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException | RemotingException | MQBrokerException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_3"</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(<span class="string">"TopicTestjjj"</span>, <span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p><img src="https://upload-images.jianshu.io/upload_images/10354196-3788df31eb50866e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="顺序消息.png"></p>
<p>从上面我们看到，虽然订单1和订单2之间是无序的，但是对于单个订单，他的消息是<strong>有序</strong>的。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>我们这里只分析<strong>局部顺序</strong>，全局顺序也是一样的。</p>
<p><strong>要保证消息的顺序消费</strong>，有三个关键点</p>
<ol>
<li>消息顺序发送</li>
<li>消息顺序存储</li>
<li>消息顺序消费</li>
</ol>
<h2 id="消息顺序发送"><a href="#消息顺序发送" class="headerlink" title="消息顺序发送"></a>消息顺序发送</h2><p>多线程发送的消息无法保证有序性，因此，需要业务方在发送时，<strong>针对同一个业务编号(如同一笔订单)的消息需要保证在一个线程内顺序发送</strong>，在上一个消息发送成功后，再进行下一个消息的发送。对于同一个业务编号，生产者消息发送方法必须使用同步发送，异步发送无法保证顺序性。</p>
<h2 id="消息顺序存储"><a href="#消息顺序存储" class="headerlink" title="消息顺序存储"></a>消息顺序存储</h2><p>mq的topic下会存在多个queue，要保证消息的顺序存储，<strong>同一个业务编号的消息需要被发送到一个queue中</strong>。所以需要使用MessageQueueSelector来选择要发送的queue，即对业务编号进行hash，然后根据队列数量对hash值取余，将消息发送到一个queue中，这就是实现<strong>局部顺序</strong>的关键，如果是<strong>全局顺序</strong>，大家应该都能想到就是要将所有的消息只发送到一个队列即可。</p>
<h2 id="消息顺序消费"><a href="#消息顺序消费" class="headerlink" title="消息顺序消费"></a>消息顺序消费</h2><p>要保证消息顺序消费，同一个queue就只能被一个消费者所消费，因此对broker中消费队列加锁是无法避免的。同一时刻，一个消费队列只能被一个消费者消费，消费者内部，也只能有一个消费线程来消费该队列。即<strong>同一时刻，一个消费队列只能被一个消费者中的一个线程消费</strong>。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h2><p>上面我们提到了保证消息的顺序发送和消息顺序存储都是在生产者端控制的，我们在使用方式中也有一定的体现，核心就是<code>MessageQueueSelector</code>。</p>
<p>关于<strong>生产者发送消</strong>息的解析，可以看我之前的文章，这里我们直接跳到和<code>MessageQueueSelector</code>相关的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl  </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendSelectImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">       Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">       MessageQueueSelector selector,</span></span></span><br><span class="line"><span class="function"><span class="params">       Object arg,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> CommunicationMode communicationMode,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> SendCallback sendCallback, <span class="keyword">final</span> <span class="keyword">long</span> timeout</span></span></span><br><span class="line"><span class="function"><span class="params">   )</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> beginStartTime = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line">       Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">       TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">       <span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">           MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 选择队列，使用Hash选择</span></span><br><span class="line">               mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"select message queue throwed exception."</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">long</span> costTime = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">           <span class="keyword">if</span> (timeout &lt; costTime) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendSelectImpl call timeout"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (mq != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 发送消息</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, <span class="keyword">null</span>, timeout - costTime);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"select message queue return null."</span>, <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"No route info for this topic, "</span> + msg.getTopic(), <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// org.apache.rocketmq.client.producer.selector.SelectMessageQueueByHash</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectMessageQueueByHash</span> <span class="keyword">implements</span> <span class="title">MessageQueueSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> value = arg.hashCode();</span><br><span class="line">         <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             value = Math.abs(value);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         value = value % mqs.size();</span><br><span class="line">         <span class="keyword">return</span> mqs.get(value);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h2><p>消费者的目标就是保证<strong>同一时刻，一个消费队列只能被一个消费者中的一个线程消费</strong>。</p>
<p>我们在使用方式中看到他有自己的<strong>顺序消费监听器</strong><code>MessageListenerOrderly</code>，如果忘了<strong>消息者是如何消费消息的</strong>，也可以回头看看我之前的文章，这里也直入主题。</p>
<h3 id="获取队列"><a href="#获取队列" class="headerlink" title="获取队列"></a>获取队列</h3><p>Consumer启动后会初始化一个<code>RebalanceImpl</code>做rebalance操作，从而得到当前这个consumer负责处理哪些queue的消息。</p>
<p>对于顺序消息的消费者，还要求在获取队列的时候去给消息队列加锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.impl.consumer.RebalanceImpl#updateProcessQueueTableInRebalance</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateProcessQueueTableInRebalance</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> Set&lt;MessageQueue&gt; mqSet,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">        List&lt;PullRequest&gt; pullRequestList = <span class="keyword">new</span> ArrayList&lt;PullRequest&gt;();</span><br><span class="line">        <span class="keyword">for</span> (MessageQueue mq : mqSet) &#123;</span><br><span class="line">            <span class="comment">// 如果是新加入的Queue</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.processQueueTable.containsKey(mq)) &#123;</span><br><span class="line">                <span class="comment">// 如果是顺序消费者，则去给消息队列加锁   **关键**</span></span><br><span class="line">                <span class="keyword">if</span> (isOrder &amp;&amp; !<span class="keyword">this</span>.lock(mq)) &#123;</span><br><span class="line">                    log.warn(<span class="string">"doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed"</span>, consumerGroup, mq);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从offset store中移除过时的数据</span></span><br><span class="line">                <span class="keyword">this</span>.removeDirtyOffset(mq);</span><br><span class="line">                ProcessQueue pq = <span class="keyword">new</span> ProcessQueue();</span><br><span class="line">                <span class="comment">// 获取起始消费offset</span></span><br><span class="line">                <span class="keyword">long</span> nextOffset = <span class="keyword">this</span>.computePullFromWhere(mq);</span><br><span class="line">                <span class="keyword">if</span> (nextOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 为新的Queue初始化一个ProcessQueue，用来缓存收到的消息</span></span><br><span class="line">                    ProcessQueue pre = <span class="keyword">this</span>.processQueueTable.putIfAbsent(mq, pq);</span><br><span class="line">                    <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        log.info(<span class="string">"doRebalance, &#123;&#125;, mq already exists, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.info(<span class="string">"doRebalance, &#123;&#125;, add a new mq, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                        <span class="comment">// 对新加的queue初始化一个PullRequest</span></span><br><span class="line">                        PullRequest pullRequest = <span class="keyword">new</span> PullRequest();</span><br><span class="line">                        pullRequest.setConsumerGroup(consumerGroup);</span><br><span class="line">                        pullRequest.setNextOffset(nextOffset);</span><br><span class="line">                        pullRequest.setMessageQueue(mq);</span><br><span class="line">                        pullRequest.setProcessQueue(pq);</span><br><span class="line">                        pullRequestList.add(pullRequest);</span><br><span class="line">                        changed = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.warn(<span class="string">"doRebalance, &#123;&#125;, add new mq failed, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分发pull request到PullMessageService拉取消息</span></span><br><span class="line">        <span class="keyword">this</span>.dispatchPullRequest(pullRequestList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//org.apache.rocketmq.client.impl.consumer.RebalanceImpl#lock</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span> </span>&#123;</span><br><span class="line">        FindBrokerResult findBrokerResult = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (findBrokerResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">            LockBatchRequestBody requestBody = <span class="keyword">new</span> LockBatchRequestBody();</span><br><span class="line">            requestBody.setConsumerGroup(<span class="keyword">this</span>.consumerGroup);</span><br><span class="line">            requestBody.setClientId(<span class="keyword">this</span>.mQClientFactory.getClientId());</span><br><span class="line">            requestBody.getMqSet().add(mq);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 请求Broker获得指定消息队列的分布式锁</span></span><br><span class="line">                Set&lt;MessageQueue&gt; lockedMq =</span><br><span class="line">                    <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, <span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 设置消息处理队列锁定成功</span></span><br><span class="line">                <span class="keyword">for</span> (MessageQueue mmqq : lockedMq) &#123;</span><br><span class="line">                    ProcessQueue processQueue = <span class="keyword">this</span>.processQueueTable.get(mmqq);</span><br><span class="line">                    <span class="keyword">if</span> (processQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        processQueue.setLocked(<span class="keyword">true</span>);</span><br><span class="line">                        processQueue.setLastLockTimestamp(System.currentTimeMillis());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> lockOK = lockedMq.contains(mq);</span><br><span class="line">                log.info(<span class="string">"the message queue lock &#123;&#125;, &#123;&#125; &#123;&#125;"</span>,</span><br><span class="line">                    lockOK ? <span class="string">"OK"</span> : <span class="string">"Failed"</span>,</span><br><span class="line">                    <span class="keyword">this</span>.consumerGroup,</span><br><span class="line">                    mq);</span><br><span class="line">                <span class="keyword">return</span> lockOK;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"lockBatchMQ exception, "</span> + mq, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们在之前分析<code>Consumer</code>的时候，我们说过在启动<code>DefaultMQPushConsumer</code>时会启动一个<code>ConsumeMessageService</code>，对应顺序消息它会启动对应的<code>ConsumeMessageOrderlyService</code>，看看它启动干了什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在集群模式下</span></span><br><span class="line">    <span class="keyword">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel())) &#123;</span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 定时给MQ加锁</span></span><br><span class="line">                ConsumeMessageOrderlyService.<span class="keyword">this</span>.lockMQPeriodically();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">1</span>, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockMQPeriodically</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.stopped) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumerImpl.getRebalanceImpl().lockAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h3><p><code>RebalanceImpl</code>在从Broker获取到消息后，会调用<code>ConsumeMessageOrderlyService</code>的<code>submitConsumeRequest()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitConsumeRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ProcessQueue processQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> MessageQueue messageQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">boolean</span> dispathToConsume)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dispathToConsume) &#123;</span><br><span class="line">        ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(processQueue, messageQueue);</span><br><span class="line">        <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ComsumeRequest</code>其实就是一个，我们就是把它丢进线程池进行处理，我们具体看看这个任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumeRequest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ProcessQueue processQueue;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> MessageQueue messageQueue;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConsumeRequest</span><span class="params">(ProcessQueue processQueue, MessageQueue messageQueue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.processQueue = processQueue;</span><br><span class="line">            <span class="keyword">this</span>.messageQueue = messageQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ProcessQueue <span class="title">getProcessQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> processQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">getMessageQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> messageQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                log.warn(<span class="string">"run, the message queue not be able to consume, because it's dropped. &#123;&#125;"</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取消息MessageQueue锁对象，加互斥锁，保证同一个MessageQueue同时只会有一个线程在处理消息</span></span><br><span class="line">            <span class="comment">// 就是将本地的MessageQueue对象与远程的分布式关联起来</span></span><br><span class="line">            <span class="keyword">final</span> Object objLock = messageQueueLock.fetchLockObject(<span class="keyword">this</span>.messageQueue);</span><br><span class="line">            <span class="keyword">synchronized</span> (objLock) &#123;</span><br><span class="line">                <span class="comment">// Cluster模式下同时判断processQueue也是被锁定的</span></span><br><span class="line">                <span class="keyword">if</span> (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel())</span><br><span class="line">                    || (<span class="keyword">this</span>.processQueue.isLocked() &amp;&amp; !<span class="keyword">this</span>.processQueue.isLockExpired())) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">boolean</span> continueConsume = <span class="keyword">true</span>; continueConsume; ) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                            log.warn(<span class="string">"the message queue not be able to consume, because it's dropped. &#123;&#125;"</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果没有获得锁，放入定时任务中待会重新加锁消费</span></span><br><span class="line">                        <span class="keyword">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel())</span><br><span class="line">                            &amp;&amp; !<span class="keyword">this</span>.processQueue.isLocked()) &#123;</span><br><span class="line">                            log.warn(<span class="string">"the message queue not locked, so consume later, &#123;&#125;"</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                            ConsumeMessageOrderlyService.<span class="keyword">this</span>.tryLockLaterAndReconsume(<span class="keyword">this</span>.messageQueue, <span class="keyword">this</span>.processQueue, <span class="number">10</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果锁过期，放入定时任务中待会重新加锁消费</span></span><br><span class="line">                        <span class="keyword">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel())</span><br><span class="line">                            &amp;&amp; <span class="keyword">this</span>.processQueue.isLockExpired()) &#123;</span><br><span class="line">                            log.warn(<span class="string">"the message queue lock expired, so consume later, &#123;&#125;"</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                            ConsumeMessageOrderlyService.<span class="keyword">this</span>.tryLockLaterAndReconsume(<span class="keyword">this</span>.messageQueue, <span class="keyword">this</span>.processQueue, <span class="number">10</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 当前周期消费时间超过连续时长</span></span><br><span class="line">                        <span class="comment">// 默认：60s，提交延迟消费请求。默认情况下，每消费1分钟休息10ms</span></span><br><span class="line">                        <span class="keyword">long</span> interval = System.currentTimeMillis() - beginTime;</span><br><span class="line">                        <span class="keyword">if</span> (interval &gt; MAX_TIME_CONSUME_CONTINUOUSLY) &#123;</span><br><span class="line">                            ConsumeMessageOrderlyService.<span class="keyword">this</span>.submitConsumeRequestLater(processQueue, messageQueue, <span class="number">10</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 从ProcessQueue获取一批消息</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> consumeBatchSize =</span><br><span class="line">                            ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line"></span><br><span class="line">                        List&lt;MessageExt&gt; msgs = <span class="keyword">this</span>.processQueue.takeMessags(consumeBatchSize);</span><br><span class="line">                        <span class="keyword">if</span> (!msgs.isEmpty()) &#123;</span><br><span class="line">                            <span class="keyword">final</span> ConsumeOrderlyContext context = <span class="keyword">new</span> ConsumeOrderlyContext(<span class="keyword">this</span>.messageQueue);</span><br><span class="line"></span><br><span class="line">                            ConsumeOrderlyStatus status = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                            ConsumeMessageContext consumeMessageContext = <span class="keyword">null</span>;</span><br><span class="line">                           	<span class="comment">// ...</span></span><br><span class="line">                            ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">                            <span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 获得消费锁，粒度更小，防止在消费时，有其他线程介入</span></span><br><span class="line">                                <span class="keyword">this</span>.processQueue.getLockConsume().lock();</span><br><span class="line">                                <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                                    log.warn(<span class="string">"consumeMessage, the message queue not be able to consume, because it's dropped. &#123;&#125;"</span>,</span><br><span class="line">                                        <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 调用用户自定义Listener处理消息</span></span><br><span class="line">                                status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                                log.warn(<span class="string">"consumeMessage exception: &#123;&#125; Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;"</span>,</span><br><span class="line">                                    RemotingHelper.exceptionSimpleDesc(e),</span><br><span class="line">                                    ConsumeMessageOrderlyService.<span class="keyword">this</span>.consumerGroup,</span><br><span class="line">                                    msgs,</span><br><span class="line">                                    messageQueue);</span><br><span class="line">                                hasException = <span class="keyword">true</span>;</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                <span class="comment">// 消费锁解锁</span></span><br><span class="line">                                <span class="keyword">this</span>.processQueue.getLockConsume().unlock();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">														<span class="comment">// ...</span></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            ConsumeMessageOrderlyService.<span class="keyword">this</span>.getConsumerStatsManager()</span><br><span class="line">                                .incConsumeRT(ConsumeMessageOrderlyService.<span class="keyword">this</span>.consumerGroup, messageQueue.getTopic(), consumeRT);</span><br><span class="line">                            <span class="comment">// 处理消费结果</span></span><br><span class="line">                            continueConsume = ConsumeMessageOrderlyService.<span class="keyword">this</span>.processConsumeResult(msgs, status, context, <span class="keyword">this</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            continueConsume = <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                        log.warn(<span class="string">"the message queue not be able to consume, because it's dropped. &#123;&#125;"</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ConsumeMessageOrderlyService.<span class="keyword">this</span>.tryLockLaterAndReconsume(<span class="keyword">this</span>.messageQueue, <span class="keyword">this</span>.processQueue, <span class="number">100</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理消费结果"><a href="#处理消费结果" class="headerlink" title="处理消费结果"></a>处理消费结果</h3><p>跟着上面走，<code>ConsumeMessageOrderlyService</code>是如何处理消费结果的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processConsumeResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ConsumeOrderlyStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ConsumeOrderlyContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ConsumeRequest consumeRequest</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> continueConsume = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">long</span> commitOffset = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">if</span> (context.isAutoCommit()) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        		<span class="comment">// ROLLBACK 、COMMIT 暂时只使用在 MySQL binlog 场景，官方将这两状态标记为 @Deprecated</span></span><br><span class="line">            <span class="keyword">case</span> COMMIT:</span><br><span class="line">            <span class="keyword">case</span> ROLLBACK:</span><br><span class="line">                log.warn(<span class="string">"the message queue consume result is illegal, we think you want to ack these message &#123;&#125;"</span>,</span><br><span class="line">                    consumeRequest.getMessageQueue());</span><br><span class="line">            <span class="keyword">case</span> SUCCESS:</span><br><span class="line">                <span class="comment">// 如果成功，则调用ProcessQueue的commit方法</span></span><br><span class="line">                commitOffset = consumeRequest.getProcessQueue().commit();</span><br><span class="line">                <span class="keyword">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUSPEND_CURRENT_QUEUE_A_MOMENT:</span><br><span class="line">                <span class="comment">// 检查重试次数，如果没超过则放到ProcessQueue中；如果超过则直接发到broker的Dead Queue中</span></span><br><span class="line">                <span class="comment">// ProcessQueue维护了一个msgTreeMap，保证了顺序</span></span><br><span class="line">                <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</span><br><span class="line">                <span class="keyword">if</span> (checkReconsumeTimes(msgs)) &#123;</span><br><span class="line">                    consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);</span><br><span class="line">                    <span class="keyword">this</span>.submitConsumeRequestLater(</span><br><span class="line">                        consumeRequest.getProcessQueue(),</span><br><span class="line">                        consumeRequest.getMessageQueue(),</span><br><span class="line">                        context.getSuspendCurrentQueueTimeMillis());</span><br><span class="line">                    continueConsume = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    commitOffset = consumeRequest.getProcessQueue().commit();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (commitOffset &gt;= <span class="number">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> continueConsume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里就结束啦~</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="https://help.aliyun.com/document_detail/49319.html" target="_blank" rel="noopener">顺序消息</a></p>
</li>
<li><p><a href="https://blog.csdn.net/hosaos/article/details/90675978" target="_blank" rel="noopener">RocketMQ-顺序消息Demo及实现原理分析</a></p>
</li>
<li><p><a href="http://www.iocoder.cn/RocketMQ/message-send-and-consume-orderly/" target="_blank" rel="noopener">RocketMQ 源码分析 —— Message 顺序发送与消费</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在前面的源码分析中，我们总是能在很多地方看到对于顺序消息特别的逻辑，这次我们终于可以讲一下啦！
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>数据库调优</title>
    <link href="http://bestlixiang.site/2019/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98/"/>
    <id>http://bestlixiang.site/2019/06/29/数据库/数据库调优/</id>
    <published>2019-06-29T15:18:04.000Z</published>
    <updated>2019-06-29T15:19:51.204Z</updated>
    
    <content type="html"><![CDATA[<p>引：我恨自己当有问题出现时，没有立刻去把握它！今天看了很多关于Mysql索引优化器的东西，但是没有拿到结果！留下一些链接，希望下次出现索引优化的问题或者慢查询的问题，自己能好好分析一波！<a id="more"></a></p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ol>
<li><a href="https://dev.mysql.com/doc/internals/en/optimizer-tracing-typical-usage.html" target="_blank" rel="noopener">mysql手册</a></li>
<li><a href="[https://iluoy.com/articles/203#TRACE%E5%88%86%E6%9E%908](https://iluoy.com/articles/203#TRACE分析8">mysql之通过trace分析优化器如何选择执行计划</a>)</li>
<li><a href="https://www.kancloud.cn/taobaomysql/monthly/81380" target="_blank" rel="noopener">MySQL · 答疑解惑 · MySQL 优化器 range 的代价计算</a></li>
<li><a href="https://blog.csdn.net/angry_mills/article/details/87720396" target="_blank" rel="noopener">[官方] mysql 性能优化文档（中英文自译）</a></li>
<li><a href="https://blog.csdn.net/why15732625998/article/details/80388236" target="_blank" rel="noopener"> EXPLAIN用法和结果分析</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：我恨自己当有问题出现时，没有立刻去把握它！今天看了很多关于Mysql索引优化器的东西，但是没有拿到结果！留下一些链接，希望下次出现索引优化的问题或者慢查询的问题，自己能好好分析一波！
    
    </summary>
    
      <category term="数据库" scheme="http://bestlixiang.site/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://bestlixiang.site/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——Broker接收拉消息</title>
    <link href="http://bestlixiang.site/2019/06/29/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Broke%E6%8E%A5%E6%94%B6%E6%8B%89%E6%B6%88%E6%81%AF/"/>
    <id>http://bestlixiang.site/2019/06/29/RocketMQ源码/RocketMQ源码分析——Broke接收拉消息/</id>
    <published>2019-06-28T23:44:23.000Z</published>
    <updated>2019-07-01T00:12:04.392Z</updated>
    
    <content type="html"><![CDATA[<p>引：前面讲到了Broker对于不同的消息有自己不同的Processor，对于<code>PushConsumer</code>的Pull请求的时候，它对应的就是<code>PullMessageProcessor</code>~<a id="more"></a></p>
<h1 id="PullMessageProcessor"><a href="#PullMessageProcessor" class="headerlink" title="PullMessageProcessor"></a>PullMessageProcessor</h1><p>通过前面的分析，我们自然而然地就会想到去看<code>org.apache.rocketmq.broker.processor.PullMessageProcessor#processRequest()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">processRequest</span><span class="params">(<span class="keyword">final</span> Channel channel, RemotingCommand request, <span class="keyword">boolean</span> brokerAllowSuspend)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">        RemotingCommand response = RemotingCommand.createResponseCommand(PullMessageResponseHeader.class);</span><br><span class="line">        <span class="keyword">final</span> PullMessageResponseHeader responseHeader = (PullMessageResponseHeader) response.readCustomHeader();</span><br><span class="line">        <span class="keyword">final</span> PullMessageRequestHeader requestHeader =</span><br><span class="line">            (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);</span><br><span class="line"></span><br><span class="line">        response.setOpaque(request.getOpaque());</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"receive PullMessage request command, &#123;&#125;"</span>, request);</span><br><span class="line">        <span class="comment">// 判断Broker当前是否可读</span></span><br><span class="line">        <span class="keyword">if</span> (!PermName.isReadable(<span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerPermission())) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(String.format(<span class="string">"the broker[%s] pulling message is forbidden"</span>, <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1()));</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断consumerGroup是否存在</span></span><br><span class="line">        SubscriptionGroupConfig subscriptionGroupConfig =</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionGroupConfig) &#123;</span><br><span class="line">            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</span><br><span class="line">            response.setRemark(String.format(<span class="string">"subscription group [%s] does not exist, %s"</span>, requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断consumerGroup的消费状态是否Enable</span></span><br><span class="line">        <span class="keyword">if</span> (!subscriptionGroupConfig.isConsumeEnable()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(<span class="string">"subscription group no permission, "</span> + requestHeader.getConsumerGroup());</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> hasSuspendFlag = PullSysFlag.hasSuspendFlag(requestHeader.getSysFlag());</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> hasCommitOffsetFlag = PullSysFlag.hasCommitOffsetFlag(requestHeader.getSysFlag());</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> hasSubscriptionFlag = PullSysFlag.hasSubscriptionFlag(requestHeader.getSysFlag());</span><br><span class="line">				<span class="comment">// 获得挂起时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> suspendTimeoutMillisLong = hasSuspendFlag ? requestHeader.getSuspendTimeoutMillis() : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 判断请求的topic是否存在，并且可读，请求的queueId是否合法</span></span><br><span class="line">        TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">            log.error(<span class="string">"the topic &#123;&#125; not exist, consumer: &#123;&#125;"</span>, requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(channel));</span><br><span class="line">            response.setCode(ResponseCode.TOPIC_NOT_EXIST);</span><br><span class="line">            response.setRemark(String.format(<span class="string">"topic[%s] not exist, apply first please! %s"</span>, requestHeader.getTopic(), FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!PermName.isReadable(topicConfig.getPerm())) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(<span class="string">"the topic["</span> + requestHeader.getTopic() + <span class="string">"] pulling message is forbidden"</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (requestHeader.getQueueId() &lt; <span class="number">0</span> || requestHeader.getQueueId() &gt;= topicConfig.getReadQueueNums()) &#123;</span><br><span class="line">            String errorInfo = String.format(<span class="string">"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] consumer:[%s]"</span>,</span><br><span class="line">                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(), channel.remoteAddress());</span><br><span class="line">            log.warn(errorInfo);</span><br><span class="line">            response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">            response.setRemark(errorInfo);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SubscriptionData subscriptionData = <span class="keyword">null</span>;</span><br><span class="line">        ConsumerFilterData consumerFilterData = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 有设置subscribe flag,表示第一次pull或者需要更新filter</span></span><br><span class="line">        <span class="keyword">if</span> (hasSubscriptionFlag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              	<span class="comment">// 获得订阅信息，用于过滤消息</span></span><br><span class="line">                subscriptionData = FilterAPI.build(</span><br><span class="line">                    requestHeader.getTopic(), requestHeader.getSubscription(), requestHeader.getExpressionType()</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 是否使用了表达式过滤</span></span><br><span class="line">                <span class="keyword">if</span> (!ExpressionType.isTagType(subscriptionData.getExpressionType())) &#123;</span><br><span class="line">                    consumerFilterData = ConsumerFilterManager.build(</span><br><span class="line">                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getSubscription(),</span><br><span class="line">                        requestHeader.getExpressionType(), requestHeader.getSubVersion()</span><br><span class="line">                    );</span><br><span class="line">                    <span class="keyword">assert</span> consumerFilterData != <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.warn(<span class="string">"Parse the consumer's subscription[&#123;&#125;] failed, group: &#123;&#125;"</span>, requestHeader.getSubscription(),</span><br><span class="line">                    requestHeader.getConsumerGroup());</span><br><span class="line">                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);</span><br><span class="line">                response.setRemark(<span class="string">"parse the consumer's subscription failed"</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有设置subscribe flag，表示之前已经订阅过了,对比订阅条件是否一致</span></span><br><span class="line">            <span class="comment">// 对于同一个ConsumerGroup下的多个consumer客户端，Broker要求订阅参数设置必须要是一致的，要不然会造成数据混乱</span></span><br><span class="line">            ConsumerGroupInfo consumerGroupInfo =</span><br><span class="line">                <span class="keyword">this</span>.brokerController.getConsumerManager().getConsumerGroupInfo(requestHeader.getConsumerGroup());</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == consumerGroupInfo) &#123;</span><br><span class="line">                log.warn(<span class="string">"the consumer's group info not exist, group: &#123;&#125;"</span>, requestHeader.getConsumerGroup());</span><br><span class="line">                response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);</span><br><span class="line">                response.setRemark(<span class="string">"the consumer's group info not exist"</span> + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!subscriptionGroupConfig.isConsumeBroadcastEnable()</span><br><span class="line">                &amp;&amp; consumerGroupInfo.getMessageModel() == MessageModel.BROADCASTING) &#123;</span><br><span class="line">                response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">                response.setRemark(<span class="string">"the consumer group["</span> + requestHeader.getConsumerGroup() + <span class="string">"] can not consume by broadcast way"</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            subscriptionData = consumerGroupInfo.findSubscriptionData(requestHeader.getTopic());</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionData) &#123;</span><br><span class="line">                log.warn(<span class="string">"the consumer's subscription not exist, group: &#123;&#125;, topic:&#123;&#125;"</span>, requestHeader.getConsumerGroup(), requestHeader.getTopic());</span><br><span class="line">                response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);</span><br><span class="line">                response.setRemark(<span class="string">"the consumer's subscription not exist"</span> + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (subscriptionData.getSubVersion() &lt; requestHeader.getSubVersion()) &#123;</span><br><span class="line">                log.warn(<span class="string">"The broker's subscription is not latest, group: &#123;&#125; &#123;&#125;"</span>, requestHeader.getConsumerGroup(),</span><br><span class="line">                    subscriptionData.getSubString());</span><br><span class="line">                response.setCode(ResponseCode.SUBSCRIPTION_NOT_LATEST);</span><br><span class="line">                response.setRemark(<span class="string">"the consumer's subscription not latest"</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ExpressionType.isTagType(subscriptionData.getExpressionType())) &#123;</span><br><span class="line">                consumerFilterData = <span class="keyword">this</span>.brokerController.getConsumerFilterManager().get(requestHeader.getTopic(),</span><br><span class="line">                    requestHeader.getConsumerGroup());</span><br><span class="line">                <span class="keyword">if</span> (consumerFilterData == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    response.setCode(ResponseCode.FILTER_DATA_NOT_EXIST);</span><br><span class="line">                    response.setRemark(<span class="string">"The broker's consumer filter data is not exist!Your expression may be wrong!"</span>);</span><br><span class="line">                    <span class="keyword">return</span> response;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (consumerFilterData.getClientVersion() &lt; requestHeader.getSubVersion()) &#123;</span><br><span class="line">                    log.warn(<span class="string">"The broker's consumer filter data is not latest, group: &#123;&#125;, topic: &#123;&#125;, serverV: &#123;&#125;, clientV: &#123;&#125;"</span>,</span><br><span class="line">                        requestHeader.getConsumerGroup(), requestHeader.getTopic(), consumerFilterData.getClientVersion(), requestHeader.getSubVersion());</span><br><span class="line">                    response.setCode(ResponseCode.FILTER_DATA_NOT_LATEST);</span><br><span class="line">                    response.setRemark(<span class="string">"the consumer's consumer filter data not latest"</span>);</span><br><span class="line">                    <span class="keyword">return</span> response;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ExpressionType.isTagType(subscriptionData.getExpressionType())</span><br><span class="line">            &amp;&amp; !<span class="keyword">this</span>.brokerController.getBrokerConfig().isEnablePropertyFilter()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">            response.setRemark(<span class="string">"The broker does not support consumer to filter message by "</span> + subscriptionData.getExpressionType());</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据订阅信息和过滤信息创建消息过滤器</span></span><br><span class="line">        MessageFilter messageFilter;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isFilterSupportRetry()) &#123;</span><br><span class="line">            messageFilter = <span class="keyword">new</span> ExpressionForRetryMessageFilter(subscriptionData, consumerFilterData,</span><br><span class="line">                <span class="keyword">this</span>.brokerController.getConsumerFilterManager());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            messageFilter = <span class="keyword">new</span> ExpressionMessageFilter(subscriptionData, consumerFilterData,</span><br><span class="line">                <span class="keyword">this</span>.brokerController.getConsumerFilterManager());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过messageStore读取消息（带上topic和queueId和offset和过滤器）</span></span><br><span class="line">        <span class="keyword">final</span> GetMessageResult getMessageResult =</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</span><br><span class="line">                requestHeader.getQueueId(), requestHeader.getQueueOffset(), requestHeader.getMaxMsgNums(), messageFilter);</span><br><span class="line">        <span class="keyword">if</span> (getMessageResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">            response.setRemark(getMessageResult.getStatus().name());</span><br><span class="line">            responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());</span><br><span class="line">            responseHeader.setMinOffset(getMessageResult.getMinOffset());</span><br><span class="line">            responseHeader.setMaxOffset(getMessageResult.getMaxOffset());</span><br><span class="line">            <span class="comment">// master读取比较慢的话，默认设置推荐从slave读取</span></span><br><span class="line">            <span class="keyword">if</span> (getMessageResult.isSuggestPullingFromSlave()) &#123;</span><br><span class="line">                responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">                <span class="keyword">case</span> ASYNC_MASTER:</span><br><span class="line">                <span class="keyword">case</span> SYNC_MASTER:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> SLAVE:</span><br><span class="line">                    <span class="comment">// 如果当前broker是slave，并且不支持read，则提示客户端从master读</span></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;</span><br><span class="line">                        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">                        responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果slave可读，覆盖之前的设置</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;</span><br><span class="line">                <span class="comment">// consume too slow ,redirect to another machine</span></span><br><span class="line">                <span class="keyword">if</span> (getMessageResult.isSuggestPullingFromSlave()) &#123;</span><br><span class="line">                    responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// consume ok</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将MessageStore读取的返回状态映射成repsonse的状态</span></span><br><span class="line">            <span class="keyword">switch</span> (getMessageResult.getStatus()) &#123;</span><br><span class="line">                <span class="keyword">case</span> FOUND:</span><br><span class="line">                    response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_WAS_REMOVING:</span><br><span class="line">                    response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> NO_MATCHED_LOGIC_QUEUE:</span><br><span class="line">                <span class="keyword">case</span> NO_MESSAGE_IN_QUEUE:</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> != requestHeader.getQueueOffset()) &#123;</span><br><span class="line">                        response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                        log.info(<span class="string">"the broker store no queue data, fix the request offset &#123;&#125; to &#123;&#125;, Topic: &#123;&#125; QueueId: &#123;&#125; Consumer Group: &#123;&#125;"</span>,</span><br><span class="line">                            requestHeader.getQueueOffset(),</span><br><span class="line">                            getMessageResult.getNextBeginOffset(),</span><br><span class="line">                            requestHeader.getTopic(),</span><br><span class="line">                            requestHeader.getQueueId(),</span><br><span class="line">                            requestHeader.getConsumerGroup()</span><br><span class="line">                        );</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> NO_MATCHED_MESSAGE:</span><br><span class="line">                    response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> OFFSET_FOUND_NULL:</span><br><span class="line">                    response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> OFFSET_OVERFLOW_BADLY:</span><br><span class="line">                    response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">                    <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                    log.info(<span class="string">"the request offset: &#123;&#125; over flow badly, broker max offset: &#123;&#125;, consumer: &#123;&#125;"</span>,</span><br><span class="line">                        requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> OFFSET_OVERFLOW_ONE:</span><br><span class="line">                    response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> OFFSET_TOO_SMALL:</span><br><span class="line">                    response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">                    log.info(<span class="string">"the request offset too small. group=&#123;&#125;, topic=&#123;&#125;, requestOffset=&#123;&#125;, brokerMinOffset=&#123;&#125;, clientIp=&#123;&#125;"</span>,</span><br><span class="line">                        requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueOffset(),</span><br><span class="line">                        getMessageResult.getMinOffset(), channel.remoteAddress());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果有回调函数</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 处理返回结果</span></span><br><span class="line">            <span class="keyword">switch</span> (response.getCode()) &#123;</span><br><span class="line">                <span class="keyword">case</span> ResponseCode.SUCCESS:</span><br><span class="line">                    <span class="comment">// 成功后更新统计信息</span></span><br><span class="line">                    <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incGroupGetNums(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</span><br><span class="line">                        getMessageResult.getMessageCount());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incGroupGetSize(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</span><br><span class="line">                        getMessageResult.getBufferTotalSize());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incBrokerGetNums(getMessageResult.getMessageCount());</span><br><span class="line">                    <span class="comment">// 如果是通过堆，则从文件中读取消息set到response body返回</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isTransferMsgByHeap()) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = <span class="keyword">this</span>.brokerController.getMessageStore().now();</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">byte</span>[] r = <span class="keyword">this</span>.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());</span><br><span class="line">                        <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),</span><br><span class="line">                            requestHeader.getTopic(), requestHeader.getQueueId(),</span><br><span class="line">                            (<span class="keyword">int</span>) (<span class="keyword">this</span>.brokerController.getMessageStore().now() - beginTimeMills));</span><br><span class="line">                        response.setBody(r);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 否则，利用netty直接读取内存映射文件，少一次copy</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            FileRegion fileRegion =</span><br><span class="line">                                <span class="keyword">new</span> ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult);</span><br><span class="line">                            channel.writeAndFlush(fileRegion).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    getMessageResult.release();</span><br><span class="line">                                    <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                                        log.error(<span class="string">"transfer many message by pagecache failed, &#123;&#125;"</span>, channel.remoteAddress(), future.cause());</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                            log.error(<span class="string">"transfer many message by pagecache exception"</span>, e);</span><br><span class="line">                            getMessageResult.release();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        response = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 没有读取到消息，则hold住请求，有新消息时唤醒</span></span><br><span class="line">                <span class="comment">// 等待超时后还是没读到brokerAllowSuspend=false</span></span><br><span class="line">                <span class="keyword">case</span> ResponseCode.PULL_NOT_FOUND:</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;</span><br><span class="line">                      	<span class="comment">// 默认长轮询时间为设置的挂起超时时间</span></span><br><span class="line">                        <span class="keyword">long</span> pollingTimeMills = suspendTimeoutMillisLong;</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">                          	<span class="comment">// 没有开启长轮询，则轮询时间为1s</span></span><br><span class="line">                            pollingTimeMills = <span class="keyword">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        String topic = requestHeader.getTopic();</span><br><span class="line">                        <span class="keyword">long</span> offset = requestHeader.getQueueOffset();</span><br><span class="line">                        <span class="keyword">int</span> queueId = requestHeader.getQueueId();</span><br><span class="line">                        PullRequest pullRequest = <span class="keyword">new</span> PullRequest(request, channel, pollingTimeMills,</span><br><span class="line">                            <span class="keyword">this</span>.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);</span><br><span class="line">                        <span class="comment">// 利用PullRequestHoldService hold住PullRequest</span></span><br><span class="line">                        <span class="keyword">this</span>.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</span><br><span class="line">                        response = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> ResponseCode.PULL_RETRY_IMMEDIATELY:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 消费开始的offset不正确</span></span><br><span class="line">                <span class="keyword">case</span> ResponseCode.PULL_OFFSET_MOVED:</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE</span><br><span class="line">                        || <span class="keyword">this</span>.brokerController.getMessageStoreConfig().isOffsetCheckInSlave()) &#123;</span><br><span class="line">                        MessageQueue mq = <span class="keyword">new</span> MessageQueue();</span><br><span class="line">                        mq.setTopic(requestHeader.getTopic());</span><br><span class="line">                        mq.setQueueId(requestHeader.getQueueId());</span><br><span class="line">                        mq.setBrokerName(<span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerName());</span><br><span class="line"></span><br><span class="line">                        OffsetMovedEvent event = <span class="keyword">new</span> OffsetMovedEvent();</span><br><span class="line">                        event.setConsumerGroup(requestHeader.getConsumerGroup());</span><br><span class="line">                        event.setMessageQueue(mq);</span><br><span class="line">                        event.setOffsetRequest(requestHeader.getQueueOffset());</span><br><span class="line">                        event.setOffsetNew(getMessageResult.getNextBeginOffset());</span><br><span class="line">                        <span class="keyword">this</span>.generateOffsetMovedEvent(event);</span><br><span class="line">                        log.warn(</span><br><span class="line">                            <span class="string">"PULL_OFFSET_MOVED:correction offset. topic=&#123;&#125;, groupId=&#123;&#125;, requestOffset=&#123;&#125;, newOffset=&#123;&#125;, suggestBrokerId=&#123;&#125;"</span>,</span><br><span class="line">                            requestHeader.getTopic(), requestHeader.getConsumerGroup(), event.getOffsetRequest(), event.getOffsetNew(),</span><br><span class="line">                            responseHeader.getSuggestWhichBrokerId());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());</span><br><span class="line">                        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">                        log.warn(<span class="string">"PULL_OFFSET_MOVED:none correction. topic=&#123;&#125;, groupId=&#123;&#125;, requestOffset=&#123;&#125;, suggestBrokerId=&#123;&#125;"</span>,</span><br><span class="line">                            requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getQueueOffset(),</span><br><span class="line">                            responseHeader.getSuggestWhichBrokerId());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">            response.setRemark(<span class="string">"store getMessage return null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> storeOffsetEnable = brokerAllowSuspend;</span><br><span class="line">        storeOffsetEnable = storeOffsetEnable &amp;&amp; hasCommitOffsetFlag;</span><br><span class="line">        storeOffsetEnable = storeOffsetEnable</span><br><span class="line">            &amp;&amp; <span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;</span><br><span class="line">        <span class="keyword">if</span> (storeOffsetEnable) &#123;</span><br><span class="line">            <span class="comment">// 记录消息读取位置</span></span><br><span class="line">            <span class="keyword">this</span>.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),</span><br><span class="line">                requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看出：我们会根据topic和queueId和offset和过滤器从<code>MessageStore</code>中读取消息，<strong>如果成功</strong>，我们可以从指向内存文件的<code>ByteBuffer</code>得到数据，根据配置有两种返回数据的方式，第一种是从<code>ByteBuffer</code>中将数据读取到response中（经过堆），然后返回。第二种是让netty直接读取<code>ByteBuffer</code>，将消息写给客户端，相对前一种，不需要将<code>ByteBuffer</code>中的数据copy到java Heap中，少一次内存copy。<strong>但是第二种方式无法记录监控信息，比如consumer消费延时（从代码看出）等指标</strong>；<strong>如果没有读取到消息</strong>，会判断是否是<code>PushConsumer</code>（参数<code>hasSuspendFlag</code>）以及是否允许挂起（参数<code>brokerAllowSuspend</code>），如果是的话，则将请求挂起，方式就是封装成<code>PullRequest</code>提交给<code>PullRequestHoldService</code>。</p>
<p>#MessageStore#getMessage</p>
<p>我们看看这个方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> GetMessageResult <span class="title">getMessage</span><span class="params">(<span class="keyword">final</span> String group, <span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">int</span> maxMsgNums,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> MessageFilter messageFilter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.shutdown) &#123;</span><br><span class="line">        log.warn(<span class="string">"message store has shutdown, so getMessage is forbidden"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.runningFlags.isReadable()) &#123;</span><br><span class="line">        log.warn(<span class="string">"message store is not readable, so getMessage is forbidden "</span> + <span class="keyword">this</span>.runningFlags.getFlagBits());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> beginTime = <span class="keyword">this</span>.getSystemClock().now();</span><br><span class="line">    <span class="comment">// 默认没有消息在队列</span></span><br><span class="line">    GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</span><br><span class="line">    <span class="keyword">long</span> nextBeginOffset = offset;</span><br><span class="line">    <span class="keyword">long</span> minOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> maxOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    GetMessageResult getResult = <span class="keyword">new</span> GetMessageResult();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> maxOffsetPy = <span class="keyword">this</span>.commitLog.getMaxOffset();</span><br><span class="line">    <span class="comment">// 找到对应的ConsumeQueue</span></span><br><span class="line">    ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);</span><br><span class="line">    <span class="keyword">if</span> (consumeQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        minOffset = consumeQueue.getMinOffsetInQueue();</span><br><span class="line">        maxOffset = consumeQueue.getMaxOffsetInQueue();</span><br><span class="line">        <span class="comment">// 一些offset不合法的情况</span></span><br><span class="line">        <span class="keyword">if</span> (maxOffset == <span class="number">0</span>) &#123;</span><br><span class="line">            status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</span><br><span class="line">            nextBeginOffset = nextOffsetCorrection(offset, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &lt; minOffset) &#123;</span><br><span class="line">            status = GetMessageStatus.OFFSET_TOO_SMALL;</span><br><span class="line">            nextBeginOffset = nextOffsetCorrection(offset, minOffset);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset == maxOffset) &#123;</span><br><span class="line">            status = GetMessageStatus.OFFSET_OVERFLOW_ONE;</span><br><span class="line">            nextBeginOffset = nextOffsetCorrection(offset, offset);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &gt; maxOffset) &#123;</span><br><span class="line">            status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == minOffset) &#123;</span><br><span class="line">                nextBeginOffset = nextOffsetCorrection(offset, minOffset);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextBeginOffset = nextOffsetCorrection(offset, maxOffset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 根据offset找到对应的ConsumeQueue的MappedFile（包含ByteBuf）</span></span><br><span class="line">            SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset);</span><br><span class="line">            <span class="keyword">if</span> (bufferConsumeQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> nextPhyFileStartOffset = Long.MIN_VALUE;</span><br><span class="line">                    <span class="keyword">long</span> maxPhyOffsetPulling = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// 能返回的最大信息大小，不能大于16M</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> maxFilterMessageCount = Math.max(<span class="number">16000</span>, maxMsgNums * ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> diskFallRecorded = <span class="keyword">this</span>.messageStoreConfig.isDiskFallRecorded();</span><br><span class="line">                    <span class="comment">// 封装CqExtUnit</span></span><br><span class="line">                    ConsumeQueueExt.CqExtUnit cqExtUnit = <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit();</span><br><span class="line">                    <span class="keyword">for</span> (; i &lt; bufferConsumeQueue.getSize() &amp;&amp; i &lt; maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">                        <span class="comment">// 对应了CQUnit的结构</span></span><br><span class="line">                        <span class="keyword">long</span> offsetPy = bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class="line">                        <span class="keyword">int</span> sizePy = bufferConsumeQueue.getByteBuffer().getInt();</span><br><span class="line">                        <span class="keyword">long</span> tagsCode = bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class="line"></span><br><span class="line">                        maxPhyOffsetPulling = offsetPy;</span><br><span class="line">                        <span class="comment">// 不是末尾的情况，offsetPy不正常则返回</span></span><br><span class="line">                        <span class="keyword">if</span> (nextPhyFileStartOffset != Long.MIN_VALUE) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (offsetPy &lt; nextPhyFileStartOffset)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">boolean</span> isInDisk = checkInDiskByCommitOffset(offsetPy, maxOffsetPy);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.isTheBatchFull(sizePy, maxMsgNums, getResult.getBufferTotalSize(), getResult.getMessageCount(),</span><br><span class="line">                            isInDisk)) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">boolean</span> extRet = <span class="keyword">false</span>, isTagsCodeLegal = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (consumeQueue.isExtAddr(tagsCode)) &#123;</span><br><span class="line">                            extRet = consumeQueue.getExt(tagsCode, cqExtUnit);</span><br><span class="line">                            <span class="keyword">if</span> (extRet) &#123;</span><br><span class="line">                                tagsCode = cqExtUnit.getTagsCode();</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// can't find ext content.Client will filter messages by tag also.</span></span><br><span class="line">                                log.error(<span class="string">"[BUG] can't find consume queue extend file content!addr=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;, topic=&#123;&#125;, group=&#123;&#125;"</span>,</span><br><span class="line">                                    tagsCode, offsetPy, sizePy, topic, group);</span><br><span class="line">                                isTagsCodeLegal = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                      	<span class="comment">// 关于过滤，可以在参考出找到大佬的文章膜拜一下</span></span><br><span class="line">                        <span class="comment">// 是否有根据tagsCode匹配的消息</span></span><br><span class="line">                        <span class="keyword">if</span> (messageFilter != <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : <span class="keyword">null</span>, extRet ? cqExtUnit : <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (getResult.getBufferTotalSize() == <span class="number">0</span>) &#123;</span><br><span class="line">                                status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 根据offset和size从CommitLog拿到具体的Message</span></span><br><span class="line">                        SelectMappedBufferResult selectResult = <span class="keyword">this</span>.commitLog.getMessage(offsetPy, sizePy);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">null</span> == selectResult) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (getResult.getBufferTotalSize() == <span class="number">0</span>) &#123;</span><br><span class="line">                                status = GetMessageStatus.MESSAGE_WAS_REMOVING;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            nextPhyFileStartOffset = <span class="keyword">this</span>.commitLog.rollNextFile(offsetPy);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 是否有根据内容匹配的消息</span></span><br><span class="line">                        <span class="keyword">if</span> (messageFilter != <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; !messageFilter.isMatchedByCommitLog(selectResult.getByteBuffer().slice(), <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (getResult.getBufferTotalSize() == <span class="number">0</span>) &#123;</span><br><span class="line">                                status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// release...</span></span><br><span class="line">                            selectResult.release();</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 增加一些统计信息</span></span><br><span class="line">                        <span class="keyword">this</span>.storeStatsService.getGetMessageTransferedMsgCount().incrementAndGet();</span><br><span class="line">                        <span class="comment">// 将Message放入结果集</span></span><br><span class="line">                        getResult.addMessage(selectResult);</span><br><span class="line">                        status = GetMessageStatus.FOUND;</span><br><span class="line">                        nextPhyFileStartOffset = Long.MIN_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (diskFallRecorded) &#123;</span><br><span class="line">                        <span class="keyword">long</span> fallBehind = maxOffsetPy - maxPhyOffsetPulling;</span><br><span class="line">                        brokerStatsManager.recordDiskFallBehindSize(group, topic, queueId, fallBehind);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 更新offset</span></span><br><span class="line">                    nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> diff = maxOffsetPy - maxPhyOffsetPulling;</span><br><span class="line">                    <span class="keyword">long</span> memory = (<span class="keyword">long</span>) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE</span><br><span class="line">                        * (<span class="keyword">this</span>.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / <span class="number">100.0</span>));</span><br><span class="line">                    getResult.setSuggestPullingFromSlave(diff &gt; memory);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    bufferConsumeQueue.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                status = GetMessageStatus.OFFSET_FOUND_NULL;</span><br><span class="line">                nextBeginOffset = nextOffsetCorrection(offset, consumeQueue.rollNextFile(offset));</span><br><span class="line">                log.warn(<span class="string">"consumer request topic: "</span> + topic + <span class="string">"offset: "</span> + offset + <span class="string">" minOffset: "</span> + minOffset + <span class="string">" maxOffset: "</span></span><br><span class="line">                    + maxOffset + <span class="string">", but access logic queue failed."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = GetMessageStatus.NO_MATCHED_LOGIC_QUEUE;</span><br><span class="line">        nextBeginOffset = nextOffsetCorrection(offset, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (GetMessageStatus.FOUND == status) &#123;</span><br><span class="line">        <span class="keyword">this</span>.storeStatsService.getGetMessageTimesTotalFound().incrementAndGet();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.storeStatsService.getGetMessageTimesTotalMiss().incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> eclipseTime = <span class="keyword">this</span>.getSystemClock().now() - beginTime;</span><br><span class="line">    <span class="keyword">this</span>.storeStatsService.setGetMessageEntireTimeMax(eclipseTime);</span><br><span class="line"></span><br><span class="line">    getResult.setStatus(status);</span><br><span class="line">    getResult.setNextBeginOffset(nextBeginOffset);</span><br><span class="line">    getResult.setMaxOffset(maxOffset);</span><br><span class="line">    getResult.setMinOffset(minOffset);</span><br><span class="line">    <span class="keyword">return</span> getResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果理解了Broker的信息存储，上面的这些代码粗略的看还是比较好懂的。</p>
<p>主要是先找到topic+queue对应的<code>ConsumeQueue</code>，根据<code>PullRequest</code>传入的offset找到<br>对应的<code>MappedFile</code>；从<code>MappedFile</code>中里面读取指定数量的<code>CQUnit</code>，根据TagsCode做下过滤，然后得到过滤后的<code>Commit log</code>的offset；然后根据offset从CommitLog中获取具体的Message；最后再根据消息内容再做一次过滤，然后返回结果。</p>
<h1 id="PullRequestHoldService-suspendPullRequest"><a href="#PullRequestHoldService-suspendPullRequest" class="headerlink" title="PullRequestHoldService#suspendPullRequest"></a>PullRequestHoldService#suspendPullRequest</h1><p>从Processor的处理来看，<strong>如果没有读取到消息</strong>，会判断是否是<code>PushConsumer</code>（参数<code>hasSuspendFlag</code>）以及是否允许挂起（参数<code>brokerAllowSuspend</code>），如果是的话，则将请求挂起，方式就是封装成<code>PullRequest</code>提交给<code>PullRequestHoldService</code>。所以我们这里看看它是如何挂起请求处理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.broker.longpolling.PullRequestHoldService</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspendPullRequest</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">      String key = <span class="keyword">this</span>.buildKey(topic, queueId);</span><br><span class="line">      <span class="comment">// pullRequest被放入一个以topic+queue为key的Map中， value为一个队列ManyPullRequest</span></span><br><span class="line">      ManyPullRequest mpr = <span class="keyword">this</span>.pullRequestTable.get(key);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == mpr) &#123;</span><br><span class="line">          mpr = <span class="keyword">new</span> ManyPullRequest();</span><br><span class="line">          ManyPullRequest prev = <span class="keyword">this</span>.pullRequestTable.putIfAbsent(key, mpr);</span><br><span class="line">          <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">              mpr = prev;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mpr.addPullRequest(pullRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们回想一下，我们是不是在BrokerController启动中看到了PullRequestHoldService(继承ServiceThread)被启动了，所以我们应该去看看PullRequestHoldService做了什么，所以首先去看他的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       log.info(<span class="string">"&#123;&#125; service started"</span>, <span class="keyword">this</span>.getServiceName());</span><br><span class="line">       <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 是否开启长轮询, 长轮询等待5秒，短轮询等待1秒</span></span><br><span class="line">         			<span class="comment">// 如何过被通知有消息了就不会等，没有就等待</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.waitForRunning(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">this</span>.waitForRunning(<span class="keyword">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills());</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">long</span> beginLockTimestamp = <span class="keyword">this</span>.systemClock.now();</span><br><span class="line">             	<span class="comment">// 时间到了，或者有消息了就去通知消息消息到达</span></span><br><span class="line">               <span class="keyword">this</span>.checkHoldRequest();</span><br><span class="line">               <span class="keyword">long</span> costTime = <span class="keyword">this</span>.systemClock.now() - beginLockTimestamp;</span><br><span class="line">               <span class="keyword">if</span> (costTime &gt; <span class="number">5</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">                   log.info(<span class="string">"[NOTIFYME] check hold request cost &#123;&#125; ms."</span>, costTime);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">               log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       log.info(<span class="string">"&#123;&#125; service end"</span>, <span class="keyword">this</span>.getServiceName());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkHoldRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (String key : <span class="keyword">this</span>.pullRequestTable.keySet()) &#123;</span><br><span class="line">           String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR);</span><br><span class="line">           <span class="keyword">if</span> (<span class="number">2</span> == kArray.length) &#123;</span><br><span class="line">               String topic = kArray[<span class="number">0</span>];</span><br><span class="line">               <span class="keyword">int</span> queueId = Integer.parseInt(kArray[<span class="number">1</span>]);</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">long</span> offset = <span class="keyword">this</span>.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 通知消息到达，这个时候可能有，也可能没有</span></span><br><span class="line">                   <span class="keyword">this</span>.notifyMessageArriving(topic, queueId, offset);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                   log.error(<span class="string">"check hold request failed. topic=&#123;&#125;, queueId=&#123;&#125;"</span>, topic, queueId, e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyMessageArriving</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> <span class="keyword">long</span> maxOffset, <span class="keyword">final</span> Long tagsCode,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">long</span> msgStoreTime, <span class="keyword">byte</span>[] filterBitMap, Map&lt;String, String&gt; properties)</span> </span>&#123;</span><br><span class="line">       String key = <span class="keyword">this</span>.buildKey(topic, queueId);</span><br><span class="line">       <span class="comment">// 拿到topic+queueId对应的所有PullRequest</span></span><br><span class="line">       ManyPullRequest mpr = <span class="keyword">this</span>.pullRequestTable.get(key);</span><br><span class="line">       <span class="keyword">if</span> (mpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// clone等待的List，同时会清空等待列表</span></span><br><span class="line">           List&lt;PullRequest&gt; requestList = mpr.cloneListAndClear();</span><br><span class="line">           <span class="keyword">if</span> (requestList != <span class="keyword">null</span>) &#123;</span><br><span class="line">               List&lt;PullRequest&gt; replayList = <span class="keyword">new</span> ArrayList&lt;PullRequest&gt;();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span> (PullRequest request : requestList) &#123;</span><br><span class="line">                   <span class="comment">// 判断等待的时间内有没有新的消息进来</span></span><br><span class="line">                   <span class="keyword">long</span> newestOffset = maxOffset;</span><br><span class="line">                   <span class="keyword">if</span> (newestOffset &lt;= request.getPullFromThisOffset()) &#123;</span><br><span class="line">                       newestOffset = <span class="keyword">this</span>.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 有消息到来</span></span><br><span class="line">                   <span class="keyword">if</span> (newestOffset &gt; request.getPullFromThisOffset()) &#123;</span><br><span class="line">                       <span class="comment">// 判断消息是否符合过滤条件</span></span><br><span class="line">                       <span class="keyword">boolean</span> match = request.getMessageFilter().isMatchedByConsumeQueue(tagsCode,</span><br><span class="line">                           <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit(tagsCode, msgStoreTime, filterBitMap));</span><br><span class="line">                       <span class="comment">// match by bit map, need eval again when properties is not null.</span></span><br><span class="line">                       <span class="keyword">if</span> (match &amp;&amp; properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           match = request.getMessageFilter().isMatchedByCommitLog(<span class="keyword">null</span>, properties);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 匹配到消息，重新通过PullRequestProcessor执行消息读取</span></span><br><span class="line">                       <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">                                   request.getRequestCommand());</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                               log.error(<span class="string">"execute request when wakeup failed."</span>, e);</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 如果requst等待超时，无论前一步是否符合条件，肯定会发给processor处理</span></span><br><span class="line">                   <span class="keyword">if</span> (System.currentTimeMillis() &gt;= (request.getSuspendTimestamp() + request.getTimeoutMillis())) &#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">                               request.getRequestCommand());</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                           log.error(<span class="string">"execute request when wakeup failed."</span>, e);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 未超时和没有匹配到消息的request，重新放入队列等待</span></span><br><span class="line">                   replayList.add(request);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!replayList.isEmpty()) &#123;</span><br><span class="line">                   mpr.addPullRequest(replayList);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="comment">// org.apache.rocketmq.broker.processor.PullMessageProcessor</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeRequestWhenWakeup</span><span class="params">(<span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">     	<span class="comment">// 封装成一个任务</span></span><br><span class="line">       Runnable run = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">final</span> RemotingCommand response = PullMessageProcessor.<span class="keyword">this</span>.processRequest(channel, request, <span class="keyword">false</span>);</span><br><span class="line">									<span class="comment">// 不为空就直接推给消费者</span></span><br><span class="line">                   <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       response.setOpaque(request.getOpaque());</span><br><span class="line">                       response.markResponseType();</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           channel.writeAndFlush(response).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                               <span class="meta">@Override</span></span><br><span class="line">                               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                   <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                                       log.error(<span class="string">"processRequestWrapper response to &#123;&#125; failed"</span>,</span><br><span class="line">                                           future.channel().remoteAddress(), future.cause());</span><br><span class="line">                                       log.error(request.toString());</span><br><span class="line">                                       log.error(response.toString());</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;);</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                           log.error(<span class="string">"processRequestWrapper process request over, but response failed"</span>, e);</span><br><span class="line">                           log.error(request.toString());</span><br><span class="line">                           log.error(response.toString());</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (RemotingCommandException e1) &#123;</span><br><span class="line">                   log.error(<span class="string">"excuteRequestWhenWakeup run"</span>, e1);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="keyword">this</span>.brokerController.getPullMessageExecutor().submit(<span class="keyword">new</span> RequestTask(run, channel, request));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在回想一下<code>PullRequestHoldService#notifyMessageArriving()</code>方法，我们是否似曾相识，对了，就是在<code>org.apache.rocketmq.store.DefaultMessageStore.ReputMessageService#doReput()</code>方法时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getBrokerRole()</span><br><span class="line">                                        &amp;&amp; DefaultMessageStore.<span class="keyword">this</span>.brokerConfig.isLongPollingEnable()) &#123;</span><br><span class="line">	<span class="comment">// 唤醒等待的PullReqeust接收消息                              </span></span><br><span class="line">  DefaultMessageStore.<span class="keyword">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</span><br><span class="line">                                              dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class="number">1</span>,</span><br><span class="line">                                              dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),</span><br><span class="line">                                              dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK！到这里，Broker就已经完成了PullMessage的接收啦！！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/f63c7836feb0" target="_blank" rel="noopener">RocketMQ源码解析(十一)-Broker#消息消费</a></li>
<li><a href="https://www.kunzhao.org/blog/2018/04/02/rocketmq-message-filter-flow/" target="_blank" rel="noopener">RocketMQ 消息过滤流程</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前面讲到了Broker对于不同的消息有自己不同的Processor，对于&lt;code&gt;PushConsumer&lt;/code&gt;的Pull请求的时候，它对应的就是&lt;code&gt;PullMessageProcessor&lt;/code&gt;~
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——Broker接收发送消息</title>
    <link href="http://bestlixiang.site/2019/06/26/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Broke%E6%8E%A5%E6%94%B6%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF/"/>
    <id>http://bestlixiang.site/2019/06/26/RocketMQ源码/RocketMQ源码分析——Broke接收发送消息/</id>
    <published>2019-06-25T23:30:53.000Z</published>
    <updated>2019-06-25T23:59:31.271Z</updated>
    
    <content type="html"><![CDATA[<p>引：前面我们说过了Producer和Consumer是如何发送消息的，当我们了解完Broker的消息存储之后，我们就可以看看Broker是如何接收发来的消息啦~<a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在分析完Producer和Consumer之后，我们知道无论是消费者还是生产者来说，Broker都是接受消息的一方，同时我们知道RocketMQ是通过Netty实现通信的，对应接收消息，我们很容易就会想到一定是一个ChannelHandler在处理，而在RocketMQ的设计中对应是<code>NettyRequestProcessor</code>，所以我们就可以分析一下接收消息的几种类型啦，有几种消息类型，就有几种Processor，如下图：<br><img src="https://upload-images.jianshu.io/upload_images/10354196-8900cd8452e3e0a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="broker-processor.png"></p>
<p>我们看到有很多种消息类型，我们这次只分析<code>SendMessage</code>。</p>
<h1 id="SendMessage"><a href="#SendMessage" class="headerlink" title="SendMessage"></a>SendMessage</h1><p>对于SendMessage有下面这几种可能：单条消息、批量消息、RETRY消息。Retry消息即consumer消费失败，要求broker重发的消息。失败的原因有两种，一种是业务端代码处理失败；还有一种是消息在consumer的缓存队列中待的时间超时，consumer会将消息从队列中移除，然后退回给Broker重发。</p>
<h1 id="SendMessageProcessor"><a href="#SendMessageProcessor" class="headerlink" title="SendMessageProcessor"></a>SendMessageProcessor</h1><p>我们肯定会找到<code>org.apache.rocketmq.broker.processor.SendMessageProcessor#processRequest()</code>这个方法，因为它实现自<code>NettyRequestProcessor</code>接口的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    SendMessageContext mqtraceContext;</span><br><span class="line">    <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line">            <span class="comment">// RETRY消息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.consumerSendMsgBack(ctx, request);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            SendMessageRequestHeader requestHeader = parseRequestHeader(request);</span><br><span class="line">            <span class="keyword">if</span> (requestHeader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mqtraceContext = buildMsgContext(ctx, requestHeader);</span><br><span class="line">            <span class="keyword">this</span>.executeSendMessageHookBefore(ctx, request, mqtraceContext);</span><br><span class="line"></span><br><span class="line">            RemotingCommand response;</span><br><span class="line">            <span class="keyword">if</span> (requestHeader.isBatch()) &#123;</span><br><span class="line">                <span class="comment">// 批量发送</span></span><br><span class="line">                response = <span class="keyword">this</span>.sendBatchMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 单条消息</span></span><br><span class="line">                response = <span class="keyword">this</span>.sendMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.executeSendMessageHookAfter(response, mqtraceContext);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Consumer的RETRY消息"><a href="#Consumer的RETRY消息" class="headerlink" title="Consumer的RETRY消息"></a>Consumer的RETRY消息</h1><p>对于Consumer的RETRY消息，我们可以找到<code>org.apache.rocketmq.broker.processor.SendMessageProcessor#consumerSendMsgBack()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">consumerSendMsgBack</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> RemotingCommand request)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">final</span> ConsumerSendMsgBackRequestHeader requestHeader =</span><br><span class="line">           (ConsumerSendMsgBackRequestHeader)request.decodeCommandCustomHeader(ConsumerSendMsgBackRequestHeader.class);</span><br><span class="line"></span><br><span class="line"> 			<span class="comment">// ...</span></span><br><span class="line">			<span class="comment">// consumer group是否存在</span></span><br><span class="line">       SubscriptionGroupConfig subscriptionGroupConfig =</span><br><span class="line">           <span class="keyword">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getGroup());</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionGroupConfig) &#123;</span><br><span class="line">           response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</span><br><span class="line">           response.setRemark(<span class="string">"subscription group not exist, "</span> + requestHeader.getGroup() + <span class="string">" "</span></span><br><span class="line">               + FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST));</span><br><span class="line">           <span class="keyword">return</span> response;</span><br><span class="line">       &#125;</span><br><span class="line">			<span class="comment">// ... </span></span><br><span class="line">       <span class="comment">// 获得重试队列Topic和queue</span></span><br><span class="line">       String newTopic = MixAll.getRetryTopic(requestHeader.getGroup());</span><br><span class="line">       <span class="keyword">int</span> queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % subscriptionGroupConfig.getRetryQueueNums();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> topicSysFlag = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (requestHeader.isUnitMode()) &#123;</span><br><span class="line">           topicSysFlag = TopicSysFlag.buildSysFlag(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(</span><br><span class="line">           newTopic,</span><br><span class="line">           subscriptionGroupConfig.getRetryQueueNums(),</span><br><span class="line">     	<span class="comment">// ...</span></span><br><span class="line">			<span class="comment">// 根据offset找到MessageExt</span></span><br><span class="line">       MessageExt msgExt = <span class="keyword">this</span>.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getOffset());</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == msgExt) &#123;</span><br><span class="line">           response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">           response.setRemark(<span class="string">"look message by offset failed, "</span> + requestHeader.getOffset());</span><br><span class="line">           <span class="keyword">return</span> response;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> String retryTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == retryTopic) &#123;</span><br><span class="line">           MessageAccessor.putProperty(msgExt, MessageConst.PROPERTY_RETRY_TOPIC, msgExt.getTopic());</span><br><span class="line">       &#125;</span><br><span class="line">       msgExt.setWaitStoreMsgOK(<span class="keyword">false</span>);</span><br><span class="line">			<span class="comment">// 查看延迟等级</span></span><br><span class="line">       <span class="comment">//  messageDelayLevel = "1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h"</span></span><br><span class="line">       <span class="keyword">int</span> delayLevel = requestHeader.getDelayLevel();</span><br><span class="line">			<span class="comment">// 最大重复次数16次</span></span><br><span class="line">       <span class="keyword">int</span> maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();</span><br><span class="line">       <span class="keyword">if</span> (request.getVersion() &gt;= MQVersion.Version.V3_4_9.ordinal()) &#123;</span><br><span class="line">           maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果大于重试次数，则放入DLQ死信队列</span></span><br><span class="line">       <span class="keyword">if</span> (msgExt.getReconsumeTimes() &gt;= maxReconsumeTimes</span><br><span class="line">           || delayLevel &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         	<span class="comment">// 将topic和queueid设置为死信队列的</span></span><br><span class="line">           newTopic = MixAll.getDLQTopic(requestHeader.getGroup());</span><br><span class="line">           queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % DLQ_NUMS_PER_GROUP;</span><br><span class="line"></span><br><span class="line">           topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic,</span><br><span class="line">               DLQ_NUMS_PER_GROUP,</span><br><span class="line">               PermName.PERM_WRITE, <span class="number">0</span></span><br><span class="line">           );</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">               response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">               response.setRemark(<span class="string">"topic["</span> + newTopic + <span class="string">"] not exist"</span>);</span><br><span class="line">               <span class="keyword">return</span> response;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     			<span class="comment">// 加三个等级的延迟</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="number">0</span> == delayLevel) &#123;</span><br><span class="line">               delayLevel = <span class="number">3</span> + msgExt.getReconsumeTimes();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           msgExt.setDelayTimeLevel(delayLevel);</span><br><span class="line">       &#125;</span><br><span class="line">			<span class="comment">// 将msgExt转化为MessageExtBrokerInner</span></span><br><span class="line">       MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">       msgInner.setTopic(newTopic);</span><br><span class="line">       msgInner.setBody(msgExt.getBody());</span><br><span class="line">       msgInner.setFlag(msgExt.getFlag());</span><br><span class="line">       MessageAccessor.setProperties(msgInner, msgExt.getProperties());</span><br><span class="line">       msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));</span><br><span class="line">       msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(<span class="keyword">null</span>, msgExt.getTags()));</span><br><span class="line"></span><br><span class="line">       msgInner.setQueueId(queueIdInt);</span><br><span class="line">       msgInner.setSysFlag(msgExt.getSysFlag());</span><br><span class="line">       msgInner.setBornTimestamp(msgExt.getBornTimestamp());</span><br><span class="line">       msgInner.setBornHost(msgExt.getBornHost());</span><br><span class="line">       msgInner.setStoreHost(<span class="keyword">this</span>.getStoreHost());</span><br><span class="line">       msgInner.setReconsumeTimes(msgExt.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       String originMsgId = MessageAccessor.getOriginMessageId(msgExt);</span><br><span class="line">       MessageAccessor.setOriginMessageId(msgInner, UtilAll.isBlank(originMsgId) ? msgExt.getMsgId() : originMsgId);</span><br><span class="line">       <span class="comment">// 存储消息</span></span><br><span class="line">       PutMessageResult putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line">       <span class="keyword">if</span> (putMessageResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">switch</span> (putMessageResult.getPutMessageStatus()) &#123;</span><br><span class="line">               <span class="keyword">case</span> PUT_OK:</span><br><span class="line">                   String backTopic = msgExt.getTopic();</span><br><span class="line">                   String correctTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line">                   <span class="keyword">if</span> (correctTopic != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       backTopic = correctTopic;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incSendBackNums(requestHeader.getGroup(), backTopic);</span><br><span class="line"></span><br><span class="line">                   response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">                   response.setRemark(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">return</span> response;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">           response.setRemark(putMessageResult.getPutMessageStatus().name());</span><br><span class="line">           <span class="keyword">return</span> response;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">       response.setRemark(<span class="string">"putMessageResult is null"</span>);</span><br><span class="line">       <span class="keyword">return</span> response;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Producer的单条消息"><a href="#Producer的单条消息" class="headerlink" title="Producer的单条消息"></a>Producer的单条消息</h1><p>对于Producer的单条消息，我们可以找到<code>org.apache.rocketmq.broker.processor.SendMessageProcessor#sendMessage()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> RemotingCommand request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> SendMessageContext sendMessageContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> SendMessageRequestHeader requestHeader)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(SendMessageResponseHeader.class);</span><br><span class="line">    <span class="keyword">final</span> SendMessageResponseHeader responseHeader = (SendMessageResponseHeader)response.readCustomHeader();</span><br><span class="line"></span><br><span class="line">    response.setOpaque(request.getOpaque());</span><br><span class="line"></span><br><span class="line">    response.addExtField(MessageConst.PROPERTY_MSG_REGION, <span class="keyword">this</span>.brokerController.getBrokerConfig().getRegionId());</span><br><span class="line">    response.addExtField(MessageConst.PROPERTY_TRACE_SWITCH, String.valueOf(<span class="keyword">this</span>.brokerController.getBrokerConfig().isTraceOn()));</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">"receive SendMessage request command, &#123;&#125;"</span>, request);</span><br><span class="line">    <span class="comment">// 判断当前时间broker是否提供服务，不提供则返回code为SYSTEM_ERROR的response</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTimstamp = <span class="keyword">this</span>.brokerController.getBrokerConfig().getStartAcceptSendRequestTimeStamp();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getMessageStore().now() &lt; startTimstamp) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(String.format(<span class="string">"broker unable to service, until %s"</span>, UtilAll.timeMillisToHumanString2(startTimstamp)));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.setCode(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 检查topic和queue，如果不存在且broker设置中允许自动创建，则自动创建</span></span><br><span class="line">    <span class="keyword">super</span>.msgCheck(ctx, requestHeader, response);</span><br><span class="line">    <span class="keyword">if</span> (response.getCode() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] body = request.getBody();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> queueIdInt = requestHeader.getQueueId();</span><br><span class="line">    <span class="comment">// 获取topic的配置</span></span><br><span class="line">    TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line">    <span class="comment">// 如果消息中的queueId小于0，则随机选取一个queue</span></span><br><span class="line">    <span class="keyword">if</span> (queueIdInt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % topicConfig.getWriteQueueNums();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新封装request中的message成MessageExtBrokerInner</span></span><br><span class="line">    MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">    msgInner.setTopic(requestHeader.getTopic());</span><br><span class="line">    msgInner.setQueueId(queueIdInt);</span><br><span class="line">    <span class="comment">// 对于RETRY消息的一些处理</span></span><br><span class="line">    <span class="keyword">if</span> (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转化消息为MessageExtBrokerInner</span></span><br><span class="line">    msgInner.setBody(body);</span><br><span class="line">    msgInner.setFlag(requestHeader.getFlag());</span><br><span class="line">    MessageAccessor.setProperties(msgInner, MessageDecoder.string2messageProperties(requestHeader.getProperties()));</span><br><span class="line">    msgInner.setPropertiesString(requestHeader.getProperties());</span><br><span class="line">    msgInner.setBornTimestamp(requestHeader.getBornTimestamp());</span><br><span class="line">    msgInner.setBornHost(ctx.channel().remoteAddress());</span><br><span class="line">    msgInner.setStoreHost(<span class="keyword">this</span>.getStoreHost());</span><br><span class="line">    msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == <span class="keyword">null</span> ? <span class="number">0</span> : requestHeader.getReconsumeTimes());</span><br><span class="line">    PutMessageResult putMessageResult = <span class="keyword">null</span>;</span><br><span class="line">    Map&lt;String, String&gt; oriProps = MessageDecoder.string2messageProperties(requestHeader.getProperties());</span><br><span class="line">    String traFlag = oriProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">    <span class="keyword">if</span> (traFlag != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(traFlag)) &#123;</span><br><span class="line">        <span class="comment">// 是否拒绝事务消息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(</span><br><span class="line">                <span class="string">"the broker["</span> + <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1()</span><br><span class="line">                    + <span class="string">"] sending transaction message is forbidden"</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        putMessageResult = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().prepareMessage(msgInner);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用MessageStore接口存储消息，这里就到我们之前分析的消息存储哪里了</span></span><br><span class="line">        putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据存储结果设置repsonse状态，更新broker统计信息，成功则回复producer，更新context上下文</span></span><br><span class="line">    <span class="keyword">return</span> handlePutMessageResult(putMessageResult, response, request, msgInner, responseHeader, sendMessageContext, ctx, queueIdInt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>其实我有个问题就是对于Producer的单条信息，为了要判断重试次数？？ 问题先放在这，等以后知道了，再来回答！！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="https://www.jianshu.com/p/0b4b1147366f" target="_blank" rel="noopener">RocketMQ源码解析(八)-Broker#消息发送</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/925a628f3f80" target="_blank" rel="noopener">RocketMQ消费失败消息深入分析（consumer,broker的具体处理逻辑）</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前面我们说过了Producer和Consumer是如何发送消息的，当我们了解完Broker的消息存储之后，我们就可以看看Broker是如何接收发来的消息啦~
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——Broker消息存储</title>
    <link href="http://bestlixiang.site/2019/06/22/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Broker%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/"/>
    <id>http://bestlixiang.site/2019/06/22/RocketMQ源码/RocketMQ源码分析——Broker消息存储/</id>
    <published>2019-06-22T06:23:01.000Z</published>
    <updated>2019-06-22T06:23:48.546Z</updated>
    
    <content type="html"><![CDATA[<p>引：消息存储对于一个消息队列来说是肯定要有的，在RocketMQ中，Broker将消息存储抽象成<code>MessageStore</code>接口，我们也将从这里入手~ <a id="more"></a></p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>美图：</p>
<p><img src="https://img-blog.csdn.net/20180322173040972?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjc1Mjk5MTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="MessageStore"></p>
<p>从上面我们可以看到几个核心的数据结构：</p>
<ul>
<li><strong>CommitLog</strong>：存储消息的数据结构，类似一个消息数组，按照消息收到的顺序，所有消息都存储在一起。每个消息存储后都会生成一个对应的offset，代表在commitLog中的字节偏移量。注意：CommitLog并不是一个文件，而是一系列文件（上图中的MappedFile）。每个MappedFile文件的大小都是固定的（默认1G），写满一个会生成一个新的文件，新文件的文件名就是它存储的第一条消息的offset。</li>
<li><strong>ConsumeQueue</strong>：之前说了所有消息都是存储在一个commitLog中的，但是consumer是按照topic+queue的维度来消费消息的，没有办法直接从commitLog中读取，所以针对每个topic的每个queue都会生成consumeQueue，ConsumeQueue中存储的是消息在commitLog中的offset，可以理解成一个按topic+queue建的索引，每条消息占用20字节（上图中的一个cq）。跟commitLog一样，每个Queue文件也是一系列连续的文件组成，每个文件默认放30w个offset索引。</li>
<li><strong>IndexFile</strong>：CommitLog的另外一种形式的索引文件，只是索引的是messageKey，每个MsgKey经过hash后计算存储的slot，然后将offset存到IndexFile的相应slot上。根据msgKey来查询消息时，可以先到IndexFile（slot+index类似一个hashmap）中查询offset，然后根据offset去commitLog中查询对应的消息。</li>
</ul>
<p>关于图中的过程我们后面会展开讲解~</p>
<h1 id="MessageStore启动"><a href="#MessageStore启动" class="headerlink" title="MessageStore启动"></a>MessageStore启动</h1><p>之前，我们在BrokerController的启动中看到了MessageStore启动，所以我们也从那里开始看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.store.DefaultMessageStore</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 构造文件锁，保证磁盘上的文件只会被一个messageStore读写</span></span><br><span class="line">      lock = lockFile.getChannel().tryLock(<span class="number">0</span>, <span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (lock == <span class="keyword">null</span> || lock.isShared() || !lock.isValid()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Lock failed,MQ already started"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      lockFile.getChannel().write(ByteBuffer.wrap(<span class="string">"lock"</span>.getBytes()));</span><br><span class="line">      lockFile.getChannel().force(<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">// 启动FlushConsumeQueueService(继承ServiceThread，是个单线程)</span></span><br><span class="line">      <span class="comment">// 定时将consumeQueue文件的数据刷新到磁盘，周期由参数flushIntervalConsumeQueue设置，默认1秒</span></span><br><span class="line">      <span class="keyword">this</span>.flushConsumeQueueService.start();</span><br><span class="line">      <span class="comment">// 启动CommitLog，对应了flushCommitLogService服务</span></span><br><span class="line">    	<span class="comment">// flushCommitLogService服务负责将CommitLog的数据flush到磁盘，有同步刷盘和异步刷盘两种方式</span></span><br><span class="line">      <span class="keyword">this</span>.commitLog.start();</span><br><span class="line">      <span class="comment">// 消息存储指标统计服务，RT，TPS等指标，admin可以用</span></span><br><span class="line">      <span class="keyword">this</span>.storeStatsService.start();</span><br><span class="line">      <span class="comment">// 针对master，启动延时消息调度服务，真的消费失败的情况</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.scheduleMessageService != <span class="keyword">null</span> &amp;&amp; SLAVE != messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.scheduleMessageService.start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 启动ReputMessageService，该服务负责将CommitLog中的消息offset记录到cosumeQueue文件中</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageStoreConfig().isDuplicationEnable()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.reputMessageService.setReputFromOffset(<span class="keyword">this</span>.commitLog.getConfirmOffset());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.reputMessageService.setReputFromOffset(<span class="keyword">this</span>.commitLog.getMaxOffset());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.reputMessageService.start();</span><br><span class="line">      <span class="comment">// 启动HAService，数据主从同步的服务</span></span><br><span class="line">      <span class="keyword">this</span>.haService.start();</span><br><span class="line">      <span class="comment">// 对于新的broker，初始化文件存储的目录</span></span><br><span class="line">      <span class="keyword">this</span>.createTempFile();</span><br><span class="line">      <span class="comment">// 启动定时任务</span></span><br><span class="line">      <span class="keyword">this</span>.addScheduleTask();</span><br><span class="line">      <span class="keyword">this</span>.shutdown = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后看看它起了哪些定时任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addScheduleTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定时清理过期的commitLog、cosumeQueue数据文件</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DefaultMessageStore.<span class="keyword">this</span>.cleanFilesPeriodically();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">60</span>, <span class="keyword">this</span>.messageStoreConfig.getCleanResourceInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="comment">// 定时自检commitLog和consumerQueue文件，校验文件是否完整。主要用于监控，不会做修复文件的动作</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DefaultMessageStore.<span class="keyword">this</span>.checkSelf();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">// 定时检查commitLog的Lock时长(因为在write或者flush时侯会lock)</span></span><br><span class="line">    <span class="comment">// 如果lock的时间过长，则打印jvm堆栈，用于监控。</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().isDebugLockEnable()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.commitLog.getBeginTimeInLock() != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">long</span> lockTime = System.currentTimeMillis() - DefaultMessageStore.<span class="keyword">this</span>.commitLog.getBeginTimeInLock();</span><br><span class="line">                        <span class="keyword">if</span> (lockTime &gt; <span class="number">1000</span> &amp;&amp; lockTime &lt; <span class="number">10000000</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            String stack = UtilAll.jstack();</span><br><span class="line">                            <span class="keyword">final</span> String fileName = System.getProperty(<span class="string">"user.home"</span>) + File.separator + <span class="string">"debug/lock/stack-"</span></span><br><span class="line">                                + DefaultMessageStore.<span class="keyword">this</span>.commitLog.getBeginTimeInLock() + <span class="string">"-"</span> + lockTime;</span><br><span class="line">                            MixAll.string2FileNotSafe(stack, fileName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="CommitLog"><a href="#CommitLog" class="headerlink" title="CommitLog"></a>CommitLog</h1><p>我们知道当Broker接收到消息会进行存储，首先存储的就是CommitLog，所以我们可以找到<code>org.apache.rocketmq.store.CommitLog#putMessage()</code>方法，这里可能有多条消息一起存储，我们这里主要说一下单条消息存储：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置存储时间戳</span></span><br><span class="line">    msg.setStoreTimestamp(System.currentTimeMillis());</span><br><span class="line">    <span class="comment">// 忽略加密</span></span><br><span class="line">    msg.setBodyCRC(UtilAll.crc32(msg.getBody()));</span><br><span class="line">    <span class="comment">// 构造返回结果</span></span><br><span class="line">    AppendMessageResult result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 拿到统计状态服务，后面会设置一些值</span></span><br><span class="line">    StoreStatsService storeStatsService = <span class="keyword">this</span>.defaultMessageStore.getStoreStatsService();</span><br><span class="line">    <span class="comment">// 拿到Topic和queue信息</span></span><br><span class="line">    String topic = msg.getTopic();</span><br><span class="line">    <span class="keyword">int</span> queueId = msg.getQueueId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">    <span class="comment">// 非事务消息</span></span><br><span class="line">    <span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE</span><br><span class="line">        || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">        <span class="comment">// Delay Delivery</span></span><br><span class="line">        <span class="comment">// 延时投放消息，变更topic为SCHEDULE_TOPIC_XXXX以及队列</span></span><br><span class="line">      	<span class="comment">// 被重发的Schedule任务读到</span></span><br><span class="line">        <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">                msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">            queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 备份之前的topic和queueId</span></span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">            msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">            msg.setTopic(topic);</span><br><span class="line">            msg.setQueueId(queueId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> eclipseTimeInLock = <span class="number">0</span>;</span><br><span class="line">    MappedFile unlockMappedFile = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取当前正在写入文件</span></span><br><span class="line">    MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile();</span><br><span class="line">    <span class="comment">// 获取写message的锁，可以是自旋锁或者可重入锁，看配置</span></span><br><span class="line">    putMessageLock.lock(); <span class="comment">//spin or ReentrantLock ,depending on store config</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> beginLockTimestamp = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now();</span><br><span class="line">        <span class="keyword">this</span>.beginTimeInLock = beginLockTimestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here settings are stored timestamp, in order to ensure an orderly</span></span><br><span class="line">        <span class="comment">// global</span></span><br><span class="line">        msg.setStoreTimestamp(beginLockTimestamp);</span><br><span class="line">        <span class="comment">// 如果文件不存在或者文件已经写满，新建一个mappedfile</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line">            mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>); <span class="comment">// Mark: NewFile may be cause noise</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 文件创建失败，则返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">            log.error(<span class="string">"create mapped file1 error, topic: "</span> + msg.getTopic() + <span class="string">" clientAddr: "</span> + msg.getBornHostString());</span><br><span class="line">            beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 消息写入文件，有一个回调，待会说</span></span><br><span class="line">        result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">        <span class="keyword">switch</span> (result.getStatus()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PUT_OK:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果文件已满，则新建一个文件继续</span></span><br><span class="line">            <span class="keyword">case</span> END_OF_FILE:</span><br><span class="line">                unlockMappedFile = mappedFile;</span><br><span class="line">                <span class="comment">// Create a new file, re-write the message</span></span><br><span class="line">                mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                    log.error(<span class="string">"create mapped file2 error, topic: "</span> + msg.getTopic() + <span class="string">" clientAddr: "</span> + msg.getBornHostString());</span><br><span class="line">                    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result);</span><br><span class="line">                &#125;</span><br><span class="line">                result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_SIZE_EXCEEDED:</span><br><span class="line">            <span class="keyword">case</span> PROPERTIES_SIZE_EXCEEDED:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);</span><br><span class="line">            <span class="keyword">case</span> UNKNOWN_ERROR:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eclipseTimeInLock = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</span><br><span class="line">        beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放获取到的锁</span></span><br><span class="line">        putMessageLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写消息时间过长, 警告</span></span><br><span class="line">    <span class="keyword">if</span> (eclipseTimeInLock &gt; <span class="number">500</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">"[NOTIFYME]putMessage in lock cost time(ms)=&#123;&#125;, bodyLength=&#123;&#125; AppendMessageResult=&#123;&#125;"</span>, eclipseTimeInLock, msg.getBody().length, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// unlock已经写满的文件，释放内存锁（系统锁）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != unlockMappedFile &amp;&amp; <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMessageStore.unlockMappedFile(unlockMappedFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PutMessageResult putMessageResult = <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PUT_OK, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些统计信息</span></span><br><span class="line">    storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).incrementAndGet();</span><br><span class="line">    storeStatsService.getSinglePutMessageTopicSizeTotal(topic).addAndGet(result.getWroteBytes());</span><br><span class="line">    <span class="comment">// flush数据到磁盘，分同步和异步</span></span><br><span class="line">    handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line">    <span class="comment">// 如果是SYNC_MASTER，则Master保存消息后，需要将消息同步给slave后才会返回结果</span></span><br><span class="line">    <span class="comment">// 如果ASYNC_MASTER，这里不会做任何操作，由HAService的后台线程做数据同步</span></span><br><span class="line">    handleHA(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> putMessageResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在之前的数据结构图中以及上面的代码中都看到了CommitLog是存储在MappedFile中，下面我们就看看写入消息到MappedFile的实现，对应了<code>org.apache.rocketmq.store.MappedFile#appendMessage()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">appendMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg, <span class="keyword">final</span> AppendMessageCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> appendMessagesInner(msg, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">appendMessagesInner</span><span class="params">(<span class="keyword">final</span> MessageExt messageExt, <span class="keyword">final</span> AppendMessageCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> messageExt != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">assert</span> cb != <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取当前的write position，用了原子计数器AtomicInteger</span></span><br><span class="line">    <span class="keyword">int</span> currentPos = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentPos &lt; <span class="keyword">this</span>.fileSize) &#123;</span><br><span class="line">        <span class="comment">// 获得NIO的BytBuffer，从writeBuffer或者mappedByteBuffer，这里就利用了零拷贝</span></span><br><span class="line">        <span class="comment">// 如果是writeBuffer，属于异步</span></span><br><span class="line">        <span class="comment">// CommitLog启动的时候初始化一块内存池(通过ByteBuffer申请的堆外内存)</span></span><br><span class="line">        <span class="comment">// 消息数据首先写入内存池中，然后后台有个线程定时将内存池中的数据commit到FileChannel中</span></span><br><span class="line">        <span class="comment">// 如果是mappedByteBuffer，属于同步</span></span><br><span class="line">        <span class="comment">// 在写入文件时，从FileChannel获取直接内存映射，收到消息后，将数据写入到这块内存中，内存和物理文件的数据交互由操作系统负责</span></span><br><span class="line">        ByteBuffer byteBuffer = writeBuffer != <span class="keyword">null</span> ? writeBuffer.slice() : <span class="keyword">this</span>.mappedByteBuffer.slice();</span><br><span class="line">        byteBuffer.position(currentPos);</span><br><span class="line">        AppendMessageResult result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBrokerInner) &#123;</span><br><span class="line">            <span class="comment">// 写单条消息到byteBuffer</span></span><br><span class="line">            result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBrokerInner) messageExt);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBatch) &#123;</span><br><span class="line">            <span class="comment">// 批量消息到byteBuffer</span></span><br><span class="line">            result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBatch) messageExt);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新write position，到最新值</span></span><br><span class="line">        <span class="keyword">this</span>.wrotePosition.addAndGet(result.getWroteBytes());</span><br><span class="line">        <span class="keyword">this</span>.storeTimestamp = result.getStoreTimestamp();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    log.error(<span class="string">"MappedFile.appendMessage return null, wrotePosition: &#123;&#125; fileSize: &#123;&#125;"</span>, currentPos, <span class="keyword">this</span>.fileSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在写入到MappedZFile的函数中，我们看到有个回调函数，好像也不算回调🤣，我们调用了这个函数的<code>#doAppend()</code>方法，我们看看它做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">doAppend</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> fileFromOffset, <span class="keyword">final</span> ByteBuffer byteBuffer, <span class="keyword">final</span> <span class="keyword">int</span> maxBlank,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> MessageExtBrokerInner msgInner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// STORETIMESTAMP + STOREHOSTADDRESS + OFFSET &lt;br&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// PHY OFFSET 消息偏移 文件的名的offset + bytebuffer的位置就是要写的offset</span></span><br><span class="line">    <span class="keyword">long</span> wroteOffset = fileFromOffset + byteBuffer.position();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.resetByteBuffer(hostHolder, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// 生成message ID, 前8位是host，后8位是wroteOffset,目的是便于使用msgID来查找消息</span></span><br><span class="line">    String msgId = MessageDecoder.createMessageId(<span class="keyword">this</span>.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record ConsumeQueue information</span></span><br><span class="line">    keyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">    keyBuilder.append(msgInner.getTopic());</span><br><span class="line">    keyBuilder.append(<span class="string">'-'</span>);</span><br><span class="line">    keyBuilder.append(msgInner.getQueueId());</span><br><span class="line">    String key = keyBuilder.toString();</span><br><span class="line">    <span class="comment">// 取得具体Queue的offset，值是当前是Queue里的第几条消息</span></span><br><span class="line">    Long queueOffset = CommitLog.<span class="keyword">this</span>.topicQueueTable.get(key);</span><br><span class="line">    <span class="comment">// 如果是这个queue的第一条消息，需要初始化queueOffset</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == queueOffset) &#123;</span><br><span class="line">        queueOffset = <span class="number">0L</span>;</span><br><span class="line">        CommitLog.<span class="keyword">this</span>.topicQueueTable.put(key, queueOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务消息需要特别的处理，略过</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msgInner.getSysFlag());</span><br><span class="line">    <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">        <span class="comment">// Prepared and Rollback message is not consumed, will not enter the</span></span><br><span class="line">        <span class="comment">// consumer queuec</span></span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">            queueOffset = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化消息</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] propertiesData =</span><br><span class="line">        msgInner.getPropertiesString() == <span class="keyword">null</span> ? <span class="keyword">null</span> : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> propertiesLength = propertiesData == <span class="keyword">null</span> ? <span class="number">0</span> : propertiesData.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propertiesLength &gt; Short.MAX_VALUE) &#123;</span><br><span class="line">        log.warn(<span class="string">"putMessage message properties length too long. length=&#123;&#125;"</span>, propertiesData.length);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> topicLength = topicData.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bodyLength = msgInner.getBody() == <span class="keyword">null</span> ? <span class="number">0</span> : msgInner.getBody().length;</span><br><span class="line">    <span class="comment">// 计算机序列化消息的长度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> msgLen = calMsgLength(bodyLength, topicLength, propertiesLength);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exceeds the maximum message</span></span><br><span class="line">    <span class="keyword">if</span> (msgLen &gt; <span class="keyword">this</span>.maxMessageSize) &#123;</span><br><span class="line">        CommitLog.log.warn(<span class="string">"message size exceeded, msg total size: "</span> + msgLen + <span class="string">", msg body size: "</span> + bodyLength</span><br><span class="line">            + <span class="string">", maxMessageSize: "</span> + <span class="keyword">this</span>.maxMessageSize);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果空间不足，magic code设置成-626843481,然后剩余字节随机，保证所有文件大小都是FileSize</span></span><br><span class="line">    <span class="keyword">if</span> ((msgLen + END_FILE_MIN_BLANK_LENGTH) &gt; maxBlank) &#123;</span><br><span class="line">        <span class="keyword">this</span>.resetByteBuffer(<span class="keyword">this</span>.msgStoreItemMemory, maxBlank);</span><br><span class="line">        <span class="comment">// 1 TOTALSIZE</span></span><br><span class="line">        <span class="keyword">this</span>.msgStoreItemMemory.putInt(maxBlank);</span><br><span class="line">        <span class="comment">// 2 MAGICCODE</span></span><br><span class="line">        <span class="keyword">this</span>.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);</span><br><span class="line">        <span class="comment">// 3 The remaining space may be any value</span></span><br><span class="line">        <span class="comment">// Here the length of the specially set maxBlank</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</span><br><span class="line">        byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, maxBlank);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),</span><br><span class="line">            queueOffset, CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() - beginTimeMills);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看到这里，CommitLog就已经被存入到ByteBuf里啦，等待被flush到文件里！！！！</p>
<h1 id="ConsumeQueue"><a href="#ConsumeQueue" class="headerlink" title="ConsumeQueue"></a>ConsumeQueue</h1><p>上面我们看到消息被放到了CommitLog中，但是consumer在消费消息的时候是按照topic+queue的维度来拉取消息的。为了方便读取，<code>MessageStore</code>将<code>CommitLog</code>中消息的offset按照topic+queueId划分后，存储到不同的文件中，这就是<code>ConsumeQueue</code>。</p>
<p>在上面MessageStore启动的时候，我们看到他会启动一个服务<code>ReputMessageService</code>将CommitLog中的消息按照topic+queueId划分后，存储到不同的ConsumerQueue中，所以我们也从<code>org.apache.rocketmq.store.DefaultMessageStore.ReputMessageService</code>开始看，既然是一个线程，所以我们首先会找到他的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">this</span>.doReput();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                DefaultMessageStore.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 从上面可以看到主要在执行doReput方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断commitLog的maxOffset是否比上次读取的offset大，大就代表了有新的消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">boolean</span> doNext = <span class="keyword">true</span>; <span class="keyword">this</span>.isCommitLogAvailable() &amp;&amp; doNext; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().isDuplicationEnable()</span><br><span class="line">                &amp;&amp; <span class="keyword">this</span>.reputFromOffset &gt;= DefaultMessageStore.<span class="keyword">this</span>.getConfirmOffset()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从上次的结束offset开始读取commitLog文件中的消息</span></span><br><span class="line">            SelectMappedBufferResult result = DefaultMessageStore.<span class="keyword">this</span>.commitLog.getData(reputFromOffset);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.reputFromOffset = result.getStartOffset();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> readSize = <span class="number">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</span><br><span class="line">                        <span class="comment">// 检查message数据完整性并封装成DispatchRequest</span></span><br><span class="line">                        DispatchRequest dispatchRequest =</span><br><span class="line">                            DefaultMessageStore.<span class="keyword">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">int</span> size = dispatchRequest.getMsgSize();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (dispatchRequest.isSuccess()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">// 分发消息到CommitLogDispatcher</span></span><br><span class="line">                                DefaultMessageStore.<span class="keyword">this</span>.doDispatch(dispatchRequest);</span><br><span class="line">                                <span class="comment">// 当Broker为Master的时候，分发消息到MessageArrivingListener,唤醒等待的PullReqeust接收消息</span></span><br><span class="line">                                <span class="keyword">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getBrokerRole()</span><br><span class="line">                                    &amp;&amp; DefaultMessageStore.<span class="keyword">this</span>.brokerConfig.isLongPollingEnable()) &#123;</span><br><span class="line">                                    DefaultMessageStore.<span class="keyword">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</span><br><span class="line">                                        dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class="number">1</span>,</span><br><span class="line">                                        dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),</span><br><span class="line">                                        dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 更新最新reput的offset</span></span><br><span class="line">                                <span class="keyword">this</span>.reputFromOffset += size;</span><br><span class="line">                                readSize += size;</span><br><span class="line">                                <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE) &#123;</span><br><span class="line">                                    DefaultMessageStore.<span class="keyword">this</span>.storeStatsService</span><br><span class="line">                                        .getSinglePutMessageTopicTimesTotal(dispatchRequest.getTopic()).incrementAndGet();</span><br><span class="line">                                    DefaultMessageStore.<span class="keyword">this</span>.storeStatsService</span><br><span class="line">                                        .getSinglePutMessageTopicSizeTotal(dispatchRequest.getTopic())</span><br><span class="line">                                        .addAndGet(dispatchRequest.getMsgSize());</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">// 如果读到文件结尾，则切换到新文件</span></span><br><span class="line">                                <span class="keyword">this</span>.reputFromOffset = DefaultMessageStore.<span class="keyword">this</span>.commitLog.rollNextFile(<span class="keyword">this</span>.reputFromOffset);</span><br><span class="line">                                readSize = result.getSize();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dispatchRequest.isSuccess()) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                log.error(<span class="string">"[BUG]read total count not equals msg total size. reputFromOffset=&#123;&#125;"</span>, reputFromOffset);</span><br><span class="line">                                <span class="keyword">this</span>.reputFromOffset += size;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                doNext = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.brokerConfig.getBrokerId() == MixAll.MASTER_ID) &#123;</span><br><span class="line">                                    log.error(<span class="string">"[BUG]the master dispatch message to consume queue error, COMMITLOG OFFSET: &#123;&#125;"</span>,</span><br><span class="line">                                        <span class="keyword">this</span>.reputFromOffset);</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">this</span>.reputFromOffset += result.getSize() - readSize;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放bytebuff，避免内存泄漏</span></span><br><span class="line">                    result.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                doNext = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面我们看到了消息被分发到了CommitLogDispatcher，这个是啥？找到<code>DefaultMessageStore#doDispatch()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(DispatchRequest req)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (CommitLogDispatcher dispatcher : <span class="keyword">this</span>.dispatcherList) &#123;</span><br><span class="line">          dispatcher.dispatch(req);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;CommitLogDispatcher&gt; dispatcherList;</span><br></pre></td></tr></table></figure>
<p>从上面看到是DefaultMessageStore的集合成员变量，那么这个集合是什么时候生成的呢？</p>
<p>我们在构造DefaultMessageStore会往里面添加两个CommitLogDispatcher，我们定位到DefaultMessageStore的构造函数，省略无关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.dispatcherList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">// consumeQueue构建Dispatcher</span></span><br><span class="line"><span class="keyword">this</span>.dispatcherList.addLast(<span class="keyword">new</span> CommitLogDispatcherBuildConsumeQueue());</span><br><span class="line"><span class="comment">// IndexFile构建Dispatcher</span></span><br><span class="line"><span class="keyword">this</span>.dispatcherList.addLast(<span class="keyword">new</span> CommitLogDispatcherBuildIndex());</span><br></pre></td></tr></table></figure>
<p>不知道大家还有没有印象，其实在说<a href="[http://todorex.com/2019/06/19/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Broker%E5%90%AF%E5%8A%A8/](http://todorex.com/2019/06/19/RocketMQ源码/RocketMQ源码分析——Broker启动/">Broker初始化</a>)的时候也提到过。我们省略下无关代码，再看一遍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"> 		<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 消息存取的核心接口初始化</span></span><br><span class="line">            <span class="keyword">this</span>.messageStore =</span><br><span class="line">                <span class="keyword">new</span> DefaultMessageStore(<span class="keyword">this</span>.messageStoreConfig, <span class="keyword">this</span>.brokerStatsManager, <span class="keyword">this</span>.messageArrivingListener,</span><br><span class="line">                    <span class="keyword">this</span>.brokerConfig);</span><br><span class="line">            <span class="comment">// 添加消息分发器，分发到布隆过滤器</span></span><br><span class="line">            <span class="keyword">this</span>.messageStore.getDispatcherList().addFirst(<span class="keyword">new</span> CommitLogDispatcherCalcBitMap(<span class="keyword">this</span>.brokerConfig, <span class="keyword">this</span>.consumerFilterManager));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">            log.error(<span class="string">"Failed to initialize"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们只分析<code>org.apache.rocketmq.store.DefaultMessageStore.CommitLogDispatcherBuildConsumeQueue</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildConsumeQueue</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(request.getSysFlag());</span><br><span class="line">          <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">              <span class="comment">// 非事务消息</span></span><br><span class="line">              <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">              <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                  <span class="comment">// 放位置offset信息</span></span><br><span class="line">                  DefaultMessageStore.<span class="keyword">this</span>.putMessagePositionInfo(request);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">              <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putMessagePositionInfo</span><span class="params">(DispatchRequest dispatchRequest)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 找到对应的ConsumeQueue，没有就创建一个新的MappedFile文件</span></span><br><span class="line">      ConsumeQueue cq = <span class="keyword">this</span>.findConsumeQueue(dispatchRequest.getTopic(), dispatchRequest.getQueueId());</span><br><span class="line">      cq.putMessagePositionInfoWrapper(dispatchRequest);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.store.ConsumeQueue</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putMessagePositionInfoWrapper</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 写入重试次数，最多30次</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> maxRetries = <span class="number">30</span>;</span><br><span class="line">      <span class="comment">// 判断CQ是否是可写的</span></span><br><span class="line">      <span class="keyword">boolean</span> canWrite = <span class="keyword">this</span>.defaultMessageStore.getRunningFlags().isCQWriteable();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxRetries &amp;&amp; canWrite; i++) &#123;</span><br><span class="line">          <span class="comment">// 拿到消息的Tag</span></span><br><span class="line">          <span class="keyword">long</span> tagsCode = request.getTagsCode();</span><br><span class="line">          <span class="keyword">if</span> (isExtWriteEnable()) &#123;</span><br><span class="line">              <span class="comment">// 如果需要写ext文件，则将消息的tagsCode写入，用于消息过滤，后面有机会再说</span></span><br><span class="line">              ConsumeQueueExt.CqExtUnit cqExtUnit = <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit();</span><br><span class="line">              cqExtUnit.setFilterBitMap(request.getBitMap());</span><br><span class="line">              cqExtUnit.setMsgStoreTime(request.getStoreTimestamp());</span><br><span class="line">              cqExtUnit.setTagsCode(request.getTagsCode());</span><br><span class="line"></span><br><span class="line">              <span class="keyword">long</span> extAddr = <span class="keyword">this</span>.consumeQueueExt.put(cqExtUnit);</span><br><span class="line">              <span class="keyword">if</span> (isExtAddr(extAddr)) &#123;</span><br><span class="line">                  tagsCode = extAddr;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  log.warn(<span class="string">"Save consume queue extend fail, So just save tagsCode! &#123;&#125;, topic:&#123;&#125;, queueId:&#123;&#125;, offset:&#123;&#125;"</span>, cqExtUnit,</span><br><span class="line">                      topic, queueId, request.getCommitLogOffset());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 写入CQ文件</span></span><br><span class="line">          <span class="keyword">boolean</span> result = <span class="keyword">this</span>.putMessagePositionInfo(request.getCommitLogOffset(),</span><br><span class="line">              request.getMsgSize(), tagsCode, request.getConsumeQueueOffset());</span><br><span class="line">          <span class="keyword">if</span> (result) &#123;</span><br><span class="line">              <span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setLogicsMsgTimestamp(request.getStoreTimestamp());</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">              log.warn(<span class="string">"[BUG]put commit log position info to "</span> + topic + <span class="string">":"</span> + queueId + <span class="string">" "</span> + request.getCommitLogOffset()</span><br><span class="line">                  + <span class="string">" failed, retry "</span> + i + <span class="string">" times"</span>);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  log.warn(<span class="string">""</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">      log.error(<span class="string">"[BUG]consume queue can not write, &#123;&#125; &#123;&#125;"</span>, <span class="keyword">this</span>.topic, <span class="keyword">this</span>.queueId);</span><br><span class="line">      <span class="keyword">this</span>.defaultMessageStore.getRunningFlags().makeLogicsQueueError();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">putMessagePositionInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">int</span> size, <span class="keyword">final</span> <span class="keyword">long</span> tagsCode,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">long</span> cqOffset)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (offset &lt;= <span class="keyword">this</span>.maxPhysicOffset) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 结构可以参考数据结构中图</span></span><br><span class="line">      <span class="keyword">this</span>.byteBufferIndex.flip();</span><br><span class="line">      <span class="comment">// 一个CQUnit的大小是固定的20字节</span></span><br><span class="line">      <span class="keyword">this</span>.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);</span><br><span class="line">      <span class="keyword">this</span>.byteBufferIndex.putLong(offset);</span><br><span class="line">      <span class="keyword">this</span>.byteBufferIndex.putInt(size);</span><br><span class="line">      <span class="keyword">this</span>.byteBufferIndex.putLong(tagsCode);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> expectLogicOffset = cqOffset * CQ_STORE_UNIT_SIZE;</span><br><span class="line">      <span class="comment">// 获取最后一个MappedFile, 没有就创建</span></span><br><span class="line">      MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(expectLogicOffset);</span><br><span class="line">      <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mappedFile.isFirstCreateInQueue() &amp;&amp; cqOffset != <span class="number">0</span> &amp;&amp; mappedFile.getWrotePosition() == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">this</span>.minLogicOffset = expectLogicOffset;</span><br><span class="line">              <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(expectLogicOffset);</span><br><span class="line">              <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(expectLogicOffset);</span><br><span class="line">              <span class="keyword">this</span>.fillPreBlank(mappedFile, expectLogicOffset);</span><br><span class="line">              log.info(<span class="string">"fill pre blank space "</span> + mappedFile.getFileName() + <span class="string">" "</span> + expectLogicOffset + <span class="string">" "</span></span><br><span class="line">                  + mappedFile.getWrotePosition());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (cqOffset != <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">long</span> currentLogicOffset = mappedFile.getWrotePosition() + mappedFile.getFileFromOffset();</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">          <span class="keyword">this</span>.maxPhysicOffset = offset;</span><br><span class="line">          <span class="comment">// CQUnit写入文件中, 使用filechannel写,同步写</span></span><br><span class="line">          <span class="keyword">return</span> mappedFile.appendMessage(<span class="keyword">this</span>.byteBufferIndex.array());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>看到这里，ConsumeQueue就被写入到文件中了！！！！</p>
<h1 id="IndexFile"><a href="#IndexFile" class="headerlink" title="IndexFile"></a>IndexFile</h1><p><code>MessageStore</code>中存储的消息除了通过<code>ConsumeQueue</code>提供给consumer消费之外，还支持通过MessageID或者MessageKey来查询消息。使用ID查询时，因为ID就是用broker+offset生成的，所以很容易就找到对应的<code>commitLog</code>文件来读取消息。对于用MessageKey来查询消息，<code>MessageStore</code>通过构建一个index来提高读取速度。</p>
<p>在上面的CommitLogDispatcher链表中，我们还看到一个CommitLogDispatcher——<code>CommitLogDispatcherBuildIndex</code></p>
<p>他就是用来创建IndexFile的，我们也将从那里入手：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildIndex</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.messageStoreConfig.isMessageIndexEnable()) &#123;</span><br><span class="line">              DefaultMessageStore.<span class="keyword">this</span>.indexService.buildIndex(request);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.store.index.IndexService</span></span><br><span class="line"><span class="comment">// 写入indexFile</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildIndex</span><span class="params">(DispatchRequest req)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 获取或者新建当前可写入的index file, 默认重试3次</span></span><br><span class="line">      IndexFile indexFile = retryGetAndCreateIndexFile();</span><br><span class="line">      <span class="keyword">if</span> (indexFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 获取当前indexFile中记录的最大offset</span></span><br><span class="line">          <span class="keyword">long</span> endPhyOffset = indexFile.getEndPhyOffset();</span><br><span class="line">          DispatchRequest msg = req;</span><br><span class="line">          String topic = msg.getTopic();</span><br><span class="line">          String keys = msg.getKeys();</span><br><span class="line">          <span class="keyword">if</span> (msg.getCommitLogOffset() &lt; endPhyOffset) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 过滤回滚消息</span></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">          <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">              <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">              <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">              <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 单条消息</span></span><br><span class="line">          <span class="keyword">if</span> (req.getUniqKey() != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 写入index</span></span><br><span class="line">              indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey()));</span><br><span class="line">              <span class="keyword">if</span> (indexFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  log.error(<span class="string">"putKey error commitlog &#123;&#125; uniqkey &#123;&#125;"</span>, req.getCommitLogOffset(), req.getUniqKey());</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 多条消息，循环写入index</span></span><br><span class="line">          <span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; keys.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              String[] keyset = keys.split(MessageConst.KEY_SEPARATOR);</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyset.length; i++) &#123;</span><br><span class="line">                  String key = keyset[i];</span><br><span class="line">                  <span class="keyword">if</span> (key.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                      indexFile = putKey(indexFile, msg, buildKey(topic, key));</span><br><span class="line">                      <span class="keyword">if</span> (indexFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">                          log.error(<span class="string">"putKey error commitlog &#123;&#125; uniqkey &#123;&#125;"</span>, req.getCommitLogOffset(), req.getUniqKey());</span><br><span class="line">                          <span class="keyword">return</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.error(<span class="string">"build index error, stop building index"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 接着看如何将MessageKey写入IndexFile</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> IndexFile <span class="title">putKey</span><span class="params">(IndexFile indexFile, DispatchRequest msg, String idxKey)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 重试写入</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">boolean</span> ok = indexFile.putKey(idxKey, msg.getCommitLogOffset(), msg.getStoreTimestamp()); !ok; ) &#123;</span><br><span class="line">          log.warn(<span class="string">"Index file ["</span> + indexFile.getFileName() + <span class="string">"] is full, trying to create another one"</span>);</span><br><span class="line"></span><br><span class="line">          indexFile = retryGetAndCreateIndexFile();</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">null</span> == indexFile) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          ok = indexFile.putKey(idxKey, msg.getCommitLogOffset(), msg.getStoreTimestamp());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> indexFile;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.store.index.IndexFile</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putKey</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">long</span> phyOffset, <span class="keyword">final</span> <span class="keyword">long</span> storeTimestamp)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 判断indexFile是否已满，已满返回失败</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getIndexCount() &lt; <span class="keyword">this</span>.indexNum) &#123;</span><br><span class="line">          <span class="comment">// 计算key的hashCode(非负)，调用的java String的hashcode方法</span></span><br><span class="line">          <span class="keyword">int</span> keyHash = indexKeyHashMethod(key);</span><br><span class="line">          <span class="comment">// 计算slot位置（第几个）</span></span><br><span class="line">          <span class="keyword">int</span> slotPos = keyHash % <span class="keyword">this</span>.hashSlotNum;</span><br><span class="line">          <span class="comment">// 计算slot的数据存储位置</span></span><br><span class="line">          <span class="keyword">int</span> absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize;</span><br><span class="line"></span><br><span class="line">          FileLock fileLock = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 之前说过slot+index类似一个hashmap，slot类似于hashmap的数组</span></span><br><span class="line">              <span class="comment">// 如果存在hash冲突，获取这个slot存的前一个index的计数，如果没有则值为0</span></span><br><span class="line">              <span class="keyword">int</span> slotValue = <span class="keyword">this</span>.mappedByteBuffer.getInt(absSlotPos);</span><br><span class="line">              <span class="keyword">if</span> (slotValue &lt;= invalidIndex || slotValue &gt; <span class="keyword">this</span>.indexHeader.getIndexCount()) &#123;</span><br><span class="line">                  slotValue = invalidIndex;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 计算当前msg的存储时间和第一条msg相差秒数</span></span><br><span class="line">              <span class="keyword">long</span> timeDiff = storeTimestamp - <span class="keyword">this</span>.indexHeader.getBeginTimestamp();</span><br><span class="line"></span><br><span class="line">              timeDiff = timeDiff / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getBeginTimestamp() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  timeDiff = <span class="number">0</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                  timeDiff = Integer.MAX_VALUE;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                  timeDiff = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 获取该条index实际存储position</span></span><br><span class="line">              <span class="keyword">int</span> absIndexPos =</span><br><span class="line">                  IndexHeader.INDEX_HEADER_SIZE + <span class="keyword">this</span>.hashSlotNum * hashSlotSize</span><br><span class="line">                      + <span class="keyword">this</span>.indexHeader.getIndexCount() * indexSize;</span><br><span class="line">              <span class="comment">// 生成一个index的unit内容(看图)</span></span><br><span class="line">              <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos, keyHash);</span><br><span class="line">              <span class="keyword">this</span>.mappedByteBuffer.putLong(absIndexPos + <span class="number">4</span>, phyOffset);</span><br><span class="line">              <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span>, (<span class="keyword">int</span>) timeDiff);</span><br><span class="line">              <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span> + <span class="number">4</span>, slotValue);</span><br><span class="line">              <span class="comment">// 更新slot中的值为本条消息的index(因为rocketmq觉得新消息被查询的机会更大)</span></span><br><span class="line">              <span class="keyword">this</span>.mappedByteBuffer.putInt(absSlotPos, <span class="keyword">this</span>.indexHeader.getIndexCount());</span><br><span class="line">              <span class="comment">// 如果是第一条消息，更新header中的起始offset和起始时间</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getIndexCount() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.indexHeader.setBeginPhyOffset(phyOffset);</span><br><span class="line">                  <span class="keyword">this</span>.indexHeader.setBeginTimestamp(storeTimestamp);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 更新header中的计数</span></span><br><span class="line">              <span class="keyword">this</span>.indexHeader.incHashSlotCount();</span><br><span class="line">              <span class="keyword">this</span>.indexHeader.incIndexCount();</span><br><span class="line">              <span class="keyword">this</span>.indexHeader.setEndPhyOffset(phyOffset);</span><br><span class="line">              <span class="keyword">this</span>.indexHeader.setEndTimestamp(storeTimestamp);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              log.error(<span class="string">"putKey exception, Key: "</span> + key + <span class="string">" KeyHashCode: "</span> + key.hashCode(), e);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (fileLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      fileLock.release();</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                      log.error(<span class="string">"Failed to release the lock"</span>, e);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.warn(<span class="string">"Over index file capacity: index count = "</span> + <span class="keyword">this</span>.indexHeader.getIndexCount()</span><br><span class="line">              + <span class="string">"; index max num = "</span> + <span class="keyword">this</span>.indexNum);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>看到这里，IndexFile就已经被存入到ByteBuf里啦，等待被flush到文件里！！！！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/qq_27529917/article/details/79595395" target="_blank" rel="noopener">RocketMQ消息存储流程图及数据结构图</a></li>
<li><a href="https://www.jianshu.com/p/7833f5c28ec7" target="_blank" rel="noopener">RocketMQ源码解析(九)-Broker#消息存储ConsumeQueue</a></li>
<li><a href="https://www.jianshu.com/p/606d4b77d504" target="_blank" rel="noopener">RocketMQ源码解析(十)-Broker#消息存储Index</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：消息存储对于一个消息队列来说是肯定要有的，在RocketMQ中，Broker将消息存储抽象成&lt;code&gt;MessageStore&lt;/code&gt;接口，我们也将从这里入手~
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——Broker启动</title>
    <link href="http://bestlixiang.site/2019/06/19/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Broker%E5%90%AF%E5%8A%A8/"/>
    <id>http://bestlixiang.site/2019/06/19/RocketMQ源码/RocketMQ源码分析——Broker启动/</id>
    <published>2019-06-19T11:46:01.000Z</published>
    <updated>2019-06-19T11:46:10.269Z</updated>
    
    <content type="html"><![CDATA[<p>引：前面讲了NameServer，Producer，Consumer，现在终于轮到Broker了，对于一个消息队列来说，Broker是当仁不让的核心~<a id="more"></a></p>
<h1 id="五大作用"><a href="#五大作用" class="headerlink" title="五大作用"></a>五大作用</h1><ul>
<li>存储消息</li>
<li>接收生产者提交的消息</li>
<li>回复consumer的消息拉取请求</li>
<li>主从节点间同步数据保证高可用</li>
<li>提供简单的api来查询磁盘上的临时数据</li>
</ul>
<p>之后我们也将从上面的作用来进行源码的探索！</p>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>真实使用当然是用命令行去部署，这里为了看源码，我们把<strong>环境搭建</strong>那篇文章的例子搬过来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 设置版本号，很关键，不然topic创建不成功</span></span><br><span class="line">      System.setProperty(RemotingCommand.REMOTING_VERSION_KEY, Integer.toString(MQVersion.CURRENT_VERSION));</span><br><span class="line">      <span class="keyword">final</span> BrokerConfig brokerConfig = <span class="keyword">new</span> BrokerConfig();</span><br><span class="line">      brokerConfig.setBrokerName(<span class="string">"broker-a"</span>);</span><br><span class="line">      brokerConfig.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line"></span><br><span class="line">      BrokerController brokerController = <span class="keyword">new</span> BrokerController(</span><br><span class="line">              brokerConfig,</span><br><span class="line">              <span class="keyword">new</span> NettyServerConfig(),</span><br><span class="line">              <span class="keyword">new</span> NettyClientConfig(),</span><br><span class="line">              <span class="keyword">new</span> MessageStoreConfig());</span><br><span class="line">      assertThat(brokerController.initialize());</span><br><span class="line">      brokerController.start();</span><br><span class="line">      <span class="comment">// 不让主方法结束</span></span><br><span class="line">      Thread.sleep(DateUtils.MILLIS_PER_DAY);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Broker启动"><a href="#Broker启动" class="headerlink" title="Broker启动"></a>Broker启动</h1><p>从上面的例子可以看出Broker启动实质就是<code>org.apache.rocketmq.broker.BrokerController</code>完成初始化和启动的过程。</p>
<h2 id="BrokerController初始化"><a href="#BrokerController初始化" class="headerlink" title="BrokerController初始化"></a>BrokerController初始化</h2><p>我们看到<code>org.apache.rocketmq.broker.BrokerController#initialize()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 从持久化文件中加载数据到内存中</span></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">this</span>.topicConfigManager.load();</span><br><span class="line"></span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.consumerOffsetManager.load();</span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.subscriptionGroupManager.load();</span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.consumerFilterManager.load();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 消息存取的核心接口初始化</span></span><br><span class="line">            <span class="keyword">this</span>.messageStore =</span><br><span class="line">                <span class="keyword">new</span> DefaultMessageStore(<span class="keyword">this</span>.messageStoreConfig, <span class="keyword">this</span>.brokerStatsManager, <span class="keyword">this</span>.messageArrivingListener,</span><br><span class="line">                    <span class="keyword">this</span>.brokerConfig);</span><br><span class="line">            <span class="comment">// messageStore的指标统计类，提供最近一天的消息吞吐量的统计数据</span></span><br><span class="line">            <span class="keyword">this</span>.brokerStats = <span class="keyword">new</span> BrokerStats((DefaultMessageStore) <span class="keyword">this</span>.messageStore);</span><br><span class="line">            <span class="comment">//load plugin</span></span><br><span class="line">            MessageStorePluginContext context = <span class="keyword">new</span> MessageStorePluginContext(messageStoreConfig, brokerStatsManager, messageArrivingListener, brokerConfig);</span><br><span class="line">            <span class="keyword">this</span>.messageStore = MessageStoreFactory.build(context, <span class="keyword">this</span>.messageStore);</span><br><span class="line">            <span class="comment">// 添加消息分发器，分发到布隆过滤器</span></span><br><span class="line">            <span class="keyword">this</span>.messageStore.getDispatcherList().addFirst(<span class="keyword">new</span> CommitLogDispatcherCalcBitMap(<span class="keyword">this</span>.brokerConfig, <span class="keyword">this</span>.consumerFilterManager));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">            log.error(<span class="string">"Failed to initialize"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// messageStore加载内存映射文件，commit log文件，consumer queue文件，index文件</span></span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.messageStore.load();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="comment">// 3. 初始化Netty Server</span></span><br><span class="line">        <span class="keyword">this</span>.remotingServer = <span class="keyword">new</span> NettyRemotingServer(<span class="keyword">this</span>.nettyServerConfig, <span class="keyword">this</span>.clientHousekeepingService);</span><br><span class="line">        NettyServerConfig fastConfig = (NettyServerConfig) <span class="keyword">this</span>.nettyServerConfig.clone();</span><br><span class="line">        <span class="comment">// 初始化VIP通道 Netty Server</span></span><br><span class="line">        fastConfig.setListenPort(nettyServerConfig.getListenPort() - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">this</span>.fastRemotingServer = <span class="keyword">new</span> NettyRemotingServer(fastConfig, <span class="keyword">this</span>.clientHousekeepingService);</span><br><span class="line">        <span class="comment">// 初始化一系列客户端指令执行的线程池，Netty处理的优化</span></span><br><span class="line">        <span class="keyword">this</span>.sendMessageExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getSendMessageThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getSendMessageThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.sendThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"SendMessageThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.pullMessageExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getPullMessageThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getPullMessageThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.pullThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"PullMessageThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.queryMessageExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getQueryMessageThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getQueryMessageThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.queryThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"QueryMessageThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.adminBrokerExecutor =</span><br><span class="line">            Executors.newFixedThreadPool(<span class="keyword">this</span>.brokerConfig.getAdminBrokerThreadPoolNums(), <span class="keyword">new</span> ThreadFactoryImpl(</span><br><span class="line">                <span class="string">"AdminBrokerThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.clientManageExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getClientManageThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getClientManageThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.clientManagerThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"ClientManageThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.heartbeatExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getHeartbeatThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getHeartbeatThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.heartbeatThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"HeartbeatThread_"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.endTransactionExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getEndTransactionThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getEndTransactionThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.endTransactionThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"EndTransactionThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.consumerManageExecutor =</span><br><span class="line">            Executors.newFixedThreadPool(<span class="keyword">this</span>.brokerConfig.getConsumerManageThreadPoolNums(), <span class="keyword">new</span> ThreadFactoryImpl(</span><br><span class="line">                <span class="string">"ConsumerManageThread_"</span>));</span><br><span class="line">        <span class="comment">// 将这些线程池添加到Netty Pipeline中</span></span><br><span class="line">        <span class="keyword">this</span>.registerProcessor();</span><br><span class="line">        <span class="comment">// 4. 打印broker的消息吞吐信息到日志文件定时任务，每天0点记录一次</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> initialDelay = UtilAll.computNextMorningTimeMillis() - System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> period = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>;</span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.getBrokerStats().record();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"schedule record error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, initialDelay, period, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="comment">//  记录consumerOffet到文件定时任务,默认5秒一次</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.consumerOffsetManager.persist();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"schedule persist consumerOffset error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="keyword">this</span>.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="comment">// 记录consumer filter到文件中定时任务,10秒一次</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.consumerFilterManager.persist();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"schedule persist consumer filter error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="comment">// 定时检查consumer的消费记录，如果延时太大,则disable consumer,不再往这个consumer投递消息</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.protectBroker();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"protectBroker error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, <span class="number">3</span>, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 打印当前Queue size日志</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.printWaterMark();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"printWaterMark error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">10</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 打印dispatch落后情况</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">"dispatch behind commit log &#123;&#125; bytes"</span>, BrokerController.<span class="keyword">this</span>.getMessageStore().dispatchBehindBytes());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"schedule dispatchBehindBytes error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="comment">// 定时更新nameserv address信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.brokerConfig.getNamesrvAddr() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.brokerOuterAPI.updateNameServerAddressList(<span class="keyword">this</span>.brokerConfig.getNamesrvAddr());</span><br><span class="line">            log.info(<span class="string">"Set user specified name server address: &#123;&#125;"</span>, <span class="keyword">this</span>.brokerConfig.getNamesrvAddr());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.brokerConfig.isFetchNamesrvAddrByAddressServer()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        BrokerController.<span class="keyword">this</span>.brokerOuterAPI.fetchNameServerAddr();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        log.error(<span class="string">"ScheduledTask fetchNameServerAddr exception"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是broker是slave，启动定时任务，每分钟从master同步配置和offset</span></span><br><span class="line">        <span class="keyword">if</span> (BrokerRole.SLAVE == <span class="keyword">this</span>.messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.messageStoreConfig.getHaMasterAddress() != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageStoreConfig.getHaMasterAddress().length() &gt;= <span class="number">6</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.messageStore.updateHaMasterAddress(<span class="keyword">this</span>.messageStoreConfig.getHaMasterAddress());</span><br><span class="line">                <span class="keyword">this</span>.updateMasterHAServerAddrPeriodically = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.updateMasterHAServerAddrPeriodically = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        BrokerController.<span class="keyword">this</span>.slaveSynchronize.syncAll();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        log.error(<span class="string">"ScheduledTask syncAll slave exception"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果broker是master，定时打印slave延时情况</span></span><br><span class="line">            <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        BrokerController.<span class="keyword">this</span>.printMasterAndSlaveDiff();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        log.error(<span class="string">"schedule printMasterAndSlaveDiff error."</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 初始化事务消息service</span></span><br><span class="line">        initialTransaction();</span><br><span class="line">        initialAcl();</span><br><span class="line">        initialRpcHooks();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑还是非常简单的，一看就知道他在干什么~</p>
<h2 id="BrokerController启动"><a href="#BrokerController启动" class="headerlink" title="BrokerController启动"></a>BrokerController启动</h2><p>当BrokerController初始化完成之后，我们看<code>org.apache.rocketmq.broker.BrokerController#start()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 启动消息存储服务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.messageStore != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.messageStore.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动Netty Server接收请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.remotingServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.remotingServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动VIP Channel Netty Server</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fastRemotingServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fastRemotingServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动TLS签名文件检测服务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fileWatchService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fileWatchService.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动Broker的Netty Client</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerOuterAPI != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerOuterAPI.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动PushConsumer的请求 Hold 服务 (后面会展开)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.pullRequestHoldService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.pullRequestHoldService.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监控客户端连接，定时检查Producer，Consumer和Filter是否长时间未收到心跳</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.clientHousekeepingService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.clientHousekeepingService.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动Filter Server</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.filterServerManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.filterServerManager.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册Broker到Namesrv</span></span><br><span class="line">    <span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时向Namesrv发心跳，如果有变化则同步Broker信息</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BrokerController.<span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, brokerConfig.isForceRegister());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"registerBrokerAll Exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">10</span>, Math.max(<span class="number">10000</span>, Math.min(brokerConfig.getRegisterNameServerPeriod(), <span class="number">60000</span>)), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerStatsManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerStatsManager.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动BrokerFastFailure服务，定时清理长时间未执行的客户端请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerFastFailure != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerFastFailure.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是Master，开启事务消息检查</span></span><br><span class="line">    <span class="keyword">if</span> (BrokerRole.SLAVE != messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.transactionalMessageCheckService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"Start transaction service!"</span>);</span><br><span class="line">            <span class="keyword">this</span>.transactionalMessageCheckService.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从整个过程来看还是比较简单的，水文一篇，但是后面会继续分析Broker的各个作用的实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前面讲了NameServer，Producer，Consumer，现在终于轮到Broker了，对于一个消息队列来说，Broker是当仁不让的核心~
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——Consumer</title>
    <link href="http://bestlixiang.site/2019/06/18/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Consumer/"/>
    <id>http://bestlixiang.site/2019/06/18/RocketMQ源码/RocketMQ源码分析——Consumer/</id>
    <published>2019-06-18T11:43:10.000Z</published>
    <updated>2019-06-18T11:43:32.676Z</updated>
    
    <content type="html"><![CDATA[<p>引：当消息达到Broker之后，就等着Consumer去consume了呀~<a id="more"></a></p>
<h1 id="消费方式"><a href="#消费方式" class="headerlink" title="消费方式"></a>消费方式</h1><ul>
<li><p>PullConsumer：消费者主动调用pull方法来获取消息，没有则返回</p>
</li>
<li><p>PushConsumer：虽然名为Push，但是是消费者主动循环发送Pull请求到broker，如果没有消息，broker会把请求放入等待队列，新消息到达后返回response</p>
</li>
</ul>
<p>所以本质上，两种方式都是通过消费者主动Pull来实现的。</p>
<h1 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h1><p>Consumer的消费模式在初始化consumer时设置的，主要有下面两种：</p>
<ul>
<li>Broadcast模式：消息会发送给group内所有consumer</li>
<li>Cluster模式：每条消息只会发送给group内的一个consumer，但是Cluster模式的支持消费失败重发，从而保证消息一定被消费</li>
</ul>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>这次我们主要看看PushConsumer，以Cluster模式消费的源码是如何实现的，因为这种方式相对来说是最复杂的一种。例子其实也是在之前<strong>环境搭建</strong>那边文章中例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">				<span class="comment">// 指定消费者组的PushConsumer</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_4"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指明Namesrv</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定消费开始位置</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 订阅Topic</span></span><br><span class="line">        consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 指定回调逻辑</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">"%s Receive New Messages: %s %n"</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">			  <span class="comment">// 启动</span></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Consumer启动"><a href="#Consumer启动" class="headerlink" title="Consumer启动"></a>Consumer启动</h1><p>之前其实在Producer分析里面带过Consumer，所以逻辑也是类似的。</p>
<h2 id="DefaultMQPushConsumer初始化"><a href="#DefaultMQPushConsumer初始化" class="headerlink" title="DefaultMQPushConsumer初始化"></a>DefaultMQPushConsumer初始化</h2><p>和Producer一样包装了一个DefaultMQPushConsumerImpl，下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.consumer.DefaultMQPushConsumer</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">DefaultMQPushConsumer</span><span class="params">(<span class="keyword">final</span> String consumerGroup)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(consumerGroup, <span class="keyword">null</span>, <span class="keyword">new</span> AllocateMessageQueueAveragely());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultMQPushConsumer</span><span class="params">(<span class="keyword">final</span> String consumerGroup, RPCHook rpcHook,</span></span></span><br><span class="line"><span class="function"><span class="params">      AllocateMessageQueueStrategy allocateMessageQueueStrategy)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.consumerGroup = consumerGroup;</span><br><span class="line">      <span class="comment">// 默认平均分配</span></span><br><span class="line">      <span class="keyword">this</span>.allocateMessageQueueStrategy = allocateMessageQueueStrategy;</span><br><span class="line">      <span class="comment">// 构造实际类</span></span><br><span class="line">      defaultMQPushConsumerImpl = <span class="keyword">new</span> DefaultMQPushConsumerImpl(<span class="keyword">this</span>, rpcHook);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultMQPushConsumerImpl</span><span class="params">(DefaultMQPushConsumer defaultMQPushConsumer, RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.defaultMQPushConsumer = defaultMQPushConsumer;</span><br><span class="line">      <span class="keyword">this</span>.rpcHook = rpcHook;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="DefaultMQPushConsumer启动"><a href="#DefaultMQPushConsumer启动" class="headerlink" title="DefaultMQPushConsumer启动"></a>DefaultMQPushConsumer启动</h2><p>实质就是defaultMQPushConsumerImpl启动，下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"> 	<span class="comment">// org.apache.rocketmq.client.consumer.DefaultMQPushConsumer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">      <span class="comment">// 实质defaultMQPushConsumerImpl启动</span></span><br><span class="line">      <span class="keyword">this</span>.defaultMQPushConsumerImpl.start();</span><br><span class="line">		<span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">          <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">              log.info(<span class="string">"the consumer [&#123;&#125;] start beginning. messageModel=&#123;&#125;, isUnitMode=&#123;&#125;"</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(),</span><br><span class="line">                  <span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel(), <span class="keyword">this</span>.defaultMQPushConsumer.isUnitMode());</span><br><span class="line">              <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">              <span class="comment">// 基本参数检查</span></span><br><span class="line">              <span class="keyword">this</span>.checkConfig();</span><br><span class="line">              <span class="comment">// 将DefaultMQPushConsumer的订阅信息copy到RebalanceService中</span></span><br><span class="line">              <span class="comment">// 如果是cluster模式，如果订阅了topic,则自动订阅%RETRY%groupname，也加入到RebalanceService中</span></span><br><span class="line">              <span class="keyword">this</span>.copySubscription();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line">                  <span class="comment">// 如果InstanceName参数值为DEFAULT则修改为PID</span></span><br><span class="line">                  <span class="keyword">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 新建一个MQClientInstance,客户端管理类, 单例，一个进程中只有一个</span></span><br><span class="line">              <span class="comment">// 所有的i/o类操作由它管理，缓存客户端和topic信息，各种service，很重要</span></span><br><span class="line">              <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQPushConsumer, <span class="keyword">this</span>.rpcHook);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">this</span>.rebalanceImpl.setConsumerGroup(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">              <span class="keyword">this</span>.rebalanceImpl.setMessageModel(<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel());</span><br><span class="line">              <span class="keyword">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="keyword">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">              <span class="keyword">this</span>.rebalanceImpl.setmQClientFactory(<span class="keyword">this</span>.mQClientFactory);</span><br><span class="line">              <span class="comment">// PullRequest封装实现类，封装了和broker的通信接口</span></span><br><span class="line">              <span class="keyword">this</span>.pullAPIWrapper = <span class="keyword">new</span> PullAPIWrapper(</span><br><span class="line">                  mQClientFactory,</span><br><span class="line">                  <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">              <span class="comment">// 消息被客户端过滤时会回调的钩子</span></span><br><span class="line">              <span class="keyword">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// consumer客户端消费offset持久化</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.offsetStore = <span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore();</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">                      <span class="comment">// 广播消息本地持久化offset</span></span><br><span class="line">                      <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">                          <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> LocalFileOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="comment">// 集群模式broker持久化offset</span></span><br><span class="line">                      <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">                          <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> RemoteBrokerOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">default</span>:</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">this</span>.defaultMQPushConsumer.setOffsetStore(<span class="keyword">this</span>.offsetStore);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 如果是广播模式则从本地文件中load，如果是集群模式不做操作</span></span><br><span class="line">              <span class="keyword">this</span>.offsetStore.load();</span><br><span class="line">              <span class="comment">// 消息消费服务，顺序和并发消息逻辑不同,接收消息并调用listener消费，处理消费结果</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerOrderly) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.consumeOrderly = <span class="keyword">true</span>;</span><br><span class="line">                  <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                      <span class="keyword">new</span> ConsumeMessageOrderlyService(<span class="keyword">this</span>, (MessageListenerOrderly) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerConcurrently) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.consumeOrderly = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                      <span class="keyword">new</span> ConsumeMessageConcurrentlyService(<span class="keyword">this</span>, (MessageListenerConcurrently) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 启动等待处理消息服务（定时服务）</span></span><br><span class="line">              <span class="keyword">this</span>.consumeMessageService.start();</span><br><span class="line">              <span class="comment">// 注册Consumer</span></span><br><span class="line">              <span class="keyword">boolean</span> registerOK = mQClientFactory.registerConsumer(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="keyword">this</span>);</span><br><span class="line">              <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                  <span class="keyword">this</span>.consumeMessageService.shutdown();</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The consumer group["</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()</span><br><span class="line">                      + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                      <span class="keyword">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// mqClient启动</span></span><br><span class="line">              mQClientFactory.start();</span><br><span class="line">              log.info(<span class="string">"the consumer [&#123;&#125;] start OK."</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">              <span class="comment">// 改变状态</span></span><br><span class="line">              <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> RUNNING:</span><br><span class="line">          <span class="keyword">case</span> START_FAILED:</span><br><span class="line">          <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The PushConsumer service state not OK, maybe started once, "</span></span><br><span class="line">                  + <span class="keyword">this</span>.serviceState</span><br><span class="line">                  + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                  <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新Topic信息</span></span><br><span class="line">      <span class="keyword">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line">      <span class="keyword">this</span>.mQClientFactory.checkClientInBroker();</span><br><span class="line">      <span class="comment">// 发送心跳</span></span><br><span class="line">      <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">      <span class="comment">// 做一次rebalance</span></span><br><span class="line">      <span class="keyword">this</span>.mQClientFactory.rebalanceImmediately();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个点说一下：</p>
<ul>
<li>%RETRY% +groupname：如果consumer是cluster模式，并且订阅了TopicA的消息，那客户端会自动订阅%RETRY% + +groupname。我们知道consumer消费消息处理失败的话，broker是会延时一定的时间重新推送的，重新推送不是跟其它新消息一起过来，而是通过单独的%RETRY%过来。</li>
<li>RebalanceService分配策略：Rebalance支持多种分配策略，比如平均分配、一致性Hash等，默认采用平均分配策略(AVG)。</li>
</ul>
<h2 id="MQClientInstance启动"><a href="#MQClientInstance启动" class="headerlink" title="MQClientInstance启动"></a>MQClientInstance启动</h2><p>在讲Producer的时候已经讲过<code>MQClientInstance</code>的启动过程，因为Producer和Consumer共用一个<code>MQClientInstance</code>，下面我们再来看一下Consumer相关逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.impl.factory.MQClientInstance</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">              <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">             			<span class="comment">// 省略不相关...</span></span><br><span class="line">                  <span class="comment">// 开启各种定时任务</span></span><br><span class="line">                  <span class="keyword">this</span>.startScheduledTask();</span><br><span class="line">                  <span class="comment">// 开启拉消息服务(Consumer)</span></span><br><span class="line">                  <span class="keyword">this</span>.pullMessageService.start();</span><br><span class="line">                  <span class="comment">// 开启负载均衡服务，一个线程定时触发rebalance(20秒一次)</span></span><br><span class="line">                  <span class="keyword">this</span>.rebalanceService.start();</span><br><span class="line">                  <span class="comment">// 初始化一个自用的producer，`CLIENT_INNER_PRODUCER`</span></span><br><span class="line">                  <span class="comment">// 主要用于在消费失败或者超时后发送重试的消息给broker</span></span><br><span class="line">                  <span class="keyword">this</span>.defaultMQProducer.getDefaultMQProducerImpl().start(<span class="keyword">false</span>);</span><br><span class="line">                  <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">								<span class="comment">// 省略不相关...</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startScheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 省略不相关...</span></span><br><span class="line">      <span class="comment">// 持久化消费者的Offset</span></span><br><span class="line">    	<span class="comment">// 保存消费进度，广播消息存在本地，集群消息上传到所有的broker</span></span><br><span class="line">      <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  MQClientInstance.<span class="keyword">this</span>.persistAllConsumerOffset();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  log.error(<span class="string">"ScheduledTask persistAllConsumerOffset exception"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据负载调整本地处理消息的线程池corePool大小</span></span><br><span class="line">      <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  MQClientInstance.<span class="keyword">this</span>.adjustThreadPool();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  log.error(<span class="string">"ScheduledTask adjustThreadPool exception"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>到这里Consumer的相关初始化工作就做完了，下面就会去消费消息了。</p>
<h1 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h1><p>这块逻辑有点复杂，为了大家不被细节绕晕，这里画了一下时序图，如下：<br><img src="https://upload-images.jianshu.io/upload_images/10354196-0b1bee5b4c2bb8b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RocketMq——Consumer消息消费时序图.jpg"></p>
<h2 id="RebalanceImpl触发Pull消息"><a href="#RebalanceImpl触发Pull消息" class="headerlink" title="RebalanceImpl触发Pull消息"></a>RebalanceImpl触发Pull消息</h2><p>还记得<code>defaultMQPushConsumerImpl</code>启动代码中最后一行执行了<code>this.mQClientFactory.rebalanceImmediately()</code>，忘记了，可以回头看看，这里会第一次触发Pull消息。我们看看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.impl.factory.MQClientInstance</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rebalanceImmediately</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   		<span class="comment">// 之前说过rebalanceService就是一个线程，继承于ServiceThread</span></span><br><span class="line">      <span class="keyword">this</span>.rebalanceService.wakeup();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.common.ServiceThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 这里主要是唤醒rebalanceService，用来了原子类和闭锁保证线程安全</span></span><br><span class="line">      <span class="keyword">if</span> (hasNotified.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">          waitPoint.countDown(); <span class="comment">// notify</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.rebalanceService</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        	<span class="comment">// 默认20s</span></span><br><span class="line">          <span class="keyword">this</span>.waitForRunning(waitInterval);</span><br><span class="line">          <span class="keyword">this</span>.mqClientFactory.doRebalance();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.factory.MQClientInstance</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 每一个Consumer都要做doRebalance操作</span></span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, MQConsumerInner&gt; entry : <span class="keyword">this</span>.consumerTable.entrySet()) &#123;</span><br><span class="line">          MQConsumerInner impl = entry.getValue();</span><br><span class="line">          <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  impl.doRebalance();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                  log.error(<span class="string">"doRebalance exception"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.pause) &#123;</span><br><span class="line">          <span class="keyword">this</span>.rebalanceImpl.doRebalance(<span class="keyword">this</span>.isConsumeOrderly());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.RebalanceImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebalanceByTopic</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (messageModel) &#123;</span><br><span class="line">          <span class="keyword">case</span> BROADCASTING: &#123;</span><br><span class="line">              Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">              <span class="keyword">if</span> (mqSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">boolean</span> changed = <span class="keyword">this</span>.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);</span><br><span class="line">                  <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                      <span class="keyword">this</span>.messageQueueChanged(topic, mqSet, mqSet);</span><br><span class="line">                      log.info(<span class="string">"messageQueueChanged &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;"</span>,</span><br><span class="line">                          consumerGroup,</span><br><span class="line">                          topic,</span><br><span class="line">                          mqSet,</span><br><span class="line">                          mqSet);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  log.warn(<span class="string">"doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist."</span>, consumerGroup, topic);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">case</span> CLUSTERING: &#123;</span><br><span class="line">              <span class="comment">// 从路由信息中获取topic对应所有的Queue</span></span><br><span class="line">              Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">              <span class="comment">// 从broker获取所有同一个group的所有Consumer ID(192.168.1.28@83721)</span></span><br><span class="line">              List&lt;String&gt; cidAll = <span class="keyword">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">null</span> == mqSet) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                      log.warn(<span class="string">"doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist."</span>, consumerGroup, topic);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">null</span> == cidAll) &#123;</span><br><span class="line">                  log.warn(<span class="string">"doRebalance, &#123;&#125; &#123;&#125;, get consumer id list failed"</span>, consumerGroup, topic);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (mqSet != <span class="keyword">null</span> &amp;&amp; cidAll != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line">                  mqAll.addAll(mqSet);</span><br><span class="line">                  <span class="comment">// 将mq和cid都排好序</span></span><br><span class="line">                  Collections.sort(mqAll);</span><br><span class="line">                  Collections.sort(cidAll);</span><br><span class="line">                  <span class="comment">// 按照初始化是指定的分配策略（默认平均），获取Consumer分配的MQ列表</span></span><br><span class="line">                  AllocateMessageQueueStrategy strategy = <span class="keyword">this</span>.allocateMessageQueueStrategy;</span><br><span class="line"></span><br><span class="line">                  List&lt;MessageQueue&gt; allocateResult = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      allocateResult = strategy.allocate(</span><br><span class="line">                          <span class="keyword">this</span>.consumerGroup,</span><br><span class="line">                          <span class="keyword">this</span>.mQClientFactory.getClientId(),</span><br><span class="line">                          mqAll,</span><br><span class="line">                          cidAll);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                      log.error(<span class="string">"AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;"</span>, strategy.getName(),</span><br><span class="line">                          e);</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  Set&lt;MessageQueue&gt; allocateResultSet = <span class="keyword">new</span> HashSet&lt;MessageQueue&gt;();</span><br><span class="line">                  <span class="keyword">if</span> (allocateResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      allocateResultSet.addAll(allocateResult);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 更新rebalanceImpl中的processQueue用来缓存收到的消息</span></span><br><span class="line">                  <span class="comment">// 对于新加入的Queue，提交一次PullRequest</span></span><br><span class="line">                  <span class="comment">// 对于新启动的consumer来说，所有的queue都是新添加的，所以所有queue都会触发PullRequest</span></span><br><span class="line">                  <span class="keyword">boolean</span> changed = <span class="keyword">this</span>.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);</span><br><span class="line">                  <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                      log.info(</span><br><span class="line">                          <span class="string">"rebalanced result changed. allocateMessageQueueStrategyName=&#123;&#125;, group=&#123;&#125;, topic=&#123;&#125;, clientId=&#123;&#125;, mqAllSize=&#123;&#125;, cidAllSize=&#123;&#125;, rebalanceResultSize=&#123;&#125;, rebalanceResultSet=&#123;&#125;"</span>,</span><br><span class="line">                          strategy.getName(), consumerGroup, topic, <span class="keyword">this</span>.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),</span><br><span class="line">                          allocateResultSet.size(), allocateResultSet);</span><br><span class="line">                      <span class="comment">// 发送一次心跳</span></span><br><span class="line">                      <span class="keyword">this</span>.messageQueueChanged(topic, mqSet, allocateResultSet);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个点重点看看：</p>
<h3 id="Queue分配策略"><a href="#Queue分配策略" class="headerlink" title="Queue分配策略"></a>Queue分配策略</h3><p>我们看这个方法<code>AllocateMessageQueueStrategy#allocate()</code>，他有下面几种实现：</p>
<ul>
<li><p>AllocateMessageQueueAveragely：这是默认的分配方式，一个consumer分到在平均的情况下分到连续的queue，待会我们会看看代码</p>
</li>
<li><p>AllocateMessageQueueAveragelyByCircle： 和上面类似，但是分到的queue不是连续的。比如一共12个Queue，3个consumer，则第一个consumer接收queue1，4，7，9的消息</p>
</li>
<li><p>AllocateMachineRoomNearby：将queue先按照broker划分几个computer room，不同的consumer只消费某几个broker上的消息</p>
</li>
<li><p>AllocateMessageQueueByMachineRoom：根据computer room进行hash分配队列</p>
</li>
<li><p>AllocateMessageQueueByConfig：在用户启动时指定消费哪些Queue的消息</p>
</li>
<li><p>AllocateMessageQueueConsistentHash：使用一致性hash算法来分配Queue，用户需自定义虚拟节点的数量</p>
</li>
</ul>
<p>然后下面我们看看默认的<code>AllocateMessageQueueAveragely</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MessageQueue&gt; <span class="title">allocate</span><span class="params">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;String&gt; cidAll)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="keyword">int</span> index = cidAll.indexOf(currentCID);</span><br><span class="line">    <span class="keyword">int</span> mod = mqAll.size() % cidAll.size();</span><br><span class="line">    <span class="comment">// 1. mq数量 &lt;= consumer数量，size = 1</span></span><br><span class="line">    <span class="comment">// 2. 否则，size = mq数量 / consumer数量，余数是几则前几个consumer的size+1,这样所有的queue都会有consumer消费</span></span><br><span class="line">    <span class="keyword">int</span> averageSize =</span><br><span class="line">        mqAll.size() &lt;= cidAll.size() ? <span class="number">1</span> : (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size()</span><br><span class="line">            + <span class="number">1</span> : mqAll.size() / cidAll.size());</span><br><span class="line">    <span class="keyword">int</span> startIndex = (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod;</span><br><span class="line">    <span class="keyword">int</span> range = Math.min(averageSize, mqAll.size() - startIndex);</span><br><span class="line">    <span class="comment">// 从第一个consumer开始分配，每个分avgSize个连续的Queue，</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">        result.add(mqAll.get((startIndex + i) % mqAll.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="提交Pull请求"><a href="#提交Pull请求" class="headerlink" title="提交Pull请求"></a>提交Pull请求</h3><p>上面我们说过对于新加入的Queue，提交一次PullRequest，那么我们就可以看看<code>org.apache.rocketmq.client.impl.consumer.RebalanceImpl#updateProcessQueueTableInRebalance</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateProcessQueueTableInRebalance</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> Set&lt;MessageQueue&gt; mqSet,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">// 省略</span></span><br><span class="line">      List&lt;PullRequest&gt; pullRequestList = <span class="keyword">new</span> ArrayList&lt;PullRequest&gt;();</span><br><span class="line">      <span class="keyword">for</span> (MessageQueue mq : mqSet) &#123;</span><br><span class="line">          <span class="comment">// 如果是新加入的Queue</span></span><br><span class="line">          <span class="keyword">if</span> (!<span class="keyword">this</span>.processQueueTable.containsKey(mq)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (isOrder &amp;&amp; !<span class="keyword">this</span>.lock(mq)) &#123;</span><br><span class="line">                  log.warn(<span class="string">"doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed"</span>, consumerGroup, mq);</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 从offset store中移除过时的数据</span></span><br><span class="line">              <span class="keyword">this</span>.removeDirtyOffset(mq);</span><br><span class="line">              ProcessQueue pq = <span class="keyword">new</span> ProcessQueue();</span><br><span class="line">              <span class="comment">// 获取起始消费offset</span></span><br><span class="line">              <span class="keyword">long</span> nextOffset = <span class="keyword">this</span>.computePullFromWhere(mq);</span><br><span class="line">              <span class="keyword">if</span> (nextOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 为新的Queue初始化一个ProcessQueue，用来缓存收到的消息</span></span><br><span class="line">                  ProcessQueue pre = <span class="keyword">this</span>.processQueueTable.putIfAbsent(mq, pq);</span><br><span class="line">                  <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      log.info(<span class="string">"doRebalance, &#123;&#125;, mq already exists, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      log.info(<span class="string">"doRebalance, &#123;&#125;, add a new mq, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                      <span class="comment">// 对新加的queue初始化一个PullRequest</span></span><br><span class="line">                      PullRequest pullRequest = <span class="keyword">new</span> PullRequest();</span><br><span class="line">                      pullRequest.setConsumerGroup(consumerGroup);</span><br><span class="line">                      pullRequest.setNextOffset(nextOffset);</span><br><span class="line">                      pullRequest.setMessageQueue(mq);</span><br><span class="line">                      pullRequest.setProcessQueue(pq);</span><br><span class="line">                      pullRequestList.add(pullRequest);</span><br><span class="line">                      changed = <span class="keyword">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  log.warn(<span class="string">"doRebalance, &#123;&#125;, add new mq failed, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 分发pull request到PullMessageService拉取消息</span></span><br><span class="line">      <span class="keyword">this</span>.dispatchPullRequest(pullRequestList);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> changed;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.RebalancePushImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchPullRequest</span><span class="params">(List&lt;PullRequest&gt; pullRequestList)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (PullRequest pullRequest : pullRequestList) &#123;</span><br><span class="line">        	<span class="comment">// 执行拉取消息</span></span><br><span class="line">          <span class="keyword">this</span>.defaultMQPushConsumerImpl.executePullRequestImmediately(pullRequest);</span><br><span class="line">          log.info(<span class="string">"doRebalance, &#123;&#125;, add a new pull request &#123;&#125;"</span>, consumerGroup, pullRequest);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executePullRequestImmediately</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.mQClientFactory.getPullMessageService().executePullRequestImmediately(pullRequest);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.PullMessageService</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executePullRequestImmediately</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">// 将pull request 放入到pullRequestQueue中</span></span><br><span class="line">          <span class="keyword">this</span>.pullRequestQueue.put(pullRequest);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          log.error(<span class="string">"executePullRequestImmediately pullRequestQueue.put"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息拉取服务"><a href="#消息拉取服务" class="headerlink" title="消息拉取服务"></a>消息拉取服务</h2><p>我们在MQClientInstance启动的时候，我们看到我们启动了一个消息拉取的定时服务。这里我们也就知道其实<code>PullMessageService</code>也是一个线程，我们先看run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.impl.consumer.PullMessageService</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="comment">// 取pull request 进行拉取</span></span><br><span class="line">              PullRequest pullRequest = <span class="keyword">this</span>.pullRequestQueue.take();</span><br><span class="line">              <span class="keyword">this</span>.pullMessage(pullRequest);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              log.error(<span class="string">"Pull Message Service Run Method exception"</span>, e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> MQConsumerInner consumer = <span class="keyword">this</span>.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());</span><br><span class="line">      <span class="keyword">if</span> (consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">          DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;</span><br><span class="line">        	<span class="comment">// 实质</span></span><br><span class="line">          impl.pullMessage(pullRequest);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.warn(<span class="string">"No matched consumer for the PullRequest &#123;&#125;, drop it"</span>, pullRequest);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 拿到缓存消息的队列</span></span><br><span class="line">      <span class="keyword">final</span> ProcessQueue processQueue = pullRequest.getProcessQueue();</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 设置拉取时间戳</span></span><br><span class="line">      pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 查看消息缓存队列的消息数量以及大小</span></span><br><span class="line">      <span class="keyword">long</span> cachedMessageCount = processQueue.getMsgCount().get();</span><br><span class="line">      <span class="keyword">long</span> cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">      <span class="comment">// 如果堆积未处理的消息数量过多(大于默认1000条)，则放回pull request队列,延时执行（默认50ms）</span></span><br><span class="line">      <span class="keyword">if</span> (cachedMessageCount &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果堆积未处理的消息的大小过大（大于100MB），同上面的逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (cachedMessageSizeInMiB &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 无序消息，消息offset跨度过大，同上面的逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.consumeOrderly) &#123;</span><br><span class="line">          <span class="keyword">if</span> (processQueue.getMaxSpan() &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) &#123;</span><br><span class="line">              <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">              <span class="comment">// ...</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检查订阅关系有没有变化，有可能在延时期间，topic或者consumer的配置都发生了变化，需要重新处理</span></span><br><span class="line">      <span class="keyword">final</span> SubscriptionData subscriptionData = <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionData) &#123;</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">          log.warn(<span class="string">"find the consumer's subscription failed, &#123;&#125;"</span>, pullRequest);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line">      <span class="comment">// Pull Command发送后的回调</span></span><br><span class="line">      PullCallback pullCallback = <span class="keyword">new</span> PullCallback() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(PullResult pullResult)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (pullResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 消息预处理，客户端再次过滤，设置minOffset和maxOffset</span></span><br><span class="line">                  pullResult = DefaultMQPushConsumerImpl.<span class="keyword">this</span>.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</span><br><span class="line">                      subscriptionData);</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                      <span class="keyword">case</span> FOUND:</span><br><span class="line">                          <span class="keyword">long</span> prevRequestOffset = pullRequest.getNextOffset();</span><br><span class="line">                          pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line">                          <span class="keyword">long</span> pullRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">                          DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),</span><br><span class="line">                              pullRequest.getMessageQueue().getTopic(), pullRT);</span><br><span class="line"></span><br><span class="line">                          <span class="keyword">long</span> firstMsgOffset = Long.MAX_VALUE;</span><br><span class="line">                          <span class="comment">// 如果获取到的消息数为0，则立即发起下一次pull</span></span><br><span class="line">                          <span class="keyword">if</span> (pullResult.getMsgFoundList() == <span class="keyword">null</span> || pullResult.getMsgFoundList().isEmpty()) &#123;</span><br><span class="line">                              DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                              firstMsgOffset = pullResult.getMsgFoundList().get(<span class="number">0</span>).getQueueOffset();</span><br><span class="line"></span><br><span class="line">                              DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),</span><br><span class="line">                                  pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());</span><br><span class="line">                              <span class="comment">// 消息放入ProcessQueue</span></span><br><span class="line">                              <span class="keyword">boolean</span> dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span><br><span class="line">                              <span class="comment">// 消费消息服务（线程池），调用messageListener处理，处理完成会通知ProcessQueue</span></span><br><span class="line">                              DefaultMQPushConsumerImpl.<span class="keyword">this</span>.consumeMessageService.submitConsumeRequest(</span><br><span class="line">                                  pullResult.getMsgFoundList(),</span><br><span class="line">                                  processQueue,</span><br><span class="line">                                  pullRequest.getMessageQueue(),</span><br><span class="line">                                  dispatchToConsume);</span><br><span class="line">                              <span class="comment">// 再次提交pull request</span></span><br><span class="line">                              <span class="keyword">if</span> (DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                  DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest,</span><br><span class="line">                                      DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval());</span><br><span class="line">                              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                  DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                          <span class="keyword">if</span> (pullResult.getNextBeginOffset() &lt; prevRequestOffset</span><br><span class="line">                              || firstMsgOffset &lt; prevRequestOffset) &#123;</span><br><span class="line">                              log.warn(</span><br><span class="line">                                  <span class="string">"[BUG] pull message result maybe data wrong, nextBeginOffset: &#123;&#125; firstMsgOffset: &#123;&#125; prevRequestOffset: &#123;&#125;"</span>,</span><br><span class="line">                                  pullResult.getNextBeginOffset(),</span><br><span class="line">                                  firstMsgOffset,</span><br><span class="line">                                  prevRequestOffset);</span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">case</span> NO_NEW_MSG:</span><br><span class="line">                          <span class="comment">// ...</span></span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">case</span> OFFSET_ILLEGAL:</span><br><span class="line">                          <span class="comment">// ...</span></span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">default</span>:</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 调用Netty去发送Pull Command，其实这后面就和生产者发送消息是一样的，不过这里是异步发送消息</span></span><br><span class="line">        	<span class="comment">// 异步完成之后会执行pullCallback</span></span><br><span class="line">          <span class="keyword">this</span>.pullAPIWrapper.pullKernelImpl(</span><br><span class="line">              pullRequest.getMessageQueue(),</span><br><span class="line">              subExpression,</span><br><span class="line">              subscriptionData.getExpressionType(),</span><br><span class="line">              subscriptionData.getSubVersion(),</span><br><span class="line">              pullRequest.getNextOffset(),</span><br><span class="line">              <span class="keyword">this</span>.defaultMQPushConsumer.getPullBatchSize(),</span><br><span class="line">              sysFlag,</span><br><span class="line">              commitOffsetValue,</span><br><span class="line">              BROKER_SUSPEND_MAX_TIME_MILLIS,</span><br><span class="line">              CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,</span><br><span class="line">              CommunicationMode.ASYNC,</span><br><span class="line">              pullCallback</span><br><span class="line">          );</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          log.error(<span class="string">"pullKernelImpl exception"</span>, e);</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息消费-1"><a href="#消息消费-1" class="headerlink" title="消息消费"></a>消息消费</h2><p>上面我们已经说过了当消息拉取完之后会执行PullCallback，具体一点就是会执行到<code>org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService.submitConsumeRequest()</code>，我们看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitConsumeRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ProcessQueue processQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> MessageQueue messageQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">boolean</span> dispatchToConsume)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> consumeBatchSize = <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line">      <span class="comment">// 看是否需要批量消费，默认阈值是1</span></span><br><span class="line">      <span class="keyword">if</span> (msgs.size() &lt;= consumeBatchSize) &#123;</span><br><span class="line">          <span class="comment">// 创建一个消费任务</span></span><br><span class="line">          ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgs, processQueue, messageQueue);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">              <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 创建批量消费任务</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> total = <span class="number">0</span>; total &lt; msgs.size(); ) &#123;</span><br><span class="line">              List&lt;MessageExt&gt; msgThis = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeBatchSize);</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumeBatchSize; i++, total++) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (total &lt; msgs.size()) &#123;</span><br><span class="line">                      msgThis.add(msgs.get(total));</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgThis, processQueue, messageQueue);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                  <span class="keyword">for</span> (; total &lt; msgs.size(); total++) &#123;</span><br><span class="line">                      msgThis.add(msgs.get(total));</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于ConsumeRequest是一个任务，所以我们可以看看它的run方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">          <span class="comment">// 得到改消息的Listener</span></span><br><span class="line">          MessageListenerConcurrently listener = ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.messageListener;</span><br><span class="line">          ConsumeConcurrentlyContext context = <span class="keyword">new</span> ConsumeConcurrentlyContext(messageQueue);</span><br><span class="line">          ConsumeConcurrentlyStatus status = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">          ConsumeMessageContext consumeMessageContext = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">              consumeMessageContext = <span class="keyword">new</span> ConsumeMessageContext();</span><br><span class="line">              consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">              consumeMessageContext.setProps(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">              consumeMessageContext.setMq(messageQueue);</span><br><span class="line">              consumeMessageContext.setMsgList(msgs);</span><br><span class="line">              consumeMessageContext.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">              ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line">          <span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">          ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.resetRetryTopic(msgs);</span><br><span class="line">              <span class="keyword">if</span> (msgs != <span class="keyword">null</span> &amp;&amp; !msgs.isEmpty()) &#123;</span><br><span class="line">                  <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                      MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// listener执行回调逻辑</span></span><br><span class="line">              status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">              log.warn(<span class="string">"consumeMessage exception: &#123;&#125; Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;"</span>,</span><br><span class="line">                  RemotingHelper.exceptionSimpleDesc(e),</span><br><span class="line">                  ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup,</span><br><span class="line">                  msgs,</span><br><span class="line">                  messageQueue);</span><br><span class="line">              hasException = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">long</span> consumeRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">        	<span class="comment">// 设置消费结果</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">null</span> == status) &#123;</span><br><span class="line">              <span class="keyword">if</span> (hasException) &#123;</span><br><span class="line">                  returnType = ConsumeReturnType.EXCEPTION;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  returnType = ConsumeReturnType.RETURNNULL;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (consumeRT &gt;= defaultMQPushConsumer.getConsumeTimeout() * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">              returnType = ConsumeReturnType.TIME_OUT;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConsumeConcurrentlyStatus.RECONSUME_LATER == status) &#123;</span><br><span class="line">              returnType = ConsumeReturnType.FAILED;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status) &#123;</span><br><span class="line">              returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">              consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());</span><br><span class="line">          &#125;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">          <span class="keyword">if</span> (!processQueue.isDropped()) &#123;</span><br><span class="line">              <span class="comment">// 处理消费结果</span></span><br><span class="line">              ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.processConsumeResult(status, context, <span class="keyword">this</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              log.warn(<span class="string">"processQueue is dropped without process consume result. messageQueue=&#123;&#125;, msgs=&#123;&#125;"</span>, messageQueue, msgs);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConsumeResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ConsumeConcurrentlyStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ConsumeConcurrentlyContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ConsumeRequest consumeRequest</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> ackIndex = context.getAckIndex();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (consumeRequest.getMsgs().isEmpty())</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 设置消费状态</span></span><br><span class="line">      <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">          <span class="comment">// 消费成功</span></span><br><span class="line">          <span class="keyword">case</span> CONSUME_SUCCESS:</span><br><span class="line">              <span class="keyword">if</span> (ackIndex &gt;= consumeRequest.getMsgs().size()) &#123;</span><br><span class="line">                  ackIndex = consumeRequest.getMsgs().size() - <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">int</span> ok = ackIndex + <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">int</span> failed = consumeRequest.getMsgs().size() - ok;</span><br><span class="line">              <span class="keyword">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok);</span><br><span class="line">              <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 重新消费</span></span><br><span class="line">          <span class="keyword">case</span> RECONSUME_LATER:</span><br><span class="line">              ackIndex = -<span class="number">1</span>;</span><br><span class="line">              <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(),</span><br><span class="line">                  consumeRequest.getMsgs().size());</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">          <span class="comment">// broadcast模式，处理失败，不做处理</span></span><br><span class="line">          <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                  MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                  log.warn(<span class="string">"BROADCASTING, the message consume failed, drop it, &#123;&#125;"</span>, msg.toString());</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">              List&lt;MessageExt&gt; msgBackFailed = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeRequest.getMsgs().size());</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                  MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                  <span class="comment">// Cluster模式，将消息发回broker，让broker重新发送</span></span><br><span class="line">                  <span class="comment">// 一共有两种方式让broker重发(有兴趣自己去看看): </span></span><br><span class="line">                  <span class="comment">// 1. 先尝试给broker发送send_msg_back的命令，</span></span><br><span class="line">                  <span class="comment">// 2. 如果失败了，则通过consumer预留的producer给%RETRY%groupname发送消息，等于是自己给自己发一条消息。</span></span><br><span class="line">                  <span class="keyword">boolean</span> result = <span class="keyword">this</span>.sendMessageBack(msg, context);</span><br><span class="line">                  <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                      msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line">                      msgBackFailed.add(msg);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (!msgBackFailed.isEmpty()) &#123;</span><br><span class="line">                  consumeRequest.getMsgs().removeAll(msgBackFailed);</span><br><span class="line">                  <span class="comment">// 发回broker失败，则再次尝试本地消费</span></span><br><span class="line">                  <span class="keyword">this</span>.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将消费前缓存的消息清除</span></span><br><span class="line">      <span class="keyword">long</span> offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</span><br><span class="line">      <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们也基本上吧消息消费的流程走完了， 现在可以再回头看看流程图，如果能对的上就OK啦！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/dd2202cc22ea" target="_blank" rel="noopener">RocketMQ源码解析(四)-Consumer</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：当消息达到Broker之后，就等着Consumer去consume了呀~
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>Seata源码解析——环境搭建</title>
    <link href="http://bestlixiang.site/2019/06/16/Seata%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Seata%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://bestlixiang.site/2019/06/16/Seata源码分析/Seata源码解析——环境搭建/</id>
    <published>2019-06-16T02:18:22.000Z</published>
    <updated>2019-06-16T02:22:00.631Z</updated>
    
    <content type="html"><![CDATA[<p>引：2019 年 1 月，阿里巴巴中间件团队发起了开源项目 <strong>Fescar（Fast &amp; EaSy Commit And Rollback）</strong>，和社区一起共建开源分布式事务解决方案。Fescar 的愿景是让分布式事务的使用像本地事务的使用一样，简单和高效，并逐步解决开发者们遇到的分布式事务方面的所有难题。为了打造更中立、更开放、生态更加丰富的分布式事务开源社区，经过社区核心成员的投票，大家决定对 <strong>Fescar </strong>进行品牌升级，并更名为 <strong>Seata</strong>，意为：<strong>Simple Extensible Autonomous Transaction Architecture</strong>，是一套一站式<strong>分布式事务</strong>解决方案。<a id="more"></a></p>
<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p>还是那句话：<br><strong>源码，是原理的具象化</strong><br><strong>原理，是代码的抽象化</strong></p>
<p>所以在开始看源码前一定要好好了解Seata的使用方式以及原理，喜欢Seata的<a href="https://github.com/seata/seata/wiki" target="_blank" rel="noopener">wiki</a>。</p>
<h1 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h1><ol>
<li>Git</li>
<li>Maven</li>
<li>JDK1.8</li>
<li>IntelliJ IDEA</li>
<li>Mysql</li>
</ol>
<h1 id="源码拉取"><a href="#源码拉取" class="headerlink" title="源码拉取"></a>源码拉取</h1><p>好像是在fescar升级到seata的时候，项目将samples抽出成一个独立的项目了，所以我们需要拉两个工程的代码：</p>
<ol>
<li><a href="https://github.com/seata/seata" target="_blank" rel="noopener">seata</a></li>
<li><a href="https://github.com/seata/seata-samples" target="_blank" rel="noopener">seata-samples</a></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/seata/seata.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/seata/seata-samples.git</span><br></pre></td></tr></table></figure>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="启动Seata-Server"><a href="#启动Seata-Server" class="headerlink" title="启动Seata Server"></a>启动Seata Server</h2><p>在seata工程中找到<code>io.seata.server.Server</code>，直接点击运行main方法即可，我们可以看到如下输出日志：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-06-16 09:11:11.542 INFO [main]io.seata.core.rpc.netty.AbstractRpcRemotingServer.start:176 -Server started ...</span><br></pre></td></tr></table></figure>
<h2 id="启动Seata-samples"><a href="#启动Seata-samples" class="headerlink" title="启动Seata-samples"></a>启动Seata-samples</h2><p>seata-samples项目中提供了各种Demo，我们这里选择最简单的一种好了——dubbo。</p>
<h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><p>使用mysql</p>
<ol>
<li>创建数据库：fescar_demo</li>
<li>执行seata-samples/dubbo/src/main/resources/sql/dubbo_biz.sql</li>
<li>执行seata-samples/dubbo/src/main/resources/sql/undo_log.sql</li>
</ol>
<h3 id="启动基础服务"><a href="#启动基础服务" class="headerlink" title="启动基础服务"></a>启动基础服务</h3><ol>
<li><p>DubboAccountServiceStarter</p>
<p>找到<code>io.seata.samples.dubbo.starter.DubboAccountServiceStarter</code>，直接点击运行main方法，在当前线程下，我们没有看到日志，但是在Server端，我们可以看到下面的日志，就代码Rm已经注册成功啦，同时在数据库<code>account_tbl</code>表中插入了一条记录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-06-16 09:32:45.562 INFO [ServerHandlerThread_1_500]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegRmMessage:112 -rm register success,message:RegisterRMRequest&#123;resourceIds=<span class="string">'jdbc:mysql://127.0.0.1:3306/seata'</span>, applicationId=<span class="string">'dubbo-demo-account-service'</span>, transactionServiceGroup=<span class="string">'my_test_tx_group'</span>&#125;,channel:[id: 0xcbff48be, L:/127.0.0.1:8091 - R:/127.0.0.1:54122]</span><br><span class="line">2019-06-16 09:32:48.139 INFO [NettyServerNIOWorker_2_8]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegTmMessage:128 -checkAuth <span class="keyword">for</span> client:127.0.0.1:54123 vgroup:my_test_tx_group ok</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-10458e4af725f5fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="acount.png"></p>
<ol>
<li><p>DubboStorageServiceStarter</p>
<p>找到<code>io.seata.samples.dubbo.starter.DubboStorageServiceStarter</code>，直接点击运行main方法，在当前线程下，我们没有看到日志，但是在Server端，我们可以看到下面的日志，就代码Rm已经注册成功啦，同时在数据库<code>storage_tbl</code>表中插入了一条记录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-06-16 09:41:06.227 INFO [ServerHandlerThread_2_500]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegRmMessage:112 -rm register success,message:RegisterRMRequest&#123;resourceIds=<span class="string">'jdbc:mysql://127.0.0.1:3306/seata'</span>, applicationId=<span class="string">'dubbo-demo-storage-service'</span>, transactionServiceGroup=<span class="string">'my_test_tx_group'</span>&#125;,channel:[id: 0xf37dc389, L:/127.0.0.1:8091 - R:/127.0.0.1:54214]</span><br><span class="line">2019-06-16 09:41:08.969 INFO [NettyServerNIOWorker_4_8]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegTmMessage:128 -checkAuth <span class="keyword">for</span> client:127.0.0.1:54215 vgroup:my_test_tx_group ok</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-a48b6dba285bba5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="storage.png"></p>
<ol>
<li><p>DubboOrderServiceStarter</p>
<p>找到<code>io.seata.samples.dubbo.DubboOrderServiceStarter</code>，直接点击运行main方法，在当前线程下，我们没有看到日志，但是在Server端，我们可以看到下面的日志，就代码Rm已经注册成功啦：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-06-16 09:44:18.384 INFO [ServerHandlerThread_3_500]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegRmMessage:112 -rm register success,message:RegisterRMRequest&#123;resourceIds=<span class="string">'jdbc:mysql://127.0.0.1.200:3306/seata'</span>, applicationId=<span class="string">'dubbo-demo-order-service'</span>, transactionServiceGroup=<span class="string">'my_test_tx_group'</span>&#125;,channel:[id: 0xe370a8ab, L:/127.0.0.1:8091 - R:/127.0.0.1:54259]</span><br><span class="line">2019-06-16 09:44:21.333 INFO [NettyServerNIOWorker_6_8]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegTmMessage:128 -checkAuth <span class="keyword">for</span> client:127.0.0.1:54261 vgroup:my_test_tx_group ok</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="测试分布式事务"><a href="#测试分布式事务" class="headerlink" title="测试分布式事务"></a>测试分布式事务</h3><p>找到<code>io.seata.samples.dubbo.DubboBusinessTester</code> 这里执行的是一个购买的方法，会先调用库存服务扣减库存，然后调用订单服务生产订单，在生成订单之前，他还会调用扣减账户余额的服务，这样会形成一个微服务链路。</p>
<h4 id="正常提交"><a href="#正常提交" class="headerlink" title="正常提交"></a>正常提交</h4><p>我们先把<code>io.seata.samples.dubbo.service.impl#purchase</code>方法中的异常给注释掉：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purchase</span><span class="params">(String userId, String commodityCode, <span class="keyword">int</span> orderCount)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"purchase begin ... xid: "</span> + RootContext.getXID());</span><br><span class="line">    storageService.deduct(commodityCode, orderCount);</span><br><span class="line">    orderService.create(userId, commodityCode, orderCount);</span><br><span class="line">    <span class="comment">// throw new RuntimeException("xxx");</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后点击运行<code>io.seata.samples.dubbo.DubboBusinessTester#main</code>方法，我们看到方法正常结束，并且表中数据发送了如下变化：<br><img src="https://upload-images.jianshu.io/upload_images/10354196-cb3b6179b4da2d8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="normal-acount.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-42255f8875371e19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="normal-storage.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-e8586aefc68ed8e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="normal-order.png"></p>
<h4 id="异常回滚"><a href="#异常回滚" class="headerlink" title="异常回滚"></a>异常回滚</h4><p>我们先把<code>io.seata.samples.dubbo.service.impl#purchase</code>方法中的异常的注释给放开, 为了更好的看到回滚的过程，我们在抛出异常的那一行代码前面加上<strong>断点</strong>，然后debug运行<code>io.seata.samples.dubbo.DubboBusinessTester#main</code>方法，执行到断点，我们看看数据库的变化：<br><img src="https://upload-images.jianshu.io/upload_images/10354196-53d207bcb1f6e4f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="exception-account.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-3ecd332b64ce4500.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="exception-storage.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-d2b1f11253b620e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="exception-order.png"></p>
<p>我们看到数据其实都已经有了一些变化，然后看看很重要的  <code>undo_log</code>表，发现它也生成了一些记录，不过这里先不管：<br><img src="https://upload-images.jianshu.io/upload_images/10354196-521fd48999566ecc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="undo_log.png"></p>
<p>我们放开断点之后看到方法执行抛出了异常，同时表中数据变成了上面正常提交的数据，同时<code>undo_log</code>表也被清空了，从这里可以看出seata确实是帮我们实现了<strong>分布式事务</strong>。</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>好了，环境到这里就搭建结束了，关于seata代码上是如何实现分布式事务的，我们慢慢来分析~</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/seata/seata/wiki" target="_blank" rel="noopener">Seata Wiki</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：2019 年 1 月，阿里巴巴中间件团队发起了开源项目 &lt;strong&gt;Fescar（Fast &amp;amp; EaSy Commit And Rollback）&lt;/strong&gt;，和社区一起共建开源分布式事务解决方案。Fescar 的愿景是让分布式事务的使用像本地事务的使用一样，简单和高效，并逐步解决开发者们遇到的分布式事务方面的所有难题。为了打造更中立、更开放、生态更加丰富的分布式事务开源社区，经过社区核心成员的投票，大家决定对 &lt;strong&gt;Fescar &lt;/strong&gt;进行品牌升级，并更名为 &lt;strong&gt;Seata&lt;/strong&gt;，意为：&lt;strong&gt;Simple Extensible Autonomous Transaction Architecture&lt;/strong&gt;，是一套一站式&lt;strong&gt;分布式事务&lt;/strong&gt;解决方案。
    
    </summary>
    
      <category term="Seata源码" scheme="http://bestlixiang.site/categories/Seata%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Seata" scheme="http://bestlixiang.site/tags/Seata/"/>
    
      <category term="分布式事务" scheme="http://bestlixiang.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——Producer</title>
    <link href="http://bestlixiang.site/2019/06/15/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Producer/"/>
    <id>http://bestlixiang.site/2019/06/15/RocketMQ源码/RocketMQ源码分析——Producer/</id>
    <published>2019-06-15T06:46:21.000Z</published>
    <updated>2019-06-15T06:50:11.364Z</updated>
    
    <content type="html"><![CDATA[<p>引：使用MQ，第一步构造Producer，然后就可以开始发送消息啦！<a id="more"></a></p>
<h1 id="发送方式"><a href="#发送方式" class="headerlink" title="发送方式"></a>发送方式</h1><p>producer发送消息支持3种方式，同步、异步和Oneway。</p>
<ul>
<li>同步发送：客户端提交消息到broker后会等待返回结果。有可靠性保障。</li>
<li>异步发送：调用发送接口时会注册一个callback类，发送线程继续其它业务逻辑，producer在收到broker结果后回调。当消息结果不影响正常业务逻辑的时候使用。</li>
<li>Oneway：Producer提交消息后，无论broker是否正常接收消息都不关心。适合于追求高吞吐、能容忍消息丢失的场景，比如日志收集。</li>
</ul>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>我们主要讲同步发送，异步发送和Oneway方式和事务消息带过，同步发送例子就是环境搭建中Producer的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化一个Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指明Namesrv</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                    <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                    (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">                );</span><br><span class="line">                SendResult sendResult = producer.send(msg);</span><br><span class="line">                System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面我们实例化一个DefaultMQProducer，设置group name和nameserv的地址。Producer启动后就可以往指定的topic发送消息啦！</p>
<h1 id="Producer启动"><a href="#Producer启动" class="headerlink" title="Producer启动"></a>Producer启动</h1><h2 id="DefaultMQProducer初始化"><a href="#DefaultMQProducer初始化" class="headerlink" title="DefaultMQProducer初始化"></a>DefaultMQProducer初始化</h2><p>下面代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.client.producer.DefaultMQProducer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(producerGroup, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup, RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.producerGroup = producerGroup;</span><br><span class="line">        <span class="comment">// DefaultMQProducer包装了DefaultMQProducerImpl</span></span><br><span class="line">        defaultMQProducerImpl = <span class="keyword">new</span> DefaultMQProducerImpl(<span class="keyword">this</span>, rpcHook);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducerImpl</span><span class="params">(<span class="keyword">final</span> DefaultMQProducer defaultMQProducer, RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMQProducer = defaultMQProducer;</span><br><span class="line">        <span class="keyword">this</span>.rpcHook = rpcHook;</span><br><span class="line">        <span class="comment">// 构造了一个同步发送线程池</span></span><br><span class="line">        <span class="keyword">this</span>.asyncSenderThreadPoolQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">50000</span>);</span><br><span class="line">        <span class="keyword">this</span>.defaultAsyncSenderExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            Runtime.getRuntime().availableProcessors(),</span><br><span class="line">            Runtime.getRuntime().availableProcessors(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.asyncSenderThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                <span class="keyword">private</span> AtomicInteger threadIndex = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncSenderExecutor_"</span> + <span class="keyword">this</span>.threadIndex.incrementAndGet());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="DefaultMQProducer启动"><a href="#DefaultMQProducer启动" class="headerlink" title="DefaultMQProducer启动"></a>DefaultMQProducer启动</h2><p>下面代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.client.producer.DefaultMQProducer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="comment">// 调用实际的实现类</span></span><br><span class="line">    <span class="keyword">this</span>.defaultMQProducerImpl.start();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != traceDispatcher) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            traceDispatcher.start(<span class="keyword">this</span>.getNamesrvAddr());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            log.warn(<span class="string">"trace dispatcher start failed "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.start(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> startFactory)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            <span class="comment">// 如果下面的过程中出错了，那么serviceState就为START_FAILED</span></span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">            <span class="comment">// 检查group name是否合适</span></span><br><span class="line">            <span class="keyword">this</span>.checkConfig();</span><br><span class="line">            <span class="comment">// 更改defaultMQProducer的名称为进程id</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// MQClientManager为单例，创建mQClientFactory</span></span><br><span class="line">            <span class="comment">// 一个进程只会存在一个MQClientInstance， 设置clientId （IP@PID）</span></span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQProducer, rpcHook);</span><br><span class="line">            <span class="comment">// 向mQClientFactory注册defaultMQProducer</span></span><br><span class="line">            <span class="keyword">boolean</span> registerOK = mQClientFactory.registerProducer(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup(), <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer group["</span> + <span class="keyword">this</span>.defaultMQProducer.getProducerGroup()</span><br><span class="line">                    + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加默认的topicPublishInfo</span></span><br><span class="line">            <span class="keyword">this</span>.topicPublishInfoTable.put(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey(), <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (startFactory) &#123;</span><br><span class="line">                <span class="comment">// 核心</span></span><br><span class="line">                <span class="comment">// 启动MQClientInstance</span></span><br><span class="line">                mQClientFactory.start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">"the producer [&#123;&#125;] start OK. sendMessageWithVIPChannel=&#123;&#125;"</span>, <span class="keyword">this</span>.defaultMQProducer.getProducerGroup(),</span><br><span class="line">                <span class="keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel());</span><br><span class="line">            <span class="comment">// 启动完成</span></span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">        <span class="keyword">case</span> START_FAILED:</span><br><span class="line">        <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer service state not OK, maybe started once, "</span></span><br><span class="line">                + <span class="keyword">this</span>.serviceState</span><br><span class="line">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向所有broker发送一次心跳</span></span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到DefaultMQProducer 的start的过程主要就是初始化和启动一个MQClientInstance，将producer注册到instance中。我们来看下MQClientInstance的启动过程。</p>
<h2 id="MQClientInstance启动"><a href="#MQClientInstance启动" class="headerlink" title="MQClientInstance启动"></a>MQClientInstance启动</h2><p>下面是启动代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">                <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">                    <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">                    <span class="comment">// If not specified,looking address from name server</span></span><br><span class="line">                    <span class="comment">// 如果NameservAddr为空，尝试从http server获取nameserv的地址</span></span><br><span class="line">                    <span class="comment">// 这里看出适合于有统一配置中心的系统</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Start request-response channel</span></span><br><span class="line">                    <span class="comment">// 初始化Netty客户端</span></span><br><span class="line">                    <span class="keyword">this</span>.mQClientAPIImpl.start();</span><br><span class="line">                    <span class="comment">// Start various schedule tasks</span></span><br><span class="line">                    <span class="comment">// 开启各种定时任务</span></span><br><span class="line">                    <span class="keyword">this</span>.startScheduledTask();</span><br><span class="line">                    <span class="comment">// Start pull service</span></span><br><span class="line">                    <span class="comment">// producer和consumer公用一个MQClientInstance的实现</span></span><br><span class="line">                    <span class="comment">// 开启拉消息服务(Consumer)</span></span><br><span class="line">                    <span class="keyword">this</span>.pullMessageService.start();</span><br><span class="line">                    <span class="comment">// Start rebalance service</span></span><br><span class="line">                    <span class="comment">// 开启负载均衡服务</span></span><br><span class="line">                    <span class="keyword">this</span>.rebalanceService.start();</span><br><span class="line">                    <span class="comment">// Start push service</span></span><br><span class="line">                    <span class="comment">// 开启Producer</span></span><br><span class="line">                    <span class="keyword">this</span>.defaultMQProducer.getDefaultMQProducerImpl().start(<span class="keyword">false</span>);</span><br><span class="line">                    log.info(<span class="string">"the client factory [&#123;&#125;] start OK"</span>, <span class="keyword">this</span>.clientId);</span><br><span class="line">                    <span class="comment">// 更改client状态</span></span><br><span class="line">                    <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RUNNING:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> START_FAILED:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The Factory object["</span> + <span class="keyword">this</span>.getClientId() + <span class="string">"] has been created before, and failed."</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看看它起了哪些定时任务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startScheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">        <span class="comment">// 获取nameserv地址</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    MQClientInstance.<span class="keyword">this</span>.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"ScheduledTask fetchNameServerAddr exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从nameserv更新topicRouteInfo</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MQClientInstance.<span class="keyword">this</span>.updateTopicRouteInfoFromNameServer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"ScheduledTask updateTopicRouteInfoFromNameServer exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPollNameServerInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除已经下线的broker，并发送心跳</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MQClientInstance.<span class="keyword">this</span>.cleanOfflineBroker();</span><br><span class="line">                MQClientInstance.<span class="keyword">this</span>.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"ScheduledTask sendHeartbeatToAllBroker exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>, <span class="keyword">this</span>.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持久化消费者的Offset(Consumer)</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MQClientInstance.<span class="keyword">this</span>.persistAllConsumerOffset();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"ScheduledTask persistAllConsumerOffset exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态调整消费者的线程池（Consumer）</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MQClientInstance.<span class="keyword">this</span>.adjustThreadPool();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"ScheduledTask adjustThreadPool exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，我们的Producer就启动完成了，接下来我们就可以看看它是怎么发送消息啦！</p>
<h1 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h1><p>Producer默认采用同步方式发送消息，如我们的示例，接下来我们看看这个方法<code>DefaultMQProducer.send( Message msg)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.client.producer.DefaultMQProducer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Message msg)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.defaultMQProducerImpl.send(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.producer.defaultMQProducerImpl</span></span><br><span class="line"><span class="comment">// 超时时间3秒</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Message msg)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> send(msg, <span class="keyword">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到默认采用同步方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sendDefaultImpl(msg, CommunicationMode.SYNC, <span class="keyword">null</span>, timeout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际发送逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendDefaultImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> CommunicationMode communicationMode,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> SendCallback sendCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">long</span> timeout</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 检查client状态是否是runing</span></span><br><span class="line">    <span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line">    <span class="comment">// 参数校验，消息不能发给系统预留的topic，消息体不能超过最大长度4M，或者是空消息</span></span><br><span class="line">    Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> invokeID = random.nextLong();</span><br><span class="line">    <span class="keyword">long</span> beginTimestampFirst = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> beginTimestampPrev = beginTimestampFirst;</span><br><span class="line">    <span class="keyword">long</span> endTimestamp = beginTimestampFirst;</span><br><span class="line">    <span class="comment">// 根据消息的topic，获取该topic的路由信息</span></span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> callTimeout = <span class="keyword">false</span>;</span><br><span class="line">        MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line">        Exception exception = <span class="keyword">null</span>;</span><br><span class="line">        SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 重试次数，同步模式下默认为3次</span></span><br><span class="line">        <span class="keyword">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">        String[] brokersSent = <span class="keyword">new</span> String[timesTotal];</span><br><span class="line">        <span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</span><br><span class="line">            <span class="comment">// 记录上次的发送的broker</span></span><br><span class="line">            String lastBrokerName = <span class="keyword">null</span> == mq ? <span class="keyword">null</span> : mq.getBrokerName();</span><br><span class="line">            <span class="comment">// 从所有topic可用queue中选择一个queue，有不同的策略</span></span><br><span class="line">            MessageQueue mqSelected = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line">            <span class="keyword">if</span> (mqSelected != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mq = mqSelected;</span><br><span class="line">                <span class="comment">// 记录下当前的broker</span></span><br><span class="line">                brokersSent[times] = mq.getBrokerName();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">long</span> costTime = beginTimestampPrev - beginTimestampFirst;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTime) &#123;</span><br><span class="line">                        callTimeout = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 发送消息</span></span><br><span class="line">                    sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);</span><br><span class="line">                    endTimestamp = System.currentTimeMillis();</span><br><span class="line">                    <span class="comment">// 更新本次调用时间到MQFaultStrategy中</span></span><br><span class="line">                    <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">                        <span class="comment">// 异步和ONEWAY方式调用后就直接返回了</span></span><br><span class="line">                        <span class="keyword">case</span> ASYNC:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">case</span> SYNC:</span><br><span class="line">                            <span class="comment">// 发送没成功</span></span><br><span class="line">                            <span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">                                <span class="comment">// 如果broker存储失败，判断是否要重试</span></span><br><span class="line">                                <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">return</span> sendResult;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                    <span class="comment">// 省略异常</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 成功则返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (sendResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sendResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略不重要逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面完整的发送逻辑信息量还是比较大的，我们具体看看几个重要的部分。</p>
<h2 id="获取topic路由信息"><a href="#获取topic路由信息" class="headerlink" title="获取topic路由信息"></a>获取topic路由信息</h2><p>关注<code>DefaultMQProducerImpl#tryToFindTopicPublishInfo()</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TopicPublishInfo <span class="title">tryToFindTopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从本地缓存获取，之前看到过有定时任务会定时更新这个缓存</span></span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="comment">// 如果不存在，则从Namesrv加锁更新TopicRouteInfo ，使用Netty</span></span><br><span class="line">        <span class="keyword">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="comment">// 若获取的 Topic发布信息时候可用，则返回</span></span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当从Namesrv获取不到时，如果允许broker自动创建topic信息则自动创建并更新</span></span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, <span class="keyword">true</span>, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Queue选取策略"><a href="#Queue选取策略" class="headerlink" title="Queue选取策略"></a>Queue选取策略</h2><p>Queue的选取是采用轮询的方式，如果客户端开启延迟容错，那么在轮询的时候会加入broker可用性的判断。<br>关注<code>DefaultMQProducerImpl#selectOneMessageQueue()</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MQFaultStrategy mqFaultStrategy = <span class="keyword">new</span> MQFaultStrategy();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mqFaultStrategy.selectOneMessageQueue(tpInfo, lastBrokerName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.latency.MQFaultStrategy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果开启了延时容错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 首先获取上次使用的Queue index+1，这个index是放在ThreadLocal下</span></span><br><span class="line">            <span class="comment">// 实现了轮询的效果，但是在重试的时候是为了选择上一次发送的broker</span></span><br><span class="line">            <span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                    pos = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 找到index对应的queue</span></span><br><span class="line">                MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</span><br><span class="line">                <span class="comment">// 如果queue对应的broker可用（根据faultItemTable判断），则使用该broker</span></span><br><span class="line">                <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line">                    <span class="comment">// 第一次发送或者是重试，直接选</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line">                        <span class="keyword">return</span> mq;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找个合适的broker，则从所有的broker中选择一个相对合适的，并且是可写的broker</span></span><br><span class="line">            <span class="comment">// 相对合适是指 可用/延迟低/上次不可用时间早</span></span><br><span class="line">            <span class="keyword">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</span><br><span class="line">            <span class="keyword">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</span><br><span class="line">            <span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</span><br><span class="line">                <span class="keyword">if</span> (notBestBroker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mq.setBrokerName(notBestBroker);</span><br><span class="line">                    mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                latencyFaultTolerance.remove(notBestBroker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error occurred when selecting message queue"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tpInfo.selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未开启延时容错，直接按顺序选下一个</span></span><br><span class="line">    <span class="keyword">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于queue选择有很多细节可以说，看以后是不是单独拎出来说一下，这里给个延迟的结论：当发送时长低于100ms时，设置broker不可用时长为0，之后依次增加，如果超过15秒，则有10分钟不可用。可以看到如果上次发送失败的话，也是10分钟不可用，如果重试肯定不会选择相同的broker，即不会选择不可用的broker。</p>
<h2 id="消息发送-1"><a href="#消息发送-1" class="headerlink" title="消息发送"></a>消息发送</h2><p>关注DefaultMQProducerImpl#sendKernelImpl()方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendKernelImpl</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> MessageQueue mq,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> CommunicationMode communicationMode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> SendCallback sendCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> TopicPublishInfo topicPublishInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> beginStartTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 根据brokerName从缓存中获取broker的地址</span></span><br><span class="line">    String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">    <span class="comment">// 如果地址为空，则从namesrv中再获取一次</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddr) &#123;</span><br><span class="line">        tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line">        <span class="comment">// 重新获取</span></span><br><span class="line">        brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SendMessageContext context = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (brokerAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 切换到VIP channel</span></span><br><span class="line">        <span class="comment">// Broker启动时会开启2个端口接收客户端数据，其中一个端口只接收producer的消息，不接受consumer的拉取请求，被称为VIP channel</span></span><br><span class="line">        brokerAddr = MixAll.brokerVIPChannel(<span class="keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] prevBody = msg.getBody();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//for MessageBatch,ID has been set in the generating process</span></span><br><span class="line">            <span class="comment">// 如果不是批量发送则客户端设置的id</span></span><br><span class="line">            <span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line">                MessageClientIDSetter.setUniqID(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sysFlag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> msgBodyCompressed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果消息body过长，则压缩并设置标记位</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tryToCompressMessage(msg)) &#123;</span><br><span class="line">                sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line">                msgBodyCompressed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 事务消息标记</span></span><br><span class="line">            <span class="keyword">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">            <span class="keyword">if</span> (tranMsg != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line">                sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 省略不重要逻辑</span></span><br><span class="line">            <span class="comment">// 设置消息头</span></span><br><span class="line">            SendMessageRequestHeader requestHeader = <span class="keyword">new</span> SendMessageRequestHeader();</span><br><span class="line">            requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">            requestHeader.setTopic(msg.getTopic());</span><br><span class="line">            requestHeader.setDefaultTopic(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey());</span><br><span class="line">            requestHeader.setDefaultTopicQueueNums(<span class="keyword">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</span><br><span class="line">            requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">            requestHeader.setSysFlag(sysFlag);</span><br><span class="line">            requestHeader.setBornTimestamp(System.currentTimeMillis());</span><br><span class="line">            requestHeader.setFlag(msg.getFlag());</span><br><span class="line">            requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line">            requestHeader.setReconsumeTimes(<span class="number">0</span>);</span><br><span class="line">            requestHeader.setUnitMode(<span class="keyword">this</span>.isUnitMode());</span><br><span class="line">            requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);</span><br><span class="line">            <span class="comment">// 要求重新发送的消息，设置重试次数和延时时间</span></span><br><span class="line">            <span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</span><br><span class="line">                <span class="keyword">if</span> (reconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line">                <span class="keyword">if</span> (maxReconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 通过NettyClient发送消息到Broker</span></span><br><span class="line">            <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">                <span class="keyword">case</span> ASYNC:</span><br><span class="line">                    Message tmpMessage = msg;</span><br><span class="line">                    <span class="keyword">if</span> (msgBodyCompressed) &#123;</span><br><span class="line">                        <span class="comment">//If msg body was compressed, msgbody should be reset using prevBody.</span></span><br><span class="line">                        <span class="comment">//Clone new message using commpressed message body and recover origin massage.</span></span><br><span class="line">                        <span class="comment">//Fix bug:https://github.com/apache/rocketmq-externals/issues/66</span></span><br><span class="line">                        tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">                        msg.setBody(prevBody);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">long</span> costTimeAsync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTimeAsync) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendKernelImpl call timeout"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 实际发送消息的位置</span></span><br><span class="line">                    sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">                        brokerAddr,</span><br><span class="line">                        mq.getBrokerName(),</span><br><span class="line">                        tmpMessage,</span><br><span class="line">                        requestHeader,</span><br><span class="line">                        timeout - costTimeAsync,</span><br><span class="line">                        communicationMode,</span><br><span class="line">                        sendCallback,</span><br><span class="line">                        topicPublishInfo,</span><br><span class="line">                        <span class="keyword">this</span>.mQClientFactory,</span><br><span class="line">                        <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),</span><br><span class="line">                        context,</span><br><span class="line">                        <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                <span class="keyword">case</span> SYNC:</span><br><span class="line">                    <span class="keyword">long</span> costTimeSync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTimeSync) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendKernelImpl call timeout"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">                        brokerAddr,</span><br><span class="line">                        mq.getBrokerName(),</span><br><span class="line">                        msg,</span><br><span class="line">                        requestHeader,</span><br><span class="line">                        timeout - costTimeSync,</span><br><span class="line">                        communicationMode,</span><br><span class="line">                        context,</span><br><span class="line">                        <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">                context.setSendResult(sendResult);</span><br><span class="line">                <span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> sendResult;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">           <span class="comment">// ... 省略异常处理</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            msg.setBody(prevBody);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The broker["</span> + mq.getBrokerName() + <span class="string">"] not exist"</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里就结束了！除了队列选择逻辑有点复杂，其他还好，但是还是要好好去体会~</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/02dbc0710f80" target="_blank" rel="noopener">RocketMQ源码解析(三)-Producer</a></li>
<li><a href="[http://b.shiwuliang.com/RocketMQ%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E4%B9%8B%E9%80%89%E6%8B%A9%E9%98%9F%E5%88%97%E5%B9%B6%E5%8F%91%E9%80%81.html](http://b.shiwuliang.com/RocketMQ%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E4%B9%8B%E9%80%89%E6%8B%A9%E9%98%9F%E5%88%97%E5%B9%B6%E5%8F%91%E9%80%81.html">RocketMQ源码解读——消息发送之选择队列并发送</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：使用MQ，第一步构造Producer，然后就可以开始发送消息啦！
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——Namesrv</title>
    <link href="http://bestlixiang.site/2019/06/09/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Namesrv/"/>
    <id>http://bestlixiang.site/2019/06/09/RocketMQ源码/RocketMQ源码分析——Namesrv/</id>
    <published>2019-06-09T10:17:12.000Z</published>
    <updated>2019-06-09T10:19:31.294Z</updated>
    
    <content type="html"><![CDATA[<p>引：NameSrv是RocketMQ的注册中心，保存所有Broker、Topic的元数据。Broker启动后会向namesrv发送心跳，namesrv也会定时检测broker的可用性，并移除不可用的broker。对于生产者和消费者来说，它提供了Broker的查询服务。<a id="more"></a></p>
<h1 id="NameSrv启动"><a href="#NameSrv启动" class="headerlink" title="NameSrv启动"></a>NameSrv启动</h1><p>我们按照按照上一篇环境搭建的<code>#org.apache.rocketmq.namesrv.NameServerInstanceTest</code>出发，我们看到Main函数，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    NamesrvConfig namesrvConfig1 = <span class="keyword">new</span> NamesrvConfig();</span><br><span class="line">    NettyServerConfig nettyServerConfig1 = <span class="keyword">new</span> NettyServerConfig();</span><br><span class="line">    nettyServerConfig1.setListenPort(<span class="number">9876</span>);</span><br><span class="line">    NamesrvController nameSrvController1 = <span class="keyword">new</span> NamesrvController(namesrvConfig1, nettyServerConfig1);</span><br><span class="line">    nameSrvController1.initialize();</span><br><span class="line">    nameSrvController1.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不让主方法结束</span></span><br><span class="line">    Thread.sleep(DateUtils.MILLIS_PER_DAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现主要有三个步骤：</p>
<ol>
<li>构造NamesrvController</li>
<li>初始化NamesrvController</li>
<li>启动NamesrvController</li>
</ol>
<p>可见NamesrvController是关键，负责初始化和后台任务启动。</p>
<h2 id="构造NamesrvController"><a href="#构造NamesrvController" class="headerlink" title="构造NamesrvController"></a>构造NamesrvController</h2><p><code>org.apache.rocketmq.namesrv.NamesrvController</code>的构造函数如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NamesrvController</span><span class="params">(NamesrvConfig namesrvConfig, NettyServerConfig nettyServerConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// namesrv参数配置</span></span><br><span class="line">    <span class="keyword">this</span>.namesrvConfig = namesrvConfig;</span><br><span class="line">    <span class="comment">// netty的参数配置</span></span><br><span class="line">    <span class="keyword">this</span>.nettyServerConfig = nettyServerConfig;</span><br><span class="line">    <span class="comment">// KVConfigManager绑定NamesrvController</span></span><br><span class="line">    <span class="keyword">this</span>.kvConfigManager = <span class="keyword">new</span> KVConfigManager(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 初始化RouteInfoManager，很重要</span></span><br><span class="line">    <span class="keyword">this</span>.routeInfoManager = <span class="keyword">new</span> RouteInfoManager();</span><br><span class="line">    <span class="comment">// 监听客户端连接(Channel)的变化，通知RouteInfoManager检查broker是否有变化</span></span><br><span class="line">    <span class="keyword">this</span>.brokerHousekeepingService = <span class="keyword">new</span> BrokerHousekeepingService(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.configuration = <span class="keyword">new</span> Configuration(</span><br><span class="line">        log,</span><br><span class="line">        <span class="keyword">this</span>.namesrvConfig, <span class="keyword">this</span>.nettyServerConfig</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// namesrv的配置参数会保存到磁盘文件中</span></span><br><span class="line">    <span class="keyword">this</span>.configuration.setStorePathFromConfig(<span class="keyword">this</span>.namesrvConfig, <span class="string">"configStorePath"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中主要的就是<code>org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager</code> 它负责缓存整个集群的broker信息，以及topic和queue的配置信息。我们看看的内部构造：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读写锁，控制并发读写</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="comment">// Topic和Broker的Queue的Map，保存了topic在每个broker上的读写Queue的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line"><span class="comment">// 注册到namesrv上的所有Broker，按照brokername分组，Broker使用brokerName来标识主从关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;</span><br><span class="line"><span class="comment">// broker的集群对应关系，使用clusterName来判断多个broker是不是属于同一个集群。</span></span><br><span class="line"><span class="comment">// 对于同一个cluster下的broker，producer在发送消息时只会选择发送给其中一个</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable;</span><br><span class="line"><span class="comment">// broker最新的心跳时间和配置版本号，nameserv会记录brokerAddr的最后活跃时间，</span></span><br><span class="line"><span class="comment">// 如果超过一定时间没有心跳或其他数据交互，会认为broker已下线</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;</span><br><span class="line"><span class="comment">// broker和FilterServer的对应关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br></pre></td></tr></table></figure></p>
<p>RouteInfoManager的所有数据通过HashMap缓存在内存中，通过读写锁来控制并发更新。这样可最大程度的提高客户端查询数据的速度。</p>
<h2 id="初始化NamesrvController"><a href="#初始化NamesrvController" class="headerlink" title="初始化NamesrvController"></a>初始化NamesrvController</h2><p>我们看看它的初始化方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化KVConfigManager</span></span><br><span class="line">    <span class="keyword">this</span>.kvConfigManager.load();</span><br><span class="line">    <span class="comment">// 初始化netty server</span></span><br><span class="line">    <span class="keyword">this</span>.remotingServer = <span class="keyword">new</span> NettyRemotingServer(<span class="keyword">this</span>.nettyServerConfig, <span class="keyword">this</span>.brokerHousekeepingService);</span><br><span class="line">    <span class="comment">// 初始化客户端请求处理的线程池</span></span><br><span class="line">    <span class="keyword">this</span>.remotingExecutor =</span><br><span class="line">        Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"RemotingExecutorThread_"</span>));</span><br><span class="line">    <span class="comment">// 注册DefaultRequestProcessor，所有的客户端请求都会转给这个Processor来处理</span></span><br><span class="line">    <span class="comment">// 它的逻辑到时候会出现在NettyServerHandler里</span></span><br><span class="line">    <span class="keyword">this</span>.registerProcessor();</span><br><span class="line">    <span class="comment">// 启动定时调度，每10秒钟扫描所有Broker，检查存活状态</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NamesrvController.<span class="keyword">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">// 日志打印的调度器，定时打印kvConfigManager的内容</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NamesrvController.<span class="keyword">this</span>.kvConfigManager.printAllPeriodically();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">// 监听ssl证书文件变化</span></span><br><span class="line">    <span class="keyword">if</span> (TlsSystemConfig.tlsMode != TlsMode.DISABLED) &#123;</span><br><span class="line">        <span class="comment">// Register a listener to reload SslContext</span></span><br><span class="line">       <span class="comment">// 省略无用逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以稍微看看它是怎样踢出无效链接的，代码在<code>org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager</code>中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanNotActiveBroker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;String, BrokerLiveInfo&gt;&gt; it = <span class="keyword">this</span>.brokerLiveTable.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, BrokerLiveInfo&gt; next = it.next();</span><br><span class="line">        <span class="keyword">long</span> last = next.getValue().getLastUpdateTimestamp();</span><br><span class="line">        <span class="comment">// 默认120秒</span></span><br><span class="line">        <span class="keyword">if</span> ((last + BROKER_CHANNEL_EXPIRED_TIME) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">            RemotingUtil.closeChannel(next.getValue().getChannel());</span><br><span class="line">            it.remove();</span><br><span class="line">            <span class="keyword">this</span>.onChannelDestroy(next.getKey(), next.getValue().getChannel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="启动NamesrvController"><a href="#启动NamesrvController" class="headerlink" title="启动NamesrvController"></a>启动NamesrvController</h2><p>启动的过程就是启动netty server开始接收客户端请求，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 开启Netty Server</span></span><br><span class="line">    <span class="keyword">this</span>.remotingServer.start();</span><br><span class="line">    <span class="comment">// 监听ssl文件变化，可以实时更新证书</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fileWatchService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fileWatchService.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，Namesrv就启动完成了，下面我们将讲一下它最重要的两个功能Broker注册（管理）和Broker查询。</p>
<h1 id="DefaultRequestProcessor请求处理"><a href="#DefaultRequestProcessor请求处理" class="headerlink" title="DefaultRequestProcessor请求处理"></a>DefaultRequestProcessor请求处理</h1><p>在讲Broker注册（管理）和Broker查询之前我们要将一下DefaultRequestProcessor，因为所有请求都会被它处理，在上面初始化的过程中，我们也看到了它被注册到Netty的Pipeline上。<br>下面我就看看<code>org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor #processRequest</code>方法是如何处理请求的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略无用逻辑</span></span><br><span class="line">    <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> RequestCode.PUT_KV_CONFIG:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.putKVConfig(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_KV_CONFIG:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getKVConfig(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.DELETE_KV_CONFIG:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.deleteKVConfig(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.QUERY_DATA_VERSION:</span><br><span class="line">            <span class="keyword">return</span> queryBrokerTopicConfig(ctx, request);</span><br><span class="line">        <span class="comment">// Broker注册</span></span><br><span class="line">        <span class="keyword">case</span> RequestCode.REGISTER_BROKER:</span><br><span class="line">            Version brokerVersion = MQVersion.value2Version(request.getVersion());</span><br><span class="line">            <span class="keyword">if</span> (brokerVersion.ordinal() &gt;= MQVersion.Version.V3_0_11.ordinal()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.registerBrokerWithFilterServer(ctx, request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.registerBroker(ctx, request);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// Broker注销</span></span><br><span class="line">        <span class="keyword">case</span> RequestCode.UNREGISTER_BROKER:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.unregisterBroker(ctx, request);</span><br><span class="line">        <span class="comment">// 根据Topic拿到Broker路由信息</span></span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_ROUTEINTO_BY_TOPIC:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getRouteInfoByTopic(ctx, request);</span><br><span class="line">        <span class="comment">// 拿到Broker集群信息</span></span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_BROKER_CLUSTER_INFO:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getBrokerClusterInfo(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.WIPE_WRITE_PERM_OF_BROKER:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.wipeWritePermOfBroker(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_ALL_TOPIC_LIST_FROM_NAMESERVER:</span><br><span class="line">            <span class="keyword">return</span> getAllTopicListFromNameserver(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.DELETE_TOPIC_IN_NAMESRV:</span><br><span class="line">            <span class="keyword">return</span> deleteTopicInNamesrv(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_KVLIST_BY_NAMESPACE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getKVListByNamespace(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_TOPICS_BY_CLUSTER:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getTopicsByCluster(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_SYSTEM_TOPIC_LIST_FROM_NS:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getSystemTopicListFromNs(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_UNIT_TOPIC_LIST:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getUnitTopicList(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_HAS_UNIT_SUB_TOPIC_LIST:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getHasUnitSubTopicList(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_HAS_UNIT_SUB_UNUNIT_TOPIC_LIST:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getHasUnitSubUnUnitTopicList(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.UPDATE_NAMESRV_CONFIG:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.updateConfig(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_NAMESRV_CONFIG:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getConfig(ctx, request);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理器根据RemotingCommand中的请求码将执行具体的请求逻辑，下面我们重点分析一下Broker注册和查询。</p>
<h1 id="Broker注册"><a href="#Broker注册" class="headerlink" title="Broker注册"></a>Broker注册</h1><p>根据上面DefaultRequestProcessor的处理逻辑，我们找到<code>#registerBroker</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">registerBroker</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(RegisterBrokerResponseHeader.class);</span><br><span class="line">    <span class="keyword">final</span> RegisterBrokerResponseHeader responseHeader = (RegisterBrokerResponseHeader) response.readCustomHeader();</span><br><span class="line">    <span class="keyword">final</span> RegisterBrokerRequestHeader requestHeader =</span><br><span class="line">        (RegisterBrokerRequestHeader) request.decodeCommandCustomHeader(RegisterBrokerRequestHeader.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略校验</span></span><br><span class="line">    <span class="comment">// topic相关配置</span></span><br><span class="line">    TopicConfigSerializeWrapper topicConfigWrapper;</span><br><span class="line">    <span class="keyword">if</span> (request.getBody() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        topicConfigWrapper = TopicConfigSerializeWrapper.decode(request.getBody(), TopicConfigSerializeWrapper.class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        topicConfigWrapper = <span class="keyword">new</span> TopicConfigSerializeWrapper();</span><br><span class="line">        topicConfigWrapper.getDataVersion().setCounter(<span class="keyword">new</span> AtomicLong(<span class="number">0</span>));</span><br><span class="line">        topicConfigWrapper.getDataVersion().setTimestamp(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据broker上报的信息更新namesrv的RouteInfo</span></span><br><span class="line">    RegisterBrokerResult result = <span class="keyword">this</span>.namesrvController.getRouteInfoManager().registerBroker(</span><br><span class="line">        requestHeader.getClusterName(),</span><br><span class="line">        requestHeader.getBrokerAddr(),</span><br><span class="line">        requestHeader.getBrokerName(),</span><br><span class="line">        requestHeader.getBrokerId(),</span><br><span class="line">        requestHeader.getHaServerAddr(),</span><br><span class="line">        topicConfigWrapper,</span><br><span class="line">        <span class="keyword">null</span>,</span><br><span class="line">        ctx.channel()</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 返回master和haserver地址</span></span><br><span class="line">    responseHeader.setHaServerAddr(result.getHaServerAddr());</span><br><span class="line">    responseHeader.setMasterAddr(result.getMasterAddr());</span><br><span class="line">    <span class="comment">// 将topic的KV配置信息通过response返回</span></span><br><span class="line">    <span class="keyword">byte</span>[] jsonValue = <span class="keyword">this</span>.namesrvController.getKvConfigManager().getKVListByNamespace(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG);</span><br><span class="line">    response.setBody(jsonValue);</span><br><span class="line">    response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">    response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们继续看看如何更新namesrv的RouteInfo，找到<code>org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager#registerBroker</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RegisterBrokerResult <span class="title">registerBroker</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String clusterName,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String brokerAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String brokerName,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">long</span> brokerId,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String haServerAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> TopicConfigSerializeWrapper topicConfigWrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> List&lt;String&gt; filterServerList,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Channel channel)</span> </span>&#123;</span><br><span class="line">    RegisterBrokerResult result = <span class="keyword">new</span> RegisterBrokerResult();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 更新加锁</span></span><br><span class="line">            <span class="keyword">this</span>.lock.writeLock().lockInterruptibly();</span><br><span class="line">            <span class="comment">// 更新cluster和broker对应关系</span></span><br><span class="line">            Set&lt;String&gt; brokerNames = <span class="keyword">this</span>.clusterAddrTable.get(clusterName);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == brokerNames) &#123;</span><br><span class="line">                brokerNames = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">                <span class="keyword">this</span>.clusterAddrTable.put(clusterName, brokerNames);</span><br><span class="line">            &#125;</span><br><span class="line">            brokerNames.add(brokerName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> registerFirst = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 更新brokername和brokerdata的分组</span></span><br><span class="line">            BrokerData brokerData = <span class="keyword">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</span><br><span class="line">                registerFirst = <span class="keyword">true</span>;</span><br><span class="line">                brokerData = <span class="keyword">new</span> BrokerData(clusterName, brokerName, <span class="keyword">new</span> HashMap&lt;Long, String&gt;());</span><br><span class="line">                <span class="keyword">this</span>.brokerAddrTable.put(brokerName, brokerData);</span><br><span class="line">            &#125;</span><br><span class="line">            String oldAddr = brokerData.getBrokerAddrs().put(brokerId, brokerAddr);</span><br><span class="line">            registerFirst = registerFirst || (<span class="keyword">null</span> == oldAddr);</span><br><span class="line">            <span class="comment">// 如果是master broker，第一次注册或者是topic信息发生变化了，更新topicQueueTable</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != topicConfigWrapper</span><br><span class="line">                &amp;&amp; MixAll.MASTER_ID == brokerId) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion())</span><br><span class="line">                    || registerFirst) &#123;</span><br><span class="line">                    ConcurrentMap&lt;String, TopicConfig&gt; tcTable =</span><br><span class="line">                        topicConfigWrapper.getTopicConfigTable();</span><br><span class="line">                    <span class="keyword">if</span> (tcTable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.createAndUpdateQueueData(brokerName, entry.getValue());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新broker的心跳时间</span></span><br><span class="line">            BrokerLiveInfo prevBrokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.put(brokerAddr,</span><br><span class="line">                <span class="keyword">new</span> BrokerLiveInfo(</span><br><span class="line">                    System.currentTimeMillis(),</span><br><span class="line">                    topicConfigWrapper.getDataVersion(),</span><br><span class="line">                    channel,</span><br><span class="line">                    haServerAddr));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == prevBrokerLiveInfo) &#123;</span><br><span class="line">                log.info(<span class="string">"new broker registered, &#123;&#125; HAServer: &#123;&#125;"</span>, brokerAddr, haServerAddr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新filter server table</span></span><br><span class="line">            <span class="keyword">if</span> (filterServerList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (filterServerList.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.filterServerTable.remove(brokerAddr);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.filterServerTable.put(brokerAddr, filterServerList);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是slave broker注册，如果master存在，则返回master broker信息</span></span><br><span class="line">            <span class="keyword">if</span> (MixAll.MASTER_ID != brokerId) &#123;</span><br><span class="line">                String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</span><br><span class="line">                <span class="keyword">if</span> (masterAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    BrokerLiveInfo brokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.get(masterAddr);</span><br><span class="line">                    <span class="keyword">if</span> (brokerLiveInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</span><br><span class="line">                        result.setMasterAddr(masterAddr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"registerBroker Exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Broker查询"><a href="#Broker查询" class="headerlink" title="Broker查询"></a>Broker查询</h1><p>根据上面DefaultRequestProcessor的处理逻辑，我们找到<code>#getRouteInfoByTopic</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">getRouteInfoByTopic</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> GetRouteInfoRequestHeader requestHeader =</span><br><span class="line">        (GetRouteInfoRequestHeader) request.decodeCommandCustomHeader(GetRouteInfoRequestHeader.class);</span><br><span class="line">    <span class="comment">// 从RouteInfoManager中获取topic的Broker信息</span></span><br><span class="line">    TopicRouteData topicRouteData = <span class="keyword">this</span>.namesrvController.getRouteInfoManager().pickupTopicRouteData(requestHeader.getTopic());</span><br><span class="line">    <span class="comment">// 如果支持顺序消息，则填充KVConfig信息</span></span><br><span class="line">    <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.namesrvController.getNamesrvConfig().isOrderMessageEnable()) &#123;</span><br><span class="line">            String orderTopicConf =</span><br><span class="line">                <span class="keyword">this</span>.namesrvController.getKvConfigManager().getKVConfig(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG,</span><br><span class="line">                    requestHeader.getTopic());</span><br><span class="line">            topicRouteData.setOrderTopicConf(orderTopicConf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] content = topicRouteData.encode();</span><br><span class="line">        response.setBody(content);</span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.setCode(ResponseCode.TOPIC_NOT_EXIST);</span><br><span class="line">    response.setRemark(<span class="string">"No topic route info in name server for the topic: "</span> + requestHeader.getTopic()</span><br><span class="line">        + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们继续看看如何查找namesrv的RouteInfo，找到<code>org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager#pickupTopicRouteData</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TopicRouteData <span class="title">pickupTopicRouteData</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">    TopicRouteData topicRouteData = <span class="keyword">new</span> TopicRouteData();</span><br><span class="line">    <span class="keyword">boolean</span> foundQueueData = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> foundBrokerData = <span class="keyword">false</span>;</span><br><span class="line">    Set&lt;String&gt; brokerNameSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    List&lt;BrokerData&gt; brokerDataList = <span class="keyword">new</span> LinkedList&lt;BrokerData&gt;();</span><br><span class="line">    topicRouteData.setBrokerDatas(brokerDataList);</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, List&lt;String&gt;&gt; filterServerMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">    topicRouteData.setFilterServerTable(filterServerMap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取读锁</span></span><br><span class="line">            <span class="keyword">this</span>.lock.readLock().lockInterruptibly();</span><br><span class="line">            <span class="comment">// 获取所有支持该topic的broker的queue配置</span></span><br><span class="line">            List&lt;QueueData&gt; queueDataList = <span class="keyword">this</span>.topicQueueTable.get(topic);</span><br><span class="line">            <span class="keyword">if</span> (queueDataList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                topicRouteData.setQueueDatas(queueDataList);</span><br><span class="line">                foundQueueData = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 获取BrokerName Set</span></span><br><span class="line">                Iterator&lt;QueueData&gt; it = queueDataList.iterator();</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    QueueData qd = it.next();</span><br><span class="line">                    brokerNameSet.add(qd.getBrokerName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 根据brokerName获取broker主从地址以及过滤器信息</span></span><br><span class="line">                <span class="keyword">for</span> (String brokerName : brokerNameSet) &#123;</span><br><span class="line">                    BrokerData brokerData = <span class="keyword">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != brokerData) &#123;</span><br><span class="line">                        BrokerData brokerDataClone = <span class="keyword">new</span> BrokerData(brokerData.getCluster(), brokerData.getBrokerName(), (HashMap&lt;Long, String&gt;) brokerData</span><br><span class="line">                            .getBrokerAddrs().clone());</span><br><span class="line">                        brokerDataList.add(brokerDataClone);</span><br><span class="line">                        foundBrokerData = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">final</span> String brokerAddr : brokerDataClone.getBrokerAddrs().values()) &#123;</span><br><span class="line">                            List&lt;String&gt; filterServerList = <span class="keyword">this</span>.filterServerTable.get(brokerAddr);</span><br><span class="line">                            filterServerMap.put(brokerAddr, filterServerList);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"pickupTopicRouteData Exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (foundBrokerData &amp;&amp; foundQueueData) &#123;</span><br><span class="line">        <span class="keyword">return</span> topicRouteData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此，我们就介绍完啦！其实简单来看，Namesrv其实一个用Netty写的一个<code>NettyRemotingServer</code>，在Namesrv定义了一个默认处理器<code>DefaultRequestProcessor</code>，在这个处理器中会根绝具体的请求码去做一些更新<code>RouteInfoManager</code>的操作，在<code>RouteInfoManager</code>中利用HashMap保存了各种关系映射，就这么简单，那么到这里结束啦！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/1686fdfc409b" target="_blank" rel="noopener">RocketMQ源码解析(二)-nameserv</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：NameSrv是RocketMQ的注册中心，保存所有Broker、Topic的元数据。Broker启动后会向namesrv发送心跳，namesrv也会定时检测broker的可用性，并移除不可用的broker。对于生产者和消费者来说，它提供了Broker的查询服务。
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>DDD Flag</title>
    <link href="http://bestlixiang.site/2019/06/09/DDD/DDD%20Flag/"/>
    <id>http://bestlixiang.site/2019/06/09/DDD/DDD Flag/</id>
    <published>2019-06-09T05:52:42.000Z</published>
    <updated>2019-06-09T05:02:49.015Z</updated>
    
    <content type="html"><![CDATA[<p>引：上周看完了Eric Evans 的《领域驱动设计—软件核心复杂性应对之道》，影响比较深的就是是这样一句话——软件的核心是其为用户解决领域相关问题的能力。<a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看花是花，看花不是花，看花是花。这是一个过程。我想所有人在学习一个东西都是这样一个过程。在忙于CRUD的过程中，我最初看待业务只是觉得他就是一个自然的业务逻辑，照着写就完事了，这处于第一步；当看完《领域驱动设计—软件核心复杂性应对之道》之后，发现在进行业务编码的时候我们更应该往领域上靠近，最好能形成一套领域模式，但是原来的业务逻辑已经不是简单的业务逻辑了，这是第二步，而我好像就处于这一步；但是我相信以后能熟练的使用领域驱动设计的时候，那时候业务又是业务了，达到第三步。Flag here！</p>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><ol>
<li><a href="https://tech.meituan.com/2017/12/22/ddd-in-practice.html" target="_blank" rel="noopener">领域驱动设计在互联网业务开发中的实践</a></li>
<li><a href="http://www.sohu.com/a/191769788_748431" target="_blank" rel="noopener">交易系统 - 领域驱动设计浅析 </a></li>
</ol>
<p>第二个是自己目前的重点，希望接下来能好好理解并且实践！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：上周看完了Eric Evans 的《领域驱动设计—软件核心复杂性应对之道》，影响比较深的就是是这样一句话——软件的核心是其为用户解决领域相关问题的能力。
    
    </summary>
    
      <category term="DDD" scheme="http://bestlixiang.site/categories/DDD/"/>
    
    
      <category term="DDD" scheme="http://bestlixiang.site/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>再看单元测试</title>
    <link href="http://bestlixiang.site/2019/06/09/%E8%B5%9E/%E5%86%8D%E7%9C%8B%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://bestlixiang.site/2019/06/09/赞/再看单元测试/</id>
    <published>2019-06-09T03:18:46.000Z</published>
    <updated>2019-06-09T03:23:59.594Z</updated>
    
    <content type="html"><![CDATA[<p>引：对于大部分开发来说，写单元测试时一件多么痛苦的事呀！<a id="more"></a></p>
<h1 id="单元测试介绍"><a href="#单元测试介绍" class="headerlink" title="单元测试介绍"></a>单元测试介绍</h1><h2 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h2><p><img src="https://upload-images.jianshu.io/upload_images/10354196-e61d89f061b4de52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试架构.png"><br>单元测试是指对软件中的最小可测试单元进行检查和验证。相信大多数都看见过这幅测试模型图，根据测试金字塔原理，越往上层的测试，所需的测试投入比例越大，效果也越差，而单元测试的成本要小的多，也更容易发现问题。话虽然这么说，但是写单元测试对于大部分开发来说依然是一件很蛋疼的事。在以前没有QA的年代，TDD单元测试驱动开发以前还是很火的，现在就不知道了。因为那个时候没有QA，开发都得靠自己测试，在重构项目时，通过单元测试可以快速的了解到自己重构时发生的修改，然后重新修正。但是现在有专业的QA同学，他们会写集成测试，导致了开发更加不想写单元测试了。但是很多公司都会有单元测试的硬性要求加上谁知道QA是不是一个和蔼可亲的小姐姐，所以单元测试还是得写，不管用不用得上，万一用得上呢？</p>
<h2 id="单元测试和集成测试"><a href="#单元测试和集成测试" class="headerlink" title="单元测试和集成测试"></a>单元测试和集成测试</h2><p>单元测试和集成测试的界线我相信大部分开发也是不清晰的。我也不是特别清楚。个人理解单元测试针对于一块业务逻辑最小的单元，可以简单理解为一个类的方法。一个单元测试不应该包含外部依赖的逻辑，反之就是集成测试了。 但是一个service的一个接口实现一般都会依赖很多第三方：1.本地其它的service 2.dao调用 3.rpc调用 4.微服务调用，等等。相信大家一定身有感受。</p>
<p>但是我们遇到的就是这样的情况，那我们还怎么写单元测试呀？答案是<strong>MOCK</strong>。现在有很多Mock的开源框架比如：mockito，easymock，还有更强大的powermock，最后放了使用参考链接。那么问题来了，既然我们可以mock第三方远程依赖，为何不mock dao、local service呢？没错外部依赖全部mock掉，就是单元测试了。因为我们只关心所测试的方法的业务逻辑，也就是真正高内聚的逻辑单元了。</p>
<p>有了Mock，我们发现：没有什么数据是造不出来的，而且还不产生任何脏数据， 跑case更快了，因为不用启动整个项目。是不是整个世界都清晰了，但是一想又有点害怕，毕竟都mock了还测试个鸡儿。还是回到对单元测试得理解，单元测试应该只针对于目标方法的业务逻辑测试，dao、其它service应该在它们自身的单元测试去测试。对于依赖的第三方，我们应该信任它们能正确的完成我们所预期的。我们应该验证的内容是：方法是否被调用，调用的次数对不对，调用参数对不对，只要这三个验证通过，就OK了。Mockito框架的verify接口就是做这件事情的。如果你理解了上述内容，那么你就开窍了，UT不在变得这么难写。</p>
<h1 id="单元测试规范"><a href="#单元测试规范" class="headerlink" title="单元测试规范"></a>单元测试规范</h1><p>好的单元测试必须遵守AIR 原则<br>A：Automatic（自动化）<br>I:    Independent（独立性）<br>R:   Repeatable（可重复） </p>
<ol>
<li>单元测试必须是全自动的，非交互式的，必须使用assert 验证，不能使用 System.out.println  肉眼观察执行结果，无参方法测试后，需要使用verify 进行验证</li>
<li>保持单元测试的独立性。单元测试用例之间不能相互调用，不能依赖执行的先后顺序</li>
<li><p>单元测试是可以重复执行的，不能受到外界环境的影响</p>
<ul>
<li>业务中使用了localcache、redis 缓存的，执行测试用例前，先清理缓存</li>
<li>DB 的测试，不可以依赖真实的DB，需要用 H2 测试框架mock 数据层，使用方式：<a href="http://www.h2database.com/html/main.html" target="_blank" rel="noopener">http://www.h2database.com/html/main.html</a></li>
<li>所有的第三方 dubbo 调用，也需要mock 调，不可以真实调用。</li>
<li>所有的中间件mock 掉。</li>
</ul>
</li>
<li><p>单元测试必须写在如下工程目录中: src/test/java，不允许写在业务代码目录下。禁止通过在业务代码类中写 main 函数进行测试</p>
</li>
<li>单元测试的BCDE 原则，保证被测模块的交付质量<ul>
<li>B: Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。</li>
<li>C：Correct，正确的输入，并得到预期结果。</li>
<li>D:  Design，与设计文档结合，编写测试用例</li>
<li>E:  Error，错误的信息输入，得到预期结果</li>
</ul>
</li>
</ol>
<h1 id="单元测试实践"><a href="#单元测试实践" class="headerlink" title="单元测试实践"></a>单元测试实践</h1><h2 id="单元测试的过程"><a href="#单元测试的过程" class="headerlink" title="单元测试的过程"></a>单元测试的过程</h2><p><img src="https://upload-images.jianshu.io/upload_images/10354196-1e92c9bd81100ef5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单元测试流程.png"></p>
<p>单元测试的编写，主要包含以下几个阶段：</p>
<ol>
<li>数据准备：在编写测试用例前，尤其是Dao层，需要依赖到一些数据，数据来源一般是数据库，而构造数据，又不能依赖 DAO 层的代码，需要使用原生jdbc 去插入数据，测试代码编写效率低。</li>
<li>构造参数及打桩（stub）：调用方法需要传递入参，有时候一个入参十几个参数需要 set，set 方法写完，代码已经写了十来行了。</li>
<li>执行测试：这一步比较简单，直接调用被测方法即可。</li>
<li>结果验证：这里除了验证被测方法的返回值外，还需要验证插入到数据库中的 数据是否正确，某外部方法被调用过n次或未调用过。</li>
<li>必要的清理：对打桩进行清理，对数据库脏数据进行清理。</li>
</ol>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>基于上面的问题，我们可以采用如下的解决方案：<br><strong>spring-test+powermock +h2数据库 的测试框架</strong></p>
<ol>
<li>H2数据库<br>H2数据库非常适合在测试程序中使用，程序关闭时自动清理数据，H2 数据库的表结构初始化是通过 jdbc:initialize-database 标签实现的，单元测试中使用 H2 数据库非常简单，仅需修改 jdbc 连接即可。</li>
<li>powermock<br>powermock支持静态方法 mock，同时兼容 mockito，powermock 示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXXTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> YourTestService yourTestService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> YourRPCClient yourRPCClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 构造参数，这里可以使用json构造</span></span><br><span class="line">     </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://juejin.im/post/5be7eaf26fb9a049d4415278" target="_blank" rel="noopener">Mockito与PowerMock的使用基础教程</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTY5MDMxNA==&amp;mid=2455759766&amp;idx=1&amp;sn=536939d467bf2f09525809f74b20860e" target="_blank" rel="noopener">有赞单元测试实践</a></li>
<li><a href="http://www.h2database.com/html/quickstart.html" target="_blank" rel="noopener">H2数据库</a></li>
<li><a href="https://github.com/powermock/powermock" target="_blank" rel="noopener">powermock</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：对于大部分开发来说，写单元测试时一件多么痛苦的事呀！
    
    </summary>
    
      <category term="赞" scheme="http://bestlixiang.site/categories/%E8%B5%9E/"/>
    
    
      <category term="单元测试" scheme="http://bestlixiang.site/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
