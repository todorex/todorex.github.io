<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rex note</title>
  <subtitle>雨过，云过</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bestlixiang.site/"/>
  <updated>2018-01-22T06:13:49.000Z</updated>
  <id>http://bestlixiang.site/</id>
  
  <author>
    <name>rex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发_6_取消与关闭</title>
    <link href="http://bestlixiang.site/2018/01/22/Java%E5%B9%B6%E5%8F%91-6-%E5%8F%96%E6%B6%88%E4%B8%8E%E5%85%B3%E9%97%AD/"/>
    <id>http://bestlixiang.site/2018/01/22/Java并发-6-取消与关闭/</id>
    <published>2018-01-22T06:13:10.000Z</published>
    <updated>2018-01-22T06:13:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：任务和线程的启动很容易，在大多数时候，我们都会让他们运行直到结束，然而，有时候我们希望提前结束任务或线程，但是Java没有提供任何机制来安全地终止线程，只是提供了中断，这是一种<strong>协作机制</strong>，能够使一个线程终止另一个线程的工作。所以需要我们能很完善地处理失败、关闭和取消等过程。<a id="more"></a></p>
<h1 id="任务取消"><a href="#任务取消" class="headerlink" title="任务取消"></a>任务取消</h1><p>如果外部代码能在某个操作正常完成之前将其置入“完成”状态，那么这个操作就可以称为可取消的。取消这个操作的原因有很多：</p>
<ol>
<li>用户请求取消。用户点击图形界面程序的“取消”按钮。</li>
<li>有时间限制的操作。某个程序需要在有限时间内完成搜索任务，当超时时，需要取消搜索任务。</li>
<li>错误。当一个爬虫程序发生错误时，那么搜索任务都会取消。</li>
<li>关闭。在立即关闭的过程中，当前的任务则可能被取消。</li>
</ol>
<p>在Java中没有一种安全的抢占式方法来停止线程，因此也就没有安全的抢占式方法来停止任务，只有一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。</p>
<p>其中一种协作机制能设置某个“已请求取消”标志，而任务将定期地查看该标志。如果设置了这个标志，那么任务将提前结束。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="title">implement</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 为了使这个过程能可靠得工作，标志cancelled必须为volatile类型</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span>(!cancelled) &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</div><div class="line">        cancelled = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>如果在上面代码中while里面出现了一个阻塞的方法，那么在调用cancel方法来设置cancelled状态，当却检查不到标志，因为它无法从阻塞的方法恢复过来。如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrokenPrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    BrokenPrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            BigInteger p = BigInteger.ONE;</div><div class="line">            <span class="keyword">while</span> (!cancelled) &#123;</div><div class="line">                <span class="comment">// 如果生产者的速度超过消费者的处理速度，队列将被填满，put方法会被阻塞</span></div><div class="line">                queue.put(p = p.nextProbablePrime());</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</div><div class="line">        cancelled = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以我们会想到一些线程中断这种协作机制，它利用了特殊的<strong>阻塞库</strong>用来是实现任务取消，注意：如果在取消之外的其他操作中使用中断，都是<strong>不合适</strong>的，并且很难支撑起更大的应用。下面是Thread的中断方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 每个线程都有一个boolean类型的中断状态，当中断线程时，这个线程的中断状态将被设置为true</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="comment">// 中断目标线程</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 清除当前线程的中断状态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 返回目标线程的中断状态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>阻塞库的方法，如Thread.sleep和Object.wait等都会检查线程何时中断，并且在发生中断时返回。响应中断执行的操作包括：清除中断状态，抛出InterruptedException。JVM不保证阻塞方法检测到中断的速度，但通常响应速度还是非常快的。</p>
<p>注意：调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。然后由线程在下一个合适的时刻中断自己（这些时刻也被称为取消点）。有些方法，例如wait、sleep和join等，将严格处理这种请求，当他们收到中断请求或者在开始执行时发现某个已被设置好的中断状态，将抛出一个异常。示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrokenPrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</div><div class="line"></div><div class="line">    BrokenPrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            BigInteger p = BigInteger.ONE;</div><div class="line">            <span class="comment">// 在阻塞的put方法调用中以及在循环开始处查询中断状态时，都会检查中断标志</span></div><div class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</div><div class="line">                queue.put(p = p.nextProbablePrime());</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</div><div class="line">        interrupt();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="中断策略"><a href="#中断策略" class="headerlink" title="中断策略"></a>中断策略</h2><p>最合理的中断策略是某种形式的线程级取消操作或者服务级取消操作：尽快退出，在必要时清理，通知某个<strong>所有者</strong>该线程已经退出。此外还可以建立其他的中断策略，例如暂停服务或重新开始服务。</p>
<p>任务不应该对执行该任务的线程的中断策略做出假设。无论任务把中断视为取消，还是其他某个中断响应操作，都应该小心的保存线程的中断状态，如果除了将InterruptException传递给调用者外还需要执行其他操作，那么应该在捕获InterruptException之后恢复中断状态。</p>
<p><strong>线程只能由其所有者中断，所有者可以将线程的中断策略信息封装到某个合适的取消机制中，例如关闭方法中。</strong></p>
<h2 id="响应中断"><a href="#响应中断" class="headerlink" title="响应中断"></a>响应中断</h2><p>在调用可中断的阻塞函数时，有两种实用策略可用于处理InterruptException：</p>
<ul>
<li>传递异常：从而使你的方法也称为了可中断的阻塞方法。</li>
<li>恢复中断状态：从而使调用栈中的上层代码能够对其进行处理。</li>
</ul>
<p><strong>只有是实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求。</strong></p>
<h2 id="通过Future来实现取消"><a href="#通过Future来实现取消" class="headerlink" title="通过Future来实现取消"></a>通过Future来实现取消</h2><p>使用ExecuorService.submit方法将返回一个Future来描述任务，Future有一个cancel方法。cancle方法有一个参数mayInterruptIfRunning,如果设置为true，那么就表示取消操作是否成功（这只是表示任务是否能够接受中断，而不是表示任务是否能够检测并处理中断）。如果为false，表示如果任务还没有运行，那么就不要运行它。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimedRun</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService taskExec = Executors.newCachedThreadPool();  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(Runnable r,<span class="keyword">long</span> timeout, TimeUnit unit)</span>  </span></div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;  </div><div class="line">        Future&lt;?&gt; task = taskExec.submit(r);  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            task.get(timeout, unit);  </div><div class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;  </div><div class="line">            <span class="comment">// 接下来任务将被取消  </span></div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;  </div><div class="line">            <span class="comment">// 如果在任务执行和中抛出了异常，那么重新抛出该异常  </span></div><div class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());  </div><div class="line">        &#125; <span class="keyword">finally</span> &#123;  </div><div class="line">            <span class="comment">//如果任务已经结束，那么执行取消操作也不会带来任何影响  </span></div><div class="line">            task.cancel(<span class="keyword">true</span>); <span class="comment">// 如果任务正在运行，那么将被中断  </span></div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="处理不可中断的阻塞"><a href="#处理不可中断的阻塞" class="headerlink" title="处理不可中断的阻塞"></a>处理不可中断的阻塞</h2><p>在java库中，很多阻塞的方法都是通过提前返回或者是抛出InterruptedException来响应中断请求的，然而并非所有的可阻塞方法或者阻塞机制都能响应中断。</p>
<p>比如一个线程由于执行同步的Socket IO 或者等待获得内置锁而阻塞，那么中断请求只能设置线程的中断状态，除此之外没有其他任何作用，对于那些执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，但这要求我们必须知道线程阻塞的原因，然后通过重写<strong>非标准的取消操作</strong>。</p>
<h1 id="停止基础线程的服务"><a href="#停止基础线程的服务" class="headerlink" title="停止基础线程的服务"></a>停止基础线程的服务</h1><p>应用程序通常会创建多个线程的服务，例如线程池。正确地封装原则是：除非拥有某个线程，否则不能对该线程进行操控，线程池是其工作线程的所有者，如果要中断这些线程，那么应该使用线程池。线程的所有权是不可以传递的：应用程序可以拥有服务，服务可以拥有工作者线程，但应用程序并不能拥有工作者线程，因此应用程序不能直接停止工作者线程。相反，服务应用提供生命周期方法来关闭它自己以及它所拥有的线程，在ExecutorService中提供了shutdown和shutdownNow方法。</p>
<ol>
<li><p>例子：日志服务</p>
<p> 方式：通过调用log方法将日志消息放入某个队列中，并由其他线程来处理；</p>
<p> 停止该服务的方式：通过原子方式来检查关闭请求，并且有条件地递增一个计数器来保存提交信息的权利；</p>
</li>
<li><p>关闭ExecutorService</p>
<p> Service封装在某个更高级别的服务中，并且该服务能提供其自己的生命周期方法。</p>
</li>
<li><p>毒丸对象</p>
<p> 毒丸是指一个放在队列上的对象，其含义是：当得到这个对象时，立即停止；</p>
<p> 限制：只有在生产者和消费者的数量都已知的情况下，才可以使用“毒丸”对象；</p>
<p> 当生产者和消费者数目较大时，这种方法变得难以使用。</p>
</li>
<li><p>例子：只执行一次的服务</p>
<p> 场景：某个方法需要处理一批任务，并且当所有任务都处理完后才返回，可以通过一个私有的Executor来简化服务的生命周期管理，其中该Executor的生命周期是由这个方法控制的</p>
</li>
<li><p>shutdownNow的局限性</p>
<p> 当通过shutdownNow来强行关闭ExecutorService时，尝试取消正在执行的任务，并返回所有已经提交但未开始的任务。但无法在关闭过程中知道正在执行的任务的状态。除非任务本身会执行某种检查。</p>
</li>
</ol>
<h1 id="处理非正常的线程终止"><a href="#处理非正常的线程终止" class="headerlink" title="处理非正常的线程终止"></a>处理非正常的线程终止</h1><p>在并发程序中,是无法做到一直观察控制台的, 例如:你的web应用部署到服务器上,难道你要派个人一直去观察控制台?</p>
<p>任何代码都可能抛出一个RuntimeExecption,每当调用另一个方法时,都要对它的行为保持怀疑,不要盲目地认为它一定会抛出在方法原型中声明的某个已检查异常。对调用的代码越不熟悉,就越应该对其代码行为保持怀疑。</p>
<h2 id="典型的线程池工作者线程结构"><a href="#典型的线程池工作者线程结构" class="headerlink" title="典型的线程池工作者线程结构"></a>典型的线程池工作者线程结构</h2><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">    Throwable <span class="keyword">throw</span> = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="keyword">while</span>(!isInterrupted)&#123;</div><div class="line">            runTask(getTaskFromWorkQueue());</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e)&#123;</div><div class="line">        thrown = e;</div><div class="line">    &#125; <span class="keyword">finally</span>&#123;</div><div class="line">        threadExited(<span class="keyword">this</span>,thrown);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果任务抛出了一个未检查的异常,那么它将使线程终结,但会首先通知框架该线程已经终结.然后,框架可能会用新的线程来代替这个工作线程。</p>
<h2 id="将异常写入日志的UncaughtExecptionHandler"><a href="#将异常写入日志的UncaughtExecptionHandler" class="headerlink" title="将异常写入日志的UncaughtExecptionHandler"></a>将异常写入日志的UncaughtExecptionHandler</h2><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span>.<span class="title">UncaughtExecptionHandler</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t,Throwable e)</span></span>&#123;</div><div class="line">        Logger logger = Logger.getAnonymousLogger();</div><div class="line">        Logger.log(Level.SEVERE,<span class="string">"Thread terminated with exception: "</span>+ t.getName(),e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在运行时间较长的应用程序中,通常会为所有线程的未捕获异常指定同一个异常处理器,并且该异常处理器至少会将异常信息记录到日志中。</p>
<h1 id="JVM关闭"><a href="#JVM关闭" class="headerlink" title="JVM关闭"></a>JVM关闭</h1><p>JVM既可以正常关闭，也可以强行关闭。正常关闭的触发方式有多种，包括：当最后一个“正常（非守护）”线程结束时，或者调用了System.exit时，或者通过其他特定于平台的方法关闭时（例如发送了SIGINT信号或Ctrl-C）。虽然可以通过这些标准方法来正常关闭JVM，但也可以通过调用Runtime.halt或者在操作系统中“杀死”JVM进程来强行关闭JVM。</p>
<h2 id="关闭钩子"><a href="#关闭钩子" class="headerlink" title="关闭钩子"></a>关闭钩子</h2><p>在正常关闭中，JVM首先调用所有已注册的关闭钩子，关闭钩子是指通过Runtime.addShutdownHook注册的但尚未开始的线程。JVM不能保证关闭钩子的调用顺序。在关闭应用程序线程时,如果有线程仍然在运行,那么这些线程接下来将与关闭进程并发执行.</p>
<p><strong>关闭钩子应该是线程安全:它们在访问共享数据时,必须使用同步机制,小心避免死锁。</strong></p>
<p>关闭钩子可以用于实现服务或应用程序的清理工作，例如删除临时文件，或者清除无法由操作系统自动清除的资源。</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>有时候，你希望创建一个线程来执行一些辅助工作，但又不希望这个线程阻碍了JVM的关闭，这种情况就需要使用守护线程。</p>
<p>线程分为两种: 普通线程和守护线程,在JVM启动时启动创建的所有线程中,除了主线程以外，其他的线程都是守护线程。例如垃圾回收器，当创建一个新的线程时，它将继承创建它的线程的类型。</p>
<p><strong>我们应该尽可能少地使用守护线程–很少有操作能够在不进行清理的情况下被安全地抛弃,特别是在执行I/O操作的任务,那么将是一种非常危险的行为; 并且守护线程不能用来替代应用程序管理程序中各个服务的生命周期</strong></p>
<h2 id="终结器"><a href="#终结器" class="headerlink" title="终结器"></a>终结器</h2><p>当不再需要内存资源时，可以通过垃圾回收器来回收它们，但对于其他一些资源，例如文件句柄或套接字句柄，当不再需要它们时,必须显式交还给操作系统。为了实现这个功能，垃圾回收器对那些定义了finalize方法的对象会进行特殊处理: 在垃圾回收期释放它们后，调用它们的finalize方法，从而保证一些持久化的资源被释放。</p>
<p>由于终结器可以在某个JVM管理的线程中运行，因此终结器访问任何状态都可能被多个线程访问，这样就必须对其访问操作进行同步。终结器并不能保证它们将在何时甚至是否会运行，并且复杂的终结器带来性能上的巨大开销。编写正确的终结器是非常困难的。在大多数情况下，通过使用finally代码块和显式的close方法能够比终结器更好的管理资源。</p>
<p><strong>避免使用终结器</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在任务、线程、服务以及应用程序等模块中的生命周期结束问题，可能会增加他们在设计和实现时的复杂性。Java并没有提供某种抢占式的机制来取消操作或者总结线程。相反，它提供了一种协作式的中断机制来实现取消操作，但这要依赖于如何构建取消操作的协议，以及能否始终遵循这些协议。通过使用<strong>FutureTask</strong>和<strong>Executor</strong>框架，可以帮助我们构建可取消的任务和服务。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：任务和线程的启动很容易，在大多数时候，我们都会让他们运行直到结束，然而，有时候我们希望提前结束任务或线程，但是Java没有提供任何机制来安全地终止线程，只是提供了中断，这是一种&lt;strong&gt;协作机制&lt;/strong&gt;，能够使一个线程终止另一个线程的工作。所以需要我们能很完善地处理失败、关闭和取消等过程。
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发_5_任务执行</title>
    <link href="http://bestlixiang.site/2018/01/15/Java%E5%B9%B6%E5%8F%91-5-%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/"/>
    <id>http://bestlixiang.site/2018/01/15/Java并发-5-任务执行/</id>
    <published>2018-01-15T03:02:09.000Z</published>
    <updated>2018-01-15T03:02:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在大多数并发应用程序都是围绕“任务执行”来构造的：任务通常是一些抽象且离散的工作单元。通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。<a id="more"></a></p>
<h1 id="在线程中执行任务"><a href="#在线程中执行任务" class="headerlink" title="在线程中执行任务"></a>在线程中执行任务</h1><p>要使服务器应用程序同时表现出良好的吞吐量和快速的响应性，应该选择清晰的<strong>任务边界</strong>以及明确的任务<strong>执行策略</strong>（见后面）。</p>
<h2 id="串行地执行任务"><a href="#串行地执行任务" class="headerlink" title="串行地执行任务"></a>串行地执行任务</h2><p>最简单的调度任务策略就是在单个线程中串行地执行各项任务。但串行处理机制通常都无法提供高吞吐率或快速响应性。</p>
<h2 id="显示地为任务创建线程"><a href="#显示地为任务创建线程" class="headerlink" title="显示地为任务创建线程"></a>显示地为任务创建线程</h2><p>通过为每个请求创建一个新的线程来提供服务，从而实现更高的响应性。但为每个任务分配一个线程也存在一些缺陷。</p>
<h2 id="无限创建线程的不足"><a href="#无限创建线程的不足" class="headerlink" title="无限创建线程的不足"></a>无限创建线程的不足</h2><ul>
<li>线程生命周期的开销非常高。线程的创建过程需要时间，这就延迟了请求的处理，并且需要JVM和操作系统提供一些辅助操作。</li>
<li>资源消耗。如果可运行线程数量多于可用处理器的数量，那么有些线程会闲置就会占用许多内存，如果大量线程在竞争CPU还会产生其他的性能消耗。</li>
<li>稳定性。在可创建线程的数量上有一个阈值，这个阈值随着平台不同而不同，并且受多个因素制约，包括JVM的启动参数、Thread构造函数中请求的栈大小，以及底层操作系统对线程的限制等。如果超过这个限制，就很可能有OOM异常。</li>
</ul>
<h1 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h1><p><strong>线程池</strong>简化了线程的管理工作，并且java.util.concurrent提供了一种灵活的线程池作为Executor框架的一部分。在java类库中，任务执行的不是Thread，而是Executor。其代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Executor框架提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用Runnable来表示任务。Executor的实现还提供了对生命周期的支持，以及统计信息收集/应用程序管理机制和性能监视等机制。Executor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程相当于消费者。</p>
<h2 id="示例：基于Executor的Web服务器"><a href="#示例：基于Executor的Web服务器" class="headerlink" title="示例：基于Executor的Web服务器"></a>示例：基于Executor的Web服务器</h2><p>可以看到下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskExecutorWebServer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NTHREAD = <span class="number">100</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor exe = Executors.newFixedThreadPool(NTHREAD);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">final</span> Socket connection = socket.accept();</div><div class="line">            Runnable task = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    handleRequest(connection);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            exec.execute(task);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在TaskExecutionWebServer中，通过使用Executor，将请求处理任务的提交与任务的实际执行解耦开来，并且只需要采用另一种不同的Executor实现，就可以改变服务器的行为。</p>
<p>将TaskExecutorWebServer改为显示地为任务创建线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 为每个请求都创建新线程的Executor</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Thread(r).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将TaskExecutorWebServer改为串行地执行任务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 以同步方式执行所有任务的Executor</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WithinThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        r.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h2><p>各种执行策略都是一种资源管理工具，最佳策略取决于可用的计算资源以及对服务质量的需求。通过限制并发任务的数量，可以确保应用程序不会由于资源耗尽而失败，或者由于在稀缺资源发生竞争而严重影响性能。通过将任务的提交于任务的执行分离开来，有助于在部署阶段选择与可用硬件资源最匹配的执行策略。</p>
<p>每当看到下面形式的代码时，并且希望获得一种更灵活的执行策略时，考虑使用Executor来代替Thread：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(runnable).start();</div></pre></td></tr></table></figure></p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池是指管理一组相同工作线程的资源池。线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务。工作线程的任务很简单： 从工作队列中获取一个任务，执行任务，执行完后返回线程池并等待下一个任务。</p>
<p>“在线程池中执行任务”比“为每个任务分配一个线程”优势更多。通过重用现有的线程而不是创建新线程，可以减少在线程创建与销毁的开销。另一个好处是请求到来时，不会再因为要等待线程创建而延迟，也就提高了响应性。通过适当调整线程池的大小，可以创建足够多的线程以便处理器保持忙碌状态，同时还可以防止过多线程互相竞争资源而使应用程序耗尽内存。</p>
<p>类库提供了一个灵活的线程池以及一些有用的默认配置。可以通过调用Executors中的静态工厂方法之一来创建一个线程池：</p>
<ul>
<li>newFixedThreadPool：创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化。（如果某个线程由于发生了未预期的Exception而结束，那么线程池会补充一个新的线程）。</li>
<li>newCachedThreadPool：创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。</li>
<li>newSingleThreadExecutor：是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。它能确保依照任务在队列中的顺序来串行执行。</li>
<li>newScheduledThreadPool：创建了一个固定长度的线程池，而且以延迟或定时的方式执行任务，类似于Timer。</li>
</ul>
<p>从“为每个任务分配一个线程”策略变为基于线程池的策略，将对应用程序的稳定性产生重大影响：Web服务器不会再在高负载情况下失败。由于服务器不会创建数千个线程来争夺有限的CPU和内存资源，因此服务器的性能将平缓地降低。通过使用Executor，可以实现各种调优/管理/监视/记录日志/错误报告和其他功能，如果不使用任务执行框架，那么要增加这些功能是非常困难的。</p>
<h2 id="Executor的生命周期"><a href="#Executor的生命周期" class="headerlink" title="Executor的生命周期"></a>Executor的生命周期</h2><p>Executor的实现通常会创建线程来执行任务，但JVM只有在所有非守护线程全部终止之后才会退出，如果无法正确关闭Executor，那么JVM将无法结束。</p>
<p>由于Executor以异步方式来执行任务，因此在任何时刻，之前提交任务的状态不是立即可见的。有些任务可能已经完成，有些可能正在运行，而其他的任务可能在队列中等待执行。当关闭应用程序时，可能采用平缓的方式（完成所有已经启动的任务，并且不再接受任何新的任务），也可能采用粗暴方式（直接所有都关掉）。Executor视为应用程序提供服务的，因此它们也是可关闭的，并把在关闭操作中受影响的任务的状态返回给应用程序。</p>
<p>为了解决执行任务的生命周期问题，ExecutorService接口扩展了Executor，添加了一些用于生命周期管理的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutDownNow</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">    <span class="comment">// ......其他用于任务提交的便利方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ExectuorService的生命周期有三种状态：运行、关闭和已终止。ExecutorService在创建时处于运行状态，shutdown方法执行优雅地关闭:不再接受新的任务，同时等待已经提交的任务执行完成–包括那些还未开始执行的任务。shutdownNow方法执行粗暴的关闭：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。</p>
<p>例如支持关闭操作的Web服务器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleWebServer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = ...;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</div><div class="line">        <span class="keyword">while</span>(!exec.isShutdown()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">final</span> Socket conn = socket.accept();</div><div class="line">                exec.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        handleRequest(conn);</div><div class="line">                    &#125;</div><div class="line">                &#125; );</div><div class="line">           &#125; <span class="keyword">catch</span> (RejectedExecutonException e) &#123;</div><div class="line">                 <span class="keyword">if</span> (!exec.isShutdown()) &#123;</div><div class="line">                    log(<span class="string">"task submission rejected"</span>, e);</div><div class="line">                &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">          exec.shutdown();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Socket connection)</span> </span>&#123;</div><div class="line">          Request req = readRequest(connection);</div><div class="line">          <span class="keyword">if</span> (isShutdownRequest(req)) &#123;</div><div class="line">               stop();</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">               dispatchRequest(req);</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="延迟任务与周期任务"><a href="#延迟任务与周期任务" class="headerlink" title="延迟任务与周期任务"></a>延迟任务与周期任务</h2><p>Timer类负责管理延迟任务以及周期任务，然而，Timer存在一些缺陷，因此应该考虑使用ScheduledThreadPoolExecutor来代替它，可以通过ScheduledThreadPoolExecutor的构造函数或Executors.newScheduledThreadPool工厂方法来创建该类的对象。它很少被使用，主要的缺陷有：</p>
<ul>
<li>Time在执行所有定时任务时只会创建一个线程，会破坏其他TimeTask的定时精确性。</li>
<li>如果TimeTask抛出一个未检查的异常，那么Time将表现出糟糕的行为。</li>
</ul>
<h1 id="找出可利用的并行性"><a href="#找出可利用的并行性" class="headerlink" title="找出可利用的并行性"></a>找出可利用的并行性</h1><p>下面将展示一个逐步利用并行性的浏览器程序中的页面渲染功能，它的作用是将HTMl页面回执到图像缓存中。</p>
<p>最简单的方法是对HTML文档进行串行处理，遇到图像引用，就通过网络获取它，然后再将其绘制到图像缓存中。但是这种方式需要等待很长时间。</p>
<p>另一种串行方式是先绘制文本元素，然后再开始下载图像，如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 图片下载过程的部分时间都是在等待I/O操作执行完成，没有充分利用CPU</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadRenderer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</div><div class="line">        renderText(source);</div><div class="line">        List&lt;ImageData&gt; imageData = <span class="keyword">new</span> ArrayList&lt;ImageData&gt;();</div><div class="line">        <span class="keyword">for</span> (ImageInfo imageInfo : scanForImageInfo(source)) &#123;</div><div class="line">            imageData.add(imageInfo.downloadImage());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (ImageData data : imageData) &#123;</div><div class="line">            renderImage(data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Executor使用Runnable作为其基本的任务表示形式，但是Runnable是一种有很大局限的抽象，虽然run能写入到日志文件或者将结果放入到某个共享的数据结构，但它不能返回一个值或抛出一个受检查的异常。</p>
<p>许多任务实际上都是存在延迟的计算—— 执行数据库查询，从网络上获取资源，或者计算某个复杂的功能。对于这些任务，Callable是一种更好的抽象：它认为主入口点（即call）将返回一个值，并可能抛出一个异常。</p>
<p>Runnable和Callable描述的都是抽象的计算任务。这些任务通常都是有范围的，即都有一个明确的起点，并且最终会结束。Executor执行的任务又四个生命周期阶段：创建/提交/开始/完成。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当它们响应中断时，才能取消。</p>
<p>Future表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。在Future规范中包含的隐含意义是，任务的生命周期只能前进，不能后退。当某个任务完成后，它就永远停留在“完成”状态上。</p>
<p>可以通过许多方法创建一个Future来描述任务。<strong>ExecutorService中的所有submit方法都将返回一个Future，从而将一个Runnable或Callable提交给Executor，并得到一个Future用来获得任务的执行结果或者取消任务</strong>。还可以显式地为某个指定的Runnable或Callable实例化一个FutureTask。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// FutureReaderer使得渲染文本与下载图像数据的任务并发执行</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureRenderer</span> </span>&#123;</div><div class="line">    <span class="comment">// 1.创建ExecutorService</span></div><div class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> List&lt;ImageInfo&gt; imageInfos = scanFooImageInfo(source);</div><div class="line"></div><div class="line">        <span class="comment">// 2.创建Callable任务</span></div><div class="line">        Callable&lt;List&lt;ImageData&gt;&gt; task = <span class="keyword">new</span> Callable&lt;List&lt;ImageData&gt;&gt;() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> List&lt;ImageData&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                List&lt;ImageData&gt; result = <span class="keyword">new</span> ArrayList&lt;ImageData&gt;();</div><div class="line">                <span class="keyword">for</span> (ImageInfo imageInfo : imageInfos) &#123;</div><div class="line">                    result.add(imageInfo);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">// 3. 提交Callable任务，获得Future</span></div><div class="line">        Future&lt;List&lt;ImageData&gt;&gt; future = (Future) executorService.submit(task);</div><div class="line">        <span class="comment">// 渲染文本</span></div><div class="line">        renderText(source);</div><div class="line"></div><div class="line">        <span class="comment">// 4. 调用get获取结果，并处理异常</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            List&lt;ImageData&gt; imageData = future.get();</div><div class="line">            <span class="keyword">for</span> (imageData data : imageData) &#123;</div><div class="line">                RenderableImage(data);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            Thread.currentThread().interrupt();</div><div class="line">            future.cancel(<span class="keyword">true</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get方法的行为取决于任务的状态（尚未开始，正在执行，已完成）。如果任务已经完成，那么get会立即返回或者抛出一个Exception，如果任务没有完成，那么get将阻塞并直到任务完成。如果任务抛出了异常，那么get将该异常封装为ExecutionException并重新抛出。如果任务被取消，那么get将抛出CancellationException。</p>
<p>如果将两个任务A和B分配给两个工人，但A的执行时间是B的10倍，那么整个过程也只能加速9%。最后，当在多个工人之间分解任务时，还需要一定的任务协调开销：为了使任务分解能提高性能，这种开销不能高于并行性实现的提升。所以只有当大量互相独立且同构的任务可以并发进行处理时，才能体现出将程序的工作负载分配到多个任务中带来的真正性能提升。</p>
<p>如果向Executor提交了一组计算任务，并且希望在计算完成后获得结果，那么可以保留与每个任务关联的Future，然后反复使用get方法，同时将参数timeout指定为0，从而通过轮训来判断任务是否完成。这种方法虽然可行，但有些繁琐。幸好有CompletionService（完成服务）。</p>
<p>CompetionService将Executor和BlockingQueue的功能融合在一起，可以将Callable任务提交给它来执行，然后使用类似于队列操作的take和poll等方法来获得已完成的结果，而这些结果会在完成时被封装为Future。ExecutorCompletionService实现了CompletionService，并将计算部分委托给一个Executor。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过CompletionService从两方面来提高页面渲染器的性能：缩短总运行时间以及提高响应性。其实现是为每一幅图像都创建一个独立的任务。</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Renderer</span> </span>&#123;</div><div class="line">    <span class="comment">// 1.创建一个ExecutorService</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line"></div><div class="line">    Renderer(ExecutorService executor) &#123; <span class="keyword">this</span>.executor = executor; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span> <span class="params">(CharSequence source)</span> </span>&#123;</div><div class="line">        List&lt;ImageInfo&gt; info = scanForImageInfo(source);</div><div class="line">        <span class="comment">// 2. 创建ExecutorCompletionService</span></div><div class="line">        CompletionService&lt;ImageData&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;ImageData&gt;(executorService);</div><div class="line">        <span class="comment">// 3. 为每幅图片创建一个独立任务</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">final</span> ImageInfo imageInfo: info) &#123;</div><div class="line">            completionService.submit(<span class="keyword">new</span> Callable&lt;ImageData&gt;() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> ImageData <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> imageInfo.downloadImage();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 渲染文本</span></div><div class="line">        renderText(source);</div><div class="line">        <span class="comment">// 4. 获取Future，调用get</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, n=info.size(); t&lt;n; t++) &#123;</div><div class="line">                Future&lt;ImageData&gt; future = completionService.take();</div><div class="line">                ImageData imageData = future.get();</div><div class="line">                RenderImage(imageData);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            Thread.currentThread().interrupt();</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有时候，如果某个任务无法在指定时间内完成，那么将不再需要它的结果，此时可以放弃这个任务。在支持时间限制的Future.get中支持这种需求：当结果可用时，它将立即返回，如果在指定时限内没有计算出结果，那么将抛出TimeoutException。在使用限时任务时需要注意，当这些任务超时后应该立即停止，从而避免为继续计算一个不再使用的结果而浪费计算资源。Future如果一个限时的get方法抛出了TimeoutException，那么可以通过Future来取消任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">Page <span class="title">renderPageWithAd</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">long</span> endNanos = System.nanoTime() + TIME_BUDGET;</div><div class="line">    Future&lt;Ad&gt; future = exec.submit(<span class="keyword">new</span> FetchAdTask());</div><div class="line">    Page page = renderPageBody();</div><div class="line">    Ad ad;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">long</span> timeLeft = endNanos - System.nanoTime();</div><div class="line">        ad = f.get(timeLeft, NANOSECONDS); <span class="comment">// 设定时间</span></div><div class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">        ad = DEFAULT_AD;</div><div class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</div><div class="line">        ad = DEFAULT_AD;</div><div class="line">        f.cancel(<span class="keyword">true</span>); <span class="comment">//取消任务</span></div><div class="line">    &#125;</div><div class="line">    page.setAd(ad);</div><div class="line">    <span class="keyword">return</span> page;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Executor框架可以将任务提交与执行策略解耦开来，当需要创建线程来执行任务时，可以考虑使用Executor，同时考虑Callable和Future。要想将应用程序分解为不同的任务并发执行时，必须定义清晰的任务边界。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在大多数并发应用程序都是围绕“任务执行”来构造的：任务通常是一些抽象且离散的工作单元。通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发_4_基础构建模块</title>
    <link href="http://bestlixiang.site/2018/01/14/Java%E5%B9%B6%E5%8F%91-4-%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97/"/>
    <id>http://bestlixiang.site/2018/01/14/Java并发-4-基础构建模块/</id>
    <published>2018-01-14T11:30:08.000Z</published>
    <updated>2018-01-14T11:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：JDK提供的东西效率应该是可以保证的，所以我们要学会去使用JDK自带的并发基础构建模块，以及理解在使用这些模块来构建应用程序时的一些常用模式。<a id="more"></a></p>
<h1 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h1><p>同步容器类包括Vector和Hashtable。这些类实现线程安全的方式是：将他们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。</p>
<h2 id="同步容器类的问题"><a href="#同步容器类的问题" class="headerlink" title="同步容器类的问题"></a>同步容器类的问题</h2><p>先看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> list.get(lastIndex);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</div><div class="line">    list.remove(lastIndex);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这些方法看起来没有问题，但是如果线程A在执行deleteLast, 线程B在执行getLast，list中有10个元素，刚好B在执行list.size()和get(lastIndex)之间，线程A执行完了remove(lastIndex), 那么线程B在执行get(lastIndex)时就会抛出ArrayIndexOutOfBoundsException。</p>
<p>由于同步容器类要遵守同步策略，即客户端加锁，因此在创建一些新的操作时，只要我们知道应该使用哪一个锁，那么这些新操作就与容器的其他操作一样都是原子操作。如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(list) &#123;</div><div class="line">        <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> list.get(lastIndex);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(list) &#123;</div><div class="line">        <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</div><div class="line">       list.remove(lastIndex);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在调用size和相应的get之间，Vector的长度可能会发生变化，这种风险在对Vector中的元素进行迭代时仍然会出现，如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 可能抛出ArrayIndexOutOfBoundsException的迭代操作</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</div><div class="line">    doSomething(vetor.get(i));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以通过在客户端加锁来解决不可靠迭代的问题，但是要牺牲一些伸缩性。通过在迭代期间持有Vector的锁，可以防止其他线程在迭代期间修改Vector。如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">synchronized (vector) &#123;</div><div class="line">    for (int i = 0; i &lt; vector.size(); i++) &#123;</div><div class="line">        doSomething(vetor.get(i));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="迭代器与ConcurrentModificationException"><a href="#迭代器与ConcurrentModificationException" class="headerlink" title="迭代器与ConcurrentModificationException"></a>迭代器与ConcurrentModificationException</h2><p>对容器类进行迭代的标准方式是使用Iterator，然而，如果有其他线程并发地修改容器，那么即使是使用迭代器也无法避免地需要在同步容器上加锁。在设计同步容器类的迭代器时并没有考虑到并发修改的问题，它们的迭代器是“及时失败”的，所以当它们发现容器在迭代过程中发生变化，就会抛出一个ConcurrentModificationException异常。这种fail-fast机制并不是一种完备的处理机制，而只是“善意地”捕获并发错误，因此只能作为并发问题的预警指示器。它们采取的实现方式是将计数器变化与容器关联起来：如果在迭代期间计数器被修改，那么hasNext或next将抛出ConcurrentModificationException。然而，这种检查是在没有同步的情况下进行的，因此可能会看到失效的值，而迭代器可能并没有意识到已经发生了修改。要想避免出现ConcurrentModificationException，就必须在迭代过程中持有容器的锁。</p>
<p>然而，有时候开发人员并不希望在迭代器间对容器加锁。例如，某些线程在可以访问容器之前，必须等待迭代过程结束，如果容器规模很大，或者在每个元素上执行操作的时间很长，那么这些线程就需要长时间等待。持有锁的时间越长，那么在锁上的竞争就越激烈，如果许多线程都在等待锁被释放，那么将极大地降低吞吐量和CPU的利用率。</p>
<p>另一种替代方法是“克隆”容器，并在副本上进行迭代。由于副本被封闭在线程内，因此其他线程不会在迭代期间对其进行修改，这样就避免了抛出ConcurrentModificationException，不过在克隆过程中仍然要加锁（以防在此期间被克隆容器被其他线程修改，那样克隆出来的容器就是失效的容器），所以也会增加性能开销。所以这种方法的好坏取决于多个因素：容器的大小，在每个元素上执行的操作，迭代操作相对于容器上其他操作被调用的频率，以及在响应时间和吞吐量等方面的需求。</p>
<h2 id="隐藏迭代器"><a href="#隐藏迭代器" class="headerlink" title="隐藏迭代器"></a>隐藏迭代器</h2><p>虽然加锁可以防止迭代器抛出ConcurrentModificationException，但必须记住在所有对共享容器进行迭代的地方都需要加锁。实际情况更复杂，因为在某些情况下，迭代器会隐藏起来。</p>
<p>如下例，标准容器的toString方法将迭代容器，并在每个元素上调用toString来生成容器内容的格式化表示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenIterator</span> </span>&#123;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer i)</span> </span>&#123;</div><div class="line">        set.add(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Integer i)</span> </span>&#123;</div><div class="line">        set.remove(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTenThing</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random r = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            set.add(r.nextInt());</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"DEBUG: added ten elements to "</span> + set);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>addTenThings方法可能会抛出ConcurrentModificationException，因为toString对set进行了迭代，而且没加锁。如果状态与保护它的同步代码之间相隔越远，那开发人员就越容易忘记在访问状态时使用正确的同步。如果HiddenIterator用<br><strong>synchronizedSet</strong>来包装HashSet，并且对同步代码进行封装，那么就不会抛出异常了。容器的hashCode和equals等方法也会间接地执行迭代操作，同样，containsAll, removeAll和retainAll等方法，以及把容器作为参数的构造函数，都会对容器进行迭代，所有这些间接的迭代操作都可能抛出ConcurrentModificationException。</p>
<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><p>同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性，这样的代价就是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重降低。Java 5.0提供了多种并发容器类来改进同步容器的性能。通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。</p>
<p>Java 5.0增加了ConcurrentHashMap，用来替代基于hash的同步map，增加了CopyOnWriteArrayList，用来替代以遍历操作为主要操作的同步List。在新的ConcurrentMap接口中增加了一些常用的复合操作，例如“putIfAbsent”,replace, 和 conditional remove。</p>
<p>Java 5.0还增加了两个新的集合类型，Queue和BlockingQueue。</p>
<p>Java 6.0增加了ConcurrentSkipListMap来替换同步的SortedMap，增加了ConcurrentSkipListSet替换SortedSet（例如TreeMap和TreeSet）</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>与HashMap一样，ConcurrentHashMap也是一个基于HashCode的Map，但它使用了一种完全不同的加锁策略来提供更高的并发性和伸缩性。ConcurrentHashMap并不是将每个方法都在同一把锁上同步并使得每次只有一个线程访问容器，而是使用一个种粒度更细的加锁机制来时间共享，叫做<strong>分段锁</strong>。在这种机制下，任意数量的读取线程可以并发地访问这个map，执行读取操作的线程和执行写入操作的线程可以并发地访问map，并且一定数量的写入线程可以并发地修改Map。</p>
<p>而且ConcurrentHashMap提供的迭代器不会抛出ConcurrentModificationException，因此不需要再迭代过程中对容器加锁。它返回的迭代器具有弱一致性，而并非“及时失败”。弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以在迭代器被构造后将修改操作反映给容器。</p>
<p>与Hashtable和synchronized-Map相比，ConcurrentHashMap有着更多的优势以及更少的劣势。因此在大多数情况下，用ConcurrentHashMap来代替同步Map能进一步提高代码的可伸缩性，只有当应用程序需要给map加锁以进行独占访问时，才应该放弃使用ConcurrentHashMap。</p>
<h2 id="额外的原子Map操作"><a href="#额外的原子Map操作" class="headerlink" title="额外的原子Map操作"></a>额外的原子Map操作</h2><p>由于ConcurrentHashMap不能被加锁来执行独占访问，因此也无法使用客户端加锁来创建新的原子操作。但是一些常见的复合操作，如“如没有则添加（put-if-absent）”,”若相等则移除（remove-if-equals）”,”若相等则替换（replace-if-equals）”等，都已经在ConcurrentMap接口中有声明，所以如果需要为现有的同步Map添加这样的功能，就应该考虑使用ConcurrentMap了。</p>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>CopyOnWriteArrayList用于替代同步list，在某些情况下提供了更好的并发性能，并且在迭代器间不需要对容器进行加锁或复制。（类似地，CopyOnWriteArraySet的作用是替代同步set）</p>
<p>Copy-On-Write容器的线程安全性在于，只要正确地发布一个实际不可变的对象，那么在访问该对象时就不需要进一步的同步了。</p>
<p>Copy-On-Write从字面上看就是，Write的时候总是要Copy，所以在每次修改时，都会创建并重新发布一个新的容器副本。而CopyOnWriteArrayList容器的迭代器会保留一个指向原始数组的引用，遍历的也是原始数组，而其他线程修改的是这个原始数组的副本，所以也不会影响原始数组，原始数组不会改变，也就不会有ConcurrentModificationException了，并且返回的元素和迭代器创建时的元素完全一致。</p>
<p>显然，每当修改容器时都会复制原始数组，这需要一定开销，特别是当容器的规模较大时。仅当迭代器操作多于修改操作时，才应该使用“写入时复制”容器。</p>
<h1 id="阻塞队列和生产者-消费者模式"><a href="#阻塞队列和生产者-消费者模式" class="headerlink" title="阻塞队列和生产者-消费者模式"></a>阻塞队列和生产者-消费者模式</h1><p><strong>基于阻塞队列构建的生产者-消费者设计中</strong>：当数据生成时，生产者把数据放入队列，而当消费者准备处理数据时，将从队列中获取数据。阻塞队列简化了生产者-消费者设计的实现过程，它支持任意数量的生产者和消费者。</p>
<p>在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。</p>
<p>BlockingQueue有多种实现：LinkedBlockingQueue和ArrayBlockingQueue是FIFO队列，与LinkedList和ArrayList相似，但比同步list有更好的并发性能。PriorityBlockingQueue是一个按优先级排序的队列，当你希望按照某种顺序而不是FIFO来处理元素时，这个队列非常有用，PriorityBlockingQueue既可以根据元素的自然顺序来比较元素，也可以使用Comparator来比较。最后一个BlockingQueue是SynchronousQueue，它并不是一个真正的队列，因为它不会为队列中元素维护存储空间。它维护的是一组线程，这些线程在等待着把元素加入或移出队列。以洗盘子为例，相当于没有盘架，直接将洗好的盘子放入下一个空闲的烘干机中，它可以直接交付工作，从而降低了将数据从生产者移动到消费者的延迟。因为SynchronousQueue没有存储功能，因此put和take会一直阻塞，直到有另一个线程已经准备好参与到交付过程中。仅当有足够多的消费者，并且总有一个消费者准备好获取交付的工作时，才适合使用同步队列。</p>
<h2 id="串行线程封闭"><a href="#串行线程封闭" class="headerlink" title="串行线程封闭"></a>串行线程封闭</h2><p>对于可变对象，生产者-消费者这种设计与阻塞队列组合在一起使得把对象从生产者转移给消费者变得容易。线程封闭对象只能由单个线程拥有，但可以通过安全地发布该对象来转移所有权。在所有权转移后，就只有新线程能获得这个对象的访问权限，并且发布对象的线程不会再访问它。这种安全的发布确保了对象状态对于新的所有者来说是可见的，并且由于最初的所有者不会再访问它，所以这个对象又被封闭在新的线程中，新线程可以对该对象做任意修改，因为它具有独占的访问权。</p>
<p>对象池利用了串行线程封闭，将对象借给一个请求线程。只要对象池包含足够的内部同步来安全地发布池中的对象，并且只要客户代码本身不会发布池中的对象，或者在将对象返回给对象池后就不再使用它，那么就可以安全地在线程之间传递所有权。</p>
<h2 id="双端队列与工作密取"><a href="#双端队列与工作密取" class="headerlink" title="双端队列与工作密取"></a>双端队列与工作密取</h2><p>Java 6增加了两种容器类型，Deque&amp;BlockingQueue。Deque是一个双端队列，实现了在队列头和队列尾的高效插入和移除。</p>
<p>双端队列适用于另一种相关模式，即工作密取（Work Stealing）。（不懂）</p>
<h1 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h1><p>同步器可以是任何一个对象，只要它根据其自身的状态来协调线程的控制流就可以叫同步器。阻塞队列可以作为同步器，其他类型的同步器还包括信号量(Semaphore)/栅栏（Barrier）以及闭锁（Latch）。</p>
<p>所有的同步器都包含一些特定的结构化属性：它们封装了一些状态，这些状态将决定使用同步器的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用于高效地等待同步器进入到预期状态。</p>
<h2 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h2><p>闭锁时一种同步器，可以延迟线程的进度直到线程到达终止状态。闭锁的作用相当于一扇门：在闭锁到达terminal状态前，这扇门一直是关闭的，没有任何线程通过，而当到达terminal状态时，这扇门就会打开允许所有线程通过。当闭锁达到terminal状态，它的状态就不会再改变，因此这扇门会永远打开。闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。例如：</p>
<ul>
<li>确保某个计算在其需要的所有资源都初始化之后才继续执行</li>
<li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动</li>
<li>等待某个操作的所有参与者都就绪再继续执行</li>
</ul>
<p>CountDownLatch是一种灵活的闭锁，可以在上述各种情况中使用，它可以使一个或多个线程等待一组事件发生。countDown方法递减计数器，表示有一个事件已经发生了，而await方法等待计数器达到零，这表示所有需要等待的事件都已经发生。如果计数器的值非零，那么await会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。例如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHarness</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTasks</span><span class="params">(<span class="keyword">int</span> nThreads, <span class="keyword">final</span> Runnable task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThreads);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;</div><div class="line">            Thread t = <span class="keyword">new</span> Thread() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        startGate.await();</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            task.run();</div><div class="line">                        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                            endGate.countDown();</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            t.start();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        startGate.countDown();</div><div class="line">        endGate.await();</div><div class="line">        <span class="keyword">long</span> end = System.nanoTime();</div><div class="line">        <span class="keyword">return</span> end-start;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Runnable task = <span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"ing"</span>);</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">long</span> interval = <span class="keyword">new</span> TestHarness().timeTasks(<span class="number">3</span>, task);</div><div class="line">            System.out.println(interval);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动门将使得主线程能够同时释放所有工作线程，而结束门则使主线程能够等待最后一个线程执行完成。</p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>FutureTask也可以用作闭锁，它可以处于下面3种状态：等待运行、正在运行和运行完成。Future.get的行为取决于任务的状态，如果任务已经完成，那么get会立即返回结果，否则get将阻塞直到任务进行完成状态。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。</p>
<p>Semaphore管理着一组虚拟的permits，许可的初始数量通过构造函数指定。在执行操作前先acquire permits（只要有剩余的许可就可以），在使用完后会release这个许可。如果没有获得permit，acquire方法将一直阻塞到有许可或指导被中断或超时。release方法将返回一个permit给信号量。</p>
<p>Semaphore也可以将任何一种容器变成有界阻塞容器。信号量的计数值会初始化为容器容量的最大值，add操作在向容器添加一个元素之前，首先获取一个permit，然后再添加，如果添加失败，那么会释放许可，如果成功就不释放了。同样，remove操作会释放一个许可，来使更多的元素能够添加到容器中。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedHashSet</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; set;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedHashSet</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;T&gt;());</div><div class="line">        sem = <span class="keyword">new</span> Semaphore(bound);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        sem.acquire();</div><div class="line">        <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            wasAdded = set.add(o);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (!wasAdded) &#123;</div><div class="line">                sem.release();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> wasAdded;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> wasRemoved = set.remove(o);</div><div class="line">        <span class="keyword">if</span> (wasRemoved) &#123;</div><div class="line">            sem.release();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> wasRemoved;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h2><p>闭锁可以启动一组相关的操作，或者等待一组相关的操作结束。闭锁时一次性对象，一旦进入终止状态，就不能被重置。</p>
<p>栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于<strong>等待事件发生</strong>，而栅栏用于<strong>等待其他线程</strong>。</p>
<h1 id="构建高效且可伸缩的结果缓存"><a href="#构建高效且可伸缩的结果缓存" class="headerlink" title="构建高效且可伸缩的结果缓存"></a>构建高效且可伸缩的结果缓存</h1><p>下面的几个代码段将逐步构架一个高效且可伸缩的缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Memoizer1存在一个可伸缩的问题，每次只有一个线程能够执行compute。</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computable</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function">V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpensiveFunction</span> <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">String</span>, <span class="title">BigInteger</span>&gt;</span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> BigInteger <span class="title">compute</span><span class="params">(String arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">//在经过长时间的计算后</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(arg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer1</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> HashMap&lt;A, V&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer1</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.c = c;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        V result = cache.get(arg);</div><div class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">            result =  c.compute(arg);</div><div class="line">            cache.put(arg, result);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 会存在重复计算的问题</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer2</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;A, V&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer2</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.c = c;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        V result = cache.get(arg);</div><div class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">            result =  c.compute(arg);</div><div class="line">            cache.put(arg, result);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*利用FutureTask来减少重复计算的问题,但是由于if判断中依然存在非原子的“先检查再执行”的操作，</span></div><div class="line">所以还是会存在重复计算的问题*/             </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer3</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer3</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.c = c;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(<span class="keyword">final</span> A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        Future&lt;V&gt; f = cache.get(arg);</div><div class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</div><div class="line">            Callable&lt;V&gt; eval = <span class="keyword">new</span> Callable&lt;V&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">                    <span class="keyword">return</span> c.compute(arg);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;V&gt;(eval);</div><div class="line">            f = ft;</div><div class="line">            cache.put(arg,ft);</div><div class="line">            ft.run();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> f.get();</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 强制将未检查的Throwable转化为RuntimeException</div><div class="line">     * <span class="doctag">@param</span> t</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RuntimeException <span class="title">launderThrowable</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</div><div class="line">            <span class="keyword">return</span> (RuntimeException) t;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Error) &#123;</div><div class="line">            <span class="keyword">throw</span> (Error) t;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Not unchecked"</span>,t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// **最终版**</span></div><div class="line"><span class="comment">// 利用复合操作“若没有则添加”可以解决Memoizer3的问题</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer4</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer4</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.c = c;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(<span class="keyword">final</span> A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Future&lt;V&gt; f = cache.get(arg);</div><div class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</div><div class="line">                Callable&lt;V&gt; eval = <span class="keyword">new</span> Callable&lt;V&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">                        <span class="keyword">return</span> c.compute(arg);</div><div class="line">                    &#125;</div><div class="line">                &#125;;</div><div class="line">                FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;V&gt;(eval);</div><div class="line">                f = ft;</div><div class="line">                cache.putIfAbsent(arg, ft);</div><div class="line">                ft.run();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">return</span> f.get();</div><div class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                cache.remove(arg, f); <span class="comment">//为了解决缓存污染问题，当计算被取消或者失败时，就从缓存中remove</span></div><div class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                <span class="keyword">throw</span> launderThrowable(e.getCause());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>构建一个高效且具有伸缩性的基础模块还是有点难度的，我们要考虑的东西比较多，我们要利用已有的基础模块合理构建。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
<li><a href="http://www.cnblogs.com/IvySue/p/6862496.html" target="_blank" rel="external">《Java并发编程实践》（四）—- 构建阻塞</a></li>
<li><a href="http://www.cnblogs.com/xrq730/p/5020760.html" target="_blank" rel="external">图解集合3：CopyOnWriteArrayList</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：JDK提供的东西效率应该是可以保证的，所以我们要学会去使用JDK自带的并发基础构建模块，以及理解在使用这些模块来构建应用程序时的一些常用模式。
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发_3_对象的组合</title>
    <link href="http://bestlixiang.site/2018/01/13/Java%E5%B9%B6%E5%8F%91-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88/"/>
    <id>http://bestlixiang.site/2018/01/13/Java并发-3-对象的组合/</id>
    <published>2018-01-13T14:40:01.000Z</published>
    <updated>2018-01-13T14:40:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：我们不希望每一次访问内存都进行分析以确保程序是线程安全的，而是希望将一些现有的线程安全组件组合为更大规模的组件或程序。<a id="more"></a></p>
<h1 id="设计线程安全的类"><a href="#设计线程安全的类" class="headerlink" title="设计线程安全的类"></a>设计线程安全的类</h1><p> 在设计线程安全类的过程中，需要包含以下三个基本要素：</p>
<ul>
<li>找出构成对象状态的所有变量</li>
<li>找出约束状态变量的不变性条件</li>
<li>建立对象的并发访问管理策略</li>
</ul>
<p>同步策略规定了如何将不变性、线程封闭、加锁机制等结合起来以维护线程的安全性，并且规定了哪些变量由哪些锁来保护。要确保开发人员可以对这个类进行分析与维护，就必须将同步策略写成正式文档。</p>
<h2 id="收集同步需求"><a href="#收集同步需求" class="headerlink" title="收集同步需求"></a>收集同步需求</h2><p>要确保类的线程安全性，就需要确保它的不变性条件不会再并发访问时被破坏，这就需要对其状态进行推断。在许多类中都定义了一些不可变条件，用于判断状态是有效的还是无效的。同样，在操作中还包含一些后验条件来判断状态转换是否有效。当下一个状态需要依赖当前状态时，这个操作就必须是一个复合操作。如果不了解对象的不变性与后验条件，那么就不能确保线程安全性，要满足状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。</p>
<h2 id="依赖状态的操作"><a href="#依赖状态的操作" class="headerlink" title="依赖状态的操作"></a>依赖状态的操作</h2><p>类的不变性条件和后验条件限制了对象的有效状态已经状态转换的有效性。有些对象包含一些基于状态的先验条件，例如，不能从空队列中移除一个元素。如果在操作中包含基于状态的先验条件，那么这个操作就叫做依赖状态操作。</p>
<p>在并发程序中要一直等到先验条件为真然后再进行操作，可以使用现有库的类（阻塞队列<br>[Blocking Queue]或信号量[Semaphore]）来实现依赖状态的行为。</p>
<h2 id="状态的所有权"><a href="#状态的所有权" class="headerlink" title="状态的所有权"></a>状态的所有权</h2><p>多数情况下，所有权与封装性是相互关联的：对象封装它拥有的状态，也对它封装的状态拥有所有权。状态变量的所有者将决定采用何种加锁协议来维持变量状态的完整性。所有权意味着控制权。如果发布了某个可变对象的引用，那么原来的所有者就不再独占控制权了，就变成共享控制权了。</p>
<h1 id="实例封闭"><a href="#实例封闭" class="headerlink" title="实例封闭"></a>实例封闭</h1><p>封装简化了线程安全类的实现过程，它提供了一种<strong>实例封装机制</strong>，也简称为<strong>封闭</strong>。将数据封装在对象内部，就可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。</p>
<p>可以看下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ThreadSafe</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonSet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Person&gt; mySet = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(Person p)</span> </span>&#123;</div><div class="line">        mySet.add(p);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsPerson</span><span class="params">(Person p)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mySet.contains(p);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>PersonSet类说明了如何通过将mySet封闭在一个类属性中以及使用加锁机制使一个类成为线程安全的。PersonSet的状态由HashSet来管理，而HashSet不是线程安全的，但由于mySet是私有的并且不会逸出，因此HashSet被封闭在PersonSet中。唯一能访问mySet的代码路径是addPerson和containsPerson两个方法，在执行它们时都要获得PersonSet的内置锁，所以PersonSet的状态完全由它的内置锁保护，因而PersonSet是一个线程安全的类。</p>
<p>线程封闭的作用可以将非线程安全的类转化为线程安全的类。可以利用到<strong>装饰器模式</strong>。封闭机制更易于构造线程安全的类，因为在分析线程安全性时可以只分析该类而不用检查整个程序。</p>
<h2 id="Java监视器模式"><a href="#Java监视器模式" class="headerlink" title="Java监视器模式"></a>Java监视器模式</h2><p>Java的内置锁也称为监视器锁或监视器。所以使用内置锁来保证线程安全性的模式就叫做Java监视器模式。遵循Java监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。Java监视器模式仅仅是一种编写代码的乐队，对于任何一种锁对象，只要自始至终都使用该锁对象，都可以用来保护对象的状态。（不知道是不是只要读和写方法只要都保持同步就好了？）</p>
<h1 id="线程安全的委托（需要好好理解的，日后加深）"><a href="#线程安全的委托（需要好好理解的，日后加深）" class="headerlink" title="线程安全的委托（需要好好理解的，日后加深）"></a>线程安全的委托（需要好好理解的，日后加深）</h1><p>在某些情况下，通过多个线程类组合而成的类是线程安全的，而在某些情况下，这仅仅是一个好的开端，但却是线程不安全的（由于没有维持不变性约束）。</p>
<p>如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给这些状态变量。</p>
<p>如果一个状态变量是线程安全的，也不参与<strong>任何不变性条件</strong>，也没有操作上的状态变换，那这个变量就可以发布出去。</p>
<h1 id="在现有的线程安全类中添加功能"><a href="#在现有的线程安全类中添加功能" class="headerlink" title="在现有的线程安全类中添加功能"></a>在现有的线程安全类中添加功能</h1><p>Java类库包中包含许多有用的“基础模块”类，通常，我们应该优先选择重用这些现有的类而不是创建新的类：重用能降低开发工作量、开发风险（因为现有的类都已经通过测试）以及维护成本。我们需要在不破坏线程安全性的情况下添加一个新的操作。</p>
<p>要添加一个新的原子操作，最安全的方法是修改原始类，但这通常无法做到，因为可能无法访问或修改类的源代码。如果直接将新方法添加到类中，那么意味着实现同步策略的所有代码仍然处于一个源文件中，从而更容易维护。另一种方法是用子类扩展这个类，但这样的话同步策略的实现就分布在了多个需要单独维护的源文件中，如果父类修改了同步策略选择不同的锁来保护它的状态变量，那子类也需要跟着变。如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 扩展Vector并增加一个“若没有则添加”方法</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BetterVector</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> absent = !contains(x);</div><div class="line">        <span class="keyword">if</span> (absent) &#123;</div><div class="line">            add(x);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> absent</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="客户端加锁机制"><a href="#客户端加锁机制" class="headerlink" title="客户端加锁机制"></a>客户端加锁机制</h2><p>第三种策略是扩展类的功能，但并不是扩展类本身，而是将扩展方法放在一个辅助类（Helper class）中。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListHelper</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> absent = !list.contains(x);</div><div class="line">        <span class="keyword">if</span>(absent) &#123;</div><div class="line">            list.add(x);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> absent;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>putIfAbsent用的是ListHelper的内置锁，但list用的肯定不是ListHelper的锁，尽管所有的list操作都被声明为synchronized，但却是不一样的锁，这就无法确保当putIfAbsent执行时另一个线程不会修改这个list。</p>
<p>要想使这个方法正确执行，必须使list在实现客户端加锁或外部加锁时使用同一个锁。<strong>客户端加锁</strong>是指，对于使用某个对象X的客户端代码，使用X本身用于保护其状态的锁来保护这段客户端代码。要使用客户端加锁，就必须知道对象X使用的是哪一个锁。在Vector和同步封装器类的文档中指出，它们通过使用Vector或封装器容器的内置锁来支持客户端加锁。所以修改后的putIfAbsent如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListHelper</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(list) &#123;</div><div class="line">            <span class="keyword">boolean</span> absent = !list.contains(x);</div><div class="line">            <span class="keyword">if</span>(absent) &#123;</div><div class="line">                list.add(x);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> absent;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>更好地为现有类添加原子操作的方法是：<strong>组合</strong>。示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImprovedList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> list&lt;T&gt; list;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImprovedList</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(T x)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> contains = list.contains(x);</div><div class="line">        <span class="keyword">if</span>(!contains) &#123;</div><div class="line">            list.add(x);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> !contains;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">       list.clear();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ImprovedList通过自身的内置锁增加了一层额外的加锁。它并不关心List是否是线程安全的，即使List不是线程安全的或者修改了它的加锁实现，ImprovedList也会提供一致的加锁机制来实现线程安全性。事实上，我们使用了Java监视器模式来封装现有的List，并且只要在类中拥有指向底层List的唯一外部引用，就能确保线程安全性。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>设计一个线程安全的类方法有很多种，这里提到了三点：实例封闭、线程委托、复用现有基础类。但是具体实现线程安全都不一样，需要按实际情况来确定。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：我们不希望每一次访问内存都进行分析以确保程序是线程安全的，而是希望将一些现有的线程安全组件组合为更大规模的组件或程序。
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发_2_对象的共享</title>
    <link href="http://bestlixiang.site/2018/01/13/Java%E5%B9%B6%E5%8F%91-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB/"/>
    <id>http://bestlixiang.site/2018/01/13/Java并发-2-对象的共享/</id>
    <published>2018-01-13T09:58:17.000Z</published>
    <updated>2018-01-13T09:58:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：为了能够安全地由多个线程同时访问某个对象，我们就需要学会在共享和发布对象时，构建一个线程安全类或者通过java.util.concurrent类库来构建。<a id="more"></a></p>
<h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p>在读操作和写操作在不同线程执行时，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，所谓“不可见”。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p>
<p>先看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoVisibility</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span>(!ready) &#123;</div><div class="line">                Thread.yield();</div><div class="line">            &#125;</div><div class="line">            System.out.println(number);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> ReaderThread().start();</div><div class="line">        number = <span class="number">42</span>;</div><div class="line">        ready = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码不能保证输出42，可能输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入的number的值，这种现象称为“重排序”，它的意思是代码的顺序可能因为优化而发生重排序。</p>
<h2 id="失效数据"><a href="#失效数据" class="headerlink" title="失效数据"></a>失效数据</h2><p>失效数据：当读线程查看一个变量是，可能会得到一个已经失效的值。除非在每次访问变量时都使用同步，否则很可能获得该变量的一个失效值。更糟糕的是，失效值可能不会同时出现：一个线程可能得到某个变量的最新值，而获得另一个变量的失效值。</p>
<p>下面的代码不是线程安全的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NonThreadSafe</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableInteger</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>get和set都是在没有同步的情况下访问value，所以失效值问题很容易出现：如果某个线程在调用了get，那么另一个正在调用get的线程可能会看到更新后的value值，也可能看不到。要使MutableInteger成为一个线程安全的类，必须对set和get都进行同步。</p>
<h2 id="非原子的64位操作"><a href="#非原子的64位操作" class="headerlink" title="非原子的64位操作"></a>非原子的64位操作</h2><p>最低安全性（out-of-thin-air-safety）:当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。</p>
<p>例外：对于非volatile类型的long和double变量，JVM允许64位的读操作和写操作分解为两个32位的操作。那么很有可能会读到某个值的高32位和另一个值的低32位。所以在多线程程序中使用共享且可变的long和double等类型的变量是不安全的，除非使用关键字volatile来声明他们，或者用锁保护起来。</p>
<h2 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h2><p>volatile变量可以确保将变量的更新操作通知到其他线程。并且会禁止重排序，因此在读取volatile类型的变量时总会返回最新写入的值。volatile通常用作某个操作完成。发生中断或者状态的标志。它只能保证可见性，但是不能保证原子性。</p>
<p>当且仅当满足所有条件时，才应该使用volatile变量：</p>
<ol>
<li>对变量的写入操作不依赖变量的当前值（比读到的还要新的值），或者你能保证只有当个线程更新变量的值。</li>
<li>该变量不会与其他状态变量一起纳入不变性条件中。</li>
<li>在访问变量时不需要加锁。</li>
</ol>
<h1 id="发布和逸出"><a href="#发布和逸出" class="headerlink" title="发布和逸出"></a>发布和逸出</h1><p><strong>“发布（Publish）”对象</strong>：使对象能够在当前作用域之外的代码中使用。例如：将一个指向该对象的引用保存到其他代码可以访问的地方（公有的静态变量中）</p>
<p><strong>“逸出（Escape）”</strong>：当某个不应该发布的对象被发布。例如：在对象构造完成之前就发布对象</p>
<p>发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象，如下面代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Secret&gt; knownSecrets;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">    knownSecrets = <span class="keyword">new</span> HashSet&lt;Secret&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当发布某个对象时，可能会间接地发布其他对象。如果将一个Secret对象添加到集合knownSecrets中，那么同样会发布这个对象，因为任何代码都可以遍历这个集合，并获得对这个新Secret对象的引用。同样，如果从非私有方法中返回一个引用，那么同样会发布返回的对象。如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeStates</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String[] states = <span class="keyword">new</span> String[] &#123;<span class="string">"AK"</span>,<span class="string">"AL"</span>...&#125;;</div><div class="line">    <span class="keyword">public</span> String[] getStates() &#123;</div><div class="line">        <span class="keyword">return</span> states;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另一种将一个对象或者它内部的状态publish出去的方式就是publish这个对象所在类的内部类，如下例子,但是会将this对象的引用escape出去。因为当ThisEscape将EventListener　publish出去，它就显示地将外部类ThisEscape实例对象也公布出去了，因为内部类实例保存了外部类实例的隐藏引用。所以会把this　escape出去。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span> </span>&#123;</div><div class="line">        source.registerListener(  </div><div class="line">                <span class="keyword">new</span> EventListener() &#123;</div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event o)</span> </span>&#123;</div><div class="line">                        doSomething(o);<span class="comment">// 由于这个线程是异步的，所有EventSource可能还没有构造完</span></div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当内部EventListener实例发布时，在外部封装的ThisEscape实例也逸出了，当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态。一个常见的使this引用在构造过程中逸出的错误是在构造函数中启动一个线程。如果想在构造函数中注册一个事件监听器或启动线程，可以使用一个私有的构造函数和一个公共的工厂方法，从而避免不正确的构造过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeListener</span><span class="params">()</span> </span>&#123;</div><div class="line">        listener = <span class="keyword">new</span> EventListener() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event o)</span> </span>&#123;</div><div class="line">                doSomething(o);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title">newInstance</span><span class="params">(EventSource source)</span> </span>&#123;</div><div class="line">        SafeListener safeListener = <span class="keyword">new</span> SafeListener();</div><div class="line">        source.registerListener(safeListener);</div><div class="line">        <span class="keyword">return</span> safeListener;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h1><p>当访问共享的可变数据时，通常需要同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭。</p>
<p>线程封闭的一个常见应用是从池中拿JDBC Connection。在典型的服务器应用中，一个线程从池中获取connection对象，用它来处理一个单独的请求，处理完后归还该connection，又放入池中。Connection池是不会把相同的connection对象分配给不同的线程的，这种模式就显式地将那个connection封闭在一个线程中。</p>
<p>局部变量和ThreadLocal类就是用来维护线程封闭特性的，但即便有这些现成的特性，程序员仍有义务去保证封闭在线程中的对象不会从线程中逸出</p>
<h2 id="Ad-hoc线程封闭"><a href="#Ad-hoc线程封闭" class="headerlink" title="Ad-hoc线程封闭"></a>Ad-hoc线程封闭</h2><p>这种线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。这种技术很脆弱，因此程序中尽量少用它。</p>
<h2 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h2><p>栈封闭式线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问这个栈。栈封闭比Ad-hoc线程封闭更易于维护，也更加健壮。可以看看下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadTheArk</span><span class="params">(Collections&lt;Animal&gt; candidates)</span> </span>&#123;</div><div class="line">        SortedSet&lt;Animal&gt; animals;</div><div class="line">        <span class="keyword">int</span> numPairs = <span class="number">0</span>;</div><div class="line">        Animals candidate = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        animals = <span class="keyword">new</span> TreeSet&lt;Animal&gt;(<span class="keyword">new</span> SpeciesGenderComparator());</div><div class="line">        animals.addAll(candidates);</div><div class="line">        <span class="keyword">for</span>(animals a : animals) &#123;</div><div class="line">            <span class="keyword">if</span> (candidate == <span class="keyword">null</span> || !candidate.isPotentialMate(a)) &#123;</div><div class="line">                candidate = a;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ark.load(<span class="keyword">new</span> AnimalPair(candidate, a));</div><div class="line">                ++numPairs;</div><div class="line">                candidate = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> numPairs;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中的numPairs不会破坏线程封闭性，因为任何方法都无法获得对基本类型的引用，所以基本类型的局部变量始终封闭在线程内。但是对于对象引用的线程封闭，就需要一些额外的工作确保对象引用不会逸出。在上例中实例化了一个TreeSet,并用animals引用指向它，因为只有一个引用指向这个Set，而且这个引用是局部变量，所以这个对象引用也被封闭在线程中。但是如果把这个animals公布（publish）出去，线程封闭性就会破化。</p>
<h2 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h2><p>维护线程封闭性的一种更规范的方式是使用ThreadLocal. ThreadLocal提供了get和set方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。</p>
<p>例如，在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都要传递一个Connection对象。由于JDBC的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将JDBC的连接保存到ThreadLocal对象中，每个线程都会拥有属于自己的连接，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="keyword">new</span> ThreadLocal&lt;&gt;()&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> connectionHolder.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 当某个线程初次调用ThreadLocal.get方法时，会调用initialValue()方法来获取初始值。从概念上讲，可以将ThreadLocal<t>视为包含了Map<thread, t="">对象，其中保存了只属于该线程的值。当线程终止后，这些值就会作为垃圾被回收掉。</thread,></t></p>
<h1 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h1><p>如果某个对象在创建之后状态就不能被修改，那这个对象就被称为<strong>不可变对象</strong>。不可变对象一定是线程安全的。不可变对象只有一种状态，而且这种状态由构造函数来控制。</p>
<p>当满足一下条件的时候，对象才是不可变的：</p>
<ul>
<li>对象创建以后其状态就不能修改</li>
<li>对象的所有域都是final类型</li>
<li>对象是正确创建的（在对象的创建过程中，this引用没有逸出）</li>
</ul>
<p>不可变对象仍然可以在内部使用可变对象来管理它们的状态。如下例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Immutable</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeStooges</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; stooges = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeStooges</span><span class="params">()</span> </span>&#123;</div><div class="line">        stooges.add(<span class="string">"Moe"</span>);</div><div class="line">        stooges.add(<span class="string">"Larry"</span>);</div><div class="line">        stooges.add(<span class="string">"Curly"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStooge</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> stooges.contains(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Final域"><a href="#Final域" class="headerlink" title="Final域"></a>Final域</h2><p>正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”一样，“除非需要某个域是可变的，否则应将其声明为final域”也是一个良好的编程习惯。</p>
<h2 id="使用Volatile类型来发布不可变对象"><a href="#使用Volatile类型来发布不可变对象" class="headerlink" title="使用Volatile类型来发布不可变对象"></a>使用Volatile类型来发布不可变对象</h2><p>为了保证操作的原子性，可以将多个状态转化为包含多个状态的不可变对象，然后使用volatile来保持可见性，从而保证了线程安全。如下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache = <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</div><div class="line">        BigInteger i = extractFromRequest(req);</div><div class="line">        BigInteger[] factors = cache.getFactors(i);</div><div class="line">        <span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</div><div class="line">            factors = factor(i);</div><div class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</div><div class="line">        &#125;</div><div class="line">        encodeIntoResponse(resp, factors);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactos;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i, BigInteger[] factors)</span> </span>&#123;</div><div class="line">        lastNumber = i;</div><div class="line">        lastFactos = Arrays.copyOf(factors, factors.length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</div><div class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> Arrays.copyOf(lastFactos, lastFactos.length);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h1><p>在某些情况下我们希望在多个线程间共享对象，此时必须确保安全地进行共享。</p>
<h2 id="不正确的发布：可见性出现问题"><a href="#不正确的发布：可见性出现问题" class="headerlink" title="不正确的发布：可见性出现问题"></a>不正确的发布：可见性出现问题</h2><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Holder hoder;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">    holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.n = n;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertSanity</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(n != n) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"This statement is false"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为除了发布对象的线程外，其他线程可以看到的Holder域可能是一个失效值。</p>
<h2 id="不可变对象与初始化安全性"><a href="#不可变对象与初始化安全性" class="headerlink" title="不可变对象与初始化安全性"></a>不可变对象与初始化安全性</h2><p>任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。</p>
<h2 id="安全发布的常用模式"><a href="#安全发布的常用模式" class="headerlink" title="安全发布的常用模式"></a>安全发布的常用模式</h2><p>要安全地发布一个对象，那它的引用和状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式安全地发布：</p>
<ul>
<li>在静态初始化函数中初始化对象的引用</li>
<li>把对象的引用保存在volatile类型的域或者AtomicReference对象中</li>
<li>将对象的引用保存到某个正确构造的final对象的域中</li>
<li>将对象的引用保存到一个由锁保护的域中</li>
</ul>
<p>使用静态初始化函数通常是最简单最安全的发布方式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Holder holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</div></pre></td></tr></table></figure></p>
<p>静态初始化器由JVM在类的初始化阶段执行，由于JVM内部存在在同步机制，因此通过这种方式初始化的任何对象都哦可以被安全发布。</p>
<h2 id="事实不可变对象"><a href="#事实不可变对象" class="headerlink" title="事实不可变对象"></a>事实不可变对象</h2><p>如果对象在技术上来看是可变的，但其状态在发布之后不会再改变，那么这种对象成为“实际不可变对象”，在这些对象发布之后，程序之需要将它们视为不可变对象即可。所以如果确认某些对象是实际不可变对象，就可以简化开发减少同步从而提升性能。</p>
<h2 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h2><p>如果对象在构造后可以被修改，那么安全发布只能确保这个对象在发布当时状态的可见性，为了保证线程安全，就需要在每次对象访问时也使用同步来确保后续修改操作的可见性。对象的发布方式取决于它的可变性：</p>
<ul>
<li>不可变对象可以通过任何机制来发布；</li>
<li>事实不可变对象必须通过安全方式来发布</li>
<li>可变对象必须通过安全方式来发布，并且必须是线程安全的或由某个锁保护起</li>
</ul>
<h2 id="安全的共享对象"><a href="#安全的共享对象" class="headerlink" title="安全的共享对象"></a>安全的共享对象</h2><p>在并发程序中使用共享对象是，可以使用一些实用的策略：</p>
<ul>
<li>线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。</li>
<li>只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和实际不可变对象。</li>
<li>线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。</li>
<li>保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于对象需要共享，所以要注意发布的安全性，以及对不可以变对象的合理应用。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
<li><a href="https://www.2cto.com/kf/201405/298701.html" target="_blank" rel="external">java并发编程实践学习（四）对象的发布和逸出之this逃逸</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：为了能够安全地由多个线程同时访问某个对象，我们就需要学会在共享和发布对象时，构建一个线程安全类或者通过java.util.concurrent类库来构建。
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发_1_线程安全性</title>
    <link href="http://bestlixiang.site/2018/01/12/Java%E5%B9%B6%E5%8F%91-1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>http://bestlixiang.site/2018/01/12/Java并发-1-线程安全性/</id>
    <published>2018-01-12T05:58:09.000Z</published>
    <updated>2018-01-12T06:00:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对“共享的(Shared)”和“可变的(Mutable)”状态的访问。而对象的状态是指存储在状态变量（类变量和成员变量）中的数据。“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期可以发生变化。<a id="more"></a></p>
<h1 id="什么是线程的安全性"><a href="#什么是线程的安全性" class="headerlink" title="什么是线程的安全性"></a>什么是线程的安全性</h1><p>线程安全性简单点说就是<strong>所见即所知</strong>，这是对正确性的认识。在书中还有一个比较长的定义：</p>
<pre><code>当多个线程访问某个类时，不管运行时环境采用何种调度方法或者这些线程将如何交替执行，
并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确地行为，
那么这个类是线程安全的。
</code></pre><p>自己再开始也简单介绍了对象的状态，这里需要明确一点：</p>
<pre><code>无状态的对象一定是线程安全的。
</code></pre><h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><ol>
<li>原子操作：不可再分割为几个操作的操作</li>
<li>竞态条件：由于不恰当的执行时序而出现不正确的结果（不是原子操作引起的）</li>
<li>竞态条件的类型：<ul>
<li>先检查后执行，例如延迟初始化</li>
<li>读取-修改-写入，例如统计命中数操作</li>
</ul>
</li>
<li>复合操作：将几个操作变为一个原子操作，在java.util.concurrent.atomic包中包含了一些原子变量类，用于实现在数值和对象引用上的原子状态转换。</li>
<li>在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。</li>
</ol>
<h1 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h1><p>要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。</p>
<h2 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h2><p>Java提供了一种内置的锁机制来支持原子性：同步代码块。同步代码块包括两部分：一个“作为锁”的对象引用，一个“作为由这个锁保护”的代码块。这个锁称为内置锁或监视器锁。线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁。Java的内置锁相当于一种互斥体，最多只有一个线程能够持有这种锁。由于每次只能有一个线程执行内置锁保护的代码块，因此，有这个锁保护的同步代码块会以原子方式执行。</p>
<h2 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h2><p>内置锁是可重入的，如果某个线程试图获得一个已经有它自己持有的锁，这个请求将会成功，“重入”意味着获取锁的操作的粒度是“线程”。</p>
<p>重入的一种是实现方法是：为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减，当计数值为0时，这个锁将被释放。</p>
<h2 id="用锁来保护状态"><a href="#用锁来保护状态" class="headerlink" title="用锁来保护状态"></a>用锁来保护状态</h2><ol>
<li>只把复合操作包装在synchronized块中并不够，如果对一个变量的访问需要使用同步，那所有访问该变量的地方都要加上同步。而且在使用锁来实现对变量的同步时，所有访问该变量的地方都要使用同一把锁。</li>
<li>获取一个对象关联的锁并不能阻止其他线程访问该对象，只有所有线程都获取的是相同的锁才能确保该对象被串行访问。所以每个共享的可变变量要被同一把锁保护。并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。</li>
<li>一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码进行同步，使得在该对象上不会发生并发访问。</li>
</ol>
<h1 id="活跃性与性能"><a href="#活跃性与性能" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h1><p>这里展示两个代码：</p>
<p>利用同步方法实现锁的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.math.BigInteger;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="keyword">this</span>) <span class="keyword">private</span> BigInteger lastNumber;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="keyword">this</span>) <span class="keyword">private</span> BigInteger[] lastFactors;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</div><div class="line">        BigInteger i = extractFromRequest(req);</div><div class="line">        <span class="keyword">if</span>(i.equals(lastNumber)) &#123;</div><div class="line">            encodeIntoResponse(resp, lastFactors);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            BigInteger[] factors = factor(i);</div><div class="line">            lastNumber = i;</div><div class="line">            lastFactors = factors.clone();</div><div class="line">            encodeIntoResponse(resp, factors);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过缩小同步代码块的作用范围实现锁的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.math.BigInteger;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.IF_ACMPEQ;</div><div class="line"></div><div class="line"><span class="meta">@ThreadSafe</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span></span>&#123;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="keyword">this</span>) <span class="keyword">private</span> BigInteger lastNumber;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="keyword">this</span>) <span class="keyword">private</span> BigInteger[] lastFactors;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="keyword">this</span>) <span class="keyword">private</span> <span class="keyword">long</span> hits;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="keyword">this</span>) <span class="keyword">private</span> <span class="keyword">long</span> cacheHits;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getHits</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> hits;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">double</span> <span class="title">getCachedHits</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)cacheHits /(<span class="keyword">double</span>) hits;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</div><div class="line">        BigInteger i = extractFromRequest(req);</div><div class="line">        BigInteger[] factors = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            ++hits;</div><div class="line">            <span class="keyword">if</span>(i.equals(lastNumber)) &#123;</div><div class="line">                ++cacheHits;</div><div class="line">                factors = lastFactors.clone();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(factors == <span class="keyword">null</span>) &#123;</div><div class="line">            factors = factor(i); <span class="comment">//花费时间长的代码不要持有锁，相当于两个同步代码块的界限</span></div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                lastNumber = i;</div><div class="line">                lastFactors = factors.clone();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        encodeIntoResponse(resp, factors);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要判断同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性（这个需求必须要满足）、简单性和性能。我们需要权衡。</p>
<pre><code>tip：当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>安全性需要保证，活跃性和性能也要在权衡之中。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对“共享的(Shared)”和“可变的(Mutable)”状态的访问。而对象的状态是指存储在状态变量（类变量和成员变量）中的数据。“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期可以发生变化。
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>人生之语言与数学</title>
    <link href="http://bestlixiang.site/2018/01/11/%E4%BA%BA%E7%94%9F%E4%B9%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%95%B0%E5%AD%A6/"/>
    <id>http://bestlixiang.site/2018/01/11/人生之语言与数学/</id>
    <published>2018-01-11T14:15:41.000Z</published>
    <updated>2018-01-11T14:21:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：其实最近自己一直都在准备考试，结果突然脑海出现了关于对人生的杂想（可能想的高度太高了），自己没有及时写下来，现在基本上考完了，所以就想认真谈一下自己的思考。<a id="more"></a></p>
<h1 id="人生"><a href="#人生" class="headerlink" title="人生"></a>人生</h1><p>我想大部人都是想着<strong>成功</strong>得过完这一生的，但是每个人都会迷茫，都会在某个时刻不知道自己想要什么，或者该怎么做。我想简单得把世界上的人归为这样两类。</p>
<h2 id="话人生"><a href="#话人生" class="headerlink" title="话人生"></a>话人生</h2><p>这里有一类人他们是靠<strong>情商</strong>和<strong>努力</strong>来获得成功的，说的通俗点就是走上行政或者做生意的，这类人对我们的世界是十分重要的，能说会道的人在哪都能吃得开吧。</p>
<h3 id="行政人生"><a href="#行政人生" class="headerlink" title="行政人生"></a>行政人生</h3><p>行政现在对学历的要求也越来越高了，所以不管怎么样，我觉得这样的人还是要对考试保持敬畏，我个人觉得锻炼应试能力是十分有必要的，因为在升学或者入职，这都将起着置关重要的作用，我想也许不用把每块知识都弄的那么深，那么透，反而应该是学会总结，学会归类，学会预测以便花最少的时间或者最佳的结果。这里要提一下就是我们从小的学的语文这门科目了，不能说它多有用，但是对于提高我们的文笔还是很有帮助的，还有就是书写能力也会显得十分重要。</p>
<h3 id="生意人生"><a href="#生意人生" class="headerlink" title="生意人生"></a>生意人生</h3><p>做生意或者说做销售，其实大部分的人都能感觉到实业越来越难做了，或者说是太稳固，墙外面的人很难挤进去，反而随着互联网的发展，线上的生意火好一些。这只是一种形式。真正想做大做好，你除了能说会道，我想掌握一口标准的普通话和一口流利的英语口语对生意的广度和未来都会有很好的帮助，所以语言能力需要好好的get。</p>
<h2 id="学人生"><a href="#学人生" class="headerlink" title="学人生"></a>学人生</h2><p>还有这一种人那就是通过<strong>学习</strong>和<strong>努力</strong>来改变人生，或者说是走技术路线的，当然这里也会分为两种人。</p>
<h3 id="科研人生"><a href="#科研人生" class="headerlink" title="科研人生"></a>科研人生</h3><p>世界需要进步，那进步从何而来，我想其中的核心是来自一部分占比不高的人（科学家，至少是个博士吧）的努力。这里数学就会显得那么重要。当然数学会分很多方面，之前听到过一种说法就是数学其实一门哲学，信了它就是对的，不信它就是错的。说的其实也是十分的有道理，数学的对错其实是相对的，不是绝对的，要根据所处的领域基础，但是对于大部分我们所认识到的数学大多数还是同一个基础，就是我们大部分人从小到大所学的数学。然后我想说说自己对于数学的认知，我想说数学其实是一个工具，它对于无论是哪方面的科研都是很重要的，无论是工科还是经济学科。所以也就诞生了那么多交叉学科。这里又想提到计算机科学，其实计算机科学在科研方便起到的只是减少人类的工作量以及提高人所需要的计算能力。就像大数据其实是属于统计学科，但是结合到计算机，那么就变成了计算机的热门学科了。</p>
<h3 id="经验人生"><a href="#经验人生" class="headerlink" title="经验人生"></a>经验人生</h3><p>世界的进步需要科学家，但是也少不了靠经验解决问题的专家，比如架构师，我想大概就是通过不断的实践来提高自己的解决问题的能力，而这不需要多好的科研能力或者说绝对的创新能力，只要多做多想，学会快又准确地解决问题就好了。我相信大部分人的智商都是差不多的，所以想在经验人生上取的小小的成功，真的是需要花很多时间来提升自己的经验。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：其实最近自己一直都在准备考试，结果突然脑海出现了关于对人生的杂想（可能想的高度太高了），自己没有及时写下来，现在基本上考完了，所以就想认真谈一下自己的思考。
    
    </summary>
    
      <category term="生活" scheme="http://bestlixiang.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="人生" scheme="http://bestlixiang.site/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_14_线程安全与锁优化</title>
    <link href="http://bestlixiang.site/2017/12/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-14-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>http://bestlixiang.site/2017/12/14/深入理解JVM-14-线程安全与锁优化/</id>
    <published>2017-12-14T09:57:38.000Z</published>
    <updated>2017-12-14T10:14:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：面向对象的编程思想极大的提升了现在软件开发的生产效率和软件可以达到的规模，但是现实中对象在一项工作进行期间，会被不停地中断和切换，对象的属性可能会在中断期间被修改和变“脏”，所以我们在谈“高效并发”之前必须先保证并发的正确性和如何实现线程安全。<a id="more"></a></p>
<h1 id="线程的安全"><a href="#线程的安全" class="headerlink" title="线程的安全"></a>线程的安全</h1><p>在《Java Concurrency In Practice》一书中这样定义线程安全：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下得调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确地结果，那这个对象是线程安全的。</p>
<p>它要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无需关心多线程的问题，更无需自己采用任何措施来保障多线程的正确调用。</p>
<h2 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h2><p>在讨论线程安全的时候，都会限定于多个线程之间存在共享数据访问这个前提，我们按照线程安全的“安全程度”由强至弱来排序，可以将Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p>
<h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p>在Java语言中，不可变对象一定是线程安全的，无论是对象的方法实现还是方法调用者都不需要在采取任何的线程安全保障措施。</p>
<p>Java语言中，如果共享数据是一个基本类型数据，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行。如String类、枚举类等（有需要继续探究的可以去看看这些类的源码），保证对象行为不影响自己状态最简单的途径就是讲对象带有状态的变量都声明为final。</p>
<h3 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h3><p>绝对线程安全需要完全满足《Java Concurrency In Practice》一书对线程安全的定义。<br>这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不要任何额外的同步措施”通常需要付出很大的代价，在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。</p>
<h3 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h3><p>相对线程安全就是我们通常意义上的线程安全，它需要保证这个对象单独操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的联系调用，就可能需要在调用端使用额外的同步手段来保障调用的正确性。下面就展示java.util.Vector（Vector只是加了个方法锁，保证一个时间只能调用方法一次）这个线程安全的容器的不安全可能，。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误代码</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                vector.add(i);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</div><div class="line">                        vector.remove(i);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</div><div class="line">                        System.out.println(vector.get(i));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            removeThread.start();</div><div class="line">            printThread.start();</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">20</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行分析：我在自己机器上没有发生异常，但是按照作者所说的是应该会出现数组越界异常的，这是因为如果另一个线程恰好在错误的时间删除了一个元素，导致序号为i已经不再可用的话，再用i访问数组就会抛出一个ArrayIndexOutOfBoundsException，如果要保证这段代码能正确执行下去，需要改成如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对vector操作加上锁</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                vector.add(i);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">synchronized</span> (vector) &#123;</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</div><div class="line">                            vector.remove(i);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">synchronized</span> (vector) &#123;</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</div><div class="line">                            System.out.println(vector.get(i));</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            removeThread.start();</div><div class="line">            printThread.start();</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">20</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Java语言中，大部分线程安全类都属于这种类型，例如Vector、HashTable等。</p>
<h3 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h3><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全使用，我们平常说的一个类不是线程安全的，绝大多数时候是指这一种情况。Java API中大部分的类都是属于线程兼容的，如与前面Vector和HashTable相对应的集合类ArrayList和HashTable等。</p>
<h3 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h3><p>线程对立是指无论调用端是否采取了同步措施，都无法再多线程环境中并发使用代码，大部分原因是会产生死锁。</p>
<h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><p>线程安全的实现是通过代码编写以及利用虚拟机提供的同步和锁机制，而我们这主要是说一下虚拟机线程安全手段的运作过程。</p>
<h3 id="互斥同步（阻塞同步）"><a href="#互斥同步（阻塞同步）" class="headerlink" title="互斥同步（阻塞同步）"></a>互斥同步（阻塞同步）</h3><p>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、信号量（都没用过）、互斥量都是主要的互斥实现方式。互斥是因，同步是果；互斥是方法，同步是目的。主要的互斥同步手段有下面两种：</p>
<ol>
<li>使用synchronizd关键字，synchronized关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这个两个字节码指令，这两个字节码都需要一个 reference类型的参数来指明要锁定和解锁的对象；如果java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。在执行monitorenter指令时，如果这个对象没有锁定或当前线程已经拥有了那个对象的锁，锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1；当计数器为0时，锁就被释放了。对于monitorenter 和 monitorexit的行为描述中，有两点需要注意：<ul>
<li>synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。</li>
<li>同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。</li>
</ul>
</li>
<li>使用java.util.concurrent（J.U.C）包中的重入锁（ReentrantLock）。synchronized 和 ReentrantLock 的区别： 一个表现为 API 层面的互斥锁（lock() 和 unlock() 方法配合 try/finally语句块来完成），另一个表现为原生语法层面的互斥锁；ReentrantLock增加了一些高级功能主要有以下3项：<ul>
<li>等待可中断：指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮 助 。</li>
<li>公平锁：指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</li>
<li>锁绑定多个条件：指一个 ReentrantLock对象可以同时绑定多个 Condition对象，而在 synchronized中，锁对象的wait() 和 notify() 或 notifyAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock 则无需这样做，只需要多次调用 newCondition() 方法即可。</li>
</ul>
</li>
<li>关于两者的性能在JDK1.6以后，两者基本持平了，所以提倡在synchronized能实现需求的情况下，优先考虑使用sychronized来进行同步锁。</li>
</ol>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><ol>
<li>阻塞同步与非阻塞同步的对比：阻塞同步是一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁）就会出现问题，所以会带来进行线程阻塞和唤醒的性能问题；非阻塞同步是一种基于<strong>冲突检测</strong>的乐观的并发策略，它是先进行操作，如果没有其他线程争用共享数据，那操作就是成功的，如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止）。</li>
<li><p>非阻塞同步需要硬件指令集的发展：因为需要保证操作和冲突检测这两个步骤具备原子性，而这里原子性的实现是通过一条处理器指令完成的。这类指令常用的有：</p>
<ul>
<li>测试并设置</li>
<li>获取并增加</li>
<li>交换</li>
<li>比较并交换（Compare-and-set,CAS）</li>
<li><p>加载链接/条件存储</p>
<p>我们可以从J.U.C下得原子类的操作来证明这一点。</p>
</li>
</ul>
</li>
</ol>
<h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。下面介绍两类线程安全代码：</p>
<ol>
<li>可重入代码（纯代码）：，可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。如何判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。</li>
<li>线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能够保证在同一线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程内，这样，无需同步也可以保证线程间不出现数据争用问题。</li>
</ol>
<h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><p>各种锁优化技术都是为了在线程之间更加高效地共享数据，以及解决竞争问题。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><ol>
<li>为什么需要自旋锁：互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程很不值得。</li>
<li>什么是自旋锁：为了让线程等待，我们只需让线程执行一个忙循环（自旋）而不放弃处理器时间，这项技术就是所谓的自旋锁。</li>
<li>自旋时间有一定限度：如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10，用户可以用参数 -XX:PreBlockSpin 来更改。</li>
<li>自适应自旋锁：jdk1.6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定；</li>
</ol>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检查到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据：来源于逃逸分析的数据支持，如果判定在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行了。其中很多无用的同步措施都是Java API自带的。</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><ol>
<li>轻量级锁：使用操作系统互斥量来实现的传统锁通常被称为重量级锁，而这个轻量级锁的出现就是是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</li>
<li>HotSpot虚拟机头Mark Word：它是实现轻量级锁和偏向锁的关键，它的内容如下表：</li>
</ol>
<table>
<thead>
<tr>
<th>存储内容</th>
<th>标志位</th>
<th>转态</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象哈希码、对象年龄分代</td>
<td>01</td>
<td>未锁定</td>
</tr>
<tr>
<td>指向所记录的指针</td>
<td>00</td>
<td>轻量级锁定</td>
</tr>
<tr>
<td>指向重量级锁的指针</td>
<td>10</td>
<td>膨胀（重量级锁定）</td>
</tr>
<tr>
<td>空，不需要记录信息</td>
<td>11</td>
<td>GC标记</td>
</tr>
<tr>
<td>偏向线程ID、偏向时间戳、对象分代年龄</td>
<td>01</td>
<td>可偏向</td>
</tr>
</tbody>
</table>
<ol>
<li>在进入同步代码块时，轻量级锁加锁过程：<ul>
<li>如果此同步对象没有被锁定（锁标志位为01状态）：虚拟机首先将在当前线程的栈帧中建立一个名为锁记录的空间，用于存储对象目前的Mark Word的拷贝（Displace Mark Word）。</li>
<li>然后，虚拟机将使用CAS 操作尝试将对象的 Mark Word 更新为指向Lock Record的指针。</li>
<li>如果这个更新工作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为 00，即表示此对象处于轻量级锁定状态；</li>
<li>如果这个更新失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象以及被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为 10，Mark Word中存储的就是指向重量级（互斥量）的指针，后面等待锁的线程也要进入阻塞 状态。</li>
</ul>
</li>
<li>轻量级锁解锁过程：<ul>
<li>如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS 操作把对象当前的Mark Word和线程中复制的 Displaced Mark Word替换回来。</li>
<li>如果替换成功，整个同步过程就完成了。</li>
<li>如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。</li>
</ul>
</li>
<li>轻量级锁能提升程序同步性能的依据是：对于绝大部分的锁，在整个同步周期内都是不存在竞争的。</li>
</ol>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><ol>
<li>偏向锁的目的：消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS 操作都不做了。</li>
<li>偏向锁的偏：它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</li>
<li>偏向锁过程：若当前虚拟机启用了偏向锁，那么，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为01，即偏向模式；同时使用CAS操作把获取到这个锁的线程的ID 记录在对象的 Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。当有另一个线程去尝试获取这个锁时，偏向模式就结束了，根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定（标志位为01）或轻量级锁定（标志位为00）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。</li>
<li>偏向锁是一个带有效益权衡性质的优化：偏向锁可以提高带有同步但无竞争的程序性能，但是如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式是多余的。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于线程安全我们可以有明确的定义，然后我们也知道了线程安全的实现方式，以及虚拟机为我们提供的各种锁优化。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入理解Java虚拟机》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：面向对象的编程思想极大的提升了现在软件开发的生产效率和软件可以达到的规模，但是现实中对象在一项工作进行期间，会被不停地中断和切换，对象的属性可能会在中断期间被修改和变“脏”，所以我们在谈“高效并发”之前必须先保证并发的正确性和如何实现线程安全。
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_13_Java内存模型与线程</title>
    <link href="http://bestlixiang.site/2017/12/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-13-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://bestlixiang.site/2017/12/13/深入理解JVM-13-Java内存模型与线程/</id>
    <published>2017-12-13T15:27:12.000Z</published>
    <updated>2017-12-14T10:29:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：并发处理的广泛应用是使得阿姆德尔定律替代摩尔定律成为计算机性能发展原动力的根本原因。由于计算机的运算速度和它的存储和通信子系统速度差距太大，所以才出现了并发，而并发绝对是Java运用很大的优势。我们绝对需要理解！<a id="more"></a></p>
<h1 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h1><p>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的告诉缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步到内存之中，这样处理器就无须等待缓慢的内存读写了。</p>
<p>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为引入了一个新的问题：缓存一致性。为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。下面是常用的内存模型图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/image/jpg/AcheModel.jpg" alt="内存模型图"></p>
<p>除了增加高速缓存之外，为了使得处理器的内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化。</p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>目的：让Java程序在各种平台下都能达到一致的内存访问效果。</p>
<h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java编程中所说的变量有所区别，它包括实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享。</p>
<p>Java内存模型规定了所有的变量都存储在主内存中（此处的主内存与介绍物理硬件时的主内存可以类比，但是此处仅仅是虚拟机内存的一部分）。每条线程都有自己的工作内存（可以与处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/image/jpg/JavaAcheModel.jpg" alt="Java内存模型"></p>
<p>这里的Java内存模型如果和Java运行时内存勉强对应，可以这样理解：主内存主要对应Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存直接对应于物理硬件内存，而工作内存优先存储于寄存器和高速缓存中。</p>
<h2 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h2><p>Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。</p>
<ol>
<li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ol>
<p>如果要把一个变量从主内存复制到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按照顺序地执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证必须是连续执行。Java内存模型规定了在执行上述八种基本操作时必须满足时必须满足如下规则：</p>
<ol>
<li>不允许read和load、store和write操作之一单独出现。</li>
<li>不允许一个线程丢弃它的最近的assign操作。</li>
<li>不允许一个线程无原因的（没有发生过任何assign操作）把数据从线程的工作内存同步到主内存中</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li>
<li>如果一个变量事先没有被lock锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定住的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write）。</li>
</ol>
<p>这8种内存访问操作以及上述规则限定，再加上volatile的一些特殊规定，就已经完全确定了Java程序中哪些内存访问操作是并发是安全的。</p>
<h2 id="对于volatile修饰的变量的特殊规则"><a href="#对于volatile修饰的变量的特殊规则" class="headerlink" title="对于volatile修饰的变量的特殊规则"></a>对于volatile修饰的变量的特殊规则</h2><p>关键字volatile是Java虚拟机提供的最轻量级的同步机制。Java内存模型堆volatile专门定义了一些特殊的访问规则。当一个变量定义为volatile之后，它将具备以下两种特性：</p>
<ol>
<li>保证此变量对所有线程的<strong>可见性</strong>：当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性。<ul>
<li>运算结果不依赖变量的当前值，或者只能保证只有单一的线程来保证原子性。</li>
<li>变量不需要与其他状态变量共同参与不变约束。（目前不理解）</li>
</ul>
</li>
<li>禁止指令重排序优化：如果有两个或者更多CPU访问同一块内存，且其中有一个在观测另一个，那么它会通过设置<strong>内存屏障</strong>来使重排序时不能把后面的指令重排序到内存屏障之前访问。</li>
</ol>
<p>volatile的意义：volatile变量读操作的消耗与普通变量几乎没有什么差别，但是写操作则可能慢一点，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，不过即便如此，大多数场景下volatile得总开销仍然比锁低。</p>
<p>volatile的特殊规则就是：use/assign、load/store、read/write操作必须连续一起出现，即volatile修饰的变量不会被指令重排序优化。</p>
<h2 id="对于long和double类型的变量的特殊规则"><a href="#对于long和double类型的变量的特殊规则" class="headerlink" title="对于long和double类型的变量的特殊规则"></a>对于long和double类型的变量的特殊规则</h2><p>Java内存模型要求对于lock、unlock、read、load、assign、use、store和write这八个操作都具有原子性，但是对于64位的数据类型（long和double），允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，但是强烈建议虚拟机实现为具有原子性的操作。</p>
<h2 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为基本数据类型的访问读写是具备原子性的。synchronized关键字可以实现原子性。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性就是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。volatile、synchronized以及final关键字都能实现可见性。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。volatile和synchronized关键字都能实现有序性。</p>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了小写、调用了方法等。</p>
<p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发送关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，他们就没有顺序性保障，虚拟机可以对它们进行随意重新排序：</p>
<ol>
<li>程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前的操作先于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</li>
<li>volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。“后面”是指时间上的先后顺序。</li>
<li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li>线程终止规则（Thread Termination Rule）：线程中所有操作都先行发生于此线程的终止检测。</li>
<li>线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>
<li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li>
<li>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得到操作A先行发生于操作C。</li>
</ol>
<h1 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h1><p>在Java里面谈论并发，大多数都与线程脱不开关系。我们需要知道在Java线程在虚拟机的实现。</p>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源，又可以独立调度（线程是CPU调度的基本单位）。</p>
<p>实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级线程混合实现。</p>
<h2 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h2><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。</p>
<ol>
<li>协同式线程调度：线程的执行时间由线程本身来控制，线程把自己的工作执行完毕后，要主动通知系统切换到另一个线程上去。好处是实现简单，没有线程同步问题；缺点是：线程执行时间不可控制，容易导致整个系统崩溃。</li>
<li>抢占式线程调度：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。好处是线程执行之间可控，不会有一个线程导致整个进程阻塞的问题，Java使用的线程调度方式就是抢占式调度。这里说一下就是java线程优先级不太靠谱，原因是Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统。</li>
</ol>
<h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><p>Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别是：新建，运行，无限期等待，限期等待，阻塞，结束。上述5种状态在遇到特定时间发生的时候回互相转换，他们的转换关系如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/image/jpg/threadStateThansform.jpg" alt="线程状态转换关系"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虚拟机本身具有一套和线程相关内存模型，我们需要利用好它，特别是要理解线性发生原则以及volatil的一些特殊规则。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入理解Java虚拟机》</li>
<li><a href="https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html" target="_blank" rel="external">Java内存模型</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：并发处理的广泛应用是使得阿姆德尔定律替代摩尔定律成为计算机性能发展原动力的根本原因。由于计算机的运算速度和它的存储和通信子系统速度差距太大，所以才出现了并发，而并发绝对是Java运用很大的优势。我们绝对需要理解！
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_12_晚期（运行期）优化</title>
    <link href="http://bestlixiang.site/2017/12/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-12-%E6%99%9A%E6%9C%9F%EF%BC%88%E8%BF%90%E8%A1%8C%E6%9C%9F%EF%BC%89%E4%BC%98%E5%8C%96/"/>
    <id>http://bestlixiang.site/2017/12/12/深入理解JVM-12-晚期（运行期）优化/</id>
    <published>2017-12-12T14:18:20.000Z</published>
    <updated>2017-12-12T14:19:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：之前说过Java中的JIT即时编译器在运行期的优化对于程序运行来说更重要，那我们就来看看这个即时编译器。本文提及的编译器、即时编译器都是指HotSpot虚拟机内的即时编译器，虚拟机也特指HotSpot虚拟机。<a id="more"></a></p>
<h1 id="什么是即时编译器"><a href="#什么是即时编译器" class="headerlink" title="什么是即时编译器"></a>什么是即时编译器</h1><p>在部分的商用虚拟机中，Java程序最初是通过解释器来解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”（Hot Spot Code）,为了提高 热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器 称为即时编译器（Just In Time Compiler,简称JIT编译器）。</p>
<h1 id="HotSpot虚拟机内的即时编译器"><a href="#HotSpot虚拟机内的即时编译器" class="headerlink" title="HotSpot虚拟机内的即时编译器"></a>HotSpot虚拟机内的即时编译器</h1><h2 id="为什么要使用解释器与编译器并存的架构"><a href="#为什么要使用解释器与编译器并存的架构" class="headerlink" title="为什么要使用解释器与编译器并存的架构"></a>为什么要使用解释器与编译器并存的架构</h2><ol>
<li>解释器与编译器各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获得更高的执行效率，当程序运行环境中内存资源限制较大时，可以使用解释执行节约内存，反之可以使用编译执行来提高效率。</li>
<li>解释器可以作为编译器激进优化时的一个“逃生门”，可以通过逆优化退回到解释器状态继续执行。</li>
</ol>
<h2 id="HotSpot虚拟机内置编译器"><a href="#HotSpot虚拟机内置编译器" class="headerlink" title="HotSpot虚拟机内置编译器"></a>HotSpot虚拟机内置编译器</h2><ol>
<li>Client Compiler(C1编译器)：使用“-client” 参数去强制指定虚拟机运行在Client模式。</li>
<li>Server Compiler(C2编译器)：使用“-server” 参数去强制指定虚拟机运行在Server模式。</li>
</ol>
<p>虚拟机默认采用解释器与编译器搭配使用的方式（混合模式）。为了在程序响应速度和运行效率之间达到最佳平衡，HotSpot虚拟机会逐渐启用分层编译策略：</p>
<ol>
<li>第0层：程序解释执行，解释器不开启性能监控功能，可触发第1层编译。</li>
<li>第1层：也称为C1编译，将字节码编译为本地代码，进行简单，可靠的优化，如果必要将加入性能监控的逻辑。</li>
<li>第2层（或2层以上）：也称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</li>
</ol>
<h2 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h2><h3 id="编译对象（热点代码）"><a href="#编译对象（热点代码）" class="headerlink" title="编译对象（热点代码）"></a>编译对象（热点代码）</h3><ol>
<li>被多次调用的方法（JIT编译方式）</li>
<li>被多次执行的循环体（OSR编译方式）</li>
</ol>
<h3 id="热点探测"><a href="#热点探测" class="headerlink" title="热点探测"></a>热点探测</h3><ol>
<li>基于采样的热点探测：虚拟机周期地检查各个线程的栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。优点是实现简单、高效，还可以很容易获取方法的调用关系（将调用堆栈展开即可），缺点就是很难精确得确认一个方法的热度，容易因为受到线程阻塞或者别的外界因素的影响而扰乱热点探测。</li>
<li>基于计数器的热点探测：虚拟机会每一个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认定它是“热点方法”。缺点是实现麻烦，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，优点是统计结果更加精确和严谨。</li>
</ol>
<p>在HotSpot虚拟机中使用的是基于计数器的热点探测方法。因此它为每个方法准备了两类计数器：方法调用计数器（用于探测方法）和回边计数器（用于探测循环体）。这两个计数器都有一个确定的阈值，当计数器超过了阈值，就会提交编译请求。</p>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>在默认设置下，无论是方法调用产生的即时编译请求，还是OSR编译请求，虚拟机代码编译器还未完成之前，都依然将按照解释方式继续执行，而编译动作则在后台的编译线程中进行。</p>
<h3 id="Client-Compiler"><a href="#Client-Compiler" class="headerlink" title="Client Compiler"></a>Client Compiler</h3><p>它是个三段式编译器，主要关注点在<strong>局部性</strong>的优化，放弃了许多耗时较长的全局优化手段。下面是三个阶段</p>
<ol>
<li>字节码-&gt;高级中间代码（HIR）:使用静态单分配的形式来代表代码值，其中会完成方法内联、常量传播等优化。</li>
<li>HIR-&gt;低级中间代码（LIR）：会在HIR上完成空值检查消除、范围检查消除等优化，以便让HIR达到更高效的代码的表示形式。</li>
<li>LIR-&gt;机器代码：在平台相关的后端使用线性扫描算法在LIR上分配寄存器，并在LIR上做窥孔优化。</li>
</ol>
<h3 id="Server-Compiler"><a href="#Server-Compiler" class="headerlink" title="Server Compiler"></a>Server Compiler</h3><p>它是专门面向服务端的典型应用并为服务器端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器。它会执行所有经典的优化工作。它的寄存器分配器是一个全局图着色分配器，可以充分利用某些处理器架构上的大寄存器集合。</p>
<h3 id="查看及分析即时编译结果"><a href="#查看及分析即时编译结果" class="headerlink" title="查看及分析即时编译结果"></a>查看及分析即时编译结果</h3><p>这一块我没有去实践，但是这里写一个结论：在Java中空循环不能用作程序延时的手段，因为空循环会被优化消除。</p>
<h1 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a>编译优化技术</h1><p>Java程序员有一个共识：以编译方式执行本地代码比解释方式更快。这主要是因为虚拟机设计团队几乎把对代码的所有优化措施都集中在编译器之中了。关于HotSpot的优化技术列表可以参考《深入理解Java虚拟机》一书，这里也根据书上举的几个例子来看看其中的优化技术。</p>
<h2 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h2><p>含义是：如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有的变量的值都没有发生变化，那么E的这次出现就成为了公共子表达式。对于这种表达式，没有必要花时间再对它进行计算，只需要直接用前面计算过的表达式结果代替E即可。可以看看下面的优化历程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 源代码</span></div><div class="line"><span class="keyword">int</span> d = (c * b) * <span class="number">12</span> + a + (a + b * c);</div><div class="line"></div><div class="line"><span class="comment">// 编译器检测到“c * b”和“b * c”是一样的表达式，这条表达式就变成下面这样了</span></div><div class="line"><span class="keyword">int</span> d = E * <span class="number">12</span> + a + (a + E);</div><div class="line"></div><div class="line"><span class="comment">// 编译器还可能进行代数简化，把表达式变为：</span></div><div class="line"><span class="keyword">int</span> d = E * <span class="number">13</span> + a * <span class="number">2</span>;</div></pre></td></tr></table></figure></p>
<p>大家肯定能发现，最后的表达式计算起来就可以节省时间了。</p>
<h2 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h2><p>含义：虚拟机执行子系统每次数组的读写都带有一次隐含的条件判断操作，这对于拥有大量 数组访问的程序代码，无疑是一种性能负担。解决思路除了将数组边界检查优化尽可能把运行期检查提到编译期完成之外，还有另一种思路——隐式异常处理（try - catch）。可以看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 源代码</span></div><div class="line"><span class="keyword">if</span> (foo != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> foo.value</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointException();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译器转换代码</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> foo.value;</div><div class="line">&#125; <span class="keyword">catch</span>(segment_fault) &#123;</div><div class="line">    uncommon_trap();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样可以避免每次去做非空检查。</p>
<h2 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h2><p>它除了消除方法调用成本之外，它更重要的是位其他优化手段建立良好的基础，如果不做内联，就发现不了无用代码。。内联具有两种情况：</p>
<ol>
<li>对于非虚方法：直接内联</li>
<li>对于虚方法：会使用“类型继承关系分析”（CHA）技术，虚拟机如果遇到虚方法就会向CHA查询此方法在当前程序下是否有多个目标版本可供选择，如果查询结果只有一个版本，就可以进行内联，不过这种内联属于激进优化，需要余留一个“逃生门”，称为守护内联；如果查出有多个版本的目标方法可供选择，则编译器还会使用内联缓存来完成方法内联。</li>
</ol>
<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>它也是为其他优化手段提供依据的技术，它的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。甚至还有可能被外部线程访问到，例如复制给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p>
<p>如果能证明一个对象不会逃逸到方法或者线程之外，则可能为这个变量进行一些高效的优化：</p>
<ol>
<li>栈上分配：让对象直接在栈上分配内存，这样大量对象就会随着方法的结束而自动销毁了，垃圾收集系统的压力将会小很多。</li>
<li>同步消除：对变量实施的同步措施可以消除掉</li>
<li>标量替换：不能再分解的量称为标量（如：数值类型），可以继续分解的称为聚合量（如：对象），我们可以直接将对象拆分成标量存在栈上。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对于JIT编译的学习，我么可以知道哪些代码编译器是可以帮我们优化的，以及哪些代码是需要自己调节以便更合适编译器的优化。这样我们才可以写出更高效的代码。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入理解Java虚拟机》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：之前说过Java中的JIT即时编译器在运行期的优化对于程序运行来说更重要，那我们就来看看这个即时编译器。本文提及的编译器、即时编译器都是指HotSpot虚拟机内的即时编译器，虚拟机也特指HotSpot虚拟机。
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_11_早期（编译期）优化</title>
    <link href="http://bestlixiang.site/2017/12/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-11-%E6%97%A9%E6%9C%9F%EF%BC%88%E7%BC%96%E8%AF%91%E6%9C%9F%EF%BC%89%E4%BC%98%E5%8C%96/"/>
    <id>http://bestlixiang.site/2017/12/10/深入理解JVM-11-早期（编译期）优化/</id>
    <published>2017-12-10T13:36:22.000Z</published>
    <updated>2017-12-10T13:36:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：之前简单的提到过java程序的使用首先要经过编译，然后再“解释”执行，这里我们就先看看它在编译期的过程。<a id="more"></a></p>
<h1 id="编译概述"><a href="#编译概述" class="headerlink" title="编译概述"></a>编译概述</h1><p>java的编译期其实是一段“不确定”的操作过程，它有一下几种形式：</p>
<ol>
<li>前端编译器：把<em>.java文件转变为</em>.class文件的过程，如：Sun的javac、Eclipse JDT中的增量式编译器。</li>
<li>虚拟机的后端运行期编译器（JIT编译器）：把字节码转变成机器码的过程，如HotSpotVM的C1、C2编译器。</li>
<li>静态提前编译器（AOT编译器）：直接把*.java文本编译为本地机器代码的过程：GNU Compiler for the Java、Excelsior JET。</li>
</ol>
<p>我们平时所说的编译基本上都是指第一类，前端编译器。总的来说，Java中的JIT即时编译器在运行期的优化对于程序运行来说更重要，而前端编译器在编译器的优化过程对于程序编码来说关系更密切，相当多新生的Java语法特性，都是靠编译器的“语法糖”来实现的。</p>
<h1 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h1><p>编译过程大致分为3个过程：</p>
<ol>
<li>解析与填充符号表过程</li>
<li>插入式注解处理器的注解处理过程</li>
<li>分析与字节码生成过程</li>
</ol>
<p>这3个过程之间的关系与交互顺序如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/image/png/javac_compiler.png" alt="javac_compiler"></p>
<h2 id="解析与填充符号表过程"><a href="#解析与填充符号表过程" class="headerlink" title="解析与填充符号表过程"></a>解析与填充符号表过程</h2><p>其中解析步骤包括了经典程序编译原理找那个的词法分析和语法分析两个过程。</p>
<h3 id="词法、语法分析"><a href="#词法、语法分析" class="headerlink" title="词法、语法分析"></a>词法、语法分析</h3><ol>
<li>词法分析：将源代码的字符流转变为标记（Token）集合，单个字符是程序编写过程的最小元素，而标记是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记。</li>
<li><p>语法分析：根据Token序列构造抽象语法树，抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、运算符、接口、返回值甚至代码注释都可以是一个语法结构。如下图：</p>
<p> <img src="http://img.blog.csdn.net/20160726103442665" alt="abstract syntax tree"></p>
</li>
</ol>
<p>经过上面两个步骤编译器就基本不会再对源文件进行操作了。</p>
<h3 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h3><ol>
<li>符号表是由一组符号地址和符号信息构成的表格，类似k-v形式。符号表中登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。</li>
<li>在Java源代码中，填空符号表过程的出口是一个待处理列表，包含了每一个编译单元的抽象语法数的顶级节点，以及package-info.java（如果存在）的顶级节点。</li>
</ol>
<h2 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h2><p>JDK1.6之中提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，可以把它看做是一组编译器插件，在这些插件中，可以读取、修改、添加抽象语法树中的任意元素。若这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round。如编译过程图的回环过程。</p>
<h2 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h2><p>语法分析之后，编译器获得程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的，而语义分析的主要任务是对结构上正确地源程序进行上下文有关性质的审查，如类型审查。语义分析过程分为标注检查以及数据及控制流分析两个步骤。</p>
<h3 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h3><p>标注检查步骤检查的内容包括诸如变量使用前是否已被声明，变量与赋值之前的数据类型能否匹配，还有一个重要的动作是常量折叠，如果我们在代码写了如下定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">1</span> + <span class="number">2</span>;</div></pre></td></tr></table></figure></p>
<p>在经过变量折叠之后，1 + 2会被折叠为字面量3。所以在代码里定义int a = 1 + 2比起直接定义int a = 3并不会增加程序运行期的运算量。</p>
<h3 id="数据及控制流分析"><a href="#数据及控制流分析" class="headerlink" title="数据及控制流分析"></a>数据及控制流分析</h3><p>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受检异常都被正确处理了等问题，编译期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或者运行期才能进行，如方法的参数以及局部变量的检查就只会在编译器检查。</p>
<h3 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h3><ol>
<li>语法糖：指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，当时更方便使用，Java最常用的语法糖主要有泛型、变长参数、自动装箱、拆箱等</li>
<li>解语法糖：虚拟机运行时不支持这些语法，他们会在编译阶段还原回简单的基础语法结构。</li>
</ol>
<h3 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h3><p>字节码生成是Javac编译过程的最后一个阶段，此阶段编译器还进行了少量的代码添加和转换工作。实例构造器()（不是默认构造函数）和类构造器()就是在这个阶段添加到语法树中的。完成了对语法树的遍历和调整之后，生成最终的Class文件。</p>
<h1 id="Java语法糖的味道"><a href="#Java语法糖的味道" class="headerlink" title="Java语法糖的味道"></a>Java语法糖的味道</h1><h2 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h2><ol>
<li>本质：参数化类型的应用，就是所操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法上，分别称为泛型类、泛型接口和泛型方法。</li>
<li><p>提出原因：先看下面的代码</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object object = <span class="keyword">new</span> Object();</div><div class="line">String str = (String)object;</div></pre></td></tr></table></figure>
<p> 由于编译器无法检查这个Object强制转换能否成功，为了防止保障强制类型的转换成功，避免ClassCaseException的风险转嫁到程序运行期之中，所以提出了泛型。</p>
</li>
<li>真实泛型：参数化类型无论在源码中还是编译后的中间语言都是存在的。</li>
<li><p>伪泛型：参数化类型只在源码中存在，而在中间语言不存在。可以看到下面的例子：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 泛型擦除的例子</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    map.put(<span class="string">"hello"</span>, <span class="string">"您好"</span>);</div><div class="line">    map.put(<span class="string">"how are you?"</span>, <span class="string">"最近怎么样？"</span>);</div><div class="line">    System.out.println(map.get(<span class="string">"hello"</span>));</div><div class="line">    System.out.println(map.get(<span class="string">"how are you?"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 利用Beyond Compare反编译可以得到下面的代码:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  反编译后的代码</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Map map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    map.put(<span class="string">"hello"</span>, <span class="string">"您好"</span>);</div><div class="line">    map.put(<span class="string">"how are you?"</span>, <span class="string">"最近怎么样？"</span>);</div><div class="line">    System.out.println(map.get(<span class="string">"hello"</span>));</div><div class="line">    System.out.println(map.get(<span class="string">"how are you?"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 有人可能像我一样，用jd反编译，发现泛型没有被擦除，我一开始很惊讶，后来找了参考，大家可以从参考部分看到该现象的解释，这里需要说明一点，就是由于Java泛型的引入，各种场景（虚拟机解析、反射等）下的方法调用都可能对原有的基础产生影响和新的需求，所以JCP（Java Community Process）组织对虚拟机规范做出了相应的修改，引入了诸如Signature、LocalVariabelTypeTable等新的属性用于解决伴随泛型而来的参数类型识别问题，从Signature属性的出现我们还可以得出结论：擦除泛型所谓的擦除，仅仅是对方法的Code属性中的字节码进行删除，实际上元数据中还是保留了泛型信息。</p>
</li>
</ol>
<h2 id="自动装箱、拆箱与遍历循环"><a href="#自动装箱、拆箱与遍历循环" class="headerlink" title="自动装箱、拆箱与遍历循环"></a>自动装箱、拆箱与遍历循环</h2><p>我们可以看看这些语法糖，编译的过程中做了什么处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 源代码</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxProcessTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</div><div class="line">            sum += i;</div><div class="line">        &#125;</div><div class="line">        System.out.println(sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 反编译后的代码</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxProcessTest</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">  &#123;</div><div class="line">    List list = Arrays.asList(<span class="keyword">new</span> Integer[] &#123; Integer.valueOf(<span class="number">1</span>), Integer.valueOf(<span class="number">2</span>), Integer.valueOf(<span class="number">3</span>), Integer.valueOf(<span class="number">4</span>) &#125;);</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (Iterator localIterator = list.iterator(); localIterator.hasNext();)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">int</span> i = ((Integer)localIterator.next()).intValue();</div><div class="line">      sum += i;</div><div class="line">    &#125;</div><div class="line">    System.out.println(sum);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们清楚的看到其实语法糖的最后还是用最基本的语法实现的，只是更利于我们写代码了。</p>
<p>再来看看自动装箱的陷阱：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Integer a = <span class="number">1</span>;</div><div class="line">        Integer b = <span class="number">2</span>;</div><div class="line">        Integer c = <span class="number">3</span>;</div><div class="line">        Integer d = <span class="number">3</span>;</div><div class="line">        Integer e = <span class="number">321</span>;</div><div class="line">        Integer f = <span class="number">321</span>;</div><div class="line">        Long g= <span class="number">3L</span>;</div><div class="line">        System.out.println(c == d); <span class="comment">//true</span></div><div class="line">        System.out.println(e == f); <span class="comment">//false，如果Integer在-128到127之间会保存到常量池，此时Integer直接等于数字</span></div><div class="line">        System.out.println(c == (a + b)); <span class="comment">//true</span></div><div class="line">        System.out.println(c.equals(a + b)); <span class="comment">//true</span></div><div class="line">        System.out.println(g == (a + b)); <span class="comment">//true</span></div><div class="line">        System.out.println(g.equals(a + b)); <span class="comment">//false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你对上面分不清楚的话，加上鉴于包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱，以及它们的equals()方法不处理数据类型转型的关系，建议在实际编码找那个尽量避免这样使用自动装箱与拆箱。</p>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>Java语言实现条件编译的方法是使用条件为<strong>常量</strong>的if语句，案例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 源代码</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionCompilerTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"block 1"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"block 2"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 反编译代码</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionCompilerTest</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">  &#123;</div><div class="line">    System.out.println(<span class="string">"block 1"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们很清楚的看到编译后的代码就只剩true里面的代码块了，从而实现了条件编译。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面的学习，我们可以从编译器的层次上了解Java源代码编译为字节码的过程，以及各种语法糖的前因后果。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入理解Java虚拟机》</li>
<li><a href="http://blog.csdn.net/u013678930/article/details/52032328" target="_blank" rel="external">早期（编译期）优化</a></li>
<li><a href="http://blog.csdn.net/liboyang71/article/details/72772583" target="_blank" rel="external"> 关于java泛型擦除反编译后泛型会出现问题</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：之前简单的提到过java程序的使用首先要经过编译，然后再“解释”执行，这里我们就先看看它在编译期的过程。
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_10_虚拟机字节码执行引擎</title>
    <link href="http://bestlixiang.site/2017/12/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-10-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://bestlixiang.site/2017/12/09/深入理解JVM-10-虚拟机字节码执行引擎/</id>
    <published>2017-12-09T11:55:21.000Z</published>
    <updated>2017-12-09T12:04:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：我们知道方法的代码的字节码是放在方法区的Code属性表里面，但是里面的字节码是怎么执行我们却不知道，这里通过理解虚拟机字节码执行引擎去看看这些字节码是怎么走的？<a id="more"></a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="物理机与虚拟机"><a href="#物理机与虚拟机" class="headerlink" title="物理机与虚拟机"></a>物理机与虚拟机</h2><ol>
<li>物理机的执行引擎：直接建立在处理器、硬件、指令集、和操作系统层面上。</li>
<li>虚拟机的执行引擎：自己实现，可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。</li>
</ol>
<h2 id="虚拟机怎么执行代码"><a href="#虚拟机怎么执行代码" class="headerlink" title="虚拟机怎么执行代码"></a>虚拟机怎么执行代码</h2><ol>
<li>解释执行：通过解释器执行</li>
<li>编译执行：通过即时编译器产生本地代码执行</li>
</ol>
<h1 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h1><p>栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，他是虚拟机运行时数据区中的虚拟机栈的栈元素，栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<p>一个线程的方法的调用链可能会很长，很多方法同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法，执行引擎运行的字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如下图：</p>
<p><img src="http://img.blog.csdn.net/20160605105355400" alt="Stack Frame Model"></p>
<p>接下来具体解释一下栈帧中的局部变量表、操作数栈、动态链接以及方法调用。</p>
<h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><ol>
<li>局部变量表示一组变量值存储空间，用于存放方法和方法内部定义的局部变量。</li>
<li>局部变量表的容量以<strong>变量槽Slot</strong>为单位。虚拟机规范说每个Slot都应该存放一个boolean、byte、char、int、float、reference或returnAddress类型的数据。long和double使用两个Slot。</li>
<li>reference类型在虚拟机中至少要实现能从该引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引以及从该引用直接或者间接查找到对象所属数据类型在方法区中存储的类型信息。</li>
<li>虚拟机通过索引定位的方式使用局部变量表，如果执行的实例方法，那局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，可以使用“this”来访问，其余参数按照参数表顺序排列。</li>
<li><p>局部变量表中的Slot是可以重用的，当某个变量除了它的作用域，那这个变量所对应的Slot就可以复用了，Slot的复用会直接影响到系统的垃圾收集行为，如下代码所示：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 例1</div><div class="line">// VM args : -verbose:gc</div><div class="line"></div><div class="line">public class StackFrameTest &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        byte[] placeholder = new byte[64 * 1024 * 1024];</div><div class="line"></div><div class="line">        System.gc();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 输出结果：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[GC (System.gc())  68209K-&gt;66072K(125952K), 0.0019584 secs]</div><div class="line">[Full GC (System.gc())  66072K-&gt;65962K(125952K), 0.0069900 secs]</div></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 例2</div><div class="line">// VM args : -verbose:gc</div><div class="line"></div><div class="line">public class StackFrameTest &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        &#123;</div><div class="line">            byte[] placeholder = new byte[64 * 1024 * 1024];</div><div class="line">        &#125;</div><div class="line">        System.gc();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 输出结果</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[GC (System.gc())  68875K-&gt;66072K(125952K), 0.0010138 secs]</div><div class="line">[Full GC (System.gc())  66072K-&gt;65962K(125952K), 0.0069811 secs]</div></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 例3</div><div class="line">// VM args : -verbose:gc</div><div class="line"></div><div class="line">public class StackFrameTest &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        &#123;</div><div class="line">            byte[] placeholder = new byte[64 * 1024 * 1024];</div><div class="line">        &#125;</div><div class="line">        int a = 0;</div><div class="line">        System.gc();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 输出结果</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[GC (System.gc())  68875K-&gt;66072K(125952K), 0.0016694 secs]</div><div class="line">[Full GC (System.gc())  66072K-&gt;426K(125952K), 0.0054452 secs]</div></pre></td></tr></table></figure>
<p> placeholde能否被回收的根本原因是：局部变量的Slot是否还存有关于placeholder数组对象的引用。例1没有垃圾回收，例2代码虽然已经离开了placeholder的作用域，但是之后没有任何对局部变量表的读写操作，所有placeholder原来的Slot还没有被其他变量复用，所以GC Roots一部分的局部变量表仍然保持着对它的关联，当例3修改了局部变量表，那么就会进行垃圾回收了。</p>
<p> 这里解释一个编码建议：<strong>不使用的对象应手动赋值null</strong></p>
<p> 我们看看下面的代码：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 例1</div><div class="line">// VM args : -verbose:gc</div><div class="line"></div><div class="line">public class StackFrameTest &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        byte[] placeholder = new byte[64 * 1024 * 1024];</div><div class="line">        placeholder = null;</div><div class="line">        System.gc();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 输出结果：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[GC (System.gc())  68875K-&gt;66072K(125952K), 0.0016915 secs]</div><div class="line">[Full GC (System.gc())  66072K-&gt;426K(125952K), 0.0058140 secs]</div></pre></td></tr></table></figure>
<p> 我们可以看到当placeholder赋值为null，会发生垃圾回收。</p>
</li>
<li><p>局部变量表没有赋初始值不能使用。</p>
</li>
</ol>
<h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><ol>
<li>操作数栈常被称为操作栈，一个方法刚开始执行的时候是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容，例如，在做算术运算的时候是通过操作数栈来 进行的，又或者是在调用方法的时候通过操作数栈来进行参数传递的。</li>
<li><p>在概念模型中，两个栈帧是完全独立的，但在大多虚拟机的实现里会做一些优化处理，令两个栈帧的部分操作数出现一部分重叠，避免方法调用时额外的参数复制，如下图：</p>
<p><img src="http://img.blog.csdn.net/20160605151831616" alt="data share"></p>
</li>
<li><p>Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中的栈就是操作数栈。</p>
</li>
</ol>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><ol>
<li>每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，持有这个引用就是为了支持方法调用过程中的动态链接。</li>
<li>Class文件的常量池存有大量的符号引用，一部分是在类加载中的解析阶段完成的，称为静态解析，另一部分是在每一次运行期间转化为直接引用，称为动态链接。</li>
</ol>
<h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>当一个方法开始执行后，只有两种方式退出这个方法。</p>
<ol>
<li>正常完成出口：执行引擎遇到一个方法返回的字节码指令，调用者的PC计数器的值可以作为返回地址</li>
<li>异常完成出口：在方法执行过程中遇到异常，并且这个异常没有在方法体得到处理，它不会给调用者产生任何返回值，它的返回值是要通过异常处理器表来确定的。</li>
</ol>
<h1 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h1><p>方法调用不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本。Class文件的编译过程不包含传统编译找那个的链接步骤，所以Java方法调用过程需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析： 方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用在运行期是不可变的，这类方法的调用成为解析。</p>
<p>所有方法可以分为两类虚方法和非虚方法，其中非虚方法都可以在类加载的时候就会把符号引用解析为该方法的直接引用。</p>
<ol>
<li>非虚方法：静态方法、私有方法、实例构造器、父类方法和final方法</li>
<li>虚方法：与非虚方法相反</li>
</ol>
<p>解析调用一定是个静态的过程，在编译器就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派调用则可能是静态也可能是动态的，根据分派的宗数量（方法的接收者与方法的参数统称为方法的总量）可分为单分派和多分派，这两种分派方式地组合可分为静态单分派、静态多分派、动态单分派、动态多分派。</p>
<h2 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h2><h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Human man = <span class="keyword">new</span> Man();</div></pre></td></tr></table></figure>
<p>上面代码中Human称为变量的静态类型，或者叫做外观类型，后面的Man称为实际类型，静态类型是编译器可知，实际类型是运行期才能确定的。虚拟机在重载时是通过参数的静态类型而不是实际类型来作为判断依据的。</p>
<p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派，静态分派的典型应用是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的，另外，编译器虽然能确定出方法的重载版本，当在很多情况下这个重载版本不是“唯一的”，往往只能确定一个“更加合适的”版本，具体例子可以看看《深入理解Java虚拟机》。</p>
<h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派，典型应用是方法重写。它主要是通过invokevirturl指令来实现的。invokevirtual指令的运行时解析过程大致分为如下几个步骤：</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ol>
<h3 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h3><p>单分派是根据一个宗量对目标方法进行选择，多分派则是根据一个宗量对目标方法进行选择。我们结合下面的代码来理解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"father choose qq"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"father choose _360"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"son choose qq"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"son choose _360"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Father father = <span class="keyword">new</span> Father();</div><div class="line">        Father son = <span class="keyword">new</span> Son();</div><div class="line">        father.hardChoice(<span class="keyword">new</span> _360());</div><div class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">father choose _360</div><div class="line">son choose qq</div></pre></td></tr></table></figure></p>
<ol>
<li>编译阶段编译器的选择过程（静态分派过程）：这时选择目标方法的依据有两点：一是静态类型是Father还是Son，二是方法参数是QQ还是360。因为是根据两个宗量进行选择，所有Java语言的静态分派属于多分派类型。</li>
<li>运行阶段虚拟机的选择过程（动态分派过程）：由于编译器已经已经决定目标方法的签名必须为hardChoice(QQ)，所以这时参数的静态类型，实际类型都对方法的选择不会构成影响，唯一可以影响虚拟机选择的因素只有此方法的接受者的实际类型是Father还是Son,因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。</li>
<li>jdk1.8之前的Java语言是一门静态多分派，动态单分派的语言。</li>
</ol>
<h3 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h3><p>由于动态分派是非常频繁的操作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此虚拟机会进行优化。常用的方法就是为类在方法区中建立一个虚方法表（Virtual Method Table，在invokeinterface执行时也会用到接口方法表，Interface Method Table），使用虚方法表索引来替代元数据查找以提升性能。下图就是前面代码的虚方法表结构：</p>
<p><img src="http://img.blog.csdn.net/20160606200822089" alt="virtual method table"></p>
<p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类重写了父类的方法，子类方法表中的地址会替换为指向子类实现版本的入口地址。在上图中，Son重写了Father的全部方法，所以Son的方法表替换了父类的地址。但是Son和Father都没有重写Object的方法，所以方法表都指向了Object的数据类型。<br>为了程序实现上的方便，具有相同签名的方法，在父类和子类的虚方法表中都应该具有一样的索引号，这样当类型变换时，仅仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。<br>方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。</p>
<h2 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h2><p>动态类型语言的关键特征是它的类型检查的主体过程是在运行期间而不是编译期间，可以理解为<strong>变量无类型而变量值才有类型</strong>，Javascript就是这样的语言，而目前Java属于静态类型语言。当然Java也有它实现动态性的方法，这块知识点蛮大，就不展开说了。</p>
<h1 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h1><h2 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h2><p>先看看编译过程流图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/image/png/compilers.png" alt="compilers"></p>
<ol>
<li>上图最下面的那一条就是传统编译原理中程序代码到目标机器代码生成过程（C）</li>
<li>上图中间那一条就是解释执行的过程（Java）</li>
</ol>
<h2 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h2><ol>
<li>基于栈的指令集：指令流中的大部分都是零地址指令（无显示参数），他们依赖操作数栈进行工作。<ul>
<li>优点：可移植性，代码紧凑，编译器实现简单</li>
<li>缺点：执行速度稍慢（频繁访问内存）</li>
</ul>
</li>
<li>基于寄存器的指令集：指令集依赖寄存器进行工作</li>
</ol>
<h2 id="基于栈的解释器执行流程"><a href="#基于栈的解释器执行流程" class="headerlink" title="基于栈的解释器执行流程"></a>基于栈的解释器执行流程</h2><p>其实就是按照指令解释执行，随便看了例子应该就能明白。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实这里谈的主要还是解释执行，其中有一点很重要就是分派的概念，明白invokevirtual指令的执行过程。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入理解Java虚拟机》</li>
<li><a href="http://blog.csdn.net/u012877472/article/details/51585297" target="_blank" rel="external">虚拟机字节码执行引擎</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：我们知道方法的代码的字节码是放在方法区的Code属性表里面，但是里面的字节码是怎么执行我们却不知道，这里通过理解虚拟机字节码执行引擎去看看这些字节码是怎么走的？
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_9_类加载器</title>
    <link href="http://bestlixiang.site/2017/12/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-9-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://bestlixiang.site/2017/12/06/深入理解JVM-9-类加载器/</id>
    <published>2017-12-06T02:59:56.000Z</published>
    <updated>2017-12-09T12:04:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：之前一直在说类加载，类加载就需要类加载器，类加载最初是为了满足Java Applet，现在基本已经死掉了，但是类加载却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为Java体系中一块重要的基石，可谓失之桑榆，收之东隅。<a id="more"></a></p>
<h1 id="什么是类加载器？"><a href="#什么是类加载器？" class="headerlink" title="什么是类加载器？"></a>什么是类加载器？</h1><p>虚拟机设计团队把类加载阶段的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己去决定如何去获取所需要的类，实现这个动作的代码模块称为“类加载器”。</p>
<h1 id="同一个Class文件，不同的类"><a href="#同一个Class文件，不同的类" class="headerlink" title="同一个Class文件，不同的类"></a>同一个Class文件，不同的类</h1><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。换个说法：比较两个类是否“相等”，只是在这两个类是由同一个类加载器加载的前提下才有意义，如果这两个类源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<p>这里的相等包括：代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法返回结果，下面的代码展示了不同的类加载器对instanceof关键字运算的结果的影响。(下面的代码属于破坏双亲委派模型，只是为了验证类的命名空间)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</div><div class="line"></div><div class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</div><div class="line">                    <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</div><div class="line">                    is.read(b);</div><div class="line">                    <span class="keyword">return</span> defineClass(name,b,<span class="number">0</span>,b.length);</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Object obj = myLoader.loadClass(<span class="string">"com.todorex.demo.ClassLoaderTest"</span>).newInstance();</div><div class="line"></div><div class="line">        System.out.println(obj.getClass());</div><div class="line"></div><div class="line">        System.out.println(obj <span class="keyword">instanceof</span> com.todorex.demo.ClassLoaderTest );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class com.todorex.demo.ClassLoaderTest</div><div class="line">false</div></pre></td></tr></table></figure></p>
<p>这里的false就证明了两个类虽然来自于同一个Class文件，但是由于使用的类加载器不同，就依然是两个独立的类。</p>
<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><h2 id="类加载器的类型"><a href="#类加载器的类型" class="headerlink" title="类加载器的类型"></a>类加载器的类型</h2><h3 id="Java虚拟机角度"><a href="#Java虚拟机角度" class="headerlink" title="Java虚拟机角度"></a>Java虚拟机角度</h3><ol>
<li>启动类加载器，它本身是由C++语言实现，或者底层的关键方法是用C实现的。</li>
<li>所有其他类加载器，这些类加载器都由Java语言实现。</li>
</ol>
<h3 id="Java开发人员角度"><a href="#Java开发人员角度" class="headerlink" title="Java开发人员角度"></a>Java开发人员角度</h3><ol>
<li>启动类加载器：这个类加载器负责将存放在<java_home>\lib目录中的，或者被-Xbootclasspath参数所指定的路径找那个的，并且是虚拟机识别的（按照文件名识别的）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接使用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，直接使用null即可。（不知道怎么用，知道的大佬请告知！！！！）</java_home></li>
<li>扩展类加载器：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<java_home>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以使用扩展类加载器。</java_home></li>
<li>应用程序类加载器：这个类加载器由sun.misc.Launcher$AppClassLoader实现，也称系统类加载器。它负责加载用户所指定的类路径java -classpath或-Djava.class.path的所有类，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ol>
<h2 id="类加载器的双亲委派模型"><a href="#类加载器的双亲委派模型" class="headerlink" title="类加载器的双亲委派模型"></a>类加载器的双亲委派模型</h2><h3 id="模型图"><a href="#模型图" class="headerlink" title="模型图"></a>模型图</h3><p><img src="http://o6plzvjf2.bkt.clouddn.com/image/parentsDelegationModel.jpg" alt="Parents Delegation Model"></p>
<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里的类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。（组合就是在一个类中调用另一个类的代码）</p>
<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>我相信这张图最清楚了：</p>
<p><img src="http://static.zybuluo.com/Rico123/8ty4pk8xgubfhq123dhxg68m/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E7%B1%BB%E7%9A%84%E8%BF%87%E7%A8%8B" alt="双亲委派模型工作流程"></p>
<p>我们可以由图看到以下过程：</p>
<ol>
<li>自底向上检查类是否已经加载，若已加载，直接返回。</li>
<li>若所有父类都没有加载该类，则自顶向下尝试加载该类。</li>
<li>如果加载不成功，则抛出ClassNotFoundException异常。</li>
</ol>
<p>我们可以从代码看看他是怎么实现的？</p>
<ol>
<li>先看ClassLoader函数的loadClass函数<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</div><div class="line">      <span class="keyword">throws</span> ClassNotFoundException</div><div class="line">  &#123;</div><div class="line">      <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</div><div class="line">          <span class="comment">// 先从缓存查找该class对象，找到就不用重新加载</span></div><div class="line">          Class&lt;?&gt; c = findLoadedClass(name);</div><div class="line">          <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line">              <span class="keyword">try</span> &#123;</div><div class="line">                  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">                      <span class="comment">//如果找不到，则委托给父类加载器去加载</span></div><div class="line">                      c = parent.loadClass(name, <span class="keyword">false</span>);</div><div class="line">                  &#125; <span class="keyword">else</span> &#123;</div><div class="line">                  <span class="comment">//如果没有父类，则委托给启动加载器去加载</span></div><div class="line">                      c = findBootstrapClassOrNull(name);</div><div class="line">                  &#125;</div><div class="line">              &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                  <span class="comment">// ClassNotFoundException thrown if class not found</span></div><div class="line">                  <span class="comment">// from the non-null parent class loader</span></div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">                  <span class="comment">// If still not found, then invoke findClass in order</span></div><div class="line">                  <span class="comment">// 如果都没有找到，则通过自定义实现的findClass去查找并加载</span></div><div class="line">                  c = findClass(name);</div><div class="line"></div><div class="line">                  <span class="comment">// this is the defining class loader; record the stats</span></div><div class="line">                  sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</div><div class="line">                  sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</div><div class="line">                  sun.misc.PerfCounter.getFindClasses().increment();</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (resolve) &#123;<span class="comment">//是否需要在加载时进行解析</span></div><div class="line">              resolveClass(c);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> c;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>从该函数我们可以得知双亲委派模型会先递归去查找父加载器是否已经加载过该类了。如果父加载器都没有加载过该类，则开始调用fandClass<br>()尝试去加载该类。由于启动类加载器不可知，我们可以去看看扩展类加载器的findClass()。我们可以看到下面的类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/image/jpg/ExtClassLoader.jpg" alt="ExtClassLoader"></p>
<p>我接着我想去看看ExtClassLoader类里面的findClass()方法，结果发现没有，只要去他的父类URLClassLoader去找找，还好找到了，可以看看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)</div><div class="line">    <span class="keyword">throws</span> ClassNotFoundException</div><div class="line">&#123;</div><div class="line">    <span class="keyword">final</span> Class&lt;?&gt; result;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        result = AccessController.doPrivileged(</div><div class="line">            <span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</div><div class="line">                <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">                    String path = name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>);</div><div class="line">                    Resource res = ucp.getResource(path, <span class="keyword">false</span>);</div><div class="line">                    <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                             <span class="comment">//defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象</span></div><div class="line">                            <span class="keyword">return</span> defineClass(name, res);</div><div class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;, acc);</div><div class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</div><div class="line">        <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实AppClassLoader的findClass()也是继承自URLCLassLoader，所以都是一样的，我们再结合最开始的loadClass()就可以很好的理解了上面双亲委派模型的工作流程了。</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>java随着它的类加载一起具备了一种带有优先级的层次关系，它能保证一个类在程序中各种类加载器环境中都是同一个类。</p>
<h3 id="双亲委派模型的“双亲”"><a href="#双亲委派模型的“双亲”" class="headerlink" title="双亲委派模型的“双亲”"></a>双亲委派模型的“双亲”</h3><p>在Java虚拟机英文文章里双亲委派模型的英文是Parent-Delegation Model，不知道为什么中文翻译会称他为双亲委派模型，可能是他一般都会找到一个爸爸去委托去处理吧。</p>
<h1 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h1><p>目前为止，双亲委派模型主要出现过3次较大的“被破坏”的情况。</p>
<ol>
<li>在JDK1.2之前，新建加载器都是通过重写loadClass()方法来区分不同的加载器,以及修改加载逻辑，这样就破坏了双亲委派模型的向上寻找父加载器去加载的规范，在JDK1.2之后为了向前兼容，ClassLoader添加了新的protect方法findCLass()方法，从而实现了在双亲委派模型上实现加载逻辑的修改。</li>
<li>线程上下文类加载器，如JNDI服务(没用过)</li>
<li>实现动态性，如OSGi(没用过)</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有时候分析东西查看源码是必要的，还要利用一些工具去分析他们的继承关系。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入理解Java虚拟机》</li>
<li><a href="http://blog.csdn.net/javazejian/article/details/73413292" target="_blank" rel="external">深入理解Java类加载器(ClassLoader)</a></li>
<li><a href="http://blog.csdn.net/justloveyou_/article/details/72217806" target="_blank" rel="external">深入理解Java类加载器(一)：Java类加载原理解析</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：之前一直在说类加载，类加载就需要类加载器，类加载最初是为了满足Java Applet，现在基本已经死掉了，但是类加载却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为Java体系中一块重要的基石，可谓失之桑榆，收之东隅。
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_8_虚拟机类加载机制</title>
    <link href="http://bestlixiang.site/2017/12/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-8-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://bestlixiang.site/2017/12/02/深入理解JVM-8-虚拟机类加载机制/</id>
    <published>2017-12-02T07:22:11.000Z</published>
    <updated>2017-12-09T12:04:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在Class文件中描述的各种信息最终都需要加载到虚拟机之中之后才能运行和使用。而虚拟机如何加载这些Class文件？Class文件中的信息进入到虚拟机后会发生什么变化？<a id="more"></a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>虚拟机的类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p>
<p>C/C++和Java链接的不同：</p>
<ol>
<li>C/C++：在编译时完成链接工作；降低了运行时的性能开销，但是也降低了运行时的灵活性。</li>
<li>Java：类型的加载、链接和初始化过程都是在程序运行期间完成的；增加了运行时的性能开销，但是增强了运行时的灵活性，使Java变成了可以动态扩展的语言。这里的动态扩展可以分为两点：<ul>
<li>动态加载：用户可以通过Java预定义的或者自定义的类加载，让一个本地的应用程序可以在运行时在从网络或其他地方加载一个二进制流作为程序代码的一部分。</li>
<li>动态链接：如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类。</li>
</ul>
</li>
</ol>
<h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/image/classloading1.jpg" alt="classloading1"></p>
<p>其中链接包括下面三个部分：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/image/classloading2.jpg" alt="classloading2"></p>
<p>生命周期中加载、验证、准备、初始化和卸载这5个阶段顺序是确定的，但是又是可以互相交叉混合式进行的。</p>
<h2 id="类的初始化时机"><a href="#类的初始化时机" class="headerlink" title="类的初始化时机"></a>类的初始化时机</h2><p>什么情况下需要开始类加载过程的第一阶段：加载？Java虚拟机规范没有进行强制约束，但是对初始化阶段，虚拟机规范则是严格规定了<strong>有且只有</strong>5种情况必须立即对类“初始化”。</p>
<ol>
<li>遇到new、getstatic、putstatic或者invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要触发其初始化，生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段（被final修饰并且已在编译器把结果放在常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包的时候对类进行反射调用的时候，如果类没有进行过初始化，则需要触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要制定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个类。</li>
<li>如果一个java.lang.invoke.MethodHandle实例解析结果是REF_getStaic,REF_putStatic,REF_invokeStatic的方法句柄，并且这个句柄所对应的类没有进行过初始化，则需要先触发其初始化。（还没用过）</li>
</ol>
<p>上面5种场景中的行为成为对一个类的<strong>主动引用</strong>，除此之外，所有应用类的方式都不会触发初始化，成为<strong>被动引用</strong>。下面是几个被动引用的场景：</p>
<ol>
<li>通过子类引用父类的静态字段，不会导致子类初始化。</li>
<li>通过数组来定义引用类，不会触发此类的初始化。</li>
<li>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，不会触发该类的初始化，因为在编译阶段通过常量传播优化，已经将其他类的常量存入到调用类的常量池了。</li>
</ol>
<p>说一点接口与类初始化世时机的不同：在有且只有的5条中的第3条,当一个类在初始化时，要求其父类全部都已经初始化过了，但是接口在初始化时，不要求其父接口全部都完成了初始化，只有真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p>
<h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><p>Java虚拟机中类加载的全过程为：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/image/classloading3.jpg" alt="classloading3"></p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><h3 id="虚拟机在加载阶段要干什么"><a href="#虚拟机在加载阶段要干什么" class="headerlink" title="虚拟机在加载阶段要干什么"></a>虚拟机在加载阶段要干什么</h3><ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个类的字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<h3 id="二进制字节流的来源"><a href="#二进制字节流的来源" class="headerlink" title="二进制字节流的来源"></a>二进制字节流的来源</h3><ol>
<li>从ZIP包中读取，最终成为了日后JAR、EAR、WAR格式的基础。</li>
<li>从网络中获取，这个场景最典型的应用就是Applet（没用过）。</li>
<li>运行时计算生成，这个场景使用的最多的就是动态代理技术，生成代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。</li>
</ol>
<h3 id="加载阶段的注意点"><a href="#加载阶段的注意点" class="headerlink" title="加载阶段的注意点"></a>加载阶段的注意点</h3><ol>
<li>非数组类的加载阶段是开发人员可控性最强的，加载阶段既可以使用系统提供的引导类加载器，也可以使用用户自定义的类加载器。</li>
<li>数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的，但是最终还是要靠类加载器是创建数组类里面的元素类型，每个数组都会在加载数组元素的类加载器的类名称空间上被标识。</li>
<li>Java虚拟机规范没有规定类在方法区的具体数据结构，也没有规定生成的Class对象存储在哪里，对于HotSpot虚拟机而言，它被存放在方法区里面，jdk1.8以后应该在直接内存中吧。</li>
<li>加载阶段与连接阶段的部分内容（一部分字节码文件格式验证工作）是交叉进行的。</li>
</ol>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="验证目的"><a href="#验证目的" class="headerlink" title="验证目的"></a>验证目的</h3><p>由于Class文件并不一定要求用Java源码编译而来，可以使用任何途径产生，所以安全性得不到保证，而验证的目的就是为了确保Class文件的字节流包含的信息符合虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h3><ol>
<li><p>文件格式验证</p>
<p> 主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上负荷一个Java类型信息的要求，这个阶段的验证是基于二进制字节流进行的，只有通过这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字符流。</p>
</li>
<li><p>元数据验证</p>
<p> 主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</p>
</li>
<li><p>字节码验证</p>
<p> 主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</p>
</li>
<li><p>符号引用验证</p>
<p> 发生在解析阶段（将符号引用转化为直接引用），主要目的是确保解析动作能正常执行。</p>
</li>
</ol>
<h3 id="调优的地方"><a href="#调优的地方" class="headerlink" title="调优的地方"></a>调优的地方</h3><p>如果所运行的代码都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为<strong>类变量</strong>分配内存并设置<strong>类变量</strong>初始值的阶段，但是这里的初始值需要注意一下：</p>
<ol>
<li>通常情况：初始值是数据类型的零值</li>
<li>类变量有fianl关键字修饰：初始值是ConstantValue属性所指定的值</li>
</ol>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。这里解释一下直接引用和符号引用：</p>
<ol>
<li>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量。它的字面量形式明确定义在Java虚拟机规范的Class文件格式中。符号引用于虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</li>
<li>直接引用：它可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局相关，有了直接引用，那么引用的目标必定已经在内存中存在。</li>
</ol>
<p>虚拟机规范中并未规定解析阶段发生的具体时间。所以虚拟机可以根据需要来判断到底是在类被加载器加载时就对常量池的符号引用进行解析，还是等到一个符号引用被使用前再去解析它。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>类初始化时类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化变量和其他资源，从另一个角度来表达：初始化阶段是执行类构造器clinit()方法的过程。下面是clinit()方法的注意点：</p>
<ol>
<li><p>clinit()方法是由编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和静态语句块中语句合并产生的，收集的顺序是有语句在源文件出现的顺序决定的，这里有很特别的一点：<strong>静态语句块中只能访问到定义在静态语句块之前的变量，定义在之后的变量，在前面的静态语句块可以赋值，但是不能访问</strong>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        i =<span class="number">0</span>; <span class="comment">//正常编译</span></div><div class="line">        System.out.println(i);  <span class="comment">//提示“非法向前引用”</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i =<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>clinit()方法不需要显式地调用父类构造器，虚拟机会保证在子类的clinit()方法执行前，父类的clinit()方法已经执行完毕。</p>
</li>
<li>由于父类的clinit()方法先执行，所以父类定义的静态语句块要优先于子类的变量赋值操作。</li>
<li>虚拟机会保证一个类的clinit()方法在多线程中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其他线程都要阻塞等待，直到活动线程执行clinit()方法完毕。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>类加载的5个阶段都很重要，对理解对象的创建过程有了更好的理解。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入理解Java虚拟机》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在Class文件中描述的各种信息最终都需要加载到虚拟机之中之后才能运行和使用。而虚拟机如何加载这些Class文件？Class文件中的信息进入到虚拟机后会发生什么变化？
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_7_探秘类文件</title>
    <link href="http://bestlixiang.site/2017/12/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-7-%E6%8E%A2%E7%A7%98%E7%B1%BB%E6%96%87%E4%BB%B6/"/>
    <id>http://bestlixiang.site/2017/12/01/深入理解JVM-7-探秘类文件/</id>
    <published>2017-12-01T12:52:36.000Z</published>
    <updated>2017-12-09T12:04:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：java代码编译的结果从本地机器码转变为字节码，并且生成了类文件，那么这个类文件里面是什么东西呢？<a id="more"></a></p>
<h1 id="JVM的无关性"><a href="#JVM的无关性" class="headerlink" title="JVM的无关性"></a>JVM的无关性</h1><p>一般提到Java的好处，其中必定有一条是平台无关性，但是这个太狭隘了，其实它有两点无关性。</p>
<h2 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h2><p>Java在刚刚诞生之时就有一个著名的宣传口号：“一次编写，到处运行（Write Once, Run Anywhere）”。“与平台无关”的理想最终实现在操作系统的应用层上：其实就是Java虚拟机了，他可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写，到处运行”。</p>
<h2 id="语言无关性"><a href="#语言无关性" class="headerlink" title="语言无关性"></a>语言无关性</h2><p>目前已经一大批能够在JVM运行语言了，就我自己知道并且使用过就有Groovy、Jython、Scala等。实现语言无关性的基础仍然是虚拟机和字节码存储格式。其他语言通过自己的编译把程序代码编程成符合Java虚拟机规范的Class文件即可。</p>
<h1 id="类文件的结构"><a href="#类文件的结构" class="headerlink" title="类文件的结构"></a>类文件的结构</h1><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑排列在Class文件之中，中间没有任何分隔符。Class文件只有两种数据类型：无符号数和表</p>
<ul>
<li>无符号数：以u1，u2，u4，u8来分别代表1个字节，2个字节，4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数值量或者按照UTF-8编码构成字符串值。</li>
<li>表：它是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表习惯地以“_info”结尾。</li>
</ul>
<p>整个Class文件本质上就是一张表，它由下表所示的数据项构成。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u4</td>
<td>魔数</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>次版本号</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>主版本号</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>常量数量</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>常量池</td>
<td>常量数量-1</td>
</tr>
<tr>
<td>u2</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>类索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>父类索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>接口数量</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>接口索引集合</td>
<td>接口数量</td>
</tr>
<tr>
<td>u2</td>
<td>字段数量</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>字段表</td>
<td>字段数量</td>
</tr>
<tr>
<td>u2</td>
<td>方法数量</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>方法表</td>
<td>方法数量</td>
</tr>
<tr>
<td>u2</td>
<td>属性数量</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>属性表</td>
<td>属性数量</td>
</tr>
</tbody>
</table>
<p>接下里稍微详细看看上面的数据：</p>
<p>不过按例子来吧，下面是一个简单的Java类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.todorex.demo;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> m+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先编译这个类得到TestClass.class文件，打开它可以下面的16进制数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">cafe babe 0000 0034 0013 0a00 0400 0f09</div><div class="line">0003 0010 0700 1107 0012 0100 016d 0100</div><div class="line">0149 0100 063c 696e 6974 3e01 0003 2829</div><div class="line">5601 0004 436f 6465 0100 0f4c 696e 654e</div><div class="line">756d 6265 7254 6162 6c65 0100 0369 6e63</div><div class="line">0100 0328 2949 0100 0a53 6f75 7263 6546</div><div class="line">696c 6501 000e 5465 7374 436c 6173 732e</div><div class="line">6a61 7661 0c00 0700 080c 0005 0006 0100</div><div class="line">1a63 6f6d 2f74 6f64 6f72 6578 2f64 656d</div><div class="line">6f2f 5465 7374 436c 6173 7301 0010 6a61</div><div class="line">7661 2f6c 616e 672f 4f62 6a65 6374 0021</div><div class="line">0003 0004 0000 0001 0002 0005 0006 0000</div><div class="line">0002 0001 0007 0008 0001 0009 0000 001d</div><div class="line">0001 0001 0000 0005 2ab7 0001 b100 0000</div><div class="line">0100 0a00 0000 0600 0100 0000 0600 0100</div><div class="line">0b00 0c00 0100 0900 0000 1f00 0200 0100</div><div class="line">0000 072a b400 0204 60ac 0000 0001 000a</div><div class="line">0000 0006 0001 0000 0009 0001 000d 0000</div><div class="line">0002 000e</div></pre></td></tr></table></figure></p>
<p>然后用javap 解析TestClass.class文件，得到：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">Classfile /Users/rex/IdeaProjects/JVMTest/src/com/todorex/demo/TestClass.class</div><div class="line">  Last modified 2017-12-1; size 292 bytes</div><div class="line">  MD5 checksum 337a51d3bebe0e9a82142a352eb0977e</div><div class="line">  Compiled from "TestClass.java"</div><div class="line">public class com.todorex.demo.TestClass</div><div class="line">  minor version: 0</div><div class="line">  major version: 52</div><div class="line">  flags: ACC_PUBLIC, ACC_SUPER</div><div class="line">Constant pool:</div><div class="line">   #1 = Methodref          #4.#15         // java/lang/Object."&lt;init&gt;":()V</div><div class="line">   #2 = Fieldref           #3.#16         // com/todorex/demo/TestClass.m:I</div><div class="line">   #3 = Class              #17            // com/todorex/demo/TestClass</div><div class="line">   #4 = Class              #18            // java/lang/Object</div><div class="line">   #5 = Utf8               m</div><div class="line">   #6 = Utf8               I</div><div class="line">   #7 = Utf8               &lt;init&gt;</div><div class="line">   #8 = Utf8               ()V</div><div class="line">   #9 = Utf8               Code</div><div class="line">  #10 = Utf8               LineNumberTable</div><div class="line">  #11 = Utf8               inc</div><div class="line">  #12 = Utf8               ()I</div><div class="line">  #13 = Utf8               SourceFile</div><div class="line">  #14 = Utf8               TestClass.java</div><div class="line">  #15 = NameAndType        #7:#8          // "&lt;init&gt;":()V</div><div class="line">  #16 = NameAndType        #5:#6          // m:I</div><div class="line">  #17 = Utf8               com/todorex/demo/TestClass</div><div class="line">  #18 = Utf8               java/lang/Object</div><div class="line">&#123;</div><div class="line">  public com.todorex.demo.TestClass();</div><div class="line">    descriptor: ()V</div><div class="line">    flags: ACC_PUBLIC</div><div class="line">    Code:</div><div class="line">      stack=1, locals=1, args_size=1</div><div class="line">         0: aload_0</div><div class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</div><div class="line">         4: return</div><div class="line">      LineNumberTable:</div><div class="line">        line 6: 0</div><div class="line"></div><div class="line">  public int inc();</div><div class="line">    descriptor: ()I</div><div class="line">    flags: ACC_PUBLIC</div><div class="line">    Code:</div><div class="line">      stack=2, locals=1, args_size=1</div><div class="line">         0: aload_0</div><div class="line">         1: getfield      #2                  // Field m:I</div><div class="line">         4: iconst_1</div><div class="line">         5: iadd</div><div class="line">         6: ireturn</div><div class="line">      LineNumberTable:</div><div class="line">        line 9: 0</div><div class="line">&#125;</div><div class="line">SourceFile: "TestClass.java"</div></pre></td></tr></table></figure></p>
<h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><ol>
<li>每个Class文件的头4个字节成为魔数</li>
<li>使用魔数来进行身份识别（文件类别），因为如果使用文件名来识别，安全性太低，由于文件名可以随意改动。</li>
<li>Class文件的魔数的获得就有“浪漫气息”，值为0xcafebabe,上面16进制文件也可以看到。这让自己想起了高中用的三星手机打开qq就是一杯咖啡的标志。</li>
</ol>
<h2 id="Class文件的版本"><a href="#Class文件的版本" class="headerlink" title="Class文件的版本"></a>Class文件的版本</h2><p>接下来第5，6个字节显示的是次版本号，7，8字节显示的是主版本号。</p>
<p>高版本的JDK可以向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>在版本号之后的是常量池入口。</p>
<ol>
<li>常量池是Class文件结构中与其他项目关联最大的数据类型，也是占Class文件空间最大的数据项目之一。</li>
<li>常量池常量的数据不是固定的，在最前面的Class文件组成可以看到有一个常量数量项，这个容量计数是从1而不是0开始的，比如上面的十六进制的值为0x0013(19)就代表有18个常量。</li>
<li><p>常量池主要存放两大类变量</p>
<ul>
<li>字面量：文本字符串、声明为final的常量值等</li>
<li>符号引用：（编译原理的概念）<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
</ul>
</li>
<li><p>常量池的每一项常量都是表，常量的顺序可以参照javap解析出来的常量顺序，在JDK1.7以后共有14种不同类型的表，他们共同点是表的第一位是一个u1类型的标志位（tag），具体的标志对应的类型参照书《深入理解Java虚拟机》。这里提一下CONSTANT_UTF8_info这个表：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>bytes</td>
<td>length</td>
</tr>
</tbody>
</table>
<pre><code>length值说明了UTF-8编码的字符串长度是多少字节，他后面跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。而u2最大值是65535，所以说如果Java程序如果定义了超过64KB（大约）英文字符的变量或者方法名，将无法编译。
</code></pre><ol>
<li>UTF-8缩略编码和UTF-8编码的区别：UTF-8编码都是使用3个字节编码，而UTF-8缩略编码可以使用1或2或3个字节编码。</li>
</ol>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等，访问标志一共有16个标志位可以使用，当前只定义了8个。</p>
<h2 id="类索引、父类索引、接口索引集合"><a href="#类索引、父类索引、接口索引集合" class="headerlink" title="类索引、父类索引、接口索引集合"></a>类索引、父类索引、接口索引集合</h2><ol>
<li>类索引、父类索引都是u2类型的数据，类索引、父类索引都是指向一个CONSTANT_Class_info的类描述符常量</li>
<li>接口索引集合是一组u2类型的数据的集合，它入口的第一项是u2的接口计数器，后面就是具体接口索引</li>
<li>Class文件有这三项数据来确定这个类的继承关系</li>
</ol>
<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>接下来是字段表，字段表用于描述接口或者类中声明的变量，包括类级变量以及实例级变量，不包括方法内部声明的局部变量。我们看一下一个字段表的构成：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>简单名称索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>属性数量</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>属性表</td>
<td>属性数量</td>
</tr>
</tbody>
</table>
<p>根据上表我们解析一下其中的含义：</p>
<ol>
<li>访问标志：它和之前的访问标志很类似。</li>
<li>简单名称索引：它指向一个CONSTANT_UTF8_info类型的常量，这里面存储了本字段的名字信息，像javap解析后的第5个常量m。</li>
<li>描述符索引：用来描述字段的数据类型，像javap解析后的第6个常量I,代表了基本类型int</li>
<li>属性表（可能有ConstantValue表</li>
</ol>
<p>下面是字符表的注意点：</p>
<ol>
<li>字段表集合不会列出从超类或者父接口继承而来的字段。</li>
<li>字段表有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加执行外部类实例的字段。（不懂，大佬请指教）</li>
<li>Java语言中字段是无法重载的，名称必须不一样，但是对于字节码来说，如果两个字段的描述符不一致，那么字段重名是合法的。</li>
</ol>
<h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>接下来是方法表，方法表的内容和字段表几乎完全一致。其中坑顶也看一下方法表的构成：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>简单名称索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>属性数量</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>属性表</td>
<td>属性数量</td>
</tr>
</tbody>
</table>
<p>这里解释一下和字段表不一样的地方</p>
<ol>
<li>简单名称索引：它指向一个CONSTANT_UTF8_info类型的常量，这里面存储了本字段的名字信息，像javap解析后的第11个常量inc。</li>
<li>描述符索引：它的作用是用来描方法的参数列表（包括数量、类型以及顺序）和返回值，像javap解析后的第12个常量()I,表示的就是一个返回值为int的方法。</li>
<li>属性表：这里肯定存放了Code属性表（方法里的Java代码）</li>
</ol>
<p>下面是方法表的注意点：</p>
<ol>
<li>如果父类方法在子类没有被重写，方法表集合中就不会出现来自父类的方法信息。</li>
<li>可能会出现由编译器自动添加的方法，最典型的有类构造器“<clinit>”方法和实例构造器“<init>”方法，就像javap解析后的第11个常量<init>。</init></init></clinit></li>
<li>在Java语言中，要重载一个方法，需要相同的简单名称和与原方法不同的Java代码的方法特征签名，这里需要解释一下Java特征签名和JVM特征签名：<ul>
<li>Java特征签名：方法名称、参数顺序</li>
<li>JVM特征签名：Java特征签名、方法返回值以及受查异常表</li>
</ul>
</li>
</ol>
<h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>最后就是属性表集合了，在Class文件、字段表、方法表都可以携带自己的属性表集合，以及用于描述某些场景专有的信息。属性表集合不要求各个属性具有严格的顺序，并且只要不与已有属性名重复就好。</p>
<p>上面程序的例子出现过几个属性表：Code、LineNumberTable、SourceFile、ConstantValue，接下来我们详细说一下：</p>
<h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h3><p>Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内，Code属性出现在方法表属性集合之中，我们先看看Code属性表的结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>属性名索引</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>属性长度</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>操作数栈深度的最大值</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>局部变量表所需的存储空间</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>Java方法代码字节码指令长度</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>Java方法代码字节码</td>
<td>Java方法代码字节码指令长度</td>
</tr>
<tr>
<td>u2</td>
<td>显式异常表长度</td>
<td>1</td>
</tr>
<tr>
<td>exception_info</td>
<td>显式异常表</td>
<td>显式异常表长度</td>
</tr>
<tr>
<td>u2</td>
<td>属性个数</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>属性表</td>
<td>属性个数</td>
</tr>
</tbody>
</table>
<p>接下来我们说明一下几个关键项：</p>
<ol>
<li>属性名索引：它是一项指向CONSTANT_UTF8_info型的索引，常量值固定为“Code”，就像上面javap解析出来的常量池的第9个。</li>
<li>属性长度：固定为整个属性表长度减去6个字节。</li>
<li>操作数栈深度的最大值：在方法执行的任意时刻，操作数栈都不会超过这个深度，虚拟机运行的时候需要根据这个值来分配栈栈中的操作数栈深度。</li>
<li>局部变量表所需的存储空间：它的单位是Slot，局部变量表存储了方法参数（包括<strong>实例方法</strong>中的隐藏参数this）、显示异常处理器的参数（try-catch检查的异常）、方法体中定义的局部变量，Javac编译器会根据变量的作用域来分配Slot，然后计算出需要的存储空间大小。</li>
<li><p>Java方法代码字节码指令长度和Java方法代码字节码：存储了Java源程序编译后生成的字节码指令，目前Java虚拟机规范已经定义了约200条编码值对应的指令含义。</p>
<p> PS：如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义以及其他信息）两部分，那么在整个Class文件，Code属性用来描述代码，所有其他数据项目都用于描述元数据。</p>
</li>
<li>显式异常表：用于显示try-catch代码块要检查的异常</li>
</ol>
<h3 id="LineNumberTable"><a href="#LineNumberTable" class="headerlink" title="LineNumberTable"></a>LineNumberTable</h3><p>它的使用位置是在Code属性，用于描述Java源码行号与字节码行号之间的对应关系，当抛出异常的时候堆栈会显示出错的行号。</p>
<h3 id="SourceFile"><a href="#SourceFile" class="headerlink" title="SourceFile"></a>SourceFile</h3><p>它的使用位置是类文件，用于记录生成这个Class文件的源码文件名称，当抛出异常的时候会显示出错代码所属的文件名。</p>
<h3 id="ConstantValue"><a href="#ConstantValue" class="headerlink" title="ConstantValue"></a>ConstantValue</h3><p>它的使用位置是字段表，作用是通知虚拟机自动为静态变量赋值，只有static关键字修饰的变量（类变量）才可以使用这项属性，虚拟机对于类变量和实例变量赋值的方式有所不用。</p>
<ol>
<li>实例变量：在实例构造器<init>方法中进行</init></li>
<li>类变量：在类构造器<clinit>方法中或者使用ConstantValue属性</clinit></li>
</ol>
<p>目前Sun Javac编译器的选择是：如果同时使用final和static来修饰一个变量，并且这个常量的数据类型是基本类型或者String类型，就生成ConstantValue属性来进行初始化，如果这个变量没有被final修饰，或者并非基本类型或者字符串，则将会选择在<clinit>方法中进行初始化。</clinit></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面的分析，我们一定能清楚的知道Class文件是什么以及Class文件包含什么东西，再也不怕了！！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入理解Java虚拟机》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：java代码编译的结果从本地机器码转变为字节码，并且生成了类文件，那么这个类文件里面是什么东西呢？
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_6_JVM调优实战</title>
    <link href="http://bestlixiang.site/2017/11/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-6-JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/"/>
    <id>http://bestlixiang.site/2017/11/30/深入理解JVM-6-JVM调优实战/</id>
    <published>2017-11-30T13:46:19.000Z</published>
    <updated>2017-12-09T12:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：带着浅尝基本的Java诊断工具就这样把《深入理解Java虚拟机》的调优部分看完了，似懂非懂，我想待自己经历过一次性能调优，结合自身经历再来好好总结一番吧。<a id="more"></a></p>
<h1 id="此处暂时省略一万字。。。"><a href="#此处暂时省略一万字。。。" class="headerlink" title="此处暂时省略一万字。。。"></a>此处暂时省略一万字。。。</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：带着浅尝基本的Java诊断工具就这样把《深入理解Java虚拟机》的调优部分看完了，似懂非懂，我想待自己经历过一次性能调优，结合自身经历再来好好总结一番吧。
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_5_内存分配策略</title>
    <link href="http://bestlixiang.site/2017/11/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-5-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://bestlixiang.site/2017/11/30/深入理解JVM-5-内存分配策略/</id>
    <published>2017-11-30T06:31:15.000Z</published>
    <updated>2017-12-09T12:04:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：一直在说Java的垃圾回收，既然有回收，那么当然会有分配。<a id="more"></a></p>
<p>Java技术体系中所提倡的自动内存管理可以归结为自动化地解决了两个问题：</p>
<ol>
<li>给对象分配内存</li>
<li>回收分配给对象的内存</li>
</ol>
<p>之前垃圾回收已经讲了很多，接下来我们详细地来看看内存分配</p>
<h1 id="内存分配总说"><a href="#内存分配总说" class="headerlink" title="内存分配总说"></a>内存分配总说</h1><p>对象的内存分配，主要是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程的分配缓冲，将按线程优先在TLAB上分配，少数情况下（大对象）也可能直接分配在老年代中，分配的规则不是百分百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p>
<h1 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h1><ol>
<li>大多数情况，对象在新生代Eden区分配。当Eden区没有足够空间进行分配时，虚拟机会发起一次MinorGC。</li>
<li>当MinorGC发现复制的对象大于Survivor区时，会通过分配担保机制提前转移到老年代中。</li>
</ol>
<h1 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h1><p>所谓大对象是指需要大量连续内存空间的Java对象，如数组。</p>
<p>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配，避免了在Eden区及Survivor区之间发生大量的内存复制。（新生代采用复制算法收集内存）</p>
<h1 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h1><p>虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设置为1.对象在Survivor中每度过一次MinorGC，年龄就增加一岁，当他的年龄达到一定程度（默认15岁），就将被晋升到老年代中。对象的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。</p>
<h1 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h1><p>虚拟机不是永远要求对象的年龄必须达到MaxTenuringThreshold才晋升到老年代，如果Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入老年代。</p>
<h1 id="空间分配担保策略"><a href="#空间分配担保策略" class="headerlink" title="空间分配担保策略"></a>空间分配担保策略</h1><p>虽然有空间分配担保，但是也需要考虑老年代能否装下由于担保转存的内存大小，所以这个空间分配担保也需要一定的策略。</p>
<ol>
<li>在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间</li>
<li>如果上面条件成立，那么MinorGC就是安全的，可以进行</li>
<li>如果上面条件不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。</li>
<li>如果允许担保失败，就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小</li>
<li>如果大于，将尝试进行一次MinorGC</li>
<li>如果小于，或者HandlePromotionFailure设置为不允许冒险，那这时需要进行一次FullGC</li>
</ol>
<p>在jdk 6 update 24之后的规则是只要老年代的连续空间大于新生代对象的总大小或者历次晋升平均大小就会进行MinorGC，否则进行FullGC。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面我们可以知道JAVA虚拟机是怎么自动进行内存分配的，然后在进行GC之后，内存是怎么转换的。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入理解JAVA虚拟机》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：一直在说Java的垃圾回收，既然有回收，那么当然会有分配。
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_4_垃圾收集策略</title>
    <link href="http://bestlixiang.site/2017/11/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-4-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AD%96%E7%95%A5/"/>
    <id>http://bestlixiang.site/2017/11/29/深入理解JVM-4-垃圾收集策略/</id>
    <published>2017-11-29T11:33:14.000Z</published>
    <updated>2017-12-09T12:04:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：Java与C++之间有一堵内存动态分配与垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。那我们就先来看看JVM到底是怎么进行垃圾收集的？<a id="more"></a></p>
<h1 id="垃圾回收，回收哪里？"><a href="#垃圾回收，回收哪里？" class="headerlink" title="垃圾回收，回收哪里？"></a>垃圾回收，回收哪里？</h1><p>之前介绍过Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，这几个区域的内存分配和回收都具有确定性，方法结束或者线程结束，内存自然就跟着回收了，但是Java堆和方法区（元空间）则不一样，我们只有在运行期间才知道会创建哪些对象，这部分内存的分配和回收都是动态的，所有垃圾回收就是回收这里。</p>
<h1 id="对象已死么？"><a href="#对象已死么？" class="headerlink" title="对象已死么？"></a>对象已死么？</h1><p>垃圾收集器在对堆进行回收前，第一件事就是要确定这些对象之中还有那些还“存活”者，哪些已经“死去”（即不可能再被任何途径使用的对象）。</p>
<ol>
<li><p>引用计数算法</p>
<p> 给每个对象添加一个引用计数器，每当有一个地方引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器为0的对象就是不可能再被使用的。</p>
</li>
<li><p>可达性分析算法（Java使用）</p>
<p> 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径被称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p>
<p> 在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性应用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
</li>
</ol>
<h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><ol>
<li>强引用：类似”Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用：用来描述还有用但非必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。它是通过SoftReference类来实现软引用的。</li>
<li>弱引用：用来描述非必需对象的，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象，它是通过WeakReference类来实现弱引用的。</li>
<li>虚引用：只要发生垃圾回收，它就会被收集，它唯一的目的就是能在这个对象被收集器回收时收到一个系统通知，它是用过PhantomReference类来实现虚引用。</li>
</ol>
<h1 id="方法区（元空间）的回收"><a href="#方法区（元空间）的回收" class="headerlink" title="方法区（元空间）的回收"></a>方法区（元空间）的回收</h1><p>类和其元数据的生命周期和其对应的类加载器是相同的。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。准确的来说，每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。</p>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>流程：</p>
<ol>
<li>标记出所有需要回收的对象</li>
<li>在标记完成后统一回收所有被标记的对象</li>
</ol>
<p>不足：</p>
<ol>
<li><p>效率问题</p>
<p> 标记和清除两个过程效率都不高</p>
</li>
<li><p>空间问题</p>
<p> 标记清除以后会产生大量不连续的空间碎片，无法存储大对象</p>
</li>
</ol>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>流程：</p>
<ol>
<li>将可用内存按容量分为大小相同的两块</li>
<li>在第一块分配内存，并标记出所有需要回收的对象</li>
<li>当第一块内存用完了，将所有活着的对象复制到另外一块上</li>
<li>将第一块所使用过的内存空间一次性清除</li>
</ol>
<p>好处：解决了空间碎片问题</p>
<p>不足：降低了空间利用率</p>
<p>现在的商业虚拟机都用这种收集算法来回收新生代，因为新生代中的对象98%是“朝生夕死”的，所以不需要1:1划分空间,而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还活着的对象那个一次性复制到另一块Survivor空间上，最后清理掉前两块空间。HotSpot虚拟机默认Eden和Survivor的大小比例为8:1，所以只有10%的内存会被“浪费”，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。</p>
<p>内存的分配担保是指如果放着存活对象的Survivor空间没有足够空间放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>适合老年代</p>
<p>流程：</p>
<ol>
<li>标记出所有需要回收的对象</li>
<li>让所有存活的对象都向一端移动</li>
<li>直接清理掉端边界以外的内存</li>
</ol>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>将内存划分为老年代和新生代。老年代中存放寿命较长的对象，新生代中存放“朝生夕死”的对象。然后在不同的区域使用不同的垃圾收集算法。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从上面我们了解了对象存活判定算法和垃圾回收算法，但是不同虚拟机的具体实现还是不同的，而且不同的垃圾收集器的内存回收的具体实现也是不同的，我们要因机而议。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入理解Java虚拟机》</li>
<li><a href="http://blog.csdn.net/qq_16681169/article/details/70471010" target="_blank" rel="external">JDK8 从永久代到元空间</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：Java与C++之间有一堵内存动态分配与垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。那我们就先来看看JVM到底是怎么进行垃圾收集的？
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_3_OutOfMemoryError异常现场</title>
    <link href="http://bestlixiang.site/2017/11/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-3-OutOfMemoryError%E5%BC%82%E5%B8%B8%E7%8E%B0%E5%9C%BA/"/>
    <id>http://bestlixiang.site/2017/11/29/深入理解JVM-3-OutOfMemoryError异常现场/</id>
    <published>2017-11-29T07:24:08.000Z</published>
    <updated>2017-12-09T12:04:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：之前面对JVM运行内存的分析，总会提到出现OutMemoryError异常，接下来我们详细看下常出现这种异常的现场。<a id="more"></a></p>
<h1 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h1><p>我们通过限制Java堆得大小为20MB,不可扩张（将堆得最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX：+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump（备份）出当前的内存堆转储快照以便时候分析处理。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">OOMobject</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;OOMobject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            list.add(<span class="keyword">new</span> OOMobject());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">java.lang.OutOfMemoryError: Java heap space</div><div class="line">Dumping heap to java_pid81611.hprof ...</div><div class="line">Heap dump file created [27573572 bytes in 0.121 secs]</div><div class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</div><div class="line">	at java.util.Arrays.copyOf(Arrays.java:3210)...</div></pre></td></tr></table></figure></p>
<p>我们很容易在输出结果中看到Java heap space OOM出现在堆中。我们要解决这个区域的异常主要是通过内存映像分析工具（很多）对Dump出来的堆转储快照进行分析，重点确认是<strong>内存泄漏（Memory leak）</strong>还是<strong>内存溢出（Memory Overflow</strong>）。</p>
<ol>
<li><p>内存泄漏：被分配的内存的对象不会被回收，永久占据内存。</p>
<p> 解决方法：通过工具查看泄漏对象到GC Roots的引用链。</p>
</li>
<li><p>内存溢出：无法申请到内存。</p>
<p> 解决方法：检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长的情况，尝试减少程序运行期的内存消耗。</p>
</li>
</ol>
<h1 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h1><p>我们说过HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，所以设置本地方法栈大小是无效的，栈容量只由-Xss参数设定，在Java虚拟机规范中描述了两种异常</p>
<ol>
<li>StackOverflowError异常：如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出此异常。</li>
<li>OutOfMemoryError异常：如果虚拟机在扩展栈使无法申请到足够的内存空间，将抛出此异常。</li>
</ol>
<p>我个人想如果单线程中栈的内存大小等于总内存大小，那么上面两种异常应该是等价的吧，但是基本上是不可能的。所以单线程中出现得基本上都是StackOverflowError异常。</p>
<p>单线程代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// VM args: -Xss128k</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">OOMobject</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;OOMobject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            list.add(<span class="keyword">new</span> OOMobject());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">stack lenth:18855</div><div class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</div><div class="line">	at com.todorex.demo.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:10)</div></pre></td></tr></table></figure></p>
<p>这里抄一下书的结论：在单个线程下，无论是由于栈帧太大还是虚拟机容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。</p>
<p>多线程代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// VM args: -Xss2M</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    dontStop();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            thread.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        JavaVMStackOOM javaVMStackOOM = <span class="keyword">new</span> JavaVMStackOOM();</div><div class="line">        javaVMStackOOM.stackLeakByThread();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我在自己的机器上没有运行出来，可能需要点时间，不过机器变卡了，我想其实这里解释一下就好，它应该会抛出OutOfMemoryError异常。</p>
<p>解释：首先操作系统分给每个进程的内存是有限制的，所以总的方法栈的大小也是有限制的，但是每个线程都需要方法栈，所以线程建立的越多，剩余的方法栈内存就越小，一直创建线程，进程所拥有的内存终将被耗尽，到最后就会抛出OutOfMemoryError异常。</p>
<p>注意：线程数和方法栈大小是成反比的，所以在开发多线程的应用时应该特别注意，如果不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程了。</p>
<h1 id="方法区（元空间）和运行时常量池溢出"><a href="#方法区（元空间）和运行时常量池溢出" class="headerlink" title="方法区（元空间）和运行时常量池溢出"></a>方法区（元空间）和运行时常量池溢出</h1><h2 id="运行时常量池溢出"><a href="#运行时常量池溢出" class="headerlink" title="运行时常量池溢出"></a>运行时常量池溢出</h2><p>在之前的博客也提到过在jdk1.6以及之前运行时常量池是放在方法区中的，存的是对象，所以可以设置虚拟机参数-XX:PermSize和-XX:MaxPermSize来限制方法区的大小，来模拟常量池溢出，但是jdk1.7及以后运行时常量池被移除了方法区，常量池存储的不再是对象，而是对象的引用，真正的对象存储在堆中，我们改变虚拟机参数为：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError运行下面程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// VM args:-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            list.add(String.valueOf(i++).intern());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java.lang.OutOfMemoryError: GC overhead limit exceeded</div><div class="line">Dumping heap to java_pid10818.hprof ...</div><div class="line">Heap dump file created [25172419 bytes in 0.251 secs]</div></pre></td></tr></table></figure></p>
<p>上面结果提示GC开销超过限制，默认的话，如果你98%的时间都花在GC上并且回收了才不到2%的空间的话，虚拟机就会抛这个异常。</p>
<p>其实我们之前也提起过在JDK1.8及以后，字符串常量池从永久代移到到元空间中，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整，如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集，-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集，具体验证代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// VM args: -XX:MetaspaceSize=4M -XX:MaxMetaspaceSize=4M</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            list.add(String.valueOf(i++).intern());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Error occurred during initialization of VM</div><div class="line">OutOfMemoryError: Metaspace</div></pre></td></tr></table></figure></p>
<p>关于这个字符串常量池的实现问题，还真的会出现一个很意思的问题或者说是一个很奇怪的问题。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// jdk:1.8</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"软件"</span>).toString();</div><div class="line">        System.out.println(str1.intern() == str1);</div><div class="line"></div><div class="line">        String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</div><div class="line">        System.out.println(str2.intern() == str2);</div><div class="line"></div><div class="line">        String str3 = <span class="keyword">new</span> StringBuilder(<span class="string">"ma"</span>).append(<span class="string">"in"</span>).toString();</div><div class="line">        System.out.println(str3.intern() == str3);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">false</div><div class="line">false</div></pre></td></tr></table></figure></p>
<p>jdk1.6中，intern()方法会把首次遇到的字符串实例复制在永久代，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用。而在jdk1.7及以后，intern()的实现不会再复制实例，只是在常量池中记录首次出现得实例的引用，因此intern()返回的由StringBuilder创建的那个字符串是同一个实例，而关于上面的运行结果，我想java和main之前都是在字符串常量池中都有他的引用了，所以返回的都是false。</p>
<h2 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h2><p>方法区用于存放Class的相关信息，如类名，访问修饰符，常量池，字段描述，方法描述等，基本的思路是运行时产生大量的类去填充方法区，下面是借助CGLib（cglib和asm的依赖有个坑，选择cglib2.2,asm3.1亲测可用）来操作字节码运行时生成大量的动态类，这种场景在Spring，Hibernate中经常出现，需要多注意，本人使用的JDK1.8，所以测试的是方法区的变迁元空间，代码实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// VM args:-XX:MetaspaceSize=4M -XX:MaxMetaspaceSize=4M</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">            enhancer.setSuperclass(OOMObject.class);</div><div class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</div><div class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            OOMObject oomObject = (OOMObject) enhancer.create();</div><div class="line">            oomObject.sayHi();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</div><div class="line">            System.out.println(<span class="string">"hi"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Error occurred during initialization of VM</div><div class="line">OutOfMemoryError: Metaspace</div></pre></td></tr></table></figure></p>
<p>这类异常经常出现在web应用中，需要多注意。</p>
<h1 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h1><p>DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样，在《深入理解Java虚拟机》中用了以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// VM args:-Xmx20M -XX:MaxDirectMemorySize=10M</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span>*<span class="number">1024</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</div><div class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</div><div class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            unsafe.allocateMemory(_1MB);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是在自己电脑中没有运行成功，反而让自己的电脑死机了，这个地方还是没有弄懂？？？？？？，希望懂的大佬给我点支持。</p>
<p>这个异常在使用NIO中可能会出现，所以在使用的时候需要多注意。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在总结得过程中，知道了各个内存区域可能会出现OOM的情况，重要的是了解了方法区在jdk1.6到1.7到1.8的变迁，有兴趣的人可以深入了解。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入理解Java虚拟机》</li>
<li><a href="http://blog.csdn.net/zghwaicsdn/article/details/50957474" target="_blank" rel="external">CGLIB介绍与原理</a></li>
<li><a href="http://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="external">Java8内存模型—永久代(PermGen)和元空间(Metaspace)</a></li>
<li><a href="http://www.sczyh30.com/posts/Java/jvm-metaspace/" target="_blank" rel="external">深入探究JVM | 探秘Metaspace</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：之前面对JVM运行内存的分析，总会提到出现OutMemoryError异常，接下来我们详细看下常出现这种异常的现场。
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM_2_HotSpot对象揭秘</title>
    <link href="http://bestlixiang.site/2017/11/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-2-HotSpot%E5%AF%B9%E8%B1%A1%E6%8F%AD%E7%A7%98/"/>
    <id>http://bestlixiang.site/2017/11/21/深入理解JVM-2-HotSpot对象揭秘/</id>
    <published>2017-11-21T03:11:05.000Z</published>
    <updated>2017-12-09T12:04:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：总有些人会思考对象是如果创建、如何布局、以及如何访问的？对于这些问题，我们必须把讨论范围限定在具体的虚拟机和集中在某一个内存区域才有意义。基于实用原则，我们以常用的虚拟机HotSpot和常用的内存区域Java堆为例。<a id="more"></a></p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>Java程序创建对象不过是一个new关键字而已，而在虚拟机中，创建了一个对象却经历了一系列过程。</p>
<ol>
<li>虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，如果没有就会抛出ClassNotFoundException，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，那必须先执行相应的类加载过程。</li>
<li><p>类加载检查通过后，虚拟机为新生对象分配内存，对象所需内存的大小在类加载完成后便可以完全确定。</p>
<p> 这里有两种内存分配方式：（由采用的垃圾收集器是否带有压缩整理的功能决定）</p>
<ul>
<li><p>指针碰撞</p>
<p>  假设Java堆的内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</p>
</li>
<li><p>空闲列表</p>
<p>  假如Java堆中的内存并不是完整的，已使用的内存和空闲的内存相互交错，虚拟机就必须维护一个列表，记录那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给实例，并更新列表上的记录。</p>
<p>解决在并发情况下不安全的方案:</p>
</li>
<li><p>对分配内存空间的动作进行同步处理——虚拟机采用CAS配上失败重试的方式保证更新操作的原子性</p>
</li>
<li><p>把内存分配的动作按线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲，只有需要重新分配的时候才同步锁定</p>
</li>
</ul>
</li>
<li><p>虚拟机将分配到的内存空间都初始化为零值（默认初始化），保证了对象实例在Java代码中可以不赋初始值就可以使用。</p>
</li>
<li>设置对象头</li>
<li>利用构造函数进行初始化</li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><ol>
<li>存储对象自身的运行时数据（哈希码，GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等），官方称为“Mark Word”，它被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，他会根据对象的状态复用自己的存储空间，具体见《深入理解Java虚拟机》。</li>
<li>类型指针（可选）<br>即对象指向它的元数据（方法区）的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
<li>数组长度（可选）<br>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通java对象元数据信息确定Java对象的大小，但是从数组数据无法确定数据大小</li>
</ol>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>存储所有成员变量，无论是父类继承下来的，还是在子类定义的。</p>
<p>存储顺序会受到虚拟机分配策略参数和字段在源码定义的顺序的影响。<br>HotSpot默认的分配策略为相同狂赌的字段总是被分配到一起（如long和double），在这个前提下，父类先于子类，若CompactFields参数为true，那么子类之中较窄的变量也可能插入到父类变量的空隙中（是因为一个slot太大）</p>
<h3 id="对齐填充（可选）"><a href="#对齐填充（可选）" class="headerlink" title="对齐填充（可选）"></a>对齐填充（可选）</h3><p>起到占位符的作用，确保对象的长度为8字节的整数倍</p>
<p>HotSpot VM的自动内存管理系统要求对象起始位置必须是8字节的整数倍，由于对象头一定是8字节的整数倍，所以利用占位符可以达到数据部分也是8字节的整数倍。从而达到对象的长度是8字节的整数倍。（有点绕口啊，哈哈）</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>我们通常都会使用Java对象，我们基本上都是通过虚拟机栈上的reference数据来操作堆上的具体对象，而栈上只是一个指向对象的引用，对象的具体访问方式取决于虚拟机，目前有以下两种访问方式：</p>
<h3 id="通过句柄访问对象"><a href="#通过句柄访问对象" class="headerlink" title="通过句柄访问对象"></a>通过句柄访问对象</h3><p>可以看下面的图：<br><img src="http://ozp5jl6m4.bkt.clouddn.com/image/jpg/JavaHandlerInvite.jpg" alt="通过句柄访问对象"><br>使用句柄访问，Java堆中会划分出一块内存来作为句柄池，reference存储的就是对象的句柄地址，而句柄包含了对象实例数据与类型数据各自的具体地址信息。</p>
<h3 id="通过直接指针访问对象"><a href="#通过直接指针访问对象" class="headerlink" title="通过直接指针访问对象"></a>通过直接指针访问对象</h3><p>可以看下面的图：<br><img src="http://ozp5jl6m4.bkt.clouddn.com/image/jpg/JavaHandlerInvite.jpg" alt="JavaHandlerInvite"><br>使用直接指针访问，<strong>Java堆对象的布局</strong>中就要考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。</p>
<h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><ol>
<li>通过句柄访问对象可以当对象被移动之后只会改变句柄中的实例数据指针，而reference本身不需要改变。</li>
<li>使用直接指针访问可以加快Java对象的访问，HotSpot就是使用直接指针访问对象的方式。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里讲的对象重点还是在虚拟机执行部分，关于Class文件的讲解没有涉及到，但它却是十分重要的，日后会提及。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/u010425776/article/details/51190801" target="_blank" rel="external">深入理解JVM(二)——揭开HotSpot对象创建的奥秘</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：总有些人会思考对象是如果创建、如何布局、以及如何访问的？对于这些问题，我们必须把讨论范围限定在具体的虚拟机和集中在某一个内存区域才有意义。基于实用原则，我们以常用的虚拟机HotSpot和常用的内存区域Java堆为例。
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
</feed>
