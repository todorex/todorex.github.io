<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rex note</title>
  <subtitle>雨过，云过</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bestlixiang.site/"/>
  <updated>2017-05-24T12:25:02.000Z</updated>
  <id>http://bestlixiang.site/</id>
  
  <author>
    <name>rex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Angular2入门</title>
    <link href="http://bestlixiang.site/2017/05/24/Angular2%E5%85%A5%E9%97%A8/"/>
    <id>http://bestlixiang.site/2017/05/24/Angular2入门/</id>
    <published>2017-05-24T12:22:59.000Z</published>
    <updated>2017-05-24T12:25:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：由于老师暑假的项目前端代码需要用到Angular2，作为一个后端开发者也是需要了解一丢丢的。<a id="more"></a></p>
<h2 id="Angular简介"><a href="#Angular简介" class="headerlink" title="Angular简介"></a>Angular简介</h2><p>在经过简单的了解与使用之后，感觉 到Angular2的强大与伟大，配的上说是一个优秀的前端框架。Angular2实现了前端一直提倡的组件化开发还解决了大部分项目路由混乱的问题。它还有具有MVC分层架构和依赖注入等一系列优秀的特性。现在贴上Angular2的一张架构图：<br><img src="http://o6plzvjf2.bkt.clouddn.com/angular_overview.png" alt="Angular2架构图"><br>上图描述了Angular2中8大主要构造块的关系，他们具体的理解，可以参考这篇<a href="http://www.cnblogs.com/1wen/p/5466620.html" target="_blank" rel="external">博文</a>。如果还有什么不理解，那我们可以相信实践见真知。</p>
<h2 id="Angular起步"><a href="#Angular起步" class="headerlink" title="Angular起步"></a>Angular起步</h2><p>在这次学习中，我终于理解了前辈们所说的入门一门技术就好的方法就是去看官方文档了，<a href="https://angular.cn/docs/ts/latest/" target="_blank" rel="external">Angular2的官网文档</a>里面有中文版的，相信大家一定很开心吧。当然没有中文版也是要看的，比较都是最基础的入门，不要惧怕英文。</p>
<p>在这次按照官方文档的教程（英雄编辑器）出现了两个问题，这里也说明一下：</p>
<ol>
<li>angular-in-memory-web-apia模块不存在</li>
</ol>
<p>解决方法：通过命令行安装<br><figure class="highlight plain"><figcaption><span>i angular-in-memory-web-api```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.</div></pre></td></tr></table></figure></p>
<p>create(name: string): Promise<hero> {<br>return this.http<br>.post(this.heroesUrl, JSON.stringify({name: name}), this.headers)<br>.toPromise()<br>.then(res =&gt; res.json().data as Hero)<br>.catch(this.handleError);<br>}<br>```<br>这里的post方法中的第三个参数应该是this.headers,而不是像官方文档中的那样。</hero></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果遇到不懂得问候多看看文档吧，相信自己可以的，然后就是实践见真知了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：由于老师暑假的项目前端代码需要用到Angular2，作为一个后端开发者也是需要了解一丢丢的。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="http://bestlixiang.site/tags/JavaScript/"/>
    
      <category term="Angular2" scheme="http://bestlixiang.site/tags/Angular2/"/>
    
  </entry>
  
  <entry>
    <title>简谈entity，model，domain</title>
    <link href="http://bestlixiang.site/2017/05/23/%E7%AE%80%E8%B0%88entity%EF%BC%8Cmodel%EF%BC%8Cdomain/"/>
    <id>http://bestlixiang.site/2017/05/23/简谈entity，model，domain/</id>
    <published>2017-05-23T05:58:35.000Z</published>
    <updated>2017-05-23T06:00:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：前两天听到关于entity和domain包的区别，好像之前自己也没有在意过，今天看看网上的信息总结一下。<a id="more"></a></p>
<h2 id="entity（实体）"><a href="#entity（实体）" class="headerlink" title="entity（实体）"></a>entity（实体）</h2><p>这好像是最常用的package命名了，package的类一般都是和数据库的表对应的。一个实体，一张表，其字段的类型也是对应的。</p>
<h2 id="model（模型）"><a href="#model（模型）" class="headerlink" title="model（模型）"></a>model（模型）</h2><p>最初接触到它的时候是Struts的模型驱动，用于接受和显示前台的数据对象。我们要根据实际情况来确定模型的类。</p>
<h2 id="domain（域）"><a href="#domain（域）" class="headerlink" title="domain（域）"></a>domain（域）</h2><p>说实话，这个包名用得不怎么多，在网上显示它在国外的网站用的比较多，它主要是用于存储一个业务对象（模块对象）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正确命名包名，有助于后续代码的维护，以及后来开发者的维护，最重要的是能衔接行业的规范。慢慢来！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前两天听到关于entity和domain包的区别，好像之前自己也没有在意过，今天看看网上的信息总结一下。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="web" scheme="http://bestlixiang.site/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>命令行运行hadoop程序</title>
    <link href="http://bestlixiang.site/2017/05/20/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8Chadoop%E7%A8%8B%E5%BA%8F/"/>
    <id>http://bestlixiang.site/2017/05/20/命令行运行hadoop程序/</id>
    <published>2017-05-20T05:37:33.000Z</published>
    <updated>2017-05-20T05:45:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：自己最近心态有点崩，毕竟很迷茫，趁现在比较空 ，也就微微看看hadoop。在运行《Hadoop权威指南》的时候，遇到了按照书上命令行无法运行的问题。<a id="more"></a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="https://drops.azureedge.net/drops/files/acc_558828/cM02q?rscd=inline%3B%20filename%3Dimage%252Fpng&amp;rsct=image%2Fpng&amp;se=2017-05-20T05%3A30%3A20Z&amp;sig=cRQBz%2FO6TM7UcO0YFpb8lkodVaMOOQkgOBI1uFeGYK8%3D&amp;sp=r&amp;sr=b&amp;st=2017-05-20T04%3A30%3A20Z&amp;sv=2013-08-15" alt="问题"></p>
<p>大家都知道刚开始入门，就遇到问题了就必然是十分难受的，那么我们现在可以解决。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>编辑 ~/.bash_profile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export HADOOP_HOME=/usr/local/hadoop</div><div class="line">export CLASSPATH=$($HADOOP_HOME/bin/hadoop classpath):$CLASSPATH</div></pre></td></tr></table></figure></p>
<p>使其生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.bash_profile</div></pre></td></tr></table></figure></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ol>
<li><p>编译主类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac MaxTemperature.java</div></pre></td></tr></table></figure>
</li>
<li><p>把.class 文件打包成 jar，才能在 Hadoop 中运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jar -cvf MaxTemperature.jar ./MaxTemperature*.class</div></pre></td></tr></table></figure>
</li>
<li><p>创建input文件夹的数据，就可以运行了(每次运行时，output文件夹都应该不存在)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hadoop MaxTemperature input/ncdc/sample.txt output</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然我自己还不知道书上的命令行为什么不能用，但是还是希望慢慢可以弄懂吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：自己最近心态有点崩，毕竟很迷茫，趁现在比较空 ，也就微微看看hadoop。在运行《Hadoop权威指南》的时候，遇到了按照书上命令行无法运行的问题。
    
    </summary>
    
      <category term="大数据" scheme="http://bestlixiang.site/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hadoop" scheme="http://bestlixiang.site/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="http://bestlixiang.site/2017/05/17/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://bestlixiang.site/2017/05/17/贪心算法/</id>
    <published>2017-05-17T14:41:13.000Z</published>
    <updated>2017-05-23T06:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：上次看到过钟华老师的一个基于贪心算法的毕业设计，一直很好奇，今天终于能看看它了，只是知其然，不知所以然。<a id="more"></a></p>
<h2 id="贪心算法总说"><a href="#贪心算法总说" class="headerlink" title="贪心算法总说"></a>贪心算法总说</h2><p>贪心算法在每一步都会做出看起来是最佳的选择，也就是说会做出局部最优的选择，希望以此能够得到最优解。</p>
<h2 id="活动选择问题"><a href="#活动选择问题" class="headerlink" title="活动选择问题"></a>活动选择问题</h2><h3 id="贪心选择"><a href="#贪心选择" class="headerlink" title="贪心选择"></a>贪心选择</h3><p>我们要选择这样一个活动，选出它之后身下的资源能够被尽量多的其他任务所用，即选择最早结束的活动。</p>
<h3 id="递归贪心算法"><a href="#递归贪心算法" class="headerlink" title="递归贪心算法"></a>递归贪心算法</h3><p>算法思路：用两个数组s和f表示活动的开始和结束时间。下表k是我们要求解的子问题，以及问题规模n，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class ActivitySelector &#123;</div><div class="line">public int[] s = new int[]&#123;1,3,0,5,3,5,6,8,8,2,12&#125;;</div><div class="line">public int[] f = new int[]&#123;4,5,6,7,9,9,10,11,12,14,16&#125;;</div><div class="line">public List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</div><div class="line">public void recursiveActivitySelector(int[] s, int[] f,int k,int n)&#123;</div><div class="line">if(list.size()==0)&#123;</div><div class="line">list.add(1);</div><div class="line">&#125;</div><div class="line">int m = k+1;</div><div class="line">while (m&lt;n &amp;&amp; s[m]&lt;f[k])&#123;</div><div class="line">m = m+1;</div><div class="line">&#125;</div><div class="line">if(m&lt;n)&#123;</div><div class="line">list.add(m+1);</div><div class="line">recursiveActivitySelector(s, f, m, n);</div><div class="line">&#125; else &#123;</div><div class="line">return ;</div><div class="line">&#125;		</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">ActivitySelector activitySelector = new ActivitySelector();</div><div class="line"></div><div class="line">activitySelector.recursiveActivitySelector(activitySelector.s, activitySelector.f, 0, activitySelector.f.length);</div><div class="line">for (Integer i : activitySelector.list) &#123;</div><div class="line">System.out.println(i);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="迭代贪心算法"><a href="#迭代贪心算法" class="headerlink" title="迭代贪心算法"></a>迭代贪心算法</h3><p>这个过程是假设输入活动的结束时间是已经排好序的，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class GreedyActivitySelector &#123;</div><div class="line">public int[] s = new int[]&#123;1,3,0,5,3,5,6,8,8,2,12&#125;;</div><div class="line">public int[] f = new int[]&#123;4,5,6,7,9,9,10,11,12,14,16&#125;;</div><div class="line">public List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</div><div class="line">public void greedActivitySelector(int[] s,int[] f)&#123;</div><div class="line">int n = s.length;</div><div class="line">list.add(1);</div><div class="line">int k = 1;</div><div class="line">for (int m = 1; m &lt; n; m++) &#123;</div><div class="line">if(s[m]&gt;=f[k])&#123;</div><div class="line">list.add(k);</div><div class="line">k = m;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">ActivitySelector activitySelector = new ActivitySelector();</div><div class="line"></div><div class="line">activitySelector.recursiveActivitySelector(activitySelector.s, activitySelector.f, 0, activitySelector.f.length);</div><div class="line">for (Integer i : activitySelector.list) &#123;</div><div class="line">System.out.println(i);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="贪心算法原理"><a href="#贪心算法原理" class="headerlink" title="贪心算法原理"></a>贪心算法原理</h2><p>设计贪心算法的过程</p>
<ol>
<li>确定问题的最优子结构</li>
<li>设计一个递归算法</li>
<li>证明一个贪心选择，则只剩下一个子问题</li>
<li>证明贪心选择总是安全的</li>
<li>设计一个递归算法实现贪心策略</li>
<li>将递归算法转换为迭代算法</li>
</ol>
<p>证明一个贪心算法是否能求解一个最优化问题？具有下面性质就ok？</p>
<ol>
<li>贪心选择性质</li>
</ol>
<p>我们可以通过做出局部最优选择来构造全局最优解</p>
<ol>
<li>最优子结构</li>
</ol>
<p>如果一个问题的最优解包含子问题的最优解</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一步一步慢慢贪心，和做人是一样的，但是总的来说还是要考虑全局的！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：上次看到过钟华老师的一个基于贪心算法的毕业设计，一直很好奇，今天终于能看看它了，只是知其然，不知所以然。
    
    </summary>
    
      <category term="算法" scheme="http://bestlixiang.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="算法导论" scheme="http://bestlixiang.site/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://bestlixiang.site/2017/05/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://bestlixiang.site/2017/05/17/动态规划/</id>
    <published>2017-05-17T11:52:35.000Z</published>
    <updated>2017-05-17T11:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：慢慢就步入了算法导论的高级设计与分析技术模块，先来看看动态规划。ps:快毕业的心情org。<a id="more"></a></p>
<h2 id="动态规划总说"><a href="#动态规划总说" class="headerlink" title="动态规划总说"></a>动态规划总说</h2><p>动态规划虽然与分治方法相似，但是它能够解决子问题重叠的情况，这样就提高了效率。它通常是用来求解最优化的问题。求得是<strong>一个</strong>最优解。一般按如下4个步骤来设计一个动态规划算法。</p>
<ol>
<li>刻画一个最优解的结构特征</li>
<li>递归地定义最优解的值</li>
<li>计算最优解的值，通常采用自底向上的方法</li>
<li>利用计算出的信息构造出一个最优解</li>
</ol>
<h2 id="钢条切割"><a href="#钢条切割" class="headerlink" title="钢条切割"></a>钢条切割</h2><p>先看以前常用的分治方法即自顶向下方法,代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class CutRod &#123;</div><div class="line">//a[i]表示长度为i的钢条利润是多少</div><div class="line">public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;</div><div class="line">//自顶向下递归设计</div><div class="line">public int cutRod(int[] a,int n) &#123;</div><div class="line">if(n == 0)&#123;</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line">int q = 0;</div><div class="line">for (int i = 0; i&lt;n; i++)&#123;</div><div class="line">q = max(q,a[i]+cutRod(a,n-1-i));</div><div class="line">&#125;</div><div class="line">return q;</div><div class="line">&#125;</div><div class="line">//求最大值函数</div><div class="line">public int max(int a, int b)&#123;</div><div class="line">if(a&gt;b)&#123;</div><div class="line">return a;</div><div class="line">&#125; else &#123;</div><div class="line">return b;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">CutRod cut = new CutRod(); </div><div class="line">int lost = cut.cutRod(cut.a,10);</div><div class="line">System.out.println(lost);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>问题：反复地用相同的参数值对自身进行递归调用，造成了运行时间为n的指数函数。</p>
<p>为了解决这个问题，我们可以采用动态规划方法求解最优钢条切割问题。</p>
<ol>
<li><p>采用带备忘的自顶向下法<br>核心是利用一个数组存储已经求解过的最优解，避免了重复的计算，具体的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class MemoizedCutRod &#123;</div><div class="line">//a[i]表示长度为i的钢条利润是多少</div><div class="line">public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;</div><div class="line">//带备忘的自顶向下函数</div><div class="line">public int memoizedCutRod(int[] a,int n)&#123;</div><div class="line">//创建一个备忘的数组存储一个之前计算过的最优解</div><div class="line">int[] r = new int[n];</div><div class="line">//初始化数组</div><div class="line">for (int i : r) &#123;</div><div class="line">i = 0;</div><div class="line">&#125;</div><div class="line">//借助辅助函数计算</div><div class="line">return memoizedCutRodAux(a, n, r);</div><div class="line">&#125;</div><div class="line">//带备忘的自顶向下法辅助函数</div><div class="line">public int memoizedCutRodAux(int[] a,int n,int[] r) &#123;</div><div class="line">//定义利润</div><div class="line">int q = 0;</div><div class="line">if(n == 0)&#123;</div><div class="line">return 0;</div><div class="line">&#125; </div><div class="line">//判断原先是否已经计算过，若计算过就不用再计算</div><div class="line">if(r[n-1] &gt;0)&#123;</div><div class="line">return r[n-1]; </div><div class="line">&#125;else &#123;</div><div class="line">for (int i = 0; i&lt;n; i++)&#123;</div><div class="line">q = max(q,a[i]+memoizedCutRodAux(a, n-1-i, r));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">r[n-1] = q;</div><div class="line">return q;</div><div class="line">&#125;</div><div class="line">//求最大值函数</div><div class="line">public int max(int a, int b)&#123;</div><div class="line">if(a&gt;b)&#123;</div><div class="line">return a;</div><div class="line">&#125; else &#123;</div><div class="line">return b;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MemoizedCutRod cut = new MemoizedCutRod();</div><div class="line">int lost = cut.memoizedCutRod(cut.a, 10);</div><div class="line">System.out.println(lost);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>采用由底向上的方法<br>核心是从小算到大算出每一个长度的最优解，然后返回想要的长度的最优解。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class BottomUpTopCutRod &#123;</div><div class="line">//a[i]表示长度为i的钢条利润是多少</div><div class="line">public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;</div><div class="line">public int bottomUpTopCutRod(int[] a, int n)&#123;</div><div class="line">int[] r = new int[n+1];</div><div class="line">//长度为0的时候，收益为0</div><div class="line">r[0] = 0;</div><div class="line">int q = 0;</div><div class="line">for(int i = 0; i&lt;n; i++)&#123;</div><div class="line">for(int j = 0; j&lt;=i; j++)&#123;</div><div class="line">q = max(q,a[j]+r[i-j]);</div><div class="line">&#125;</div><div class="line">r[i+1] = q;</div><div class="line">&#125;</div><div class="line">return r[n];</div><div class="line">&#125;</div><div class="line">//求最大值函数</div><div class="line">public int max(int a, int b)&#123;</div><div class="line">if(a&gt;b)&#123;</div><div class="line">return a;</div><div class="line">&#125; else &#123;</div><div class="line">return b;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">BottomUpTopCutRod cut = new BottomUpTopCutRod();</div><div class="line">int lost = cut.bottomUpTopCutRod(cut.a, 10);</div><div class="line">System.out.println(lost);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>优势：实现了运行时间复杂度n*n</p>
<h2 id="动态规划原理"><a href="#动态规划原理" class="headerlink" title="动态规划原理"></a>动态规划原理</h2><p>适用应用动态规划方法求解的最优化问题应该具备的两个要素：最优子结构和子问题重叠</p>
<h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>如果一个问题的最优解包含其子问题的最优解，我们就称这个问题具有最优子结构性质。例如：无权最短路径。</p>
<h3 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h3><p>如果递归算法反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质。例如钢条切割。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>慢慢懂一点小算法思想。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：慢慢就步入了算法导论的高级设计与分析技术模块，先来看看动态规划。ps:快毕业的心情org。
    
    </summary>
    
      <category term="算法" scheme="http://bestlixiang.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="算法导论" scheme="http://bestlixiang.site/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>观《驴得水》呻吟</title>
    <link href="http://bestlixiang.site/2017/05/11/%E8%A7%82%E3%80%8A%E9%A9%B4%E5%BE%97%E6%B0%B4%E3%80%8B%E5%91%BB%E5%90%9F/"/>
    <id>http://bestlixiang.site/2017/05/11/观《驴得水》呻吟/</id>
    <published>2017-05-11T07:48:01.000Z</published>
    <updated>2017-05-17T07:50:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：其实当身边同学都在打游戏的时候，我却不能静下心来了，内心仍然是浮躁，既然不能改论文，所以自己就找电影看吧。自认为自己是一个不懂得享受的人，所以在大脑思索良久之后，决定观看好久之前评价还不错的电影《驴得水》。<a id="more"></a></p>
<h2 id="总说"><a href="#总说" class="headerlink" title="总说"></a>总说</h2><p>我不知道该以什么角度来评价这部电影，但这部电影给我感受是深刻，至少在灵魂上还是有一定的冲击，感觉作者与导演把每个角色想要表达的思想基本上都表达出来了，下面我也将按这些角色把在我身上能够体会到的思想说一下，至少在我心里，这是一部好电影。</p>
<h2 id="角色思想"><a href="#角色思想" class="headerlink" title="角色思想"></a>角色思想</h2><h3 id="校长"><a href="#校长" class="headerlink" title="校长"></a>校长</h3><p>这个一个有抱负的校长，但是却又特别的自私，为了达成自己的抱负，他选择了屈服，虽然在某些片段来说，他有一点想反抗，如他不能忍受裴魁山去骂张一曼，但是那一点反抗却是那么无力，到最后他选择了屈服，屈服到了让自己的女儿去做牺牲。<br>关于这个角色我不想做太多评价，他总说以大局为重，或许在生活中很多人都会这么做，自私到可以牺牲掉很多。</p>
<h3 id="裴魁山"><a href="#裴魁山" class="headerlink" title="裴魁山"></a>裴魁山</h3><p>这个角色应该就是现在很多人所说的腹黑吧，自己得不到，就宁愿把他毁掉，他从不介意张一曼的出身愿意娶她，到指着他的鼻子骂，这个转变让很多人心凉，追不到还能做朋友么，他的回答告诉我们，他不搞她已经是最好的结果了。爱一个可以随时为她着想，恨一个人希望所有人都恨他。</p>
<h3 id="铜匠"><a href="#铜匠" class="headerlink" title="铜匠"></a>铜匠</h3><p>也许他后面变得很坏，但是我从头到尾都认为他是这部剧最可怜的人，他原来是一个单纯至极的人，命运使然他加入到了一个骗子集团吧，因为单纯才会认为张一曼会喜欢他吧，因为单纯所以期望太高，这导致在张一曼骂他牲口之后开始最强烈的抱负。但是有一点他这个觉得传递了不好的概念，有知识不是为了更好的抱负，而是应该为了更好的帮助别人，虽然他的行为可以理解，但是却不提倡，从他到最后还是想去美国学习，可以看出他还是很想学习的，想脱离文盲这个行列。</p>
<h3 id="张一曼"><a href="#张一曼" class="headerlink" title="张一曼"></a>张一曼</h3><p>这是一个不畏世俗的眼光，勇敢追求自由的女子，也不能说是道德败坏吧，虽然和有妇之夫搞一起不太好，但是他自己也有自己的原则，就像他一开始不愿意将她和铜匠的事情说出来一样，他有自己一定的原则。但是在校长的屈服下，也造就了他的悲剧，最后开枪自杀了。</p>
<h3 id="周铁男"><a href="#周铁男" class="headerlink" title="周铁男"></a>周铁男</h3><p>这个角色也是反映了一部分人，他喜欢孙佳，但是一直没有说出来，也算单纯耿直的人，平时脾气挺冲，在别人要动孙佳的时候也立马站了出来，可惜在擦过枪子的之后，他选择了屈服，他慢慢开始收敛自己，只是为了能够活下去，他甚至可以认忍受孙佳去嫁给铜匠，所以说，所谓的爱在现实的生与死之间是那么的不堪。</p>
<h3 id="孙佳"><a href="#孙佳" class="headerlink" title="孙佳"></a>孙佳</h3><p>这个人或许是这部剧中完全没有污点的人吧，应该也是导演想表达的正面形象，他是唯一一个把驴得水当做人看的人，也是第一个想揭发整个阴谋的人，面对这一切，她说过去的都让他过去的话，那么只能越来越错，不能让错误一直延续下去。莫名戳中内心。</p>
<h3 id="特派员"><a href="#特派员" class="headerlink" title="特派员"></a>特派员</h3><p>一个目不识丁，却假装英国留学回来的官员，所谓的民间教育家的评选，不过是教育部敛财的名头，从被骗到一起骗说明政府的腐败与强势，从十万到三万，我们看到了心凉。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要人物各有各的责任，他们都反应了这个世界上的一部分人，所以感受很深，点评不当之处，也希望大家担待。好吧，呻吟到此结束。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：其实当身边同学都在打游戏的时候，我却不能静下心来了，内心仍然是浮躁，既然不能改论文，所以自己就找电影看吧。自认为自己是一个不懂得享受的人，所以在大脑思索良久之后，决定观看好久之前评价还不错的电影《驴得水》。
    
    </summary>
    
      <category term="生活" scheme="http://bestlixiang.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="电影" scheme="http://bestlixiang.site/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>选择算法</title>
    <link href="http://bestlixiang.site/2017/05/10/%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/"/>
    <id>http://bestlixiang.site/2017/05/10/选择算法/</id>
    <published>2017-05-10T14:18:10.000Z</published>
    <updated>2017-05-10T14:19:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：300000是不是一个小目标，不知道为了目的还是目的，只想好好努力，功利也好，安慰也罢！<a id="more"></a></p>
<h2 id="期望为线性时间的选择算法"><a href="#期望为线性时间的选择算法" class="headerlink" title="期望为线性时间的选择算法"></a>期望为线性时间的选择算法</h2><p>算法思想：</p>
<ol>
<li>检查数组是否只有一个数，如是，只好返回该数</li>
<li>采用随机分割将数组氛围a[p..q-1]和a[q+1..r]并返回主元q</li>
<li>检查如果该主元就是我们要找的数，就返回</li>
<li>判断前半部分的个数，如果要找的顺序大于前面的个数，就递归调用后面的数组，否则递归调用前面的数组</li>
</ol>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">public class Randomized_select &#123;</div><div class="line">public int randomized_select(int[] a,int p, int r,int i)&#123;</div><div class="line">//如果分割到只剩一个元素了，那么就是这个了</div><div class="line">if(p == r)&#123;</div><div class="line">return a[p];</div><div class="line">&#125;</div><div class="line">//随机分割</div><div class="line">int q = randompartition(a, p, r);</div><div class="line">//确定q是第几小的数</div><div class="line">int k = q-p+1;</div><div class="line">if(k == i) &#123;</div><div class="line">return a[q];</div><div class="line">&#125;</div><div class="line">else if(k&lt;i)&#123;</div><div class="line">//递归调用后半部分的数</div><div class="line">return randomized_select(a, q+1, r, i-k);</div><div class="line">&#125; else &#123;</div><div class="line">//递归调用前半部分的数</div><div class="line">return randomized_select(a, p, q-1, i);</div><div class="line">&#125;		</div><div class="line">&#125;</div><div class="line">//分割函数</div><div class="line">public int partition(int[] a,int p,int r)&#123;</div><div class="line">int x = a[r];</div><div class="line">int i = -1;</div><div class="line">int temp = 0;</div><div class="line">for (int j = 0; j &lt; a.length-1; j++) &#123;</div><div class="line">if(a[j]&lt;x)&#123;</div><div class="line">i=i+1;</div><div class="line">temp = a[i];</div><div class="line">a[i] = a[j];</div><div class="line">a[j] = temp;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">temp = a[i+1];</div><div class="line">a[i+1] = x;</div><div class="line">a[r] = temp;</div><div class="line">return i+1;</div><div class="line">&#125;</div><div class="line">//随机分割　</div><div class="line">public int randompartition(int[] a,int p,int r)&#123;</div><div class="line">int temp = 0;</div><div class="line">Random random = new Random();</div><div class="line">int i = random.nextInt(r);</div><div class="line">temp = a[i];</div><div class="line">a[i] = a[r];</div><div class="line">a[r] = temp;</div><div class="line">return partition(a, p, r);</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">int[] a = new int[]&#123;3,2,9,0,7,5,4,8,6,1&#125;;</div><div class="line">Randomized_select select = new Randomized_select();</div><div class="line">int num = select.randomized_select(a, 0, a.length-1, 10);</div><div class="line">System.out.println(num);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>算法分析：期望时间复杂度是线性的O(n),但是最坏的时间复杂度是O(n*n)</p>
<h2 id="最坏情况为线性时间的选择算法"><a href="#最坏情况为线性时间的选择算法" class="headerlink" title="最坏情况为线性时间的选择算法"></a>最坏情况为线性时间的选择算法</h2><p>算法思想：</p>
<ol>
<li>将输入数组的n个元素划分为n/5组，每组5个元素，且至多只有一组由剩下的nmod5个元素组成。</li>
<li>寻找每一个组的中位数：首先对每组元素进行插入排序，然后确定每组的中位数。</li>
<li>对第2部的中位数数组利用递归调用前面的random_select()求取中位数x</li>
<li>利用修改的partition(),按中位数x进行划分，得到比x小的数有k个</li>
<li>如果i=k则返回x。如果i<k,则在低区递归调用select找出第i小元素，如果i>k，则在高区递归查找第i-k小的元素</k,则在低区递归调用select找出第i小元素，如果i></li>
</ol>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">package select;</div><div class="line"></div><div class="line">public class GoodSelect &#123;</div><div class="line">//插入排序</div><div class="line">public void insertsort(int[] a,int p, int r)</div><div class="line">&#123;</div><div class="line">for (int i=p+1;i&lt;=r;i++) &#123;</div><div class="line">int temp = 0;</div><div class="line">//*从后往前插*</div><div class="line">for(int j = i;j&gt;p &amp;&amp; a[j]&lt;a[j-1];j--)&#123;</div><div class="line">temp = a[j];</div><div class="line">a[j] = a[j-1];</div><div class="line">a[j-1] = temp;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//对数组A[]分组，每组5个元素，分别进行插入排序,返回中位数数组</div><div class="line">public int[] partInsertSort(int[] a,int p,int r)  &#123;</div><div class="line">int i = 0;</div><div class="line">int[] b;</div><div class="line">if((r-p+1)%5==0)&#123;</div><div class="line">b = new int[(r-p+1)/5];</div><div class="line">&#125; else &#123;</div><div class="line">b = new int[(r-p+1)/5+1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">int Length = r-p+1;</div><div class="line">if (Length &lt;= 5)     //元素个数少于5个</div><div class="line">&#123;  </div><div class="line">insertsort(a,p,r);</div><div class="line">b[0]=a[p+(Length-1)/2];</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">for (i=0;i&lt;Length/5;i++)</div><div class="line">&#123;</div><div class="line">insertsort(a,p+i*5,p+i*5+4);</div><div class="line"></div><div class="line">b[i]=a[i*5+2];     //B[i] 存储各组中位数</div><div class="line">&#125;</div><div class="line">if ( Length%5 != 0 )</div><div class="line">&#123;</div><div class="line">insertsort(a,Length-1-(Length-1)%5,Length-1);</div><div class="line">b[i]=a[Length-1-Length%5/2];  //B[i] 存储最后一组中位数</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return b;           //  返回分组的个数</div><div class="line"></div><div class="line">&#125;</div><div class="line">//调用random_select算法，选出中位数数组的中位数</div><div class="line">public int selectmid(int[] a)&#123;</div><div class="line">Randomized_select randomized_select = new Randomized_select();</div><div class="line">int num = randomized_select.randomized_select(a, 0, a.length-1, (a.length+1)/2);</div><div class="line">return num;		</div><div class="line">&#125;</div><div class="line">//安装精心挑选的中位数来分割数组</div><div class="line">public int partition(int[] a,int p,int r,int x)&#123;</div><div class="line">int j = p-1;</div><div class="line">int i = 0;</div><div class="line">int temp =0;</div><div class="line">int addr = 0;//记录最佳中位数的位置</div><div class="line">for(i = p; i&lt;r+1; i++)&#123;</div><div class="line">if(a[i]&lt;=x)&#123;</div><div class="line">j+=1;</div><div class="line">temp = a[j];</div><div class="line">a[j] = a[i];</div><div class="line">a[i] = temp;				</div><div class="line">&#125;</div><div class="line">if(a[i] == x)&#123;</div><div class="line">addr = i;</div><div class="line">&#125;		</div><div class="line">&#125;</div><div class="line">temp = a[j];</div><div class="line">a[j] = a[addr];</div><div class="line">a[addr] = temp;	</div><div class="line">return j;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public int goodselect(int[] a,int p,int r,int i)&#123;</div><div class="line">//如果分割到只剩一个元素了，那么就是这个了</div><div class="line">if(p == r)&#123;</div><div class="line">return a[p];</div><div class="line">&#125;</div><div class="line">int [] b = partInsertSort(a, p, r);</div><div class="line">int x = selectmid(b);</div><div class="line">int q = partition(a, p, r, x);</div><div class="line">//确定q是第几小的数</div><div class="line">int k = q-p+1;</div><div class="line">if(k == i) &#123;</div><div class="line">return a[q];</div><div class="line">&#125;</div><div class="line">else if(k&lt;i)&#123;</div><div class="line">//递归调用后半部分的数</div><div class="line">return goodselect(a, q+1, r, i-k);</div><div class="line">&#125; else &#123;</div><div class="line">//递归调用前半部分的数</div><div class="line">return goodselect(a, p, q-1, i);</div><div class="line">&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">int[] a = new int[]&#123;2,1,4,6,5,8,9,7,11,13,12,15,16&#125;;</div><div class="line">GoodSelect select = new GoodSelect();</div><div class="line">int num  = select.goodselect(a, 0, a.length-1, 13);</div><div class="line">System.out.println(num);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>算法总结：毕竟是三个人发明的算法，真是好牛逼的，厉害，实现了最坏时间还是线性的。具体分析请参考算法导论原书。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第二个算法真的花了自己好长的时间来调试，还是说明自己的编码能力差劲，要好好努力，慢慢提高，加油！</p>
<p>ps：有一种体会，学算法是为了创造，大多数人只要把优秀的源码包里的算法理解了就好，并加以使用就好！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：300000是不是一个小目标，不知道为了目的还是目的，只想好好努力，功利也好，安慰也罢！
    
    </summary>
    
      <category term="算法" scheme="http://bestlixiang.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法导论" scheme="http://bestlixiang.site/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>“线性时间排序（未完，待续）”</title>
    <link href="http://bestlixiang.site/2017/05/10/%E2%80%9C%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%8C%E5%BE%85%E7%BB%AD%EF%BC%89%E2%80%9D/"/>
    <id>http://bestlixiang.site/2017/05/10/“线性时间排序（未完，待续）”/</id>
    <published>2017-05-10T02:11:16.000Z</published>
    <updated>2017-05-10T02:13:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：排序慢慢来，今天要接触到线性时间排序了：计数排序，基数排序，桶排序。<a id="more"></a></p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>前提条件：知道输入数组的最大值。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public int[] countingsort(int[] a,int k)&#123;</div><div class="line">//初始化临时数组,k为数组的最大值</div><div class="line">int[] c = new int[k+1];</div><div class="line">for(int i=0; i&lt;=k; i++) &#123;</div><div class="line">c[i]=0;</div><div class="line">&#125;</div><div class="line">//获得等于i的元素个数</div><div class="line">for(int i= 0; i&lt;a.length-1;i++) &#123;</div><div class="line">c[a[i]] = c[a[i]]+1;</div><div class="line">&#125;</div><div class="line">//获得小于等于i的元素个数(隐含了递归调用)</div><div class="line">for(int i = 1; i&lt;=k; i++) &#123;</div><div class="line">c[i] = c[i] +c[i-1];</div><div class="line">&#125;</div><div class="line">//按顺序分到输出数组</div><div class="line">int[] b = new int[a.length];</div><div class="line">for(int i = a.length-1; i&gt;=0; i--) &#123;</div><div class="line">b[c[a[i]]] = a[i];</div><div class="line">c[a[i]] = c[a[i]]-1;</div><div class="line">&#125;</div><div class="line">return b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优劣：实现了线性时间，但是空间损失惨重，像是叫你排序这三个数：1，3，1000000000000，马上高低立见。</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>IBM创始人发明，利用进制数的位进行从低到高比较。其中会将原来的数转化为r进制数，使时间复杂度变为线性。<br>写一下伪代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">redix-sort(A,d)</div><div class="line">for i = 1 to d</div><div class="line">use a stable sort to sort array A on digit i</div></pre></td></tr></table></figure></p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序假设数据服从均匀分布，讲一个区间分成若干个桶，先将数据放到桶中分开排序再合并。<br>伪代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">bucket-sort(A)</div><div class="line">n = A.length</div><div class="line">let B[0.. n-1] be a new array</div><div class="line">for i = 0 to n - 1</div><div class="line">make  B[i] an empty list</div><div class="line">for i = 1 to n </div><div class="line">insert A[i] into list B[nA[i]]</div><div class="line">for i = 0 to n - 1</div><div class="line">sort list B[i] with insertion sort</div><div class="line">concatenete the lists B[0],B[1].. B[n-1] together in order</div></pre></td></tr></table></figure></p>
<p>它的期望时间为线形。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其中对于基数排序和桶排序理解得不是很好，需要加深理解，写出具体实现代码，未完，待续…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：排序慢慢来，今天要接触到线性时间排序了：计数排序，基数排序，桶排序。
    
    </summary>
    
      <category term="算法" scheme="http://bestlixiang.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="线性时间排序" scheme="http://bestlixiang.site/tags/%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F/"/>
    
      <category term="算法导论" scheme="http://bestlixiang.site/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://bestlixiang.site/2017/05/10/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://bestlixiang.site/2017/05/10/堆排序/</id>
    <published>2017-05-10T01:32:17.000Z</published>
    <updated>2017-05-10T01:37:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：真的是烦，连个hadoop集群环境都搭不好，发现一个人学还是很困难的，想想还是一个人看算法会简单些，所以来看看了，今天看堆排序！<a id="more"></a></p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>堆排序是原址运算，后来由于Java的原因我用了变址，但是算法的思想还是没有变得的.堆分为大顶堆，小顶堆，我们下面以大顶堆为例。</p>
<h3 id="维护堆"><a href="#维护堆" class="headerlink" title="维护堆"></a>维护堆</h3><p>我们需要一个函数在任何情况下子节点要比根节点小。<br>函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">//取父节点</div><div class="line">public int parent(int i)&#123;</div><div class="line"> return (int)Math.ceil(i/2)-1;</div><div class="line">&#125;</div><div class="line">//取左子树</div><div class="line">public int left(int i)&#123;</div><div class="line">	if(i == 0)&#123;</div><div class="line">		return i+1;</div><div class="line">	&#125; else&#123;</div><div class="line">		return 2*i+1;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//取右子树</div><div class="line">public int right(int i)&#123;</div><div class="line">	if(i == 0)&#123;</div><div class="line">		return i+2;</div><div class="line">	&#125; else&#123;</div><div class="line">		return 2*i+2;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//维护大顶堆</div><div class="line">public int[] max_heapify(int[] a,int i)&#123;</div><div class="line">	int l = left(i);</div><div class="line">	int r = right(i);</div><div class="line">	int largest = 0;</div><div class="line">	int temp = 0;</div><div class="line">	if(l&gt;=a.length &amp;&amp; r&gt;=a.length)&#123;</div><div class="line">		return a;</div><div class="line">	&#125;</div><div class="line">	if(l&lt;a.length &amp;&amp; a[l]&gt;a[i])&#123;</div><div class="line">		largest = l;</div><div class="line">	&#125; else&#123;</div><div class="line">		largest = i;</div><div class="line">	&#125;</div><div class="line">	if(r&lt;a.length &amp;&amp; a[r]&gt;a[largest])&#123;</div><div class="line">		largest = r;</div><div class="line">	&#125;</div><div class="line">	if(largest!=i) &#123;</div><div class="line">		temp = a[i];</div><div class="line">		a[i] = a[largest];</div><div class="line">		a[largest] = temp;</div><div class="line">		max_heapify(a, largest);</div><div class="line">	&#125;</div><div class="line">	return a;		</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>在对数组遍历建立二叉树的时候，我们容易得出Math.floor(n/2)到n都是叶节点，其余是根节点，所以我们在建堆得时候冲根节点不断往前维护就好。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//建大堆</div><div class="line">public int[] bulid_max_heap(int[] a)&#123;</div><div class="line">	heap_size = a.length;</div><div class="line">	for(int i = (int)Math.floor(a.length/2)-1; i&gt;=0; i--)&#123;</div><div class="line">		max_heapify(a, i);</div><div class="line">	&#125;</div><div class="line">	return a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h3><p>思想：先取出顶，再维护，再取顶，再维护，知道最后<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//堆排序算法</div><div class="line">public int[] heapsort(int[] a) &#123;</div><div class="line">	int[] b = new int[a.length];//无奈之举，java没有size这个属性，或者用list也可以</div><div class="line">	bulid_max_heap(a);</div><div class="line">	for(int i = a.length-1; i&gt;=1; i--)&#123;</div><div class="line">		b[i] = a[0];</div><div class="line">		a[0] = a[i];</div><div class="line">		a[i] = 0;//使最后一个元素不参与排序</div><div class="line">		max_heapify(a, 0);</div><div class="line">	&#125;</div><div class="line">	b[0] = a[0];</div><div class="line">	return b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>算法时间复杂度：<strong>nlgn</strong></p>
<h3 id="重要应用——优先队列"><a href="#重要应用——优先队列" class="headerlink" title="重要应用——优先队列"></a>重要应用——优先队列</h3><p>优先队列应用于共享计算机的系统的作业调度，最大优先队列记录将要执行的各个作业以及它们之间的相对优先级，在任何时候都可以调用insert把一个新作业加入到队列中来。<br>讲一下最大优先序列的几个操作。</p>
<h4 id="maximum获取最大值"><a href="#maximum获取最大值" class="headerlink" title="maximum获取最大值"></a>maximum获取最大值</h4><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">	//获取最大值</div><div class="line">public int maximum(int[] a)&#123;</div><div class="line">	return a[1];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="去掉并返回数组中的最大键值得元素"><a href="#去掉并返回数组中的最大键值得元素" class="headerlink" title="去掉并返回数组中的最大键值得元素"></a>去掉并返回数组中的最大键值得元素</h4><p>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//去掉并返回数组中具有最大键值得元素</div><div class="line">public int extract_max(int[] a)&#123;</div><div class="line">	if(a.length&lt;1)&#123;</div><div class="line">		System.out.println(&quot;heap underflow&quot;);</div><div class="line">	&#125;</div><div class="line">	int max = a[0];</div><div class="line">	a[0] = a[a.length];</div><div class="line">	max_heapify(a, 0);</div><div class="line">	return max;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>加油呀加油！堆排序还是强大的，期待运用！ </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：真的是烦，连个hadoop集群环境都搭不好，发现一个人学还是很困难的，想想还是一个人看算法会简单些，所以来看看了，今天看堆排序！
    
    </summary>
    
      <category term="算法" scheme="http://bestlixiang.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法导论" scheme="http://bestlixiang.site/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>nginx反向代理与负载均衡</title>
    <link href="http://bestlixiang.site/2017/05/06/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://bestlixiang.site/2017/05/06/nginx反向代理与负载均衡/</id>
    <published>2017-05-06T14:45:44.000Z</published>
    <updated>2017-05-06T15:09:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：慢慢做项目的过程中，也就接触到了负载均衡，谈到负载均衡就会接触到反向代理服务器，这里介绍一下nginx。<a id="more"></a></p>
<h2 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h2><h3 id="nginx简介"><a href="#nginx简介" class="headerlink" title="nginx简介"></a>nginx简介</h3><p>nginx是一个使用c语言开发的高性能的http服务器及反向代理服务器，是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。<br>感觉棒棒哒。</p>
<h3 id="nginx应用场景"><a href="#nginx应用场景" class="headerlink" title="nginx应用场景"></a>nginx应用场景</h3><ol>
<li>http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。</li>
<li>虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。</li>
<li>反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。</li>
</ol>
<h3 id="nginx安装启动配置"><a href="#nginx安装启动配置" class="headerlink" title="nginx安装启动配置"></a>nginx安装启动配置</h3><ol>
<li>安装：<br>nginx一般安装在linux下</li>
<li>启动： <code>在sbin目录下执行: ./nginx</code> 如果访问不到，可能就是linux防火墙没有开启8080端口的访问——关闭：<code>在sbin目录下执行: ./nginx -s stop</code>——刷新配置：<code>在sbin目录下执行: ./nginx -s reload</code></li>
<li>配置虚拟主机：在nginx.conf文件中添加一个Service节点，修改端口号就可以<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">	listen       81;</div><div class="line">	server_name  localhost;</div><div class="line"></div><div class="line">	#charset koi8-r;</div><div class="line"></div><div class="line">	#access_log  logs/host.access.log  main;</div><div class="line"></div><div class="line">	location / &#123;</div><div class="line">	root   html81;</div><div class="line">	index  index.html index.htm;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="nginx反向代理-1"><a href="#nginx反向代理-1" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h2><p>反向代理服务器是引用在服务端。决定哪台服务器提供服务。<br>用一张图来理解：<br><img src="http://o6plzvjf2.bkt.clouddn.com/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" alt="反向代理"></p>
<h2 id="nginx负载均衡"><a href="#nginx负载均衡" class="headerlink" title="nginx负载均衡"></a>nginx负载均衡</h2><p>并发量大的时候自然会用到负载均衡，其实每台服务器的内容都是一样的，多台机器服务自然减轻了单台服务器的压力。在nginx中其实配置很简单，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">upstream tomcats&#123;</div><div class="line">	server 192.168.142.128:8080 weight=2;</div><div class="line">	server 192.168.142.128:8081;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server&#123; </div><div class="line">	listen     80;</div><div class="line">	server_name  tomcat.taobao.com;</div><div class="line"></div><div class="line">	#charset koi8-r;</div><div class="line"></div><div class="line">	#access_log  logs/host.access.log  main;</div><div class="line">	location / &#123;</div><div class="line">	proxy_pass http://tomcats;</div><div class="line">	index  index.html index.htm;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只需要在upstream的server后面添加一个weight即可代表权重。权重越高，分配请求的数量就越多。默认权重是1。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实很多东西没有自己想象的那么难，好好努力，每天积累！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：慢慢做项目的过程中，也就接触到了负载均衡，谈到负载均衡就会接触到反向代理服务器，这里介绍一下nginx。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="nginx" scheme="http://bestlixiang.site/tags/nginx/"/>
    
      <category term="负载均衡" scheme="http://bestlixiang.site/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>快速排序及随机化算法</title>
    <link href="http://bestlixiang.site/2017/05/06/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    <id>http://bestlixiang.site/2017/05/06/快速排序及随机化算法/</id>
    <published>2017-05-05T16:04:52.000Z</published>
    <updated>2017-05-05T23:42:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：算法一直很重要，最近没有心情去看项目的代码与技术，所以就拿起其了算法导论来看，最经典的快速排序及随机化算法，java实现。<a id="more"></a></p>
<h2 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h2><ol>
<li>核心思想<br>分治思想和原址运算：看一张图<br><img src="http://o6plzvjf2.bkt.clouddn.com/131558588563352.jpg" alt="快速排序"></li>
<li><p>算法具体实现 </p>
<blockquote>
</blockquote>
<pre><code>public class QuickSort {
    public int partition(int[] a,int p,int r){
        int x = a[r];
        int i = -1;
        int temp = 0;
        for (int j = 0; j &lt; a.length-1; j++) {
            if(a[j]&lt;x){
                i=i+1;
                temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
        temp = a[i+1];
        a[i+1] = x;
        a[r] = temp;
        return i+1;
    }

    public int[] quicksort(int[] b,int p,int r){
        if(p&lt;r){
            int q = partition(b,p,r);
            quicksort(b, p, q-1);
            quicksort(b, q+1, r);
        }
        return b;
    }

    public static void main(String[] args) {
        QuickSort sort = new QuickSort();
        int[] a = {2,8,7,1,3,5,6,4};
        int[] b = sort.quicksort(a, 0, a.length-1);
        for (int i : b) {
            System.out.print(i+&quot; &quot;);
        }
    }
}
</code></pre></li>
</ol>
<p>3.时间复杂度</p>
<p>通过分析我们最看重的平均复杂度是nlgn</p>
<h2 id="随机化算法"><a href="#随机化算法" class="headerlink" title="随机化算法"></a>随机化算法</h2><ol>
<li>核心思想</li>
</ol>
<p>在算法加入随机性，要么在使序列生成随机化，要么就是使主元随机化，这里我们使主元随机化。</p>
<ol>
<li><p>算法具体实现</p>
<blockquote>
</blockquote>
<pre><code>import java.util.Random;    
public class RandomQuickSort {
    public int partition(int[] a,int p,int r){
        int x = a[r];
        int i = -1;
        int temp = 0;
        for (int j = 0; j &lt; a.length-1; j++) {
            if(a[j]&lt;x){
                i=i+1;
                temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
        temp = a[i+1];
        a[i+1] = x;
        a[r] = temp;
        return i+1;
    }

    public int randompartition(int[] a,int p,int r){
        int temp = 0;
        Random random = new Random();
        int i = random.nextInt(r);
        temp = a[i];
        a[i] = a[r];
        a[r] = temp;
        return partition(a, p, r);
    }

    public int[] randomquicksort(int[] b,int p,int r){
        if(p&lt;r){
            int q = randompartition(b, p, r);
            randomquicksort(b, p, q-1);
            randomquicksort(b, q+1, r);
        }
        return b;
    }

    public static void main(String[] args) {
        RandomQuickSort sort = new RandomQuickSort();
        int[] a = {2,8,7,1,3,5,6,4};
        int[] b = sort.randomquicksort(a, 0, a.length-1);
        for (int i : b) {
            System.out.print(i+&quot; &quot;);
        }
    }
}
</code></pre></li>
<li><p>时间复杂度</p>
</li>
</ol>
<p>通过分析我们最看重的平均复杂度是nlgn</p>
<h2 id="基本排序算法"><a href="#基本排序算法" class="headerlink" title="基本排序算法"></a>基本排序算法</h2><p><img src="http://o6plzvjf2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-05%20%E4%B8%8B%E5%8D%8810.15.58.png" alt="排序"></p>
<p>小结：同等情况下快速排序&gt;随机化算法&gt;归并排序&gt;插入排序；<br>在有序的情况下随机化算法&gt;快速排序</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>慢慢走，不要急！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：算法一直很重要，最近没有心情去看项目的代码与技术，所以就拿起其了算法导论来看，最经典的快速排序及随机化算法，java实现。
    
    </summary>
    
      <category term="算法" scheme="http://bestlixiang.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法导论" scheme="http://bestlixiang.site/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="排序" scheme="http://bestlixiang.site/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>git个人使用与多人协作</title>
    <link href="http://bestlixiang.site/2017/05/04/git%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/"/>
    <id>http://bestlixiang.site/2017/05/04/git个人使用与多人协作/</id>
    <published>2017-05-04T15:52:34.000Z</published>
    <updated>2017-05-04T15:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：因为没有加入到什么团队中，没有机会和别人一起合作过项目，所以对git使用并不熟练，但是这次比较空，就好好梳理一下吧！<a id="more"></a></p>
<h1 id="个人使用"><a href="#个人使用" class="headerlink" title="个人使用"></a>个人使用</h1><h2 id="git介绍"><a href="#git介绍" class="headerlink" title="git介绍"></a>git介绍</h2><p>特点就是分布式了，请看下图，每一台电脑都是一个仓库，大家都可以使用。</p>
<p><img src="http://i4.buimg.com/1949/ae304bcf1db73902.jpg" alt="分布式"></p>
<h2 id="仓库理解及操作"><a href="#仓库理解及操作" class="headerlink" title="仓库理解及操作"></a>仓库理解及操作</h2><p>先上图：</p>
<p><img src="http://i2.muimg.com/593324/0b2d71ab51b7e2b6.jpg" alt="仓库"></p>
<p>有个上面的图做铺垫，下面的操作也就好理解了</p>
<p>添加文件：<code>git add file</code></p>
<p>提交文件：<code>git commit -m &quot;提交描述&quot;</code></p>
<p>查看状态:<code>git status</code></p>
<p>查看日志：<code>git log</code> 相关版本号可以通过reset来回退到任何提交时间点</p>
<p>添加远程库：<code>git remote add origin git@github.com:username/repository</code></p>
<p>推送到远程库： 第一次用：<code>git push -u origin master</code>之后用<code>git push origin master</code><br>注意点：要将电脑的ssh添加到你的github里</p>
<p>克隆远程库：<code>git clone origin git@github.com:username/repository</code></p>
<h1 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h1><p>我想大家需要理解这样一张图：</p>
<p><img src="http://i1.piimg.com/593324/2e66bb0030802f7f.png" alt="多人协作"></p>
<p>推送分支：<code>$ git push origin branchname</code></p>
<p>抓取分支：<code>git clone origin git@github.com:username/repository;git checkout -b dev origin/dev</code></p>
<p>基本操作肯定会碰到问题：</p>
<p>如果你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，那么就会提交被解决，这个时候就需要：</p>
<p><code>git pull</code></p>
<p>这个时候合并是有冲突的，需要你本地修改之后再提交上去。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前自己所要掌握的就是这些东西了，再遇到问题可以谷歌或者百度。<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">最后感谢廖雪峰的git教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：因为没有加入到什么团队中，没有机会和别人一起合作过项目，所以对git使用并不熟练，但是这次比较空，就好好梳理一下吧！
    
    </summary>
    
      <category term="工具" scheme="http://bestlixiang.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://bestlixiang.site/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>String,StringBuilder,StringBuffer区别</title>
    <link href="http://bestlixiang.site/2017/05/04/String-StringBuilder-StringBuffer%E5%8C%BA%E5%88%AB/"/>
    <id>http://bestlixiang.site/2017/05/04/String-StringBuilder-StringBuffer区别/</id>
    <published>2017-05-04T11:50:29.000Z</published>
    <updated>2017-05-04T12:15:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：最近心情非常的不静，我知道自己需要沉下心去沉淀，慢慢来，小朋友。今天谈谈3个字符串类<a id="more"></a></p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>查看String源码的时候，我们很容易看到<br>&gt;<br>    public final class String</p>
<p>从源码中对String的定义可以知道它是final类，这意味着她不可被继承，也不可被更改。而且总它的方法中也没有可以拼接字符串的函数。</p>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>查看StringBuilder源码的时候，我们也可以看到这样的定义：<br>&gt;<br>    public final class StringBuilder<br>    extends AbstractStringBuilder</p>
<p>我们发现他也是final类，但是它却又append()方法，这是为什么，我们找到它的append():</p>
<blockquote>
<pre><code>@Override
public StringBuilder append(String str) {
    super.append(str);
    return this;
}
</code></pre></blockquote>
<p>我们看到他的append()方法是调用他的父类来的，所以我们继续看看他的父类是在搞什么鬼👻</p>
<blockquote>
<pre><code>    public AbstractStringBuilder append(String str) {
    if (str == null)
        return appendNull();
    int len = str.length();
    ensureCapacityInternal(count + len);
    str.getChars(0, len, value, count);
    count += len;
    return this;
}
</code></pre></blockquote>
<p>我们终于找到他怎么又这个添加字符串的方法了。具体AbstractStringBuilder是怎么实现添加的就让想要了解的人继续往下看源码就好了。</p>
<p><strong>对比string:</strong> 我们可以从日常编写的代码可以了解到，用String拼接由于每次都是新建一个对象所以效率自然是低的，所以在使用字符串拼接的时候还是用StringBuilder比较好，但是对于单个常量字符串来说还是String好，因为它是放在常量池里，读取速度比放在堆中的对象自然是要快很多。</p>
<h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p>这又是一个什么鬼，继续看源码吧</p>
<blockquote>
<pre><code>public final class StringBuffer
extends AbstractStringBuilder
</code></pre></blockquote>
<p>这个和StringBuilder一样也是final类，但是我们可以很清楚的看到也是继承了AbstractStringBuilder，也就是说它也有append()方法，但是我们可以它的append()方法。</p>
<blockquote>
<pre><code>public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}
</code></pre></blockquote>
<p>我们看到它的append()方法加入了synchronized关键字，所以它是个线程安全的类</p>
<p><strong>和StringBuilder的区别：</strong> 由于他是线程安全的，所以自然牺牲了效率，在操作速度上没有StringBuilder快。</p>
<p>总结：点点滴滴积累</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：最近心情非常的不静，我知道自己需要沉下心去沉淀，慢慢来，小朋友。今天谈谈3个字符串类
    
    </summary>
    
      <category term="java基础" scheme="http://bestlixiang.site/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>请不要无脑</title>
    <link href="http://bestlixiang.site/2017/04/27/%E8%AF%B7%E4%B8%8D%E8%A6%81%E6%97%A0%E8%84%91/"/>
    <id>http://bestlixiang.site/2017/04/27/请不要无脑/</id>
    <published>2017-04-27T12:41:48.000Z</published>
    <updated>2017-04-29T01:25:22.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">大喊一声密码.</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      简单，不为人知.
    
    </summary>
    
      <category term="生活" scheme="http://bestlixiang.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>记一次失败的面试</title>
    <link href="http://bestlixiang.site/2017/04/26/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%9D%A2%E8%AF%95/"/>
    <id>http://bestlixiang.site/2017/04/26/记一次失败的面试/</id>
    <published>2017-04-26T12:41:48.000Z</published>
    <updated>2017-04-29T01:25:38.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">大喊一声密码.</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      简单，不为人知.
    
    </summary>
    
      <category term="生活" scheme="http://bestlixiang.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="面试" scheme="http://bestlixiang.site/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SSH项目初体验</title>
    <link href="http://bestlixiang.site/2017/04/24/SSH%E9%A1%B9%E7%9B%AE%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://bestlixiang.site/2017/04/24/SSH项目初体验/</id>
    <published>2017-04-24T13:41:48.000Z</published>
    <updated>2017-05-04T12:14:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：历时四天，终于在视频的帮助下完成了基于SSH（struts2+hibernate3+spring4）的一个网站商城项目，也是自己第一次采用idea开发项目简单，谈谈收获和感想。<a id="more"></a></p>
<h2 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h2><ol>
<li>导包<br>主要的文件：导三大框架的包<br>这里的包我也不贴图了，都是最基本的jar包</li>
<li>框架配置<br>这里我想说的是三个文件：<ol>
<li>web.xml：配置struts核心过滤器和配置Spring的核心监听器</li>
<li>struts.xml：配置各种action</li>
<li>applicationContext.xml：作为大管家事情也就比较多了，有配置数据库C3P0连接池，配置Hibernate引入数据源，事务管理，管理action，service，dao</li>
</ol>
</li>
<li>按层码代码</li>
</ol>
<h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><ol>
<li>web层<br>主要使用action进行控制，这里使用了动态匹配，如userAction_*.action<br>其中要点：<ol>
<li>值栈：对于单个业务逻辑来说存取值实在是太方便了。</li>
<li>模型驱动：对于模块的对象使用模型存值也很方便</li>
<li>拦截器：对于后台范围一定要对访问进行控制，若未登录，请先登录</li>
<li>ognl表达式：可以进行运算，除模型驱动以及值栈内取值之外都要加#</li>
</ol>
</li>
<li>service层<br>本次项目并未多少体现出来，我们只要注意添加spring事务注解</li>
<li>dao层<br>此次使用的hibernate，要点如下<ol>
<li>实体映射文件：对于主外键一定要设置正确，懒加载问题，级联删除问题</li>
<li>hql语句：join的用法，面向对象的语句编写</li>
</ol>
</li>
</ol>
<h2 id="项目模块"><a href="#项目模块" class="headerlink" title="项目模块"></a>项目模块</h2><p>这里只是简单说说作为一个商场应该具有的模块</p>
<ol>
<li>前台<br>首页；前台用户 ；一级目录； 二级目录； 商品； 购物车； 订单</li>
<li>后台<br>后台用户；一级目录；二级目录；商品；订单</li>
</ol>
<h2 id="查bug方法"><a href="#查bug方法" class="headerlink" title="查bug方法"></a>查bug方法</h2><p>即使是按着视频来的，但是也还是会出错，有的时候还查了一个多小时，bug：码农的一生之敌呀！<br>回到正题：首先看控制台错误，分析错误类型</p>
<ol>
<li>前台传数据错误<br>可以将表单的发送方式改为get，这个就可以从uri中看出错误了，自己好几次入坑，就是在参数填写的地方多了一个空格，欲哭无泪。</li>
<li>业务逻辑代码错误<br>其实最简单也最烦，就是利用debug。按逻辑顺序进行查错。</li>
<li>数据库查询出错<br>可以充分利用控制台输出的sql语句进行排错，将sql语句放到sql桌面程序中查询，是否与自己想要的结果一致，如果不一致，就很有可能是自己的hql语句写错，或者映射文件出错了。</li>
</ol>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>关于这个项目架构都是比较简单的，业务逻辑也都是CRUD也算简单，可能还有最重要的高并发问题没有考虑，但是整个项目做下来，自己也算理解了整个项目系统，但是自己绝对不能以CRUD为终点，继续向前加油！！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：历时四天，终于在视频的帮助下完成了基于SSH（struts2+hibernate3+spring4）的一个网站商城项目，也是自己第一次采用idea开发项目简单，谈谈收获和感想。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="ssh" scheme="http://bestlixiang.site/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>iis实现手机端访问电脑本地服务器</title>
    <link href="http://bestlixiang.site/2017/04/24/iis%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E7%AB%AF%E8%AE%BF%E9%97%AE%E7%94%B5%E8%84%91%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://bestlixiang.site/2017/04/24/iis实现手机端访问电脑本地服务器/</id>
    <published>2017-04-24T12:41:48.000Z</published>
    <updated>2017-04-29T01:19:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：对于很多没有服务器的人来说,实现手机端访问自己写的网页还是有困难的，虽然我们可以可以利用githubpage来实现挂载页面，但是调试起来还是不方便，所以iis就成为了一种简单的方式。<a id="more"></a></p>
<h2 id="iis简介"><a href="#iis简介" class="headerlink" title="iis简介"></a>iis简介</h2><p>iis（Internet Information Services）是由微软公司提供的基于运行Microsoft  Windows的互联网基本服务,其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。</p>
<h2 id="iis安装"><a href="#iis安装" class="headerlink" title="iis安装"></a>iis安装</h2><p>这里我就不多说了，网上一搜，安装教程一大把，这里推荐一个链接<a href="https://jingyan.baidu.com/article/e2284b2b3cb58ae2e6118d22.html" target="_blank" rel="external">安装iis</a></p>
<h2 id="有无线的时候使用"><a href="#有无线的时候使用" class="headerlink" title="有无线的时候使用"></a>有无线的时候使用</h2><p>大部分人，大部分时间，大部分地方，相信大家都会身处在无线之下，所以只要按照上面的链接使用就可以了。</p>
<h2 id="没无线的时候使用"><a href="#没无线的时候使用" class="headerlink" title="没无线的时候使用"></a>没无线的时候使用</h2><p>这个时候就要借助流量与热点了</p>
<ol>
<li>打开手机热点</li>
<li>查看电脑ip地址<br>一般这个时候ip地址已经变了，所有之前按照有无线的时候电脑的ip设置访问地址就有问题了，所以要利用新的ip地址设置访问地址</li>
<li>用手机访问新的ip地址<br>一下子就爽歪歪了</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>iis对于windows用户来说真是出家旅行，调试代码必备之良品。</li>
<li>当不能访问的时候一定要随时关注电脑的ip地址是否已经发生变化，做到随时更改</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：对于很多没有服务器的人来说,实现手机端访问自己写的网页还是有困难的，虽然我们可以可以利用githubpage来实现挂载页面，但是调试起来还是不方便，所以iis就成为了一种简单的方式。
    
    </summary>
    
      <category term="编程" scheme="http://bestlixiang.site/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="服务器" scheme="http://bestlixiang.site/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
</feed>
