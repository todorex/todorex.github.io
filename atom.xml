<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rex note</title>
  <subtitle>雨过，云过</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bestlixiang.site/"/>
  <updated>2018-04-12T13:10:44.000Z</updated>
  <id>http://bestlixiang.site/</id>
  
  <author>
    <name>rex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>揭秘Spring(四)_Spring设计模式</title>
    <link href="http://bestlixiang.site/2018/04/12/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Spring-%E5%9B%9B-Spring%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/04/12/深入SSM/揭秘Spring-四-Spring设计模式/</id>
    <published>2018-04-12T13:07:10.000Z</published>
    <updated>2018-04-12T13:10:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：说完了IOC和AOP（虽然可能还是不够深入，不够全面，但是对于自己还是有一定的收获，日后有新的领悟再来调整），再来说说Spring这么优秀的框架所使用的的设计模式，可谓遍地都是，我就自己看到写一下。<a id="more"></a></p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">设计模式之禅——单例模式</a>。</p>
<p>Spring应用到的单例模式可以在org.springframework.beans.factory.config.AbstractFactoryBean类中看到这个逻辑。看看它的getObject方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 如果是单例且已经初始化，就直接返回</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.isSingleton()?(<span class="keyword">this</span>.initialized?<span class="keyword">this</span>.singletonInstance:<span class="keyword">this</span>.getEarlySingletonInstance()):<span class="keyword">this</span>.createInstance();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>工厂方法模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">设计模式之禅——工厂方法模式</a>。</p>
<p>Spring应用到的工厂方法模式可以在org.springframework.beans.factory.BeanFactory类中看到这个逻辑。我们看到下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</div><div class="line">    <span class="comment">// 根据唯一标识来获得Bean对象</span></div><div class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String var1)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">设计模式之禅——抽象工厂模式</a>。</p>
<p>Spring应用到的抽象工厂模式可以在org.springframework.beans.factory.BeanFactory类中看到这个逻辑。通过它的实现，我们可以从Spring的容器访问bean。根据采用的策略，getBean方法可以返回已创建的对象（共享实例，单例作用域）或初始化新的对象（原型作用域）。在BeanFactory的实现中，我们可以区分：ClassPathXmlApplicationContext，XmlWebApplicationContext，StaticWebApplicationContext，StaticPortletApplicationContext，GenericApplicationContext，StaticApplicationContext，相当于不同的Creator。</p>
<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式之禅——建造者模式</a>。</p>
<p>Spring应用到的建造者模式可以在org.springframework.beans.factory.support.BeanDefinitionBuilder类中检索这个逻辑。这是一个允许我们以编程方式定义bean的类。BeanDefinitionBuilder包含几个方法，它们为AbstractBeanDefinition抽象类的相关实现设置值，比如作用域，工厂方法，属性等。想看看它是如何工作的，请查看以下这些方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionBuilder</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> AbstractBeanDefinition beanDefinition;</div><div class="line"></div><div class="line">  <span class="comment">// 设置Bean的父类名</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setParentName</span><span class="params">(String parentName)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.setParentName(parentName);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 设置Bean的工厂方法</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setFactoryMethod</span><span class="params">(String factoryMethod)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.setFactoryMethodName(factoryMethod);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 设置Bean的构造函数参数</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">addConstructorArgValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(</div><div class="line">                    <span class="keyword">this</span>.constructorArgIndex++, value);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 添加Bean的属性值</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">addPropertyValue</span><span class="params">(String name, Object value)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.getPropertyValues().add(name, value);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 设置Bean的初始化方法</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setInitMethodName</span><span class="params">(String methodName)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.setInitMethodName(methodName);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 返回建造好的对象</span></div><div class="line">  <span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">getBeanDefinition</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.validate();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinition;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>原型模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">设计模式之禅——原型模式</a>。</p>
<p>Spring应用到的原型模式可以在org.springframework.beans.factory.support.AbstractBeanFactory类中看到这个逻辑。它使用一种特定的原型设计模式，它先初始化bean原型作用域(克隆)。新对象基于配置文件中的bean定义。</p>
<h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><p>模板模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">设计模式之禅——模板模式</a>。</p>
<p>Spring应用到的模板模式可以在org.springframework.context.support.AbstractApplicationContext类以及它的实现类中看到这个逻辑。它的模板方法是refresh方法，而refreshBeanFactory以及getBeanFactory等方法都由子类具体实现。</p>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><p>访问者模式模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式之禅——访问者模式</a>。</p>
<p>Spring应用到的访问者模式可以在org.springframework.beans.factory.config.BeanDefinitionVisitor类中看到这个逻辑。该对象用于解析bean元数据并将其解析为String（例如：具有作用域或工厂方法名称的XML属性）或Object（例如：构造函数定义中的参数）。已解析的值在与分析的bean关联的BeanDefinition实例中进行判断设置。具体的源码请看BeanDefinitionVisitor的代码片段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionVisitor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitBeanDefinition</span><span class="params">(BeanDefinition beanDefinition)</span> </span>&#123;</div><div class="line">      visitParentName(beanDefinition);</div><div class="line">      visitBeanClassName(beanDefinition);</div><div class="line">      visitFactoryBeanName(beanDefinition);</div><div class="line">      visitFactoryMethodName(beanDefinition);</div><div class="line">      visitScope(beanDefinition);</div><div class="line">      visitPropertyValues(beanDefinition.getPropertyValues());</div><div class="line">      ConstructorArgumentValues cas = beanDefinition.</div><div class="line">        getConstructorArgumentValues();</div><div class="line">      visitIndexedArgumentValues(cas.</div><div class="line">        getIndexedArgumentValues());</div><div class="line">      visitGenericArgumentValues(cas.</div><div class="line">        getGenericArgumentValues());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">visitParentName</span><span class="params">(BeanDefinition beanDefinition)</span> </span>&#123;</div><div class="line">      String parentName = beanDefinition.getParentName();</div><div class="line">      <span class="keyword">if</span> (parentName != <span class="keyword">null</span>) &#123;</div><div class="line">        String resolvedName = resolveStringValue(parentName);</div><div class="line">        <span class="keyword">if</span> (!parentName.equals(resolvedName)) &#123;</div><div class="line">          beanDefinition.setParentName(resolvedName);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">设计模式之禅——代理模式</a>。</p>
<p>Spring应用到的代理模式可以在org.springframework.aop.framework.ProxyFactoryBean类中看到这个逻辑。详细说明可以参照上一篇文章。</p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">设计模式之禅——策略模式</a>。</p>
<p>Spring应用到的策略模式可以在org.springframework.aop.framework.DefaultAopProxyFactory类中看到这个逻辑。看一下这个类的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !<span class="keyword">this</span>.hasNoUserSuppliedProxyInterfaces(config)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</div><div class="line">            <span class="keyword">if</span>(targetClass == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: Either an interface or a target is required for proxy creation."</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 根据目标类是否有接口而采取不同的策略</span></div><div class="line">                <span class="keyword">return</span> (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass)?<span class="keyword">new</span> ObjenesisCglibAopProxy(config):<span class="keyword">new</span> JdkDynamicAopProxy(config));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>适配器模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">设计模式之禅——适配器模式</a>。</p>
<p>Spring应用到的适配器模式可以在org.springframework.aop.framework.adapter.DefaultAdvisorAdapterRegistry类中看到这个逻辑，Spring需要将每个Advice（通知）都封装成对应的拦截器类型，返回给容器，所以需要使用适配器模式对Advice进行转换。下面我们看看具体的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Adaptee</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">BeforeAdvice</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable</span>;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Target</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvisorAdapter</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span></span>;  </div><div class="line"></div><div class="line">    <span class="function">MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span></span>;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Adapter</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceAdapter</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapter</span>, <span class="title">Serializable</span> </span>&#123;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> (advice <span class="keyword">instanceof</span> MethodBeforeAdvice);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;  </div><div class="line">        MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodBeforeAdviceInterceptor(advice);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式之禅——观察者模式</a>。</p>
<p>Spring应用到的观察者模式可以应用程序上下文相关的事件传输看到这个逻辑，具体一点在AbstractApplicationContext与org.springframework.context.ApplicationListener以及org.springframework.context.event.ApplicationEventMulticaster中看到，我们可以看到下面的相关代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span>, <span class="title">DisposableBean</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义传播者，用来传播消息</span></div><div class="line">    <span class="keyword">private</span> ApplicationEventMulticaster applicationEventMulticaster;</div><div class="line">    <span class="comment">// 注册监听者</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationEventMulticaster</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addApplicationListenerBean</span><span class="params">(String var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeApplicationListenerBean</span><span class="params">(String var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeAllListeners</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(ApplicationEvent var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(ApplicationEvent var1, ResolvableType var2)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><p>解释器模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/">设计模式之禅——解释器模式</a>。</p>
<p>Spring应用到的解释器模式主要以Spring Expression Language（SpEL）为例。SpEL是一种由Spring的org.springframework.expression.ExpressionParser实现分析和执行的语言。这些实现使用作为字符串给出的Spel表达式，并将它们转换为org.springframework.expression.Expression的实例。上下文组件由org.springframework.expression.EvaluationContext实现表示，例如：StandardEvaluationContext。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>参考了超级多，都快忘了，各位大佬不要介意！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：说完了IOC和AOP（虽然可能还是不够深入，不够全面，但是对于自己还是有一定的收获，日后有新的领悟再来调整），再来说说Spring这么优秀的框架所使用的的设计模式，可谓遍地都是，我就自己看到写一下。
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Spring" scheme="http://bestlixiang.site/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Centos7利用Nginx配置HTTPS</title>
    <link href="http://bestlixiang.site/2018/04/12/%E5%B7%A5%E5%85%B7/Centos7%E5%88%A9%E7%94%A8Nginx%E9%85%8D%E7%BD%AEHTTPS/"/>
    <id>http://bestlixiang.site/2018/04/12/工具/Centos7利用Nginx配置HTTPS/</id>
    <published>2018-04-12T08:53:31.000Z</published>
    <updated>2018-04-12T08:54:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：最近在做一个微信小程序项目，坑爹的小程序不仅需要https协议，而且还要是80端口才能访问后台，这里总结一下Nginx的安装过程与HTTPS的配置。<a id="more"></a></p>
<h1 id="Ngnix的安装"><a href="#Ngnix的安装" class="headerlink" title="Ngnix的安装"></a>Ngnix的安装</h1><p>由于后面Nginx需要添加模块，所以我们采用<strong>源码安装</strong>，具体安装方法可以参考 <a href="http://bestlixiang.site/2018/04/08/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/">走进Linux_软件安装</a> 中的源码安装一节。</p>
<p>这里需要注意的我们在 <strong>产生makefile文件的时候</strong> 需要加一些configure arguments，以便安装相关模块。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module</div></pre></td></tr></table></figure></p>
<p>安装完之后可以利用下面的命令查看Ngnix版本及其编译参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/usr/local/nginx/sbin/nginx -V</div><div class="line"></div><div class="line">// 输出如下结果就是对的</div><div class="line">nginx version: nginx/1.11.6</div><div class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC)</div><div class="line">built with OpenSSL 1.0.2k-fips  26 Jan 2017</div><div class="line">TLS SNI support enabled</div><div class="line">configure arguments: --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module</div></pre></td></tr></table></figure></p>
<p>然后我们测试新的nginx程序是否正确：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/usr/local/nginx/sbin/nginx -t</div><div class="line"></div><div class="line">// 输出如下结果J就表面安装成功</div><div class="line">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</div><div class="line">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</div></pre></td></tr></table></figure></p>
<h1 id="配置HTTPS"><a href="#配置HTTPS" class="headerlink" title="配置HTTPS"></a>配置HTTPS</h1><h2 id="SSL证书申请"><a href="#SSL证书申请" class="headerlink" title="SSL证书申请"></a>SSL证书申请</h2><p>SSL证书遵守 SSL（Secure Sockets Layer 安全套接层）协议，由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能，也就是说你想要使用https就需要拥有SSL证书。</p>
<p>这里我们使用openssl证书来举例，<a href="https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=10_4" target="_blank" rel="external">微信小程序官网也是使用openssl来进行HTTPS服务器配置</a>。</p>
<ol>
<li><p>生成私钥</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 进入nginx的安装目录</div><div class="line">cd /usr/local/nginx</div><div class="line"></div><div class="line">// 创建一个存放私钥的文件夹（自定义）</div><div class="line">mkdir key</div><div class="line"></div><div class="line">// 进入key文件夹</div><div class="line">cd key</div><div class="line"></div><div class="line">// 生成私钥</div><div class="line">openssl genrsa -out server.key 2048</div></pre></td></tr></table></figure>
</li>
<li><p>生成csr文件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// CSR 是Certificate Signing Request的缩写，即证书签名请求，</div><div class="line">// 这不是证书，可以简单理解成公钥，生成证书时要把这个提交给权威的证书颁发机构。</div><div class="line"></div><div class="line"></div><div class="line">// 生成csr文件</div><div class="line">openssl req -new -key server.key -out certreq.csr</div><div class="line"></div><div class="line">// 输入上面的命令后会要求你输入一些信息：</div><div class="line">Country Name： CN        //您所在国家的ISO标准代号，中国为CN</div><div class="line">State or Province Name：guandong //您单位所在地省/自治区/直辖市</div><div class="line">Locality Name：shenzhen      //您单位所在地的市/县/区</div><div class="line">Organization Name： Tencent Technology (Shenzhen) Company Limited    //您单位/机构/企业合法的名称</div><div class="line">Organizational Unit Name： R&amp;D         //部门名称</div><div class="line">Common Name： www.example.com     //通用名，网站域名。此项必须与您访问提供SSL服务的服务器时所应用的域名完全匹配。</div><div class="line">Email Address：      //您的邮件地址，不必输入，直接回车跳过</div><div class="line">&quot;extra&quot;attributes  // 以下信息不必输入，回车跳过直到命令执行完毕。</div></pre></td></tr></table></figure>
</li>
<li><p>生成crt证书</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// CRT 即 certificate的缩写，即证书。</div><div class="line">openssl x509 -req -days 365 -in certreq.csr -signkey server.key -out certreq.crt</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Nginx配置SSL加密"><a href="#Nginx配置SSL加密" class="headerlink" title="Nginx配置SSL加密"></a>Nginx配置SSL加密</h2><p>想要https就要监听443端口，nginx.conf已经预留出了server，只要我们把注释去掉开启即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 编辑Ngnix配置文件</div><div class="line">vim /usr/local/nginx/conf/nginx.conf</div><div class="line"></div><div class="line">// 修改监听443端口的Server，使其如下：</div><div class="line">server &#123;</div><div class="line">    listen 443 ssl;</div><div class="line">    server_name www.example.com;</div><div class="line">    ssl on;</div><div class="line">    # ssl_certificate证书其实是个公钥，它会被发送到连接服务器的每个客户端</div><div class="line">    ssl_certificate /usr/local/nginx/key/certreq.crt;</div><div class="line">    # ssl_certificate_key私钥是用来解密的，所以它的权限要得到保护但nginx的主进程能够读取</div><div class="line">    ssl_certificate_key /usr/local/nginx/key/server.key;</div><div class="line">    ssl_session_timeout  5m;</div><div class="line">    # 指定SSL服务器端支持的协议版本</div><div class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">    # 选择加密算法</div><div class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</div><div class="line">    # ssl_ciphers  ALL：!ADH：!EXPORT56：RC4+RSA：+HIGH：+MEDIUM：+LOW：+SSLv2：+EXP;</div><div class="line">    # 在使用SSLv3和TLS协议时指定服务器的加密算法要优先于客户端的加密算法</div><div class="line">    ssl_prefer_server_ciphers   on;</div><div class="line">    # 虽然我们要使用HTTPS，但是服务器的程序接收的还是HTTP，所以要做个反向代理</div><div class="line">    location /&#123;</div><div class="line">        proxy_pass http://localhost:8080;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>这样虽然可以利用https来访问我们的ip，但是对于浏览器还是不受信任的。</strong></p>
<h2 id="导入证书"><a href="#导入证书" class="headerlink" title="导入证书"></a>导入证书</h2><p>如果你是找一个知名的SSL证书颁发机构如VeriSign、Wosign、StartSSL签发的证书，<strong>并且浏览器已经内置并信任了这些根证书</strong>，如果你是自建证书（向我们刚才那样）或获得二级证书授权，那么就<strong>需要将证书添加到浏览器</strong>，这样在访问站点时才不会显示不安全连接。<strong>不够买证书微信小程序会不支持。</strong> 证书生成的方法有很多，这里说两种：</p>
<ol>
<li><p>购买阿里云的免费证书</p>
</li>
<li><p>购买<a href="http://note.youdao.com/" target="_blank" rel="external">GETSSL官网</a>证书</p>
</li>
</ol>
<p>购买好证书并下载后（可以将证书和私钥放到之前的key目录）需要从新配置nginx.conf文件，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 443 ssl;</div><div class="line">    server_name www.example.com;</div><div class="line">    ssl on;</div><div class="line">    # pem是crt的一种，内容是BASE64编码，Apache和*NIX服务器偏向于使用这种编码格式</div><div class="line">    ssl_certificate /usr/local/nginx/key/*.pem;</div><div class="line">    ssl_certificate_key /usr/local/nginx/key/*.key;</div><div class="line">    ssl_session_timeout  5m;</div><div class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</div><div class="line">    ssl_prefer_server_ciphers   on;</div><div class="line">    location /&#123;</div><div class="line">        proxy_pass http://localhost:8080;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/w410589502/article/details/72833283" target="_blank" rel="external"> linux nginx配置https</a></li>
<li><a href="https://www.cnblogs.com/yjmyzz/p/openssl-tutorial.html" target="_blank" rel="external">openssl、x509、crt、cer、key、csr、ssl、tls 这些都是什么鬼?</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：最近在做一个微信小程序项目，坑爹的小程序不仅需要https协议，而且还要是80端口才能访问后台，这里总结一下Nginx的安装过程与HTTPS的配置。
    
    </summary>
    
      <category term="工具" scheme="http://bestlixiang.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
      <category term="HTTPS" scheme="http://bestlixiang.site/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Spring(三)_Spring之AOP</title>
    <link href="http://bestlixiang.site/2018/04/11/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Spring-%E4%B8%89-Spring%E4%B9%8BAOP/"/>
    <id>http://bestlixiang.site/2018/04/11/深入SSM/揭秘Spring-三-Spring之AOP/</id>
    <published>2018-04-11T13:21:34.000Z</published>
    <updated>2018-04-11T13:47:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：前一节讲到Spring的核心概念IOC，那么就不能不提到Spring的另一个核心概念AOP，我们先是先讲一下它的概念与原理实现，然后在讲Spring中AOP的实现。<a id="more"></a></p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="AOP思想"><a href="#AOP思想" class="headerlink" title="AOP思想"></a>AOP思想</h2><p>AOP（Aspect Oriented Programming的缩写，意为：面向切面编程）是对OOP的一种补充。</p>
<ul>
<li>面向对象(OOP)引入了继承、多态、封装，将系统的业务功能按照模块划分，每个模块用一个或多个类来表示。<strong>而对于一些系统功能，无法使用OOP的思想来实现它们。这些系统功能往往穿插在业务功能的各处，和业务代码耦合在一起；而且系统功能往往会被重复使用，这就导致了模块不利于复用，这就是使用OOP实现系统功能的弊端。</strong></li>
<li>AOP即为面向切面编程，它把系统需求按照功能分门归类，把它们封装在一个个切面中，然后再指定这些系统功能往业务功能，主要应用于权限认证、日志，事务等。</li>
</ul>
<p>它的主要是好处如下：</p>
<ul>
<li><p>降低模块之间的耦合度</p>
</li>
<li><p>使系统容易扩展</p>
</li>
<li><p>更好的代码复用。</p>
</li>
</ul>
<h2 id="AOP实现原理"><a href="#AOP实现原理" class="headerlink" title="AOP实现原理"></a>AOP实现原理</h2><p>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。而Spring采用的是动态代理技术，关于动态代理的实现可以参照自己之前的博客 <a href="http://bestlixiang.site/2018/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">设计模式之禅——代理模式</a>一文中的动态代理这一节去了解。</p>
<h1 id="SpringAOP实现"><a href="#SpringAOP实现" class="headerlink" title="SpringAOP实现"></a>SpringAOP实现</h1><p>Spring的AOP实现遵守AOP联盟的约定。同时Spring又扩展了它，增加了Pointcut、Advisor等一些接口使得其更加灵活。</p>
<h2 id="Spring-AOP的基本概念"><a href="#Spring-AOP的基本概念" class="headerlink" title="Spring AOP的基本概念"></a>Spring AOP的基本概念</h2><ul>
<li>切面（Aspect）：类似于OOP中的Class，一个Aspect存放一个系统功能的所有逻辑。切面用Spring的 Advisor或拦截器实现。</li>
<li>连接点（Joinpoint）：程序执行过程中的某一事件，如方法被调用时、抛出异常时。</li>
<li>切入点（Pointcut）：指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上。</li>
<li>引入（Introduction）: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口。</li>
<li>目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象（POJO）。</li>
<li>AOP代理（AOP Proxy）: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</li>
<li>织入（Weaving）: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</li>
<li>通知（Advice）：具体的横切逻辑；Spring中有五种Advice：<ul>
<li>前置通知（Before Advice）</li>
<li>后置通知（After Advice）</li>
<li>返回通知（After Return Advice）</li>
<li>环绕通知（Around Advice）</li>
<li>抛出异常后通知（After Throwing Advice）</li>
</ul>
</li>
</ul>
<h2 id="SpringAOP动态代理"><a href="#SpringAOP动态代理" class="headerlink" title="SpringAOP动态代理"></a>SpringAOP动态代理</h2><p>Spring AOP中使用了两种动态代理，一种是JDK的动态代理，一种CGLIB的动态代理。JDK的动态代理必须指定接口，这些接口都是已经被代理对象实现了的；而CGLIB代理则不需要指定接口。</p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>如果被代理对象实现了需要被代理的接口，则使用JDK的动态代理。我们一步步来看这个过程：</p>
<ol>
<li><p>首先明确我们使要生成一个代理，而Spring的内部机制是由FactoryBean的getObject方法来产生的，所以我们会一步步debug到这个方法行（在FactoryBeanRegistrySupport类的doGetObjectFromFactoryBean中），我们看看这个方法的源代码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    <span class="comment">// 初始化通知器链，为代理对象配置通知器链。</span></div><div class="line">    <span class="keyword">this</span>.initializeAdvisorChain();</div><div class="line">    <span class="comment">//区分SingleTon和ProtoType，生成对应的Proxy</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.isSingleton()) &#123;</div><div class="line">    <span class="comment">// 只有SingleTon的Bean才会一开始就初始化，ProtoType的只有在请求的时候才会初始化，代理也一样</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getSingletonInstance();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.logger.warn(<span class="string">"Using non-singleton proxies with singleton targets is often undesirable. Enable prototype proxies by setting the 'targetName' property."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.newPrototypeInstance();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>到达getObject方法后，我们需要去看看它是怎么初始化通知链的就是initializeAdvisorChain的代码：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initializeAdvisorChain</span><span class="params">()</span> <span class="keyword">throws</span> AopConfigException, BeansException </span>&#123;</div><div class="line">    <span class="comment">// 初始化过程的标志位advisorChainInitialized，这个标志用来表示通知器链是否已经初始化。</span></div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.advisorChainInitialized) &#123;</div><div class="line">        <span class="keyword">if</span>(!ObjectUtils.isEmpty(<span class="keyword">this</span>.interceptorNames)) &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.beanFactory == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No BeanFactory available anymore (probably due to serialization) - cannot resolve interceptor names "</span> + Arrays.asList(<span class="keyword">this</span>.interceptorNames));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.interceptorNames[<span class="keyword">this</span>.interceptorNames.length - <span class="number">1</span>].endsWith(<span class="string">"*"</span>) &amp;&amp; <span class="keyword">this</span>.targetName == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSource == EMPTY_TARGET_SOURCE) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Target required after globals"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            String[] var1 = <span class="keyword">this</span>.interceptorNames;</div><div class="line">            <span class="keyword">int</span> var2 = var1.length;</div><div class="line"></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</div><div class="line">                String name = var1[var3];</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</div><div class="line">                    <span class="keyword">this</span>.logger.trace(<span class="string">"Configuring advisor or advice '"</span> + name + <span class="string">"'"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(name.endsWith(<span class="string">"*"</span>)) &#123;</div><div class="line">                    <span class="keyword">if</span>(!(<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ListableBeanFactory)) &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Can only use global advisors or interceptors with a ListableBeanFactory"</span>);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">this</span>.addGlobalAdvisor((ListableBeanFactory)<span class="keyword">this</span>.beanFactory, name.substring(<span class="number">0</span>, name.length() - <span class="string">"*"</span>.length()));</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    Object advice;</div><div class="line">                    <span class="keyword">if</span>(!<span class="keyword">this</span>.singleton &amp;&amp; !<span class="keyword">this</span>.beanFactory.isSingleton(name)) &#123;</div><div class="line">                        advice = <span class="keyword">new</span> ProxyFactoryBean.PrototypePlaceholderAdvisor(name);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        advice = <span class="keyword">this</span>.beanFactory.getBean(name);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">this</span>.addAdvisorOnChainCreation(advice, name);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.advisorChainInitialized = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  初始化只是在应用第一次通过ProxyFactoryBean获取代理对象的时候。完成这个初始化之后，接着会读取配置中出现的所有通知器（把通知器的名字交给容器的getBean，IOC容器的回调获取通知器），把通知器加入拦截器链（addAdvisoronChainCreation实现）。</p>
</li>
<li><p>生成代理对象，利用ProxyFactoryBean的getSingletonInstance方法，源码如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Object <span class="title">getSingletonInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.singletonInstance == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//这里会调用getBean，获取被代理对象</span></div><div class="line">        <span class="keyword">this</span>.targetSource = <span class="keyword">this</span>.freshTargetSource();</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.autodetectInterfaces &amp;&amp; <span class="keyword">this</span>.getProxiedInterfaces().length == <span class="number">0</span> &amp;&amp; !<span class="keyword">this</span>.isProxyTargetClass()) &#123;</div><div class="line">            <span class="comment">// 根据 AOP 框架判断需要代理的接口</span></div><div class="line">            Class&lt;?&gt; targetClass = <span class="keyword">this</span>.getTargetClass();</div><div class="line">            <span class="keyword">if</span>(targetClass == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FactoryBeanNotInitializedException(<span class="string">"Cannot determine target class for proxy"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//这里是设置代理对象的接口</span></div><div class="line">            <span class="keyword">this</span>.setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, <span class="keyword">this</span>.proxyClassLoader));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>.setFrozen(<span class="keyword">this</span>.freezeProxy);</div><div class="line">        <span class="comment">//这里方法会使用ProxyFactory生成需要的Proxy</span></div><div class="line">        <span class="keyword">this</span>.singletonInstance = <span class="keyword">this</span>.getProxy(<span class="keyword">this</span>.createAopProxy());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.singletonInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>进入ProxyCreatorSupport的createAopProxy，源码如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</div><div class="line">    activate();</div><div class="line">&#125;</div><div class="line"><span class="comment">//通过AopProxyFactory取得AopProxy，AopProxyFactory是在初始化函数中定义的，使用的是DefaultAopProxyFactory</span></div><div class="line"><span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>那么DefaultAopProxyFactory如何生成AopProxy了，这里有两种方式，JdkDynamicAopProxy和CglibProxyFactory,DefaultAopProxyFactory的createAopProxy的源码如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</div><div class="line">            <span class="comment">//获取配置的目标对象</span></div><div class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</div><div class="line">            <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//如果没有目标对象，抛出异常，提醒AOP应用提供正确的目标配置</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</div><div class="line">                        <span class="string">"Either an interface or a target is required for proxy creation."</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 这个判断很重要，通过目标类是否是接口来决定采用什么代理方式</span></div><div class="line">            <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//由于CGLIB是一个第三方类库，所以需要在CLASSPATH中配置</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>由于我们这里目标类是接口，所以采用JdkDynamicAopProxy 生成AopProxy代理对象，我们可以看一下JdkDynamicAopProxy的invoke方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">       Object oldProxy = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</div><div class="line">       TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</div><div class="line">       Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</div><div class="line">       Object target = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">       Object var13;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">if</span>(!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</div><div class="line">               Boolean var20 = Boolean.valueOf(<span class="keyword">this</span>.equals(args[<span class="number">0</span>]));</div><div class="line">               <span class="keyword">return</span> var20;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span>(!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</div><div class="line">               Integer var18 = Integer.valueOf(<span class="keyword">this</span>.hashCode());</div><div class="line">               <span class="keyword">return</span> var18;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">if</span>(method.getDeclaringClass() == DecoratingProxy.class) &#123;</div><div class="line">               Class var17 = AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</div><div class="line">               <span class="keyword">return</span> var17;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           Object retVal;</div><div class="line"></div><div class="line">           <span class="comment">// Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知</span></div><div class="line">           <span class="keyword">if</span>(!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</div><div class="line">               retVal = AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</div><div class="line">               <span class="keyword">return</span> retVal;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">if</span>(<span class="keyword">this</span>.advised.exposeProxy) &#123;</div><div class="line">               oldProxy = AopContext.setCurrentProxy(proxy);</div><div class="line">               setProxyContext = <span class="keyword">true</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">//获得目标对象的类</span></div><div class="line">           target = targetSource.getTarget();</div><div class="line">           <span class="keyword">if</span>(target != <span class="keyword">null</span>) &#123;</div><div class="line">               targetClass = target.getClass();</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 获得拦截链</span></div><div class="line">           List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</div><div class="line">           <span class="comment">// 如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)</span></div><div class="line">           <span class="keyword">if</span>(chain.isEmpty()) &#123;</div><div class="line">               Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</div><div class="line">               retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="comment">//创建MethodInvocation</span></div><div class="line">               MethodInvocation invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</div><div class="line">               <span class="comment">// 处理通知</span></div><div class="line">               retVal = invocation.proceed();</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           Class&lt;?&gt; returnType = method.getReturnType();</div><div class="line">           <span class="keyword">if</span>(retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp; returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp; !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</div><div class="line">               retVal = proxy;</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           var13 = retVal;</div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           <span class="keyword">if</span>(target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</div><div class="line">               targetSource.releaseTarget(target);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">if</span>(setProxyContext) &#123;</div><div class="line">               AopContext.setCurrentProxy(oldProxy);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> var13;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>如果被代理对象没有实现需要被代理的接口，则使用CGLIB动态代理，CGLIB动态代理按照前面的分析基本与JDK动态代理一样，由于在Spring AOP中对应的包装类为CglibAopProxy，CglibAopProxy的intercept回调方法的实现和JdkDynamicAopProxy的回调实现是非常类似的，只是在CglibAopProxy中构造的是CglibMethodInvocation对象来完成拦截器链的调用，这里看一下与invoke类似的getCallbacks源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Callback[] getCallbacks(Class&lt;?&gt; rootClass) <span class="keyword">throws</span> Exception &#123;</div><div class="line">    <span class="keyword">boolean</span> exposeProxy = <span class="keyword">this</span>.advised.isExposeProxy();</div><div class="line">    <span class="keyword">boolean</span> isFrozen = <span class="keyword">this</span>.advised.isFrozen();</div><div class="line">    <span class="keyword">boolean</span> isStatic = <span class="keyword">this</span>.advised.getTargetSource().isStatic();</div><div class="line">    Callback aopInterceptor = <span class="keyword">new</span> CglibAopProxy.DynamicAdvisedInterceptor(<span class="keyword">this</span>.advised);</div><div class="line">    Object targetInterceptor;</div><div class="line">    <span class="keyword">if</span>(exposeProxy) &#123;</div><div class="line">        targetInterceptor = isStatic?<span class="keyword">new</span> CglibAopProxy.StaticUnadvisedExposedInterceptor(<span class="keyword">this</span>.advised.getTargetSource().getTarget()):<span class="keyword">new</span> CglibAopProxy.DynamicUnadvisedExposedInterceptor(<span class="keyword">this</span>.advised.getTargetSource());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        targetInterceptor = isStatic?<span class="keyword">new</span> CglibAopProxy.StaticUnadvisedInterceptor(<span class="keyword">this</span>.advised.getTargetSource().getTarget()):<span class="keyword">new</span> CglibAopProxy.DynamicUnadvisedInterceptor(<span class="keyword">this</span>.advised.getTargetSource());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Callback targetDispatcher = (Callback)(isStatic?<span class="keyword">new</span> CglibAopProxy.StaticDispatcher(<span class="keyword">this</span>.advised.getTargetSource().getTarget()):<span class="keyword">new</span> CglibAopProxy.SerializableNoOp());</div><div class="line">    Callback[] mainCallbacks = <span class="keyword">new</span> Callback[]&#123;aopInterceptor, (Callback)targetInterceptor, <span class="keyword">new</span> CglibAopProxy.SerializableNoOp(), targetDispatcher, <span class="keyword">this</span>.advisedDispatcher, <span class="keyword">new</span> CglibAopProxy.EqualsInterceptor(<span class="keyword">this</span>.advised), <span class="keyword">new</span> CglibAopProxy.HashCodeInterceptor(<span class="keyword">this</span>.advised)&#125;;</div><div class="line">    Callback[] callbacks;</div><div class="line">    <span class="keyword">if</span>(isStatic &amp;&amp; isFrozen) &#123;</div><div class="line">        Method[] methods = rootClass.getMethods();</div><div class="line">        Callback[] fixedCallbacks = <span class="keyword">new</span> Callback[methods.length];</div><div class="line">        <span class="keyword">this</span>.fixedInterceptorMap = <span class="keyword">new</span> HashMap(methods.length);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; methods.length; ++x) &#123;</div><div class="line">            <span class="comment">// 获得拦截链</span></div><div class="line">            List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(methods[x], rootClass);</div><div class="line">            <span class="comment">// 准备处理通知</span></div><div class="line">            fixedCallbacks[x] = <span class="keyword">new</span> CglibAopProxy.FixedChainStaticTargetInterceptor(chain, <span class="keyword">this</span>.advised.getTargetSource().getTarget(), <span class="keyword">this</span>.advised.getTargetClass());</div><div class="line">            <span class="keyword">this</span>.fixedInterceptorMap.put(methods[x].toString(), Integer.valueOf(x));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        callbacks = <span class="keyword">new</span> Callback[mainCallbacks.length + fixedCallbacks.length];</div><div class="line">        System.arraycopy(mainCallbacks, <span class="number">0</span>, callbacks, <span class="number">0</span>, mainCallbacks.length);</div><div class="line">        System.arraycopy(fixedCallbacks, <span class="number">0</span>, callbacks, mainCallbacks.length, fixedCallbacks.length);</div><div class="line">        <span class="keyword">this</span>.fixedInterceptorOffset = mainCallbacks.length;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        callbacks = mainCallbacks;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> callbacks;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/u010425776/article/details/59112466" target="_blank" rel="external"> 深入剖析Spring(四)——AOP</a></li>
<li><a href="https://blog.csdn.net/zly9923218/article/details/51348583" target="_blank" rel="external">Spring AOP源码分析（生成代理对象）</a></li>
<li><a href="https://blog.csdn.net/zhangliangzi/article/details/52334964" target="_blank" rel="external">Spring AOP四种实现方式Demo详解与相关知识探究</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前一节讲到Spring的核心概念IOC，那么就不能不提到Spring的另一个核心概念AOP，我们先是先讲一下它的概念与原理实现，然后在讲Spring中AOP的实现。
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Spring" scheme="http://bestlixiang.site/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Spring(二)_Spring之IOC</title>
    <link href="http://bestlixiang.site/2018/04/11/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Spring(%E4%BA%8C)_Spring%E4%B9%8BIOC/"/>
    <id>http://bestlixiang.site/2018/04/11/深入SSM/揭秘Spring(二)_Spring之IOC/</id>
    <published>2018-04-11T02:26:40.000Z</published>
    <updated>2018-04-11T02:29:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：前一篇文章我们介绍了Spring的整体架构以及核心组件，接下来我们将讲解Spring的核心概念之一IOC，我们将先简单介绍IOC与DI，然后再深入SpringIOC容器的工作流程。<a id="more"></a></p>
<h1 id="IOC与DI"><a href="#IOC与DI" class="headerlink" title="IOC与DI"></a>IOC与DI</h1><p>IoC和DI是Spring的两个核心概念，很多人都把它们视为相同的东西（之前自己也一直这样认为），<strong>但事实并非如此</strong>。</p>
<ul>
<li>IoC(Inversion of Control)：控制反转。</li>
<li>DI(Dependency Injection)：依赖注入</li>
</ul>
<p><strong>开始画重点了：</strong> 控制反转是<strong>目的</strong>，依赖注入是实现控制反转的<strong>手段</strong>。</p>
<p>控制反转是一种设计模式思想，它是一种宽泛的概念，只要一个类将对它内部状态的控制权交由其他机制去完成即为控制反转。控制反转是为了降低类与类之间的耦合度。而Spring采用依赖注入这一具体的手段来达到控制反转的目的。</p>
<p>关于依赖注入可以看我之前的文章<a href="http://bestlixiang.site/2018/02/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%88%E5%90%B9%E5%93%8D%E5%8F%A3%E5%8F%B7-6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">先吹响口号_6大设计原则</a>中的依赖倒置原则 DIP一节，这里就不做过多的介绍了。</p>
<h1 id="IOC容器工作流程"><a href="#IOC容器工作流程" class="headerlink" title="IOC容器工作流程"></a>IOC容器工作流程</h1><p>IOC容器实际上就是 Context 组件结合其他Bean和Core组件共同构建了一个 Bean 关系网，如何构建这个关系网？构建的入口就在 AbstractApplicationContext 类的 refresh 方法中。这个方法的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</div><div class="line">        Object var1 = <span class="keyword">this</span>.startupShutdownMonitor;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</div><div class="line">            <span class="comment">// 为刷新准备新的context</span></div><div class="line">            <span class="keyword">this</span>.prepareRefresh();</div><div class="line">            <span class="comment">// **创建BeanFactory**</span></div><div class="line">            ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</div><div class="line">            <span class="comment">// 刷新所有BeanFactory子容器</span></div><div class="line">            <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 注册实现了BeanPostProcessor接口的bean（AOP使用）</span></div><div class="line">                <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</div><div class="line">                <span class="comment">// 初始化和执行BeanFactoryPostProcessor beans</span></div><div class="line">                <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</div><div class="line">                <span class="comment">// 初始化和执行BeanPostProcessors beans</span></div><div class="line">                <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</div><div class="line">                <span class="comment">// 初始化MessageSource</span></div><div class="line">                <span class="keyword">this</span>.initMessageSource();</div><div class="line">                <span class="comment">// 初始化 event multicaster （多路广播）</span></div><div class="line">                <span class="keyword">this</span>.initApplicationEventMulticaster();</div><div class="line">                <span class="comment">// 刷新由子类实现的方法</span></div><div class="line">                <span class="keyword">this</span>.onRefresh();</div><div class="line">                <span class="comment">// 注册事件</span></div><div class="line">                <span class="keyword">this</span>.registerListeners();</div><div class="line">                <span class="comment">// 初始化单例Bean</span></div><div class="line">                <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</div><div class="line">                <span class="comment">// 发布相应的事件</span></div><div class="line">                <span class="keyword">this</span>.finishRefresh();</div><div class="line">            &#125; <span class="keyword">catch</span> (BeansException var9) &#123;</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</div><div class="line">                    <span class="keyword">this</span>.logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> + var9);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 销毁beans</span></div><div class="line">                <span class="keyword">this</span>.destroyBeans();</div><div class="line">                <span class="keyword">this</span>.cancelRefresh(var9);</div><div class="line">                <span class="keyword">throw</span> var9;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">this</span>.resetCommonCaches();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这个方法就是构建整个IOC容器过程的完整的代码，了解了里面的每一行代码基本上就了解大部分 Spring 的原理和功能了。</p>
<p>这段代码主要包含这样几个步骤：</p>
<ul>
<li>构建 BeanFactory</li>
<li>注册可能感兴趣的事件</li>
<li>创建 Bean 实例对象</li>
<li>触发被监听的事件</li>
</ul>
<p>其中我们我们最关心的就是BeanFactory和创建Bean实例对象了，我们下面可以好好看看：</p>
<h2 id="创建BeanFactory工厂"><a href="#创建BeanFactory工厂" class="headerlink" title="创建BeanFactory工厂"></a>创建BeanFactory工厂</h2><p>我们利用debug可以进入到refresh()方法里面的obtainFreshBeanFactory()方法里面的refreshBeanFactory() <strong>（有点绕，但是自己就不画时序图了）</strong> 去看看他的创建代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.hasBeanFactory()) &#123;</div><div class="line">            <span class="keyword">this</span>.destroyBeans();</div><div class="line">            <span class="keyword">this</span>.closeBeanFactory();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 创建一个DefaultListableBeanFactory（上一节说过的很重要的类）</span></div><div class="line">            DefaultListableBeanFactory beanFactory = <span class="keyword">this</span>.createBeanFactory();</div><div class="line">            beanFactory.setSerializationId(<span class="keyword">this</span>.getId());</div><div class="line">            <span class="keyword">this</span>.customizeBeanFactory(beanFactory);</div><div class="line">            <span class="comment">// **这个方法会加载、解析Bean的定义**</span></div><div class="line">            <span class="keyword">this</span>.loadBeanDefinitions(beanFactory);</div><div class="line">            Object var2 = <span class="keyword">this</span>.beanFactoryMonitor;</div><div class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.beanFactoryMonitor) &#123;</div><div class="line">                <span class="keyword">this</span>.beanFactory = beanFactory;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException var5) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + <span class="keyword">this</span>.getDisplayName(), var5);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="创建Bean实例并构建Bean的关系网"><a href="#创建Bean实例并构建Bean的关系网" class="headerlink" title="创建Bean实例并构建Bean的关系网"></a>创建Bean实例并构建Bean的关系网</h2><p>我们利用debug可以进入到refresh()方法里面的finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory)方法里面的preInstantiateSingletons() <strong>（有点绕，但是自己就不画时序图了）</strong> 去看看它的创建Bean的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</div><div class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList(<span class="keyword">this</span>.beanDefinitionNames);</div><div class="line">        Iterator var2 = beanNames.iterator();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">                String beanName;</div><div class="line">                RootBeanDefinition bd;</div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        <span class="keyword">do</span> &#123;</div><div class="line">                            <span class="keyword">if</span>(!var2.hasNext()) &#123;</div><div class="line">                                var2 = beanNames.iterator();</div><div class="line"></div><div class="line">                                <span class="keyword">while</span>(var2.hasNext()) &#123;</div><div class="line">                                    beanName = (String)var2.next();</div><div class="line">                                    Object singletonInstance = <span class="keyword">this</span>.getSingleton(beanName);</div><div class="line">                                    <span class="keyword">if</span>(singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</div><div class="line">                                        <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;</div><div class="line">                                        <span class="keyword">if</span>(System.getSecurityManager() != <span class="keyword">null</span>) &#123;</div><div class="line">                                            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</div><div class="line">                                                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                                                    smartSingleton.afterSingletonsInstantiated();</div><div class="line">                                                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                                                &#125;</div><div class="line">                                            &#125;, <span class="keyword">this</span>.getAccessControlContext());</div><div class="line">                                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                            smartSingleton.afterSingletonsInstantiated();</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;</div><div class="line">                                &#125;</div><div class="line"></div><div class="line">                                <span class="keyword">return</span>;</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            beanName = (String)var2.next();</div><div class="line">                            bd = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</div><div class="line">                        &#125; <span class="keyword">while</span>(bd.isAbstract());</div><div class="line">                    &#125; <span class="keyword">while</span>(!bd.isSingleton());</div><div class="line">                &#125; <span class="keyword">while</span>(bd.isLazyInit());</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.isFactoryBean(beanName)) &#123;</div><div class="line">                    <span class="comment">// 这个Bean很重要，Spring有一大半扩展功能都与这个Bean有关系，</span></div><div class="line">                    <span class="comment">// 它是个工厂Bean，可以产生Bean实例的Bean，</span></div><div class="line">                    <span class="comment">// Spring获取FactoryBean本身的对象是通过在前面加上&amp;来完成的                    </span></div><div class="line">                    <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean)<span class="keyword">this</span>.getBean(<span class="string">"&amp;"</span> + beanName);</div><div class="line">                    <span class="keyword">boolean</span> isEagerInit;</div><div class="line">                    <span class="keyword">if</span>(System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</div><div class="line">                        isEagerInit = ((Boolean)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</div><div class="line">                            <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                                <span class="keyword">return</span> Boolean.valueOf(((SmartFactoryBean)factory).isEagerInit());</div><div class="line">                            &#125;</div><div class="line">                        &#125;, <span class="keyword">this</span>.getAccessControlContext())).booleanValue();</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        isEagerInit = factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp; ((SmartFactoryBean)factory).isEagerInit();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span>(isEagerInit) &#123;</div><div class="line">                        <span class="comment">// 普通的Bean只要通过getBean方法直接创建它的实例</span></div><div class="line">                        <span class="comment">// getBean方法里面包含了他们关系的创建</span></div><div class="line">                        <span class="keyword">this</span>.getBean(beanName);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">this</span>.getBean(beanName);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="IOC容器的扩展点"><a href="#IOC容器的扩展点" class="headerlink" title="IOC容器的扩展点"></a>IOC容器的扩展点</h2><p>如何让这些 Bean 对象有一定的扩展性（就是可以加入用户的一些操作）也是我们需要思考的！那么有哪些扩展点呢？ Spring 又是如何调用到这些扩展点的？</p>
<p>对 Spring 的 IOC 容器来说，主要有这么几个扩展点：</p>
<ul>
<li>BeanFactoryPostProcessor， BeanPostProcessor：他们分别是在构建 BeanFactory 和构建 Bean 对象时调用。</li>
<li>InitializingBean 和 DisposableBean ：他们分别是在 Bean 实例创建和销毁时被调用。用户可以实现这些接口中定义的方法，Spring 就会在适当的时候调用他们。</li>
<li>FactoryBean ：他是个特殊的 Bean，这个 Bean 可以被用户更多的控制。</li>
</ul>
<p>这些扩展点通常也是我们使用 Spring 来完成我们特定任务的地方，<strong>是否精通 Spring 就看你有没有掌握好Spring有哪些扩展点，并且如何使用他们。</strong></p>
<p>要知道如何使用他们就必须了解他们内在的机理。可以用下面一个比喻（优秀）来解释：</p>
<p>我们把 IOC 容器比作一个箱子，这个箱子里有若干个球的模子，可以用这些模子来造很多种不同的球，还有一个造这些球模的机器，这个机器可以产生球模。那么他们的对应关系就是 BeanFactory 就是那个造球模的机器，球模就是 Bean，而球模造出来的球就是 Bean 的实例。</p>
<p>那前面所说的几个扩展点又在什么地方呢？ BeanFactoryPostProcessor 对应到当造球模被造出来时，你将有机会可以对其做出设当的修正，也就是他可以帮你修改球模。而 InitializingBean 和 DisposableBean 是在球模造球的开始和结束阶段，你可以完成一些预备和扫尾工作。BeanPostProcessor 就可以让你对球模造出来的球做出适当的修正。最后还有一个 FactoryBean，它可是一个神奇的球模。这个球模不是预先就定型了，而是由你来给他确定它的形状，既然你可以确定这个球模型的形状，当然他造出来的球肯定就是你想要的球了，这样在这个箱子里你可以发现所有你想要的球。</p>
<h2 id="IOC容器的使用"><a href="#IOC容器的使用" class="headerlink" title="IOC容器的使用"></a>IOC容器的使用</h2><p>我们使用 Spring 必须要首先构建 IOC 容器，没有它 Spring 无法工作，ApplicatonContext.xml 就是 IOC 容器的默认配置文件，Spring 的所有特性功能都是基于这个 IOC 容器工作的，比如后面要介绍的 AOP。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入分析Java Web技术内幕》</li>
<li><a href="https://blog.csdn.net/u010425776/article/details/55269848" target="_blank" rel="external"> 深入剖析Spring(一)——IoC的基本概念(从面向对象角度介绍)</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前一篇文章我们介绍了Spring的整体架构以及核心组件，接下来我们将讲解Spring的核心概念之一IOC，我们将先简单介绍IOC与DI，然后再深入SpringIOC容器的工作流程。
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Spring" scheme="http://bestlixiang.site/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Spring(一)_Spring架构</title>
    <link href="http://bestlixiang.site/2018/04/10/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Spring-%E4%B8%80-Spring%E6%9E%B6%E6%9E%84/"/>
    <id>http://bestlixiang.site/2018/04/10/深入SSM/揭秘Spring-一-Spring架构/</id>
    <published>2018-04-10T11:31:40.000Z</published>
    <updated>2018-04-10T11:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：Spring作为现在最优秀的框架之一，被广泛得使用在Web场景中。很多人只会使用，但是却不知道Spring整个体系架构。<a id="more"></a></p>
<h1 id="Spring的骨骼架构"><a href="#Spring的骨骼架构" class="headerlink" title="Spring的骨骼架构"></a>Spring的骨骼架构</h1><p>Spring总共有十几个组件，但是真正核心的组件只有几个，如下图为Spring框架开始以来拥有的总体架构图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/gif/spring.gif" alt="spring"></p>
<p>从上图可以看出，在Spring框架中的 <strong>核心组件</strong> 只有三个：core、context、bean。他们构建起整个Spring的骨骼架构，没有他们就不可能有AOP、Web等上层的 <strong>特性功能</strong> 。</p>
<h2 id="Spring的设计理念"><a href="#Spring的设计理念" class="headerlink" title="Spring的设计理念"></a>Spring的设计理念</h2><p>上面说了三个核心组件，但是最重要就是Bean组件了，用过Spring的人都知道，我们所有的类基本上都会交给Spring托管，也就是说Spring就是面向Bean的编程。Bean在Spring中的作用就像Object对OOP的意义一样，没有对象的概念就没有面向对象的概念，在Spring中没有Bean也就没有Spring存在的意义。</p>
<p><strong>使用Spring最大的原因：</strong> 是他解决了一个非常关键的问题，它可以让你把对象之间的依赖关系解耦，其中的关系交由<strong>IOC容器</strong>（Bean关系的集合）来管理，核心就是<strong>依赖注入机制</strong>。Spring也正是通过把对象包装在Bean中达到管理这些对象及做一些列额外操作的目的。</p>
<p><strong>一般框架设计理念：</strong> 先构建一个数据结构，然后根据这个数据结构设计它的生存环境，并让它在这个环境中按照一定的规律不停的运动，在他不停运动的过程中设计它们与环境或者与其他个体完成信息交换。</p>
<h2 id="核心组件如何协同工作"><a href="#核心组件如何协同工作" class="headerlink" title="核心组件如何协同工作"></a>核心组件如何协同工作</h2><p>参考《深入分析Java Web技术内幕》一书中有个形象的比喻：Spring框架就像一场演出，Bean相当于演员，Context相当于演出的舞台背景、Core相当于演出的道具（把演员联系起来）。如果想演出足够新颖，就需要Spring提供的其他特色功能了。</p>
<p>回到Spring：Bean包装的是Object，而Object必然有数据，如何给这些数据提供生成环境就是Context要解决的事情，对于Context来说就是要发现每个Bean之间的关系，为他们建立这种关系并且维护好这种关系，而发现、建立和维护每个Bean之间的关系维护这种关系就需要Core组件了，Core组件其实就是发现、建立和维护每个Bean之间的关系所需要的一些列工具。最后我们发现Context就是一个Bean关系的集合，这个关系集合就叫<strong>IOC容器</strong>，当建立起IOC容器，Spring就可以工作了。他们的关系可以用下图来描述：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/gif/ccb.gif" alt="ccb"></p>
<h1 id="核心组件解析"><a href="#核心组件解析" class="headerlink" title="核心组件解析"></a>核心组件解析</h1><h2 id="Bean组件"><a href="#Bean组件" class="headerlink" title="Bean组件"></a>Bean组件</h2><p>Bean 组件在 Spring 的 org.springframework.beans 包下。这个包下的所有类主要解决了三件事：<strong>Bean 的定义、 Bean 的解析以及对Bean 的创建</strong>。对 Spring 的使用者来说唯一需要关心的就是 Bean 的创建，其他两个由 Spring 在内部帮你完成了，对你来说是透明的。</p>
<h3 id="Bean的定义"><a href="#Bean的定义" class="headerlink" title="Bean的定义"></a>Bean的定义</h3><p>Bean 的定义主要有 BeanDefinition 描述，如下图（RootBeanDefinition类图）说明了这些类的层次关系：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/rootBeanDefinition.png" alt="rootBeanDefinition"></p>
<p>Bean 的定义就是完整的描述了在 Spring 的配置的Bean中所有的信息。当 Spring 成功解析你定义的一个Bean后，在 Spring 的内部他就被转化成 BeanDefinition 对象，它可以定义为SINGLETON还是PROTOTYPE。以后所有的操作都是对这个对象完成的。</p>
<h3 id="Bean的解析"><a href="#Bean的解析" class="headerlink" title="Bean的解析"></a>Bean的解析</h3><p>Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析方式有很多种，这也就导致配置方式有很多种（之后会介绍各种Bean的配置方法，如xml，扫描，注解、java配置）。这里就介绍一下最早的解析XML配置，它的过程主要通过下图中的类(XmlBeanDefinitionReader)完成：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/XmlBeanDefinitionReader.png" alt="XmlBeanDefinitionReader"></p>
<h3 id="Bean的创建"><a href="#Bean的创建" class="headerlink" title="Bean的创建"></a>Bean的创建</h3><p>Spring Bean 的创建是典型的工厂模式，我们可以通过DefaultListableBeanFactory这个类来了解Spring的工厂模式，工厂模式的顶级接口是 BeanFactory，下图是这个工厂的继承层次关系：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/defaultListableBeanFactory.png" alt="image"></p>
<p>BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory。但是从上图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，他实现了所有的接口。</p>
<p>框架核心：那为何要定义这么多层次的接口呢？</p>
<p>查阅这些接口的源码和说明发现，每个接口都有他使用的场合，它主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制，具体如下：</p>
<ul>
<li>ListableBeanFactory 接口表示这些 Bean 是可列表的</li>
<li>HierarchicalBeanFactory 表示的是这些 Bean是有继承关系的，也就是每个 Bean有可能有父 Bean。</li>
<li>AutowireCapableBeanFactory 接口定义Bean的自动装配规则。</li>
</ul>
<p>这四个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为。</p>
<h2 id="Context组件"><a href="#Context组件" class="headerlink" title="Context组件"></a>Context组件</h2><p>Context 在 Spring 的 org.springframework.context 包下，<strong>Context 组件在 Spring 中的作用实际上就是给Spring提供一个运行时的环境，用以保存各个对象的状态</strong> 。下面看一下这个环境是如何构建的。</p>
<p>ApplicationContext 是 Context 的顶级父类，他除了能标识一个应用环境的基本信息外，他还继承了六个接口，这六个接口主要是扩展了 Context 的功能。下面是 Context 相关的类结构图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/AbstractRefreshableWebApplicationContext.png" alt="Context"></p>
<p>从上图中可以看出 ApplicationContext 继承了BeanFactory，这也说明了 Spring 容器中运行的主体对象是 Bean，另外 ApplicationContext 继承了 ResourceLoader 接口，使得 ApplicationContext 可以访问到任何外部资源（就是Core里面的工具了，这将在 Core 中详细说明）。</p>
<p>ApplicationContext 的子类主要包含两个方面：</p>
<ul>
<li>ConfigurableApplicationContext：表示该Context是可修改的，也就是在构建 Context 中用户可以动态添加或修改已有的配置信息，它下面又有多个子类，其中最经常使用的是可更新的 Context，即 AbstractRefreshableApplicationContext 类。</li>
<li>WebApplicationContext ：看到web就知道这为 web 准备的 Context 他可以直接访问到 ServletContext，通常情况下，这个接口使用的少。<br>再往下分就是按照构建 Context 的文件类型（没列出，感兴趣的可以自己去看），接着就是访问 Context 的方式。这样一级一级构成了完整的 Context 等级层次。</li>
</ul>
<p>总体来说 ApplicationContext 必须要完成以下几件事：</p>
<ul>
<li>标识一个应用环境</li>
<li>利用 BeanFactory 创建 Bean 对象</li>
<li>保存对象关系表</li>
<li>能够捕获各种事件</li>
</ul>
<p>Context 作为 Spring 的 <strong>IOC 容器</strong>，基本上整合了 Spring 的大部分功能，或者说是大部分功能的基础。</p>
<h2 id="Core组件"><a href="#Core组件" class="headerlink" title="Core组件"></a>Core组件</h2><p>Core 组件在Spring 的org.springframework.core包下，它作为 Spring的核心组件，他其中包含了很多的关键类，其中一个重要组成部分就是定义了资源（Resource）的访问方式。这种<strong>把所有资源都抽象成一个接口的方式</strong>很值得在以后的设计中拿来学习。下面就重要看一下这个部分在 Spring 的作用。我们通过下图（ Resource 相关的类结构图）来理解：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/resource.png" alt="resource"></p>
<p>从上图可以看出 Resource 接口封装了各种可能的资源类型，也就是对使用者来说屏蔽了文件类型的不同。对资源的提供者来说，如何把资源包装起来交给其他人用这也是一个问题(所以产生了很多方式)，我们看到 Resource 接口继承了 InputStreamSource 接口，这个接口中有个 getInputStream 方法，返回的是 InputStream 类。这样所有的资源都被可以通过 InputStream 这个类来获取，所以也屏蔽了资源的提供者。另外还有一个问题就是加载资源的问题，也就是资源的加载者要统一，从上图中可以看出这个任务是由 ResourceLoader 接口完成，他屏蔽了所有的资源加载者的差异，只需要实现这个接口就可以加载所有的资源，他的默认实现是 DefaultResourceLoader。</p>
<p>那Context 和 Resource 是如何建立关系的？下面是他们的类关系图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/cc.png" alt="cc"></p>
<p>从上图可以看出，Context 是把资源的加载、解析和描述工作委托给了 ResourcePatternResolver 类来完成，他相当于一个接头人，他把资源的加载、解析和资源的定义整合在一起便于其他组件使用。Core 组件中还有很多类似的方式。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入分析Java Web技术内幕》</li>
<li><a href="http://www.jb51.net/article/112039.htm" target="_blank" rel="external">Spring多种加载Bean方式解析</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：Spring作为现在最优秀的框架之一，被广泛得使用在Web场景中。很多人只会使用，但是却不知道Spring整个体系架构。
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Spring" scheme="http://bestlixiang.site/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_防火墙配置</title>
    <link href="http://bestlixiang.site/2018/04/09/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux-%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"/>
    <id>http://bestlixiang.site/2018/04/09/走进Linux/走进Linux-防火墙配置/</id>
    <published>2018-04-09T04:41:43.000Z</published>
    <updated>2018-04-09T04:42:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：保障数据的安全性是继保障数据的可用性之后最为重要的一项工作。防火墙作为公网与内网之间的保护屏障，在保障数据的安全性方面起着至关重要的作用。<a id="more"></a></p>
<h1 id="防火墙管理工具"><a href="#防火墙管理工具" class="headerlink" title="防火墙管理工具"></a>防火墙管理工具</h1><p>在公网与企业内网之间充当保护屏障的防火墙虽然有软件或硬件之分，但主要功能都是 <strong>依据策略对穿越防火墙自身的流量进行过滤。</strong> 防火墙策略可以基于流量的源目地址、端口号、协议、应用等信息来定制，然后防火墙使用预先定制的策略规则监控出入的流量，若流量与某一条策略规则相匹配，则执行相应的处理，反之则丢弃。这样一来，就可以保证仅有合法的流量在企业内网和外部公网之间流动了。</p>
<p>在Centos 7系统中，firewalld防火墙取代了iptables防火墙。但是 <strong>iptables与firewalld都不是真正的防火墙</strong> ，它们都只是用来定义防火墙策略的 <strong>防火墙管理工具</strong> 而已，或者说，它们只是一种 <strong>服务</strong> 。iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。虽然这些工具各有优劣，但它们在防火墙策略的配置思路上是保持一致的。</p>
<h1 id="Iptables"><a href="#Iptables" class="headerlink" title="Iptables"></a>Iptables</h1><p>在早期的Linux系统中，默认使用的是iptables防火墙管理服务来配置防火墙。尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables。</p>
<h2 id="策略与规则链"><a href="#策略与规则链" class="headerlink" title="策略与规则链"></a>策略与规则链</h2><p>防火墙会从上至下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。<strong>一般而言，防火墙策略规则的设置有两种：一种是“通”（即放行），一种是“堵”（即阻止）。当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否则谁都进不来；如果防火墙的默认策略为允许时，就要设置拒绝规则，否则谁都能进来，</strong> 防火墙也就失去了防范的作用。</p>
<p>iptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下：</p>
<ul>
<li>在进行路由选择前处理数据包（PREROUTING）</li>
<li>处理流入的数据包（INPUT）</li>
<li>处理流出的数据包（OUTPUT）</li>
<li>处理转发的数据包（FORWARD）</li>
<li>在进行路由选择后处理数据包（POSTROUTING）</li>
</ul>
<p>一般来说，从内网向外网发送的流量一般都是可控且良性的，<strong>因此我们使用最多的就是INPUT规则链</strong>， 该规则链可以增大黑客人员从外网入侵内网的难度。</p>
<p>iptables还可以选择采用什么样的动作来处理这些匹配的流量，比如“允许”、“拒绝”、“登记”、“不理它”。这些动作对应到iptables服务的术语中分别是</p>
<ul>
<li>ACCEPT（允许流量通过）</li>
<li>REJECT（拒绝流量通过）：</li>
<li>LOG（记录日志信息）</li>
<li>DROP（拒绝流量通过）。</li>
</ul>
<p>“允许流量通过”和“记录日志信息”都比较好理解，这里需要着重讲解的是REJECT和DROP的不同点。就DROP来说，它是直接将流量丢弃而且不响应；REJECT则会在拒绝流量后再回复一条“您的信息已经收到，但是被扔掉了”信息，从而让流量发送方清晰地看到数据被拒绝的响应信息。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>iptables是一款基于命令行的防火墙策略管理工具，对于日常的防火墙策略配置来讲，只需要掌握常用的参数并做到灵活搭配即可，这就足以应对日常工作了。</p>
<p>iptables命令可以根据<strong>流量的源地址、目的地址、传输协议、服务类型等信息进行匹配</strong>，一旦匹配成功，iptables就会根据策略规则所预设的动作来处理这些流量。另外，再次提醒一下，<strong>防火墙策略规则的匹配顺序是从上至下的，因此要把较为严格、优先级较高的策略规则放到前面，以免发生错误</strong>。下表总结归纳了常用的iptables命令参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-P</td>
<td>设置默认策略</td>
</tr>
<tr>
<td>-F</td>
<td>清空规则链</td>
</tr>
<tr>
<td>-L</td>
<td>查看规则链</td>
</tr>
<tr>
<td>-A</td>
<td>在规则链的末尾加入新规则</td>
</tr>
<tr>
<td>-I num</td>
<td>在规则链的头部加入新规则</td>
</tr>
<tr>
<td>-D num</td>
<td>删除某一条规则</td>
</tr>
<tr>
<td>-s</td>
<td>匹配来源地址IP/MASK，加叹号“!”表示除这个IP外</td>
</tr>
<tr>
<td>-d</td>
<td>匹配目标地址</td>
</tr>
<tr>
<td>-i</td>
<td>网卡名称    匹配从这块网卡流入的数据</td>
</tr>
<tr>
<td>-o</td>
<td>网卡名称    匹配从这块网卡流出的数据</td>
</tr>
<tr>
<td>-p</td>
<td>匹配协议，如TCP、UDP、ICMP</td>
</tr>
<tr>
<td>–dport num</td>
<td>匹配目标端口号</td>
</tr>
<tr>
<td>–sport num</td>
<td>匹配来源端口号</td>
</tr>
</tbody>
</table>
<p>范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 1. 查看已有的防火墙规则链</div><div class="line">iptables -L</div><div class="line"></div><div class="line">// 2. 清空已有的防火墙规则链</div><div class="line">iptables -F</div><div class="line"></div><div class="line">// 3. 把INPUT规则链的默认策略设置为拒绝(规则链的默认策略拒绝动作只能是DROP，而不能是REJECT)</div><div class="line">// 特别注意，如果你是在云服务上做实验，千万不要这样做，因为它会由于防火墙断开你的ssh连接，只能到控制台登录修改。</div><div class="line">iptables -P INPUT DROP</div><div class="line"></div><div class="line">// 4. 向INPUT链中添加拒绝ICMP流量进入的策略规则</div><div class="line">iptables -I INPUT -p icmp -j DROP</div><div class="line"></div><div class="line">// 5. 删除INPUT规则链中刚刚加入的那条策略（允许ICMP流量）</div><div class="line">iptables -D INPUT 1</div><div class="line"></div><div class="line">// 6. 将INPUT规则链设置为只允许指定网段的主机访问本机的22端口，拒绝来自其他所有主机的流量</div><div class="line">iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPT</div><div class="line"></div><div class="line">// 7. 向INPUT规则链中添加拒绝所有人访问本机12345端口的策略规则</div><div class="line">iptables -I INPUT -p tcp --dport 12345 -j REJECT</div><div class="line"></div><div class="line">// 8. 向INPUT规则链中添加拒绝192.168.10.5主机访问本机80端口（Web服务）的策略规则</div><div class="line">iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT</div><div class="line"></div><div class="line">// 9. 向INPUT规则链中添加拒绝所有主机访问本机1000～1024端口的策略规则</div><div class="line">iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT</div><div class="line"></div><div class="line">// 10. 使用iptables命令配置的防火墙规则默认会在系统下一次重启时失效，如果想让配置的防火墙策略永久生效，还要执行</div><div class="line">// 保存命令：</div><div class="line">service iptables save</div><div class="line">// 如果出现</div><div class="line">The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.</div><div class="line">需要如下操作：</div><div class="line">yum install iptables-services // 安装服务</div><div class="line">systemctl enable iptables // 设置开机启动iptables</div><div class="line">systemctl start iptables //打开iptables</div><div class="line">然后执行就可以了</div></pre></td></tr></table></figure></p>
<h1 id="Firewalld"><a href="#Firewalld" class="headerlink" title="Firewalld"></a>Firewalld</h1><p>Centos7系统中集成了多款防火墙管理工具，其中firewalld（Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器）服务是默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式。但是我们只介绍命令行界面。</p>
<h2 id="区域Zone"><a href="#区域Zone" class="headerlink" title="区域Zone"></a>区域Zone</h2><p>相较于传统的防火墙管理配置工具，<strong>firewalld支持动态更新技术并加入了区域（zone）的概念</strong>。简单来说，区域就是firewalld预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。从而极大地提升了防火墙策略的应用效率。firewalld中常见的区域名称（默认为public）以及相应的策略规则如下表所示：</p>
<table>
<thead>
<tr>
<th>区域</th>
<th>默认规则策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>trusted</td>
<td>允许所有的数据包</td>
</tr>
<tr>
<td>home</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>internal</td>
<td>等同于home区域</td>
</tr>
<tr>
<td>work</td>
<td>拒绝流入的流量，除非与流出的流量数相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>public</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>external</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>dmz</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>block</td>
<td>拒绝流入的流量，除非与流出的流量相关</td>
</tr>
<tr>
<td>drop</td>
<td>拒绝流入的流量，除非与流出的流量相关</td>
</tr>
</tbody>
</table>
<h2 id="基本使用：firewall-cmd"><a href="#基本使用：firewall-cmd" class="headerlink" title="基本使用：firewall-cmd"></a>基本使用：firewall-cmd</h2><p>firewall-cmd是firewalld防火墙配置管理工具的CLI（命令行界面）版本。它的参数一般都是以“长格式”来提供的，但是Centos7支持部分命令的参数补齐，其中就包含这条命令，美滋滋。也就是说，现在除了能用Tab键自动补齐命令或文件名等内容之外，还可以用Tab键来补齐下表中所示的长格式参数了：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>–get-default-zone</td>
<td>查询默认的区域名称</td>
</tr>
<tr>
<td>–set-default-zone=&lt;区域名称&gt;</td>
<td>设置默认的区域，使其永久生效</td>
</tr>
<tr>
<td>–get-zones</td>
<td>显示可用的区域</td>
</tr>
<tr>
<td>–get-services</td>
<td>显示预先定义的服务</td>
</tr>
<tr>
<td>–get-active-zones</td>
<td>显示当前正在使用的区域与网卡名称</td>
</tr>
<tr>
<td>–remove-source=</td>
<td>将源自此IP或子网的流量导向指定的区域</td>
</tr>
<tr>
<td>–remove-source=</td>
<td>不再将源自此IP或子网的流量导向某个指定区域</td>
</tr>
<tr>
<td>–add-interface=&lt;网卡名称&gt;</td>
<td>将源自该网卡的所有流量都导向某个指定区域</td>
</tr>
<tr>
<td>–change-interface=&lt;网卡名称&gt;</td>
<td>将某个网卡与区域进行关联</td>
</tr>
<tr>
<td>–list-all</td>
<td>显示当前区域的网卡配置参数、资源、端口以及服务等信息</td>
</tr>
<tr>
<td>–list-all-zones</td>
<td>显示所有区域的网卡配置参数、资源、端口以及服务等信息</td>
</tr>
<tr>
<td>–add-service=&lt;服务名&gt;</td>
<td>设置默认区域允许该服务的流量</td>
</tr>
<tr>
<td>–add-port=&lt;端口号/协议&gt;</td>
<td>设置默认区域允许该端口的流量</td>
</tr>
<tr>
<td>–remove-service=&lt;服务名&gt;</td>
<td>设置默认区域不再允许该服务的流量</td>
</tr>
<tr>
<td>–remove-port=&lt;端口号/协议&gt;</td>
<td>设置默认区域不再允许该端口的流量</td>
</tr>
<tr>
<td>–reload</td>
<td>让“永久生效”的配置规则立即生效，并覆盖当前的配置规则</td>
</tr>
<tr>
<td>–panic-on</td>
<td>开启应急状况模式</td>
</tr>
<tr>
<td>–panic-off</td>
<td>关闭应急状况模式</td>
</tr>
</tbody>
</table>
<p>与Linux系统中其他的防火墙策略配置工具一样，<strong>使用firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且随着系统的重启会失效。如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd命令正常设置防火墙策略时添加–permanent参数，这样配置的防火墙策略就可以永久生效了。但是使用永久生效模式设置的策略只有在系统重启之后才能自动生效。如果想让配置的策略立即生效，需要手动执行firewall-cmd –reload命令。</strong></p>
<p>使用范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">// 1. 查看firewalld服务当前所使用的区域</div><div class="line">firewall-cmd --get-default-zone</div><div class="line"></div><div class="line">// 2. 查询eth0网卡在firewalld服务中的区域</div><div class="line">firewall-cmd --get-zone-of-interface=eth0</div><div class="line"></div><div class="line">// 3. 把firewalld服务中eth0网卡的默认区域修改为external，并在系统重启后生效。</div><div class="line">// 分别查看当前与永久模式下的区域名称：</div><div class="line">firewall-cmd --permanent --zone=external --change-interface=eth0</div><div class="line">firewall-cmd --get-zone-of-interface=eth0</div><div class="line">firewall-cmd --permanent --get-zone-of-interface=eth0</div><div class="line"></div><div class="line">// 4. 把firewalld服务的当前默认区域设置为public</div><div class="line">firewall-cmd --set-default-zone=public</div><div class="line"></div><div class="line">// 5. 启动/关闭firewalld防火墙服务的应急状况模式，阻断一切网络连接（当远程控制服务器时请慎用）</div><div class="line">firewall-cmd --panic-on</div><div class="line">firewall-cmd --panic-off</div><div class="line"></div><div class="line">// 6. 查询public区域是否允许请求SSH和HTTPS协议的流量</div><div class="line">firewall-cmd --zone=public --query-service=ssh</div><div class="line">firewall-cmd --zone=public --query-service=https</div><div class="line"></div><div class="line">// 7. 把firewalld服务中请求HTTPS协议的流量设置为永久允许，并立即生效</div><div class="line">firewall-cmd --zone=public --add-service=https</div><div class="line">firewall-cmd --permanent --zone=public --add-service=https</div><div class="line">firewall-cmd --reload</div><div class="line"></div><div class="line">// 8. 把firewalld服务中请求HTTP协议的流量设置为永久拒绝，并立即生效</div><div class="line">firewall-cmd --permanent --zone=public --remove-service=http</div><div class="line">firewall-cmd --reload</div><div class="line"></div><div class="line">// 9. 把在firewalld服务中访问8080和8081端口的流量策略设置为允许，但仅限当前生效</div><div class="line">firewall-cmd --zone=public --add-port=8080-8081/tcp</div><div class="line"></div><div class="line">// 10. 把原本访问本机888端口的流量转发到22端口，要且求当前和长期均有效</div><div class="line">firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.10.10(目标地址)</div><div class="line">firewall-cmd --reload</div><div class="line"></div><div class="line">// 11. firewalld中的富规则表示更细致、更详细的防火墙策略配置，</div><div class="line">// 它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置。</div><div class="line">// 它的优先级在所有的防火墙策略中也是最高的。比如，我们可以在firewalld服务中配置一条富规则，使其拒绝192.168.10.0/24网段的所有用户访问本机的ssh服务（22端口）：</div><div class="line">firewall-cmd --permanent --zone=public --add-rich-rule=&quot;rule family=&quot;ipv4&quot; \</div><div class="line">source address=&quot;192.168.10.0/24&quot; service name=&quot;ssh&quot; reject&quot;</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.linuxprobe.com/chapter-08.html" target="_blank" rel="external">iptables与firewalld防火墙</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：保障数据的安全性是继保障数据的可用性之后最为重要的一项工作。防火墙作为公网与内网之间的保护屏障，在保障数据的安全性方面起着至关重要的作用。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_Linux中常用的网络命令</title>
    <link href="http://bestlixiang.site/2018/04/08/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_Linux%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://bestlixiang.site/2018/04/08/走进Linux/走进Linux_Linux中常用的网络命令/</id>
    <published>2018-04-08T12:51:27.000Z</published>
    <updated>2018-04-09T04:31:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：Linux的网络功能是相当强大的。所以我们必须要好好了解它，这里我们只是介绍一下常用的命令。<a id="more"></a></p>
<h1 id="设置网络参数的命令"><a href="#设置网络参数的命令" class="headerlink" title="设置网络参数的命令"></a>设置网络参数的命令</h1><h2 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h2><p>ifconfig主要是可以都手动启动、查看与修改网络接口的相关参数，范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 1. 查看所有网络接口</div><div class="line">ifconfig</div><div class="line">// 2. 查看eth0网卡</div><div class="line">ifconfig eth0</div><div class="line"></div><div class="line">输出：</div><div class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</div><div class="line">        inet 172.16.0.9  netmask 255.255.240.0  broadcast 172.16.15.255</div><div class="line">        ether 52:54:00:1c:91:2a  txqueuelen 1000  (Ethernet)</div><div class="line">        RX packets 15979545  bytes 1741444280 (1.6 GiB)</div><div class="line">        RX errors 0  dropped 0  overruns 0  frame 0</div><div class="line">        TX packets 15811187  bytes 2149680103 (2.0 GiB)</div><div class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</div><div class="line"></div><div class="line">* eth0：就是网络卡的代号，也有 lo 这个 loopback</div><div class="line">* mtu：网络接口的最大传输单元</div><div class="line">* inet：IPv4 的 IP 地址，后续是子网掩码和广播地址</div><div class="line">* RX：那一行代表的是网络由启动到目前为止的封包接收情况， packets 代表封包数、errors 代表封包发生错误的数量、 dropped 代表封包由于有问题而遭丢弃的数量等等</div><div class="line">* TX：与 RX 相反，为网络由启动到目前为止的传送情况；collisions：代表封包碰撞的情况，如果发生太多次， 表示您的网络状况不太好</div><div class="line"></div><div class="line">// 3. 暂时修改网络接口，给予eth0一个192.168.100.100/24的参数</div><div class="line">ifconfig eth0 192.168.100.100</div><div class="line"></div><div class="line">// 4. 将手动的处理全部取消，使用原有的设置值重置网络参数</div><div class="line">/etc/init.d/network restart</div></pre></td></tr></table></figure></p>
<h1 id="网络排错与查看命令"><a href="#网络排错与查看命令" class="headerlink" title="网络排错与查看命令"></a>网络排错与查看命令</h1><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>这个 ping 是很重要的指令，ping 主要透过 ICMP（Internet控制报文协议） 封包来进行整个网络的状况报告。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 1. 检测一下168.95.1.1这部DNS主机是否存在(存在于网络环境中)</div><div class="line">ping -c 3 168.95.1.1</div><div class="line"></div><div class="line">输出：</div><div class="line">PING 168.95.1.1 (168.95.1.1) 56(84) bytes of data.</div><div class="line">64 bytes from 168.95.1.1: icmp_seq=1 ttl=239 time=69.9 ms</div><div class="line">64 bytes from 168.95.1.1: icmp_seq=2 ttl=239 time=70.4 ms</div><div class="line">64 bytes from 168.95.1.1: icmp_seq=3 ttl=239 time=69.9 ms</div><div class="line"></div><div class="line">--- 168.95.1.1 ping statistics ---</div><div class="line">3 packets transmitted, 3 received, 0% packet loss, time 2002ms</div><div class="line">rtt min/avg/max/mdev = 69.920/70.119/70.467/0.328 ms</div><div class="line"></div><div class="line"></div><div class="line">// 2. 找出最大的MTU数值(如果有响应，那就是可以接受这个数据包，如果无响应，就表示这个MTU太大了)</div><div class="line">ping -c 2 -s 1000 -M do 192.168.1.254</div></pre></td></tr></table></figure></p>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>如果你觉得你的某个网络服务明明就启动了，但是就是无法造成联机的话，要查询一下自己的网络接口所监听的端口 (port) 来看看是否真的有启动。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 1. 列出当前路由表状态，且以IP及port number进行系那是</div><div class="line">netstat -rn</div><div class="line"></div><div class="line">// 2. 列出当前的所有网络连接状态，使用IP与port number</div><div class="line">netstat -an</div><div class="line"></div><div class="line">// 3. 显示目前已经启动的网络服务</div><div class="line">netstat -tulnp</div><div class="line"></div><div class="line">// 4. 查看本机上所有的网络连接状态</div><div class="line">netstat -atunp</div></pre></td></tr></table></figure></p>
<h2 id="host"><a href="#host" class="headerlink" title="host"></a>host</h2><p>这个命令可以用来查出某个主机名的IP，范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 列出www.yahoo.com的IP(向/etc/resolv.conf里面记录的DNS服务器查询IP)</div><div class="line">host www.yohoo.com</div></pre></td></tr></table></figure></p>
<h2 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h2><p>功能和host一样，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. 查询www.google.com的IP</div><div class="line">nslookup www.google.com</div><div class="line"></div><div class="line">// 2. 找出168.95.1.1的主机名   (建议使用dig)</div><div class="line">nslookup 168.95.1.1</div></pre></td></tr></table></figure>
<h1 id="远程连接命令与即时通信软件"><a href="#远程连接命令与即时通信软件" class="headerlink" title="远程连接命令与即时通信软件"></a>远程连接命令与即时通信软件</h1><h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p>telnet本身数据的在传输过程中使用的是明文，所以数据在Internet上面传输的时候，会比较危险。使用范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 1. 连接到当前热门的PTT BBS站点ptt.cc</div><div class="line">yum install telnet // 默认没有安装（自己未成功）</div><div class="line"></div><div class="line">// 2. 检测本地主机的110这个port是否正确启动,</div><div class="line">// 如果出现telnet: connect to address 127.0.0.1: Connection refused，代表这个port没有启动或者这个连接有问题</div><div class="line">telnet localhost 22</div></pre></td></tr></table></figure></p>
<h2 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h2><p>用于处理ftp服务器的下载数据，范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 连接到一个ftp服务器</div><div class="line">ftp ip //之后可以利用help来帮助操作</div></pre></td></tr></table></figure></p>
<h1 id="文字接口网页浏览"><a href="#文字接口网页浏览" class="headerlink" title="文字接口网页浏览"></a>文字接口网页浏览</h1><h2 id="links"><a href="#links" class="headerlink" title="links"></a>links</h2><p>最大的功能就是查阅Linux本机上面以html语法写成的文件数据。具体效果自己看吧，范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 浏览Linux kernel网站</div><div class="line">links http://www.kernel.org</div></pre></td></tr></table></figure></p>
<h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p>主要的功能是取得网页数据。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 1. 下载 2.6.17 版的linux内核</div><div class="line">wget \</div><div class="line">http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.17.tar.gz</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：Linux的网络功能是相当强大的。所以我们必须要好好了解它，这里我们只是介绍一下常用的命令。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_软件安装</title>
    <link href="http://bestlixiang.site/2018/04/08/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://bestlixiang.site/2018/04/08/走进Linux/走进Linux_软件安装-软件安装/</id>
    <published>2018-04-08T09:14:14.000Z</published>
    <updated>2018-04-09T04:34:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：当你拿到一台新电脑的第一反应是什么，当然是装软件，然后好好玩呀！服务器也是如此，所以你必须掌握软件的安装。<a id="more"></a></p>
<h1 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h1><h2 id="开放源码的软件安装相关概念"><a href="#开放源码的软件安装相关概念" class="headerlink" title="开放源码的软件安装相关概念"></a>开放源码的软件安装相关概念</h2><p>Linux上几乎所有的软件都经过了GPL授权，因此几乎所有的软件都会提供源码。<br>而一个软件要在Linux上执行，必须是二进制文件，因此当我们拿到软件源码后，需要将它编译成二进制文件才能在Linux上运行。</p>
<h3 id="开放源码、编译程序、可执行文件"><a href="#开放源码、编译程序、可执行文件" class="headerlink" title="开放源码、编译程序、可执行文件"></a>开放源码、编译程序、可执行文件</h3><ol>
<li>开放源码：就是程序代码，写给人类看的语言，但机器并不认识，所以无法执行。</li>
<li>编译程序：将程序代码转译称为机器看得懂的语言。</li>
<li>可执行文件：经过编译程序变成二进制程序后，机器看得懂所以可执行的文件。</li>
</ol>
<h3 id="函式库"><a href="#函式库" class="headerlink" title="函式库"></a>函式库</h3><p>类似子程序的角色，可以被呼叫来执行的一段功能函数。</p>
<h3 id="make与configure"><a href="#make与configure" class="headerlink" title="make与configure"></a>make与configure</h3><ol>
<li>configure:侦测用户操作环境，是否支持软件的运行，侦测完毕生成makefile文件<ul>
<li>是否有适合的编译程序可以编译本软件的程序代码</li>
<li>是否已经存在本软件所需要的函数库，或其他需要的相依软件</li>
<li>操作系统平台是否适合本软件，包括 Linux 的核心版本</li>
<li>核心的头文件定义档 (header include) 是否存在 (驱动程序必须要的侦测)。</li>
</ul>
</li>
<li>make:make是一个程序，会去找makefile文件，然后执行编译。</li>
</ol>
<h3 id="tarball软件"><a href="#tarball软件" class="headerlink" title="tarball软件"></a>tarball软件</h3><p>tarball文件其实就是将软件的源码先以tar打包，然后再压缩。其实就是一个<strong>软件包</strong>。通常解压缩之后会存在源代码文件、侦测程序文件（configure）、本软件的简易说明与安装说明（README）。</p>
<h2 id="Tarball的安装的基本步骤"><a href="#Tarball的安装的基本步骤" class="headerlink" title="Tarball的安装的基本步骤"></a>Tarball的安装的基本步骤</h2><ol>
<li>取得源文件：将tarball文件在/usr/local/src目录解压缩</li>
<li>取得步骤流程：进入新建立的目录下面，去查阅INSTALL与README等相关文件内容（很重要）</li>
<li>相关属性软件安装：根据INSTALL/README的内容查看并安装好一些相关的软件</li>
<li>建立makefile文件：以自动检测程序（configure）检测操作环境，并建立Makefile文件</li>
<li>编译：以make这个程序并使用该目录下得Makefile作为它的参数配置文件，来进行make的操作</li>
<li>安装：以make这个程序，并以Makefile这个参数配置文件，依据install这个目标（在Makefile文件中会有多个操作目标，如clean）的指定来安装到正确地路径。</li>
</ol>
<h2 id="Tarball软件安装的建议事项"><a href="#Tarball软件安装的建议事项" class="headerlink" title="Tarball软件安装的建议事项"></a>Tarball软件安装的建议事项</h2><p>在默认情况下，原本的Linux distribution发布安装的软件大多是在/usr里面的，而自行安装的软件则建议放置在/usr/local里面。</p>
<ul>
<li>linux distribution默认的安装软件的路径如下，以httpd为例：<ul>
<li>/etc/httpd（配置文件）</li>
<li>/usr/lib（函数库）</li>
<li>/usr/bin（可执行文件）</li>
<li>/usr/share/man（在线帮助文档）</li>
</ul>
</li>
<li>tarball安装，默认放在/usr/local，如下目录：（升级，删除不方便）<ul>
<li>/usr/local/etc</li>
<li>/usr/local/bin</li>
<li>/usr/local/lib</li>
<li>/usr/local/man</li>
</ul>
</li>
<li>tarball安装，但是单一软件都在同一个目录下，以apache为例：（利于删除，升级）<ul>
<li>/usr/local/apache/etc</li>
<li>/usr/local/apache/bin</li>
<li>/usr/local/apache/lib</li>
<li>/usr/local/apache/man</li>
</ul>
</li>
</ul>
<p>当然，<strong>实际安装的时候还是得视该软件的Makefile里头的install目标信息才能知道安装路径情况。</strong></p>
<p>为了方便Tarball的管理，这样建议：</p>
<ol>
<li>最好将tarball的原始数据解压缩到/usr/local/src当中</li>
<li>安装时，最好安装到/usr/local这个默认路径下</li>
<li>考虑将来的删除，最好可以将每个软件<strong>单独</strong>安装在/usr/local下面</li>
<li>为安装到单独目录的软件的man page加入到man path搜索，即在/etc/man.config增加一行。</li>
</ol>
<h2 id="简单安装范例（ntp时间服务器）"><a href="#简单安装范例（ntp时间服务器）" class="headerlink" title="简单安装范例（ntp时间服务器）"></a>简单安装范例（ntp时间服务器）</h2><p>假设这个软件在/opt下，解压到/usr/local/src，并安装到/usr/local/ntp目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/src //切换目录</div><div class="line"></div><div class="line">tar -zxvf /opt/ntp-4.2.4p7.tar.gz //解压缩到此目录</div><div class="line"></div><div class="line">cd ntp-4.2.4p7/</div><div class="line"></div><div class="line">vi INSTALL // 查阅安装信息</div><div class="line"></div><div class="line">// 检查configure支持参数，并实际生成makefile规则文件(很重要)</div><div class="line">./configure --help | more</div><div class="line"></div><div class="line">./configure --prefix=/usr/local/ntp \</div><div class="line">--enable-all-clocks --enable-parse-clocks //开始建立makefile（设置了安装目录等）</div><div class="line"></div><div class="line"></div><div class="line">// 开始编译并安装</div><div class="line">make clean; make</div><div class="line">make check</div><div class="line">make install</div></pre></td></tr></table></figure></p>
<h2 id="利用patch更新源码"><a href="#利用patch更新源码" class="headerlink" title="利用patch更新源码"></a>利用patch更新源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 基本语法</div><div class="line">1. patch -p 数字 &lt; patch_file  更新</div><div class="line">2. patch -R &lt; patch_file 还原更新</div><div class="line"></div><div class="line">假如patch_file第一行是***/home/guest/example/expatch.old，</div><div class="line">如果执行patch -p0  &lt; patch_file，则更新的文件是/home/guest/example/expatch.old，</div><div class="line">如果执行patch -p4  &lt; patch_file，则更新的文件是expatch.old，</div><div class="line">基本语法中数字是指拿掉第几个下划线之前的东西（包括下划线）。</div><div class="line"></div><div class="line">在更新之后，还是需要重新编辑，这才是最终的正确的软件。</div></pre></td></tr></table></figure>
<h1 id="RPM安装"><a href="#RPM安装" class="headerlink" title="RPM安装"></a>RPM安装</h1><h2 id="RPM和DPKG"><a href="#RPM和DPKG" class="headerlink" title="RPM和DPKG"></a>RPM和DPKG</h2><p>当前Linux上有两款主流的软件管理程序，分别是：RPM和DPKG。<br>这两款软件均提供在线升级机制。</p>
<ul>
<li><p>RPM</p>
<p>  RPM全称为Red Hat Package Manager，是Red Hat公司研发的Linux软件管理程序。目前CentOS、SuSE、Fedora等操作系统使用它。<br>  RPM使用YUM进行在线升级。</p>
</li>
<li><p>DPKG<br>  dpkg由Debian Linux开发，目前使用该软件的操作系统有Ubuntu、B2D等。<br>  dpkg使用apt-get进行在线升级。</p>
</li>
</ul>
<p>PS：什么是“在线升级机制”？<br>一个软件往往会依赖其他软件的一些功能，那么在安装过程中，只有确保一个软件所依赖的所有软件都被安装后，该软件才能被正确安装。<br>而在线升级机制能够在软件安装过程中，若发现该软件的依赖软件尚未安装，则会自动从互联网中下载所依赖的软件。这就是在线升级机制</p>
<h2 id="RPM默认安装的路径"><a href="#RPM默认安装的路径" class="headerlink" title="RPM默认安装的路径"></a>RPM默认安装的路径</h2><table>
<thead>
<tr>
<th>/etc</th>
<th>一些设置文件放置的目录，例如/etc/crontab</th>
</tr>
</thead>
<tbody>
<tr>
<td>/usr/bin</td>
<td>一些可执行文件</td>
</tr>
<tr>
<td>/usr/lib</td>
<td>一些程序使用的动态函数库</td>
</tr>
<tr>
<td>/usr/share/doc</td>
<td>一些基本的软件使用手册与帮助文档</td>
</tr>
<tr>
<td>/usr/share/man</td>
<td>一些man page文件</td>
</tr>
</tbody>
</table>
<h2 id="RPM安装-1"><a href="#RPM安装-1" class="headerlink" title="RPM安装"></a>RPM安装</h2><p>因为安装软件是root的工作，所以你必须是root用户才能使用rpm命令，使用范例如下(例子为安装rp-pppoe-3.5-32.1.i386.rpm)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 安装软件是，显示安装信息与进度</div><div class="line">rpm -ivh rp-pppoe-3.5-32.1.i386.rpm</div></pre></td></tr></table></figure></p>
<h2 id="RPM的升级与更新"><a href="#RPM的升级与更新" class="headerlink" title="RPM的升级与更新"></a>RPM的升级与更新</h2><p>范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rpm -Uvh 需要升级的软件名</div><div class="line"></div><div class="line">-Uvh:若待升级的软件尚未安装，则直接安装</div><div class="line"></div><div class="line">rpm -Fvh 需要升级的软件名</div><div class="line"></div><div class="line">-Fvh:若待升级的软件尚未安装，则该软件不会被安装</div></pre></td></tr></table></figure></p>
<h2 id="RPM查询"><a href="#RPM查询" class="headerlink" title="RPM查询"></a>RPM查询</h2><p>查询的信息分为两类，一类是查询已被安装的软件的信息(由/var/lib/rpm提供)，另一类是查询尚未被安装的软件安装包的信息。 第一类信息通过rpm -q查询，第二类信息通过rpm -qp查询。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 1. 找出你的Linux是否安装logrotate这个软件</div><div class="line">rpm -q logrorate</div><div class="line"></div><div class="line">// 2. 列出logrotate这个软件所提供的所有目录与文件</div><div class="line">rpm -ql logrorate</div><div class="line"></div><div class="line">// 3. 列出logrotate这个软件的相关文件说明</div><div class="line">rpm -qi logrorate</div><div class="line"></div><div class="line">// 4. 列出logrotate这个软件的设置文件与帮助文件</div><div class="line">rpm -qc logrorate</div><div class="line">rpm -qd logrorate</div><div class="line"></div><div class="line">// 5. 列出logrotate这个软件所依赖软件的文件</div><div class="line">rpm -qR logrorate</div><div class="line"></div><div class="line">// 6. 列出该文件属于哪一个软件</div><div class="line">rpm -qf /bin/sh</div></pre></td></tr></table></figure></p>
<h2 id="卸载RPM与重建数据库"><a href="#卸载RPM与重建数据库" class="headerlink" title="卸载RPM与重建数据库"></a>卸载RPM与重建数据库</h2><p>卸载一个软件非常方便，通过-e即可删除。但一个软件所提供的动态函数库被其他软件引用，那么该软件将无法卸载，除非将引用该函数库的所有软件都卸载后才能卸载。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 找出与pam有关的软件名称，并尝试删除pam这个软件</div><div class="line">rpm -qa | grep pam</div><div class="line">rpm -e pam（出错，因为你需要先删除依赖它的软件）</div><div class="line"></div><div class="line">2. 删除pam-devel软件</div><div class="line">rpm -e pam-devel (成功)</div></pre></td></tr></table></figure></p>
<p>当/var/lib/rpm内的文件发生损坏时，可以通过如下命令重建数据库修复：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm --rebuilddb</div></pre></td></tr></table></figure></p>
<h1 id="YUM安装"><a href="#YUM安装" class="headerlink" title="YUM安装"></a>YUM安装</h1><p>RPM虽然省去了编译过程，并且提供数据库存储软件的信息，但仍然需要我们手动下载RPM安装包，而YUM的出现解决了这一问题。较多软件的RPM安装包都存放在了YUM Server上，只要我们的计算机能连互联网，就能使用yum自动下载RPM安装包并安装软件。</p>
<h2 id="yum功能"><a href="#yum功能" class="headerlink" title="yum功能"></a>yum功能</h2><p>yum的使用非常简单，就是通过yum这个命令，用法范例如下：</p>
<ol>
<li><p>查询功能</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 1. 搜索磁盘阵列相关的软件</div><div class="line">yum search raid</div><div class="line"></div><div class="line">// 2. 找出mdadm这个软件的功能如何</div><div class="line">yum info mdadm</div><div class="line"></div><div class="line">// 3. 列出yum服务器上面提供的所有软件名称</div><div class="line">yum list</div><div class="line"></div><div class="line">// 4. 列出目前服务器上可供本机升级的软件有哪些</div><div class="line">yum list updates</div><div class="line"></div><div class="line">// 5. 列出提供passwd这个文件的软件有哪些</div><div class="line">yum provides passwd</div></pre></td></tr></table></figure>
</li>
<li><p>安装/升级功能</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 安装/升级pam-devel</div><div class="line">yum install/update pam-devel</div></pre></td></tr></table></figure>
</li>
<li><p>删除功能</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 删除pam-devel</div><div class="line">yum remove pam-devel</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="管理的选择：RPM-or-Tarball"><a href="#管理的选择：RPM-or-Tarball" class="headerlink" title="管理的选择：RPM or Tarball"></a>管理的选择：RPM or Tarball</h1><p>建议如下：</p>
<ol>
<li>优先选择原厂的RPM功能</li>
<li>选择软件官方网站发布的RPM或者是提供的容器网址（yum server）</li>
<li>利用Tabball安装特殊软件（没有RPM）</li>
<li>用Tarball测试新版软件</li>
</ol>
<p>RPM与Tarball各有优点，但是如果有RPM的话，优先选择RPM。如果无法解决依赖性问题，那就选tarball。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：当你拿到一台新电脑的第一反应是什么，当然是装软件，然后好好玩呀！服务器也是如此，所以你必须掌握软件的安装。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_daemon为服务(service)保驾护航</title>
    <link href="http://bestlixiang.site/2018/04/03/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_daemon%E4%B8%BA%E6%9C%8D%E5%8A%A1(service)%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA/"/>
    <id>http://bestlixiang.site/2018/04/03/走进Linux/走进Linux_daemon为服务(service)保驾护航/</id>
    <published>2018-04-03T08:59:47.000Z</published>
    <updated>2018-04-09T04:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：我们进程会听到daemon，但是却不知道其义，其实就是一个守护进程，作用是支持其他服务(service)的运行。我们下面可以好好看看linux中的daemon与service！<a id="more"></a></p>
<h1 id="什么是daemon与服务"><a href="#什么是daemon与服务" class="headerlink" title="什么是daemon与服务"></a>什么是daemon与服务</h1><p>系统为了某些功能必须要提供一些服务，这个服务就称为<strong>service</strong>。但是service的提供总是需要进程的运行，所以实现这个service的程序我们就称它为<strong>daemon</strong>。</p>
<h2 id="daemon的分类"><a href="#daemon的分类" class="headerlink" title="daemon的分类"></a>daemon的分类</h2><p>分类方式一：按照“是否可以独立启动”分类</p>
<ol>
<li>stand alone类型的daemon：这种类型的daemon可以自行启动，启动之后可以常驻内存，直到手动关闭该daemon才释放资源。如www。</li>
<li>由super daemon管理的daemon：这种类型的daemon由super daemon统一管理，当请求到来时，由super daemon启动请求的服务，请求完成后便释放内存资源。如telnet。</li>
</ol>
<p>分类方式二：按照“请求到来时是否能够立即运行”分类</p>
<ol>
<li><p>signal-control类型的daemon<br>这种类型的daemon当有请求到来时便能立即执行。如打印机服务。</p>
</li>
<li><p>interval-control类型的daemon<br>这种类型的daemon会周期性地执行某项工作，因此它没有请求一说，它会周期性地读取配置文件，并执行配置文件中要求的功能。如crond、atd都属于interval-control类型的daemon。</p>
</li>
</ol>
<p>通常在服务的名称的之后都会加一个d。</p>
<h2 id="网络服务与端口的对应"><a href="#网络服务与端口的对应" class="headerlink" title="网络服务与端口的对应"></a>网络服务与端口的对应</h2><p>当系统提供了网络服务，就会涉及到端口的问题，这些服务与端口的定义文件在/etc/services。大家可以自己查看一下。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tcpmux          1/tcp                           # TCP port service multiplexer</div><div class="line">tcpmux          1/udp                           # TCP port service multiplexer</div></pre></td></tr></table></figure></p>
<p>第一列为daemon的名称，第二列为该daemon所使用的端口号与网络数据包协议。</p>
<h2 id="daemon的启动脚本与启动方式"><a href="#daemon的启动脚本与启动方式" class="headerlink" title="daemon的启动脚本与启动方式"></a>daemon的启动脚本与启动方式</h2><p>stand-alone类型的daemon和super daemon类型的daemon有各自的启动方式</p>
<h3 id="stand-alone型Daemon的启动方式"><a href="#stand-alone型Daemon的启动方式" class="headerlink" title="stand alone型Daemon的启动方式"></a>stand alone型Daemon的启动方式</h3><ol>
<li><p>通过/etc/init.d/xxx启动。启动一个服务是一个繁琐的过程，你需要进行一系列启动前的操作，为了避免这些麻烦，服务提供商把这些繁琐的过程封装在一个shell srcipt中，我们只需执行一个shell script即可启动一个daemon。几乎所有的stand alone型daemon的启动脚本都放在/etc/init.d/下，所以我们只需执行 <strong>/etc/init.d/xxx start</strong> 即可启动xxx服务。</p>
</li>
<li><p>通过service命令启动。若每次启动一个命令都要写/etc/init.d/略微有些麻烦，service命令将其进行了封装，我们只要执行 <strong>“service xxx start/status/restart/stop”</strong> 即可开启/查看/重启/关闭xxx服务。</p>
</li>
</ol>
<h3 id="super-daemon型Daemon的启动方式"><a href="#super-daemon型Daemon的启动方式" class="headerlink" title="super daemon型Daemon的启动方式"></a>super daemon型Daemon的启动方式</h3><ol>
<li><p>设置daemon的配置文件，每一个被super daemon管理的daemon都有一个配置文件，在/etc/xinetd.d/目录下。每个daemon的开启或关闭均在该daemon对应的配置文件中设置。</p>
</li>
<li><p>启动super daemon，super daemon是一个stand alone型daemon，因此在daemon的配置文件设置好后可通过<strong>service xinetd start</strong>启动所有由super daemon管理的daemon。</p>
</li>
</ol>
<h1 id="解析super-daemon的配置文件"><a href="#解析super-daemon的配置文件" class="headerlink" title="解析super daemon的配置文件"></a>解析super daemon的配置文件</h1><h2 id="默认值配置文件：xinetd-conf"><a href="#默认值配置文件：xinetd-conf" class="headerlink" title="默认值配置文件：xinetd.conf"></a>默认值配置文件：xinetd.conf</h2><p>高版本的contos可能没有该文件，是因为没有安装，所以要先用“yum install xinetd”安装之后，就可以看见了。</p>
<p>super daemon的默认配置文件为:/etc/xinetd.conf，它为它所管理的所有daemon做了一些默认的配置。<br>从最后一行的includedir /etc/xinetd.d可以看出，它加载了它所管理的所有daemon的配置。</p>
<p>下面来看一下具体的某个daemon的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">service rsync #service后为daemon的名字</div><div class="line">&#123;</div><div class="line">        disable = yes  # yes表示关闭此daemon，no表示开启此daemon</div><div class="line">        socket_type     = stream #stream表示使用TCP、dgram表示使用UDP、raw表示直接与IP交互</div><div class="line">        wait            = no</div><div class="line">        user            = root #以什么用户的身份启动这个daemon</div><div class="line">        server          = /usr/bin/rsync #这个daemon的启动程序</div><div class="line">        server_args     = --daemon #启动时所需的参数</div><div class="line">        log_on_failure  += USERID # 登录失败时需要记录用户</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>=：表示将某个参数设为等号右侧的值，若先前设置中已设置过该参数，则直接覆盖</li>
<li>+=：表示保留先前设置的这个参数，再给这个参数增加个值。</li>
<li>-和-=的含义同上。</li>
</ul>
<h1 id="super-deamon的防火墙管理"><a href="#super-deamon的防火墙管理" class="headerlink" title="super deamon的防火墙管理"></a>super deamon的防火墙管理</h1><p>由于受super daemon管理的daemon的请求都首先需要经过super daemon，因此super daemon可以充当防火墙的角色，拒绝一些不安全的请求。<br>super daemon提供了两种防火墙机制，第一种方式提供较多详细的安全设置，而第二种方式只能阻挡或允许指定的IP，具体见下：</p>
<ol>
<li><p>使用受super daemon管理的daemon的配置文件实现防火墙机制</p>
<p> 在某个具体的daemon配置文件中添加如下参数，即可为daemon配置防火墙：</p>
<ul>
<li>instance=数字/UNLIMITED：设置该daemon能够承受的最大连接数。`  </li>
<li>per_source=数字/UNLIMITED：每个IP的最大连接数。</li>
<li>Cps=数字1 数字2：该daemon在一秒内的连接数超过数字1，则暂时关闭该da* emon数字2的秒数。</li>
<li>log_on_success/failure=PID/HOST/USERID/EXIT/DURATION：当登录成功/* 失败时记录的信息。HOST：连接者的IP、EXIT：离开时间、DURATION：为该用户服务的时间。</li>
<li>redirect=IP：将用户的请求转至指定服务器。</li>
<li>bind=IP：允许用户用哪个IP访问本服务。<br>only_from=[0.0.0.0,192.168.1.0:24]：只允许指定IP的用户访问。0.0.0.0表示允许所有用户，192.168.1.0:24表示只允许192.168.1.1－192.168.1.255之间的用户访问。<br>access_time=00:00-12:00：只允许该时间段内访问。</li>
</ul>
</li>
<li><p>使用xinetd提供的/etc/hosts.allow和/etc/hosts.deny实现防火墙机制</p>
<ul>
<li><p>/etc/hosts.allow ：我们可以在该文件中设置允许访问的IP</p>
</li>
<li><p>/etc/hosts.deny ：我们可以在该文件中设置不允许访问的IP</p>
</li>
</ul>
</li>
</ol>
<h1 id="系统开启的服务"><a href="#系统开启的服务" class="headerlink" title="系统开启的服务"></a>系统开启的服务</h1><h2 id="查看系统启动的服务"><a href="#查看系统启动的服务" class="headerlink" title="查看系统启动的服务"></a>查看系统启动的服务</h2><p>一般情况下，我们会比较关心网络监听的服务，所以都会使用netstat命令(之前也提到过)，这里再次说明几个范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 1. 找出目前系统开启的网络服务</div><div class="line">netstat -tulp</div><div class="line"></div><div class="line">// 2. 找出所有有监听网络的服务</div><div class="line">netstat -lnp</div><div class="line"></div><div class="line">// 3. 查看所有的服务状态</div><div class="line"> service --status-all</div></pre></td></tr></table></figure></p>
<h2 id="设置Daemon开启启动"><a href="#设置Daemon开启启动" class="headerlink" title="设置Daemon开启启动"></a>设置Daemon开启启动</h2><p>在设置Daemon开机启动之前，最好先了解一下Linux主机是怎么开机的？</p>
<ol>
<li>打开计算机电源，开始读取BIOS并进行主机的自我测试</li>
<li>通过BIOS取得第一个可开机设备，读取主要开机区(MBR)取得启动装载程序</li>
<li>通过启动装载程序的设置，取得kernel并加载内存且检测系统硬件</li>
<li>内核主动调用init进程</li>
<li>init进程开始执行系统初始化(/etc/rc.d/rec.sysinit)</li>
<li>依据init的设置进行daemonstart(/etc/rc.d/rc[0-6].d/*)</li>
<li>加载本机设置</li>
</ol>
<p>在启动Linux系统时，可以进入不同的模式，这模式我们称为执行等级(run level)，不同执行等级有不同的功能与服务。图型界面为run level5，纯文本界面为run level3。当我们想要知道哪些服务默认可以启动，这就需要下面的命令来查询:</p>
<ol>
<li><p>chkconfig：管理系统服务<strong>默认开机启动与否</strong>，范例如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 1. 列出目前系统上面所有被chkconfig管理的服务</div><div class="line">chkconfig --list | more // 分为两个块，分别为两种启动方式的daemon</div><div class="line"></div><div class="line">// 2. 显示目前在run level 3 启动的服务</div><div class="line">chkconfig --list | grep &apos;2:on&apos;</div><div class="line"></div><div class="line">// 3. 让atd这个服务在run level 3，4，5时启动</div><div class="line">chkconfig --level 345 atd on</div><div class="line"></div><div class="line">// 4. 查看httpd，再查看默认有无启动，之后以chkconfig设置为默认启动</div><div class="line">/etc/init.d/httpd status // 查看本身</div><div class="line">chkconfig --list httpd // 查看是否默认启动</div><div class="line">chconfig httpd on; //设置为开机启动</div></pre></td></tr></table></figure>
<ol>
<li>chkconfig：设置自己的系统服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig [--add|--del] [服务名称] // 该服务必须在/etc/init.d/内</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h1 id="RHEL7的sytemctl（代替service和chkconfig）"><a href="#RHEL7的sytemctl（代替service和chkconfig）" class="headerlink" title="RHEL7的sytemctl（代替service和chkconfig）"></a>RHEL7的sytemctl（代替service和chkconfig）</h1><p>centos7版本中使用了systemd，systemd同时兼容service,对应的命令就是systemctl 。systemctl是RHEL 7 的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。可以使用它永久性或只在当前会话中启用/禁用服务。</p>
<p>systemd把不同的资源称为Unit<br>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit<br>存放目录：/etc/systemd/system和/usr/lib/systemd/system。</p>
<p>使用范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// 1. 以树形列出正在运行的进程，它可以递归显示控制组内容</div><div class="line">systemd-cgls</div><div class="line"></div><div class="line">// 2. 启动一个服务</div><div class="line">systemctl start firewalld.service</div><div class="line"></div><div class="line">// 3. 关闭一个服务</div><div class="line">systemctl stop firewalld.service</div><div class="line"></div><div class="line">// 4. 重启一个服务</div><div class="line">systemctl restart firewalld.service</div><div class="line"></div><div class="line">// 5. 显示一个服务的状态</div><div class="line">systemctl status firewalld.service</div><div class="line"></div><div class="line">// 6. 在开机时启动一个服务</div><div class="line">systemctl enable firewalld.service</div><div class="line"></div><div class="line">// 7. 在开机时禁用一个服务</div><div class="line">systemctl disable firewalld.service</div><div class="line"></div><div class="line">// 8. 查看服务是否开机启动</div><div class="line">systemctl is-enabled  firewalld.service</div><div class="line"></div><div class="line">// 9. 查看已启动的服务列表</div><div class="line">systemctl list-unit-files | grep enabled</div><div class="line"></div><div class="line">// 10. 查看启动失败的服务列表</div><div class="line">systemctl --failed</div><div class="line"></div><div class="line">PS：</div><div class="line">1. 使用命令 systemctl is-enabled firewalld.service 得到的值可以是enable、disable或static，</div><div class="line">     这里的 static 它是指对应的 Unit 文件中没有定义[Install]区域，因此无法配置为开机启动服务。</div><div class="line">2. 启用服务就是在当前“runlevel”的配置文件目录/etc/systemd/system/multi-user.target.wants/里，建立/usr/lib/systemd/system里面对应服务配置文件的软链接；</div><div class="line">  禁用服务就是删除此软链接，添加服务就是添加软连接。</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
<li><a href="https://blog.csdn.net/catoop/article/details/47318225" target="_blank" rel="external">RHEL7的sytemctl（代替service和chkconfig）</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：我们进程会听到daemon，但是却不知道其义，其实就是一个守护进程，作用是支持其他服务(service)的运行。我们下面可以好好看看linux中的daemon与service！
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_认识你的进程</title>
    <link href="http://bestlixiang.site/2018/04/02/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_%E8%AE%A4%E8%AF%86%E4%BD%A0%E7%9A%84%E8%BF%9B%E7%A8%8B/"/>
    <id>http://bestlixiang.site/2018/04/02/走进Linux/走进Linux_认识你的进程/</id>
    <published>2018-04-02T04:58:22.000Z</published>
    <updated>2018-04-09T04:33:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：linux服务器上可以跑很多很多的程序，当然也会遇到很多的问题，所以我们需要学会去管理好它。尤其像ps，top这些命令，你一定会很想去了解它吧！<a id="more"></a></p>
<h1 id="理解进程"><a href="#理解进程" class="headerlink" title="理解进程"></a>理解进程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p><strong>进程：</strong> 一个程序被加载到内存当中运行，那么在内存中的那个数据就被称为进程。</p>
<p>系统也会给予这个进程一个ID，称为<strong>PID</strong>。同时触发这个进程的用户与相关属性关系，给予这个PID一组有效的权限设置。</p>
<h2 id="进程与程序"><a href="#进程与程序" class="headerlink" title="进程与程序"></a>进程与程序</h2><h3 id="程序和进程概念"><a href="#程序和进程概念" class="headerlink" title="程序和进程概念"></a>程序和进程概念</h3><ol>
<li>程序：通常为二进制程序，放置在存储媒介中，以物理文件的形式存在。</li>
<li>进程：程序在触发后，执行者的权限与属性、程序的程序代码与所需数据等都会被加载到内存中，操作系统给予这个内存中的单元一个标识符（PID），可以说，进程就是一个正在运行的程序。</li>
</ol>
<h3 id="子进程与父进程"><a href="#子进程与父进程" class="headerlink" title="子进程与父进程"></a>子进程与父进程</h3><p>举个栗子：当我们登录系统后，会取得一个bash的shell，然后，我们用这个bash提供的接口去执行另一个命令，那些另外执行的命令也会被触发称为PID，那个后来执行命令才产生的PID就是“子进程”，而在我们原本在bash环境下，就称为“父进程”。子进程会具有PPID(父PID)。</p>
<h3 id="fork-and-exec：过程调用的流程"><a href="#fork-and-exec：过程调用的流程" class="headerlink" title="fork and exec：过程调用的流程"></a>fork and exec：过程调用的流程</h3><p>在Linux的过程调用中通常被称为fork and exec的流程，进程都会父进程以复制(fork)的方式产生一个一模一样的子进程（PID不一样），然后被复制出来的子进程再以exec的方式来执行实际要进行的进程，最终称为一个子进程的存在。</p>
<h1 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h1><h2 id="什么是工作管理"><a href="#什么是工作管理" class="headerlink" title="什么是工作管理"></a>什么是工作管理</h2><p><strong>工作管理：</strong> 当我们登录系统取得bash shell之后，在<strong>单一终端机下</strong>同时进行多个工作的行为管理。</p>
<p>下面是前台和后台定义:</p>
<p><strong>前台:</strong> 你可以控制与执行命令的环境</p>
<p><strong>后台：</strong> 可以自行运行的工作，你无法用ctrl + c终止它，但是可以用bg/fg调用该工作的环境</p>
<p>要进行bash的工作管理必须要注意的限制是：</p>
<ul>
<li>这些工作所触发的进程必须要来自你的shell子进程（只管理自己的bash）</li>
<li>后台中“执行”的进程不能等待terminal/shell的输入。</li>
</ul>
<h2 id="job管理"><a href="#job管理" class="headerlink" title="job管理"></a>job管理</h2><p>实际中使用的job控制主要有下面的命令：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 直接将命令丢到后台中“执行”的 &amp;</span></div><div class="line">tar -zpcf /tmp/tec/tar.gz /etc &amp;</div><div class="line"><span class="comment">/*</span></div><div class="line">会出现[1]（工作好） 13456（进程号）</div><div class="line">完成后会输出： [1]   完成                  tar -zpcf /tmp/etc.tar.gz /etc */</div><div class="line"><span class="comment">/*</span></div><div class="line">但是需要注意的是，运行的信息还是会出现在屏幕上，会影响我们正常继续使用，</div><div class="line">所以我们需要利用数据流重定向输入到文件中。*/</div><div class="line"></div><div class="line"><span class="comment">// 2. 将目前的工作丢到后台中“暂停”：ctrl + z</span></div><div class="line">vim ~/.bashrc 按ctrl+z</div><div class="line"><span class="comment">/*</span></div><div class="line">会输出 [2]+  已停止               vim ~/.bashrc */</div><div class="line"></div><div class="line"><span class="comment">// 3. 查看目前的后台工作状态：jobs</span></div><div class="line"></div><div class="line"><span class="comment">// 4. 将后台工作拿到前台来处理：fg</span></div><div class="line">fg %<span class="number">2</span> <span class="comment">//拿出刚刚vim的工作</span></div><div class="line"></div><div class="line"><span class="comment">// 5. 让工作在后台下得状态变成运行中：bg</span></div><div class="line">bg %<span class="number">2</span></div><div class="line"></div><div class="line"><span class="comment">// 6. 管理后台当中的工作：kill</span></div><div class="line">kill -signal %jobnumber/PID/命令</div><div class="line"><span class="comment">/* signal</span></div><div class="line">-1：重新读取一次参数的配置文件</div><div class="line">-2：与ctrl + c一样</div><div class="line">-9：立刻强制删除一个工作，不会删除过程文件</div><div class="line">-15(默认值)：以正常的程序方式终止一项工作，会删除过程文件 */</div></pre></td></tr></table></figure></p>
<h2 id="脱机管理"><a href="#脱机管理" class="headerlink" title="脱机管理"></a>脱机管理</h2><p>如果你是使用&amp;来放置后台工作，当你断开与终端机的连接（脱机），那么后台工作就会被中断掉。如果我们不想这样就可以使用at或者nohup命令，我们主要讲一下nohup的这个命令，这个命令可以让你在脱机或注销系统后，还能够让工作继续进行。范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. 在终端机前台中工作</div><div class="line">nohup 命令</div><div class="line"></div><div class="line">// 1. 在终端机后台工作</div><div class="line">nohup 命令 &amp;</div></pre></td></tr></table></figure></p>
<p>当你使用这个命令之后，你会发现会出现一个nohup.out文件，这个文件其实就是将原本前台显示的东西重定向到这个文件中。</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程的查看"><a href="#进程的查看" class="headerlink" title="进程的查看"></a>进程的查看</h2><h3 id="静态的ps"><a href="#静态的ps" class="headerlink" title="静态的ps"></a>静态的ps</h3><p>PS：如果man page不好查阅，最好是直接被几个常用的参数。</p>
<p>这个命令是将某个时间点的进程运行情况选取下来，主要的范例如下：</p>
<ol>
<li><p>仅查看自己的bash的相关进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">ps -l</div><div class="line"></div><div class="line">/* 输出列子如下：</div><div class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</div><div class="line">4 S     0 10573 10567  0  80   0 - 29064 wait   pts/0    00:00:00 bash</div><div class="line"></div><div class="line">含义如下：</div><div class="line">F：程序标识（process flags），说明程序的权限，4代表root，1代表子程序仅能fork不能exec</div><div class="line"></div><div class="line">S：程序状态（state），主要有R(running)、S(sleep)、D(不可唤醒)、T(stop)、Z（僵尸，命令位会跟&lt;defunct&gt;）</div><div class="line"></div><div class="line">UID/PID/PPID  ：PPID指父程序的PID</div><div class="line"></div><div class="line">C：代表CPU使用率，单位为百分比</div><div class="line"></div><div class="line">PRI/NI：此程序被CPU执行优先级，数值越小程序优先级越高</div><div class="line"></div><div class="line">ADDR/SZ/WCHAN：ADDR代表在内存哪个部分，SZ代表用掉多少内存，WCHAN表示程序是否正在运作</div><div class="line"></div><div class="line">TTY：登陆者的终端机位置，远程登录时为 pts/n</div><div class="line"></div><div class="line">TIME：使用掉的CPU时间，程序实际花费CPU运作时间</div><div class="line"></div><div class="line">CMD：触发程序的指令 */</div></pre></td></tr></table></figure>
</li>
<li><p>查看系统所有进程：ps aux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">ps aux</div><div class="line"></div><div class="line">/* 输出列子如下：</div><div class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</div><div class="line">root         1  0.0  0.1  43156  3136 ?        Ss   3月10   1:27 /usr/lib/systemd/systemd --swi</div><div class="line"></div><div class="line">含义如下：</div><div class="line">USER：该进程属于哪个用户账号</div><div class="line"></div><div class="line">PID  ：进程ID</div><div class="line"></div><div class="line">%CPU：该进程使用掉的CPU资源内存百分比</div><div class="line"></div><div class="line">%MEM：该进程所占用的物理内存百分比</div><div class="line"></div><div class="line">VSZ：该进程使用掉的虚拟内存量（KB）</div><div class="line"></div><div class="line">RSS：该进程占用的固定的内存量（KB）</div><div class="line"></div><div class="line">TTY：登陆者的终端机位置，远程登录时为 pts/n</div><div class="line"></div><div class="line">STAT：与ps -l的S表示相同</div><div class="line"></div><div class="line">START：该进程被触发启动的时间</div><div class="line"></div><div class="line">TIME：程序实际花费CPU运作时间</div><div class="line"></div><div class="line">CMD：该进程的实际命令 */</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="动态的top"><a href="#动态的top" class="headerlink" title="动态的top"></a>动态的top</h3><p>这个命令可以持续的检测进程运行的状态，主要范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 1. 每两秒更新一次top，查看整体信息，默认5秒</div><div class="line">top -d 2</div><div class="line"></div><div class="line">/* 输出例子：</div><div class="line">top - 10:54:10 up 22 days, 19:25,  1 user,  load average: 0.13, 0.07, 0.06</div><div class="line">Tasks:  69 total,   2 running,  66 sleeping,   1 stopped,   0 zombie</div><div class="line">%Cpu(s):  0.5 us,  0.0 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</div><div class="line">KiB Mem :  1883844 total,    77012 free,   356884 used,  1449948 buff/cache</div><div class="line">KiB Swap:        0 total,        0 free,        0 used.  1328820 avail Mem</div><div class="line"></div><div class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                     </div><div class="line"> 1861 root      20   0  608356  12236   1788 S  0.5  0.6  60:48.59 barad_agent</div><div class="line"></div><div class="line"> top见界面主要分为两个界面：</div><div class="line"></div><div class="line"> 上面为整个系统的资源使用状态，基本上总共有六行，显示的内容依次是：</div><div class="line"> 1. 目前的时间，开机到目前为止所经过的时间，已经登录系统的的用户数,系统在1，5，15分钟的平均工作负载</div><div class="line"> 2. 目前进程的总量与各个累呗进程的总量，注意zombie僵尸进程的数量</div><div class="line"> 3. CPU的整体负载，注意wa（I/Owait）</div><div class="line"> 4. 物理内存的使用情况</div><div class="line"> 5. 虚拟内存的使用情况，swap的是用来一定要小</div><div class="line"> 6. 这个是当在top进程中输入命令时显示状态的地方，输入r可修改nice值</div><div class="line"></div><div class="line"> 下面为每个进程使用资源情况，各个参数含义可参照ps。</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<h3 id="进程树pstree"><a href="#进程树pstree" class="headerlink" title="进程树pstree"></a>进程树pstree</h3><p>如果想找到进程之间的相关性，这个pstree就能够很好的帮助我们，它会使用线段将相关性进程连接起来，范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 1.列出目前系统上面所有的进程数的相关性</div><div class="line">pstree -A</div><div class="line">输入如下：</div><div class="line">systemd-+-acpid</div><div class="line">        |-2*[agetty]</div><div class="line">        |-atd</div><div class="line">        |-auditd---&#123;auditd&#125;</div><div class="line">        ...</div><div class="line"></div><div class="line">// 2. 在1的基础上，同时显示出PID与users</div><div class="line">pstree -Aup</div></pre></td></tr></table></figure></p>
<h2 id="进程的执行顺序"><a href="#进程的执行顺序" class="headerlink" title="进程的执行顺序"></a>进程的执行顺序</h2><p>CPU优先处理哪个进程，这就需要考虑到程序的优先执行序(priority)与CPU的调度。具体到值来说就是要考虑到PRI和nice值（之前用top和ps显示过）。<strong>PRI值越低代表越优先</strong>，不过这个PRI值是由内核动态调整的，具有无法调整，但是Nice值我们可以改变。下面的PRI值改变的公式：</p>
<pre><code>PRI(new) = PRI(old) + nice
</code></pre><p>下面是关于nice值的使用范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. 在使用命令的时候设置nice值，给nice值为-5去执行vi</div><div class="line">nice -n vi &amp;</div><div class="line"></div><div class="line">// 2. 已存在进程的nice重新分配，将PID为18625的进程nice值调整到10</div><div class="line">renice 10 18625</div></pre></td></tr></table></figure></p>
<h2 id="系统资源的查看"><a href="#系统资源的查看" class="headerlink" title="系统资源的查看"></a>系统资源的查看</h2><ol>
<li><p>查看内存的使用情况，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 查看目前系统的内存容量</div><div class="line">free -m</div></pre></td></tr></table></figure>
</li>
<li><p>查看系统与内核相关信息，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 1. 输出系统的基本信息</div><div class="line">uname -a</div></pre></td></tr></table></figure>
</li>
<li><p>查看系统启动时间与内存负载，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uptime</div></pre></td></tr></table></figure>
</li>
<li><p>跟踪网络(很重要)，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. 列出目前系统以及新建的网络连接与unix socket状态</div><div class="line">netstat</div><div class="line"></div><div class="line">// 2. 找出目前系统上已在监听的网络连接机及其PID(很重要)</div><div class="line">netstat -tlnp</div></pre></td></tr></table></figure>
</li>
<li><p>分析内核产生的信息，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. 输出所有的内核开机时的信息</div><div class="line">dmesg | more</div><div class="line"></div><div class="line">// 2. 查找开机的时候硬盘的相关信息</div><div class="line">dmesg | grep i hd</div></pre></td></tr></table></figure>
</li>
<li><p>检测系统资源变化，范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 1. 统计目前主机CPU状态，每秒一次，共计三次</div><div class="line">vmstat 1 3</div><div class="line"></div><div class="line">// 2. 系统上面所有磁盘的读写状态</div><div class="line">vmstat -d</div><div class="line"></div><div class="line">PS：详细的各个字段的含义，大家就自己查询man vmstat好了，习惯就好。</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：linux服务器上可以跑很多很多的程序，当然也会遇到很多的问题，所以我们需要学会去管理好它。尤其像ps，top这些命令，你一定会很想去了解它吧！
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_例行性工作(crontab)</title>
    <link href="http://bestlixiang.site/2018/03/31/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_%E4%BE%8B%E8%A1%8C%E6%80%A7%E5%B7%A5%E4%BD%9C(crontab)/"/>
    <id>http://bestlixiang.site/2018/03/31/走进Linux/走进Linux_例行性工作(crontab)/</id>
    <published>2018-03-31T12:35:07.000Z</published>
    <updated>2018-04-09T04:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：系统常常会主动进行一些任务，这依靠的就是设置了例行性工作。<a id="more"></a></p>
<h1 id="什么是例行性工作（定时任务crontab）"><a href="#什么是例行性工作（定时任务crontab）" class="headerlink" title="什么是例行性工作（定时任务crontab）"></a>什么是例行性工作（定时任务crontab）</h1><p>根据单词crontab（定时任务）就可以知道 <strong>例行性工作</strong> 其实就是每天都会干的事。</p>
<h2 id="Linux工作调度的种类"><a href="#Linux工作调度的种类" class="headerlink" title="Linux工作调度的种类"></a>Linux工作调度的种类</h2><ol>
<li>例行性的，就是每隔一定的周期要来办的事，利用crontab实现，这个命令所设置的工作将会循环一直进行下去，可循环的时间为分钟，小时，每周，每月或每年等，crontab除了可以使用命令执行外，也可编辑/etc/crontab来支持。至于让crontab可以生效的后台服务是crond这个服务。</li>
<li>突发性的，就是这次做完以后就没有的事，利用at实现，但是这个必须要有atd后台服务支持才行。</li>
</ol>
<h2 id="Linux上常见的例行性工作"><a href="#Linux上常见的例行性工作" class="headerlink" title="Linux上常见的例行性工作"></a>Linux上常见的例行性工作</h2><ol>
<li>进行日志文件的轮替，让旧的数据和新的数据分开存放</li>
<li>日志文件分析logwatch的任务</li>
<li>新建locate的数据库，系统会主动进行updatedb</li>
<li>whatis数据库的建立</li>
<li>删除临时文件</li>
</ol>
<h1 id="仅执行一次的工作调度：at"><a href="#仅执行一次的工作调度：at" class="headerlink" title="仅执行一次的工作调度：at"></a>仅执行一次的工作调度：at</h1><h2 id="at的运行方式"><a href="#at的运行方式" class="headerlink" title="at的运行方式"></a>at的运行方式</h2><p>我们使用at这个命令来生成所要进行的工作，并将这个工作以文本文件的方式写入/var/spool/at目录中，该工作便能等待atd这个服务的取用与执行了。但是并不是所有的人都可以进行at工作调度工作的，因为安全。我们可以利用/etc/at.allow与/etc/at.deny这两个文件进行at的使用限制，加上这两个文件后，at的工作情况其实是这样的：</p>
<ol>
<li>先寻找/etc/at.allow这个文件，写在这个文件中的用户才能使用at，没有在这个文件中的用户则不能使用at(即时没有写在at.deny当中)</li>
<li>如果/etc/at.allow不存在，就寻找/etc/at.deny这个文件，若卸载这个at.deny的用户则不能使用at，而没有在这个文件中的用户就可以使用at了</li>
<li>如果这两个文件都不存在，那么就只有root可以使用at这个命令</li>
</ol>
<h2 id="实际运行单一工作调度"><a href="#实际运行单一工作调度" class="headerlink" title="实际运行单一工作调度"></a>实际运行单一工作调度</h2><p>单一工作调度的进行就使用at这个命令，这个命令的运行十分简单！将at加上一个时间即可！范例入下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1. at [-mldv] TIME</div><div class="line">at noe + 5 minutes // 再过五分钟执行，接下来输入执行的命令，使用ctrl  + d 结束。</div><div class="line"></div><div class="line">// 2. at -c 工作号码 // 将第几号工作调出来查看</div><div class="line">at -c 1 // 将第一号工作调出来</div></pre></td></tr></table></figure></p>
<p>事实上，当我们使用at时会进入一个at shell的环境来让用户执行工作命令，此时，建议你最好使用绝对路径来执行你的命令，比较不会有问题。</p>
<p>at还有一个很棒的优点就是<strong>后台执行的功能</strong>，和nohup类似。</p>
<p><strong>at的工作管理</strong> 主要是利用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 查询目前主机上面有多少的at工作调度</div><div class="line">atq</div><div class="line"></div><div class="line"># 将第3个工作删除</div><div class="line">atrm 3</div></pre></td></tr></table></figure></p>
<h1 id="循环执行的例行性工作调度"><a href="#循环执行的例行性工作调度" class="headerlink" title="循环执行的例行性工作调度"></a>循环执行的例行性工作调度</h1><p>相对于at是仅执行一次的工作，循环执行的例行性工作调度室友crond这个系统服务来控制的，由于Linux系统上原本就有很多的例行性工作，所以这个系统服务是默认开启的。另外，由于用户自己也可以进行例行性工作调度，所以，Linux可提供用户控制例行性工作调度的命令（crontab）。</p>
<h2 id="用户的设置与使用"><a href="#用户的设置与使用" class="headerlink" title="用户的设置与使用"></a>用户的设置与使用</h2><p>为了安全性的问题，与at类似，我们可以限制使用crontab的用户账号。使用的限制数据有：</p>
<ul>
<li>/etc/cron.allow：将可以使用crontab的账号写入其中，若不在这个文件内的用户则不可使用crontab。</li>
<li>/etc/cron.deny：将不可以使用crontab的账号写入其中，若为记录到这个文件中的用户，就可以使用crontab。</li>
</ul>
<p>以优先级来说，/etc/cron.allow比/etc/cron.deny要优先，而判断上面，两个文件只选择一个来限制而已，因此，建议你只要保留一个即可。</p>
<p>当用户使用crontab这个命令来新建工作调度之后，该项工作就会被记录/var/spool/cron/里面，而且是以账号来区分的。另外，cron执行的每一项工作都会被记录到/var/log/cron这个日志文件中，所以，如果你的Linux不知道是否被植入密码，也可以查询一下这个日志文件。</p>
<p>下面是它的使用范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 1. 用root的身份在每天的12:00和14:00查看主文件夹目录ß</div><div class="line"># 编辑crontab的工作内容</div><div class="line">crontab -e</div><div class="line"># 进入vi界面，每项工作都是一行</div><div class="line">0 12,14 * * * ls /  // 解释各列含义：</div><div class="line">// 1. 分；2. 小时；3. 日期；4. 月份; 5. 周； 6. 命令</div><div class="line">// 其中“,”表示分割时段，“-”表示一段时间范围，/n 表示每隔n单位间隔</div><div class="line"></div><div class="line">// 2. 查询crontab任务</div><div class="line">crontab -l</div><div class="line"></div><div class="line">// 3. 若要删除一项工作，必须要用crontab -e去编辑，如果想要删除全部工作，如下：</div><div class="line">crontab -r</div></pre></td></tr></table></figure></p>
<h2 id="系统的配置文件：-etc-crontab"><a href="#系统的配置文件：-etc-crontab" class="headerlink" title="系统的配置文件：/etc/crontab"></a>系统的配置文件：/etc/crontab</h2><p>crontab -e是针对用户的例行性工作来设计的，如果我们要修改系统的例行性任务，就需要编辑/etc/crontab了。</p>
<p>基本上，cron这个服务的最低检测限制是“分钟”，所以cron会每分钟去读取一次/etc/crontab与/var/spool/cron里面的数据内容。</p>
<h1 id="可唤醒停机期间的工作任务"><a href="#可唤醒停机期间的工作任务" class="headerlink" title="可唤醒停机期间的工作任务"></a>可唤醒停机期间的工作任务</h1><p>如果例行性工作是在凌晨4点运行的，但是刚好关机了， 你7点开机了，你总不能不管它吧，这就需要用到anacron。</p>
<h2 id="什么是anacron"><a href="#什么是anacron" class="headerlink" title="什么是anacron"></a>什么是anacron</h2><p><strong>anacron存在的目的</strong> 是处理非24小时一直启动的linux系统的crontab的执行。</p>
<p>anacron也是通过crontab来运行的，因此anacron的运行的时间通常有两个，一是系统开机期间运行，一个是写入crontab的调度中。</p>
<h2 id="anacron使用"><a href="#anacron使用" class="headerlink" title="anacron使用"></a>anacron使用</h2><p>anacron的语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">anacron [-sfn] [job]</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：系统常常会主动进行一些任务，这依靠的就是设置了例行性工作。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_账号管理</title>
    <link href="http://bestlixiang.site/2018/03/31/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/"/>
    <id>http://bestlixiang.site/2018/03/31/走进Linux/走进Linux_账号管理/</id>
    <published>2018-03-31T05:15:52.000Z</published>
    <updated>2018-04-09T04:34:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：管理员的工作中，相对重要的一环就是“账号管理”。因为整个系统都是你在管理，并且所有的一般用户的账号申请必须要通过你的协助才行。所以我们必须要知道如果管理好一个服务器主机的账号！<a id="more"></a></p>
<h1 id="账号与用户组"><a href="#账号与用户组" class="headerlink" title="账号与用户组"></a>账号与用户组</h1><p>在管理Linux账号时，我们必须要先了解一下Linux到底是如何辨别每一个用户的。</p>
<h2 id="用户表示符：UID与GID"><a href="#用户表示符：UID与GID" class="headerlink" title="用户表示符：UID与GID"></a>用户表示符：UID与GID</h2><p>虽然我们登录Linux主机的时候，输入的是我们的账号，但是其实Linux主机并不会直接认识你的账号，它仅认识ID，而你的ID域账号的对应关系就在/etc/passwd当中。</p>
<p>每一个文件都具有<strong>所有者与所属用户组</strong>的属性，所以每个登录的用户至少会取得两个ID，一个是用户ID(UID)，一个是用户组ID(GID)。</p>
<h2 id="用户账号"><a href="#用户账号" class="headerlink" title="用户账号"></a>用户账号</h2><p>Linyx系统上面的用户如果需要登录主机以取得shell的工作环境，它必须要在计算机前面利用tty1~tty7的终端机提供的login接口，并输入账号与密码后才能登录。当我们输入账号密码后，系统主要做了如下工作：</p>
<ol>
<li>先寻找/etc/passwd里面是否有你输入的帐号？如果没有则跳出，如果有的话则将该帐号对应的UID与GID（在/etc/group中）读出来，另外，该帐号的主文件夹与shell设定也一并读出。</li>
<li>再来则是核对密码表啦！这是Linux会进入/etc/shadow里面找出对应的帐号与UID，然后核对一下你刚刚输入的密码与里面的密码是否相符。</li>
<li>如果一切都OK的话，就进入Shell控管的阶段咯！</li>
</ol>
<ul>
<li><p>/etc/passwd文件结构如下：</p>
<p>  这个文件的构造是这样的：每一行代表一个帐号，有几行就代表有几个帐号在你的系统中！不过需要特别留意的是，里头很多帐号本身就是系统正常运作所必须要的，我们可以简称为<strong>系统帐号</strong>，如bin，daemon，adm，nobody等。</p>
<p>  我们先来看一下每个Linux系统都会有的第一行，就是root这个系统管理员那一行好了，你可以明显的看出来，每一行使用：分隔，共有七个字段，分别是</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>字段号</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>    1</td>
<td>账号名称</td>
</tr>
<tr>
<td>    2</td>
<td>密码，被该放到/etc/shadow文件中，以x代替</td>
</tr>
<tr>
<td>    3</td>
<td>UID，0为系统管理员，可以多个账号的UID为0，但不建议。1~99为发现版自建系统账号，100~499为用户使用的系统账号，500~*为一般用户可登录账号</td>
</tr>
<tr>
<td>    4</td>
<td>密码，GID，与/etc/group有关</td>
</tr>
<tr>
<td>    5</td>
<td>用户信息说明</td>
</tr>
<tr>
<td>    6</td>
<td>主文件夹</td>
</tr>
<tr>
<td>    7</td>
<td>shell</td>
</tr>
</tbody>
</table>
<ul>
<li><p>/etc/shadow文件结构如下：</p>
<p>  文件构造基本与/etc/passwd一样，但是它有9个字段，分别是：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>字段号</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>    1</td>
<td>账号名称，需要与/etc/passwd对应</td>
</tr>
<tr>
<td>    2</td>
<td>密码，但是被加密过的</td>
</tr>
<tr>
<td>    3</td>
<td>最近更改密码的日期，以1970年1月1号作为1而累加的日期</td>
</tr>
<tr>
<td>    4</td>
<td>密码不可被更动的日期</td>
</tr>
<tr>
<td>    5</td>
<td>密码需要重新更改的天数</td>
</tr>
<tr>
<td>    6</td>
<td>密码需要更改期限前的警告天数</td>
</tr>
<tr>
<td>    7</td>
<td>密码过期后的账号宽限时间（密码失效日）</td>
</tr>
<tr>
<td>    8</td>
<td>账号失效日期</td>
</tr>
<tr>
<td>    9</td>
<td>保留，用于以后扩展</td>
</tr>
</tbody>
</table>
<h2 id="有效与初始用户组：groups，newgrp"><a href="#有效与初始用户组：groups，newgrp" class="headerlink" title="有效与初始用户组：groups，newgrp"></a>有效与初始用户组：groups，newgrp</h2><ul>
<li><p>/etc/group文件结构如下：</p>
<p>  文件构造基本与/etc/passwd一样，但是它有4个字段，分别是：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>字段号</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>    1</td>
<td>用户组名称</td>
</tr>
<tr>
<td>    2</td>
<td>用户组密码，以x代替</td>
</tr>
<tr>
<td>    3</td>
<td>GID，/etc/passwd第四个字段使用的GID对应的用户组名就是由这里来的</td>
</tr>
<tr>
<td>    4</td>
<td>用户组支持的账号名称，多用户以”,”分割</td>
</tr>
</tbody>
</table>
<pre><code>我们知道用户可以同时加入多个用户组，那么我们在执行工作时，到底是以哪个用户组为准呢？，这就需要引入有效用户组的概念。    
</code></pre><ul>
<li><p>/etc/gshadow文件结构如下：</p>
<p>  文件构造基本与/etc/group一样，它有4个字段，分别是：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>字段号</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>    1</td>
<td>用户组名称</td>
</tr>
<tr>
<td>    2</td>
<td>用户组密码,开头为!表示无合法密码，所以无用户组管理员</td>
</tr>
<tr>
<td>    3</td>
<td>用户组管理员的账号，用户组管理员能够将账号添加到自己管理的用户组中</td>
</tr>
<tr>
<td>    4</td>
<td>该用户组的所属账号（与/etc/group内容相同）</td>
</tr>
</tbody>
</table>
<ul>
<li>有效用户组与初始用户组<ul>
<li>初始用户组：就是/etc/passwd里面的第四列的GID，当用户登录系统，立刻就拥有这个用户组的相关权限。</li>
<li>有效用户组：就是利用groups命令看到的第一个用户组，可以利用newgrp命令更改有效用户组，newgrp命令更改目前用户的有效用户组是以另一个shell来提供这个功能的，如果要回到原来的用户组只要输入exit即可。</li>
</ul>
</li>
</ul>
<h1 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h1><p>管理账号主要是新增、删除与更改用户的相关信息。</p>
<h2 id="新增与删除用户"><a href="#新增与删除用户" class="headerlink" title="新增与删除用户"></a>新增与删除用户</h2><p>账号可以使用useradd命令来新建用户，密码的给予则是使用passwd命令。下面是范例：（里面有很多参数，自己可以去了解）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 新增</div><div class="line">useradd leonard</div><div class="line">ll -d /home/leonard/</div><div class="line"><span class="meta">#</span> 默认会创建用户主文件夹，且权限为700，这是重点</div><div class="line"><span class="meta">#</span> drwx------ 2 leonard leonard 4096 3月  31 09:36 /home/leonard/</div><div class="line"></div><div class="line">grep leonard /etc/passwd /etc/shadow /etc/group</div><div class="line"><span class="meta">#</span> /etc/passwd:leonard:x:1001:1001::/home/leonard:/bin/bash</div><div class="line"><span class="meta">#</span> /etc/shadow:leonard:!!:17621:0:99999:7:::</div><div class="line"><span class="meta">#</span> /etc/group:leonard:x:1001:</div><div class="line"><span class="meta"></span></div><div class="line"># 不加账号，默认修改自己的密码</div><div class="line">passwd leonard</div><div class="line"><span class="meta"></span></div><div class="line"># 显示账号的相关信息</div><div class="line">chage leonard</div><div class="line"><span class="meta"></span></div><div class="line"># 修改账号的相关信息</div><div class="line">usermod leonard</div><div class="line"><span class="meta"></span></div><div class="line"># 删除账号，-r：连主文件夹一起删除</div><div class="line">userdel leonard</div></pre></td></tr></table></figure></p>
<p>其实系统已经帮我们设置好了非常多的默认值，所以我们可以简单的使用“useradd 账号”来创建用户，Centos这些默认值主要会帮我们处理下面几个项目：</p>
<ul>
<li>在/etc/passwd 里面创建一行与账号相关的数据，包括创建UID/GID/主文件夹等；</li>
<li>在/etc/shadow里面将此账号的密码相关参数填入，但是尚未有密码；</li>
<li>在/etc/group里面加入一个与账号名称一模一样的组名；</li>
<li>在/home下面创建一个与账号同名的目录作为用户的主文件夹，且权限为700</li>
</ul>
<h2 id="用户功能"><a href="#用户功能" class="headerlink" title="用户功能"></a>用户功能</h2><p>不论是useradd、usermod还是userdel，那都是系统管理员能够使用的命令，下面我们就介绍一些一般身份用户常用的账号数据更改与查询命令</p>
<ul>
<li><p>finger，可以查阅很多用户相关的信息，大部分都是/etc/passwd这个文件的信息。范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 我的linux默认没有装finger，可以利用下面的命令安装</div><div class="line">yum install finger</div><div class="line"></div><div class="line">// 查阅用户信息，若不跟没有用户，则查询当前用户</div><div class="line">finger rex</div></pre></td></tr></table></figure>
</li>
<li><p>chfn(change finger)，用于修改一些相关信息,范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">chfn rex</div><div class="line">Changing finger information for rex.</div><div class="line">名称 []: rex</div><div class="line">办公 []: 123456</div><div class="line">办公电话 []: 123456</div><div class="line">住宅电话 []: 123456</div></pre></td></tr></table></figure>
</li>
<li><p>chsh(change shell)，用于修改shell。</p>
</li>
<li>id，用于查询自己或某人的相关UID/GID等信息。</li>
</ul>
<h2 id="新增与删除用户组"><a href="#新增与删除用户组" class="headerlink" title="新增与删除用户组"></a>新增与删除用户组</h2><p>基本上，用户组的内容都与这两个文件有关：/etc/group,/etc/gshadow。下面是一些相关命令使用的范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># 新建一个用户组，名称为hd</div><div class="line">groupadd hd</div><div class="line"></div><div class="line"># 修改用户组的相关参数 -g：修改既有GID，-n：修改既有组名</div><div class="line">groupmod -g 201 -n myhd hd</div><div class="line"></div><div class="line"># 删除用户组名</div><div class="line">groupdel myhd</div><div class="line"></div><div class="line"># 用户组管理员相关命令</div><div class="line"># 给用户组设置一个密码</div><div class="line">gpasswd hd</div><div class="line"># 加入用户组管理员为rex</div><div class="line">gpasswd -A rex hd</div><div class="line"># 让rex登录系统，增加leonard为hd成员</div><div class="line">gpasswd -a leonard hd</div></pre></td></tr></table></figure></p>
<h1 id="主机的具体权限规划：ACL的使用"><a href="#主机的具体权限规划：ACL的使用" class="headerlink" title="主机的具体权限规划：ACL的使用"></a>主机的具体权限规划：ACL的使用</h1><h2 id="什么是ACL"><a href="#什么是ACL" class="headerlink" title="什么是ACL"></a>什么是ACL</h2><p>ACL是Access Control List的缩写，主要的目的是提供传统的owner、group、others的read、write、execute权限之外的具体权限设置。ACL可以针对单一用户、单一文件或目录进行r、w、x的权限设置，对于需要特殊权限的使用状况非常有帮助。</p>
<p>ACL主要可以针对下面几方面来设置控制权限：</p>
<ul>
<li>用户：可以针对用户来设置权限</li>
<li>用户组：可以针对用户组来设置权限</li>
<li>默认属性（mask）：还可以在该目录下新建文件目录设置新数据的权限、</li>
</ul>
<h2 id="ACL的设置技巧"><a href="#ACL的设置技巧" class="headerlink" title="ACL的设置技巧"></a>ACL的设置技巧</h2><ol>
<li>getfacl：取得某个文件/目录的ACL设置项目</li>
<li>setfacl：设置某个文件/目录的ACL规定</li>
</ol>
<p>下面是范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 取得某个文件/目录的ACL设置项目</div><div class="line">getfacl rootfile</div><div class="line"></div><div class="line">// 输出</div><div class="line"># file: rootfile</div><div class="line"># owner: root</div><div class="line"># group: root</div><div class="line">user::rw-</div><div class="line">group::r--</div><div class="line">other::r--</div><div class="line"></div><div class="line">// 设置某个文件/目录的ACL规定</div><div class="line">setfacl -m u:rex:rwx rootfile</div></pre></td></tr></table></figure></p>
<h1 id="用户身份切换"><a href="#用户身份切换" class="headerlink" title="用户身份切换"></a>用户身份切换</h1><p>在Linux系统中是需要做身份的变换的，主要有以下几个原因：</p>
<ul>
<li>使用一般账号：系统平日操作的好习惯（不然你就有机会从删库到跑路了）</li>
<li>用较低的权限启动系统服务</li>
<li>软件本身的限制</li>
</ul>
<p>根据上面的考虑，我们都是使用一般账号登录系统的，等有需要进行系统维护或软件更新时才转为root身份来操作。从一般用户转变为root主要有下面两种方式：</p>
<ul>
<li>“su -”：需要root用户密码</li>
<li>“sudo命令”：sudo需要输入用户自己的密码</li>
</ul>
<h2 id="su"><a href="#su" class="headerlink" title="su"></a>su</h2><p>su是最简单的身份切换命令了，它可以进行任何身份的切换。但是下面有几点比较重要：</p>
<ol>
<li>若要完整切换到新用户的环境，必须要使用“su -username” 或 “su -|username”，才会连同PATH/USER/MAIL等变量都转成新用户的环境。如果只是使用“su”切换到root用户，PATH/USER/MAIL等变量都没有变，会导致很多命令执行不了。</li>
<li>如果仅想执行一次root命令，可以利用“su - -c “命令串””d的方式来处理。</li>
<li>使用root切换成为任何用户时，并不需要输入新用户的密码。</li>
</ol>
<p>虽然使用su很方便，但是会导致root密码外流。所以很多情况下我们通过sudo来处理。</p>
<h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h2><p>sudo的执行仅需要自己的密码即可！甚至可以设置不需要密码即可执行sudo，由于sudo可以让你以其他用户身份执行命令（通常是使用root的身份来执行命令），因此不是所有人都能够执行sudo，而是仅有/etc/sudoers内的用户才能够执行sudo这个命令。</p>
<ol>
<li><p>sudo的命令用法</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo [-u 新用户账号]</div><div class="line"></div><div class="line">// 范例，以sshd的身份在/tmp下面新建一个名为mysshd的文件</div><div class="line">sudo -u sshd touch /tmp/mysshd</div></pre></td></tr></table></figure>
</li>
<li><p>sudo的执行流程</p>
<ul>
<li>当用户执行sudo时，系统在/etc/sudoers文件中查找该用户是否有执行sudo的权限；</li>
<li>若用户具有可执行sudo的权限后，便让用户输入用户自己的密码来确认；</li>
<li>若密码输入成功，便开始进行sudo后面接的命令（root执行sudo不需要输入密码）</li>
<li>若欲切换的身份与执行者的身份相同，也不需要输入密码</li>
</ul>
</li>
<li><p>visudo与/etc/sudoers</p>
<p> 我们一般不直接去修改/etc/sudoers文件，而是利用visudo命令去修改，因为这个命令会在结束离开的时候去检验/etc/sudoers的语法，下面是他的用法案例：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 1. 单一用户可以执行root的所有命令与sudoers文件语法</div><div class="line">// 四个参数含义为(1).用户账号，(2).登陆者的来源主机，(3).(可切换的身份)，(4).可执行的命令</div><div class="line">root    ALL=(ALL)       ALL //文件中原有</div><div class="line">rex     ALL=(ALL)       ALL //新增</div><div class="line"></div><div class="line">// 2. 利用用户组以及免密码的功能处理visudo</div><div class="line"># %wheel        ALL=(ALL)       NOPASSWD: ALL //文件中原有，需要将#去掉，文件中的%表示后面接一个用户组</div><div class="line">usermod -a -G wheel rex //将rex加入wheel组中</div><div class="line"></div><div class="line">// 3. 有限制的命令操作，通过更改可执行的命令一栏的数据，就可以控制具体操作的安全性</div><div class="line">rex ALL=(ALL) !/usr/bin/passed //不让rex可以修改密码</div><div class="line"></div><div class="line">// 4. 通过别名设置visudo</div><div class="line">User_Alias ADMPW(大写) = rex1,rex2</div><div class="line">Cmnd_Alias ADMPWCOM(大写) = !/usr/bin/passwd, /usr/bin/passed [A-Za-z]</div><div class="line">ADMPW     ALL=(root)       ADMPWCOM</div><div class="line"></div><div class="line">// 5. sudo搭配su的使用方式,让用户用自己的密码变成root</div><div class="line">User_Alias ADMPW(大写) = rex1,rex2</div><div class="line">ADMPW     ALL=(root)       /bin/su -</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：管理员的工作中，相对重要的一环就是“账号管理”。因为整个系统都是你在管理，并且所有的一般用户的账号申请必须要通过你的协助才行。所以我们必须要知道如果管理好一个服务器主机的账号！
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_shell script 入门</title>
    <link href="http://bestlixiang.site/2018/03/30/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_shell%20script%20%E5%85%A5%E9%97%A8/"/>
    <id>http://bestlixiang.site/2018/03/30/走进Linux/走进Linux_shell script 入门/</id>
    <published>2018-03-30T10:01:49.000Z</published>
    <updated>2018-04-09T04:32:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：要想管理好自己的主机，自动化管理系统的好工具——shell script，这个家伙是真的需要好好学习学习的！<a id="more"></a></p>
<h1 id="什么是shell-script"><a href="#什么是shell-script" class="headerlink" title="什么是shell script"></a>什么是shell script</h1><p><strong>shell script</strong> 是利用shell的功能所写的一个“程序”，这个程序是使用纯文本文件，将一些shell的语法与命令（含外部命令）写在里面，搭配正则表达式，管道命令与数据重定向等功能，以达到我们所想要的处理目的。</p>
<h2 id="为什么要学习shell-script"><a href="#为什么要学习shell-script" class="headerlink" title="为什么要学习shell script"></a>为什么要学习shell script</h2><ol>
<li>自动化管理的重要依据</li>
<li>追踪与管理系统的重要工作</li>
<li>简单入侵检测功能</li>
<li>连续命令单一化</li>
<li>简易的数据处理</li>
<li>跨平台与学习历程较短</li>
</ol>
<h2 id="shell-script编写的注意事项"><a href="#shell-script编写的注意事项" class="headerlink" title="shell script编写的注意事项"></a>shell script编写的注意事项</h2><ol>
<li>命令的执行是从上而下，从左往右地分析与执行；</li>
<li>命令、参数间的多个空白都会被忽视掉；</li>
<li>空白行也将被忽略掉，并且tab按键所得的空白同样视为空格键；</li>
<li>如果读到一个enter符号（CR），就尝试开始结束该行（或该串）命令</li>
<li>至于如果一行的内容太多，则可以使用“\enter”来扩展至下一行；</li>
<li>“#”可作为批注，任何加在#后面的数据将全部被视为批注文件而被忽略。</li>
</ol>
<h2 id="shell-script的执行"><a href="#shell-script的执行" class="headerlink" title="shell script的执行"></a>shell script的执行</h2><p>假设你的程序文件名是/home/rex/shell.sh</p>
<ol>
<li>直接执行命令：shell.sh文件必须具备可读可执行(rx)的权限，然后：<ul>
<li>绝对路径：使用/home/rex/shell.sh</li>
<li>相对路径：假设工作目录在/home/rex/,则使用./shell.sh来执行</li>
<li>变量“PATH”功能：将shell.sh放在PATH指定的目录内，例如：~/bin/。</li>
</ul>
</li>
<li>以bash进程来执行：通过“bash shell.sh”或“sh shell.sh”来执行</li>
<li>利用source来执行：这样这个脚本将在父进程中执行，各项操作都会在原本的bash内生效。如果直接执行，script是在子进程中的bash内执行的，当子进程完成后，子进程的各项变量或操作将会结束而不会传回到父进程中。</li>
</ol>
<h2 id="良好的-script-撰写习惯"><a href="#良好的-script-撰写习惯" class="headerlink" title="良好的 script 撰写习惯"></a>良好的 script 撰写习惯</h2><p>在每个 script 的档头处记录好：</p>
<ol>
<li>script 的功能；</li>
<li>script 的版本资讯；</li>
<li>script 的作者与联络方式；</li>
<li>script 的版权宣告方式；</li>
<li>script 的 History (历史纪录)；<br>6。script 内较特殊的命令，使用绝对路径的方式来下达；</li>
<li>script 运行时需要的环境变量预先宣告与配置。</li>
</ol>
<h2 id="Hello-Word程序"><a href="#Hello-Word程序" class="headerlink" title="Hello Word程序"></a>Hello Word程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash // 声明这个script使用的shell名称</div><div class="line"># Program:</div><div class="line">#       This program shows &quot;Hello World!&quot; in your screen.</div><div class="line"># History:</div><div class="line"># 2015/11/03    Jiange First release</div><div class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</div><div class="line">export PATH</div><div class="line">echo -e &quot;Hello World! \a \n&quot;</div><div class="line">exit 0</div></pre></td></tr></table></figure>
<h1 id="善用判断式"><a href="#善用判断式" class="headerlink" title="善用判断式"></a>善用判断式</h1><h2 id="利用test命令的测试功能"><a href="#利用test命令的测试功能" class="headerlink" title="利用test命令的测试功能"></a>利用test命令的测试功能</h2><p>如下面的例子，用于检测文件夹是否存在：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test -e /dmtsai &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</div></pre></td></tr></table></figure></p>
<h2 id="利用判断符号"><a href="#利用判断符号" class="headerlink" title="利用判断符号[]"></a>利用判断符号[]</h2><p>如果我想要知道 $HOME 这个变量是否为空的，可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ -z &quot;$HOME&quot; ] ; echo $?</div></pre></td></tr></table></figure></p>
<p>对于判断符号我们一定要注意：</p>
<ol>
<li>在中括号 [] 内的每个组件都需要有空白键来分隔；</li>
<li>在中括号内的变量，最好都以双引号括号起来；</li>
<li>在中括号内的常数，最好都以单或双引号括号起来。</li>
</ol>
<h2 id="shell-script-的默认变量-0-1…"><a href="#shell-script-的默认变量-0-1…" class="headerlink" title="shell script 的默认变量($0, $1…)"></a>shell script 的默认变量($0, $1…)</h2><p>运行的脚本档名为 $0 变量，第一个接的参数就是 $1，依次类推。其他特殊变量：</p>
<ol>
<li>$# ：代表后接的参数个数；</li>
<li>$@ ：代表”$1” “$2” “$3” “$4” …之意，每个变量是独立的(用双引号括起来)；</li>
<li>$* ：代表『”$1c$2c$3c$4…” ，其中 c 为分隔字节，默认为空白键。</li>
</ol>
<h1 id="条件判断式"><a href="#条件判断式" class="headerlink" title="条件判断式"></a>条件判断式</h1><h2 id="利用-if-…-then"><a href="#利用-if-…-then" class="headerlink" title="利用 if …. then"></a>利用 if …. then</h2><p>如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if [ &quot;$1&quot; == &quot;hello&quot; ]; then</div><div class="line">    echo &quot;Hello, how are you ?&quot;</div><div class="line">elif [ &quot;$1&quot; == &quot;&quot; ]; then</div><div class="line">    echo &quot;You MUST input parameters, ex&gt; &#123;$0 someword&#125;&quot;</div><div class="line">else</div><div class="line">    echo &quot;The only parameter is &apos;hello&apos;, ex&gt; &#123;$0 hello&#125;&quot;</div><div class="line">fi</div></pre></td></tr></table></figure></p>
<h2 id="利用-case-…-esac-判断"><a href="#利用-case-…-esac-判断" class="headerlink" title="利用 case ….. esac 判断"></a>利用 case ….. esac 判断</h2><p>如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">case $1 in                             </div><div class="line">&quot;one&quot;)</div><div class="line">    echo &quot;Your choice is ONE&quot;</div><div class="line">    ;;</div><div class="line">&quot;two&quot;)</div><div class="line">    echo &quot;Your choice is TWO&quot;</div><div class="line">    ;;</div><div class="line">&quot;three&quot;)</div><div class="line">    echo &quot;Your choice is THREE&quot;</div><div class="line">    ;;</div><div class="line">*)</div><div class="line">    echo &quot;Usage $0 &#123;one|two|three&#125;&quot;</div><div class="line">    ;;</div><div class="line">esac</div></pre></td></tr></table></figure></p>
<h2 id="利用-function-功能"><a href="#利用-function-功能" class="headerlink" title="利用 function 功能"></a>利用 function 功能</h2><p>如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function printit()&#123;</div><div class="line">    echo &quot;Your choice is $1&quot;   # 这个 $1 必须要参考底下命令的下达</div><div class="line">&#125;</div><div class="line"></div><div class="line">echo &quot;This program will print your selection !&quot;</div><div class="line">case $1 in</div><div class="line"> &quot;one&quot;)</div><div class="line">    printit 1  # 请注意， printit 命令后面还有接参数！</div><div class="line">    ;;</div><div class="line">&quot;two&quot;)</div><div class="line">    printit 2</div><div class="line">    ;;</div><div class="line">&quot;three&quot;)</div><div class="line">    printit 3</div><div class="line">    ;;</div><div class="line"> *)</div><div class="line">    echo &quot;Usage $0 &#123;one|two|three&#125;&quot;</div><div class="line">    ;;</div><div class="line">esac</div></pre></td></tr></table></figure></p>
<h1 id="循环（loop）"><a href="#循环（loop）" class="headerlink" title="循环（loop）"></a>循环（loop）</h1><h2 id="while-do-done-until-do-done-不定次数循环"><a href="#while-do-done-until-do-done-不定次数循环" class="headerlink" title="while do done, until do done (不定次数循环)"></a>while do done, until do done (不定次数循环)</h2><p>如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">while [ condition ]  &lt;==中括号内的状态就是判断式</div><div class="line">do            &lt;==do 是循环的开始！</div><div class="line">    程序段落</div><div class="line">done          &lt;==done 是循环的结束</div><div class="line"></div><div class="line">until [ condition ]</div><div class="line">do     </div><div class="line">    程序段落</div><div class="line">done</div></pre></td></tr></table></figure></p>
<h2 id="for…do…done-固定次数循环"><a href="#for…do…done-固定次数循环" class="headerlink" title="for…do…done (固定次数循环)"></a>for…do…done (固定次数循环)</h2><p>如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for var in con1 con2 con3 ...</div><div class="line">do</div><div class="line">    程序段</div><div class="line">done</div></pre></td></tr></table></figure></p>
<h2 id="for…do…done-的数值处理"><a href="#for…do…done-的数值处理" class="headerlink" title="for…do…done 的数值处理"></a>for…do…done 的数值处理</h2><p>如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">read -p &quot;Please input a number, I will count for 1+2+...+your_input: &quot; nu</div><div class="line"></div><div class="line">s=0</div><div class="line">for (( i=1; i&lt;=$nu; i=i+1 ))</div><div class="line">do</div><div class="line">    s=$(($s+$i))</div><div class="line">done</div><div class="line">echo &quot;The result of &apos;1+2+3+...+$nu&apos; is ==&gt; $s&quot;</div></pre></td></tr></table></figure></p>
<h1 id="shell-script-的追踪与调试"><a href="#shell-script-的追踪与调试" class="headerlink" title="shell script 的追踪与调试"></a>shell script 的追踪与调试</h1><p>可以使用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sh [-nvx] scripts.sh</div><div class="line"></div><div class="line">选项与参数：</div><div class="line">-n  ：不要运行 script，仅查询语法的问题；</div><div class="line">-v  ：在运行 sccript 前，先将 scripts 的内容输出到屏幕上；</div><div class="line">-x  ：将使用到的 script 内容显示到萤幕上，这是很有用的参数！</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：要想管理好自己的主机，自动化管理系统的好工具——shell script，这个家伙是真的需要好好学习学习的！
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_深入bash数据操作</title>
    <link href="http://bestlixiang.site/2018/03/30/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_%E6%B7%B1%E5%85%A5bash%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
    <id>http://bestlixiang.site/2018/03/30/走进Linux/走进Linux_深入bash数据操作/</id>
    <published>2018-03-30T07:12:54.000Z</published>
    <updated>2018-04-09T04:32:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在这里有一切你想要的bash数据操作知识，比如数据流重定向，管道命令，正则表达式的使用，大家可以快快进来！<a id="more"></a></p>
<h1 id="数据流的重定向"><a href="#数据流的重定向" class="headerlink" title="数据流的重定向"></a>数据流的重定向</h1><h2 id="什么是数据流重定向"><a href="#什么是数据流重定向" class="headerlink" title="什么是数据流重定向"></a>什么是数据流重定向</h2><p>一般来说，如果你要执行一个命令，通常它会是这样的：</p>
<ol>
<li>文件 -&gt; 标准输入 -&gt;命令</li>
<li>如果执行正确，命令 -&gt; 标准输出 -&gt; 文件/设备；如果执行错误，命令 -&gt; 标准错误输出 -&gt; 文件或设备</li>
</ol>
<h3 id="标准输出，标准错误输出，标准输入"><a href="#标准输出，标准错误输出，标准输入" class="headerlink" title="标准输出，标准错误输出，标准输入"></a>标准输出，标准错误输出，标准输入</h3><ol>
<li>标准输出：指的是命令执行所回传的正确信息，代码为1，使用&gt; 或 &gt;&gt;;</li>
<li>标准错误输出：指的是命令执行错误失败后，所回传的错误信息，代码为12，使用2&gt; 或 2&gt;&gt;;</li>
<li>标准输入：将原本需要键盘输入的数据改由文件内容来替代，代码为0，使用&lt; 或 &lt;&lt;;</li>
</ol>
<p>如下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ll / &gt; ~/rootfile // 显示文件名信息到rootfile文件中</div></pre></td></tr></table></figure></p>
<p>关于重定向输出文件的创建方式如下：</p>
<ol>
<li>该文件如果不存在，系统会自动将它创建起来</li>
<li>当这个文件存在，那么系统就会将这个文件内容清空，然后再将数据写入</li>
<li>若以&gt;输入到一个以存在的文件中，那个文件就会被覆盖，如果不想被覆盖，可以使用 &gt;&gt;</li>
</ol>
<h3 id="dev-null-垃圾桶黑洞设备与特殊写法"><a href="#dev-null-垃圾桶黑洞设备与特殊写法" class="headerlink" title="/dev/null 垃圾桶黑洞设备与特殊写法"></a>/dev/null 垃圾桶黑洞设备与特殊写法</h3><ol>
<li><p>/dev/null 垃圾桶黑洞设备，如果我们知道错误信息会发生，所以要讲错误信息忽略掉而不显示或存储，我们就需要使用/dev/null这个黑洞设备了。写法如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ll /  2&gt; /dev/null</div></pre></td></tr></table></figure>
</li>
<li><p>如果我们要将正确地与错误数据都写入同一个文件中去，这个时候就需要使用特殊写法了，如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ll / &gt; ~/rootfile 2&gt;&amp;1  </div><div class="line">ll / &amp;&gt; ~/rootfile</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="为什么要使用命令输出重定向"><a href="#为什么要使用命令输出重定向" class="headerlink" title="为什么要使用命令输出重定向"></a>为什么要使用命令输出重定向</h3><ol>
<li>屏幕输出的信息很重要，而且我们需要将它存下来的时候</li>
<li>后台执行中的程序，不希望它干扰屏幕正常的输出结果时</li>
<li>一些系统的例行命令的执行结果，希望它可以存下来时</li>
<li>一些执行命令的可能已知信息时，想以“2&gt;/dev/null”将它丢掉时</li>
<li>错误信息与正确信息需要分别输出时</li>
</ol>
<h2 id="命令执行的判断依据：；，-amp-amp-，"><a href="#命令执行的判断依据：；，-amp-amp-，" class="headerlink" title="命令执行的判断依据：；， &amp;&amp;，||"></a>命令执行的判断依据：；， &amp;&amp;，||</h2><p>在某些情况下，很多命令我们需要一次输入去执行，而不像分开执行，基本有两个选择，一个是通过shell script编写脚本去执行，一种是听过下面的介绍来一直输入多重命令。</p>
<ol>
<li>cmd ; cmd (不考虑命令相关性的连续命令执行，第一个命令执行结束后便会执行第二个命令)</li>
<li>cmd &amp;&amp; cmd (若第一个命令执行成功才会执行第二个命令；若第一个命令执行失败，则不会执行第二个命令。)</li>
<li>cmd || cmd (若第一个命令执行成功，则不执行第二个命令；若第一个命令执行失败，才会执行第二个命令。)</li>
</ol>
<h1 id="管道命令-pipe"><a href="#管道命令-pipe" class="headerlink" title="管道命令(pipe)"></a>管道命令(pipe)</h1><h2 id="什么是管道命令"><a href="#什么是管道命令" class="headerlink" title="什么是管道命令"></a>什么是管道命令</h2><p><strong>管道命令</strong> 能够将一个命令的执行结果经过<strong>筛选</strong>，只保留我们需要的信息。 它的符号是 <strong>“ | ”</strong>。</p>
<p>管道命令有下面两个比较需要注意的地方：</p>
<ol>
<li>管道命令仅会处理标准输出，对于标准错误输出会予以忽略</li>
<li>管道命令必须要能够接收来自前一个命令的数据成为标准输人继续处理才行。</li>
</ol>
<h2 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h2><h3 id="选取指定列：cut"><a href="#选取指定列：cut" class="headerlink" title="选取指定列：cut"></a>选取指定列：cut</h3><p>cut为剪切的意思，它能将一行行的数据按照指定的分隔符切成一列列，然后只显示特定列的数据。 cut有两种使用方式：</p>
<ul>
<li><p>按照指定字符分隔，这个命令会按照特定的分隔符将数据切分，并只显示第n列的数据。如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cut -d &apos;分隔符&apos; -f n(第几列)</div></pre></td></tr></table></figure>
</li>
<li><p>选择特定范围内的数据，如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cut -c 起始字符的下标-结束字符的下标</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="关键词搜索指定行：grep"><a href="#关键词搜索指定行：grep" class="headerlink" title="关键词搜索指定行：grep"></a>关键词搜索指定行：grep</h3><p>grep用于进行关键词查找，它会将文件中含有关键词的那一整行输出来。grep的两种使用方式如下：</p>
<ul>
<li><p>从指定文件中将符合关键词的行搜索出来，如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep [-参数] ‘关键词’ 文件</div></pre></td></tr></table></figure>
</li>
<li><p>采用管道，将前一个命令的执行结果输出给grep，并通过grep的关键词搜索将符合条件的行搜索出来，如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">命令 | grep [-参数] ‘关键词’</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="排序：sort"><a href="#排序：sort" class="headerlink" title="排序：sort"></a>排序：sort</h3><p>sort命令能够将指定文件 或 前一个命令的结果数据 按照指定字段进行排序。sort两种使用方式与grep基本一样，一种是将文件中的数据按照指定字段排序。另一种是使用管道，将前一个命令执行的结果按照指定字段进行排序。。</p>
<h3 id="去除重复行：uniq"><a href="#去除重复行：uniq" class="headerlink" title="去除重复行：uniq"></a>去除重复行：uniq</h3><p>该命令只能用于管道，如统计当前系统所有用户的登录次数：如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">last | cut -d &apos; &apos; -f 1 | uniq -c</div></pre></td></tr></table></figure></p>
<h3 id="统计字数、行数、字符数：wc"><a href="#统计字数、行数、字符数：wc" class="headerlink" title="统计字数、行数、字符数：wc"></a>统计字数、行数、字符数：wc</h3><p>wc只能通过管道使用，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">命令 | wc [-参数]</div></pre></td></tr></table></figure></p>
<h3 id="双向重定向：tee"><a href="#双向重定向：tee" class="headerlink" title="双向重定向：tee"></a>双向重定向：tee</h3><p>tee只能和管道结合使用，如将last中的信息输出指文件并显示在屏幕上,指令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">last | tee -a lastfile | cut -d &apos; &apos; f 1</div></pre></td></tr></table></figure></p>
<h3 id="切割文件：split"><a href="#切割文件：split" class="headerlink" title="切割文件：split"></a>切割文件：split</h3><p>该命令能将一个大文件切分成若干个小文件。用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">split [-bl] 大文件 小文件名字前缀</div></pre></td></tr></table></figure></p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h2><p><strong>正则表达式</strong> 就是处理字符串的方法，它是行为单位来进行字符串的处理行为<br>正则表达式通过一些特殊符号的辅助，可以让用户轻易达到查找、删除、替换某特定字符串的处理程序。</p>
<p>正则表达式基本上就是一种“表示法”，只要工具支持这种表示法，那么工具程序就可以用来作为正则表达式的字符串处理之用。比如vi、grep、awk、sed等工具。</p>
<p>正则表达式的字符串表达方式依照不同的严谨度可以分为<strong>基本正则表达式</strong>与<strong>扩展正则表达式</strong>。</p>
<h2 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h2><h3 id="基础正则表达式字符"><a href="#基础正则表达式字符" class="headerlink" title="基础正则表达式字符"></a>基础正则表达式字符</h3><table>
<thead>
<tr>
<th>RE字符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>^word</td>
<td>待查找的字符串(word)在行首</td>
</tr>
<tr>
<td>word$</td>
<td>待查找的字符串(word)在行尾</td>
</tr>
<tr>
<td>.</td>
<td>代表一定有一个任意字符的字符</td>
</tr>
<tr>
<td>\/</td>
<td>转义字符,将特殊符号的特殊意义去除</td>
</tr>
<tr>
<td>*</td>
<td>重复0个或多个的前一个字符</td>
</tr>
<tr>
<td>[list]</td>
<td>从字符集合的RE字符里面找出想要选取的字符</td>
</tr>
<tr>
<td>[n1-n2]</td>
<td>从字符集合的RE字符里面找出想要选取的字符范围</td>
</tr>
<tr>
<td>[^list]</td>
<td>从字符集合的RE字符里面找出不要的字符串或范围</td>
</tr>
<tr>
<td>/{n,m/}</td>
<td>连续n到m个的前一个RE字符,/{n/}表示连续n个,/{n,/}表示连续n个及以上</td>
</tr>
</tbody>
</table>
<p>PS：正则表达式的特殊字符与一般在命令行输入的“通配符”并不相同，通配符的*代表的是零到无限多个字符的意思，但是在正则表达式中*是表示重复0到无穷多个前一个RE字符的意思。</p>
<h3 id="基础正则表达式练习-以grep工具为例"><a href="#基础正则表达式练习-以grep工具为例" class="headerlink" title="基础正则表达式练习(以grep工具为例)"></a>基础正则表达式练习(以grep工具为例)</h3><ol>
<li><p>查找特定字符串</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep -n ‘the’ regular_express.txt</div><div class="line"></div><div class="line">grep -vn &apos;the&apos; regular_express.txt  (-v反向选择)</div></pre></td></tr></table></figure>
</li>
<li><p>利用中括号[]来查找集合字符</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">grep -n &apos;t[ae]st&apos; regular_express.txt (可匹配test或tast)</div><div class="line"></div><div class="line">grep -n &apos;[^g]oo&apos; regular_express.txt (oo前不能有g的字符)</div><div class="line"></div><div class="line">grep -n &apos;[^[:lower:]]oo&apos; regular_express.txt   ([:lower:]代表a-z的意思)</div></pre></td></tr></table></figure>
</li>
<li><p>行首和行尾字符</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep -n &apos;^test&apos; regular_express.txt (注:^在[]内表示“反向选择”,在[]外表示定位在行首)</div><div class="line"></div><div class="line">grep -n &apos;/.$&apos; regular_express.txt  (找出行尾结束为小数点的那一行)</div></pre></td></tr></table></figure>
</li>
<li><p>任意一个字符.与重复字符*</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">grep -n ‘g..d’ regular_express.txt (可匹配good,glad等字符)</div><div class="line"></div><div class="line">grep -n &apos;ooo*&apos; regular_express.txt  (匹配至少两个o以上的字符)</div><div class="line"></div><div class="line">grep -n &apos;g.*g&apos; regular_express.txt (找出g开头与g结尾的字符串,.*表示o个或多个任意字符的意思)</div></pre></td></tr></table></figure>
</li>
<li><p>限定连续RE(Regular Expression)字符范围{}</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">grep -n &apos;o/&#123;2/&#125;&apos; regular_express.txt (找出两个o的字符串)</div><div class="line"></div><div class="line">grep -n ‘go/&#123;2,5/&#125;g’ regular_express.txt (g后有两个到5个o,然后接一个g的字符串)</div><div class="line"></div><div class="line">grep -n ‘go/&#123;2,/&#125;g’ regular_express.txt (g后有两个及以上的o,然后接一个g的字符串)</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="sed工具"><a href="#sed工具" class="headerlink" title="sed工具"></a>sed工具</h3><p>sed本身是一个管道命令，它可以将数据进行替换、删除、新增、选取特定行等功能。使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed [-nefr] [动作]</div></pre></td></tr></table></figure></p>
<h2 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h2><p>一般情况下只需要基础正则表达式即可，但是有时候还需要一些扩展功能，比如整合两条管道命令，这就需要用到扩展正则表达式，如果是grep，它基本使用命令是egrep，基本的符号如下：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>意义与范例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>重复一个或多个的前一个RE字符，如：egrep -n ‘go+d’ regular_express.txt</td>
</tr>
<tr>
<td>?</td>
<td>0个或一个的前一个RE字符，如：egrep -n ‘go?d’ regular_express.txt</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>用或的方式找出字符串，如：egrep -n ‘gd\</td>
<td>good’ regular_express.txt</td>
</tr>
<tr>
<td>()</td>
<td>找出“组”的字符串 (如:egrep -n ‘g(la \</td>
<td>oo)d’ regular_express.txt  表示找出glad或good字符串)</td>
</tr>
<tr>
<td>()+</td>
<td>多个重复组的判别  (如echo ‘AxyzxyzxyzxyzC’ \</td>
<td>egrep ‘A(xyz)+C’  找出开头是A结尾是C,中间有一个以上的“xyz”字符串)</td>
</tr>
</tbody>
</table>
<h1 id="文件的格式化处理"><a href="#文件的格式化处理" class="headerlink" title="文件的格式化处理"></a>文件的格式化处理</h1><h2 id="文件格式化：printf"><a href="#文件格式化：printf" class="headerlink" title="文件格式化：printf"></a>文件格式化：printf</h2><p>如果我们需要将自己的数据给它格式化输出，我们就需要一个好的样式，输出的方式其实和C语言的格式化输出差不多，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">printf &apos;打印格式&apos; 实际内容</div></pre></td></tr></table></figure></p>
<h2 id="好用的数据处理工具：awk"><a href="#好用的数据处理工具：awk" class="headerlink" title="好用的数据处理工具：awk"></a>好用的数据处理工具：awk</h2><p>awk相当适合处理小型的数据，它的基本用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">awk ‘条件类型1&#123;动作1&#125; 条件类型2&#123;动作2&#125; ...’ filename</div><div class="line"></div><div class="line">// 例子</div><div class="line">last -n 5 | awk &apos;&#123;print $1 &quot;\t&quot; $3&#125;&apos; // 取出登录者账号和ip</div></pre></td></tr></table></figure></p>
<p>这个awk的处理流程如下：</p>
<ol>
<li>读入第一行，并将第一行的填入$0,$1等变量中</li>
<li>依据条件类型的限制，判断是否需要进行后面的动作</li>
<li>做完所有的动作与条件类型</li>
<li>若还有后续行，就重复上面1~3的步骤，直到所有数据都读完为止。</li>
</ol>
<h2 id="文件比较工具：diff"><a href="#文件比较工具：diff" class="headerlink" title="文件比较工具：diff"></a>文件比较工具：diff</h2><p>diff用于比较两个文件之间的区别,并且是以行为单位的,diff也可以比较两个目录。用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">diff [-bBi] from-file to-file</div></pre></td></tr></table></figure></p>
<p>patch这个命令与diff有密不可分的联系，将旧的文件升级成为新的文件的方法是先比较新旧版本的区别，将将区别文件制作成为补丁文件，再有补丁问价更新旧文件即可。例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 范例:以/tmp/test内的passwd.old 与passwd.new 制作补丁文件,并更新旧版数据</div><div class="line"></div><div class="line">diff -Naur passwd.old passwd.new &gt;passwd.patch</div><div class="line"></div><div class="line">// 更新旧文件,变成和新文件一样</div><div class="line"></div><div class="line">patch -p0 &lt; passwd.patch</div><div class="line"></div><div class="line">// 恢复旧文件的内容</div><div class="line"></div><div class="line">patch -R -p0 &lt; passwd.patch</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在这里有一切你想要的bash数据操作知识，比如数据流重定向，管道命令，正则表达式的使用，大家可以快快进来！
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_初探shell步入bash</title>
    <link href="http://bestlixiang.site/2018/03/28/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_%E5%88%9D%E6%8E%A2shell%E6%AD%A5%E5%85%A5bash/"/>
    <id>http://bestlixiang.site/2018/03/28/走进Linux/走进Linux_初探shell步入bash/</id>
    <published>2018-03-28T05:44:19.000Z</published>
    <updated>2018-04-09T04:32:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在Linux的环境下，如果你不懂bash是什么，那么其他的东西就不用学了！<a id="more"></a></p>
<h1 id="认识bash这个shell"><a href="#认识bash这个shell" class="headerlink" title="认识bash这个shell"></a>认识bash这个shell</h1><p>管理整个计算机硬件的其实是操作系统的内核，这个内核是需要保护的，所以我们一般用户就只能通过shell来跟内核通信，以让内核达到我们所想要达到的工作，那么系统。</p>
<h2 id="硬件、内核与shell"><a href="#硬件、内核与shell" class="headerlink" title="硬件、内核与shell"></a>硬件、内核与shell</h2><p>下面是硬件、内核与shell的关系：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/linux/png/relation_shell.png" alt="shell"></p>
<p>我们必须要通过“shell”将我们输入的命令与内核通信，好让内核可以控制硬件来正确无误地工作。</p>
<p>其实shell的功能只是提供用户操作系统的一个接口，因此这个shell需要可以调用其他软件才好。<strong>只要能够操作应用程序的接口都能够称为shell。</strong> <strong>狭义的shell</strong>指的是命令行方面的软件，包括bash等。<strong>广义的shell</strong>包括图形界面的软件，因为图形界面也能够操作各种应用程序来调用内核工作。</p>
<h2 id="为什么要学命令行界面的shell"><a href="#为什么要学命令行界面的shell" class="headerlink" title="为什么要学命令行界面的shell"></a>为什么要学命令行界面的shell</h2><ol>
<li>命令行界面的shell：大家（几乎所有发行版）都一样</li>
<li>远程管理：命令行界面就是比较快，而且较不容易出现断线或者信息外流的问题。</li>
<li>Linux的任督二脉：shell是也。因为要想将自己的主机管理好，良好的shell程序编写是必须的。</li>
</ol>
<h2 id="系统合法与-etc-shells功能"><a href="#系统合法与-etc-shells功能" class="headerlink" title="系统合法与/etc/shells功能"></a>系统合法与/etc/shells功能</h2><p>目前我们的Linux有下面几个可以用的shell，我们可以通过查看/etc/shells这个文件，可以看到如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/bin/sh   (已经被/bin/bash所替代)</div><div class="line">/bin/bash  (Linux默认的shell)</div><div class="line">/sbin/nologin</div><div class="line">/usr/bin/sh</div><div class="line">/usr/bin/bash</div><div class="line">/usr/sbin/nologin</div><div class="line">/bin/tcsh   (整合C shell，提供了更多的功能)</div><div class="line">/bin/csh  (已经被/bin/tcsh所替代)</div></pre></td></tr></table></figure></p>
<p>Linux默认的就是bash。系统上合法的shell都要写入/etc/shells这个文件中，因为系统某些服务在运行过程中，会去检查用户能够使用的shells，而这些shell的查询就是借助/etc/shells这个文件。</p>
<p>用户默认取得的shell可以通过查看/etc/passwd文件，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">bin:x:1:1:bin:/bin:/sbin/nologin</div><div class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</div></pre></td></tr></table></figure></p>
<h2 id="bash-shell的功能"><a href="#bash-shell的功能" class="headerlink" title="bash shell的功能"></a>bash shell的功能</h2><p>bash的优点如下：</p>
<ol>
<li>命令记忆能力，~/.bash_history里面会记录前一次登录所执行过的命令，而这一次登录都被暂存在临时内存中，成功注销后，本次执行的命令会记录到文件中。最大的好处就是可以查询曾经做过的操作，利于排错。</li>
<li>命令与文件补全功能（Tab键的好处）</li>
<li>命令别名设置功能（alias）执行如下得命令：<blockquote>
<p>alias 简化命令=’实际命令’ （设置别名）; unalias 简化命令（解除别名）</p>
</blockquote>
</li>
<li>作业控制、前台、后台控制</li>
<li>程序脚本</li>
<li>通配符（*）</li>
</ol>
<h1 id="shell的变量功能"><a href="#shell的变量功能" class="headerlink" title="shell的变量功能"></a>shell的变量功能</h1><p>变量是bash环境中非常重要的一个玩意儿。</p>
<h2 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h2><p><strong>变量：</strong> 就是以一组文字或符号等，来替代一些设置或者一串保留的数据。</p>
<p>变量的方便性在于：</p>
<ol>
<li>变量的可变性与方便性</li>
<li>简化bash环境操作</li>
<li>脚本程序设计的好帮手</li>
</ol>
<h2 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h2><p>在Linux中，变量分为环境变量(全局变量) 和 局部变量。<br>环境变量能被子进程继承，而局部变量只能在当前进程中使用。</p>
<p>不论是环境变量还是局部变量。他们又都可以分为系统变量 和 自定义变量。系统变量是系统启动时自动创建的变量，往往为系统运行提供支持；而自定义变量是用户自己定义的。一般而言，系统变量全为大写，自定义变量全为小写。</p>
<h2 id="变量的显示与设置：echo，unset"><a href="#变量的显示与设置：echo，unset" class="headerlink" title="变量的显示与设置：echo，unset"></a>变量的显示与设置：echo，unset</h2><ol>
<li><p>变量的显示：echo</p>
<p> 读变量，只需要在变量名称前面加上$，或者是以${变量}的方式来显示就可以。</p>
</li>
<li><p>变量的修改：“=”</p>
<p> 只需要用等号连接变量与它的内容就好了。它具有如下设置规则：</p>
<ul>
<li>等号两边不能直接接空格符</li>
<li>变量名称只能是英文字母与数字，但是开头字符不能是数字</li>
<li>变量内容若有空格可使用双引号或单引号将变量的内容结合起来</li>
<li>可以用转义字符”\”将特殊符号（如enter、$、\、空格符、！等）变成一般字符。</li>
<li>在一串命令中，还需要其他的命令提供的信息，可以使用反单引号“`命令`”或“$(命令)”</li>
<li>若该变量为了增加变量内容时，则可用“$变量名称”或${变量}累加内容，后用冒号连接。</li>
<li>若该变量需要在其他自进程执行，则需要以export来使变量变成环境变量。</li>
<li>通常大写字符为系统默认变量，自行设置变量可以使用小写字符，方便判断。</li>
<li><p>取消变量的方法为使用“unset 变量名称”</p>
<p>什么是<strong>子进程：</strong> 在一个bash中开启一个新的bash，那么原本的bash称为父进程，新的bash称为子进程。 子进程会继承父进程的所有环境变量，而父进程的局部变量只能在父进程中使用。</p>
</li>
</ul>
</li>
</ol>
<h2 id="环境变量的功能"><a href="#环境变量的功能" class="headerlink" title="环境变量的功能"></a>环境变量的功能</h2><p><strong>环境变量</strong>可以帮我们达到很多功能，包括主文件夹的变换、提示符的显示、执行文件查找的路径等。在shell环境下，可以通过env与export查看环境变量。下面主要介绍一下主要的环境变量：</p>
<ul>
<li>HOME：用户主目录，当我们使用cd 或cd ~时就会调用这个环境变量找到用户主目录</li>
<li>SHELL：当前使用的SHELL，默认使用/bin/bash</li>
<li>HISTSIZE：历史命令的最大条数</li>
<li>PATH：可执行文件的查找路径。这是一个非常重要的环境变量，当我们直接写一个命令时，系统就会在PATH路径中寻找这个命令，这样我们在执行命令的时候就不用输命令完整的路径了。多个路径之间用:分隔</li>
<li>LANG：当前系统的语言</li>
<li>RANDOM：随机数生成器的路径。该路径默认指向/dev/random这个文件，这个文件是一个随机数生成器，当我们使用$RANDOM时就能获得一个0-32767之间的随机整数</li>
</ul>
<p>当然我们还可以通过set来查看所有变量（含环境变量和自定义变量）：这里也解释几个比较重要的变量：</p>
<ul>
<li>PS1：命令提示符，在命令输入光标前有一串用中括号括起来的信息，这就是命令提示符。命令提示符究竟需要显示哪些信息，这就是由PS1这个局部变量决定的。由于它是局部变量，因此子进程中无法继承这个变量，子进程拥有自己的PS1。</li>
<li><p>$：当前shell的PID，可以通过如下命令查看当前shell的PID：</p>
<blockquote>
<p>echo $$</p>
</blockquote>
</li>
<li><p>?：上个命令的执行结果,上个命令若执行成功，则echo $?就会返回0；若上个命令执行失败，则该值为一个非0整数。</p>
</li>
</ul>
<h2 id="变量内容的删除与替换"><a href="#变量内容的删除与替换" class="headerlink" title="变量内容的删除与替换"></a>变量内容的删除与替换</h2><table>
<thead>
<tr>
<th>操作方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>${变量名#关键词}</td>
<td>从变量值的头部开始，依次向后删除到关键词第一次出现的位置为止</td>
</tr>
<tr>
<td>${变量名##关键词}</td>
<td>从变量值的头部开始，依次向后删除到关键词最后一次出现的位置为止</td>
</tr>
<tr>
<td>${变量名%关键词}</td>
<td>从变量值的尾部开始，依次向前删除到关键词第一次出现的位置为止</td>
</tr>
<tr>
<td>${变量名%%关键词}</td>
<td>从变量值的尾部开始，依次向前删除到关键词最后一次出现的位置为止</td>
</tr>
<tr>
<td>${变量名/旧字符串/新字符串}</td>
<td>从变量值的头部开始，依次向后找到第一个旧字符串，并将其替换</td>
</tr>
<tr>
<td>${变量名//旧字符串/新字符串}</td>
<td>将变量值中所有的旧字符串替换成新字符串</td>
</tr>
</tbody>
</table>
<h1 id="Bash-Shell的操作环境"><a href="#Bash-Shell的操作环境" class="headerlink" title="Bash Shell的操作环境"></a>Bash Shell的操作环境</h1><h2 id="路径与命令的查找顺序"><a href="#路径与命令的查找顺序" class="headerlink" title="路径与命令的查找顺序"></a>路径与命令的查找顺序</h2><p>基本上，命令运行的顺序可以这样看：</p>
<ol>
<li>以相对/绝对路径执行命令，例如：“/bin/ls”或“./ls”</li>
<li>由alias找到该命令来执行</li>
<li>有bash内置的(builtin)命令来执行</li>
<li>通过$PATH这个变量的顺序找到的第一个命令来执行</li>
</ol>
<h2 id="bash的登录与欢迎环境：-etc-issue-etc-motd"><a href="#bash的登录与欢迎环境：-etc-issue-etc-motd" class="headerlink" title="bash的登录与欢迎环境：/etc/issue,/etc/motd"></a>bash的登录与欢迎环境：/etc/issue,/etc/motd</h2><ol>
<li>/etc/issue：放置终端机接口登录成功的界面提示的字符。</li>
<li>/etc/issue.net：放置telnet远程登录成功的界面提示的字符。</li>
<li>/etc/motd：如果你想让用户登录后取得一些信息，可以将信息加入其中。比如告知登录者系统将在什么时候维护。</li>
</ol>
<h2 id="bash的环境配置文件"><a href="#bash的环境配置文件" class="headerlink" title="bash的环境配置文件"></a>bash的环境配置文件</h2><p>由于系统有一些环境配置文件的存在，让bash在启动时直接读取这些配置文件，所有已进入bash就能够取得一堆有用的变量。而这些配置文件又可以分为全体系统的配置文件以及用户个人偏好配置文件。要注意的是，之前我们说的命令别名、自定义的变量在你注销bash后就会失效。所以你想要保留你的设置，就得要讲这些设置写入配置文件才行。，下面就看看这些东西：</p>
<ol>
<li><p>login shell与non-login shell</p>
<p> login shell和non-login shell是两种shell登录的方式，它们登录后加载的环境配置文件有所不同。</p>
<ul>
<li>login shell在获取bash前需要进行一套完整的登录过程，这个登录过程就称为login shell。所谓“完整的登录过程”指需要输入用户名和密码。login shell其实只会读取这两个配置文件：/etc/profile和(~/.bash_profile或 ~/.bash\_login或~/.profile)</li>
<li>non-login shell获取bash不需要输入密码的登录过程称为non-login shell。如在bash中直接输入bash，从而打开一个子bash，这个过程不需要输入密码，因此称为non-login shell。比如在图形界面中。</li>
</ul>
</li>
<li>/etc/profile：系统级的环境变量(login shell才会读) 。<br>该文件存放系统级环境变量，所有的用户都会拥有，一般不建议修改这个文件。</li>
<li>~/.bash_profile：用户个人的环境变量(login shell才会读)<br>当/etc/profile中的环境变量加载完毕后就会加载本文件，本文件中定义了当前用户的环境变量。</li>
<li>~/.bashrc：non-login shell会读取的环境配置文件<br>当用户以non-login方式登录后，只会加载这个文件，该文件会对一些操作加上安全询问。这个文件不管哪种登录方式都会被加载，因此这里可以存放别名。</li>
<li>/etc/man.conf：设置man的存放路径<br>如果使用源码安装软件的话(非rpm、yum)，一般软件会安装在自定义的目录中(一般为/usr/local/软件名)。那么软件中的man文件就无法被系统找到，从而无法通过“man+命令”找到这个软件的命令帮助文档。我们需要手动将该软件的man目录添加到/etc/man.conf中去，从而执行“man+命令”就能找到这个目录的帮助文档。</li>
<li>~/.bash_history：存储用户历史命令</li>
<li>~/.bash_logout：记录注销后系统执行的操作</li>
</ol>
<h2 id="通配符和特殊字符"><a href="#通配符和特殊字符" class="headerlink" title="通配符和特殊字符"></a>通配符和特殊字符</h2><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>在bash的操作环境中还有一个非常有用的功能，那就是通配符。下面是一些常用的通配符：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>代表任意多个字符</td>
</tr>
<tr>
<td>?</td>
<td>代表一个字符</td>
</tr>
<tr>
<td>[]</td>
<td>[abcd]：代表该范围内的一个字符</td>
</tr>
<tr>
<td>[-]</td>
<td>[a-z]：代表a-z之间的一个字符</td>
</tr>
<tr>
<td>[^]</td>
<td>[^a-z]：代表除了a-z以外的所有字符</td>
</tr>
</tbody>
</table>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>下面是bash环境中的特殊符号：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>#</td>
<td>注释</td>
</tr>
<tr>
<td>\</td>
<td>转移字符，将特殊字符转为普通字符</td>
</tr>
<tr>
<td>;</td>
<td>分隔多个目录，使得依次执行</td>
</tr>
<tr>
<td>~</td>
<td>用户主目录</td>
</tr>
<tr>
<td>$</td>
<td>变量的起始符</td>
</tr>
<tr>
<td>&amp;</td>
<td>将目录置于后台执行</td>
</tr>
<tr>
<td>!</td>
<td>非</td>
</tr>
<tr>
<td>/</td>
<td>目录分隔符</td>
</tr>
<tr>
<td>&gt;,&gt;&gt;</td>
<td>数据流重定向，输出导向</td>
</tr>
<tr>
<td>&lt;,&lt;&lt;</td>
<td>数据流重定向，输入导向</td>
</tr>
<tr>
<td>‘’</td>
<td>不含变量置换功能</td>
</tr>
<tr>
<td>“”</td>
<td>含有变量置换功能</td>
</tr>
<tr>
<td>``</td>
<td>中间为待执行的命令，和$()一致</td>
</tr>
<tr>
<td>()</td>
<td>中间为子shell的起始和结束</td>
</tr>
<tr>
<td>{}</td>
<td>中间为命令块</td>
</tr>
</tbody>
</table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在Linux的环境下，如果你不懂bash是什么，那么其他的东西就不用学了！
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_学会使用vim程序编辑器</title>
    <link href="http://bestlixiang.site/2018/03/26/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://bestlixiang.site/2018/03/26/走进Linux/走进Linux_学会使用vim程序编辑器/</id>
    <published>2018-03-26T09:06:33.000Z</published>
    <updated>2018-04-09T04:32:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：系统管理员的重要工作就是修改与设置某些重要软件的配置文件，因此至少得到学会一种以上的命令行界面的文本编辑器。在所有的Linux发行版中都具有vi这款编辑器，我们这次学的它的高级版vim。<a id="more"></a></p>
<h1 id="vi与vim"><a href="#vi与vim" class="headerlink" title="vi与vim"></a>vi与vim</h1><p>虽然在Linux在命令行界面下的文本编辑器有很多，比如Emacs，pico，nano，joe与vim等。但是我们却一定要学会vi或者说vim，vim相当于vi的高级版。</p>
<h2 id="为什么要学vim"><a href="#为什么要学vim" class="headerlink" title="为什么要学vim"></a>为什么要学vim</h2><ol>
<li>所有的UNIX Like系统都会内置vi文本编辑器，其他文本编辑器不一定存在。</li>
<li>所有软件的编辑结构都会主动调用vi（例如crontab，visudo,edquota等）<strong>很重要</strong></li>
<li>vim具有程序编辑能力，可以主动以字体颜色辨别语法的正确性，方便程序设计。</li>
<li>程序简单，编辑速度相当快速。</li>
</ol>
<h1 id="vi的使用"><a href="#vi的使用" class="headerlink" title="vi的使用"></a>vi的使用</h1><p>vi分为3种模式，分别是一般模式、编辑模式与命令行模式。它们的作用如下：</p>
<ol>
<li>一般模式：以vi打开一个文件就直接进入一般模式了。在这个模式中，你可以使用左右按键来移动光标，你可以删除字符或删除整行，也可以复制，粘贴你的文件数据。</li>
<li>编辑模式：在一般模式中是无法编辑文件内容的。要等到你按下“i,l,o,O,a,A,r,R”等任何一个字母之后才会进入编辑模式。通常在Linux中，按下这些按键时，在界面的左下方会出现INSERT或REPLACE的字样，此时才可以编辑，如果要回到一般模式，必须要按下ESC才可以退出编辑模式。</li>
<li>命令行模式：在一般模式中，输入“:、/、?”3个中的任何一个按钮，就可以将光标移动到最下面的那一行。在这个模式当中，可以提供你查找数据的操作，而读取、保存、大量替换字符、离开vi、显示行号等操作就是在此模式中完成的。</li>
</ol>
<h2 id="vi按键说明"><a href="#vi按键说明" class="headerlink" title="vi按键说明"></a>vi按键说明</h2><p>这个按键说明大部分人都会有总结，所以这里也就不再做无用功了，所以贴出下面的链接，遇到问题去查就好了，但是需要保证所有按键都亲自去试一遍！</p>
<p><strong><a href="https://blog.csdn.net/zyq522376829/article/details/47321739" target="_blank" rel="external">Linux - vim按键说明</a></strong></p>
<p>但是这里我还是想把<strong>常用的命令</strong>在这里再贴出来，希望能够记住：</p>
<ol>
<li>一般模式可用的按钮说明，光标移动、复制粘贴、查找替换等</li>
</ol>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + f</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键</td>
</tr>
<tr>
<td>Ctrl + b</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键</td>
</tr>
<tr>
<td>0 或功能键Home</td>
<td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td>
</tr>
<tr>
<td>$ 或功能键End</td>
<td>移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td>G</td>
<td>移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td>gg</td>
<td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td>
</tr>
<tr>
<td>nEnter</td>
<td>n为数字。光标向下移动 n 行(常用)</td>
</tr>
<tr>
<td>/word</td>
<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 server这个字符串，就输入 /vbird 即可！ (常用)</td>
</tr>
<tr>
<td>:n1,n2s/word1/word2/g</td>
<td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2</td>
</tr>
<tr>
<td>:1,$s/word1/word2/g</td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2</td>
</tr>
<tr>
<td>:1,$s/word1/word2/gc</td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代</td>
</tr>
<tr>
<td>x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键)</td>
</tr>
<tr>
<td>dd</td>
<td>删除游标所在的那一整列</td>
</tr>
<tr>
<td>ndd</td>
<td>n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列</td>
</tr>
<tr>
<td>yy</td>
<td>复制游标所在的那一行</td>
</tr>
<tr>
<td>nyy</td>
<td>n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列</td>
</tr>
<tr>
<td>p, P</td>
<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。</td>
</tr>
<tr>
<td>u</td>
<td>复原前一个动作</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>重做上一个动作</td>
</tr>
<tr>
<td>.</td>
<td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点“.”就好了！</td>
</tr>
</tbody>
</table>
<ol>
<li>一般模式切换到编辑模式的可用的按钮说明</li>
</ol>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>i, I</td>
<td>进入插入模式(Insert mode)：i 为从目前光标所在处插入， I 为在目前所在行的第一个非空格符处开始插入。</td>
</tr>
<tr>
<td>a, A</td>
<td>进入插入模式(Insert mode)：a为从目前光标所在的下一个字符处开始插入， A 为从光标所在行的最后一个字符处开始插入。</td>
</tr>
<tr>
<td>o, O</td>
<td>进入插入模式(Insert mode)：这是英文字母 o 的大小写。o 为在目前光标所在的下一行处插入新的一』； O 为在目前光标所在处的上一行插入新的一行！</td>
</tr>
<tr>
<td>r, R</td>
<td>进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止。</td>
</tr>
<tr>
<td>Esc</td>
<td>退出编辑模式，回到一般模式中</td>
</tr>
</tbody>
</table>
<ol>
<li>一般模式切换到指令列模式的可用的按钮说明</li>
</ol>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:w</td>
<td>将编辑的数据写入硬盘档案中</td>
</tr>
<tr>
<td>:q</td>
<td>离开 vi</td>
</tr>
<tr>
<td>:wq</td>
<td>储存后离开，若为 :wq! 则为强制储存后离开</td>
</tr>
</tbody>
</table>
<h1 id="vim的功能"><a href="#vim的功能" class="headerlink" title="vim的功能"></a>vim的功能</h1><p>目前大部分的发行版都以vim替代vi的功能了，如果你使用vi后，却看到界面的右下角有显示目前光标的行列号码，那么你的vi已经被vim替代了，vim相比于vi有许多新的功能。</p>
<h2 id="块操作"><a href="#块操作" class="headerlink" title="块操作"></a>块操作</h2><p>vi的操作基本上都是以行为单位的操作，但是vim具有块操作的功能，具体的按键说明如下：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>v</td>
<td>字符选择，将光标经过的地方反白选择</td>
</tr>
<tr>
<td>V</td>
<td>行选择，将光标经过的行反白选择</td>
</tr>
<tr>
<td>Ctrl + v</td>
<td>块选择，可以用长方形选择数据</td>
</tr>
<tr>
<td>y</td>
<td>将反白的地方复制</td>
</tr>
<tr>
<td>d</td>
<td>删除反白的地方</td>
</tr>
</tbody>
</table>
<h2 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h2><p>有事我们需要在一个vim内编辑多个文件，这个时候我们就需要多文件编辑功能，具体按键如下：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:n</td>
<td>编辑下一个文件</td>
</tr>
<tr>
<td>:N</td>
<td>编辑上一个文件</td>
</tr>
<tr>
<td>:files</td>
<td>列出目前这个vim打开的所有文件</td>
</tr>
</tbody>
</table>
<h2 id="多窗口功能"><a href="#多窗口功能" class="headerlink" title="多窗口功能"></a>多窗口功能</h2><p>很多时候我们需要对比文件，但是情况是在同一个vim窗口，这时候也就需要用到多窗口功能，具体按键如下：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>按键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>：sp filename</td>
<td>打开新窗口，如果有加filename,新窗口打开新文件，否则打开相同文件</td>
</tr>
<tr>
<td>Ctrl + w + j/↓</td>
<td>按键的按法是：先按下Ctrl不放，再按下w后放开所有的按键，然后再按下j或箭头，则光标可移动到下方的窗口</td>
</tr>
<tr>
<td>Ctrl + w + k/↑</td>
<td>同上，但是光标移动到上面的窗口</td>
</tr>
</tbody>
</table>
<h2 id="vim常用命令示意图"><a href="#vim常用命令示意图" class="headerlink" title="vim常用命令示意图"></a>vim常用命令示意图</h2><p><img src="http://o6plzvjf2.bkt.clouddn.com/linux/jpg/vim.jpg" alt="vim"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
<li><a href="https://blog.csdn.net/zyq522376829/article/details/47321739" target="_blank" rel="external">Linux - vim按键说明</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：系统管理员的重要工作就是修改与设置某些重要软件的配置文件，因此至少得到学会一种以上的命令行界面的文本编辑器。在所有的Linux发行版中都具有vi这款编辑器，我们这次学的它的高级版vim。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_Linux磁盘与文件系统管理</title>
    <link href="http://bestlixiang.site/2018/03/25/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_Linux%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    <id>http://bestlixiang.site/2018/03/25/走进Linux/走进Linux_Linux磁盘与文件系统管理/</id>
    <published>2018-03-25T12:02:04.000Z</published>
    <updated>2018-04-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：系统管理员最重要的任务之一就是管理好自己的磁盘文件系统，所以本文的知识对于那些需要规划自己磁盘文件系统的人群特别重要，有些内容可能不太详细，所以日后自己亲身实践过后，希望能再开一篇详细的文章。<a id="more"></a></p>
<h1 id="认识文件系统"><a href="#认识文件系统" class="headerlink" title="认识文件系统"></a>认识文件系统</h1><p>Linux最传统的磁盘文件系统使用的是EXT2（索引式文件系统）。所以要了解文件系统就得要又认识EXT2开始。</p>
<p>在Linux中，需要记录文件权限与文件属性，所以文件系统通常会将这两部分的数据分别存放在不同的块，权限和属性放置到inode中，至于实际数据则放置到data block块中，另外还有一个超级块（superblock）会记录整体文件系统的整体信息。<br>每个inode，block都有编号，下面简略说明上面三个数据的意义：</p>
<ol>
<li>super block：记录此文件系统的整体信息，包括inode/block的总量、使用量、以及文件系统的格式与相关信息。</li>
<li>inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block号码。</li>
<li>block：实际记录文件的内容，若文件太大时，会占用多个block。</li>
</ol>
<h1 id="Linux的Ext2文件系统"><a href="#Linux的Ext2文件系统" class="headerlink" title="Linux的Ext2文件系统"></a>Linux的Ext2文件系统</h1><ol>
<li>Ext2文件系统主要有boot sector，superblock，inode bitmap，block bitmap，inode table，data block六大部分。</li>
<li>data block是用来放置文件内容数据的地方，在Ext2文件系统中所支持的block大小有1KB、2KB及4KB三种。</li>
<li>inode记录文件的属性/权限等数据，每个inode大小均固定为128bytes；每个文件都仅占有一个inode而已；因此文件系统能够新建的文件数量，与inode数量有关。</li>
<li>文件的block记录文件的实际数据，目录的block则记录该目录下面文件名与其inode号码的对照表。</li>
<li>日志文件系统会多出一块记录区，随时记载文件系统的主要活动，可加快恢复时间。</li>
<li>Linux文件系统为增加其性能，会让主存储器作为大量的磁盘高速缓存。</li>
</ol>
<h1 id="文件系统的简单操作"><a href="#文件系统的简单操作" class="headerlink" title="文件系统的简单操作"></a>文件系统的简单操作</h1><h2 id="磁盘与目录的容量：df，du"><a href="#磁盘与目录的容量：df，du" class="headerlink" title="磁盘与目录的容量：df，du"></a>磁盘与目录的容量：df，du</h2><ol>
<li><p>df：列出文件系统的整体磁盘使用量</p>
<p> 在执行df命令之后，会出现如下信息：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">文件系统          1K-块    已用     可用 已用% 挂载点</div><div class="line">/dev/vda1      51474044 6759800 42092876   14% /</div><div class="line">devtmpfs         932632       0   932632    0% /dev</div><div class="line">tmpfs            941920      24   941896    1% /dev/shm</div><div class="line">tmpfs            941920     316   941604    1% /run</div><div class="line">tmpfs            941920       0   941920    0% /sys/fs/cgroup</div><div class="line">tmpfs            188388       0   188388    0% /run/user/0</div></pre></td></tr></table></figure>
</li>
<li><p>du：评估文件系统的磁盘使用量（常用于评估目录所占容量）</p>
<p> 可以看看下面的案例：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 1. 列出目前目录下的所有文件容量</div><div class="line">du</div><div class="line">// 2. 同范例一，但是将文件的容量也列出来</div><div class="line">du -a</div><div class="line">// 3. 检查根目录下面每个目录所占用的容量</div><div class="line">du -sm /*</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="连接文件"><a href="#连接文件" class="headerlink" title="连接文件"></a>连接文件</h2><ol>
<li><p>hard link (硬连接或实际连接)</p>
<p> hard link只是在某个目录下新建一条文件名连接到某inode号码的管理记录。它的命令如下：</p>
<blockquote>
<p>ln</p>
</blockquote>
<p> hard link是有如下限制的：</p>
<ul>
<li>不能跨文件系统</li>
<li>不能连接到目录</li>
</ul>
</li>
<li><p>symbolic link (符号连接，也即是快捷方式)</p>
<p> symbolic link就是在创建一个独立的文件，而这个文件会让数据的读取指向它连接的按个文件的文件名。它的命令如下：</p>
<blockquote>
<p>ls -s</p>
</blockquote>
<p> symbolic link与Windows的快捷方式可以画上等号，如果原文件被删除了，那symbolic link也就不能用了。</p>
</li>
</ol>
<h1 id="磁盘的分区、格式化、校验与挂载"><a href="#磁盘的分区、格式化、校验与挂载" class="headerlink" title="磁盘的分区、格式化、校验与挂载"></a>磁盘的分区、格式化、校验与挂载</h1><p>对于一个系统管理者(root)而言，磁盘的管理是相对重要的一环，如果我们想要在系统里面新增一块硬盘，应该有哪些动作需要做？</p>
<ol>
<li>对磁盘进行分区，以新建可用的分区</li>
<li>对该分区进行格式化，以创建系统可用的文件系统</li>
<li>若想要仔细一点，则可对刚才新建好的文件系统进行校验</li>
<li>在Linux系统上，需要创建挂载点（也即是目录），并将它挂载上来</li>
</ol>
<h2 id="磁盘分区：fdisk"><a href="#磁盘分区：fdisk" class="headerlink" title="磁盘分区：fdisk"></a>磁盘分区：fdisk</h2><p>输入如下命令，进入磁盘分区操作：</p>
<blockquote>
<p>fdisk /dev/hdc(磁盘名)</p>
</blockquote>
<p>接下来就是按照提示新增或者删除分区了。</p>
<h2 id="磁盘格式化：mkfs"><a href="#磁盘格式化：mkfs" class="headerlink" title="磁盘格式化：mkfs"></a>磁盘格式化：mkfs</h2><p>分区完毕之后就要进行格式化，格式化非常简单，使用mkfs（make file system）即可。命令如下：</p>
<blockquote>
<p>mkfs [-t 文件系统格式] 磁盘设备的文件名</p>
</blockquote>
<p>-t后的文件系统格式就是让你指定将文件系统格式化成哪种文件系统。如ext2、ext3、vfat等。</p>
<h2 id="磁盘检验：fsck"><a href="#磁盘检验：fsck" class="headerlink" title="磁盘检验：fsck"></a>磁盘检验：fsck</h2><p>当系统运行出现问题导致文件系统发生错乱，此时就需要磁盘的检验。命令如下：</p>
<blockquote>
<p>fsck [-t 文件系统] [-ACay] 设备名称</p>
</blockquote>
<p>通常只有root用户，而且在文件系统有问题的时候才能进行这个操作，因为在正常情况下使用这个命令会对系统伤害很大。 此外，fsck在扫描的时候，有问题的数据会被放在lost＋found这个文件夹中。所以正常情况下这个文件夹中是不应该有数据的。</p>
<h2 id="磁盘挂载与卸载：mount，umount"><a href="#磁盘挂载与卸载：mount，umount" class="headerlink" title="磁盘挂载与卸载：mount，umount"></a>磁盘挂载与卸载：mount，umount</h2><p>在挂载前需要确定下面几件事：</p>
<ol>
<li>单一文件系统不应该被重复挂载在不同的挂载点（目录）中</li>
<li>单一目录不应该重复挂载多个文件系统</li>
<li>作为挂载带你的目录理论上应该都是空目录</li>
</ol>
<p>具体命令如下</p>
<ul>
<li><p>挂载：</p>
<blockquote>
<p>mount [-t 文件系统] [-L 文件系统的卷标名称] [-o 额外选项] [-n] 设备文件名 挂载点  </p>
</blockquote>
</li>
<li><p>卸载</p>
<blockquote>
<p>umount [-fn] 设备文件名或挂载点</p>
</blockquote>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：系统管理员最重要的任务之一就是管理好自己的磁盘文件系统，所以本文的知识对于那些需要规划自己磁盘文件系统的人群特别重要，有些内容可能不太详细，所以日后自己亲身实践过后，希望能再开一篇详细的文章。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_Linux文件与目录管理大全解</title>
    <link href="http://bestlixiang.site/2018/03/25/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E5%A4%A7%E5%85%A8%E8%A7%A3/"/>
    <id>http://bestlixiang.site/2018/03/25/走进Linux/走进Linux_Linux文件与目录管理大全解/</id>
    <published>2018-03-25T01:40:30.000Z</published>
    <updated>2018-04-09T04:31:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在使用Linux的过程中，最多的命令莫过于在操作文件与目录，所以通过本文，能让你大概率熟悉所有关于文件与目录的命令与知识，但是参数方面就需要自己去查询了。<a id="more"></a></p>
<h1 id="目录与路径"><a href="#目录与路径" class="headerlink" title="目录与路径"></a>目录与路径</h1><h2 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h2><ol>
<li>绝对路径：路径的写法<strong>一定由根目录/写起</strong>。</li>
<li>相对路径：路径的写法是相对于当前工作目录写的。</li>
</ol>
<h2 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h2><ol>
<li><p>特殊目录列表</p>
<ul>
<li>. ：当前目录</li>
<li>.. ：上层目录</li>
<li>- ：前一个工作目录</li>
<li>~ ：登陆用户的主文件夹</li>
<li>~account ：这个用户的主文件夹 （account是个账号名称）</li>
</ul>
</li>
<li><p>常见目录处理的命令</p>
<ul>
<li>cd：切换目录</li>
<li>pwd：显示当前目录</li>
<li>mkdir：新建一个新的目录</li>
<li>rmdir：删除一个空的目录，删除非空目录需要使用rm -r</li>
<li>好习惯：经常利用Tab键快速完整地输入目录或命令</li>
</ul>
</li>
<li><p>环境变量PATH</p>
<p> 当我们执行命令：ls －al的时候，系统会按照PATH设置的路径，去这些路径中寻找ls这个文件，并执行。如果PATH路径中有多个ls文件，那么先找到的那个ls文件被执行。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 查看PATH</span></div><div class="line">echo $PATH</div><div class="line"><span class="comment">// 在PATH中添加路径/demo</span></div><div class="line">PATH=<span class="string">"$PATH"</span>:/demo</div></pre></td></tr></table></figure>
<p> 对于PATH我们有几点需要清楚：</p>
<ul>
<li>不同身份用户默认的PATH不同，默认能够随意执行的命令也不同，差异较大的地方在于/sbin和/usr/sbin。</li>
<li>PATH是可以修改的，所以一般用户还是可以通过修改PATH来执行某些位于/sbin或/usr/sbin下的命令来查询。</li>
<li>使用绝对路径或相对路径直接指定某个命令的文件名来执行。</li>
<li>命令应该要放在正确的目录下，执行才会比较方便。</li>
<li>本目录（.）最好不要放到PATH当中，因为本目录会变化。</li>
</ul>
</li>
</ol>
<h1 id="文件和目录管理"><a href="#文件和目录管理" class="headerlink" title="文件和目录管理"></a>文件和目录管理</h1><p>在文件与目录的管理上，不外乎“显示属性”、“复制”、“删除文件”、“移动目录或文件”等。下面这这种管理动作的具体指令：</p>
<ol>
<li>显示属性<blockquote>
<p>ls</p>
</blockquote>
</li>
<li>复制<blockquote>
<p>cp</p>
</blockquote>
</li>
<li>删除<blockquote>
<p>rm</p>
</blockquote>
</li>
<li>移动(重命名)<blockquote>
<p>mv</p>
</blockquote>
</li>
</ol>
<p>这些指令的具体参数，希望大家能够通过man info去熟悉。</p>
<p>我们可以通过下面的命令去取得路径的文件名与目录名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 取得文件名称</div><div class="line">basename /etc/sysconfig/network</div><div class="line">// 取得文件目录</div><div class="line">dirname /etc/sysconfig/network</div></pre></td></tr></table></figure></p>
<h1 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h1><p>主要有下面一些命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>cat</td>
<td>由第一行开始显示文件内容</td>
</tr>
<tr>
<td>tac</td>
<td>从最后一行开始显示，可以看出tac是cat的到写形式</td>
</tr>
<tr>
<td>nl</td>
<td>显示的时候，顺便输出符号</td>
</tr>
<tr>
<td>more</td>
<td>一页一页显示文件内容</td>
</tr>
<tr>
<td>less</td>
<td>与more类似，但是比more更好的是，它可以往前翻页</td>
</tr>
<tr>
<td>head</td>
<td>只看头几行</td>
</tr>
<tr>
<td>tail</td>
<td>只看尾几行</td>
</tr>
<tr>
<td>od</td>
<td>以二进制的方式读取文件内容</td>
</tr>
</tbody>
</table>
<h1 id="文件与目录的默认权限和隐藏权限"><a href="#文件与目录的默认权限和隐藏权限" class="headerlink" title="文件与目录的默认权限和隐藏权限"></a>文件与目录的默认权限和隐藏权限</h1><p>除了基本的rwx权限之外，Linux的ext2/ext3文件系统下，我们还可以设置系统隐藏属性，它可以用chattr来设置，用lsattr来查看。最重要的属性就是可以设置文件/目录为不可修改，这可以让文件所有者都不能进行修改，这对于安全性方面是非常重要的。</p>
<h2 id="文件的默认权限：umask"><a href="#文件的默认权限：umask" class="headerlink" title="文件的默认权限：umask"></a>文件的默认权限：umask</h2><p>umask指定了目前用户在新建文件或目录时候的权限默认值。</p>
<p>指定了以下面的方式来指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@VM_0_9_centos ~]# umask</div><div class="line">0022 // 与一般权限有关的是后面是三个数字(表示不拥有该数值的权限，此例就表示group不拥有w，others不拥有w)</div><div class="line">[root@VM_0_9_centos ~]# umask -S</div><div class="line">u=rwx,g=rx,o=rx</div><div class="line"></div><div class="line">// 设置默认权限</div><div class="line">umask 002</div></pre></td></tr></table></figure></p>
<p>在默认权限的属性上，目录与文件是不一样的，x权限对于目录是非常重要的，但是一般文件的创建则不应该拥有执行权限。所以默认情况下：</p>
<ul>
<li>若用户创建“文件”则默认没有可执行权限，默认权限为666，即-rw-rw-rw-</li>
<li>若用户创建“目录”则默认拥有可执行权限，默认权限为777，即drwxrwxrwx</li>
</ul>
<h2 id="文件隐藏属性chattr，lsattr"><a href="#文件隐藏属性chattr，lsattr" class="headerlink" title="文件隐藏属性chattr，lsattr"></a>文件隐藏属性chattr，lsattr</h2><ol>
<li><p>chattr 设置文件的隐藏属性</p>
<p> 注意参数a（文件只能增加数据，不能删除也不能修改数据）和i(不能 删除，修改)</p>
</li>
<li>lsattr 显示文件隐藏属性</li>
</ol>
<h2 id="文件的特殊权限SUID-SGID-SBIT"><a href="#文件的特殊权限SUID-SGID-SBIT" class="headerlink" title="文件的特殊权限SUID,SGID,SBIT"></a>文件的特殊权限SUID,SGID,SBIT</h2><ol>
<li>SUID(u+s,如x为空，则出现大S)，限制与功能如下：<ul>
<li>SUID权限仅对二进制程序有效</li>
<li>执行者对于该程序需要x的可执行权限</li>
<li>本权限仅在执行该程序的过程中有效</li>
<li>执行者将具有该程序所有者的权限</li>
</ul>
</li>
<li>SGID（g+s,如x为空，则出现大S），对于文件功能与SUID类似，但是对于目录有如下功能：<ul>
<li>用户若对于此目录具有r与x的权限时，该用户能够进入此目录</li>
<li>用户在此目录下得有效用户组将变成该目录的用户组</li>
<li>若用户在此目录下具有w的权限（可以新建文件），则用户所创建的新文件的用户组与此目录的用户组相同</li>
</ul>
</li>
<li>SBIT（o+t,如x为空，则出现大T），目前只针对目录有效，它的作用如下：<ul>
<li>当用户对于此目录具有w，x权限，即具有写入的权限时，当用户在该目录下创建文件或目录时，仅有自己与root才有权利删除该文件。</li>
</ul>
</li>
</ol>
<h2 id="查看文件类型：file"><a href="#查看文件类型：file" class="headerlink" title="查看文件类型：file"></a>查看文件类型：file</h2><p>如果想知道某个文件的基本数据，就可以使用file这个命令查看。</p>
<h1 id="文件与命令的查询"><a href="#文件与命令的查询" class="headerlink" title="文件与命令的查询"></a>文件与命令的查询</h1><h2 id="脚本文件名的查询"><a href="#脚本文件名的查询" class="headerlink" title="脚本文件名的查询"></a>脚本文件名的查询</h2><p>如果你想知道类似ls这种命令的脚本放在哪里，就通过which或type来找寻。</p>
<p>which命令是根据PATH这个环境变量所规范的路径去查询“执行文件”的文件名。</p>
<h2 id="文件名的查找"><a href="#文件名的查找" class="headerlink" title="文件名的查找"></a>文件名的查找</h2><p>通常find不很常用，因为速度慢，通常我们都是先使用whereis或者是locate来检查，如果真的找不到了，才以find来查找，因为whereis与loacate是利用数据库来查询数据的，而find是直接查找硬盘的。</p>
<ol>
<li>whereis：寻找特定文件</li>
<li>locate：根据文件的部分名称查找，由于是查询数据库的，而数据库是当晚更新，所以你新建文件是查找不到的，可以利用updatedb手动更新，但是较慢。</li>
<li>find：参数很多，自己用的时候需要使用man page自行了解。</li>
</ol>
<h1 id="文件与文件系统的压缩与打包"><a href="#文件与文件系统的压缩与打包" class="headerlink" title="文件与文件系统的压缩与打包"></a>文件与文件系统的压缩与打包</h1><h2 id="常见的压缩命令"><a href="#常见的压缩命令" class="headerlink" title="常见的压缩命令"></a>常见的压缩命令</h2><p>不同的压缩打包技术，对应着不同的解压缩拆包技术，所以在Linux中用后缀名来分辨压缩打包技术，如下表：</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>压缩打包技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>*.Z</td>
<td>compress程序压缩</td>
</tr>
<tr>
<td>*.gz</td>
<td>gzip程序压缩</td>
</tr>
<tr>
<td>*.bz2</td>
<td>bzip2程序压缩</td>
</tr>
<tr>
<td>*.tar</td>
<td>tar程序打包，未压缩</td>
</tr>
<tr>
<td>*.tar.gz</td>
<td>tar程序打包,gzip程序压缩</td>
</tr>
<tr>
<td>*.tar.bz2</td>
<td>tar程序打包,bzip2程序压缩</td>
</tr>
</tbody>
</table>
<p>由于compress已经不再流行，所有我们主要讲解gzip和gzip2:</p>
<ol>
<li><p>gzip,zcat（用来替代compress）</p>
<p> 目前gzip可以解开compress、zip与gzip等软件压缩的文件。可以看一下下面的案例：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 1. 压缩文件</div><div class="line">gzip -v 文件名 // 参数v显示压缩比</div><div class="line">// 2. 查看压缩文件内容</div><div class="line">zcat 压缩文件</div><div class="line">// 3. 解压缩</div><div class="line">gzip -d 压缩文件名 // 参数d表示解压缩</div></pre></td></tr></table></figure>
</li>
<li><p>bzip2,bzcat（用来替代gzip）</p>
<p> 使用方法与gzip基本相同，不再赘述。</p>
</li>
</ol>
<h2 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h2><p>在压缩文件夹之前需要打包，然后我们就需要用到大名鼎鼎的tar，下面通过命令来具体介绍他的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 1. 压缩，参数的含义自己去用man page查看</div><div class="line">tar -jcv -f filename.tar.bz2 // 要被压缩的文件或目录名称，tar并不会主动产生创建的文件名</div><div class="line">// 2. 查询</div><div class="line">tar -jtv -f filename.tar.bz2</div><div class="line">// 3. 解压缩</div><div class="line">tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录（如：/tmp）</div></pre></td></tr></table></figure></p>
<p>对于只是打包没有压缩的文件叫做tarfile</p>
<p>对于打包了并且压缩的文件叫做tarball</p>
<h2 id="完整备份工具"><a href="#完整备份工具" class="headerlink" title="完整备份工具"></a>完整备份工具</h2><ol>
<li>dump 备份</li>
<li>restore 恢复</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在使用Linux的过程中，最多的命令莫过于在操作文件与目录，所以通过本文，能让你大概率熟悉所有关于文件与目录的命令与知识，但是参数方面就需要自己去查询了。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_Linux的文件权限与目录配置</title>
    <link href="http://bestlixiang.site/2018/03/22/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://bestlixiang.site/2018/03/22/走进Linux/走进Linux_Linux的文件权限与目录配置/</id>
    <published>2018-03-22T09:03:13.000Z</published>
    <updated>2018-04-09T04:31:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：了解好文件权限和目录的具体含义才能更好的操作Linux，所以理解好文件权限与目录配置才至关重要。<a id="more"></a></p>
<h1 id="用户与用户组"><a href="#用户与用户组" class="headerlink" title="用户与用户组"></a>用户与用户组</h1><h2 id="用户（User）"><a href="#用户（User）" class="headerlink" title="用户（User）"></a>用户（User）</h2><ol>
<li>用户可以随意改变自己所拥有的文件</li>
<li>root用户就是最大的大佬，可以干任何事。</li>
</ol>
<h2 id="用户组（Group）"><a href="#用户组（Group）" class="headerlink" title="用户组（Group）"></a>用户组（Group）</h2><ol>
<li>同一个用户组的用户可以访问该用户组的文件</li>
<li>每个账号可以加入多个用户组</li>
<li>在同一个用户组的文件也可以设置不同的权限，可以不让本组用户查看</li>
</ol>
<h2 id="其他人（Others）"><a href="#其他人（Others）" class="headerlink" title="其他人（Others）"></a>其他人（Others）</h2><p>除了文件用户、同组用户以外的人就是其他人。</p>
<h2 id="Linux用户身份与用户组记录的文件"><a href="#Linux用户身份与用户组记录的文件" class="headerlink" title="Linux用户身份与用户组记录的文件"></a>Linux用户身份与用户组记录的文件</h2><ol>
<li>系统上的账号与一般身份用户以及root的相关信息都记录在/etc/passwd文件中</li>
<li>个人的密码都记录在/etc/shadow文件中</li>
<li>Linux所有的组名都记录在/etc/group文件中</li>
</ol>
<h1 id="文件权限概念"><a href="#文件权限概念" class="headerlink" title="文件权限概念"></a>文件权限概念</h1><h2 id="Linux文件属性"><a href="#Linux文件属性" class="headerlink" title="Linux文件属性"></a>Linux文件属性</h2><p>我们可以利用下面的命令来查看文件属性：</p>
<blockquote>
<p>ls -al  // 列出所有文件详细的权限和属性（包含隐藏文件）</p>
</blockquote>
<p>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">总用量 92</div><div class="line">drwxr-xr-x. 22 root root 4096 3月  17 12:33 .</div><div class="line">dr-xr-xr-x. 20 root root 4096 3月  22 09:14 ..</div><div class="line">drwxr-xr-x.  2 root root 4096 11月  5 2016 adm</div><div class="line">drwxr-xr-x   2 root root 4096 3月  12 10:27 alldata</div><div class="line">... 省略</div></pre></td></tr></table></figure></p>
<p>解释一下上面7列的意思：</p>
<ol>
<li><p>第一列：文件的类型与权限</p>
<p> 第一个字符代表这个文件是“目录、文件或链接文件等”。</p>
<ul>
<li>d：目录文件</li>
<li>-：普通文件</li>
<li>l：链接文件</li>
<li>b：用于存储数据的设备文件</li>
<li><p>c：用于传输数据的设备文件：鼠标、键盘</p>
<p>接下来都是三个字符为一组，分别表示文件所有者的权限、同组用户的权限、其他用户的权限，而且r（读）、w（写）、x（执行）的顺序是固定不变的。</p>
</li>
</ul>
</li>
<li>第二列：有多少文件名连接到此节点</li>
<li>第三列：这个文件（或目录）的所有者账号</li>
<li>第四列：这个文件所属的用户组</li>
<li>第五列：这个文件的大小，单位是B</li>
<li>第六列：这个文件的创建日期或修改日期</li>
<li>第七列：文件名</li>
</ol>
<h2 id="改变文件属性与权限的命令"><a href="#改变文件属性与权限的命令" class="headerlink" title="改变文件属性与权限的命令"></a>改变文件属性与权限的命令</h2><ol>
<li>chgrp：改变文件所属的用户组 （注意-R 参数，递归更改）</li>
<li>chown：改变文件所有者 （注意-R 参数，递归更改）</li>
<li><p>chmod：改变文件的权限 （注意-R 参数，递归更改）</p>
<p> 改变文件的权限有两种办法，分别是：用数字进行权限的修改、用符号进行权限的修改。</p>
<ul>
<li><p>用数字进行权限的修改：权限有9个字母组成，并且每三个为一组，分别表示：文件主的权限、同组用户的权限、其他人的权限。在这种方式中，r＝4、w＝2、x＝1，将每一组的三个值加起来，组成一个三位数即可。实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod -R 754 文件或目录</div></pre></td></tr></table></figure>
</li>
<li><p>用符号进行权限的修改：我们通过u(user)，g(group)，o(others)，a(all)来表示身份权限，通过<br>r（读）,w（写）,x（执行）来表示读写的权限，通过+（加入），-（除去），=（设置）来表示修改操作，实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod u/g/o/a  +/-/=  r/w/x  文件/目录</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="目录与文件的权限意义"><a href="#目录与文件的权限意义" class="headerlink" title="目录与文件的权限意义"></a>目录与文件的权限意义</h2><ol>
<li>权限对文件的重要性：<ul>
<li>r：可读取此文件的实际内容。</li>
<li>w：可以编辑、新增或者修改该文件的内容（单不含删除该文件）</li>
<li>x：该文件具有可以被系统执行的权限。</li>
</ul>
</li>
<li>权限对目录的重要性<ul>
<li>r：表示具有读取目录结构的权限，即可以执行ls命令</li>
<li>w：表示具有更改该目录结构列表的权限，比如新建新的文件与目录、删除已经存在的文件与目录、将已存在或目录进行重命名、转移该目录内的文件和目录位置</li>
<li>x：表示用户能否进入该目录，即可以使用cd进入该目录</li>
</ul>
</li>
</ol>
<h2 id="文件种类与扩展名"><a href="#文件种类与扩展名" class="headerlink" title="文件种类与扩展名"></a>文件种类与扩展名</h2><ol>
<li>文件种类<ul>
<li>普通文件<ul>
<li>纯文本文件（ASCII），可以用cat命令读取</li>
<li>二进制文件（binary），Linux中的可执行文件</li>
<li>数据格式文件（data），就是程序运行时会被读取的具有特定格式的文件，如配置文件，需要用last命令去读取，用cat读取会乱码</li>
</ul>
</li>
<li>目录</li>
<li>连接文件，类似Windows下的快捷方式</li>
<li>设备与设备文件<ul>
<li>块设备文件，用于存储数据的设备文件，如：硬盘、软盘</li>
<li>字符设备文件，用于数据传输的设备文件，如：键盘、鼠标</li>
<li>套接字，这个设备文件在/var/run中</li>
<li>管道，用于解决多个程序同时访问一个文件所造成的错误问题</li>
</ul>
</li>
</ul>
</li>
<li><p>文件扩展名</p>
<p> Linux并没有扩展名，一个Linux的文件是否可以执行，取决于这个文件的属性中是否有x这个权限（也要真的可以执行）。<br> 但是为了增强文件的可读性，我们还是给文件增加了“扩展名“。如下面几种（等）：</p>
<ul>
<li>＊.sh表示脚本或批处理文件</li>
<li>＊Z、＊.tar、＊.tar.gz、＊.zip、＊.tgz他们都是压缩文件</li>
<li><p>注意：从网上下载的文件的权限是有可能发生改变的，所以当我们下载的文件无法运行时查看一下它的权限是否有x。</p>
<p>Linux对文件的限制：Linxu默认采用Ext2/Ext3文件系统，对文件名的长度限制为，单个文件名或目录名最大长度255个字符；完整的文件或目录名最大长度为4096个字符。</p>
</li>
</ul>
</li>
</ol>
<h1 id="Linux目录配置"><a href="#Linux目录配置" class="headerlink" title="Linux目录配置"></a>Linux目录配置</h1><h2 id="Linux目录配置标准"><a href="#Linux目录配置标准" class="headerlink" title="Linux目录配置标准"></a>Linux目录配置标准</h2><p>FHS一句文件系统使用的频繁与否与是否允许用户随意改动，而将目录定义为四中交互的形态，如下：</p>
<table>
<thead>
<tr>
<th>/</th>
<th>可分享的(shareable)</th>
<th>不可分享的(unshareable)</th>
</tr>
</thead>
<tbody>
<tr>
<td>不变的(static)</td>
<td>/usr (软件放置处)</td>
<td>/etc (配置文件)</td>
</tr>
<tr>
<td>不变的(static)</td>
<td>/opt (第三方软件)</td>
<td>/boot(开机与内核文件)</td>
</tr>
<tr>
<td>可变动的(variable)</td>
<td>/var/mail (用户邮箱信件)</td>
<td>/var/run (程序相关)</td>
</tr>
<tr>
<td>可变动的(variable)</td>
<td>/var/spool/news (新闻组)</td>
<td>/var/lock (程序相关)</td>
</tr>
</tbody>
</table>
<p>解释一下四个类型的意思：</p>
<ul>
<li>可分享的：可以分享给网络上的其他主机挂载使用</li>
<li>不可分享的：只与自己的机器有关，所以自然就不能分享给其他主机</li>
<li>不变的：不管什么样的distributions，这些数据基本不发生变化。一般这些目录中存放函数库、系统配置文件等</li>
<li>可变的：经常改变的数据，如登录文件、新闻组等</li>
</ul>
<p><strong>根目录是整个系统最重要的目录，其他所有的子目录都是由根目录衍生而来的，同时根目录也与开机、还原、系统修复等操作有关。</strong></p>
<p>FHS建议：根目录要足够的小，而且应用程序不要和根目录放在同一个分区中。同时，FHS建议根目录下应该要有这些目录：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin</td>
<td>在bin目录下的命令可以被所有账号使用，一般的命令是：cat、chmod、chown、date、mv、mkdir、cp、bash</td>
</tr>
<tr>
<td>/boot</td>
<td>主要放置开机会使用到的文件</td>
</tr>
<tr>
<td>/dev</td>
<td>任何设备都是以文件的形式存放在这个目录当中</td>
</tr>
<tr>
<td>/etc</td>
<td>统主要的配置文件都放在这个目录中。这个目录下的文件属性是可以给一般用户查阅的，但只有root才可以修改，FHS建议：这个目录下不要放置可执行文件</td>
</tr>
<tr>
<td>/home</td>
<td>系统默认的用户主文件夹,～表示当前登陆用户的主文件夹 ，～rex表示指定用户的主文件夹</td>
</tr>
<tr>
<td>/lib</td>
<td>存放开机时用到的库函数及/bin、/sbin目录下的命令会使用到的库函数</td>
</tr>
<tr>
<td>/media</td>
<td>放置可删除的设备文件。如：软盘、光盘</td>
</tr>
<tr>
<td>/mnt</td>
<td>如果要临时挂载一些额外的设备就放在这个文件夹下</td>
</tr>
<tr>
<td>/opt</td>
<td>放置第三方软件的目录</td>
</tr>
<tr>
<td>/root</td>
<td>系统管理员的主文件夹</td>
</tr>
<tr>
<td>/sbin</td>
<td>放置开机过程中需要的，包括开机、修复、还原系统所需要的命令</td>
</tr>
<tr>
<td>/srv</td>
<td>是service的缩写，存放网络服务所需的一些数据</td>
</tr>
<tr>
<td>/tmp</td>
<td>一般用户执行程序暂时存放数据的地方。任何人都可以访问，所以要定时清理一下。FHS建议distributions开机时要将这个目录清空</td>
</tr>
</tbody>
</table>
<p>其他重要的目录：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>/lost+found</td>
<td>使用ext2/ext3文件系统才会产生的一个目录。当文件系统发生错误时，一些丢失的片段就会放在这个目录中</td>
</tr>
<tr>
<td>/proc</td>
<td>是一个虚拟文件系统，也就是它的数据都是存放在内存中的，不占用硬盘空间</td>
</tr>
<tr>
<td>/sys</td>
<td>也是一个虚拟文件系统，记录内核相关信息</td>
</tr>
</tbody>
</table>
<p>开机的时候只有根目录被挂载了，其他的目录所在的分区都是在系统启动完成之后才被挂载的。因此与开机过程有关的目录就必须要和根目录放在同一个分区中。必须与根目录放在同一个分区中的目录有下面这些目录：</p>
<ul>
<li>/etc：配置文件</li>
<li>/bin：重要的执行文件</li>
<li>/dev：所需要的设备文件</li>
<li>/lib：执行文件所需要的库函数与内核所需要的模块</li>
<li>/sbin：重要的系统执行文件</li>
</ul>
<p>/usr目录：＝UNIX Software Resource，是操作系统关键资源放置的目录。<br>FHS建议：所有软件开发者都应将数据放置在这个目录的子目录下，而不要自行创建独立的目录。<br>这个目录就相当于Windows下的c:\program files</p>
<p>/var目录：/usr放置安装程序时所需要的较大容量的文件，而/var下存放系统运行后才会渐渐占用硬盘的目录。如：缓存、日志、Mysql数据库的文件等。</p>
<h2 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h2><p>在Linux里面，所有的文件与目录都是由根目录开始的，那是所有目录与文件的源头，然后在一个一个分支下来，我们称这种目录配置为<strong>目录树</strong>。</p>
<p>目录树主要有以下特征：</p>
<ol>
<li>目录树的起始点为根目录（/，root）</li>
<li>每个目录不只能使用本地端的文件系统，也可以使用网络上的文件系统，例如可以利用NFS服务器挂载某特定目录等</li>
<li>米格文件在此目录树的文件名（包含完整路径）都是独一无二的。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：了解好文件权限和目录的具体含义才能更好的操作Linux，所以理解好文件权限与目录配置才至关重要。
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>走进Linux_Linux命令使用与查询</title>
    <link href="http://bestlixiang.site/2018/03/21/%E8%B5%B0%E8%BF%9BLinux/%E8%B5%B0%E8%BF%9BLinux_Linux%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%9F%A5%E8%AF%A2/"/>
    <id>http://bestlixiang.site/2018/03/21/走进Linux/走进Linux_Linux命令使用与查询/</id>
    <published>2018-03-21T08:55:52.000Z</published>
    <updated>2018-04-09T04:31:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：从浅入深，我们也从基础命令开始。学会基本命令的使用，学会怎么去查命令的使用，最后学会一丢丢维护（开关机）。<br><a id="more"></a></p>
<h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><h2 id="开始执行命令"><a href="#开始执行命令" class="headerlink" title="开始执行命令"></a>开始执行命令</h2><p>首先我们要了解命令的格式：</p>
<blockquote>
<p>command(命令或可执行文件) <a href="选项">-options</a> parameter1(参数1) parameter2(参数2)</p>
</blockquote>
<p>如果命令太长，我们可以使用反斜杠(\)来转义[enter符号]，注意反斜杠必须立刻接特殊字符，才能转义。</p>
<p>在linux下面是区分大小写的。</p>
<h2 id="基础命令的操作"><a href="#基础命令的操作" class="headerlink" title="基础命令的操作"></a>基础命令的操作</h2><ol>
<li>显示日期与时间的命令：date</li>
<li>显示日历的命令：cal</li>
<li>简单好用的计算器：bc，使用quit停止</li>
</ol>
<h2 id="重要的热键"><a href="#重要的热键" class="headerlink" title="重要的热键"></a>重要的热键</h2><ol>
<li>Tab按键：具有命令补全，文件补齐的功能</li>
<li>ctrl + c：可以让程序立刻停下来</li>
<li>ctrl + d：通常代码键盘输入结束，相当于exit</li>
</ol>
<h1 id="在线求助man-page-与info-page"><a href="#在线求助man-page-与info-page" class="headerlink" title="在线求助man page 与info page"></a>在线求助man page 与info page</h1><h2 id="man-page"><a href="#man-page" class="headerlink" title="man page"></a>man page</h2><p>man其实是manual（操作说明）的简写，只要通过（man + 命令） 就会有详细的说明出现。</p>
<p>如 man date可以得到下面的文本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">DATE(1)                                  User Commands                                  DATE(1)</div><div class="line"></div><div class="line">NAME</div><div class="line">       date - print or set the system date and time</div><div class="line"></div><div class="line">SYNOPSIS</div><div class="line">       date [OPTION]... [+FORMAT]</div><div class="line">       date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</div><div class="line"></div><div class="line">DESCRIPTION</div><div class="line">       Display the current time in the given FORMAT, or set the system date.</div><div class="line"></div><div class="line">       Mandatory arguments to long options are mandatory for short options too.</div><div class="line"></div><div class="line">       -d, --date=STRING</div><div class="line">              display time described by STRING, not &apos;now&apos;</div><div class="line"></div><div class="line">        ...省略其他参数</div><div class="line"></div><div class="line">ENVIRONMENT</div><div class="line"></div><div class="line">EXAMPLES</div><div class="line"></div><div class="line">DATE STRING</div><div class="line"></div><div class="line">AUTHOR</div><div class="line">       Written by David MacKenzie.</div><div class="line"></div><div class="line">COPYRIGHT</div><div class="line"></div><div class="line">SEE ALSO</div><div class="line"></div><div class="line">GNU coreutils 8.22                       November 2016                                  DATE(1)</div></pre></td></tr></table></figure></p>
<p>我们首先看到的是“DATE(1)”，这个(1)是有特殊含义的，如下表：</p>
<table>
<thead>
<tr>
<th>代号</th>
<th>代表内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>用户在shell环境中可以操作的命令或可执行的文件</td>
</tr>
<tr>
<td>2</td>
<td>系统内核可调用的函数与工具等</td>
</tr>
<tr>
<td>3</td>
<td>一些常用的函数与函数库，大部分为C的函数库</td>
</tr>
<tr>
<td>4</td>
<td>设备文件的说明，通常在/dev的文件</td>
</tr>
<tr>
<td>5</td>
<td>配置文件或者某些文件的格式</td>
</tr>
<tr>
<td>6</td>
<td>游戏</td>
</tr>
<tr>
<td>7</td>
<td>惯例与协议等，例如Linux文件系统，网络协议、ASCII code等说明</td>
</tr>
<tr>
<td>8</td>
<td>系统管理员与可用的管理命令</td>
</tr>
<tr>
<td>9</td>
<td>跟kernel有关的文件</td>
</tr>
</tbody>
</table>
<p>我们要特别注意1，5，8这三个号码，尽量背下来。</p>
<p>在上面的man page中，以NAME作为开始介绍，最后还有个SEE ALSO来作为结束。基本上，man page大致分为以下几个部分：</p>
<table>
<thead>
<tr>
<th>代号</th>
<th>内容说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME</td>
<td>简短的命令、数据名称说明</td>
</tr>
<tr>
<td>SYNOPSIS</td>
<td>简短的命令执行语法（syntax）简介</td>
</tr>
<tr>
<td>DESCRIPTION</td>
<td>较为完整的说明，最好仔细看看</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>针对SYNNPSIS部分中，有列举的所有可用的选项说明</td>
</tr>
<tr>
<td>COMMANDS</td>
<td>在这个程序在执行的时候，可以在此程序中执行的命令</td>
</tr>
<tr>
<td>FILES</td>
<td>这个程序或数据所使用或参考或连接到的某些文件</td>
</tr>
<tr>
<td>SEE ALSO</td>
<td>这个命令或数据有相关的其他说明</td>
</tr>
<tr>
<td>EXAMPLES</td>
<td>一些可以参考的范例</td>
</tr>
<tr>
<td>BUGS</td>
<td>是否有相关的错误</td>
</tr>
</tbody>
</table>
<p>通常在查询某些数据是这样来查阅的：</p>
<ol>
<li>先看NAME的项目，略微看一下数据的意思</li>
<li>再仔细看一下DESCRIPTION，这个部分会提到很多相关的资料和用法。</li>
<li>如果这个命令其实很熟悉了，那么主要就是查询OPTIONS的部分了。</li>
<li>最后会看一下和这个资料有关的还有哪些东西可以使用。</li>
<li>某些说明内容还会列举有关的文件（FILES）来提供我们参考。</li>
</ol>
<p>man page 常用的按键：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>进行工作</th>
</tr>
</thead>
<tbody>
<tr>
<td>空格键</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>Page Down</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>Page Up</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>Home</td>
<td>去到第一页</td>
</tr>
<tr>
<td>End</td>
<td>在去到最后一页</td>
</tr>
<tr>
<td>/string</td>
<td>向下查询string字符串</td>
</tr>
<tr>
<td>?string</td>
<td>向上查询string字符串</td>
</tr>
<tr>
<td>n,N</td>
<td>利用/或？来查询字符串时，可以用n来继续查询下一个查询，可以利用N来进行反向查询</td>
</tr>
<tr>
<td>q</td>
<td>结束这次man page</td>
</tr>
</tbody>
</table>
<p>下面还有两个man的用途：</p>
<ol>
<li>man -f command （= whatis）：查询和command这个命令有关的说明文件</li>
<li>man -k data（= apropos）：查询包含data这个数据有关的文件</li>
</ol>
<h2 id="info-page"><a href="#info-page" class="headerlink" title="info page"></a>info page</h2><p>info与man的用途差不多，都是用来查询命令的用法或者文件的格式，但是与man page一下子输出一堆信息不同的是，info page则是将文件数据拆成一个一个段落，每个段落用自己的页面来撰写，并且在各个页面中还有类似网页的“超链接”来调到各个页面，每个独立的页面也被称为一个节点（node）。</p>
<p>这里这里不多说，有兴趣者可以自己去看看使用。</p>
<h2 id="其他有用的文件"><a href="#其他有用的文件" class="headerlink" title="其他有用的文件"></a>其他有用的文件</h2><p>一般而言，命令或者软件开发者都会将自己的命令或者是软件的说明制作成“在线帮助文件”，但是毕竟不是什么都需要做成在线帮助文件的，在/usr/share/doc中我们会发现会有很多说明文件文档，这些会告诉我们怎么做，以及一些相关的原理。</p>
<h1 id="开机与关机"><a href="#开机与关机" class="headerlink" title="开机与关机"></a>开机与关机</h1><h2 id="开机与登录"><a href="#开机与登录" class="headerlink" title="开机与登录"></a>开机与登录</h2><p>一般服务器都不怎么重启，我们在登录服务器的时候，基本上都是使用ssh来登录，我们可以使用下面的命令：</p>
<blockquote>
<p>ssh ip</p>
</blockquote>
<p>在这个命令之后会要求与你输入密码即可成功。</p>
<h2 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h2><p>在Linux中，由于每个程序都是在后台运行的，因此你看不到屏幕后面其实可能有很多人同时在你的主机上面工作，所以我们不能随意关机。所以在正常情况下，要关机时要注意下面几件事：</p>
<ol>
<li>查看系统的使用状态<ul>
<li>如果要看目前有谁在线：执行“who”这个命令</li>
<li>如果要看网络的联机状态：执行“netstat -a”这个命令</li>
<li>如果要看后台执行的程序：执行“ps -aux”这个命令</li>
</ul>
</li>
<li>通知在线用户关机的时刻</li>
<li>正确地关机命令使用：shutdown与reboot</li>
<li>将数据同步写入硬盘的命令：sync</li>
<li>惯用的关机命令：shutdown</li>
<li>重启、关机：reboot,halt,poweroff</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一章最为基础，灰常重要，就像地基，只有有了地基，我们才能好好造下面的房子。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《鸟哥的Linux私房菜》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：从浅入深，我们也从基础命令开始。学会基本命令的使用，学会怎么去查命令的使用，最后学会一丢丢维护（开关机）。&lt;br&gt;
    
    </summary>
    
      <category term="走进Linux" scheme="http://bestlixiang.site/categories/%E8%B5%B0%E8%BF%9BLinux/"/>
    
    
      <category term="Linux" scheme="http://bestlixiang.site/tags/Linux/"/>
    
  </entry>
  
</feed>
