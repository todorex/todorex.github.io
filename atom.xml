<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rex note</title>
  <subtitle>雨过，云过</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bestlixiang.site/"/>
  <updated>2018-07-18T02:56:09.672Z</updated>
  <id>http://bestlixiang.site/</id>
  
  <author>
    <name>rex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot+Git+Jenkins+Docker实现CI/CD</title>
    <link href="http://bestlixiang.site/2018/07/18/%E8%BF%90%E7%BB%B4/SpringBoot-Git-Jenkins-Docker%E5%AE%9E%E7%8E%B0CI-CD/"/>
    <id>http://bestlixiang.site/2018/07/18/运维/SpringBoot-Git-Jenkins-Docker实现CI-CD/</id>
    <published>2018-07-18T01:03:46.000Z</published>
    <updated>2018-07-18T02:56:09.672Z</updated>
    
    <content type="html"><![CDATA[<p>引：现在DevOps这么运行，你没有理由不去了解，不去实践，这次就以Springboot为底，利用Git，jenkins，Docker实现持续集成和持续部署！<a id="more"></a></p>
<h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>下面是常用的开发流程图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com//cicd/devops.jpg" alt="dev"></p>
<p>我们简单说说这张图：首先我们会将代码文件、测试文件以及Dockerfile都存在代码仓库里，版本控制利用git，这里代码仓库有很多选择，比如github、码云(本次使用)、Coding以及自己搭建的gitlab。然后由持续集成工具进行自动化构建，包括了测试、编译、打包、构建镜像、推送镜像到仓库（有很多选择，如docker官方仓库，时速运、自己搭建的Registry）、启动服务等操作，持续集成工具也有很多选择，比如Jenkins(这次使用)、Gitlab CI、Trivas CI。这里使用的容器是Docker，这里Docker的编排工具可以选择Swarm，也可以是K8S。</p>
<p>本次实现流程如下：</p>
<ol>
<li>push代码到码云触发WebHook</li>
<li>Jenkins从码云拉取代码</li>
<li>maven构建代码</li>
<li>build镜像</li>
<li>push镜像到镜像仓库</li>
<li>部署服务</li>
</ol>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>关于Jdk、Git、Maven的配置这里就不说，自己面向搜索引擎。这里主要说Jenkins和码云的配置。</p>
<h2 id="Jenkins安装配置"><a href="#Jenkins安装配置" class="headerlink" title="Jenkins安装配置"></a>Jenkins安装配置</h2><ol>
<li><a href="https://jenkins.io/download/" target="_blank" rel="external">下载Jenkins</a>（采用war包安装）</li>
<li>将war包放入Tomcat的webapps目录下</li>
<li>进入YourHostIp:8080/jenkins路径下进行Jenkins的初始化，我们进入 <strong>用户自定义插件</strong> 安装界面，你可以根据自己的构建方式选择需要安装的插件，本次使用的Pipelines方式进行构建，Pipelines方式是Jenkins2推荐的方式，所以我们构建Pipelines相关的插件进行安装，当然待会进入Jenkins安装也行。</li>
<li>配置用户名和密码</li>
<li>全局工具配置（从系统管理进入全局工具配置，配置Jdk、Git、Maven）</li>
<li><p>安全配置（从系统管理进入全局安全配置）,如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com//cici/jenkins_security.jpg" alt="jenkins_security"></p>
</li>
</ol>
<h2 id="Jenkins构建任务"><a href="#Jenkins构建任务" class="headerlink" title="Jenkins构建任务"></a>Jenkins构建任务</h2><ol>
<li>新建任务，构建一个流水线任务（Pipeline）</li>
<li><p>在配置里构建触发器，如下图：</p>
<p> <img src="http://o6plzvjf2.bkt.clouddn.com//cicd/jenkins_webhooks_url.jpg" alt="jenkins_webhooks_url"></p>
</li>
<li><p>构建Pipeline脚本（Pipeline脚本写法见参考）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">  #!groovy</div><div class="line">  pipeline&#123;</div><div class="line">    agent any</div><div class="line">    //定义仓库地址</div><div class="line">    environment &#123;</div><div class="line">        REPOSITORY=&quot;https://gitee.com/todorex/springboot_docker_git_jenkins_demo.git&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    stages &#123;</div><div class="line"></div><div class="line">        stage(&apos;获取代码&apos;)&#123;</div><div class="line">            steps &#123;</div><div class="line">                echo &quot;start fetch code from git:$&#123;REPOSITORY&#125;&quot;</div><div class="line">                // 清空当前目录</div><div class="line">                deleteDir()</div><div class="line">                // 拉取代码    </div><div class="line">                git &quot;$&#123;REPOSITORY&#125;&quot;</div><div class="line">                // 清空之前的容器</div><div class="line">                sh &apos;docker stop $(docker ps -a -q)&apos;</div><div class="line">                sh &apos;docker rm $(docker ps -a -q)&apos;</div><div class="line">            &#125;</div><div class="line">        &#125;       </div><div class="line"></div><div class="line">        stage(&apos;Maven 构建&apos;)&#123;</div><div class="line">            steps &#123;</div><div class="line">                echo &quot;start compile&quot;</div><div class="line">                // 切换目录</div><div class="line">                dir(&apos;demo&apos;) &#123;</div><div class="line">                    // 重新打包</div><div class="line">                    sh &apos;mvn -Dmaven.test.skip=true -U clean install&apos;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        stage(&apos;构建镜像&apos;)&#123;</div><div class="line">            steps &#123;</div><div class="line">                echo &quot;start build image&quot;</div><div class="line">                dir(&apos;demo&apos;) &#123;</div><div class="line">                    // build镜像</div><div class="line">                    sh &apos;docker build -t todorex/springboot_docker_git_jenkins_demo:1.0 .&apos;</div><div class="line">                    // 登录镜像仓库</div><div class="line">                    sh &apos;docker login -u your_username -p your_password&apos;</div><div class="line">                    // 推送镜像到镜像仓库</div><div class="line">                    sh &apos;docker push todorex/springboot_docker_git_jenkins_demo:1.0&apos;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        stage(&apos;启动服务&apos;)&#123;</div><div class="line">            steps &#123;</div><div class="line">                echo &quot;start demo&quot;</div><div class="line">                // 部署服务</div><div class="line">                sh &apos;docker run -d -p 8888:8888 --name=demo todorex/springboot_docker_git_jenkins_demo:1.0&apos;</div><div class="line">            &#125;</div><div class="line">        &#125;                </div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="SSH的配置"><a href="#SSH的配置" class="headerlink" title="SSH的配置"></a>SSH的配置</h2><p>为了避免jenkins拉取代码时需要输入密码，这里需要配置SSH免密码拉取。如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com//cicd/gitee_ssh.jpg" alt="gitee_ssh"></p>
<h2 id="WebHooks配置"><a href="#WebHooks配置" class="headerlink" title="WebHooks配置"></a>WebHooks配置</h2><p>当你每次对代码仓库进行push操作时，会自动通知jenkins进行构建<br><img src="http://o6plzvjf2.bkt.clouddn.com//cicd/gitee_webhooks.jpg" alt="gitee_webhooks"></p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>这次项目的代码仓库为：<a href="https://gitee.com/todorex/springboot_docker_git_jenkins_demo" target="_blank" rel="external">springboot_docker_git_jenkins_demo</a></p>
<p>关于Dockerfile以及docker-compose.yml的编写，自己也去面向搜索引擎看看吧。</p>
<p>当我们push代码之后，jenkins就会自动帮我们进行构建。如下图：<br><img src="http://o6plzvjf2.bkt.clouddn.com//cicd/jenkins_test.jpg" alt="jenkins_test"></p>
<p>PS：第一次比较慢是因为要安装Maven依赖，后面就好了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里只是展示了一个CI/CD的开发流程，关于具体技术细节，无论是Jenkins还是Docker都需要深入学习，加油，骚年！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://niocoder.com/2018/04/22/SpringBoot+Docker+Git+Jenkins%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%92%8C%E9%83%A8%E7%BD%B2/" target="_blank" rel="external">SpringBoot+Docker+Git+Jenkins实现简易的持续集成和持续部署</a></li>
<li><a href="http://www.cnblogs.com/fengjian2016/p/8227532.html" target="_blank" rel="external">Jenkins pipeline：pipeline 语法详解</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：现在DevOps这么运行，你没有理由不去了解，不去实践，这次就以Springboot为底，利用Git，jenkins，Docker实现持续集成和持续部署！
    
    </summary>
    
      <category term="运维" scheme="http://bestlixiang.site/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="SpringBoot" scheme="http://bestlixiang.site/tags/SpringBoot/"/>
    
      <category term="Git" scheme="http://bestlixiang.site/tags/Git/"/>
    
      <category term="Jenkins" scheme="http://bestlixiang.site/tags/Jenkins/"/>
    
      <category term="Docker" scheme="http://bestlixiang.site/tags/Docker/"/>
    
      <category term="CI" scheme="http://bestlixiang.site/tags/CI/"/>
    
      <category term="CD" scheme="http://bestlixiang.site/tags/CD/"/>
    
  </entry>
  
  <entry>
    <title>Maven使用整理</title>
    <link href="http://bestlixiang.site/2018/07/06/%E5%B7%A5%E5%85%B7/Maven%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/"/>
    <id>http://bestlixiang.site/2018/07/06/工具/Maven使用整理/</id>
    <published>2018-07-06T14:03:35.000Z</published>
    <updated>2018-07-06T14:06:36.067Z</updated>
    
    <content type="html"><![CDATA[<p>引：使用Java语言来开发你的项目，基本上都少不了Maven，因为有了它真是太方便了！<a id="more"></a></p>
<h1 id="什么是Maven"><a href="#什么是Maven" class="headerlink" title="什么是Maven"></a>什么是Maven</h1><p><a href="https://maven.apache.org/" target="_blank" rel="external">Maven</a>是一种用来管理Java项目的工具、但不是那种那种用来管理资源规划和调度的工具。相反，它处理的时一个具体的项目所涉及的各种任务，如编译、测试、打包以及部署。</p>
<p>Maven包括以下几个部分：</p>
<ul>
<li><p>一组用于处理管理依赖(从<a href="http://mvnrepository.com/" target="_blank" rel="external">中央仓库</a>拉取的jar包)、<a href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html" target="_blank" rel="external">目录结构</a>以及构建工作流的<strong>约定</strong>。</p>
<p>  基于这些约定实现的标准化可以极大地简化开发过程。例如，一个常用的目录结构使得开发者可以更加容易跟上不熟悉的项目的节奏。</p>
</li>
<li><p>一个用于项目配置的<a href="http://maven.apache.org/guides/introduction/introduction-to-the-pom.html" target="_blank" rel="external">XML Schema</a>：项目对象模型(Project Object Model)，简称POM。</p>
<p>  每一个Maven项目都拥有一个POM文件，并命名为pom.xml，包含Maven用于管理该项目的所有的配置信息。</p>
</li>
<li><p>一个委托外部组件来执行项目任务的<a href="https://maven.apache.org/plugins/index.html" target="_blank" rel="external">插件结构</a>。</p>
<p>  这简化了更新一集扩展Maven能力的过程。</p>
</li>
</ul>
<h1 id="Maven安装"><a href="#Maven安装" class="headerlink" title="Maven安装"></a>Maven安装</h1><p><strong>PS：</strong> 上面提到了Maven帮我们管理依赖，是通过从中央仓库拉取jar包(依赖)来实现，但是由于Maven的中央仓库在国外，拉取会比较慢，所以我们一般会通过配置阿里云镜像来加快速度，当然你也可以<a href="https://blog.sonatype.com/" target="_blank" rel="external">Nexus</a>搭建自己的私有仓库。</p>
<ol>
<li><a href="https://blog.csdn.net/ck4438707/article/details/53377413" target="_blank" rel="external">Maven安装教程</a></li>
<li><a href="https://blog.csdn.net/u012424449/article/details/77853983" target="_blank" rel="external">配置阿里云镜像仓库</a></li>
</ol>
<h1 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h1><p>POM文件大纲如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;project&gt; // 根元素</div><div class="line">    &lt;groupId/&gt;</div><div class="line">    &lt;artifactId/&gt;</div><div class="line">    &lt;version/&gt; // 上面三个(GAV坐标)唯一地定义Maven项目的值</div><div class="line">    &lt;packaging/&gt; // 项目打包方式，默认值是jar</div><div class="line">    &lt;properties/&gt; // 在POM中引用的属性，一般会放版本信息</div><div class="line">    &lt;dependencies/&gt; //构建当前项目所需要的其他Maven项目</div><div class="line">    &lt;build/&gt; // 构建改项目所需要执行的任务的配置</div><div class="line">    &lt;profiles/&gt; // 为不同的用例自定义POM，一般用来配置环境的切换</div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Maven构件"><a href="#Maven构件" class="headerlink" title="Maven构件"></a>Maven构件</h2><p>任何可以被Maven的坐标系统(GAV)唯一标识的对象都是一个Maven构件。</p>
<p>Maven构件的类型由pom文件的<packaging>元素指定。最常用的值是pom、jar、ear、war以及maven-plugin。</packaging></p>
<h2 id="POM文件使用方式"><a href="#POM文件使用方式" class="headerlink" title="POM文件使用方式"></a>POM文件使用方式</h2><ol>
<li>默认的：用于构建一个构件</li>
<li>父POM：提供一个由子项目继承的单个配置信息源，子项目通过声明这个pom文件作为它们的<parent>元素值</parent></li>
<li>聚合器：用于构建一组声明为<modules>的项目，这些子项目位于其当前聚合器项目的文件夹中，每个都包含有他自己的pom文件</modules></li>
</ol>
<p><strong>PS：</strong> 作为父pom或者聚合器的pom文件的<packaging>元素的值将是pom。</packaging></p>
<h2 id="GAV坐标"><a href="#GAV坐标" class="headerlink" title="GAV坐标"></a>GAV坐标</h2><p>POM定义了5种称为坐标的元素，用于标识Maven构件，首字母缩写GAV指的是必须始终指定的3个坐标<groupid>、<artifactid>、<version> 的首字母。</version></artifactid></groupid></p>
<p>下面的坐标是按照他们在坐标表达式中出现的顺序列出：</p>
<ol>
<li><groupid>是项目或者项目组的<strong>全局唯一标识符</strong>。这通常是Java源代码使员工的全限定的Java包名。例如，io.netty、com.google。</groupid></li>
<li><artifactid>用于标识和某个<groupdid>相关的不同的构件。例如，netty-all、netty-handler。</groupdid></artifactid></li>
<li><type>是指和项目相关的主要构件的类型(对应于构件的POM文件中的<packaging>值)。它的默认值是jar，此外还有pom、ear。</packaging></type></li>
<li><version>标识了构件的版本、例如1.1、2.0-SNAPSHOT、4.1.9.Final。</version></li>
<li><classifier>用于区分属于相同的POM但是却被以不同方式构建的构件。例如，javadock、sources、jdk16、jdk17。</classifier></li>
</ol>
<p>一个完整的坐标表达式具有如下格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">actifactId:groupId:packaging:version:classifier</div></pre></td></tr></table></figure></p>
<p>POM文件必须声明它所管理的构件的坐标，一个具有如下坐标的项目：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;groupId&gt;io.netty&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;netty-all&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;4.1.9.Final&lt;/version&gt;</div><div class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</div></pre></td></tr></table></figure></p>
<p>将会产生一个具有以下格式的名称的构件：<br><code>artifactId-&lt;version&gt;.&lt;packaging&gt;</code></p>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><h2 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h2><p>项目的依赖是指编译和执行它所需要的外部构件。在大多数情况下，你的项目的依赖项也会有它自己的依赖。我们称这些依赖为你的项目的<strong>传递依赖</strong>。一个负责的项目可能会有一个深层级的<strong>依赖树</strong>。Maven 提供了各种用于帮助理解和管理它的工具，如执行<code>mvn dependency:tree</code>。</p>
<p>Maven的<dependency>声明在POM的<dependencies>元素中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">  &lt;dependency&gt;</div><div class="line">    &lt;groupId/&gt;</div><div class="line">    &lt;artifactId/&gt;</div><div class="line">    &lt;version/&gt;</div><div class="line">    &lt;type/&gt;</div><div class="line">    &lt;scope/&gt;</div><div class="line">    &lt;systemPath/&gt;</div><div class="line">  &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure></dependencies></dependency></p>
<p>在<dependency>声明中，GAV坐标是必不可少的。type和scope元素对于那些值不分别是默认值jar和compile的依赖来说也是必须的。</dependency></p>
<p>关于scope指的是依赖范围，即classpath，Maven里有3类依赖范围：</p>
<ul>
<li>编译</li>
<li>测试</li>
<li>运行</li>
</ul>
<p><scope>元素具有以下值（依赖范围）：</scope></p>
<ul>
<li>compile：编译（默认）</li>
<li>runtime：运行</li>
<li>provided：对于编译和测试有效，运行时无效</li>
<li>test：测试</li>
<li>import：使用在<dependencymanagement>中，导入其他项目的<dependencymanagement></dependencymanagement></dependencymanagement></li>
<li>systemPath：与provided一直，但是需要指定依赖文件的绝对位置</li>
</ul>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>POM的<dependencymanagement>元素可以包含被其他项目使用的<dependency>声明（但不拉取），这样的POM的子项目会自动继承这些声明，其他项目可以用过使用<scope>元素值来导入他们。</scope></dependency></dependencymanagement></p>
<p>引用了<dependencymanagement>元素的项目可以使用它所声明的依赖，而不需要指定他们的<version>坐标，如果<dependencymanagement>中的<version>在稍后改变，则所有应用它的pom都会改变。</version></dependencymanagement></version></dependencymanagement></p>
<p><strong>最佳实践</strong>：在原POM中的所有版本都利用<properties>元素控制。</properties></p>
<h1 id="构件的生命周期"><a href="#构件的生命周期" class="headerlink" title="构件的生命周期"></a>构件的生命周期</h1><p>Maven的生命周期就是为了对所有的构建过程进行抽象和统一。这个生命周期包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有构建步骤。也就是说，几所所有的项目的构建，都能映射到这样一个生命周期上。</p>
<p>Maven拥有三套相互独立生命周期，他们分别为clean、default和site。clean生命周期的目的是清理项目、default生命周期的目的是构建项目、site生命周期的目的是建立项目站点。每个生命周期包含一些阶段，这些阶段是有顺序的，并且后面的阶段依赖于前面的阶段。但是三套生命周期本身是相互独立的。我们按照日常的需求，我们只说前两个。</p>
<h2 id="clean生命周期"><a href="#clean生命周期" class="headerlink" title="clean生命周期"></a>clean生命周期</h2><p>它包含三个阶段：</p>
<ol>
<li>pre-clean：执行清理前要完成的工作。</li>
<li>clean：清理上一次构建生成的文件。</li>
<li>post-clean：执行一些清理后需要完成的工作。</li>
</ol>
<h2 id="default生命周期"><a href="#default生命周期" class="headerlink" title="default生命周期"></a>default生命周期</h2><p>default生命周期定义了真正构建时所需要执行的而所有步骤，这里也只是列出重要的阶段：</p>
<ol>
<li>validate：检查项目是否正确</li>
<li>compile：编译项目的源代码</li>
<li>test：使用单元测试框架进行测试，测试代码不会被打包部署</li>
<li>package：将编译的代码打包为可发布的格式，如jar</li>
<li>verify：验证软件包是否有效</li>
<li>install：将包安装到本地仓库中，可以供本地其他Maven项目使用</li>
<li>deploy：将包复制到远程仓库中，可以供其他开发人员使用</li>
</ol>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>虽然Maven协调了所有构建生命周期阶段的执行，但是他并没有直接实现它们，而是将他们委托给了<strong>插件</strong>。这些插件是maven-plugin类型的构件(打包为JAR文件)。Maven为标准构件生命周期所定义的所有任务都提供了插件，但更多的是由第三方生产的，用于处理各种自定义的任务。</p>
<h2 id="插件目标"><a href="#插件目标" class="headerlink" title="插件目标"></a>插件目标</h2><p>每个插件都有很多功能，每个插件功能对应了插件一个目标。如我们之前分析依赖的maven-dependency-plugin，它就有十多个目标，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 命令行冒号前面是插件，冒号后面是目标（功能）</div><div class="line">mvn dependency:analyze</div><div class="line">mvn dependency:tree</div><div class="line">mvn dependency:list</div></pre></td></tr></table></figure></p>
<h2 id="插件绑定"><a href="#插件绑定" class="headerlink" title="插件绑定"></a>插件绑定</h2><p>Maven的生命周期与插件相互绑定，用以完成实际的构建任务。</p>
<h3 id="内置绑定"><a href="#内置绑定" class="headerlink" title="内置绑定"></a>内置绑定</h3><p>为了让用户几乎不用任何配置就能构建Maven项目，Maven为一些主要的生命周期阶段绑定了很多插件的目标，如：</p>
<ol>
<li>maven-clean-plugin:clean绑定了clean</li>
<li>maven-compiler-plugin:compile绑定了compile</li>
<li>maven-surefire-plugin:test绑定了test</li>
<li>maven-jar-plugin:jar绑定package默认</li>
<li>maven-install-plugin:install绑定了install</li>
</ol>
<h3 id="自定义绑定"><a href="#自定义绑定" class="headerlink" title="自定义绑定"></a>自定义绑定</h3><p>除了内置绑定之外，用户还能够自己选择将某个插件目标绑定到生命周期的某个阶段上。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;build&gt;</div><div class="line">    &lt;plugins&gt;</div><div class="line">        &lt;plugin&gt;</div><div class="line">           &lt;!--引入插件--&gt;</div><div class="line">           &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</div><div class="line">            &lt;version&gt;3.0.1&lt;/version&gt;</div><div class="line">            &lt;!--构建任务--&gt;</div><div class="line">            &lt;executions&gt;</div><div class="line">                &lt;execution&gt;</div><div class="line">                    &lt;id&gt;attach-source&lt;/id&gt;</div><div class="line">                    &lt;!--绑定阶段--&gt;</div><div class="line">                    &lt;phase&gt;verify&lt;/phase&gt;</div><div class="line">                    &lt;!--绑定目标--&gt;</div><div class="line">                    &lt;goals&gt;</div><div class="line">                        &lt;goal&gt;jar-no-fork&lt;/goal&gt;</div><div class="line">                    &lt;/goals&gt;</div><div class="line">                &lt;/execution&gt;</div><div class="line">            &lt;/executions&gt;</div><div class="line">        &lt;/plugin&gt;</div><div class="line">    &lt;/plugins&gt;</div><div class="line">&lt;/build&gt;</div></pre></td></tr></table></figure></p>
<p>很多插件的目标在编写是就已经定义了默认绑定阶段，可以利用maven-help-plugin查看插件详细信息，了解插件目标的默认绑定阶段。运行命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn help:describe -Dplugin=org.apache.maven.plugins:maven-source-plugin:3.0.1</div></pre></td></tr></table></figure></p>
<p>如果多个目标被绑定到同一个阶段的时候，这些插件声明的先后顺序决定了目标的执行顺序。</p>
<h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><h3 id="命令行插件配置"><a href="#命令行插件配置" class="headerlink" title="命令行插件配置"></a>命令行插件配置</h3><p>很多插件目标的参数都是支持命令行配置的，用户可以在Maven命令中使用-D参数，并伴随参数键=参数值的形式来配置插件目标的参数，如上<code>mvn help</code>。</p>
<h3 id="POM中插件全局配置"><a href="#POM中插件全局配置" class="headerlink" title="POM中插件全局配置"></a>POM中插件全局配置</h3><p>为了避免插件参数重复书写，我们可以在pom进行全局配置，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;3.0.1&lt;/version&gt;</div><div class="line">    &lt;configuration&gt;</div><div class="line">        &lt;!--编译Java1.8版本的源文件--&gt;</div><div class="line">        &lt;source&gt;1.8&lt;/source&gt;</div><div class="line">        &lt;!--生成与JVM1.8兼容的字节码文件--&gt;</div><div class="line">        &lt;target&gt;1.8&lt;/target&gt;</div><div class="line">    &lt;/configuration&gt;</div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure></p>
<h2 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h2><p>POM的<pluginmanagement>元素可以包含被其他项目使用的<plugin>声明（但不拉取），这样的POM的子项目会自动继承这些声明。</plugin></pluginmanagement></p>
<p>引用了<pluginmanagement>元素的项目可以使用它所声明的依赖，而不需要指定他们的<version>坐标，如果<pluginmanagement>中的<version>在稍后改变，则所有应用它的pom都会改变。</version></pluginmanagement></version></pluginmanagement></p>
<p><strong>最佳实践</strong>：在原POM中的所有版本都利用<properties>元素控制。</properties></p>
<h1 id="聚合和继承"><a href="#聚合和继承" class="headerlink" title="聚合和继承"></a>聚合和继承</h1><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>如果我们想要一次构建两个项目，而不是到两个模块的目录下分别执行mvn命令，那么我们可以使用<strong>Maven聚合</strong>。</p>
<p>我们先创建一个聚合构件（除了pom文件（packaging需要为pom），其他可以都不要），然后在聚合构件目录下创建两个构件，并在聚合构件下利用<modules>来声明，每个module的值都是一个当前目录的相对目录，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;modules&gt;</div><div class="line">    &lt;module&gt;email&lt;/module&gt;</div><div class="line">    &lt;module&gt;user&lt;/module&gt;</div><div class="line">&lt;/modules&gt;</div></pre></td></tr></table></figure></modules></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>如果两个项目有重复的依赖或插件，我们可以使用<strong>继承</strong>。</p>
<p>我们先创建一个父构件（除了pom文件（packaging需要为pom），其他可以都不要），然后在父构件目录下创建两个子构件，并在子构件下利用<parent>来声明继承关系，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;parent&gt;</div><div class="line">    &lt;groupId/&gt;</div><div class="line">    &lt;artifactId/&gt;</div><div class="line">    &lt;version/&gt;</div><div class="line">    &lt;relativePath&gt;父pom的相对路径&lt;/relativePath&gt;</div><div class="line">&lt;/parent&gt;</div></pre></td></tr></table></figure></parent></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/ck4438707/article/details/53377413" target="_blank" rel="external">Maven安装教程</a></li>
<li><a href="https://blog.csdn.net/u012424449/article/details/77853983" target="_blank" rel="external">配置阿里云镜像仓库</a></li>
<li>《Maven实战》</li>
<li><a href="https://www.cnblogs.com/dreamroute/p/6729147.html" target="_blank" rel="external">Maven <resource>标签</resource></a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：使用Java语言来开发你的项目，基本上都少不了Maven，因为有了它真是太方便了！
    
    </summary>
    
      <category term="工具" scheme="http://bestlixiang.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="http://bestlixiang.site/tags/Java/"/>
    
      <category term="Maven" scheme="http://bestlixiang.site/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Git使用整理</title>
    <link href="http://bestlixiang.site/2018/07/05/%E5%B7%A5%E5%85%B7/Git%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/"/>
    <id>http://bestlixiang.site/2018/07/05/工具/Git使用整理/</id>
    <published>2018-07-05T11:29:14.000Z</published>
    <updated>2018-07-10T13:29:20.198Z</updated>
    
    <content type="html"><![CDATA[<p>引：虽然日常使用git，但是有些时候总是会忘记一些操作，难免会面向搜索引擎查找。所以这里就总结一下。<a id="more"></a></p>
<h1 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h1><p>谈到Git，就需要先说说版本控制系统。<strong>版本控制系统</strong>就是能自动帮我们记录每次文件的改动的一个软件，而Git就是它的一种实现。想想我们写论文还是写代码，是不是有了他就很方便了，再也不用自己手动备份每一次修改了。版本控制系统又分为集中式和分布式。</p>
<h2 id="集中式（SVN）"><a href="#集中式（SVN）" class="headerlink" title="集中式（SVN）"></a>集中式（SVN）</h2><p><img src="http://o6plzvjf2.bkt.clouddn.com/tool/git/%E9%9B%86%E4%B8%AD%E5%BC%8F.jpg" alt="集中式"></p>
<p>集中式版本控制系统的版本库是集中存放在中央服务器的，而我们在干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。</p>
<p><strong>问题</strong>：必须联网才能工作；中央服务器要是出了问题，所有人都没法干活了</p>
<h2 id="分布式（Git）"><a href="#分布式（Git）" class="headerlink" title="分布式（Git）"></a>分布式（Git）</h2><p><img src="http://o6plzvjf2.bkt.clouddn.com/tool/git/%E5%88%86%E5%B8%83%E5%BC%8F.jpg" alt="仓库"></p>
<p>每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。在双方协作的时候，如果你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，而且如果你们俩不在一个局域网内，两台电脑也互相访问不了。所以分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
<h1 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h1><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>这里就不多说了，推荐廖雪峰的官方网站<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000" target="_blank" rel="external">安装教程</a>。</p>
<h2 id="Git区域"><a href="#Git区域" class="headerlink" title="Git区域"></a>Git区域</h2><p><img src="http://o6plzvjf2.bkt.clouddn.com/tool/git/%E5%8C%BA%E5%9F%9F.png" alt="Git区域"></p>
<ul>
<li>工作区（Workspace）：在计算机能看到的目录。</li>
<li>缓存区（Index/Stage）：临时保存我们的改动。</li>
<li>版本库（Repository）：工作区有一个隐藏的目录.git，它是Git的本地版本库。</li>
<li>远程仓库（Remote）：“Git中央服务器”，托管在网络中的项目的版本库，可供多人协作开发。（国外有<a href="https://gitee.com/" target="_blank" rel="external">基佬俱乐部Github</a>，国内有<a href="https://gitee.com/" target="_blank" rel="external">码云</a>、<a href="https://coding.net/" target="_blank" rel="external">Coding</a>、还有可个人或者公司定制的<a href="https://about.gitlab.com/" target="_blank" rel="external">GitLab</a>，请按需选择）</li>
</ul>
<h2 id="Git个人操作"><a href="#Git个人操作" class="headerlink" title="Git个人操作"></a>Git个人操作</h2><p>在上面的区域图中，其实我们已经看到很多操作，这里我再总结一下：</p>
<h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><ul>
<li><p>在当前目录新建一个Git仓库</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure>
</li>
<li><p>在当前目录克隆一个仓库</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone [url]</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="增加文件"><a href="#增加文件" class="headerlink" title="增加文件"></a>增加文件</h3><ul>
<li><p>添加指定文件/目录到暂存区</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add [file]/[dir]</div></pre></td></tr></table></figure>
</li>
<li><p>添加当前目录的所有文件到暂存区（慎用，尤其在IDE中，因为它会包含IDE的配置文件，如IDEA的.idea和iml文件）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add .</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><ul>
<li>提交缓存区的文件到仓库区  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m [改变信息]</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><ul>
<li><p>显示有变更的文件</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure>
</li>
<li><p>显示当前分支的版本历史</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log</div></pre></td></tr></table></figure>
</li>
<li><p>根据关键词搜索提交历史</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log -S [keyword]</div></pre></td></tr></table></figure>
</li>
<li><p>显示暂存区与工作区的差异</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff</div></pre></td></tr></table></figure>
</li>
<li><p>显示工作区与当前分支最新的commit之间的差异<br>  <code>git diff HEAD(当前最新commit)</code></p>
</li>
<li>上传本地指定分支到远程仓库  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push [remote] [branch]</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><ul>
<li><p>下载远程仓库的<strong>变动</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git fetch [remote远程仓库名] [分支]:[本地新分支]</div></pre></td></tr></table></figure>
</li>
<li><p>显示所有远程仓库</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote -v</div></pre></td></tr></table></figure>
</li>
<li><p>显示某个远程仓库的信息</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote show [branch]</div></pre></td></tr></table></figure>
</li>
<li><p>增加一个远程仓库并命名</p>
<p>  <code>git remote add [shortname=remote] [url]</code></p>
</li>
<li><p>上传本地指定分支到远程仓库</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push [remote] [branch]</div></pre></td></tr></table></figure>
</li>
<li><p>强行推送当前分支到远程仓库，即使有冲突<br>  <code>git push [remote] --force</code></p>
</li>
<li>推送所有分支到远程仓库<br>  <code>git push [remote] -all</code></li>
</ul>
<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><ul>
<li><p>恢复暂存区的指定文件到工作区</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout [file]</div></pre></td></tr></table></figure>
</li>
<li><p>恢复某个commit的指定文件到暂存区与工作区</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout [commit] [file]</div></pre></td></tr></table></figure>
</li>
<li><p>恢复暂存区的所有文件到工作区</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout .</div></pre></td></tr></table></figure>
</li>
<li><p>重置暂存区与工作区，与上一次commit保持一致<br>  <code>git reset --hard</code></p>
</li>
<li><p>重置当前分支的HEAD（指针，指向commit-id）为指定commit，同时重置暂存区和工作区，与指定commit一致<br>  <code>git reset --hard [commit]</code></p>
</li>
<li><p>后者的所有变化都将被前者抵消，并应用当前分支<br>  <code>git revert [commit]</code></p>
</li>
<li><p>暂时将未提交的变化移除，稍后再移入<br>  <code>git stash</code><br>  <code>git stash pop</code> </p>
</li>
</ul>
<h2 id="Git多人协作"><a href="#Git多人协作" class="headerlink" title="Git多人协作"></a>Git多人协作</h2><p>多人协作就会涉及到分支的概念（其实单人开发也会遇到，只是多人会更常见）</p>
<p>我们先看看下面的图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/tool/git/%E5%88%86%E6%94%AF.jpg" alt="多人协作"></p>
<p>这张图可以很清楚让我们认识到在工作中使用git工作流的开发流程。Master分支是线上分支，我们在开发新功能的时候不会去动它，Hotfix分支是如果出了bug就拉一条bug分支快速修复合并到master分支里。我们平时开发都是先从Master分支拉出一条Develop分支，在这个分支上进行开发。每个人一般都会负责项目的一个特性功能，所以我们又会从Develop分支拉出几个Feature分支。在开发测试完成后我们形成Release分支，再次检验后将它与Master分支合并，然后我们之后Release分支拉出Develop分支进行新一轮的开发。</p>
<h3 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h3><ul>
<li><p>列出所有本地分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch</div></pre></td></tr></table></figure>
</li>
<li><p>列出所有远程分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -r</div></pre></td></tr></table></figure>
</li>
<li><p>列出所有本地分支和远程分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -a</div></pre></td></tr></table></figure>
</li>
<li><p>新建一个分支，但依然停留在当前分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch [branch-name]</div></pre></td></tr></table></figure>
</li>
<li><p>新建一个分支，并切换到该分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b [branch]</div></pre></td></tr></table></figure>
</li>
<li><p>切换到当前指定分支，并指定工作区</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout [branch-name]</div></pre></td></tr></table></figure>
</li>
<li><p>切换到上一个分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -</div></pre></td></tr></table></figure>
</li>
<li><p>建立追踪关系，在现有分支与指定的远程分支之间</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch --set-upstream [branch] [remote-branch]</div></pre></td></tr></table></figure>
</li>
<li><p>合并指定分支到当前分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge [branch]</div></pre></td></tr></table></figure>
</li>
<li><p>删除远程分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d [branch-name]</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="协作冲突"><a href="#协作冲突" class="headerlink" title="协作冲突"></a>协作冲突</h3><p>在多人协作的过程中肯定会碰到这样的<strong>问题</strong>：如果你的小伙伴已经向一个分支推送了他的提交，而碰巧你也对同个分支的同样的文件作了修改，并试图推送，那么就会提交被拒绝，这个时候就需要先：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull</div></pre></td></tr></table></figure></p>
<p>等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git fetch temp(临时分支)</div><div class="line">git merge temp</div></pre></td></tr></table></figure></p>
<p>这个时候合git会将你们两个人对文件的修改都呈现在同一个文件中，你需要在与你的小伙伴商量出一个最终版，修改之后再提交上去。</p>
<h1 id="IDEA与Git"><a href="#IDEA与Git" class="headerlink" title="IDEA与Git"></a>IDEA与Git</h1><p>可能大家对使用命令行并不感冒，所以这里也为大家找了一份<a href="https://blog.csdn.net/lovecarpenter/article/details/54290045" target="_blank" rel="external">IDEA的git使用教程</a>，至此大家只要点点点就好了。当然这里还会有很多我没有涉及到的地方，就需要平时多积累了。</p>
<p>别急，别急！！还要最后一点就是 <strong>.gitignore</strong> 了！</p>
<p>我们发现在使用IDEA的时候，他默认会要求我们把所有的文件加入到git控制里，但是我们知道很多IDEA的自带配置文件是不用也没有必要加入git（之前在说git add . 的时候也说过），所以可以利用IDEA的.gitignore插件来帮助我们忽略这些没有必要的插件，这里也放一个<a href="https://blog.csdn.net/qq_34590097/article/details/56284935" target="_blank" rel="external">.gitignore教程</a>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的git教程</a></li>
<li><a href="https://blog.csdn.net/riddle1981/article/details/74938111" target="_blank" rel="external">详解git fetch与git pull的区别</a></li>
<li><a href="https://blog.csdn.net/lovecarpenter/article/details/54290045" target="_blank" rel="external">版本控制之IDEA使用Git</a></li>
<li><a href="https://blog.csdn.net/qq_34590097/article/details/56284935/" target="_blank" rel="external">如何在IntelliJ IDEA中使用.ignore插件忽略不必要提交的文件</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：虽然日常使用git，但是有些时候总是会忘记一些操作，难免会面向搜索引擎查找。所以这里就总结一下。
    
    </summary>
    
      <category term="工具" scheme="http://bestlixiang.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://bestlixiang.site/tags/Git/"/>
    
      <category term="IDEA" scheme="http://bestlixiang.site/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的Java 网络IO</title>
    <link href="http://bestlixiang.site/2018/05/21/Java%E5%9F%BA%E7%A1%80/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java-%E7%BD%91%E7%BB%9CIO/"/>
    <id>http://bestlixiang.site/2018/05/21/Java基础/你不知道的Java-网络IO/</id>
    <published>2018-05-21T04:53:19.000Z</published>
    <updated>2018-05-21T04:54:17.420Z</updated>
    
    <content type="html"><![CDATA[<p>引：可能很多同学一看Java Java 网络IO，心里肯定会觉得这个有什么好讲的，不就是Socket吗，说对也对，因为他讲到了BIO(同步阻塞IO)，但是却不知还有NIO(同步非阻塞IO)，AIO(异步非阻塞IO)！<a id="more"></a></p>
<h1 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h1><p>关于BIO、NIO以及AIO的代码都放在github上了，注释应该很详细了，大家有需要的可以看一下：<a href="https://github.com/todorex/Java_IO" target="_blank" rel="external">你不知道的那些Java网络IO（BIO、NIO、AIO）</a></p>
<h1 id="同步or异步-阻塞or非阻塞"><a href="#同步or异步-阻塞or非阻塞" class="headerlink" title="同步or异步 阻塞or非阻塞"></a>同步or异步 阻塞or非阻塞</h1><p>在谈到IO的时候，避免不了听到同步、异步、阻塞、非阻塞这几个名词或者是他们的组合词，我们经常会感到迷惑不解。</p>
<h2 id="同步or异步"><a href="#同步or异步" class="headerlink" title="同步or异步"></a>同步or异步</h2><p>同步和异步是相对于IO事件(读写操作)而言的</p>
<ul>
<li>同步：在进行IO操作时，程序不能干别的事情，等着IO事件完成之后才能去做别的事情</li>
<li>异步：不关心IO处理操作(因为把IO操作交给操作系统干了)，在处理IO的时候，可以去做别的事情，然后等待IO事件处理完成的通知</li>
</ul>
<h2 id="阻塞or非阻塞"><a href="#阻塞or非阻塞" class="headerlink" title="阻塞or非阻塞"></a>阻塞or非阻塞</h2><p>阻塞和非阻塞是相对于数据而言的</p>
<ul>
<li>阻塞：如果数据没有准备好，程序就一直等待，直到数据准备好了才往下执行</li>
<li>非阻塞：不管数据有没有准备好，程序都往下进行</li>
</ul>
<p>这里是自己看到的一个例子，可以结合起来理解：</p>
<p>如果你想吃一份宫保鸡丁盖饭：</p>
<p><strong>同步阻塞</strong>：你到饭馆点餐，然后在那等着，还要一边喊：好了没啊！（IO操作[拿饭]没有干好，预想之外的事都不能干，数据[饭]没有好，就一直等着）</p>
<p><strong>同步非阻塞</strong>：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！（IO操作[拿饭]没有干好，预想之外的事都不能干，数据[饭]没有好，但是不用一直等着，可以继续干预先安排的事[遛狗]，但是需要时不时去问一下饭有没有好）</p>
<p><strong>异步阻塞</strong>：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。（IO操作[拿饭]没有干好，但是我想干啥就干啥，等着通知就好，数据[饭]没有好，就一直等着去拿饭）</p>
<p><strong>异步非阻塞</strong>：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。（IO操作[拿饭]没有干好，但是我想干啥就干啥，等着通知就好，数据[饭]没有好，但是不用一直等着，可以继续干预先安排的事）</p>
<h1 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h1><p>Unix定义了五种I/O模型，如下：</p>
<ul>
<li>阻塞I/O</li>
<li>非阻塞I/O</li>
<li>I/O复用（select、poll、linux 2.6种改进的epoll）</li>
<li>信号驱动IO（SIGIO）</li>
<li>异步I/O（POSIX的aio_系列函数）</li>
</ul>
<p>下图是五种I/O模型的比较：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/javaCore/jpg/unix_io_model.jpg" alt="unix_io_model"></p>
<p>POSIX把I/O操作划分成两类：</p>
<ul>
<li>同步I/O: 同步I/O操作<strong>导致请求阻塞</strong>，直至操作完成</li>
<li>异步I/O: 异步I/O操作<strong>不导致请求阻塞</strong></li>
</ul>
<p>从上面的图中可以看出Unix的前四种I/O模型都是同步I/O, 只有最后一种才是异步I/O。</p>
<p>我们在看看Java中的IO分类：</p>
<ul>
<li>传统的Java BIO (blocking I/O)是Unix I/O模型中的第一种。</li>
<li>Java NIO中如果不使用select模式，而只把channel配置成nonblocking则是第二种模型。</li>
<li>Java NIO select实现的是一种多路复用I/O。底层使用epoll或者相应的poll系统调用。</li>
<li>第四种模型JDK应该是没有实现。</li>
<li>Java NIO2增加了对第五种模型的支持，也就是AIO。</li>
</ul>
<h1 id="BIO网络编程"><a href="#BIO网络编程" class="headerlink" title="BIO网络编程"></a>BIO网络编程</h1><p>传统的同步阻塞模型(BIO)开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。</p>
<p>简单的描述一下BIO的服务端通信模型：采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理没处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答通信模型。如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/javaCore/jpg/bio.png" alt="bio"></p>
<p>该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1:1的正比关系，Java中的线程也是比较宝贵的系统资源，线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就<strong>死掉了</strong>。</p>
<p> <strong>为了改进这种一连接一线程的模型</strong>，我们可以使用<strong>线程池</strong>来管理这些线程（需要了解更多请参考前面提供的文章），实现1个或多个线程处理N个客户端的模型（但是底层还是使用的同步阻塞I/O），通常被称为“伪异步I/O模型“。伪异步I/O模型图如下：</p>
<p> <img src="http://o6plzvjf2.bkt.clouddn.com/javaCore/png/fake_aio.png" alt="fake_aio"></p>
<p> 我们知道，如果使用CachedThreadPool线程池，其实除了能自动帮我们管理线程（复用），看起来也就像是1:1的客户端：线程数模型，而使用FixedThreadPool我们就有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N:M的伪异步I/O模型。但是，正因为限制了线程数量，如果发生大量并发请求，超过最大数量的线程就只能等待，直到线程池中的有空闲的线程可以被复用。而对Socket的输入流就行读取时，会一直阻塞。  所以在读取数据较慢时（比如数据量大、网络传输慢等），大量并发的情况下，其他接入的消息，<strong>只能一直等待</strong>，这就是最大的弊端。</p>
<p> <strong>PS：</strong> 源码都在github上。</p>
<h1 id="NIO网络编程"><a href="#NIO网络编程" class="headerlink" title="NIO网络编程"></a>NIO网络编程</h1><p>NIO(同步非阻塞IO)提供了与传统BIO模型中的Socket和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现。<strong>新增的着两种通道都支持阻塞和非阻塞两种模式</strong>。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用NIO的非阻塞模式来开发。</p>
<p>在用NIO进行开发时，我们需要先了解一下NIO的几个核心概念：</p>
<h2 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区 Buffer"></a>缓冲区 Buffer</h2><p>Buffer是一个对象，包含一些要写入或者读出的数据。在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p>
<p>缓冲区实际上是一个数组，并提供了对数据结构化访问以及维护读写位置等信息。具体的缓存区有这些：ByteBuffe、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。他们实现了相同的接口：Buffer。</p>
<h2 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道 Channel"></a>通道 Channel</h2><p>我们对数据的读取和写入要通过Channel，它就像水管一样，是一个通道。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。底层的操作系统的通道一般都是全双工的，所以全双工的Channel比流能更好的映射底层操作系统的API。</p>
<p>Channel主要分两大类：</p>
<ul>
<li>SelectableChannel：用户网络读写</li>
<li>FileChannel：用于文件操作</li>
</ul>
<p>网络编程中涉及的ServerSocketChannel和SocketChannel都是SelectableChannel的子类。</p>
<h2 id="多路复用器-Selector"><a href="#多路复用器-Selector" class="headerlink" title="多路复用器 Selector"></a>多路复用器 Selector</h2><p>Selector提供选择已经就绪的任务的能力：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。</p>
<p>一个Selector可以同时轮询多个Channel(<strong>所以是非阻塞的</strong>)，因为JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制。所以，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。</p>
<h2 id="创建NIO服务端的通信流程"><a href="#创建NIO服务端的通信流程" class="headerlink" title="创建NIO服务端的通信流程"></a>创建NIO服务端的通信流程</h2><p>我们可以看下面这种通信序列图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/javaCore/png/nioServer.png" alt="nioServer"></p>
<p><strong>PS：</strong> 源码都在github上。</p>
<h1 id="AIO网络编程"><a href="#AIO网络编程" class="headerlink" title="AIO网络编程"></a>AIO网络编程</h1><p>异步的套接字通道是真正的异步非阻塞I/O，对应于UNIX网络编程中的事件驱动I/O（AIO）。他不需要过多的Selector对注册的通道进行轮询即可实现异步读写，从而简化了NIO的编程模型。</p>
<p>AIO(异步非阻塞IO)提供了与传统BIO模型中的Socket和ServerSocket相对应的AsynchronousSocketChannel和AsynchronousServerSocketChannel两种不同的套接字通道实现。</p>
<h2 id="异步的处理"><a href="#异步的处理" class="headerlink" title="异步的处理"></a>异步的处理</h2><p>异步无非是通知系统做一件事情。然后忘掉它，自己做其他事情去了。很多时候系统做完某一件事情后需要一些后续的操作。怎么办？这时候就是告诉异步调用如何做后续处理。通常有两种方式：</p>
<ul>
<li>将来式: 当你希望主线程发起异步调用，并轮询等待结果的时候使用将来式;</li>
<li>回调式: 常说的异步回调就是它。</li>
</ul>
<p><strong>PS：</strong> AIO的代码主要基于回调式，源码都在github上。</p>
<h1 id="BIO、NIO、AIO适用场景分析"><a href="#BIO、NIO、AIO适用场景分析" class="headerlink" title="BIO、NIO、AIO适用场景分析:"></a>BIO、NIO、AIO适用场景分析:</h1><ul>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/itismelzp/article/details/50886009" target="_blank" rel="external">Java中BIO,NIO,AIO的理解</a></li>
<li><a href="https://blog.csdn.net/mcgrady_tracy/article/details/47424149" target="_blank" rel="external">Linux select和poll系统调用</a></li>
<li><a href="http://colobu.com/2014/11/13/java-aio-introduction/" target="_blank" rel="external">java aio 编程</a></li>
<li><a href="https://blog.csdn.net/anxpp/article/details/51512200" target="_blank" rel="external">Java 网络IO编程总结（BIO、NIO、AIO均含完整实例代码）</a></li>
<li><a href="https://blog.csdn.net/huangwenyi1010/article/details/75577091?ref=myread" target="_blank" rel="external">Java之IO,BIO,NIO,AIO知多少？</a></li>
<li><a href="https://blog.csdn.net/an_tao/article/details/45914841" target="_blank" rel="external">ServerSocketChannel的用法详解</a></li>
<li><a href="https://www.jianshu.com/p/c5e16460047b" target="_blank" rel="external">(001)java中的AIO</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：可能很多同学一看Java Java 网络IO，心里肯定会觉得这个有什么好讲的，不就是Socket吗，说对也对，因为他讲到了BIO(同步阻塞IO)，但是却不知还有NIO(同步非阻塞IO)，AIO(异步非阻塞IO)！
    
    </summary>
    
      <category term="Java基础" scheme="http://bestlixiang.site/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="BIO" scheme="http://bestlixiang.site/tags/BIO/"/>
    
      <category term="NIO" scheme="http://bestlixiang.site/tags/NIO/"/>
    
      <category term="AIO" scheme="http://bestlixiang.site/tags/AIO/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议</title>
    <link href="http://bestlixiang.site/2018/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://bestlixiang.site/2018/05/20/计算机网络/HTTP协议/</id>
    <published>2018-05-20T06:55:48.000Z</published>
    <updated>2018-05-20T06:59:29.325Z</updated>
    
    <content type="html"><![CDATA[<p>引：作为Web开发人员，可能你最需要深入学习的就是<strong>HTTP协议</strong>了吧！<a id="more"></a></p>
<h1 id="HTTP认识"><a href="#HTTP认识" class="headerlink" title="HTTP认识"></a>HTTP认识</h1><p><strong>HTTP协议</strong>是Hyper Text TransferProtocol（超文本传输协议）的缩写,<br>它是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）的应用层协议。它工作于客户端-服务端架构之上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<h1 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h1><ol>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li>
<li>HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。HTTP 1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。</li>
<li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
</ol>
<p><strong>PS：</strong> HTTP协议是无状态的和Connection: keep-alive的区别：</p>
<ul>
<li><p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。<br>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</p>
</li>
<li><p>从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。<br>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p>
</li>
</ul>
<h1 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h1><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了<strong>请求/响应模型</strong>。客户端向服务器发送一个<strong>请求报文</strong>，服务器将返回一个<strong>响应报文</strong>。</p>
<p>以下是 HTTP 请求步骤：</p>
<ol>
<li>客户端连接到Web服务器：<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如：<a href="http://www.todorex.com。" target="_blank" rel="external">http://www.todorex.com。</a></li>
<li>发送HTTP请求：<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文。</li>
<li>服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。</li>
<li>释放连接TCP连接：<br>若请求报文首部的connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求。</li>
<li>客户端浏览器解析HTML内容<br>客户端浏览器首先解析响应报文，然后客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</li>
</ol>
<h1 id="HTTP报文之请求报文"><a href="#HTTP报文之请求报文" class="headerlink" title="HTTP报文之请求报文"></a>HTTP报文之请求报文</h1><p>请求报文由请求行(请求方法、URL、协议版本)、请求头部、空行(回车+换行)和请求数据(主体)四个部分组成。如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/httpRequest.png" alt="httpRequest"></p>
<p>它的例子如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/httpRequestDemo.png" alt="httpReponseDemo"></p>
<h2 id="请求报文之URL"><a href="#请求报文之URL" class="headerlink" title="请求报文之URL"></a>请求报文之URL</h2><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URI包含了用于查找某个资源的足够的信息。</p>
<p>统一资源定位符（Uniform Resource Locator, URL）是互联网上用来标识某一处资源的地点，所以可见URL是URI的子集。以下面这个URL为例，介绍下普通URL的各部分组成：</p>
<blockquote>
<p><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name" target="_blank" rel="external">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></p>
</blockquote>
<p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p>
<ol>
<li>协议部分：该URL的协议部分为“http:”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符。</li>
<li>域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用。在建立TCP连接的时候用的就是IP地址，我们可以用域名是因为有了DNS域名解析。</li>
<li>端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口，HTTP默认的端口号为80，HTTPS的端口号为443。</li>
<li>虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”。</li>
<li>文件名部分：从域名后的最后一个“/”开始到“?”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名，一般为index.html。</li>
<li>锚部分：从“#”开始到最后，都是锚部分(HTML的节点)。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分。</li>
<li>参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li>
</ol>
<h2 id="请求报文之请求方法"><a href="#请求报文之请求方法" class="headerlink" title="请求报文之请求方法"></a>请求报文之请求方法</h2><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了六种请求方法：OPTIONS, PUT, DELETE, TRACE，CONNECT和PATCH 方法。</p>
<p>这八种方法(动作)表明了请求的URL指定的资源的操作方式，分别如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>操作方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td><strong>请求</strong>指定的页面信息，并返回实体主体</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的<strong>建立</strong>和/或已有资源的<strong>修改</strong></td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据<strong>取代</strong>指定的文档的内容</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器<strong>删除</strong>指定的页面</td>
</tr>
<tr>
<td>CONNECT</td>
<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>允许客户端查看服务器的性能</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断</td>
</tr>
<tr>
<td>PATCH</td>
<td>用来将<strong>局部修改</strong>应用于某一资源</td>
</tr>
</tbody>
</table>
<p><strong>PS：</strong> GET和POST的区别：</p>
<ul>
<li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中。</li>
<li>GET提交的数据大小有限制，最多只能有1024字节（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。</li>
<li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</li>
</ul>
<h2 id="请求报文之通用首部"><a href="#请求报文之通用首部" class="headerlink" title="请求报文之通用首部"></a>请求报文之通用首部</h2><p>常见的通用首部如下：</p>
<ol>
<li>Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝；在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样。Pargma只有一个用法， 例如： Pragma: no-cache<br>注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control</li>
<li>Cache-Control：指定请求和响应遵循的缓存机制。缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程）。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public(可以被任何缓存所缓存)、private(内容只缓存到私有缓存中)、no-cache(所有内容都不会被缓存)、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage。</li>
<li>Connection：之前已经说过，主要是控制TCP连接是否在请求完马上端开。</li>
<li>Date：表示消息发送的时间。</li>
</ol>
<h2 id="请求报文之请求首部"><a href="#请求报文之请求首部" class="headerlink" title="请求报文之请求首部"></a>请求报文之请求首部</h2><p>常见的请求首部如下：</p>
<ol>
<li>If-Modified-Since：把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。</li>
<li>If-None-Match：If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag。</li>
<li>Accept：浏览器端可以接受的MIME类型。例如：Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档，如果服务器无法返回text/html类型的数据，服务器应该返回一个406错误(non acceptable)。通配符 * 代表任意类型，例如 Accept: */* 代表浏览器可以处理所有类型，(一般浏览器发给服务器都是发这个)。</li>
<li>Accept-Encoding：浏览器申明自己可接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）;Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。例如： Accept-Encoding: gzip, deflate。如果请求消息中没有设置这个域，服务器假定客户端对各种内容编码都可以接受。</li>
<li>Accept-Language：浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；例如：Accept-Language: en-us。如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。</li>
<li>Accept-Charset：浏览器可接受的字符集。如果在请求消息中没有设置这个域，缺省表示任何字符集都可以接受。</li>
<li>User-Agent：告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本</li>
<li>Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。</li>
<li>Host：（发送请求时，该头域是必需的）主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。</li>
<li>Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。</li>
<li>Range：可以请求实体的一个或者多个子范围。</li>
<li>Cookie：最重要的请求头之一, 将cookie的值发送给HTTP服务器。</li>
</ol>
<h2 id="请求报文之实体首部"><a href="#请求报文之实体首部" class="headerlink" title="请求报文之实体首部"></a>请求报文之实体首部</h2><p>常见的实体首部如下：</p>
<ol>
<li>Content-Type：说明了实体主体内对象的媒体类型。</li>
<li>Content-Length：表示请求消息正文的长度。</li>
<li>Content-Range：用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-length。</li>
<li>Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。只有在解码之后才可以得到Content-Type头指定的内容类型。</li>
<li>Content-Language：WEB服务器告诉浏览器自己响应的对象所用的自然语言。</li>
</ol>
<h2 id="请求报文之其他首部"><a href="#请求报文之其他首部" class="headerlink" title="请求报文之其他首部"></a>请求报文之其他首部</h2><ol>
<li>P3P：用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题。</li>
</ol>
<h1 id="HTTP报文之响应报文"><a href="#HTTP报文之响应报文" class="headerlink" title="HTTP报文之响应报文"></a>HTTP报文之响应报文</h1><p>响应报文由状态行(协议版本、状态码、消息状态)、响应头部、空行(回车+换行)和响应数据(主体)四个部分组成。如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/httpResponse.png" alt="httpResponse"></p>
<p>它的例子如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/httpReponseDemo.png" alt="httpReponseDemo"></p>
<p>响应报文的通用首部和实体首部以及其他首部都和请求报文差不多，我们主要讲解响应首部。</p>
<h2 id="响应报文之响应首部"><a href="#响应报文之响应首部" class="headerlink" title="响应报文之响应首部"></a>响应报文之响应首部</h2><ol>
<li>Allow：服务器支持哪些请求方法</li>
<li>Expires：指明应该在什么时候认为文档已经过期，从而不再缓存它，重新从服务器获取，会更新缓存。过期之前使用本地缓存。HTTP1.1的客户端和缓存会将非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以将Expires实体报头域，设置为0。</li>
<li>Set-Cookie：非常重要的header, 用于把cookie发送到客户端浏览器，每一个写入cookie都会生成一个Set-Cookie。</li>
<li>Last-Modified：用于指示资源的最后修改日期和时间。Last-Modified也可用setDateHeader方法来设置。</li>
<li>Server：指明HTTP服务器用来处理请求的软件信息。</li>
<li>Location：用于重定向一个新的位置，包含新的URL地址。表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。Location响应报头域常用在更换域名的时候。</li>
<li>WWW-Authenticate：该响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。</li>
</ol>
<h2 id="HTTP之状态码"><a href="#HTTP之状态码" class="headerlink" title="HTTP之状态码"></a>HTTP之状态码</h2><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx</td>
<td>指示信息–表示请求已接收，继续处理</td>
</tr>
<tr>
<td>2xx</td>
<td>成功–表示请求已被成功接收、理解、接受</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向–要完成请求必须进行更进一步的操作</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端错误–请求有语法错误或请求无法实现</td>
</tr>
<tr>
<td>5xx</td>
<td>服务器端错误–服务器未能实现合法的请求</td>
</tr>
</tbody>
</table>
<p>常用的状态码如下：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>200 OK</td>
<td>客户端请求成功</td>
</tr>
<tr>
<td>400 Bad Request</td>
<td>客户端请求有语法错误，不能被服务器所理解</td>
</tr>
<tr>
<td>401 Unauthorized</td>
<td>请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</td>
</tr>
<tr>
<td>403 Forbidden</td>
<td>服务器收到请求，但是拒绝提供服务</td>
</tr>
<tr>
<td>404 Not Found</td>
<td>请求资源不存在，eg：输入了错误的URL</td>
</tr>
<tr>
<td>500 Internal Server Error</td>
<td>服务器发生不可预期的错误</td>
</tr>
<tr>
<td>503 Server Unavailable</td>
<td>服务器当前不能处理客户端的请求，一段时间后可能恢复正常</td>
</tr>
</tbody>
</table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《图解HTTP》</li>
<li><a href="https://www.jianshu.com/p/80e25cb1d81a" target="_blank" rel="external">关于HTTP协议，一篇就够了</a></li>
<li><a href="https://www.cnblogs.com/EricaMIN1987_IT/p/3837436.html" target="_blank" rel="external">HTTP协议详解</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：作为Web开发人员，可能你最需要深入学习的就是&lt;strong&gt;HTTP协议&lt;/strong&gt;了吧！
    
    </summary>
    
      <category term="计算机网络" scheme="http://bestlixiang.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="http://bestlixiang.site/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议</title>
    <link href="http://bestlixiang.site/2018/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://bestlixiang.site/2018/05/18/计算机网络/TCP协议/</id>
    <published>2018-05-18T06:58:34.000Z</published>
    <updated>2018-05-18T07:31:18.419Z</updated>
    
    <content type="html"><![CDATA[<p>引：TCP作为传输层的一大协议，虽然没有UDP简单，但是胜在可靠。<a id="more"></a></p>
<h1 id="TCP认识"><a href="#TCP认识" class="headerlink" title="TCP认识"></a>TCP认识</h1><p><strong>TCP(传输控制协议)</strong> 是一种面向连接、可靠的、基于字节流的传输层协议。TCP在传送数据之前会先相互发送一些预备报文段协商一些参数，比如序号等等，TCP将用户数据打包成报文段，发送数据后启动一个定时器，另一端对收到的数据进行确认，对失序的数据重新排序，丢弃重复数据，TCP提供端到端的流量控制，并计算和验证一个强制性的端到端校验和。</p>
<h1 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h1><ol>
<li>TCP是面向连接的，通信前需要建立连接，通信结束需要释放连接。</li>
<li>TCP提供可靠交付服务，可靠指的是：TCP发送的数据无重复、无丢失、无错误、与发送端顺序一致。</li>
<li>TCP是面向字节流的，面向字节流指的是：TCP以字节为单位。虽然传输的过程中数据被划分成一个个数据报，但这只是为了方便传输，接收端最终接受到的数据将与发送端的数据一模一样。</li>
<li>TCP提供全双工通信，全双工通信指的是：TCP的两端既可以作为发送端，也可以作为接收端。</li>
<li>一条TCP连接的两端只能有两个端点，TCP只能提供点到点的通信，而UDP可以任意方式的通信。</li>
</ol>
<h1 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h1><p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/tcp.png" alt="tcp"></p>
<ol>
<li>16位端口号:包含源端口和目的端口，客户端通常使用系统自动选择的临时端口号，而服务器则使用自主定义端口号.</li>
<li>32位序号:一次TCP通信过程中一个传输方向上的字节流的每个字节的编号，例如:A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机值ISN，那么在该传输方向上，后续的TCP报文段中序号值将被系统设置为ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移。</li>
<li>32位的确认号: 用作对另外一方发送来的TCP报文段的响应，其值是收到的TCP报文段的序号值加1。</li>
<li>4位头部长度: 标识TCP头部有多少个32bit(4字节)，最大60字节.</li>
<li>6位标志位:<ul>
<li>URG:表示紧急指针是否有效.</li>
<li>ACK:表示确认号是否有效，我们称携带ACK标志的TCP报文段为确认报文段.</li>
<li>PSH:提示接收端应用程序应该立即从TCP接收缓冲区中读走数据,为接收数据腾出空间.</li>
<li>RST:表示要求对方重新建立连接(复位报文段)</li>
<li>SYN:表示请求建立一个连接(同步报文段);</li>
<li>FIN:表示通知对方本端要关闭连接了(结束报文段);</li>
</ul>
</li>
<li>16位窗口大小:TCP流量的一个控制手段,,它告知是对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度.</li>
<li>16位校验和:由发送端填充，接收端对TCP报文段执行CRC算法（循环冗余码检验，与UDP一样），检验TCP头部在传输过程中是否损坏，不仅包括TCP头部，也包括数据部分。</li>
<li>16位紧急指针:是一个正的偏移量.它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号.</li>
<li>选项字段，上述字段都是每个TCP头部必须要有的，而选项字段是可选的，且长度可变，最长40字节。 最常用的选项字段为MMS：最大报文长度。</li>
</ol>
<h1 id="TCP连接建立-三次握手"><a href="#TCP连接建立-三次握手" class="headerlink" title="TCP连接建立(三次握手)"></a>TCP连接建立(三次握手)</h1><p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/tcpBuild.png" alt="tcpBuild"></p>
<p>TCP协议中，主动发起请求的一端称为<strong>客户端</strong>，被动连接的一端称为<strong>服务端</strong>。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据。</p>
<ol>
<li><strong>握手前</strong>：服务器和客户端都为CLOSED状态，在通信开始前，双方都得创建各自的传输控制块（TCB）。服务器创建完TCB后遍进入LISTEN状态，此时准备接收客户端发来的连接请求。</li>
<li><strong>第一次握手</strong>：客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，(表示该报文段为连接请求报文) seq=x(x为本次TCP通信的字节流的初始序号)。请求发送后，客户端便进入SYN-SENT状态。</li>
<li><strong>第二次握手</strong> ：服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，(表示该报文段为连接同意的应答报文) seq=y，(表示服务端作为发送者时，发送字节流的初始序号) ack=x+1(表示服务端希望下一个数据报发送序号从x+1开始的字节)。<br>该应答发送完成后便进入SYN-RCVD状态。</li>
<li><strong>第三次握手</strong> ：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。<br>该报文段的头部为：ACK=1，seq=x+1，ack=y+1。<br>客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！</li>
</ol>
<p><strong>PS：为什么连接建立需要三次握手，而不是两次握手？</strong></p>
<p>防止失效的连接请求报文段被服务端接收，从而产生错误，失效的连接请求指的是：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是失效的。</p>
<p>若建立连接只需两次握手，服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，此时，如果那个失效的连接请求抵达了服务端，但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。</p>
<h1 id="TCP连接释放-四次握手"><a href="#TCP连接释放-四次握手" class="headerlink" title="TCP连接释放(四次握手)"></a>TCP连接释放(四次握手)</h1><p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/tcpRelease.png" alt="tcpRelease"><br><strong>TCP连接发送数据</strong>是双向的，因此在四次挥手中，前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一方向的连接。</p>
<ol>
<li><strong>第一次握手</strong> ：若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：FIN=1，(表示该报文段是一个连接释放请求) seq=u(u-1是A向B发送的最后一个字节的序号)。此时，A将进入FIN-WAIT-1状态。</li>
<li><strong>第二次握手</strong> ：B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含： ACK=1，(表示应答) seq=v (v-1是B向A发送的最后一个字节的序号)，ack=u+1(表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节)。A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。<strong>第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。</strong></li>
<li><strong>第三次握手</strong> ：当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。</li>
<li><strong>第四次握手</strong> ：A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL(报文最大生存时间)时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。</li>
</ol>
<h1 id="TCP的可靠传输"><a href="#TCP的可靠传输" class="headerlink" title="TCP的可靠传输"></a>TCP的可靠传输</h1><p>TCP采用了校验和、连接管理、序列号、确认应答，重发控制、滑动窗口协议（连续ARQ协议、流控制、拥塞控制）等机制来保证它的可靠性。</p>
<h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><p>TCP和UDP校验和的方式一致，可以参照另一篇博客——<a href="http://todorex.com/2018/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP%E5%8D%8F%E8%AE%AE/" target="_blank" rel="external">UDP协议</a></p>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>其实就是利用建立连接时的三次握手来提高可靠性。</p>
<h2 id="通过序列号与确认应答"><a href="#通过序列号与确认应答" class="headerlink" title="通过序列号与确认应答"></a>通过序列号与确认应答</h2><p>在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个收到消息的通知，这个消息叫做<strong>确认应答(ACK)</strong>，比如客户端发送[数据(1-1000)]，那么服务端将会回应[确认应答(下一个数1001)]。在一定时间内没有等到确认应答，发送端会认为数据已经丢失，并进行重发。</p>
<h2 id="滑动窗口协议-连续ARQ协议"><a href="#滑动窗口协议-连续ARQ协议" class="headerlink" title="滑动窗口协议(连续ARQ协议)"></a>滑动窗口协议(连续ARQ协议)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>先简单说说ARQ(Automatic Repeat reQuest)协议(自动重传请求协议)： 当请求失败时它会自动重传，直到请求被正确接收为止。这种机制保证了每个分组都能被正确接收。</p>
<p>再看连续ARQ协议：在ARQ协议发送者每次只能发送一个分组，在应答到来前必须等待。而连续ARQ协议的发送者拥有一个发送窗口，发送者可以在没有得到应答的情况下连续发送窗口中的分组。</p>
<h3 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h3><p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/sendWindow.png" alt="sendWindow"></p>
<p>发送窗口的大小由接收窗口的剩余大小决定。接收者会把当前接收窗口的剩余大小写入应答TCP报文段的头部，发送者收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小。发送窗口的大小是不断变化的。</p>
<p>发送窗口(p1-p3)由三个指针构成：</p>
<ul>
<li>p1：p1指向发送窗口的后沿，它后面的字节表示已经发送且已收到应答。</li>
<li>p2：p2指向尚未发送的第一个字节。<br>p1-p2间的字节表示已经发送，但还没收到确认应答。这部分的字节仍需保留，因为可能还要超时重发。<br>p2-p3间的字节表示可以发送，但还没有发送的字节。</li>
<li>p3：p3指向发送窗口的前沿，它前面的字节尚未发送，且不允许发送。</li>
</ul>
<p>发送者每收到一个应答，后沿就可以向前移动指定的字节。此时若窗口大小仍然没变，前沿也可以向前移动指定字节。<br>当p2和前沿重合时，发送者必须等待确认应答。</p>
<h3 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h3><p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/receiverWindow.png" alt="receiverWindow"></p>
<p>接收者收到的字节会存入接收窗口，接收者会对已经正确接收的有序字节进行累计确认，发送完确认应答后，接收窗口就可以向前移动指定字节。<br>如果某些字节并未按序收到，接收者<strong>只会</strong>确认最后一个有序的字节，从而乱序的字节就会被重新发送。</p>
<h2 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>让发送端根据接收端的实际接收能力控制发送的数据量。</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>防止接收端在高负荷的情况下接收数据，因为这个时候如果接收端会将本应该接收的数据丢弃，就又会触发重发机制，从而导致网络流量的无端浪费。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>接收端主动向发送端主机通知自己可以接受数据的大小，于是发送端会发送不超过这个限度的数据。这个大小限度就是接收窗口大小，所以流控制就是利用滑动窗口协议实现的。</p>
<h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><p>当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。为了避免此类问题的发生，发送端主机会时不时发送一个叫做窗口探测的数据段，此数据段仅含一个以获取最新窗口的大小信息。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><h3 id="拥塞控制和流控制的区别？"><a href="#拥塞控制和流控制的区别？" class="headerlink" title="拥塞控制和流控制的区别？"></a>拥塞控制和流控制的区别？</h3><ol>
<li>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况</li>
<li>流控制：流控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收</li>
</ol>
<h3 id="拥塞情况"><a href="#拥塞情况" class="headerlink" title="拥塞情况"></a>拥塞情况</h3><p>观察拥塞的方式有两种：一是超时，二是连续接收到3个重复ACK。</p>
<p><strong>PS：为什么是3个连续的ACK</strong>：由于我们不知道一个重复的ACK是由一个丢失的报文引起的，还是由于仅仅出现了几个报文段的重新排序引起的，因此我们等待少量的重复的ACK到来。因为若只是一些报文段的重新排序引起的，一般在重新排序报文段完成并产生一个新的ACK之前只可能产生1-2个重复的ACK。</p>
<h3 id="拥塞的不同处理方式"><a href="#拥塞的不同处理方式" class="headerlink" title="拥塞的不同处理方式"></a>拥塞的不同处理方式</h3><p>对于由于超时重传认为的拥塞，我们一般是重传报文段，然后进入<strong>慢启动算法</strong>(下方)；对于由于接收到3个重复的ACK认为的拥塞，我们一般是<strong>立即重传报文段</strong>，然后进入<strong>拥塞避免算法</strong>(下方)。这样处理的原因是因为当因为定时器超时，此时网络中可能已经很拥塞，数据确认的ACK已经无法发送回来，因此我们立即减少注入网络中的数据，使用慢启动拥塞窗口减小为1；而对于收到,3个重复的ACK说明还有其他的报文段到达了目的地(因为接收方只有在收到失序的报文段时才会产生重复的ACK而且还有重复的ACK发送回来)，也即收发两端还有数据的流动，因此我们不必使用慢启动突然减少注入网络的数据。</p>
<h3 id="慢启动算法-和-拥塞避免算法"><a href="#慢启动算法-和-拥塞避免算法" class="headerlink" title="慢启动算法 和 拥塞避免算法"></a>慢启动算法 和 拥塞避免算法</h3><p>发送方维护一个发送窗口，发送窗口的大小取决于网络的拥塞情况(拥塞窗口)，发送窗口是动态变化的。<br>发送方还维护一个慢启动阈值。</p>
<ul>
<li>发送窗口 &lt; 慢启动阈值：使用慢启动算法(指数级)</li>
<li>发送窗口 &gt; 慢启动阈值：使用拥塞避免算法(线性加一)</li>
<li>发送窗口 = 慢启动阈值：使用慢开始算法或拥塞避免算法</li>
</ul>
<p>算法的具体过程：</p>
<ol>
<li>通信开始时，使用慢启动算法，发送方的发送窗口设为1，并发送第一个分组M1；</li>
<li>接收方收到M1后，返回确认应答，此时发送方发送窗口扩大两倍，并发送M2、M3；（即，发送方每次收到确认应答后，都将发送窗口设为当前值的两倍）</li>
<li>若发送窗口&gt;慢启动阈值，则使用拥塞避免算法，每次收到确认应答后都将发送窗口+1；</li>
<li>若发送方出现了超时重传，则表明网络出现拥塞，此时：<ol>
<li>慢启动阈值设为当前发送窗口的一半；</li>
<li>发送窗口设为1；</li>
<li>启用拥塞避免算法；</li>
</ol>
</li>
</ol>
<p>PS：发送超时重传时，发送窗口有可能已经超过了慢开始门限，也有可能还没超过；此时不管何种情况，都一律启用拥塞避免算法，并执行上述三步操作！</p>
<p><strong>慢开始算法的作用</strong>：慢开始算法将发送窗口从小扩大，而且按指数级扩大，从而避免一开始就往网络中注入过多的分组从而导致拥塞；它将窗口慢慢扩大的过程其实也在探测网络拥塞情况的过程，当发现出现拥塞时，及时降低发送速度，从而减缓网络拥塞。</p>
<p><strong>拥塞避免算法的作用</strong>：拥塞避免算法使发送窗口以线性方式增长，而非指数级增长，从而使网络更加不容易发生拥塞。</p>
<h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p>当因收到三个及三个以上的重复ACK时，使用如下拥塞控制方法：</p>
<ol>
<li>收到3个重复的ACK，将慢启动阈值设为当前拥塞窗口大小的一半</li>
<li>此时立即重传丢失的报文不用等到定时器超时(超时重传)，此为快重传。</li>
<li>此后开始执行拥塞避免而不是慢启动，此为快恢复。</li>
</ol>
<h1 id="TCP的应用"><a href="#TCP的应用" class="headerlink" title="TCP的应用"></a>TCP的应用</h1><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用。常见的使用UDP协议的应用如下：</p>
<ul>
<li>HTTP(超文本传输协议)</li>
<li>FTP(文件传输协议)</li>
<li>POP、SMTP(邮件传输协议)</li>
<li>Telnet、Telnet(远程连接协议)</li>
<li>QQ文件传输</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/u010425776/article/details/55006347?locationNum=2&amp;fps=1" target="_blank" rel="external">计算机网络传输层知识点全覆盖</a></li>
<li><a href="https://blog.csdn.net/whoamiyang/article/details/50890801" target="_blank" rel="external">TCP协议详解—学习笔记</a></li>
<li><a href="https://blog.csdn.net/corcplusplusorjava/article/details/46954433" target="_blank" rel="external">TCP协议</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：TCP作为传输层的一大协议，虽然没有UDP简单，但是胜在可靠。
    
    </summary>
    
      <category term="计算机网络" scheme="http://bestlixiang.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="http://bestlixiang.site/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>UDP协议</title>
    <link href="http://bestlixiang.site/2018/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://bestlixiang.site/2018/05/17/计算机网络/UDP协议/</id>
    <published>2018-05-17T07:03:18.000Z</published>
    <updated>2018-05-17T07:09:07.421Z</updated>
    
    <content type="html"><![CDATA[<p>引：UDP作为传输层的一大协议，虽然没有TCP可靠，但是却胜在简单。<a id="more"></a></p>
<h1 id="UDP认识"><a href="#UDP认识" class="headerlink" title="UDP认识"></a>UDP认识</h1><p><strong>UDP(用户数据报协议)</strong> 是一种简单的面向数据报、无连接、传输层协议，并且保留了信息边界。UDP不提供错误校正，不保证有序，无法去重复，没有流量控制和拥塞控制，不能保证数据一定到达目的地，但是可以通过校验和提供错误侦测。UDP提供的的是不可靠传输，<strong>因此要有应用层来提供这些功能</strong>。</p>
<h1 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h1><ol>
<li>UDP只在IP数据报服务的基础上增加了少量的功能：利用端口号是实现分用、对整个报文的差错检测。</li>
<li>UDP是无连接的，通信前不需要建立连接，通信结束也无需释放连接。</li>
<li>UDP是不可靠的 它是<strong>尽力而为</strong>交付，不能确保每一个数据报都送达。</li>
<li>UDP是<strong>面向报文</strong>的，面向报文就是指：UDP数据传输的单位是报文，且不会对数据作任何拆分和拼接 操作。在发送端，应用程序给传输层的UDP什么样的数据，UDP不会对数据进行切分，只增加一个UDP头并交给网络层。在接收端，UDP收到网络层的数据报后，去除IP数据报头部后遍交给应用层，不会作任何拼接操作。</li>
<li>相比于TCP，UDP没有拥塞控制，UDP始终以恒定的速率发送数据，并不会根据网络拥塞情况对发送速率作调整。这种方式有利有弊。弊端：网络拥塞时有些报文可能会丢失，因此UDP不可靠。优点：有些使用场景允许报文丢失，如：直播、语音通话，但对实时性要求很高，此时UDP还是很有用武之地的。</li>
<li>UDP支持一对一、一对多、多对多、多对一通信；而TCP只支持一对一通信。</li>
<li>UDP首部开销小，只有8字节。而TCP头部至少由20字节，相比于TCP要高效很多。</li>
</ol>
<h1 id="UDP数据包首部"><a href="#UDP数据包首部" class="headerlink" title="UDP数据包首部"></a>UDP数据包首部</h1><p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/udp.png" alt="udp"></p>
<h2 id="UDP数据包首部解析"><a href="#UDP数据包首部解析" class="headerlink" title="UDP数据包首部解析"></a>UDP数据包首部解析</h2><ol>
<li>16位源端口号：发送端应用程序使用的端口号，用于区分数据报来自哪个进程，多路复用一个传输层（复用：在发送端，多个应用进程公用一个传输层）。</li>
<li>16位目的端口号：数据送往接收端哪个应用程序，利用端口号实现多路分用（分用：在接收端，传输层会根据端口号将数据分派给不同的应用进程）。</li>
<li>16位UDP长度：UDP数据报首部和UDP数据报数据部分总字节数，最小值为8字节(仅有首部)，最大值为65535字节。</li>
<li>16位UDP检验和：UDP的校验和是可选的，TCP是必需的。UDP的校验和覆盖首部及数据部分。在下一节。</li>
<li>数据：要发送的数据，可以为空(0字节)。</li>
</ol>
<h2 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h2><p>UDP校验和的内容超出了UDP数据报文本身的范围，实际上，它的值是通过计算UDP数据报及一个伪包头而得到的。校验和的计算方法与通用的一样，都是累加求和。<br>它的校验和的检验范围如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/computerNetwork/png/checksum.png" alt="checksum"></p>
<p>伪首部并非UDP数据报中实际的有效成分。伪首部是一个虚拟的数据结构，其中的信息是从数据报所在IP分组头的分组头中提取的，既不向下传送也不向上递交，而仅仅是为计算校验和。这样的校验和，既校验了UDP用户数据的源端口号和目的端口号以及UDP用户数据报的数据部分，又检验了IP数据报的源IP地址和目的IP<br>地址。<strong>伪报头保证UDP数据单元到达正确的目的地址</strong>。</p>
<p>校验方式：</p>
<ol>
<li><p>《TCP/IP 详解》卷一 第一版中如下计算检验和字段的值：</p>
<ul>
<li>发送方计算UDP检验和：<br>首先把检验和字段置为0，把上图中,各部分数据(包括UDP伪首部及填充字段)按每16bit进行二进制反码求和(若最高位产生进位就加到最低位上去)，所求结果就是16bitUDP检验和字段的值。</li>
<li>接收方计算UDP检验和：<br>对收到的UDP数据报(加上了UDP首部和填充字节)按每16bit进行二进制反码求和(若最高位产生进位就加到最低位上去)，若结果为全1，则UDP数据报在传输过程中没有出现差错，否则数据报有差错。</li>
</ul>
</li>
<li>《TCP/IP 详解》卷一 第二版中如下计算检验和字段的值：<ul>
<li>发送方计算UDP检验和：<br>首先把检验和字段置为0，把上图中,各部分数据(包括UDP伪首部及填充字段)按每16bit进行二进制反码求和(若最高位产生进位就加到最低位上去)，最后结果再按位取反，所得结果就是16bitUDP检验和字段的值。</li>
<li>接收方计算UDP检验和：<br>对收到的UDP数据报(加上了UDP首部和填充字节)按每16bit进行二进制反码求和(若最高位产生进位就加到最低位上去)，再按位取反，若结果为全0，则UDP数据报在传输过程中没有出现差错，否则数据报有差错。<strong>因为检验和的值从不为0xFFFF</strong></li>
</ul>
</li>
</ol>
<h1 id="UDP服务器三类地址绑定"><a href="#UDP服务器三类地址绑定" class="headerlink" title="UDP服务器三类地址绑定"></a>UDP服务器三类地址绑定</h1><table>
<thead>
<tr>
<th>本地地址</th>
<th>远端地址</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>LocalIP:Lport</td>
<td>ForeignIP:Fport</td>
<td>只限于一个客户</td>
</tr>
<tr>
<td>LocalIP:Lport</td>
<td>*:*</td>
<td>只限于一个本地IP和端口的数据包</td>
</tr>
<tr>
<td>*:port</td>
<td>*:*</td>
<td>接收发送到Lport的所有数据包</td>
</tr>
</tbody>
</table>
<ol>
<li>第一行中服务器限定了只从本地Local这个IP地址的Lport端口接收数据报，而且只接收来自IP为Foreign且端口为Fport发来的数据。</li>
<li>第二行中服务器限定了只从本地LocalIP这个IP地址的Lport端口接收数据报，但可以接收任何主机发送的数据。</li>
<li>第三行中服务器只限定了接收数据的端口号，因此任何一个本地接口IP都可以接收它，而且数据可以来自任何主机发送的数据。</li>
</ol>
<h1 id="UDP的应用"><a href="#UDP的应用" class="headerlink" title="UDP的应用"></a>UDP的应用</h1><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。常见的使用UDP协议的应用如下：</p>
<ul>
<li>QQ语言和视频</li>
<li>DNS(域名服务器)</li>
<li>NFS(网络文件系统)</li>
<li>TFTP(普通文件传输协议)</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/CorCplusplusorjava/article/details/47164875" target="_blank" rel="external">UDP协议</a></li>
<li><a href="https://blog.csdn.net/sinat_30270011/article/details/51980160" target="_blank" rel="external">UDP协议的应用</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：UDP作为传输层的一大协议，虽然没有TCP可靠，但是却胜在简单。
    
    </summary>
    
      <category term="计算机网络" scheme="http://bestlixiang.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="UDP" scheme="http://bestlixiang.site/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务</title>
    <link href="http://bestlixiang.site/2018/05/11/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <id>http://bestlixiang.site/2018/05/11/数据库/数据库事务/</id>
    <published>2018-05-11T07:10:33.000Z</published>
    <updated>2018-05-11T07:17:04.678Z</updated>
    
    <content type="html"><![CDATA[<p>引：数据库事务在数据库操作中是十分重要的，因为它要么全部执行，要么全部执行，这样才能保证数据库的数据的完整性与一致性。<a id="more"></a></p>
<h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><p>构成单一逻辑工作单元的操作集合。</p>
<p>事务是访问并可能更新各种数据项的一个程序执行单元，事务通常用形如begin transaction 和 end transaction来界定，事务由它们之间执行的全体操作组成。</p>
<p><strong>举个例子</strong>：将钱从一个账户转到另一个账户就是一个事务，该事务包括分别对两个账户的更新。</p>
<h1 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h1><ol>
<li>原子性（Atomicity）：事务是一个不可分割的操作，要么全都正确执行，要么全都不执行。</li>
<li>一致性（Consistency）：事务开始前和事务结束后，数据库的完整性约束没有被破坏。比如上面转账例子中，两个账户的总金额就是完整性约束，因为他们的总金额是不变的。但是在并发事务中，一致性很容易被破坏，需要我们特别注意。</li>
<li>隔离性（Isolation）：事务的执行是相互独立的，它们不会相互干扰，一个事务不会看到另一个正在运行过程中的事务的数据。</li>
<li>持久性（Durability）：事务结束后，事务的结果必须是永久保存的。即使数据库发生崩溃，在数据库恢复后事务提交的结果仍然不会丢失。</li>
</ol>
<p>确保隔离性有可能对系统性能造成较大的不利影响，由于这个原因，一些应用在隔离性上采取一些妥协。</p>
<h1 id="事务的分类"><a href="#事务的分类" class="headerlink" title="事务的分类"></a>事务的分类</h1><ol>
<li>扁平事务(Flat Transactions)：它是实际生产环境中最常用、最简单的事务类型。在扁平事务中，所有操作都处于同一层次，其由begin transaction开始，commit或rollback结束，其间的操作是原子的，要么都执行，要么都回滚，因此扁平事务是应用程序称为原子操作的的基本组成模块。但是发生错误时都需要回滚到事务的起始位置，无法回滚部分操作，所以回滚开销太大。</li>
<li>带有保存点的扁平事务(Flat Transactions with Savepoints)： 除了支持扁平事务支持的操作外，允许在事务执行过程中回滚同一事务中较早的一个状态。这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销太大，保存点用来通知事务系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。</li>
<li>链事务(Chained Transactions)：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务，提交事务操作和开始下一个事务操作 将合并为一个原子操作，这意味着下一个事务将看到上一个事务的结果，就好像一个事务中进行的一样。和带有保存点的扁平事务不同的是，带有保存点的扁平事务能回滚到任意正确的保存点，而链事务中的回滚仅限当前事务，即只能恢复到最近的一个保存点。</li>
<li><p>嵌套事务(Nested Transactions)：由一个顶层事务(top-level transaction)控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务。嵌套事务是由若干事务组成的一棵树，子树既可以是嵌套事务也可以是扁平事务，处在叶节点的事务是扁平事务，但是每个事务从根到叶节点的距离可以说是不同的。子事务既可以提交也可以回滚。但是它的提交操作并不马上生效。除非其父事务已经提交。树中的任意事务回滚会引起它的所有子事务一同回滚，故子事务仅保留ACI特性而不具有D特性。</p>
</li>
<li><p>分布式事务(Distributed Transactions)：通常是一个分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。</p>
</li>
</ol>
<h1 id="数据库并发访问会出现的问题"><a href="#数据库并发访问会出现的问题" class="headerlink" title="数据库并发访问会出现的问题"></a>数据库并发访问会出现的问题</h1><h2 id="读问题"><a href="#读问题" class="headerlink" title="读问题"></a>读问题</h2><ol>
<li>脏读：A事务读取B事务尚未提交的更改数据，并在这个数据的基础上进行操作，这时候如果事务B回滚，那么A事务读到的数据是不被承认的。</li>
<li>虚度（不可重复读）：A事务读取了B事务已经提交的<strong>更改数据</strong>。假如A在取款事务的过程中，B往该账户转账100，A两次读取的余额发生不一致。防止读到更改数据，需要对操作的数据添加行级锁。</li>
<li>幻读：A事务读取B事务提交的<strong>新增数据</strong>。例如银行系统在同一个事务中两次统计存款账户的总金额，在两次统计中，刚好新增了一个存款账户，存入了100，这时候两次统计的总金额不一致。 防止读到新增数据，需要对操作的数据添加表级锁。</li>
</ol>
<h2 id="更新问题"><a href="#更新问题" class="headerlink" title="更新问题"></a>更新问题</h2><ol>
<li>第一类丢失更新：A事务撤销时，把已经提交的B事务的更新数据覆盖了。</li>
<li>第二类丢失更新：A事务覆盖B事务已经提交的数据，造成B事务所做的操作丢失。</li>
</ol>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>为了解决上述问题，数据库通过多种<strong>并发控制机制</strong>（常用的有两阶段封锁和快照隔离）解决并发访问的问题。但是直接使用并发控制机制是很复杂的，数据库给用户提供了不同的<strong>事务隔离级别</strong>，只要设置了事务隔离级别，数据库就会分析事务中的sql语句然后自动选择合适的并发控制机制。</p>
<p>四种隔离级别如下：</p>
<ol>
<li>可串行化(SERIALIZABLE)：保证可串行化调度，不允许出现任何问题。</li>
<li>可重复读(REPEATABLE READ) ：只允许读取已提交的数据，而且在一个事务两次读取一个数据项期间，其他事务不能更新该数，单不要求该事务与其他事务可串行化。</li>
<li>已提交读(READ COMMITTED)：只允许读取已提交的数据，但不要求可重复读。</li>
<li>未提交读(READ UNCOMMITTED)：允许读取未提交的数据，这是SQL允许的最低一致性级别。</li>
</ol>
<p>不同的隔离级别对并发问题的解决情况如下图：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>虚读</th>
<th>幻读</th>
<th>第一列丢值更新</th>
<th>第二类丢失更新</th>
</tr>
</thead>
<tbody>
<tr>
<td>可串行化(SERIALIZABLE)</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
<tr>
<td>可重复读(REPEATABLE READ)</td>
<td>不允许</td>
<td>不允许</td>
<td>允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
<tr>
<td>已提交读(READ COMMITTED)</td>
<td>不允许</td>
<td>允许</td>
<td>允许</td>
<td>不允许</td>
<td>允许</td>
</tr>
<tr>
<td>未提交读(READ UNCOMMITTED)</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
<td>不允许</td>
<td>允许</td>
</tr>
</tbody>
</table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《数据库系统概念》</li>
<li><a href="https://blog.csdn.net/u010425776/article/details/60968283" target="_blank" rel="external">数据库事务详解</a></li>
<li><a href="https://blog.csdn.net/starlh35/article/details/76445267" target="_blank" rel="external">数据库并发事务存在的问题（脏读、不可重复读、幻读等）</a></li>
<li><a href="http://ihenu.iteye.com/blog/2276576" target="_blank" rel="external">数据库的事务与并发控制</a></li>
<li><a href="http://blog.itpub.net/26736162/viewspace-2144050" target="_blank" rel="external">MySQL中事务的分类</a></li>
<li><a href="https://www.cnblogs.com/wajika/p/6680200.html" target="_blank" rel="external">数据库隔离级别及其实现原理</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：数据库事务在数据库操作中是十分重要的，因为它要么全部执行，要么全部执行，这样才能保证数据库的数据的完整性与一致性。
    
    </summary>
    
      <category term="数据库" scheme="http://bestlixiang.site/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://bestlixiang.site/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库范式</title>
    <link href="http://bestlixiang.site/2018/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/05/10/数据库/数据库范式/</id>
    <published>2018-05-10T13:13:04.000Z</published>
    <updated>2018-05-10T13:13:22.509Z</updated>
    
    <content type="html"><![CDATA[<p>引：设计好数据库的表的前提就是要满足更高级别数据库的范式，当然级别不是越高越好，但是至少不差！<a id="more"></a></p>
<h1 id="数据库范式的优缺点"><a href="#数据库范式的优缺点" class="headerlink" title="数据库范式的优缺点"></a>数据库范式的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>减少数据冗余</li>
<li>消除异常（插入异常，更新异常，删除异常）</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>查询时要联结多个表，增加了查询的复杂度</li>
<li>查询时需要联结多个表，降低了数据库查询性能</li>
</ol>
<h1 id="什么是范式-NF-Normal-Form"><a href="#什么是范式-NF-Normal-Form" class="headerlink" title="什么是范式(NF Normal Form)"></a>什么是范式(NF Normal Form)</h1><p><strong>范式</strong>是一张数据表的表结构所符合的某种<strong>设计标准</strong>，满足高等级的范式的先决条件是满足低等级范式。</p>
<h1 id="五大范式"><a href="#五大范式" class="headerlink" title="五大范式"></a>五大范式</h1><p>以下范式的基本概念可以参照我的另一篇博文：<a href="http://todorex.com/2018/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" target="_blank" rel="external">关系型数据库的基础概念</a>；具体案例可以参照这篇博文：<a href="http://www.cnblogs.com/CareySon/archive/2010/02/16/1668803.html" target="_blank" rel="external">数据库范式那些事</a></p>
<h2 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h2><ol>
<li>如果一个关系模式R的所有属性都是<strong>不可分</strong>的基本数据项，则R∈1NF</li>
<li>第一范式就是每一个属性都不可再分。不符合第一范式则“不能”称为关系数据库，因为你可以一张表搞定所有，而不用产生关系。</li>
</ol>
<h2 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h2><ol>
<li>若关系模式R∈1NF，并且每一个非主属性都<strong>完全函数</strong>依赖于R的码，则R∈2NF</li>
<li>表中的属性必须完全依赖于全部主键，而不是部分主键。所以只有一个主键的表如果符合第一范式，那一定是第二范式</li>
<li>减少数据容冗余和减少更新异常</li>
</ol>
<h2 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h2><ol>
<li>若关系模式R∈2NF，并且每一个非主属性对于码都<strong>不存在传递函数依赖</strong>，则R∈3NF</li>
<li>消除了非主属性对于码的传递函数依赖</li>
<li>减少数据容冗余和减少常插入异常，更新异常，删除异常</li>
</ol>
<h2 id="巴斯-科德范式（BCNF）"><a href="#巴斯-科德范式（BCNF）" class="headerlink" title="巴斯-科德范式（BCNF）"></a>巴斯-科德范式（BCNF）</h2><ol>
<li>若关系模式R∈3NF，并且每一个主属性对于码都<strong>不存在部分与传递函数依赖</strong>，则R∈BCNF</li>
<li>消除主属性对于码的部分与传递函数依赖，BCNF是在第三范式的基础上的一种特殊情况，既每个表中只有一个候选键。</li>
<li>减少插入异常，更新异常与删除异常</li>
</ol>
<h2 id="第四范式（4NF）"><a href="#第四范式（4NF）" class="headerlink" title="第四范式（4NF）"></a>第四范式（4NF）</h2><ol>
<li>若关系模式R∈1NF，并且只允许的非平凡多值依赖是函数依赖，不允许存在其他非平凡且非函数依赖的多值依赖，则R∈4NF。</li>
<li>平凡的多值依赖属于第四范式</li>
<li>减少数据容冗余和减少常插入异常，更新异常，删除异常</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>数据库设计应用的范式不是越高越好，要看实际情况而定。第三范式已经很大程度上减少了数据冗余，并且减少了造成插入异常，更新异常，和删除异常了。大多数情况应用到第三范式已经足够，在一定情况下第二范式也是可以的。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.zhihu.com/question/24696366" target="_blank" rel="external">解释一下关系数据库的第一第二第三范式</a></li>
<li><a href="http://www.cnblogs.com/CareySon/archive/2010/02/16/1668803.html" target="_blank" rel="external">数据库范式那些事</a></li>
<li><a href="https://blog.csdn.net/legendaryhaha/article/details/80032808" target="_blank" rel="external">数据库中的范式和多值依赖</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：设计好数据库的表的前提就是要满足更高级别数据库的范式，当然级别不是越高越好，但是至少不差！
    
    </summary>
    
      <category term="数据库" scheme="http://bestlixiang.site/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://bestlixiang.site/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>关系型数据库的基础概念</title>
    <link href="http://bestlixiang.site/2018/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://bestlixiang.site/2018/05/10/数据库/关系型数据库的基础概念/</id>
    <published>2018-05-10T12:51:51.000Z</published>
    <updated>2018-05-10T12:52:55.746Z</updated>
    
    <content type="html"><![CDATA[<p>引：在学习或者设计关系型数据库之前，我们都需要先学习关系型数据库的基础概念。<a id="more"></a></p>
<h1 id="数据库关系模型"><a href="#数据库关系模型" class="headerlink" title="数据库关系模型"></a>数据库关系模型</h1><h2 id="数据库结构"><a href="#数据库结构" class="headerlink" title="数据库结构"></a>数据库结构</h2><ol>
<li>关系数据库由<strong>表</strong>的集合构成，每个表有唯一的名字。</li>
<li>在关系模型的术语中，<strong>关系</strong>用来指代表，<strong>元组</strong>用来指代行 ，<strong>属性</strong>用来指代表中的列，<strong>关系实例</strong>用来指代一个关系的特定实例。</li>
<li>对于关系的每个属性，都存在一个允许取值的集合，称为该属性的<strong>域</strong>。</li>
<li>如果<strong>域</strong>中的元素被看做是不可再分的单元，则域是<strong>原子的</strong>。</li>
</ol>
<h2 id="数据库模式"><a href="#数据库模式" class="headerlink" title="数据库模式"></a>数据库模式</h2><ol>
<li><strong>数据库模式</strong>是数据库的逻辑设计，<strong>数据库实例</strong>是给定时刻数据库数据的一个快照。</li>
<li><strong>关系</strong>对应于程序设计语言中变量的定义，<strong>关系模式</strong>对应于程序设计语言中类型的定义，<strong>关系实例</strong>对应于程序设计语言中变量的值。</li>
<li><strong>关系模式</strong>由属性序列及各属性对应的域组成。</li>
</ol>
<h2 id="码"><a href="#码" class="headerlink" title="码"></a>码</h2><ol>
<li><strong>超码</strong>是一个或多个属性的<strong>集合</strong>，这些属性的集合可以使我们在一个关系中唯一地表示一个元组。</li>
<li>如果K是一个超码，那么K的任意超集也是超码，他们的任意真子集都不能称为超码，这样最小的超码称为<strong>候选码</strong>(码),候选码中任何一个属性称为主属性，其它为非主属性。</li>
<li><strong>主码</strong>代表被数据库设计者用来在一个关系汇总区分不同元组的候选码，主码应该选择那些值从不或极少变化的属性。</li>
<li>一个关系模式(r1)可能在它的属性中包含另一个关系模式(r2)的主码，那么这个属性在r1上称做参照r2的<strong>外码</strong>。关系r1被称为外码依赖的<strong>参照关系</strong>，r2被称为外码的<strong>被参照关系</strong>。</li>
</ol>
<h1 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h1><p>若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y<strong>函数依赖</strong>于X，写作 X → Y。</p>
<ol>
<li><p>完全函数依赖</p>
<p> 在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X → Y 不成立，那么我们称 Y 对于 X 完全函数依赖，记作 X F→ Y。（那个F应该写在箭头的正上方）</p>
</li>
<li><p>部分函数依赖</p>
<p> 假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 X  P→ Y。（那个P应该写在箭头的正上方）</p>
</li>
<li><p>传递函数依赖</p>
<p> 在 Y 不包含于 X，且 X 不函数依赖于 Y这个前提下，假如 Z 函数依赖于 Y，且 Y 函数依赖于 X ，那么我们就称 Z 传递函数依赖于 X ，记作 X T→ Z。（那个T应该写在箭头的正上方）</p>
</li>
</ol>
<h1 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h1><p>若在一张表中，在属性集X, Y, 和Z是U的子集，并且Z=U-X-Y，当且仅当表中的记录上当X，Z确定时，属性Y有一组值，这组值仅仅决定于属性X值而与属性Z值无关，<strong>多值依赖</strong>X-&gt;-&gt;Y成立。如果把上面的一组改为一个，那么多值依赖就变成了函数依赖。当然一个值组成的组也是组，所以说，函数依赖是多值依赖的特殊情况。</p>
<ol>
<li><p>平凡的多值依赖</p>
<p> 若X-&gt;-&gt;Y，而Z等于空集，则称X-&gt;-&gt;Y为平凡的多值依赖，属性集合中分为两个真子集，每一个X对应一组Y的取值</p>
</li>
<li><p>非平凡的多值依赖</p>
<p> 若X-&gt;-&gt;Y，而Z不等于空集，则称X-&gt;-&gt;Y为非平凡的多值依赖</p>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《数据库系统概念》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在学习或者设计关系型数据库之前，我们都需要先学习关系型数据库的基础概念。
    
    </summary>
    
      <category term="数据库" scheme="http://bestlixiang.site/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://bestlixiang.site/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL必知必会</title>
    <link href="http://bestlixiang.site/2018/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    <id>http://bestlixiang.site/2018/05/07/数据库/MySQL必知必会/</id>
    <published>2018-05-07T07:46:56.000Z</published>
    <updated>2018-05-07T11:29:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>引:虽然用了这么久的数据库，但是有时候使用起来难免会去查怎么使用，这样下去也不是办法，所以自己就在这里以Mysql为例总结一下经常用到的地方。 <a id="more"></a></p>
<h1 id="基本注意点"><a href="#基本注意点" class="headerlink" title="基本注意点"></a>基本注意点</h1><ol>
<li>SQL关键字使用大写，所有列和表名使用小写</li>
<li>SQL语句由子句构成，一个子句通常由一个关键字和一个数据组成，子句的顺序一般为:<blockquote>
<p>SELECT 数据 FROM 数据 WHERE 数据 GROUP BY 数据 HAVING 数据 ORDER BY 数据 LIMIT 数据</p>
</blockquote>
</li>
<li>通配符搜索的处理一般要比其他搜索所花时间长，不要过度使用通配符，如果要，就应该将通配符放在搜索集合小的搜索上</li>
<li>多数DBMS使 +或||来实现拼接，MYSQL则使 Concat函数来实现</li>
<li>数据库列般称为列，计算字段一般称为字段</li>
<li>MySQL使用的日期格式必须是yyyy-mm-dd</li>
<li>WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤</li>
<li>子查询最常见的使用是在WHERE子句的IN操作符后</li>
<li>在删除或更新表之前先SELECT出来，防止删错</li>
<li>利用外键约束，防止删除与其他表相关联的行</li>
</ol>
<h1 id="MySQL基本使用"><a href="#MySQL基本使用" class="headerlink" title="MySQL基本使用"></a>MySQL基本使用</h1><ol>
<li>MySQL帮助<blockquote>
<p>相关命令 -h/–help</p>
</blockquote>
</li>
<li>MySQL服务启动和关闭<blockquote>
<p>mysql.server start/stop</p>
</blockquote>
</li>
<li><p>MySQL连接</p>
<blockquote>
<p>mysql -u 用户名 -p 密码 -h 主机名 -P 端口  </p>
</blockquote>
<p> （默认用户名为使用者名，主机名默认为localhost，端口默认为3306）    </p>
</li>
<li>退出命令行<blockquote>
<p>quit/exit</p>
</blockquote>
</li>
<li>显示所有数据库<blockquote>
<p>SHOW DATABASES</p>
</blockquote>
</li>
<li>使用数据库<blockquote>
<p>USE 数据库名</p>
</blockquote>
</li>
<li>显示某库下所有的表<blockquote>
<p>SHOW TABLES</p>
</blockquote>
</li>
<li>显示某表下面的列<blockquote>
<p>SHOW COLUMNS FROM 表名 / DISCRIBE 表名</p>
</blockquote>
</li>
<li>显示服务器的状态信息<blockquote>
<p>SHOW STATUS</p>
</blockquote>
</li>
<li>显示创建特定数据库或表的MySQL语句<blockquote>
<p>SHOW CREATE DATABASE 数据库名 / TABLE 表名</p>
</blockquote>
</li>
</ol>
<h1 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h1><ol>
<li><p>用户管理</p>
<blockquote>
<p>USE mysql</p>
<p>SELECT user FROM user</p>
<p>CREATE USER rex IDENTIFIED BY ‘密码’  //创建用户账号</p>
<p>RENAME USER rex TO rex1  // 修改用户名</p>
<p>DROP USER rex  // 删除用户账号</p>
<p>SHOW GRANTS FOR rex  // 显示rex的权限，USAGE ON <em>.</em>表示没有权限</p>
<p>GRANT SELECT ON 数据库/表.* TO rex // 给rex对数据库/表的读权限</p>
<p>REVOKE SELECT ON 数据库/表.* TO rex // 撤销rex对数据库/表的读权限</p>
</blockquote>
</li>
<li><p>更改密码</p>
<blockquote>
<p>SET PASSWORD FOR rex = Password ‘新密码’</p>
<p>SET PASSWORD = Password ‘新密码’  // 修改当前用户的密码</p>
</blockquote>
</li>
</ol>
<h1 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h1><ol>
<li>数据库备份<ul>
<li>使用mysqldump</li>
<li>使用mysqlhotcopy</li>
<li>使用BACKUP TABLE或SELECT INTO OUTFILE</li>
</ul>
</li>
<li><p>维护数据库</p>
<blockquote>
<p>ANALYZE/CHECK TABLE 表名 // 检查表键是否正确</p>
<p>OPTIMIZE TABLE 表名 // 回收所用空间  </p>
</blockquote>
</li>
<li>查看日志文件<ul>
<li>错误日志：通常为/data/hostname.err，可通过–log-error修改文件</li>
<li>查询日志：通常为/data/hostname.log，可通过–log修改文件   </li>
<li>二进制文件：通常为/data/hostname-bin</li>
<li>缓慢查询日志：通常为/data/hostname-slow.log，可通过hostname-slow- queries修改文件  </li>
</ul>
</li>
</ol>
<h1 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h1><ol>
<li>创建表<blockquote>
<p>CREATE IF NOT EXISTS TABLE 表名(id int NOT NULL AUTO_INCREMENT          ,…, PRIMARY KEY(id)) ENGINE=InnoDB</p>
</blockquote>
</li>
<li><p>更新表</p>
<blockquote>
<p>ALTER TABLE 表名 ADD 类型 // 增加列</p>
<p>ALTER TABLE  表1 ADD CONSTRAINT fk<em>表1</em>表2 FOREIGN KEY(表2id)  REFERENCES  表2(表2id)</p>
</blockquote>
</li>
<li><p>删除表</p>
<blockquote>
<p>DROP TABLE 表名</p>
</blockquote>
</li>
<li>重命名表<blockquote>
<p>RENAME TABLE 表名1 TO 表名2</p>
</blockquote>
</li>
</ol>
<h1 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h1><h2 id="基本查询数据"><a href="#基本查询数据" class="headerlink" title="基本查询数据"></a>基本查询数据</h2><ol>
<li>检索单个列<blockquote>
<p>SELECT prod_name FROM product</p>
</blockquote>
</li>
<li>检索多个列<blockquote>
<p>SELECT prod_id, prod_name FROM product</p>
</blockquote>
</li>
<li>检索所有列<blockquote>
<p>SELECT * FROM product</p>
</blockquote>
</li>
<li>检索不同的行<blockquote>
<p>SELECT DISTINCT vend_id FROM product</p>
</blockquote>
</li>
<li><p>限制结果的行数为前5条/第二个5条</p>
<blockquote>
<p>SELECT * FROM product LIMIT 5 / LIMIT 5(开始位置，第一行其实第0    行),5(要检索的行数)</p>
<p>SELECT * FROM product LIMIT 5 (偏移量) OFFSET 5 (开始位置)      </p>
</blockquote>
</li>
</ol>
<h2 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h2><ol>
<li>按一个列排序<blockquote>
<p>SELECT prod_name FROM product ORDER BY prod_name</p>
</blockquote>
</li>
<li>按多个列排序(先按prod_price排序，如果相同，则比较prod_name)<blockquote>
<p>SELECT prod_id, prod_price, prod_name FROM product ORDER BY prod_price, prod_name</p>
</blockquote>
</li>
<li>指定排序方向(默认升序ASC，降序DESC)<blockquote>
<p>SELECT prod_id, prod_price, prod_name FROM product ORDER BY prod_price DESC</p>
</blockquote>
</li>
</ol>
<h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><ol>
<li>WHERE子句过滤<blockquote>
<p>SELECT prod_name, prod_price FROM product WHERE prod_price =<br> 2.50</p>
</blockquote>
</li>
<li><p>WHERE子句操作符</p>
<p>操作符 | 说明<br>—|—<br>= | 等于<br>&lt;&gt; | 不等于<br>!= | 不等于<br>&lt; | 小于<br>&lt;= | 小于等于<br>> | 大于<br>>= | 大于等于<br>BETWEEN… AND | 在指定的两个值之间(mysql包括两端)<br>NOT BETWEEN… AND | 不在指定的两个值之间(mysql不包括两端)      </p>
</li>
<li>空值检查(需要注意null和没有值得区别)<blockquote>
<p>SELECT prod_name FROM products WHERE prod_price IS NULL</p>
</blockquote>
</li>
<li>数据过滤操作符<br> 操作符 | 说明<br> —|—<br> AND | 且（优先级比OR高）<br> OR | 或<br> IN | 在指定范围内，如WHERE id IN  (1002 1003)<br> NOT IN | 不在指定范围内</li>
<li>数据过滤通配符(利用LIKE操作符)<br> 操作符 | 说明<br> —|—<br> % | 表示任意字符出现的任意次数<br> _ | 表示单个字符</li>
<li>用正则表达式进行搜索(正则表达式的使用自行搜索)<blockquote>
<p>SELECT * FROM product WHERE prod_name REGEXP ‘.000’ OR<br> prod_name REGEXP ‘1000|2000’ OR prod_name REGEXP ‘[123]  Ton’</p>
</blockquote>
</li>
</ol>
<h2 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h2><p>计算字符是运行时在SELECT语句内创建的。</p>
<ol>
<li>拼接字段(Concat函数)<blockquote>
<p>SELECT Concat(vend_name,’(‘,vend_country,’)’) FROM vendors</p>
</blockquote>
</li>
<li>使用别名(列名，表名都可以使用，使用关键字AS，也可省略)<blockquote>
<p>SELECT Concat(RTrim(vend_name),’(‘, RTrim(vend_country),’)’)  AS vend_title FROM vendors</p>
</blockquote>
</li>
<li>执行算术计算(加减乘除)<blockquote>
<p>SELECT quantity*item_price AS expanded_price FROM orderitems</p>
</blockquote>
</li>
</ol>
<h2 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h2><ol>
<li>文本处理函数<br>函数 | 说明<br>—|—<br>Left() | 返回串左边的字符<br>Right() | 返回串右边的字符<br>Length() | 返回串的长度<br>Locate() | 找出一个串的子串<br>Lower() | 将串转化为小写<br>Upper() | 将串转化为大写<br>LRrim() | 去掉串左边的空格<br>RTrim() | 去掉串右边的空格<br>Trim() | 去掉串两边的空格<br>SubString() | 返回子串的字符  </li>
<li><p>日期和时间处理函数<br> 函数 | 说明<br> —|—<br> AddDate() | 增加一个日期(天、周等)<br> AddTime() | 增加一个时间(时、分等)<br> CurDate() | 返回当前的日期<br> CurTime() | 返回当前的时间<br> Date() | 返回日期时间的日期部分<br> DateDiff() | 计算两个日期之差<br> Date_Format() | 返回一个格式化的日期或时间串<br> Day() | 返回一个日期的天数部分，类推年月日，时分秒<br> Now() | 返回当前日期和时间  </p>
</li>
<li><p>数值处理函数<br> 函数 | 说明<br> —|—<br> Abs() | 返回一个数的绝对值<br> Cos() | 返回一个角度的余弦，类推正弦<br> Exp() | 返回一个数的指数值<br> Mod() | 返回除数操作的余数<br> Rand() | 返回一个随机数<br> Sqrt() | 返回一个数的平方根</p>
</li>
</ol>
<h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><ol>
<li><p>聚集函数</p>
<p> 函数 | 说明<br> —|—<br> AVG() | 返回某列的平均值<br> COUNT() | 返回某列的行数<br> MAX() | 返回某列的最大值<br> MIN() | 返回某列的最小值<br> SUM() | 返回某列的总和</p>
</li>
</ol>
<h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><ol>
<li>创建分组(先分组后聚集)<blockquote>
<p>SELECT vend_id  COUNT(*) AS num_prods FROM product GROUP BY vend_id</p>
</blockquote>
</li>
<li>过滤分组<blockquote>
<p>SELECT cust_id  COUNT(<em>) AS orders FROM order GROUP BY cust_id HAVING COUNT(</em>)&gt;=2</p>
</blockquote>
</li>
</ol>
<h2 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h2><ol>
<li>利用子查询进行过滤(找出买TNT2的顾客信息)<blockquote>
<p>SELECT cust_name, cust_contact FROM customers WHERE cust_id IN  (SELECT cust_id FROM order WHERE order_num IN (SELECT order_num FROM orderitem WHERE prod_id=’TNT2’))</p>
</blockquote>
</li>
<li>使用计算字段使用子查询(显示顾客的信息和订单量)<blockquote>
<p>SELECT cust_name, cust_state, (SELECT COUNT (*)  FROM order WHERE order.cust_id = customer.cust_id)  AS orders FROM customer</p>
</blockquote>
</li>
</ol>
<h2 id="联结表查询"><a href="#联结表查询" class="headerlink" title="联结表查询"></a>联结表查询</h2><ol>
<li>联结查询(没有WHERE子句会产生笛卡尔积)<blockquote>
<p>SELECT vend_name, prod_name FROM vendor, product, WHERE vendor.vend_id = product.vend_id</p>
</blockquote>
</li>
<li>内部联结(等值联结，首选)<blockquote>
<p>SELECT vend_name, prod_name FROM vendor INNER JOIN product ON vendor.vend_id = product.vend_id</p>
</blockquote>
</li>
<li>多表联结<blockquote>
<p>SELECT vend_name, prod_name, quantity FROM vendor, product, orderitem WHERE product.vend_id = vendor.vend_id AND orderitem.prod_id = product.prod_id</p>
</blockquote>
</li>
<li>自联结(一般联结查询要比子查询快)<blockquote>
<p>ELECT p1.prod_id, p1.prod_name FROM product p1, product p2 WHERE<br> p1.vend_id = p2.vend_id AND p2.prod_id = ‘DTNTR’</p>
</blockquote>
</li>
<li>自然联结(排除一个列多次出现，使每个列只返回一次; 大部分内部联结都是自然联结)</li>
<li>外部联结(联结包括了那些在相关表没有关联行的行，左外联结(左边的所有行必出现)，右外联结(右边的所有行必出现))<blockquote>
<p>SELECT vend_name, prod_name FROM vendor LEFT OUTER JOIN product ON vendor.vend_id = product.vend_id</p>
</blockquote>
</li>
</ol>
<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><ol>
<li>创建组合查询(大部分使用WHERE子句更快，但是对于多个表使用UNION可能更简单，重复行会被自动取消，如果不取消，使用UNION ALL)<blockquote>
<p>SELECT vend_id, prod_id, prod_price FROM product WHERE prod_price &lt;=5 UNION SELECT vend_id, prod_id, prod_price FROM product WHERE vend_id IN  (1001, 1002)</p>
</blockquote>
</li>
</ol>
<h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><ol>
<li>插入一行数据(如果是完整的行，可以不写列名，但是要注意值的顺序)<blockquote>
<p>INSERT INTO customer(列名) VALUES(类名对应的值)        </p>
</blockquote>
</li>
<li>插入多个行<blockquote>
<p>INSERT INTO customer(列名) VALUES(类名对应的值),VALUES(类名对应的值)</p>
</blockquote>
</li>
<li>插入检索出的数据<blockquote>
<p>INSERT INTO customer(列名) SELECT (列名) FROM  表名</p>
</blockquote>
</li>
</ol>
<h1 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h1><ol>
<li>更新表中特定的列(一定不要忘了WHERE子句)<blockquote>
<p>UPDATE customer SET 列名 = 值  WHERE 子句</p>
</blockquote>
</li>
<li>更新多列<blockquote>
<p>UPDATE customer SET 列名 = 值,列名 = 值 WHERE 子句</p>
</blockquote>
</li>
</ol>
<h1 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h1><ol>
<li>删除特定的行<blockquote>
<p>DELETE FROM 表 WHERE 子句   </p>
</blockquote>
</li>
</ol>
<h1 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h1><ol>
<li>创建视图<blockquote>
<p>CREATE VIEW 视图名 AS SELECT 语句</p>
</blockquote>
</li>
<li>查看创建视图的语句<blockquote>
<p>SHOW CREATE VIEW 视图名</p>
</blockquote>
</li>
<li>删除视图<blockquote>
<p>DROP VIEW 视图名</p>
</blockquote>
</li>
<li>更新视图（先删除原视图，再创建新视图）</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《MySQL必知必会》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引:虽然用了这么久的数据库，但是有时候使用起来难免会去查怎么使用，这样下去也不是办法，所以自己就在这里以Mysql为例总结一下经常用到的地方。
    
    </summary>
    
      <category term="数据库" scheme="http://bestlixiang.site/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://bestlixiang.site/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://bestlixiang.site/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>HelloWorld_Shiro Activity</title>
    <link href="http://bestlixiang.site/2018/05/03/HelloWorld/HelloWorld-Shiro-Activity/"/>
    <id>http://bestlixiang.site/2018/05/03/HelloWorld/HelloWorld-Shiro-Activity/</id>
    <published>2018-05-03T06:08:03.000Z</published>
    <updated>2018-05-03T06:09:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：记得去年暑假要弄工作流Activity没有弄出来，这次刚好看到了一个基于Shiro和Activity的考勤项目，就想写一下了！<a id="more"></a></p>
<h1 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h1><ol>
<li>前端模板引擎：Velocity（不做重点讲解，它的页面主要使用的BootStrap的Admin开源框架）</li>
<li>后台：SSM框架</li>
<li>任务调度框架：Quartz</li>
<li>工作流引擎：Activity</li>
<li>权限控制框架：Shiro</li>
</ol>
<h1 id="项目功能"><a href="#项目功能" class="headerlink" title="项目功能"></a>项目功能</h1><ol>
<li>利用Shiro实现登录模块并实现权限控制</li>
<li>实现查看出勤记录</li>
<li>利用Quartz实现定时任务，每天凌晨扫描没有打卡记录的员工并记录</li>
<li>利用Activity实现补签流程</li>
</ol>
<h1 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h1><p><a href="https://github.com/todorex/Shiro_Activity_WorkAttendance" target="_blank" rel="external">HelloWorld_Shiro Activity 之 WorkAttendance考勤项目</a></p>
<h1 id="重点源码说明"><a href="#重点源码说明" class="headerlink" title="重点源码说明"></a>重点源码说明</h1><h2 id="利用Shiro实现登录与权限控制"><a href="#利用Shiro实现登录与权限控制" class="headerlink" title="利用Shiro实现登录与权限控制"></a>利用Shiro实现登录与权限控制</h2><p>我们这里主要利用了Shiro来进行登录验证，我们可以先看看Shiro架构，如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/helloworld/jpg/shiro.jpg" alt="shiro"></p>
<ol>
<li>Subject主要是存储了访问信息</li>
<li>SecurityManager是Shiro的核心，他主要用于协调Shiro内部各种安全组件</li>
<li>Realm用于连接Shiro和客户系统的用户数据的桥梁。一旦Shiro真正需要访问各种安全相关的数据（比如使用用户账户来做用户身份验证以及权限验证）时，他总是通过调用系统配置的各种Realm来读取数据，可以对比为SpringSecurity的Provider。</li>
</ol>
<p>Shrio配置文件主要是WorkAttendance/src/main/resources/spring-shiro.xml，在配置文件中，我们除了配置Realm和SecurityManager，还要配置一个ShiroFilter过滤链，这个过滤链主要配置要拦截或者忽略的路径，可以对比为SpringSecurity的配置类WebSecurityConfigurerAdapter。当然我们也可以使用注解来实现路径权限控制，如: <em>@RequiresPermissions(“attend:attendList”)</em></p>
<p>我们看看登录源代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LoginController的验证登录的方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">checkLogin</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> UnsupportedEncodingException, NoSuchAlgorithmException </span>&#123;</div><div class="line">    String username = request.getParameter(<span class="string">"username"</span>);</div><div class="line">    String pwd = request.getParameter(<span class="string">"password"</span>);</div><div class="line">    <span class="comment">// 组装成Token给Realm使用</span></div><div class="line">    UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username,pwd);</div><div class="line">    <span class="comment">// 等到登录访问信息</span></div><div class="line">    Subject subject = SecurityUtils.getSubject();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 进入Realm进行认证</span></div><div class="line">        subject.login(token);</div><div class="line">        <span class="comment">// 设置session过期时间</span></div><div class="line">        SecurityUtils.getSubject().getSession().setTimeout(<span class="number">1800000</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"login_fail"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">"login_succ"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 自定义的Realm</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserService userService;</div><div class="line"></div><div class="line"><span class="comment">//    授权</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</div><div class="line">        <span class="comment">// PrincipalCollection,可以理解身份上下文</span></div><div class="line">        String username = (String) principalCollection.getPrimaryPrincipal();</div><div class="line">        User user = userService.findUserByUserName(username);</div><div class="line">        SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</div><div class="line">        <span class="keyword">for</span>(Role role :user.getRoleList())&#123;</div><div class="line">            authorizationInfo.addRole(role.getRole());</div><div class="line">            <span class="keyword">for</span>(Permission permission :role.getPermissionList())&#123;</div><div class="line">                authorizationInfo.addStringPermission(permission.getPermission());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> authorizationInfo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//    登入验证</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        <span class="comment">// UsernamePasswordToken封装了用户名和密码</span></div><div class="line">        UsernamePasswordToken usernamePasswordToke = (UsernamePasswordToken)authenticationToken;</div><div class="line">        String username =  usernamePasswordToke.getUsername();</div><div class="line">        User user = userService.findUserByUserName(username);</div><div class="line">        <span class="keyword">if</span>(user==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 会使用自定义的账号密码校验器进行验证，并返回AuthenticationInfo</span></div><div class="line">            AuthenticationInfo info = <span class="keyword">new</span> SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), getName());</div><div class="line">            SecurityUtils.getSubject().getSession().setAttribute(<span class="string">"userInfo"</span>,user);</div><div class="line">            <span class="keyword">return</span> info;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 自定义的密码验证器，配置文件中配置</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCredentialsMatcher</span> <span class="keyword">extends</span> <span class="title">SimpleCredentialsMatcher</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doCredentialsMatch</span><span class="params">(AuthenticationToken authenticationToken, AuthenticationInfo authenticationInfo)</span> </span>&#123;</div><div class="line">        <span class="comment">// 对比用户登入的数据与数据库查询出来的信息</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) authenticationToken;</div><div class="line">            <span class="comment">// 用户登录的密码</span></div><div class="line">            String password = String.valueOf(usernamePasswordToken.getPassword());</div><div class="line">            Object tokenCredentials = MD5Utils.encryptPassword(password);</div><div class="line">            <span class="comment">// getCredentials()和equals都是SimpleCredentialsMatcher自带的方法</span></div><div class="line">            Object acountCredentials = getCredentials(authenticationInfo);</div><div class="line">            <span class="keyword">return</span> equals(tokenCredentials,acountCredentials);</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="利用Quartz实现定时任务"><a href="#利用Quartz实现定时任务" class="headerlink" title="利用Quartz实现定时任务"></a>利用Quartz实现定时任务</h2><p>它的核心元素关系图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/helloworld/jpg/quartz.jpg" alt="quartz"></p>
<p>它的配置文件在WorkAttendance/src/main/resources/spring-job.xml，我们也主要就是配置SchedulerFactory，Trigger和Job。里面关于cronExpression可以使用<a href="http://cron.qqe2.com/" target="_blank" rel="external">在线Cron表达式生成器</a>来确定或者书写。</p>
<p>我们看看定时任务的源代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 其实很简单，因为我们在配置文件中以及配置好要触发的类和方法了</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttendCheckTask</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> AttendService attendService;</div><div class="line">    <span class="comment">// JobMethod</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkAttend</span><span class="params">()</span> </span>&#123;</div><div class="line">        attendService.checkAttend();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="利用Activity实现补签流程"><a href="#利用Activity实现补签流程" class="headerlink" title="利用Activity实现补签流程"></a>利用Activity实现补签流程</h2><p>它的配置文件主要在WorkAttendance/src/main/resources/spring-activity.xml，我们主要就是配置processEngineFactory，processEngineConfiguration（会设置自动建表23张以及要部署的流程资源）以及各个服务类。</p>
<p>关于流程资源我们可以利用IDEA的<strong>actiBPM插件</strong>去画这个流程图，需要注意的是设置好各个ID，因为我们后面需要用到它。</p>
<p>接下来我们看看它的核心代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 开始流程并提交任务</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startReAttendFlow</span><span class="params">(ReAttend reAttend)</span> </span>&#123;</div><div class="line">    <span class="comment">// 从公司组织架构中，查询到此人上级领导人用户名</span></div><div class="line">    <span class="comment">// 这里手动设置</span></div><div class="line">    reAttend.setCurrentHandler(<span class="string">"rex666"</span>);</div><div class="line">    reAttend.setStatus(RE_ATTEND_STATUS_ONGOING);</div><div class="line">    <span class="comment">// 插入数据库补签表(ID自增)</span></div><div class="line">    reAttendMapper.insertSelective(reAttend);</div><div class="line">    <span class="comment">// 将一些需要的参数放入流程中传递，即Variables</span></div><div class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line">    map.put(RE_ATTEND_SIGN, reAttend);</div><div class="line">    <span class="comment">// 后面需要根据流程中的变量名来获取</span></div><div class="line">    map.put(NEXT_HANDLER, reAttend.getCurrentHandler());</div><div class="line">    <span class="comment">// 获得流程实例</span></div><div class="line">    ProcessInstance instance = runtimeService.startProcessInstanceByKey(RE_ATTEND_FLOW_ID, map);</div><div class="line">    <span class="comment">// 获得任务</span></div><div class="line">    Task task = taskService.createTaskQuery().processInstanceId(instance.getId()).singleResult();</div><div class="line">    <span class="comment">// 提交用户补签任务</span></div><div class="line">    taskService.complete(task.getId(), map);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 当前处理人获得需要处理的任务</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;ReAttend&gt; <span class="title">listTasks</span><span class="params">(String userName)</span> </span>&#123;</div><div class="line">    <span class="comment">//转换成页面实体 需要返回的对象</span></div><div class="line">    List&lt;ReAttend&gt; reAttendList = <span class="keyword">new</span> ArrayList&lt;ReAttend&gt;();</div><div class="line">    List&lt;Task&gt; taskList = taskService.createTaskQuery().processVariableValueEquals(userName).list();</div><div class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(taskList)) &#123;</div><div class="line">        <span class="keyword">for</span> (Task task : taskList) &#123;</div><div class="line">            Map&lt;String, Object&gt; variable = taskService.getVariables(task.getId());</div><div class="line">            ReAttend reAttend = (ReAttend) variable.get(RE_ATTEND_SIGN);</div><div class="line">            reAttend.setTaskId(task.getId());</div><div class="line">            reAttendList.add(reAttend);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> reAttendList;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 3.当前处理人处理任务</span></div><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">approve</span><span class="params">(ReAttend reAttend)</span> </span>&#123;</div><div class="line">    <span class="comment">// 需要处理的任务</span></div><div class="line">    Task task = taskService.createTaskQuery().taskId(reAttend.getTaskId()).singleResult();</div><div class="line">    <span class="comment">// 如果同意</span></div><div class="line">    <span class="keyword">if</span> ((<span class="string">""</span> + RE_ATTEND_STATUS_PSSS).equals(reAttend.getApproveFlag())) &#123;</div><div class="line">        Attend attend = <span class="keyword">new</span> Attend();</div><div class="line">        attend.setId(reAttend.getAttendId());</div><div class="line">        attend.setAttendStatus(ATTEND_STATUS_NORMAL);</div><div class="line">        <span class="comment">// 将出勤数据的状态从异常变为正常</span></div><div class="line">        attendMapper.updateByPrimaryKeySelective(attend);</div><div class="line">        <span class="comment">// 审批通过，修改补签数据状态</span></div><div class="line">        reAttend.setStatus(RE_ATTEND_STATUS_PSSS);</div><div class="line">        reAttendMapper.updateByPrimaryKeySelective(reAttend);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="string">""</span> + RE_ATTEND_STATUS_REFUSE.toString()).equals(reAttend.getApproveFlag())) &#123;</div><div class="line">        reAttend.setStatus(RE_ATTEND_STATUS_REFUSE);</div><div class="line">        reAttendMapper.updateByPrimaryKeySelective(reAttend);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 完成任务</span></div><div class="line">    taskService.complete(task.getId());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这个项目关于前端页面前端模板引擎Velocity，SSM架构，Mybatis自动生成插件以及分页方法，这里都不再多说，项目的注释应该算是很全了，认真看就行。</p>
<h1 id="参考与致谢"><a href="#参考与致谢" class="headerlink" title="参考与致谢"></a>参考与致谢</h1><ol>
<li><a href="http://coder520.com/courses/17" target="_blank" rel="external">SSM实战-码码员工考勤系统</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：记得去年暑假要弄工作流Activity没有弄出来，这次刚好看到了一个基于Shiro和Activity的考勤项目，就想写一下了！
    
    </summary>
    
      <category term="HelloWorld" scheme="http://bestlixiang.site/categories/HelloWorld/"/>
    
    
      <category term="SSM" scheme="http://bestlixiang.site/tags/SSM/"/>
    
      <category term="Shiro" scheme="http://bestlixiang.site/tags/Shiro/"/>
    
      <category term="Activity" scheme="http://bestlixiang.site/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>HelloWorld_SpringBoot Angular</title>
    <link href="http://bestlixiang.site/2018/04/25/HelloWorld/HelloWorld-SpringBoot-Angular/"/>
    <id>http://bestlixiang.site/2018/04/25/HelloWorld/HelloWorld-SpringBoot-Angular/</id>
    <published>2018-04-25T11:31:14.000Z</published>
    <updated>2018-04-25T11:32:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：前段时间写了个前后台不分离的<a href="http://todorex.com/2018/04/17/HelloWorld/HelloWorld-SSMLogin/" target="_blank" rel="external">SSMLogin</a>，大家可能会觉得前后台不分离太low，所以这次我们使用SpringBoot+Angular搭建了一个利用Token来进行身份验证的前后台分离登录Demo项目。<a id="more"></a></p>
<h1 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h1><p><a href="https://github.com/todorex/SpringBoot_Angular_HeroesLogin/" target="_blank" rel="external">SpringBoot+Angular</a></p>
<h1 id="Angular前端"><a href="#Angular前端" class="headerlink" title="Angular前端"></a>Angular前端</h1><p>本文前端基于Angular官方样例Tour of Heroes，请先到<a href="https://angular.io/tutorial" target="_blank" rel="external">官网下载</a>，也可以拷贝自己的项目源码（不过最好还是一步步来，先去官网下载源码），这次前端不是主要讲解的地方，所以官网源码部分就不说了，自己去看。我只说增加的核心部分。</p>
<h2 id="login组件"><a href="#login组件" class="headerlink" title="login组件"></a>login组件</h2><p>下面是登录的ts代码：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> LoginComponent <span class="keyword">implements</span> OnInit &#123;</div><div class="line">  <span class="comment">// 用来接收后台的数据</span></div><div class="line">  model: <span class="built_in">any</span> = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="comment">//注入依赖对象</span></div><div class="line">  <span class="keyword">constructor</span>(<span class="params"></span></div><div class="line">    <span class="keyword">private</span> router: Router,</div><div class="line">    <span class="keyword">private</span> authenticationService: AuthenticationService,</div><div class="line">  ) &#123; &#125;</div><div class="line"></div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="comment">// 重置登录状态</span></div><div class="line">    <span class="keyword">this</span>.authenticationService.logout();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  login() &#123;</div><div class="line">    <span class="comment">// 利用authenticationService获取对象</span></div><div class="line">    <span class="keyword">this</span>.authenticationService.login(<span class="keyword">this</span>.model.username, <span class="keyword">this</span>.model.password).subscribe(</div><div class="line">      <span class="function"><span class="params">result</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span> (result) &#123;</div><div class="line">          <span class="comment">// 登录成功，调制路由</span></div><div class="line">          <span class="keyword">this</span>.router.navigate([<span class="string">'dashboard'</span>]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">this</span>.log(<span class="string">'Username or Password is incorrect'</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="AuthenticationService服务"><a href="#AuthenticationService服务" class="headerlink" title="AuthenticationService服务"></a>AuthenticationService服务</h2><p>看看它的代码：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// http头，使用json传递数据</span></div><div class="line"><span class="keyword">const</span> httpOptions = &#123;</div><div class="line">  headers: <span class="keyword">new</span> HttpHeaders(&#123;<span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>&#125;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@Injectable</span>()</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> AuthenticationService &#123;</div><div class="line">  <span class="comment">// 认证的url</span></div><div class="line">  <span class="keyword">private</span> url: <span class="built_in">string</span> = <span class="string">`<span class="subst">$&#123;environment.apiURL&#125;</span>/auth`</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>) &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  login(username: <span class="built_in">string</span>, password: <span class="built_in">string</span>): Observable&lt;<span class="built_in">boolean</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.post&lt;<span class="built_in">any</span>&gt;(<span class="keyword">this</span>.url,<span class="built_in">JSON</span>.stringify(&#123;username: username, password: password&#125;),httpOptions).pipe(</div><div class="line">      tap(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</div><div class="line">        <span class="comment">// 获得token认证</span></div><div class="line">        <span class="keyword">let</span> token = response.token;</div><div class="line">        <span class="keyword">if</span> (token) &#123;</div><div class="line">          <span class="comment">// 存储token到浏览器localStorage中，以后每次都带着它去请求数据</span></div><div class="line">          localStorage.setItem(<span class="string">'currentUser'</span>,token);</div><div class="line">        &#125;</div><div class="line">      &#125;),</div><div class="line">      catchError(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.error(err);</div><div class="line">        <span class="keyword">return</span> of (<span class="literal">false</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">      )</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 从localStorage获得token</span></div><div class="line">  getToken(): <span class="built_in">String</span> &#123;</div><div class="line">    <span class="keyword">return</span> localStorage.getItem(<span class="string">'currentUser'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  logout(): <span class="built_in">void</span> &#123;</div><div class="line">    <span class="comment">// 清空token，那么没有Token也就不能刷新页面了</span></div><div class="line">    localStorage.removeItem(<span class="string">'currentUser'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  isLoggedIn(): <span class="built_in">boolean</span> &#123;</div><div class="line">    <span class="keyword">var</span> token: <span class="built_in">String</span> = <span class="keyword">this</span>.getToken();</div><div class="line">    <span class="keyword">return</span> token &amp;&amp; token.length &gt; <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="AuthenticationInterceptor拦截器"><a href="#AuthenticationInterceptor拦截器" class="headerlink" title="AuthenticationInterceptor拦截器"></a>AuthenticationInterceptor拦截器</h1><p>有了这个拦截器，以后所有的请求都过经过这里，看看它的代码：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Injectable</span>()</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> AuthenticationInterceptor <span class="keyword">implements</span> HttpInterceptor &#123;</div><div class="line"></div><div class="line">  <span class="comment">// next 相当于Java Filter 的chain</span></div><div class="line">  intercept(req: HttpRequest&lt;<span class="built_in">any</span>&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;<span class="built_in">any</span>&gt;&gt; &#123;</div><div class="line">    <span class="keyword">const</span> idToken = localStorage.getItem(<span class="string">'currentUser'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (idToken) &#123;</div><div class="line">      <span class="comment">// 将原来的请求加上token包装成新的请求发送</span></div><div class="line">      <span class="keyword">const</span> cloned = req.clone(&#123;</div><div class="line">        headers: req.headers.set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + idToken)</div><div class="line">      &#125;);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> next.handle(cloned);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> next.handle(req);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="CanActivateAuthGuard保卫"><a href="#CanActivateAuthGuard保卫" class="headerlink" title="CanActivateAuthGuard保卫"></a>CanActivateAuthGuard保卫</h2><p>有了CanActivateAuthGuard就能够防止未登录用户访问其他页面，看看它的代码：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Injectable</span>()</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> CanActivateAuthGuard <span class="keyword">implements</span> CanActivate &#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(<span class="params"></span></div><div class="line">    <span class="keyword">public</span> router: Router,</div><div class="line">    <span class="keyword">private</span> authService: AuthenticationService</div><div class="line">  ) &#123;&#125;</div><div class="line"></div><div class="line">  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.authService.isLoggedIn()) &#123;</div><div class="line">      <span class="comment">// 可以通过</span></div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 不能通过，跳转到登录页面</span></div><div class="line">    <span class="keyword">this</span>.router.navigate([<span class="string">'/login'</span>]);</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Springboot后台"><a href="#Springboot后台" class="headerlink" title="Springboot后台"></a>Springboot后台</h1><p>我们首先要对SpringBoot的项目结构有个熟悉的认识，如果不知道的可以先稍微了解一下他，他太棒了。这次开发也是上帝模式。</p>
<h2 id="SpringSecurity权限控制"><a href="#SpringSecurity权限控制" class="headerlink" title="SpringSecurity权限控制"></a>SpringSecurity权限控制</h2><p>首先我们要对前台的请求进行认证，利用配置文件设置一些值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># 控制跨域访问</div><div class="line">cors:</div><div class="line">  allowedOrigins: &quot;*&quot;</div><div class="line">  allowedMethods: GET,POST,DELETE,PUT,OPTIONS</div><div class="line">  allowedHeaders: Origin,X-Requested-With,Content-Type,Accept,Accept-Encoding,Accept-Language,Host,Referer,Connection,User-Agent,Authorization</div><div class="line"></div><div class="line"># token配置</div><div class="line">jwt:</div><div class="line">  header: Authorization</div><div class="line">  secret: mySecret</div><div class="line">  expiration: 7200</div><div class="line">  issuer: IATA</div><div class="line">  authenticationPath: /auth</div></pre></td></tr></table></figure></p>
<h3 id="SpringSecurity配置类"><a href="#SpringSecurity配置类" class="headerlink" title="SpringSecurity配置类"></a>SpringSecurity配置类</h3><p>在com.todorex.config.WebSecurityConfig类中，在这个类中，我们主要是配置认证路径、跨域访问以及过滤器等设置。</p>
<h3 id="SpringSecurity自定义过滤器"><a href="#SpringSecurity自定义过滤器" class="headerlink" title="SpringSecurity自定义过滤器"></a>SpringSecurity自定义过滤器</h3><p>在com.todorex.config.AuthenticationTokenFilter类中，主要是验证token，但不重新计算token。</p>
<h3 id="token生成方法"><a href="#token生成方法" class="headerlink" title="token生成方法"></a>token生成方法</h3><p>在com.todorex.util.JwtTokenUtil类中，主要有生成token以及验证token的方法。</p>
<h2 id="Contoller"><a href="#Contoller" class="headerlink" title="Contoller"></a>Contoller</h2><p>主要是控制处理URL，其中比较重要的就是com.todorex.controller.AuthenticationController类，它是用来进行权限认证的，我们看看它的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(produces = MediaType.APPLICATION_JSON_VALUE)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationController</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</div><div class="line"></div><div class="line">    <span class="comment">// 请求路径(/auth)</span></div><div class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"$&#123;jwt.authenticationPath&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> AuthenticationResponse <span class="title">login</span><span class="params">(@RequestBody AuthenticationRequest request)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        <span class="comment">// 对包装过后的UsernamePasswordAuthenticationToken精心再包装成Authentication</span></div><div class="line">        <span class="keyword">final</span> Authentication authentication = authenticationManager.authenticate(<span class="keyword">new</span> UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword()));</div><div class="line">        <span class="comment">// 将该认证添加到上下文中（避免多次验证）</span></div><div class="line">        <span class="comment">// SecurityContextHolder用于存储安全上下文（security context）的信息</span></div><div class="line">        SecurityContextHolder.getContext().setAuthentication(authentication);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">final</span> UserDetails userDetails = userDetailsService.loadUserByUsername(request.getUsername());</div><div class="line">        <span class="comment">// 实际应用中，生成token时可能会用到更多的参数</span></div><div class="line">        <span class="keyword">final</span> String token = jwtTokenUtil.generate(userDetails.getUsername());</div><div class="line">        <span class="comment">// 返回Token</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AuthenticationResponse(token);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其他都是普通的Controller，但是对于URL的设计我们需要注意，我们主要是用Restful风格的URL，这种风格是怎么样的呢？我们可以参考下面的博文：<a href="https://blog.csdn.net/chenxiaochan/article/details/73716617" target="_blank" rel="external">【Restful】三分钟彻底了解Restful最佳实践</a>。</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>主要是处理业务的，这里我们需要注意的这个类：com.todorex.service.UserDetailsServiceImpl，我们需要实现UserDetailsService接口，因为SpringSecurity方法会用到，看看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserRepository userRepository;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</div><div class="line">        User user = userRepository.findByUsername(s);</div><div class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(String.format(<span class="string">"No user found with username '%s'."</span>, s));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> create(user);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 包装成SpringSecurity需要的User</div><div class="line">     * <span class="doctag">@param</span> user</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> org.springframework.security.core.userdetails.<span class="function">User <span class="title">create</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> org.springframework.security.core.userdetails.User(user.getUsername(), user.getPassword(), mapToGrantedAuthorities(user.getAuthorities()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 包装权限</div><div class="line">     * <span class="doctag">@param</span> authorities</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;GrantedAuthority&gt; <span class="title">mapToGrantedAuthorities</span><span class="params">(List&lt;Authority&gt; authorities)</span> </span>&#123;</div><div class="line">        <span class="comment">// Java8语法</span></div><div class="line">        <span class="keyword">return</span> authorities.stream()</div><div class="line">                .map(authority -&gt; <span class="keyword">new</span> SimpleGrantedAuthority(authority.getName().name()))</div><div class="line">                .collect(Collectors.toList());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h2><p>这里我们使用的JPA，它内部实现是Hibernate，我们只要先定义Entity再定义Dao类就可以了。</p>
<h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>Entity定义之后可以根据实体自动建表（可在配置文件中配置），如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># jpa配置</div><div class="line">  jpa:</div><div class="line">    database: MYSQL</div><div class="line">    show-sql: true</div><div class="line">    hibernate:</div><div class="line">    # 表不存在就自动建表</div><div class="line">      ddl-auto: create</div></pre></td></tr></table></figure></p>
<h3 id="Dao-1"><a href="#Dao-1" class="headerlink" title="Dao"></a>Dao</h3><p>Dao接口只要继承JpaRepository<t, id="">就会有很多内置方法，如果要自己写SQL也可以参照com.todorex.HeroRepository的写法。</t,></p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>我们可以先定义总的接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootTestAbstract</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后每个要测试的类继承他就可以了，避免了重复配置，IDEA还有很多技巧，自己可以去baidu、google，这里也举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTest</span> <span class="keyword">extends</span> <span class="title">SpringBootTestAbstract</span></span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    ApplicationContext applicationContext;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    DataSourceProperties dataSourceProperties;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// 获取配置的数据源</span></div><div class="line">        DataSource dataSource = applicationContext.getBean(DataSource.class);</div><div class="line">        <span class="comment">// 查看配置数据源信息</span></div><div class="line">        System.out.println(dataSource);</div><div class="line">        System.out.println(dataSource.getClass().getName());</div><div class="line">        System.out.println(dataSourceProperties);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>SpringBoot默认使用logback作为日志框架，我们可以做如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 日志配置</div><div class="line">logging:</div><div class="line">  level:</div><div class="line">    # 配置包以及输出等级</div><div class="line">    com.todorex: debug</div><div class="line">  pattern:</div><div class="line">    console: &quot;%d - %msg%n&quot;</div><div class="line">  path: /var/localLog/</div><div class="line">  file: /var/localLog/springbootdemo.log</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://blog.51cto.com/7308310/2072364" target="_blank" rel="external">Angular 5集成Spring Boot,Spring Security,JWT和CORS</a></li>
<li><a href="https://angular.io/tutorial" target="_blank" rel="external">Angular_Heroes教程</a></li>
<li><a href="http://todorex.com/2018/04/25/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98SpringSecurity-%E4%B8%80-%E8%AF%B7%E6%B1%82%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/" target="_blank" rel="external">揭秘SpringSecurity(一)_请求认证过程</a></li>
<li><a href="http://todorex.com/2018/04/21/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98SpringBoot-%E4%B8%80-SpringBoot%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/" target="_blank" rel="external">揭秘SpringBoot(一)_SpringBoot运行原理</a></li>
<li><a href="https://blog.csdn.net/chenxiaochan/article/details/73716617" target="_blank" rel="external">【Restful】三分钟彻底了解Restful最佳实践</a></li>
<li><a href="https://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="external">什么是 JWT – JSON WEB TOKEN</a></li>
<li><a href="https://blog.csdn.net/cabbges/article/details/53378516" target="_blank" rel="external">ajax 跨域 CROS</a></li>
<li><a href="https://blog.csdn.net/inke88/article/details/75007649" target="_blank" rel="external">Spring Boot 日志配置(超详细)</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前段时间写了个前后台不分离的&lt;a href=&quot;http://todorex.com/2018/04/17/HelloWorld/HelloWorld-SSMLogin/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SSMLogin&lt;/a&gt;，大家可能会觉得前后台不分离太low，所以这次我们使用SpringBoot+Angular搭建了一个利用Token来进行身份验证的前后台分离登录Demo项目。
    
    </summary>
    
      <category term="HelloWorld" scheme="http://bestlixiang.site/categories/HelloWorld/"/>
    
    
      <category term="SpringBoot" scheme="http://bestlixiang.site/tags/SpringBoot/"/>
    
      <category term="SpringSecurity" scheme="http://bestlixiang.site/tags/SpringSecurity/"/>
    
      <category term="JWT" scheme="http://bestlixiang.site/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>揭秘SpringSecurity(一)_请求认证过程</title>
    <link href="http://bestlixiang.site/2018/04/25/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98SpringSecurity-%E4%B8%80-%E8%AF%B7%E6%B1%82%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/"/>
    <id>http://bestlixiang.site/2018/04/25/深入SSM/揭秘SpringSecurity-一-请求认证过程/</id>
    <published>2018-04-25T07:39:06.000Z</published>
    <updated>2018-04-25T11:41:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：有了Spring作为基础，Spring家族的很多框架都显得那么棒，尤其是Springboot的出现，简化了配置，家族框架就显得更棒了，我们这次分析一下其中的SpringSecurity，我们会由请求认证过程，来分析其中的各个组件！<a id="more"></a></p>
<h1 id="一次认证过程"><a href="#一次认证过程" class="headerlink" title="一次认证过程"></a>一次认证过程</h1><p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/springSecurity.png" alt="SpringSecurity"></p>
<p>大家可以找到一个工程，这里也可以看看我的<a href="https://github.com/todorex/SpringBoot_Angular_HeroesLogin" target="_blank" rel="external">SpringBoot+Angular工程</a>debug验证我画的流程图。</p>
<h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>在最开始debug的过程中我们会发现pring Security使用了springSecurityFillterChian作为了安全过滤的入口，我只介绍几个比较常用的过滤器。</p>
<h3 id="SecurityContextPersistenceFilter"><a href="#SecurityContextPersistenceFilter" class="headerlink" title="SecurityContextPersistenceFilter"></a>SecurityContextPersistenceFilter</h3><p>两个主要职责：</p>
<ol>
<li>请求来临时，创建SecurityContext安全上下文信息</li>
<li>请求结束时清空SecurityContextHolder（可获得当前操作的用户是谁，该用户是否已经被认证，他拥有哪些角色权限等信息）。</li>
</ol>
<p>我们看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityContextPersistenceFilter</span> <span class="keyword">extends</span> <span class="title">GenericFilterBean</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String FILTER_APPLIED = <span class="string">"__spring_security_scpf_applied"</span>;</div><div class="line">    <span class="comment">// 安全上下文存储的仓库</span></div><div class="line">    <span class="keyword">private</span> SecurityContextRepository repo;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityContextPersistenceFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// HttpSessionSecurityContextRepository是SecurityContextRepository接口的一个实现类</span></div><div class="line">        <span class="comment">// 使用HttpSession来存储SecurityContext</span></div><div class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> HttpSessionSecurityContextRepository());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">        HttpServletRequest request = (HttpServletRequest)req;</div><div class="line">        HttpServletResponse response = (HttpServletResponse)res;</div><div class="line">        <span class="keyword">if</span>(request.getAttribute(<span class="string">"__spring_security_scpf_applied"</span>) != <span class="keyword">null</span>) &#123;</div><div class="line">            chain.doFilter(request, response);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">boolean</span> debug = <span class="keyword">this</span>.logger.isDebugEnabled();</div><div class="line">            request.setAttribute(<span class="string">"__spring_security_scpf_applied"</span>, Boolean.TRUE);</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.forceEagerSessionCreation) &#123;</div><div class="line">                HttpSession session = request.getSession();</div><div class="line">                <span class="keyword">if</span>(debug &amp;&amp; session.isNew()) &#123;</div><div class="line">                    <span class="keyword">this</span>.logger.debug(<span class="string">"Eagerly created session: "</span> + session.getId());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 包装request，response</span></div><div class="line">            HttpRequestResponseHolder holder = <span class="keyword">new</span> HttpRequestResponseHolder(request, response);</div><div class="line">            <span class="comment">// 从Session中获取安全上下文信息</span></div><div class="line">            SecurityContext contextBeforeChainExecution = <span class="keyword">this</span>.repo.loadContext(holder);</div><div class="line">            <span class="keyword">boolean</span> var13 = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                var13 = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">// 请求开始时，设置安全上下文信息，这样就避免了用户直接从Session中获取安全上下文信息</span></div><div class="line">                SecurityContextHolder.setContext(contextBeforeChainExecution);</div><div class="line">                chain.doFilter(holder.getRequest(), holder.getResponse());</div><div class="line">                var13 = <span class="keyword">false</span>;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">if</span>(var13) &#123;</div><div class="line">                    SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext();\</div><div class="line">                    <span class="comment">//请求结束后，清空安全上下文信息</span></div><div class="line">                    SecurityContextHolder.clearContext();</div><div class="line">                    <span class="keyword">this</span>.repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());</div><div class="line">                    request.removeAttribute(<span class="string">"__spring_security_scpf_applied"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="UsernamePasswordAuthenticationFilter"><a href="#UsernamePasswordAuthenticationFilter" class="headerlink" title="UsernamePasswordAuthenticationFilter"></a>UsernamePasswordAuthenticationFilter</h2><p>这个可能是我们遇见最多的过滤器了，一个最直观的业务场景便是允许用户在表单中输入用户名和密码进行登录，而这背后用到的就是UsernamePasswordAuthenticationFilter。这个过滤器也可以见证我们之前画的时序图，我们看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.postOnly &amp;&amp; !request.getMethod().equals(<span class="string">"POST"</span>)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(<span class="string">"Authentication method not supported: "</span> + request.getMethod());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 获取用户名，密码</span></div><div class="line">            String username = <span class="keyword">this</span>.obtainUsername(request);</div><div class="line">            String password = <span class="keyword">this</span>.obtainPassword(request);</div><div class="line">            <span class="keyword">if</span>(username == <span class="keyword">null</span>) &#123;</div><div class="line">                username = <span class="string">""</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(password == <span class="keyword">null</span>) &#123;</div><div class="line">                password = <span class="string">""</span>;</div><div class="line">            &#125;</div><div class="line">            username = username.trim();</div><div class="line">            <span class="comment">// 生成Authentication，下面会介绍</span></div><div class="line">            UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(username, password);</div><div class="line">            <span class="keyword">this</span>.setDetails(request, authRequest);</div><div class="line">            <span class="comment">// 讲Authentication交给AuthenticationManager认证</span></div><div class="line">            <span class="keyword">return</span>  <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="自定义Filter"><a href="#自定义Filter" class="headerlink" title="自定义Filter"></a>自定义Filter</h3><p>当自带的Filter不能满足你的要求时（例如我们要先对token进行认证），我们可以自定义过滤器，只要继承各种Filter接口，并实现其中方法即可。</p>
<h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p>先看他的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authentication</span> <span class="keyword">extends</span> <span class="title">Principal</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="comment">// 权限信息列表</span></div><div class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</div><div class="line">    <span class="comment">// 密码信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全</span></div><div class="line">    <span class="function">Object <span class="title">getCredentials</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 细节信息，它记录了访问者的ip地址和sessionId的值。</span></div><div class="line">    <span class="function">Object <span class="title">getDetails</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 最重要的身份信息，大部分情况下返回的是UserDetails接口的实现类</span></div><div class="line">    <span class="function">Object <span class="title">getPrincipal</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 是否已认证</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAuthenticated</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> var1)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从它的源码可以知道它拥有的权限信息列表，密码，用户细节信息，用户身份信息，认证信息。</p>
<p>它有很多实现类，比如流程图中的<strong>UsernamePasswordAuthenticationToken</strong>，以及AnonymousAuthenticationToken等。</p>
<h2 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h2><p>先看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationManager</span> </span>&#123;</div><div class="line">    <span class="comment">// 主要是认证传进来的Authentication</span></div><div class="line">    <span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication var1)</span> <span class="keyword">throws</span> AuthenticationException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它最有用的实现类就是流程图中的ProviderManager，我们可以看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderManager</span> <span class="keyword">implements</span> <span class="title">AuthenticationManager</span>, <span class="title">MessageSourceAware</span>, <span class="title">InitializingBean</span> </span>&#123;</div><div class="line">    <span class="comment">// 维护一个AuthenticationProvider列表</span></div><div class="line">    <span class="keyword">private</span> List&lt;AuthenticationProvider&gt; providers;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> eraseCredentialsAfterAuthentication;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</div><div class="line">        AuthenticationException lastException = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 要从新返回的Authentication</span></div><div class="line">        Authentication result = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 遍历AuthenticationProvider列表</span></div><div class="line">        Iterator var6 = <span class="keyword">this</span>.getProviders().iterator();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(var6.hasNext()) &#123;</div><div class="line">            AuthenticationProvider provider = (AuthenticationProvider)var6.next();</div><div class="line">            <span class="keyword">if</span>(provider.supports(toTest)) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// 对传进来的authentication进行认证</span></div><div class="line">                    result = provider.authenticate(authentication);</div><div class="line">                    <span class="keyword">if</span>(result != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">// 将属性复制给result</span></div><div class="line">                        <span class="keyword">this</span>.copyDetails(authentication, result);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (AccountStatusException var11) &#123;</div><div class="line">                    ...</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(result == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 如果列表里的Provider都不支持该authentication，则到父类查找</span></div><div class="line">                result = <span class="keyword">this</span>.parent.authenticate(authentication);</div><div class="line">            &#125; <span class="keyword">catch</span> (ProviderNotFoundException var9) &#123;</div><div class="line">                ;</div><div class="line">            &#125; <span class="keyword">catch</span> (AuthenticationException var10) &#123;</div><div class="line">                lastException = var10;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(result != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.eraseCredentialsAfterAuthentication &amp;&amp; result <span class="keyword">instanceof</span> CredentialsContainer) &#123;</div><div class="line">                <span class="comment">// 擦除密码信息</span></div><div class="line">                ((CredentialsContainer)result).eraseCredentials();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">this</span>.eventPublisher.publishAuthenticationSuccess(result);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="AuthenticationProvider"><a href="#AuthenticationProvider" class="headerlink" title="AuthenticationProvider"></a>AuthenticationProvider</h2><p>看看它的源码先：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationProvider</span> </span>&#123;</div><div class="line">    <span class="comment">// 认证</span></div><div class="line">    <span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication var1)</span> <span class="keyword">throws</span> AuthenticationException</span>;</div><div class="line">    <span class="comment">// 判断是否支持传进来的Authentication</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们接着看看它最常用的一个实现DaoAuthenticationProvider。也看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoAuthenticationProvider</span> <span class="keyword">extends</span> <span class="title">AbstractUserDetailsAuthenticationProvider</span> </span>&#123;</div><div class="line">    <span class="comment">// 密码加密器</span></div><div class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</div><div class="line">    <span class="comment">// 加载用户的UserDetailsService</span></div><div class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(authentication.getCredentials() == <span class="keyword">null</span>) &#123;</div><div class="line">            ...</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 验证密码</span></div><div class="line">            String presentedPassword = authentication.getCredentials().toString();</div><div class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 最核心的方法</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title">retrieveUser</span><span class="params">(String username, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        <span class="keyword">this</span>.prepareTimingAttackProtection();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 获得UserDetails</span></div><div class="line">            UserDetails loadedUser = <span class="keyword">this</span>.getUserDetailsService().loadUserByUsername(username);</div><div class="line">            <span class="keyword">if</span>(loadedUser == <span class="keyword">null</span>) &#123;</div><div class="line">                ...</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> loadedUser;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (UsernameNotFoundException var4) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h2><p>先看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetailsService</span> </span>&#123;</div><div class="line">    <span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String var1)</span> <span class="keyword">throws</span> UsernameNotFoundException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个接口的实现类有JdbcDaoImpl（负责从数据库加载用户）等，当然我们也可以自己实现这个接口。只要实现loadUserByUsername方法即可。</p>
<p>再看看<strong>UserDetails</strong>是个什么东西？</p>
<p>看看它源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="comment">// 权限属性</span></div><div class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</div><div class="line">    <span class="comment">// 密码属性</span></div><div class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 用户名属性</span></div><div class="line">    <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 账户是否过期</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 账户是否被锁</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 密码是否过期</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 是否启用</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它代表了最详细的用户信息，这个接口涵盖了一些必要的用户信息字段，具体的实现类对它进行了扩展。这里我们普通的User类也可以实现这个接口。</p>
<h1 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h1><p>通过我们上面对核心组件的解读再结合流程流就应该可以理解SpringSecurity的请求认证过程。但是不可能我们对所有的路径都需要认证，或者说它总要提供一个东西让我们配置它的细节，那就是WebSecurityConfigurerAdapter接口，它主要使用了适配器模式。我们主要看看我们需要覆盖它的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfigurerAdapter</span> <span class="keyword">implements</span> <span class="title">WebSecurityConfigurer</span>&lt;<span class="title">WebSecurity</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 配置AuthenticationManagerBuilder</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">this</span>.disableLocalConfigureAuthenticationBldr = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 配置WebSecurity</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 配置HttpSecurity</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ((HttpSecurity)((HttpSecurity)((AuthorizedUrl)http.authorizeRequests().anyRequest()).authenticated().and()).formLogin().and()).httpBasic();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="配置AuthenticationManagerBuilder"><a href="#配置AuthenticationManagerBuilder" class="headerlink" title="配置AuthenticationManagerBuilder"></a>配置AuthenticationManagerBuilder</h2><p>我们可以看看它的使用案例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        auth</div><div class="line">            .inMemoryAuthentication()</div><div class="line">            .withUser(<span class="string">"admin"</span>).password(<span class="string">"admin"</span>).roles(<span class="string">"USER"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>想要在WebSecurityConfigurerAdapter中进行认证相关的配置，可以使用configure(AuthenticationManagerBuilder auth)暴露一个AuthenticationManager的建造器：AuthenticationManagerBuilder 。如上所示，我们便完成了内存中用户的配置，也可以在这里讲自己定义的UserDetailService注入。</p>
<h2 id="配置WebSecurity"><a href="#配置WebSecurity" class="headerlink" title="配置WebSecurity"></a>配置WebSecurity</h2><p>我们可以看看它的使用案例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        http</div><div class="line">            <span class="comment">// 配置路径拦截，表明路径访问所对应的权限，角色，认证信息。</span></div><div class="line">            .authorizeRequests()</div><div class="line">                .antMatchers(<span class="string">"/resources/**"</span>, <span class="string">"/signup"</span>, <span class="string">"/about"</span>).permitAll()</div><div class="line">                .antMatchers(<span class="string">"/admin/**"</span>).hasRole(<span class="string">"ADMIN"</span>)</div><div class="line">                .antMatchers(<span class="string">"/db/**"</span>).access(<span class="string">"hasRole('ADMIN') and hasRole('DBA')"</span>)</div><div class="line">                .anyRequest().authenticated()</div><div class="line">                .and()</div><div class="line">            <span class="comment">// 配置表单认证</span></div><div class="line">            .formLogin()</div><div class="line">                .usernameParameter(<span class="string">"username"</span>)</div><div class="line">                .passwordParameter(<span class="string">"password"</span>)</div><div class="line">                .failureForwardUrl(<span class="string">"/login?error"</span>)</div><div class="line">                .loginPage(<span class="string">"/login"</span>)</div><div class="line">                .permitAll()</div><div class="line">                .and()</div><div class="line">            <span class="comment">// 配置注销</span></div><div class="line">            .logout()</div><div class="line">                .logoutUrl(<span class="string">"/logout"</span>)</div><div class="line">                .logoutSuccessUrl(<span class="string">"/index"</span>)</div><div class="line">                .permitAll()</div><div class="line">                .and()</div><div class="line">            <span class="comment">// 配置basic登录</span></div><div class="line">            .httpBasic()</div><div class="line">                .disable();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法里的各项配置分别代表了http请求相关的安全配置，这些配置项无一例外的返回了Configurer类，而所有的http相关配置可以通过查看HttpSecurity的主要方法得知。</p>
<h2 id="WebSecurityBuilder"><a href="#WebSecurityBuilder" class="headerlink" title="WebSecurityBuilder"></a>WebSecurityBuilder</h2><p>我们可以看看它的使用案例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        web</div><div class="line">            .ignoring()</div><div class="line">            .antMatchers(<span class="string">"/resources/**"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个配置中并不会出现太多的配置信息。</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="http://ov0zuistv.bkt.clouddn.com/spring%20security%20architecture.png" alt="image"></p>
<p>将这个架构图结合流程图我们会可以大致总结出核心组件之间的关系，有利于我们我们更好的理解SpringSecurity的架构以及请求认证过程。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnkirito.moe/2017/09/19/spring-security-1/" target="_blank" rel="external">Spring Security(一)–Architecture Overview</a></li>
<li><a href="https://blog.csdn.net/dandandeshangni/article/details/78959131" target="_blank" rel="external">Spring Security源码分析一：Spring Security认证过程</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：有了Spring作为基础，Spring家族的很多框架都显得那么棒，尤其是Springboot的出现，简化了配置，家族框架就显得更棒了，我们这次分析一下其中的SpringSecurity，我们会由请求认证过程，来分析其中的各个组件！
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="SpringSecurity" scheme="http://bestlixiang.site/tags/SpringSecurity/"/>
    
  </entry>
  
  <entry>
    <title>揭秘SpringBoot(一)_SpringBoot运行原理</title>
    <link href="http://bestlixiang.site/2018/04/21/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98SpringBoot-%E4%B8%80-SpringBoot%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://bestlixiang.site/2018/04/21/深入SSM/揭秘SpringBoot-一-SpringBoot运行原理/</id>
    <published>2018-04-21T05:11:48.000Z</published>
    <updated>2018-04-21T05:12:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：可能你早已开始使用SpringBoot，但是你却不知道SpringBoot是个什么东西，他又是怎么运行的，这里给你答案！<a id="more"></a></p>
<h1 id="SpringBoot是什么"><a href="#SpringBoot是什么" class="headerlink" title="SpringBoot是什么"></a>SpringBoot是什么</h1><p>用过Spring的人都知道，你肯定需要些很多很多的XML来用配置复杂的依赖关系，你肯定厌倦了。这个时候SpringBoot出现了，<br><strong>SpringBoot</strong>是由Pivotal团队提供的全新框架，其<strong>设计目的是用来简化新Spring应用的初始搭建以及开发过程</strong>。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置（想想肯定会很开心）。</p>
<h2 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h2><p><strong>习惯优于配置</strong></p>
<h2 id="SpringBoot与Spring-Framework的区别"><a href="#SpringBoot与Spring-Framework的区别" class="headerlink" title="SpringBoot与Spring Framework的区别"></a>SpringBoot与Spring Framework的区别</h2><p>做个下面的<strong>比喻</strong>：</p>
<p><strong>SpringFramework</strong> 就像一个大型电子器件生产公司，它生产的电子器件（比如zookeeper，redis等整合包）都很优秀，当其他小公司（开发者）生产机器人（项目）需要使用到它的电子器件时，就发现需要大量的焊接工作（配置XML）来连接自己的电子器件（zookeeper，redis），这样真的太耗时了，而<strong>SpringBoot</strong> 就像这个电子器件生产公司在原来电子器件的基础上包装出来的许多统一的插口（各种starter），这些插头可以与小公司的电子器件可以直接连接，不需要焊接工作就可以直接使用。</p>
<p>通过上面的比喻我们可以了解到他们两者的区别，也发现其实SpringBoot并不是什么新东西，它只是原来Spring的基础上重新包装过，从而简化了Spring的相关配置。</p>
<h2 id="SpringBoot的核心功能"><a href="#SpringBoot的核心功能" class="headerlink" title="SpringBoot的核心功能"></a>SpringBoot的核心功能</h2><ol>
<li>SpringBoot可以以jar包的形式<strong>独立运行</strong>，因为SpringBoot内嵌Servlet容器，如Tomcat、Jetty。</li>
<li>Spring会根据类路径中的jar包、类，为jar包里的类自动配置Bean，极大减少了我们要使用的配置。</li>
<li>提供starter(起动机)简化了Maven配置(依赖加载)，一个starter依赖抵了好几个依赖。</li>
</ol>
<h1 id="SpringBoot运行原理"><a href="#SpringBoot运行原理" class="headerlink" title="SpringBoot运行原理"></a>SpringBoot运行原理</h1><ol>
<li><p>对于SpringBoot工程我们总是先看到它的启动类，如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootLoginApplication</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		SpringApplication.run(SpringbootLoginApplication.class, args);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对于SpringBoot的运作原理，我们应该先从启动类的@SpringBootApplication注解来分析，这个注解是一个组合注解，我们进入它的源码看看：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@SpringBootConfiguration</span></div><div class="line"><span class="meta">@EnableAutoConfiguration</span></div><div class="line"><span class="meta">@ComponentScan</span>(</div><div class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</div><div class="line">    type = FilterType.CUSTOM,</div><div class="line">    classes = &#123;TypeExcludeFilter.class&#125;</div><div class="line">), <span class="meta">@Filter</span>(</div><div class="line">    type = FilterType.CUSTOM,</div><div class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</div><div class="line">)&#125;</div><div class="line">)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</div><div class="line">    <span class="meta">@AliasFor</span>(</div><div class="line">        annotation = EnableAutoConfiguration.class</div><div class="line">    )</div><div class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="meta">@AliasFor</span>(</div><div class="line">        annotation = EnableAutoConfiguration.class</div><div class="line">    )</div><div class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="meta">@AliasFor</span>(</div><div class="line">        annotation = ComponentScan.class,</div><div class="line">        attribute = <span class="string">"basePackages"</span></div><div class="line">    )</div><div class="line">    String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="meta">@AliasFor</span>(</div><div class="line">        annotation = ComponentScan.class,</div><div class="line">        attribute = <span class="string">"basePackageClasses"</span></div><div class="line">    )</div><div class="line">    Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 总得来说最重要的就是@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan这三个注解，我们一个个分析：</p>
<ol>
<li><p>@SpringBootConfiguration</p>
<p> 我们进入该注解，我发现它的代码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 你会发现其核心注解就是@Configuration，它对于我们来说应该不陌生，因为它就是Java配置形式的Spring Ioc容器的配置类使用的那个@Configuration（相当于XML配置文件的一个Bean），SpringBoot社区推荐使用基于JavaConfig的配置形式，所以，这里的启动类标注了@Configuration之后，本身其实也是一个IoC容器的配置类。</p>
</li>
<li><p>@ComponentScan</p>
<p> 这个注解很简单，很常见，但是也很<strong>重要</strong>。它主要的作用就是自动扫描并加载符合条件的组件（比如@Controller和@Service等）或者bean定义，最终将这些bean定义加载到IoC容器中。我们看看它的源码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Repeatable</span>(ComponentScans.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ComponentScan &#123;</div><div class="line"><span class="comment">// 设置默认路径</span></div><div class="line"><span class="meta">@AliasFor</span>(<span class="string">"basePackages"</span>)</div><div class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"><span class="comment">// 如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。</span></div><div class="line"><span class="comment">// 所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。</span></div><div class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</div><div class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</div><div class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</div><div class="line">Class&lt;? extends BeanNameGenerator&gt; nameGenerator() <span class="keyword">default</span> BeanNameGenerator.class;</div><div class="line">Class&lt;? extends ScopeMetadataResolver&gt; scopeResolver() <span class="keyword">default</span> AnnotationScopeMetadataResolver.class;</div><div class="line"><span class="function">ScopedProxyMode <span class="title">scopedProxy</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.DEFAULT</span>;</div><div class="line"><span class="comment">// 扫描类型</span></div><div class="line"><span class="function">String <span class="title">resourcePattern</span><span class="params">()</span> <span class="keyword">default</span> "**<span class="comment">/*.class";</span></span></div><div class="line">// 可设置过滤器</div><div class="line">boolean useDefaultFilters() default true;</div><div class="line">ComponentScan.Filter[] includeFilters() default &#123;&#125;;</div><div class="line">ComponentScan.Filter[] excludeFilters() default &#123;&#125;;</div><div class="line">// 配置懒加载，如果没被使用，就先不生成Bean</div><div class="line">boolean lazyInit() default false;</div><div class="line"></div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Target(&#123;&#125;)</div><div class="line">public @interface Filter &#123;</div><div class="line">    FilterType type() default FilterType.ANNOTATION;</div><div class="line"></div><div class="line">    @AliasFor("classes")</div><div class="line">    Class&lt;?&gt;[] value() default &#123;&#125;;</div><div class="line"></div><div class="line">    @AliasFor("value")</div><div class="line">    Class&lt;?&gt;[] classes() default &#123;&#125;;</div><div class="line"></div><div class="line">    String[] pattern() default &#123;&#125;;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>@EnableAutoConfiguration</p>
<p> 这个注解可以说是SpringBoot自动配置的核心了，<strong>灰常重要</strong>。我们进去看一下它的源码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@AutoConfigurationPackage</span></div><div class="line"><span class="comment">// 借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器</span></div><div class="line"><span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</div><div class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</div><div class="line"></div><div class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 我们需要好好看看AutoConfigurationImportSelector，它利用SpringFactoriesLoader.loadFactoryNames方法来扫描具有META-INF/spring.factories 文件的jar包，代码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</div><div class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</div><div class="line"><span class="keyword">return</span> configurations;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 配合@EnableAutoConfiguration使用的话，它更多是提供一种配置查找的功能支持，即根据@EnableAutoConfiguration的完整类名如org.springframework.boot.autoconfigure.EnableAutoConfiguration作为查找的Key,<strong>获取对应的一组@Configuration类</strong>，并将其中org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的配置项实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个（相当于一个XML文件）并加载到IoC容器（和Spring一样）。</p>
<p> 我们可以看看spring-boot-autoconfigure.jar 里就有一个spring.factories 文件，此文件中声明了有哪些自动配置。我们看一点点：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Auto Configure</div><div class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</div><div class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</div><div class="line"># 配置AOP对象</div><div class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>看完@SpringBootApplication注解，我们再看看SpringApplication的run方法。</p>
<ol>
<li><p>我们通过debug发现将进入这个方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 会先创建SpringApplication对象实例，然后调用它的实例run方法</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> SpringApplication(primarySources)).run(args);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>我们看看在实例初始化的过程中他做了什么：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class... primarySources)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.sources = <span class="keyword">new</span> LinkedHashSet();</div><div class="line">    <span class="comment">// banner的打印模式，此时是控制台模式</span></div><div class="line">    <span class="keyword">this</span>.bannerMode = Mode.CONSOLE;</div><div class="line">    <span class="comment">// 开启日志</span></div><div class="line">    <span class="keyword">this</span>.logStartupInfo = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">// 启用CommandLineProperties</span></div><div class="line">    <span class="keyword">this</span>.addCommandLineProperties = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">// 开启headless模式支持，Headless模式是在缺少显示屏、键盘或者鼠标时的系统配置（自行了解）</span></div><div class="line">    <span class="keyword">this</span>.headless = <span class="keyword">true</span></div><div class="line">    <span class="comment">// 启用注册ShutdownHook，用于在非Web应用中关闭IoC容器和资源</span></div><div class="line">    <span class="keyword">this</span>.registerShutdownHook = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">this</span>.additionalProfiles = <span class="keyword">new</span> HashSet();</div><div class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</div><div class="line">    <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet(Arrays.asList(primarySources));</div><div class="line">    <span class="comment">// 判断是否是web运行环境(Servlet)</span></div><div class="line">    <span class="keyword">this</span>.webApplicationType = <span class="keyword">this</span>.deduceWebApplicationType();</div><div class="line">    <span class="comment">// 设置初始化器(在META-INF/spring.factories 文件里，可扩展)</span></div><div class="line">    <span class="keyword">this</span>.setInitializers(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));</div><div class="line">    <span class="comment">// 设置监听器(在META-INF/spring.factories 文件里，可扩展)</span></div><div class="line">    <span class="keyword">this</span>.setListeners(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationListener.class));</div><div class="line">    <span class="comment">// 推断并设置main方法的定义类</span></div><div class="line">    <span class="keyword">this</span>.mainApplicationClass = <span class="keyword">this</span>.deduceMainApplicationClass();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑，如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 开启任务执行时间监听器</span></div><div class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</div><div class="line">    stopWatch.start();</div><div class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</div><div class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList();</div><div class="line">    <span class="comment">// 设置系统属性</span></div><div class="line">    <span class="keyword">this</span>.configureHeadlessProperty();</div><div class="line">    <span class="comment">//开启广播，宣告SpringBoot要开始执行了</span></div><div class="line">    SpringApplicationRunListeners listeners = <span class="keyword">this</span>.getRunListeners(args);</div><div class="line">    listeners.starting();</div><div class="line"></div><div class="line">    Collection exceptionReporters;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</div><div class="line">        <span class="comment">// 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。</span></div><div class="line">        ConfigurableEnvironment environment = <span class="keyword">this</span>.prepareEnvironment(listeners, applicationArguments);</div><div class="line">        <span class="comment">// 宣告SpringBoot应用使用的Environment准备好了。</span></div><div class="line">        <span class="keyword">this</span>.configureIgnoreBeanInfo(environment);</div><div class="line">        <span class="comment">// 决定是否打印Banner</span></div><div class="line">        Banner printedBanner = <span class="keyword">this</span>.printBanner(environment);</div><div class="line">        <span class="comment">// 根据用户是否明确设置了applicationContextClass类型，决定该为当前SpringBoot应用创建什么类型的ApplicationContext</span></div><div class="line">        <span class="comment">// 然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，</span></div><div class="line">        <span class="comment">// 最重要的是将之前准备好的Environment设置给创建好的ApplicationContext使用。</span></div><div class="line">        context = <span class="keyword">this</span>.createApplicationContext();</div><div class="line">        <span class="comment">// 得到异常报告者</span></div><div class="line">        exceptionReporters = <span class="keyword">this</span>.getSpringFactoriesInstances(SpringBootExceptionReporter.class, <span class="keyword">new</span> Class[]&#123;ConfigurableApplicationContext.class&#125;, <span class="keyword">new</span> Object[]&#123;context&#125;);</div><div class="line">        <span class="comment">// ApplicationContext创建好之后，遍历调用ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</span></div><div class="line">        <span class="comment">// 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</span></div><div class="line">        <span class="comment">// 将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext</span></div><div class="line">        <span class="comment">// (很重要，可以进入看看)</span></div><div class="line">        <span class="keyword">this</span>.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</div><div class="line">        <span class="comment">// 初始化所有自动配置类，调用ApplicationContext的refresh()方法</span></div><div class="line">        <span class="keyword">this</span>.refreshContext(context);</div><div class="line">        <span class="comment">// 调用所有的SpringApplicationRunListener的finished()方法，宣告SpringBoot已经完成了ApplicationContext初始化的全部过程。</span></div><div class="line">        <span class="keyword">this</span>.afterRefresh(context, applicationArguments);</div><div class="line">        <span class="comment">//关闭任务执行时间监听器</span></div><div class="line">        stopWatch.stop();</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logStartupInfo) &#123;</div><div class="line">            <span class="comment">// //如果开启日志，则打印执行的时间</span></div><div class="line">            (<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)).logStarted(<span class="keyword">this</span>.getApplicationLog(), stopWatch);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        listeners.started(context);</div><div class="line">        <span class="keyword">this</span>.callRunners(context, applicationArguments);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</div><div class="line">        <span class="comment">// //调用异常分析器打印报告，调用所有的SpringApplicationRunListener的finished()方法将异常信息发布出去</span></div><div class="line">        <span class="keyword">this</span>.handleRunFailure(context, var10, exceptionReporters, listeners);</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var10);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        listeners.running(context);</div><div class="line">        <span class="keyword">return</span> context;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</div><div class="line">        <span class="keyword">this</span>.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var9);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnblogs.com/zheting/p/6707035.html" target="_blank" rel="external">Spring Boot干货系列：（三）启动原理解析</a></li>
<li><a href="https://www.jianshu.com/p/cb5cb5937686" target="_blank" rel="external">Spring Boot学习笔记03–深入了解SpringBoot的启动过程</a></li>
<li><a href="https://blog.csdn.net/hengyunabc/article/details/50120001" target="_blank" rel="external">spring boot应用启动原理分析</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：可能你早已开始使用SpringBoot，但是你却不知道SpringBoot是个什么东西，他又是怎么运行的，这里给你答案！
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="SpringBoot" scheme="http://bestlixiang.site/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>HelloWorld_SSMLogin</title>
    <link href="http://bestlixiang.site/2018/04/17/HelloWorld/HelloWorld-SSMLogin/"/>
    <id>http://bestlixiang.site/2018/04/17/HelloWorld/HelloWorld-SSMLogin/</id>
    <published>2018-04-17T10:55:22.000Z</published>
    <updated>2018-04-17T11:01:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：想着怎么教一个人快速入门SSM，讲原理是真的太费时间，还是以搭建具体流程加上源码比较好吧，先模仿，后创新嘛！<a id="more"></a></p>
<h1 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h1><p><strong><a href="https://github.com/todorex/SSM_LoginDemo" target="_blank" rel="external">项目仓库地址</a></strong></p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/helloworld/png/ssm.png" alt="ssm"></p>
<p>我们先把文件夹创建好，当然也可以先直接从我<a href="https://github.com/todorex/SSM_LoginDemo" target="_blank" rel="external">仓库地址</a>把它克隆下来，删除其中部分的代码文件。</p>
<h1 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h1><p><strong>配置文件里面都有注释，大家可以对照着看：</strong></p>
<h2 id="pom-xml文件"><a href="#pom-xml文件" class="headerlink" title="pom.xml文件"></a>pom.xml文件</h2><p>pom文件作为Maven工程的核心，主要是用来引入jar包的，在我的pom文件中也详细列出了我们需要哪些包，以及哪些包是用来干什么的。</p>
<h2 id="web-xml文件"><a href="#web-xml文件" class="headerlink" title="web.xml文件"></a>web.xml文件</h2><p>web.xml作为Web功能的核心，主要是设置了如何接受请求，这里会结合SpringMVC的前端控制器类DispatcherServlet作为请求分发的核心Servlet，以及在第一次加载过程中，后台服务需要加载哪些配置文件。</p>
<h2 id="ssm配置文件（依靠Spring整合）"><a href="#ssm配置文件（依靠Spring整合）" class="headerlink" title="ssm配置文件（依靠Spring整合）"></a>ssm配置文件（依靠Spring整合）</h2><p>我们看到spring文件夹下有三个文件，分别对应了dao，service，web三层的Bean配置。</p>
<h3 id="spring-dao-config-xml文件"><a href="#spring-dao-config-xml文件" class="headerlink" title="spring-dao-config.xml文件"></a>spring-dao-config.xml文件</h3><p>这里主要是配置数据库连接池（数据源），以及注入SqlSessionFactory和所有在com.todorex.dao下得所有Dao接口。</p>
<h3 id="spring-service-config-xml文件"><a href="#spring-service-config-xml文件" class="headerlink" title="spring-service-config.xml文件"></a>spring-service-config.xml文件</h3><p>这里主要配置扫描并注入com.todorex.service包下所有Service注解类，以及配置事务管理器。</p>
<h3 id="spring-web-config-xml文件"><a href="#spring-web-config-xml文件" class="headerlink" title="spring-web-config.xml文件"></a>spring-web-config.xml文件</h3><p>这里主要配置扫描并注入com.todorex.controller包下所有Controller注解类，以及配置视图解析器。这里还有一个超级重要的就是配置处理静态资源的方式。</p>
<h2 id="mybatis-config-xml文件"><a href="#mybatis-config-xml文件" class="headerlink" title="mybatis-config.xml文件"></a>mybatis-config.xml文件</h2><p>这里主要是设置mybatis的全局属性。</p>
<h2 id="jdbc-properties文件"><a href="#jdbc-properties文件" class="headerlink" title="jdbc.properties文件"></a>jdbc.properties文件</h2><p>这里主要配置数据库连接的相关信息。</p>
<h2 id="log4j-properties文件"><a href="#log4j-properties文件" class="headerlink" title="log4j.properties文件"></a>log4j.properties文件</h2><p>这里主要配置日志记录的相关信息。</p>
<p>配置文件都配置完了，我们终于可以开始写代码了!</p>
<h1 id="SSM代码"><a href="#SSM代码" class="headerlink" title="SSM代码"></a>SSM代码</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>实现用户的登录与注销。</p>
<h2 id="上帝视角开发（我需要什么就造什么）"><a href="#上帝视角开发（我需要什么就造什么）" class="headerlink" title="上帝视角开发（我需要什么就造什么）"></a>上帝视角开发（我需要什么就造什么）</h2><h3 id="我需要一个能处理我的请求（URL）的Controller"><a href="#我需要一个能处理我的请求（URL）的Controller" class="headerlink" title="我需要一个能处理我的请求（URL）的Controller"></a>我需要一个能处理我的请求（URL）的Controller</h3><p>知道要controller，我们就造一个，我们在com.todorex.controller包下新建一个LoginController类。</p>
<p>Controller的作用主要是根据你请求的URL来做不同的事（对应的方法），结果是返回一个ModelAndView（当然View和Model也可以分开），如果方法的逻辑只是页面间的跳转和简单数据处理，我们就用不到Service了，如过我们需要进行业务处理以及操作数据库，那么我们就需要用到Service了。</p>
<p>PS：这里需要注意请求转发和请求重定向的区别（注释中有）</p>
<h3 id="我需要一个能处理业务的Service"><a href="#我需要一个能处理业务的Service" class="headerlink" title="我需要一个能处理业务的Service"></a>我需要一个能处理业务的Service</h3><p>在service层设计一个好的接口是至关重要的（我们还是HelloWorld，以后有经验了自然能设计得好一些），如果实现类有多个的话 ，可以用@Service(“userService1”)来注入，@Resource(name=”userService1”) 来对应获取。在处理业务逻辑的时候，一般都会涉及到数据库操作，这个时候我们就需要用到Dao了。</p>
<h3 id="我需要一个能处理数据的Dao"><a href="#我需要一个能处理数据的Dao" class="headerlink" title="我需要一个能处理数据的Dao"></a>我需要一个能处理数据的Dao</h3><p>这里我们要明确一点：一个Dao接口对应一个Mapper文件，Dao定义接口方法，Mapper文件实现该方法的sql语句。</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>这里我们举一个例子，就是记录登录用户的名字和时间，看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</div><div class="line">    <span class="comment">// 获得日志对象</span></div><div class="line">    Logger logger = Logger.getLogger(LoginController.class);</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/checkLogin"</span>,method = RequestMethod.POST)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">checkLogin</span><span class="params">(User user, Model model)</span> </span>&#123;</div><div class="line">        user = userService.checkLogin(user.getUsername(),user.getPassword());</div><div class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 日志记录用户登录</span></div><div class="line">            logger.info(user.getUsername()+<span class="string">"在"</span>+<span class="keyword">new</span> Date() + <span class="string">"登录过!"</span>);</div><div class="line">            model.addAttribute(<span class="string">"user"</span>,user);</div><div class="line">            <span class="keyword">return</span> <span class="string">"redirect:/success"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"redirect:/fail"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol>
<li><p>配置一个基类（用于加载配置文件）</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class) <span class="comment">//使用junit4进行测试</span></div><div class="line"><span class="comment">// 导入多个配置文件</span></div><div class="line"><span class="meta">@ContextConfiguration</span>(locations=&#123;<span class="string">"classpath:spring/spring-*.xml"</span>,<span class="string">"classpath:mybatis-config.xml"</span>&#125;) <span class="comment">//加载配置文件</span></div><div class="line"><span class="comment">//所有继承该类的测试类都会遵循该配置</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseJunit4Test</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在各个对应的包下建立单元测试，如;</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> <span class="keyword">extends</span> <span class="title">BaseJunit4Test</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserDao userDao;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFindByUsername</span><span class="params">()</span> </span>&#123;</div><div class="line">        User user = userDao.findByUsername(<span class="string">"rex"</span>);</div><div class="line">        System.out.println(user);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="页面编写"><a href="#页面编写" class="headerlink" title="页面编写"></a>页面编写</h1><p>这里只举一个例子（其实主要就是jsp的用法）,success.jsp:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</div><div class="line">         pageEncoding=&quot;UTF-8&quot;%&gt;</div><div class="line">&lt;%--引入jstl标签库，很重要--%&gt;</div><div class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;</div><div class="line"> &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Insert title here&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;!--添加背景图片--&gt;</div><div class="line">&lt;body background=&quot;image/success.jpg&quot;&gt;</div><div class="line"></div><div class="line">&lt;div style=&quot;margin: auto&quot;&gt;</div><div class="line">&lt;div&gt;</div><div class="line">    &lt;%--利用jstl标签获取session中的user的值--%&gt;</div><div class="line">    &lt;strong style=&quot;font-size: 100px;color: red&quot;&gt; $&#123;sessionScope.user.username&#125;!&lt;/strong&gt;</div><div class="line">    &lt;strong style=&quot;font-size: 100px;color: blue&quot;&gt; ，你他妈登录成功了&lt;/strong&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;form action=&quot;/LoginDemo/outLogin&quot; &gt;</div><div class="line">    &lt;button type=&quot;submit&quot; class=&quot;btn btn-success col-lg-12&quot; style=&quot;font-size: 100px;text-align: center&quot;&gt;退出登录&lt;/button&gt;</div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p><strong>终于大功告成！！！</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/s740556472/article/details/71247285" target="_blank" rel="external">SSM搭建(整合)+用户模块(登录和注销)实现</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：想着怎么教一个人快速入门SSM，讲原理是真的太费时间，还是以搭建具体流程加上源码比较好吧，先模仿，后创新嘛！
    
    </summary>
    
      <category term="HelloWorld" scheme="http://bestlixiang.site/categories/HelloWorld/"/>
    
    
      <category term="Spring" scheme="http://bestlixiang.site/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="http://bestlixiang.site/tags/SpringMVC/"/>
    
      <category term="Mybatis" scheme="http://bestlixiang.site/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Mybatis(二)_Mybatis工作原理</title>
    <link href="http://bestlixiang.site/2018/04/16/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Mybatis-%E4%BA%8C-Mybatis%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://bestlixiang.site/2018/04/16/深入SSM/揭秘Mybatis-二-Mybatis工作原理/</id>
    <published>2018-04-16T07:38:03.000Z</published>
    <updated>2018-04-16T07:38:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：了解完Mybatis的架构，那么它的执行流程又是怎么样的呢？<a id="more"></a></p>
<h1 id="Mybatis主要组件及工作流程"><a href="#Mybatis主要组件及工作流程" class="headerlink" title="Mybatis主要组件及工作流程"></a>Mybatis主要组件及工作流程</h1><h2 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h2><ol>
<li>Configuration：MyBatis所有的配置信息都维持在Configuration对象之中</li>
<li>SqlSession：作为MyBatis接口层的AOP，表示和数据库交互的会话，完成必要数据库增删改查功能</li>
<li>Executor：MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护</li>
<li>StatementHandler：封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合</li>
<li>ParameterHandler：负责对用户传递的参数转换成JDBC Statement 所需要的参数</li>
<li>resultSetHandler：负责将JDBC返回的ResultSet结果集对象转换成List类型的集合</li>
<li>TypeHandler：负责java数据类型和jdbc数据类型之间的映射和转换</li>
<li>MappedStatement：MappedStatement维护了一条<select|update|delete|insert>节点的封装</select|update|delete|insert></li>
<li>SqlSource：负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回</li>
<li>BoundSql：表示动态生成的SQL语句以及相应的参数信息</li>
</ol>
<h2 id="工作流程图"><a href="#工作流程图" class="headerlink" title="工作流程图"></a>工作流程图</h2><p><img src="https://upload-images.jianshu.io/upload_images/2062729-a2f20529d6d908a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="workflow"></p>
<p>这张图也超级棒（Nice 兄Dei），在下面参考也将看到出处。我们下面的源码分析也会参考这张图。</p>
<h1 id="Mybatis初始化源码分析"><a href="#Mybatis初始化源码分析" class="headerlink" title="Mybatis初始化源码分析"></a>Mybatis初始化源码分析</h1><ol>
<li><p>获取配置文件创建SqlSessionFactory</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String resource = &quot;mybatis-config.xml&quot;;</div><div class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</div><div class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</div></pre></td></tr></table></figure>
</li>
<li><p>进入到SqlSessionFactory的build方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</div><div class="line">    SqlSessionFactory var5;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 解析刚刚创建的配置文件文件流</span></div><div class="line">        XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</div><div class="line">        var5 = <span class="keyword">this</span>.build(parser.parse());</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception var14) &#123;</div><div class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, var14);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        ErrorContext.instance().reset();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            inputStream.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException var13) &#123;</div><div class="line">            ;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> var5;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>会进入到XMLConfigBuilder的parse方法去解析配置文件的具体内容生成Configuration对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.parsed) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.parsed = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">// 解析配置文件</span></div><div class="line">        <span class="keyword">this</span>.parseConfiguration(<span class="keyword">this</span>.parser.evalNode(<span class="string">"/configuration"</span>));</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.configuration;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 解析&lt;properties&gt;节点，数据源配置文件</span></div><div class="line">        <span class="keyword">this</span>.propertiesElement(root.evalNode(<span class="string">"properties"</span>));</div><div class="line">        <span class="comment">// 解析&lt;typeAliases&gt;节点，别名节点</span></div><div class="line">        <span class="keyword">this</span>.typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</div><div class="line">        <span class="comment">// 解析&lt;plugins&gt;节点，插件节点</span></div><div class="line">        <span class="keyword">this</span>.pluginElement(root.evalNode(<span class="string">"plugins"</span>));</div><div class="line">        <span class="comment">// 解析&lt;objectFactory&gt;节点</span></div><div class="line">        <span class="keyword">this</span>.objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</div><div class="line">        <span class="comment">// 解析&lt;reflectorFactory&gt;节点</span></div><div class="line">        <span class="keyword">this</span>.objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</div><div class="line">        <span class="comment">// 解析&lt;settings&gt;节点</span></div><div class="line">        <span class="keyword">this</span>.settingsElement(root.evalNode(<span class="string">"settings"</span>));</div><div class="line">        <span class="comment">// 解析&lt;environments&gt;节点</span></div><div class="line">        <span class="keyword">this</span>.environmentsElement(root.evalNode(<span class="string">"environments"</span>));</div><div class="line">        <span class="keyword">this</span>.databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</div><div class="line">        <span class="keyword">this</span>.typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</div><div class="line">        <span class="comment">// 解析&lt;mappers&gt;节点，很重要</span></div><div class="line">        <span class="keyword">this</span>.mapperElement(root.evalNode(<span class="string">"mappers"</span>));</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception var3) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + var3, var3);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>我们最关心的可能就是mapper的解析了，所以我们进入mapperElement方法看看：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</div><div class="line">            Iterator i$ = parent.getChildren().iterator();</div><div class="line"></div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">                <span class="comment">// 遍历&lt;mappers&gt;下所有子节点</span></div><div class="line">                <span class="keyword">while</span>(i$.hasNext()) &#123;</div><div class="line">                    XNode child = (XNode)i$.next();</div><div class="line">                    String resource;</div><div class="line">                    <span class="comment">// 如果当前节点为&lt;package&gt;</span></div><div class="line">                    <span class="keyword">if</span>(<span class="string">"package"</span>.equals(child.getName())) &#123;</div><div class="line">                        <span class="comment">// 获取&lt;package&gt;的name属性（该属性值为mapper class所在的包名）</span></div><div class="line">                        resource = child.getStringAttribute(<span class="string">"name"</span>);</div><div class="line">                        <span class="comment">// 将该包下的所有Mapper Class注册到configuration的mapperRegistry容器中</span></div><div class="line">                        <span class="keyword">this</span>.configuration.addMappers(resource);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// 依次获取resource、url、class属性</span></div><div class="line">                        resource = child.getStringAttribute(<span class="string">"resource"</span>);</div><div class="line">                        String url = child.getStringAttribute(<span class="string">"url"</span>);</div><div class="line">                        String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</div><div class="line">                        XMLMapperBuilder mapperParser;</div><div class="line">                        InputStream inputStream;</div><div class="line">                        <span class="comment">// 解析resource属性（Mapper.xml文件的路径）</span></div><div class="line">                        <span class="keyword">if</span>(resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</div><div class="line">                            ErrorContext.instance().resource(resource);</div><div class="line">                            <span class="comment">// 将Mapper.xml文件解析成输入流</span></div><div class="line">                            inputStream = Resources.getResourceAsStream(resource);</div><div class="line">                            <span class="comment">// 使用XMLMapperBuilder解析Mapper.xml，并将Mapper Class注册进configuration对象的mapperRegistry容器中</span></div><div class="line">                            mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, <span class="keyword">this</span>.configuration, resource, <span class="keyword">this</span>.configuration.getSqlFragments());</div><div class="line">                            <span class="comment">// 这个很重要，看看具体怎么解析</span></div><div class="line">                            mapperParser.parse();</div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</div><div class="line">                            <span class="comment">// 解析url属性（Mapper.xml文件的路径）</span></div><div class="line">                            ErrorContext.instance().resource(url);</div><div class="line">                            inputStream = Resources.getUrlAsStream(url);</div><div class="line">                            mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, <span class="keyword">this</span>.configuration, url, <span class="keyword">this</span>.configuration.getSqlFragments());</div><div class="line">                            mapperParser.parse();</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="comment">// 解析class属性（Mapper Class的全限定名）</span></div><div class="line">                            <span class="keyword">if</span>(resource != <span class="keyword">null</span> || url != <span class="keyword">null</span> || mapperClass == <span class="keyword">null</span>) &#123;</div><div class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</div><div class="line">                            &#125;</div><div class="line">                            <span class="comment">// 将Mapper Class的权限定名转化成Class对象</span></div><div class="line">                            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</div><div class="line">                            <span class="keyword">this</span>.configuration.addMapper(mapperInterface);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.configuration.isResourceLoaded(<span class="keyword">this</span>.resource)) &#123;</div><div class="line">        <span class="comment">// 解析&lt;mapper&gt;节点</span></div><div class="line">        <span class="keyword">this</span>.configurationElement(<span class="keyword">this</span>.parser.evalNode(<span class="string">"/mapper"</span>));</div><div class="line">        <span class="comment">// 将该Mapper.xml添加至configuration的LoadedResource容器中，下回无需再解析</span></div><div class="line">        <span class="keyword">this</span>.configuration.addLoadedResource(<span class="keyword">this</span>.resource);</div><div class="line">        <span class="comment">// 将该Mapper.xml对应的Mapper Class注册进configuration的mapperRegistry容器中，很重要，下马需要仔细看看</span></div><div class="line">        <span class="keyword">this</span>.bindMapperForNamespace();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.parsePendingResultMaps();</div><div class="line">    <span class="keyword">this</span>.parsePendingChacheRefs();</div><div class="line">    <span class="keyword">this</span>.parsePendingStatements();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>bindMapperForNamespace极其重要，因为这里会给Mapper接口创建动态代理对象，我们看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMapperForNamespace</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 获取当前映射文件对应的DAO接口的全限定名</span></div><div class="line">        String namespace = <span class="keyword">this</span>.builderAssistant.getCurrentNamespace();</div><div class="line">        <span class="keyword">if</span>(namespace != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 将全限定名解析成Class对象</span></div><div class="line">            Class boundType = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                boundType = Resources.classForName(namespace);</div><div class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var4) &#123;</div><div class="line">                ;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(boundType != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.configuration.hasMapper(boundType)) &#123;</div><div class="line">                <span class="comment">// 将当前Mapper.xml标注为已加载下回就不用再加载了</span></div><div class="line">                <span class="keyword">this</span>.configuration.addLoadedResource(<span class="string">"namespace:"</span> + namespace);</div><div class="line">                <span class="comment">// 将Mapper接口的Class对象注册进configuration中（其实是在configuration的MapperRegistry里面）</span></div><div class="line">                <span class="keyword">this</span>.configuration.addMapper(boundType);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>我们再进入到this.configuration.addMapper方法中看看会做些什么：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.mapperRegistry.addMapper(type);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(type.isInterface()) &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.hasMapper(type)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is already known to the MapperRegistry."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 创建MapperProxyFactory对象（用于创建DAO接口的代理对象），并put进knownMappers中</span></div><div class="line">            <span class="comment">// 为后面的创建Mapper代理对象做准备</span></div><div class="line">            <span class="keyword">this</span>.knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory(type));</div><div class="line">            MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(<span class="keyword">this</span>.config, type);</div><div class="line">            parser.parse();</div><div class="line">            loadCompleted = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span>(!loadCompleted) &#123;</div><div class="line">                <span class="keyword">this</span>.knownMappers.remove(type);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>等Mapper全都解析好之后，初始化工作基本就完成了。</p>
</li>
</ol>
<h1 id="Mybatis工作流程源码分析"><a href="#Mybatis工作流程源码分析" class="headerlink" title="Mybatis工作流程源码分析"></a>Mybatis工作流程源码分析</h1><ol>
<li><p>创建SqlSession对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 从数据源创建SqlSession会话对象</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.openSessionFromDataSource(<span class="keyword">this</span>.configuration.getDefaultExecutorType(), (TransactionIsolationLevel)<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</div><div class="line">    Transaction tx = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    DefaultSqlSession var8;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 初始化读取了Environment里面的数据源以及事务配置</span></div><div class="line">        Environment environment = <span class="keyword">this</span>.configuration.getEnvironment();</div><div class="line">        <span class="comment">// 获取事务工厂</span></div><div class="line">        TransactionFactory transactionFactory = <span class="keyword">this</span>.getTransactionFactoryFromEnvironment(environment);</div><div class="line">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</div><div class="line">        <span class="comment">// 生成MyBatis执行器</span></div><div class="line">        Executor executor = <span class="keyword">this</span>.configuration.newExecutor(tx, execType);</div><div class="line">        <span class="comment">// 创建DefaultSqlSession对象</span></div><div class="line">        var8 = <span class="keyword">new</span> DefaultSqlSession(<span class="keyword">this</span>.configuration, executor, autoCommit);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception var12) &#123;</div><div class="line">        <span class="keyword">this</span>.closeTransaction(tx);</div><div class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + var12, var12);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        ErrorContext.instance().reset();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> var8;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>从SqlSession对象获得Mapper（后面会看到这是个代理对象），看看执行流程：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</div><div class="line">    <span class="comment">// 进入configuration</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.configuration.getMapper(type, <span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</div><div class="line">    <span class="comment">// 调用configuration对象的apperRegistry的getMapper方法</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mapperRegistry.getMapper(type, sqlSession);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</div><div class="line">    <span class="comment">// 这个是在初始化过程中解析mapper时生成的，现有看到了Mapper对象的工厂</span></div><div class="line">    MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory)<span class="keyword">this</span>.knownMappers.get(type);</div><div class="line">    <span class="keyword">if</span>(mapperProxyFactory == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 生成Mapper实例，进入看看</span></div><div class="line">            <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + var5, var5);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</div><div class="line">    <span class="comment">// 原来这个还是个代理对象</span></div><div class="line">    MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy(sqlSession, <span class="keyword">this</span>.mapperInterface, <span class="keyword">this</span>.methodCache);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.newInstance(mapperProxy);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>获得Mapper代理对象我看看他是怎么执行Mapper接口的方法的：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">List&lt;User&gt; userList = userMapper.selectList();</div><div class="line"></div><div class="line"><span class="comment">// 一进去就发现直接到了invoke方法，相当于把方法的执行都交给了代理对象去执行</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="keyword">if</span>(Object.class.equals(method.getDeclaringClass())) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</div><div class="line">            <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(var5);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 从当前代理对象处理类MapperProxy的methodCache属性中获取MapperMethod对象,如果methodCache中没有就创建并加进去。</span></div><div class="line">        MapperMethod mapperMethod = <span class="keyword">this</span>.cachedMapperMethod(method);</div><div class="line">        <span class="comment">// 该方法就会调用JDBC执行相应的SQL语句</span></div><div class="line">        <span class="keyword">return</span> mapperMethod.execute(<span class="keyword">this</span>.sqlSession, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</div><div class="line">    Object param;</div><div class="line">    Object result;</div><div class="line">    <span class="comment">// 比对mapper标签</span></div><div class="line">    <span class="keyword">if</span>(SqlCommandType.INSERT == <span class="keyword">this</span>.command.getType()) &#123;</div><div class="line">        param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = <span class="keyword">this</span>.rowCountResult(sqlSession.insert(<span class="keyword">this</span>.command.getName(), param));</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(SqlCommandType.UPDATE == <span class="keyword">this</span>.command.getType()) &#123;</div><div class="line">        param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = <span class="keyword">this</span>.rowCountResult(sqlSession.update(<span class="keyword">this</span>.command.getName(), param));</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(SqlCommandType.DELETE == <span class="keyword">this</span>.command.getType()) &#123;</div><div class="line">        param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = <span class="keyword">this</span>.rowCountResult(sqlSession.delete(<span class="keyword">this</span>.command.getName(), param));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(SqlCommandType.SELECT != <span class="keyword">this</span>.command.getType()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + <span class="keyword">this</span>.command.getName());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.method.returnsVoid() &amp;&amp; <span class="keyword">this</span>.method.hasResultHandler()) &#123;</div><div class="line">            <span class="keyword">this</span>.executeWithResultHandler(sqlSession, args);</div><div class="line">            result = <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.method.returnsMany()) &#123;</div><div class="line">            <span class="comment">// 最终会进入这里</span></div><div class="line">            result = <span class="keyword">this</span>.executeForMany(sqlSession, args);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.method.returnsMap()) &#123;</div><div class="line">            result = <span class="keyword">this</span>.executeForMap(sqlSession, args);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</div><div class="line">            result = sqlSession.selectOne(<span class="keyword">this</span>.command.getName(), param);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(result == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.method.getReturnType().isPrimitive() &amp;&amp; !<span class="keyword">this</span>.method.returnsVoid()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + <span class="keyword">this</span>.command.getName() + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + <span class="keyword">this</span>.method.getReturnType() + <span class="string">")."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>MapperMethod到底如何去执行executeForMap(sqlSession, args)的呢？我们可以继续进入：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 将参数拼接到SQL</span></div><div class="line">        Object param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</div><div class="line">        List result;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.method.hasRowBounds()) &#123;</div><div class="line">            RowBounds rowBounds = <span class="keyword">this</span>.method.extractRowBounds(args);</div><div class="line">            result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param, rowBounds);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 进入到这里，让sqlSession来处理</span></div><div class="line">            result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.method.getReturnType().isAssignableFrom(result.getClass())?(<span class="keyword">this</span>.method.getReturnType().isArray()?<span class="keyword">this</span>.convertToArray(result):<span class="keyword">this</span>.convertToDeclaredCollection(sqlSession.getConfiguration(), result)):result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.selectList(statement, parameter, RowBounds.DEFAULT);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</div><div class="line">    List var6;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 根据StatementId(com.todorex.UserMapper.selectList)，</span></div><div class="line">        <span class="comment">// 在配置对象Configuration中查找相对应的MappedStatement</span></div><div class="line">        MappedStatement ms = <span class="keyword">this</span>.configuration.getMappedStatement(statement);</div><div class="line">        <span class="comment">// 将查询任务委托给MyBatis 的执行器 Executor</span></div><div class="line">        List&lt;E&gt; result = <span class="keyword">this</span>.executor.query(ms, <span class="keyword">this</span>.wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</div><div class="line">        var6 = result;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception var10) &#123;</div><div class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + var10, var10);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        ErrorContext.instance().reset();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> var6;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="comment">// 根据具体传入的参数，动态地生成需要执行的SQL语句，用BoundSql对象表示</span></div><div class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);</div><div class="line">    <span class="comment">// 为当前的查询创建一个缓存Key  </span></div><div class="line">    CacheKey key = <span class="keyword">this</span>.createCacheKey(ms, parameterObject, rowBounds, boundSql);</div><div class="line">    <span class="comment">// 再进去</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="comment">// 获得缓存对象</span></div><div class="line">    Cache cache = ms.getCache();</div><div class="line">    <span class="keyword">if</span>(cache != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.flushCacheIfRequired(ms);</div><div class="line">        <span class="keyword">if</span>(ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.ensureNoOutParams(ms, parameterObject, boundSql);</div><div class="line">            <span class="comment">// 如果缓存中有查询结果，则返回查询结果</span></div><div class="line">            List&lt;E&gt; list = (List)<span class="keyword">this</span>.tcm.getObject(cache, key);</div><div class="line">            <span class="keyword">if</span>(list == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// 如果缓存中没有查询结果则查询数据库</span></div><div class="line">                list = <span class="keyword">this</span>.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</div><div class="line">                <span class="comment">// 将查询结果放入缓存中</span></div><div class="line">                <span class="keyword">this</span>.tcm.putObject(cache, key, list);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> list;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果没有缓存对象则查询数据库（进入这里）</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.closed) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</div><div class="line">            <span class="keyword">this</span>.clearLocalCache();</div><div class="line">        &#125;</div><div class="line">        List list;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ++<span class="keyword">this</span>.queryStack;</div><div class="line">            list = resultHandler == <span class="keyword">null</span>?(List)<span class="keyword">this</span>.localCache.getObject(key):<span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span>(list != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">this</span>.handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 缓存中没有值，直接从数据库中读取数据（进入这里）</span></div><div class="line">                list = <span class="keyword">this</span>.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            --<span class="keyword">this</span>.queryStack;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="keyword">this</span>.localCache.putObject(key, ExecutionPlaceholder.EXECUTION_PLACEHOLDER);</div><div class="line">    List list;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 执行查询返回List 结果（进入这里）</span></div><div class="line">        list = <span class="keyword">this</span>.doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// 清楚之前的缓存</span></div><div class="line">        <span class="keyword">this</span>.localCache.removeObject(key);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将查询的结果放入缓存之中</span></div><div class="line">    <span class="keyword">this</span>.localCache.putObject(key, list);</div><div class="line">    <span class="keyword">if</span>(ms.getStatementType() == StatementType.CALLABLE) &#123;</div><div class="line">        <span class="keyword">this</span>.localOutputParameterCache.putObject(key, parameter);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    Statement stmt = <span class="keyword">null</span>;</div><div class="line">    List var9;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Configuration configuration = ms.getConfiguration();</div><div class="line">        <span class="comment">// 创建StatementHandler对象来执行查询操作  </span></div><div class="line">        StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>.wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</div><div class="line">        <span class="comment">// 利用StatementHandler对象创建java.Sql.Statement对象（进入这里）</span></div><div class="line">        stmt = <span class="keyword">this</span>.prepareStatement(handler, ms.getStatementLog());</div><div class="line">        <span class="comment">// 调用StatementHandler.query()方法，返回List结果集 （进入这里）</span></div><div class="line">        var9 = handler.query(stmt, resultHandler);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">this</span>.closeStatement(stmt);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> var9;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="comment">// 创建连接</span></div><div class="line">    Connection connection = <span class="keyword">this</span>.getConnection(statementLog);</div><div class="line">    <span class="comment">// 创建java.Sql.Statement对象，传递给StatementHandler对象</span></div><div class="line">    Statement stmt = handler.prepare(connection);</div><div class="line">    <span class="comment">// 对创建的Statement对象设置参数，即设置SQL语句中占位符设置为指定的参数</span></div><div class="line">    handler.parameterize(stmt);</div><div class="line">    <span class="keyword">return</span> stmt;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="comment">// 调用preparedStatemnt的execute()方法，然后将resultSet交给ResultSetHandler处理</span></div><div class="line">    PreparedStatement ps = (PreparedStatement)statement;</div><div class="line">    ps.execute();</div><div class="line">    <span class="comment">// 使用ResultHandler来处理ResultSet（进入这里）</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.resultSetHandler.handleResultSets(ps);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>终于查询完了，现在可以处理结果了，我们看看handleResultSets(Statement stmt)方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    ErrorContext.instance().activity(<span class="string">"handling results"</span>).object(<span class="keyword">this</span>.mappedStatement.getId());</div><div class="line">    <span class="comment">// 最后的结果集</span></div><div class="line">    List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList();</div><div class="line">    <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</div><div class="line">    ResultSetWrapper rsw = <span class="keyword">this</span>.getFirstResultSet(stmt);</div><div class="line">    List&lt;ResultMap&gt; resultMaps = <span class="keyword">this</span>.mappedStatement.getResultMaps();</div><div class="line">    <span class="keyword">int</span> resultMapCount = resultMaps.size();</div><div class="line">    <span class="keyword">this</span>.validateResultMapsCount(rsw, resultMapCount);</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</div><div class="line">        <span class="comment">// 获得resultMap</span></div><div class="line">        ResultMap resultMap = (ResultMap)resultMaps.get(resultSetCount);</div><div class="line">        <span class="comment">// 这里才开始处理（这里自己去看吧，反正会先处理行值，然后映射成对象，和JDBC一样）</span></div><div class="line">        <span class="keyword">this</span>.handleResultSet(rsw, resultMap, multipleResults, (ResultMapping)<span class="keyword">null</span>);</div><div class="line">        rsw = <span class="keyword">this</span>.getNextResultSet(stmt);</div><div class="line">        <span class="keyword">this</span>.cleanUpAfterHandlingResultSet();</div><div class="line">        ++resultSetCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    String[] resultSets = <span class="keyword">this</span>.mappedStatement.getResulSets();</div><div class="line">    <span class="keyword">if</span>(resultSets != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">while</span>(rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</div><div class="line">            ResultMapping parentMapping = (ResultMapping)<span class="keyword">this</span>.nextResultMaps.get(resultSets[resultSetCount]);</div><div class="line">            <span class="keyword">if</span>(parentMapping != <span class="keyword">null</span>) &#123;</div><div class="line">                String nestedResultMapId = parentMapping.getNestedResultMapId();</div><div class="line">                ResultMap resultMap = <span class="keyword">this</span>.configuration.getResultMap(nestedResultMapId);</div><div class="line">                <span class="keyword">this</span>.handleResultSet(rsw, resultMap, (List)<span class="keyword">null</span>, parentMapping);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            rsw = <span class="keyword">this</span>.getNextResultSet(stmt);</div><div class="line">            <span class="keyword">this</span>.cleanUpAfterHandlingResultSet();</div><div class="line">            ++resultSetCount;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.collapseSingleResultList(multipleResults);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/ec40a82cae28" target="_blank" rel="external">终结篇：MyBatis原理深入解析（一）</a></li>
<li><a href="https://blog.csdn.net/u010425776/article/details/78215845" target="_blank" rel="external"> MyBatis源码解析(二)——动态代理实现函数调用</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：了解完Mybatis的架构，那么它的执行流程又是怎么样的呢？
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Mybatis" scheme="http://bestlixiang.site/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Mybatis(一)_Mybatis架构</title>
    <link href="http://bestlixiang.site/2018/04/16/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Mybatis-%E4%B8%80-Mybatis%E6%9E%B6%E6%9E%84/"/>
    <id>http://bestlixiang.site/2018/04/16/深入SSM/揭秘Mybatis-一-Mybatis架构/</id>
    <published>2018-04-16T07:37:53.000Z</published>
    <updated>2018-04-16T07:38:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：从JDBC到Hibernate再到Mybatis，你可能会使用很多框架，但是你却不知道框架为你解决什么了或是不知道它的整个架构，我们这里就是帮你解决这些问题！<a id="more"></a></p>
<h1 id="为什么要使用Mybatis"><a href="#为什么要使用Mybatis" class="headerlink" title="为什么要使用Mybatis"></a>为什么要使用Mybatis</h1><h2 id="JDBC的使用"><a href="#JDBC的使用" class="headerlink" title="JDBC的使用"></a>JDBC的使用</h2><p>每一个人学Java的数据库操作应该都是从JDBC开始，它基本有以下7个步骤：</p>
<ol>
<li>加载JDBC驱动</li>
<li>建立并获取数据库连接</li>
<li>创建 JDBC Statements 对象</li>
<li>设置SQL语句的传入参数</li>
<li>执行SQL语句并获得查询结果</li>
<li>对查询结果进行转换处理并将处理结果返回；</li>
<li>释放相关资源（关闭Connection，关闭Statement，关闭ResultSet）；</li>
</ol>
<h2 id="JDBC相应的问题"><a href="#JDBC相应的问题" class="headerlink" title="JDBC相应的问题"></a>JDBC相应的问题</h2><ol>
<li>数据库连接频繁的开启和关闭本身就造成了资源的浪费，影响系统的性能</li>
<li>SQL语句基本都散落在各个JAVA类中可读性很差，不利于维护以及做性能调优。</li>
<li>在后台代码中自己需要根据请求的传入参数（参数个数和顺序都不确定）去拼凑相应的SQL语句。</li>
<li>执行SQL语句后，返回的是一个ResultSet结果集，这个时候我们就需要将ResultSet对象的数据取出来，不然等到释放资源时就取不到这些结果信息了。</li>
<li>SQL重复的问题，不利于维护和复用。</li>
</ol>
<h2 id="Mybatis相应的解决"><a href="#Mybatis相应的解决" class="headerlink" title="Mybatis相应的解决"></a>Mybatis相应的解决</h2><ol>
<li>数据库连接的获取和关闭我们可以使用数据库连接池来解决资源浪费的问题。通过连接池就可以反复利用已经建立的连接去访问数据库了。减少连接的开启和关闭的时间。（数据库连接池以及数据源的配置）</li>
<li>将这些SQL语句统一集中放到配置文件或者数据库里面（以key-value的格式存放）。然后通过SQL语句的key值去获取对应的SQL语句。（Mapper文件）</li>
<li>使用一种有别于SQL的语法来嵌入变量（比如使用＃变量名）。这样，SQL语句经过解析后就可以动态的生成符合上下文的SQL语句。（Mapper文件里面的SQL语句）</li>
<li>将结果不做任何处理就直接返回，也有可能将结果转换成一个JavaBean对象返回、一个Map返回、一个List返回等，而且可以将SQL语句和传入参数两部分合起来可以作为数据缓存的key值。（语句标签返回结果的配置）</li>
<li>将重复的代码抽离出来成为独立的一个类，然后在各个需要使用的地方进行引用（SQL代码块）</li>
</ol>
<h1 id="Mybatis架构"><a href="#Mybatis架构" class="headerlink" title="Mybatis架构"></a>Mybatis架构</h1><p><img src="https://upload-images.jianshu.io/upload_images/2062729-58069e90e9c66d5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="mybatis"></p>
<p>这张图超级棒，可以在后面的参考找到出处。我们就按照这个4层进行分析：</p>
<h2 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h2><p>接口调用方式主要有以下两种：</p>
<ol>
<li><p>基于StatementId(命名空间+语句id)，范例如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;?&gt;|<span class="keyword">int</span>|<span class="keyword">void</span> sqlSession select|update|delete|insert(statementId,params)</div></pre></td></tr></table></figure>
</li>
<li><p>基于Mapper接口</p>
<p> MyBatis 将配置文件中的每一个<mapper> 节点抽象为一个 Mapper 接口,这个接口中声明的方法和<mapper> 节点中的<select|update|delete|insert> 节点项对应，即<select|update|delete|insert> 节点的id值为Mapper 接口中的方法名称，parameterType 值表示Mapper 对应方法的入参类型，而resultMap 值则对应了Mapper 接口表示的返回值类型或者返回结果集的元素类型。范例如下：</select|update|delete|insert></select|update|delete|insert></mapper></mapper></p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;mapper namespace="com.todorex.UserMapper"&gt;</div><div class="line">    &lt;select id="selectList" resultType="com.todorex.User"&gt;</div><div class="line">        select * from user</div><div class="line">    &lt;/select&gt;</div><div class="line">&lt;/mapper&gt;</div><div class="line"></div><div class="line">public interface UserMapper &#123;</div><div class="line"></div><div class="line">    List&lt;User&gt; selectList();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 根据MyBatis 的配置规范配置好后，通过SqlSession.getMapper(UserMapper.class)方法，MyBatis会根据相应的接口声明的方法信息，通过<strong>动态代理机 制</strong> 生成一个Mapper 实例，我们调用Mapper接口的某一个方法时，MyBatis会根据这个方法的方法名和参数类型，确定StatementId，底层还是通过StatementId来实现对数据库的操作，MyBatis引用Mapper接口这种调用方式是为了满足面向接口编程的需 要。<strong>（其实还有一个原因是在于，面向接口的编程，使得用户在接口上可以使用注解来配置SQL语句，这样就可以脱离XML配置文件）</strong>。</p>
</li>
</ol>
<h2 id="数据处理层"><a href="#数据处理层" class="headerlink" title="数据处理层"></a>数据处理层</h2><p>数据处理层可以说是MyBatis的核心，它要完成两个功能：</p>
<ol>
<li><p>通过传入参数构建动态SQL语句</p>
<p> MyBatis 通过传入的参数值，使用 OGNL表达式 来动态地构造SQL语句，使得MyBatis有很强的灵活性和扩展性。参数映射指的是对于java 数据类型和jdbc数据类型之间的转换：这里有包括两个过程：</p>
<ol>
<li>查询阶段，我们要将java类型的数据，转换成jdbc类型的数据，通过 preparedStatement.setXXX() 来设值</li>
<li>返回阶段，我们要对resultset查询结果集的jdbcType 数据转换成java 数据类型</li>
</ol>
</li>
<li><p>SQL语句的执行以及封装查询结果集成List<e></e></p>
<p> 动态SQL语句生成之后，MyBatis 将执行SQL语句，并将可能返回的结果集转换成List<e> 列表。MyBatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换，并且有两种支持方式，一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询。</e></p>
</li>
</ol>
<h2 id="框架支持层"><a href="#框架支持层" class="headerlink" title="框架支持层"></a>框架支持层</h2><ol>
<li><p>事务管理机制</p>
<p> 事务管理机制对于ORM框架而言是不可缺少的一部分，事务管理机制的质量也是考量一个ORM框架是否优秀的一个标准。</p>
</li>
<li><p>连接池管理机制</p>
<p> 由于创建一个数据库连接所占用的资源比较大，对于数据吞吐量大和访问量非常大的应用而言，连接池的设计就显得非常重要。</p>
</li>
<li><p>缓存机制<br> 为了提高数据利用率和减小服务器和数据库的压力，MyBatis 会对于一些查询提供会话级别的数据缓存，会将对某一次查询，放置到SqlSession 中，在允许的时间间隔内，对于完全相同的查询，MyBatis会直接将缓存结果返回给用户，而不用再到数据库中查找。</p>
</li>
<li><p>SQL语句的配置方式<br> 传统的MyBatis 配置SQL语句方式就是使用XML文件进行配置的，但是这种方式不能很好地支持面向接口编程的理念，为了支持面向接口的编程，MyBatis 引入了Mapper接口的概念，面向接口的引入，对使用注解来配置SQL语句成为可能，用户只需要在接口上添加必要的注解即可，不用再去配置XML文件了，但是，目前的MyBatis 只是对注解配置SQL语句提供了有限的支持，某些高级功能还是要依赖XML配置文件配置SQL 语句。</p>
</li>
</ol>
<h2 id="引导层"><a href="#引导层" class="headerlink" title="引导层"></a>引导层</h2><p>引导层是配置和启动MyBatis配置信息的方式。MyBatis 提供两种方式来引导MyBatis：</p>
<ul>
<li><p>基于XML配置文件的方式</p>
</li>
<li><p>基于Java API 的方式</p>
</li>
</ul>
<p>范例可以查看官方使用手册：<a href="http://www.mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="external">Mybatis官方使用手册</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/ec40a82cae28" target="_blank" rel="external">终结篇：MyBatis原理深入解析（一）</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：从JDBC到Hibernate再到Mybatis，你可能会使用很多框架，但是你却不知道框架为你解决什么了或是不知道它的整个架构，我们这里就是帮你解决这些问题！
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Mybatis" scheme="http://bestlixiang.site/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>揭秘SpringMVC(一)_.SpringMVC大全解</title>
    <link href="http://bestlixiang.site/2018/04/15/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98SpringMVC-%E4%B8%80-SpringMVC%E5%A4%A7%E5%85%A8%E8%A7%A3/"/>
    <id>http://bestlixiang.site/2018/04/15/深入SSM/揭秘SpringMVC-一-SpringMVC大全解/</id>
    <published>2018-04-15T08:55:34.000Z</published>
    <updated>2018-04-15T08:56:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：现在基于所有的Web应用都离不开Spring，用了Spring，你自然会去用他家的MVC框架——SpringMVC！所以掌握SpringMVC也是非常重要的。<a id="more"></a></p>
<h1 id="SpringMVC请求处理流程总览"><a href="#SpringMVC请求处理流程总览" class="headerlink" title="SpringMVC请求处理流程总览"></a>SpringMVC请求处理流程总览</h1><p>我们可以用下面一张图来介绍SpringMVC的核心组件和请求处理流程：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/springmvc.png" alt="springmvc"></p>
<p>流程中出现的核心组件如下：</p>
<ol>
<li>DispatcherServlet是springmvc中的前端控制器，负责接收request并将request转发给对应的处理组件.</li>
<li>HanlerMapping是springmvc中完成url到controller映射的组件.DispatcherServlet接收request,然后从HandlerMapping查找处理request的controller.</li>
<li>Controller（HandlerAdapter）处理request,并返回ModelAndView对象,Controller是springmvc中负责处理request的组件(类似于struts2中的Action)</li>
<li>ModelAndView是封装Model对象和View对象的组件</li>
<li>ViewResolver是视图解析器，负责解析ModelAndView对象生成对应的View对象</li>
<li>View视图组件，复制渲染页面</li>
</ol>
<p>整个流程的大致流程如下：</p>
<ol>
<li>当request到来时，DispatcherServlet对request进行捕获，并执行doService方法，继而执行doDispatch方法。</li>
<li>HandlerMapping解析请求，并且返回HandlerExecutionChain（其中包含对应的controller和interceptors）</li>
<li>通过HandlerExecutionChain得到Handler相关类，Handler先执行拦截器的pre相关方法，接着执行handler方法，最后调用拦截器的post相关方法</li>
<li>解析handler方法返回的ModelAndView</li>
<li>根据ViewResolver（可以在配置文件中配置，也就是视图解析器）生成View对象</li>
<li>View对象渲染页面并response给客户端</li>
</ol>
<h1 id="SpringMVC请求处理初始化源码分析"><a href="#SpringMVC请求处理初始化源码分析" class="headerlink" title="SpringMVC请求处理初始化源码分析"></a>SpringMVC请求处理初始化源码分析</h1><ol>
<li><p>首先，Tomcat每次启动时都会加载并解析/WEB-INF/web.xml文件，所以可以先从web.xml找突破口（DispatcherServlet的配置），主要代码如下（我们每次都会这样配置）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;servlet &gt;</div><div class="line">    &lt;servlet-name &gt;spring-mvc&lt;/servlet-name&gt;</div><div class="line">    &lt;!-- DispatcherServlet类，这个类在spring-mvc的包下面 --&gt;</div><div class="line">    &lt;servlet-class &gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</div><div class="line">    &lt;!-- 初始化参数，这里主要是读取SpringMVC的一些配置信息，比如：</div><div class="line">    配置注解驱动，静态资源映射，视图解析器，自动扫描装配等相关信息。</div><div class="line">    --&gt;</div><div class="line">    &lt;init-param &gt;</div><div class="line">      &lt;param-name &gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">      &lt;param-value &gt;classpath:/spring-mvc.xml&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;!-- 启动时加载 --&gt;</div><div class="line">    &lt;load-on-startup &gt;1&lt;/load-on-startup&gt;</div><div class="line">  &lt;/servlet&gt;</div><div class="line">  &lt;servlet-mapping &gt;</div><div class="line">    &lt;servlet-name &gt;spring-mvc&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern &gt;/&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>进入DispatchServlet的分析，先看它的类图：</p>
<p> <img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/DispatcherServlet.png" alt="DispatchServlet"></p>
<p> 它是一个Servlet的子类，那么我们就要专注于它的init、service（后续分析）、doGet、doPost等相关方法，在它的父类HttpServeltBean，我们找到了init方法，如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 获取Servlet中的init参数，并创建了一个BeanWapper对象，由子类真正执行BeanWrapper的初始化工作</span></div><div class="line">        <span class="comment">// 但是HttpServeltBean的子类并没有覆盖其initBeanWrapper方法，所以创建的BeanWrapper没有用</span></div><div class="line">        PropertyValues pvs = <span class="keyword">new</span> HttpServletBean.ServletConfigPropertyValues(<span class="keyword">this</span>.getServletConfig(), <span class="keyword">this</span>.requiredProperties);</div><div class="line">        BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</div><div class="line">        ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(<span class="keyword">this</span>.getServletContext());</div><div class="line">        bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, <span class="keyword">this</span>.getEnvironment()));</div><div class="line">        <span class="keyword">this</span>.initBeanWrapper(bw);</div><div class="line">        bw.setPropertyValues(pvs, <span class="keyword">true</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (BeansException var4) &#123;</div><div class="line">        <span class="keyword">this</span>.logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"'"</span>, var4);</div><div class="line">        <span class="keyword">throw</span> var4;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 这里进要进入到Framework的initServletBean方法了</span></div><div class="line">    <span class="keyword">this</span>.initServletBean();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 从上面的init方法中，我们由它的initServletBean方法进入到FrameworkServlet的initServletBean方法，如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 创建Spring容器，并调用onRefresh方法来完成配置文件的加载</span></div><div class="line">        <span class="keyword">this</span>.webApplicationContext = <span class="keyword">this</span>.initWebApplicationContext();</div><div class="line">        <span class="keyword">this</span>.initFrameworkServlet();</div><div class="line">    &#125; <span class="keyword">catch</span> (ServletException var5) &#123;</div><div class="line">        <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, var5);</div><div class="line">        <span class="keyword">throw</span> var5;</div><div class="line">    &#125; <span class="keyword">catch</span> (RuntimeException var6) &#123;</div><div class="line">        <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, var6);</div><div class="line">        <span class="keyword">throw</span> var6;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 在容器加载的过程中会调用DispatchServlet的initStrategies方法来完成Dispatchservlet中定义的初始化工作，看DispatchServlet的源码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.initStrategies(context);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 初始化SpringMVC框架需要的8个组件，这8个组件对应8个bean对象保存在DispatchServlet类中</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">    <span class="comment">// 用于处理文件上传服务，将Request包装成DefaultMultipartHttpServletRequest</span></div><div class="line">    <span class="keyword">this</span>.initMultipartResolver(context);</div><div class="line">    <span class="comment">// 用于处理应用的国际化问题，控制应用中的字符编码问题</span></div><div class="line">    <span class="keyword">this</span>.initLocaleResolver(context);</div><div class="line">    <span class="comment">// 用于定义一个主题</span></div><div class="line">    <span class="keyword">this</span>.initThemeResolver(context);</div><div class="line">    <span class="comment">// 用于定义用户设置的请求映射关系，将用户请求的URL映射后才能一个个Handler实例</span></div><div class="line">    <span class="comment">// 如果没有定义HandlerMapping，将获取默认的BeanNameURLHandlerMapping和DefaultAnnotaionHandlerMapping</span></div><div class="line">    <span class="keyword">this</span>.initHandlerMappings(context);</div><div class="line">    <span class="comment">// 用于根据Handler的类型定义不同的处理规则（调用Controller实例），默认的为：</span></div><div class="line">    <span class="comment">// HttpRequestHandlerAdapter、SimpleControllerHandlerAdapter、ThrowawayControllerAdapter、AnnotationMethodHandlerAdapter</span></div><div class="line">    <span class="keyword">this</span>.initHandlerAdapters(context);</div><div class="line">    <span class="comment">// 当Handle处理出错时，会通过这个Handler来统一处理，默认为SimpleMappingExceptionResolver，</span></div><div class="line">    <span class="comment">// 将错误日志记录在日志文件中，并且跳转到默认的错误页面</span></div><div class="line">    <span class="keyword">this</span>.initHandlerExceptionResolvers(context);</div><div class="line">    <span class="comment">// 将指定的ViewName按照定义的requestToViewNameTranslator替换成想要的格式，如加上前缀或者后缀。</span></div><div class="line">    <span class="keyword">this</span>.initRequestToViewNameTranslator(context);</div><div class="line">    <span class="comment">// 用于将View解析成页面，在ViewResolvers中可以设置多个解析策略，默认的解析策略为InternalResourceViewResolver，按照JSP页面来解析</span></div><div class="line">    <span class="keyword">this</span>.initViewResolvers(context);</div><div class="line">    <span class="comment">// 为一个请求存储意图为另外一个请求所使用的属性提供了一条途径(通常存储在session)</span></div><div class="line">    <span class="keyword">this</span>.initFlashMapManager(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="SpringMVC请求处理流程源码分析"><a href="#SpringMVC请求处理流程源码分析" class="headerlink" title="SpringMVC请求处理流程源码分析"></a>SpringMVC请求处理流程源码分析</h1><p>关注完初始化init方法，我们要进入正式的流程分析了，其实就是在sevice方法里面(在其父类FrameworkServlet里)，我们看看下面的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span>(HttpMethod.PATCH.matches(request.getMethod())) &#123;</div><div class="line">        <span class="keyword">this</span>.processRequest(request, response);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">super</span>.service(request, response);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据service方法，我们一步步调试进入service –&gt; processRequest –&gt; doService（将ApplicationContext、localeResolver、themeResolver等对象添加到request中以便后面使用） –&gt; doDispatch，我们最终将目光定位在doDispatch，因为从它的方法体就可以看出它是整个SpringMVC的核心方法。我们看看DispatchServlet里面的doDispatch方法源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        HttpServletRequest processedRequest = request;</div><div class="line">        HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</div><div class="line">        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                ModelAndView mv = <span class="keyword">null</span>;</div><div class="line">                Exception dispatchException = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// //处理文件上传请求</span></div><div class="line">                    processedRequest = <span class="keyword">this</span>.checkMultipart(request);</div><div class="line">                    multipartRequestParsed = processedRequest != request;</div><div class="line">                    <span class="comment">// 解析请求（匹配URL），获取HandlerExecutionChain对象</span></div><div class="line">                    mappedHandler = <span class="keyword">this</span>.getHandler(processedRequest);</div><div class="line">                    <span class="keyword">if</span>(mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">this</span>.noHandlerFound(processedRequest, response);</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 从HandlerExecutionChain对象获取HandlerAdapter对象，实际上是从HandlerMapping对象中获取</span></div><div class="line">                    HandlerAdapter ha = <span class="keyword">this</span>.getHandlerAdapter(mappedHandler.getHandler());</div><div class="line">                    String method = request.getMethod();</div><div class="line">                    <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</div><div class="line">                    <span class="keyword">if</span>(isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</div><div class="line">                        <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</div><div class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</div><div class="line">                            <span class="keyword">this</span>.logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="keyword">if</span>((<span class="keyword">new</span> ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                   <span class="comment">// 在controller方法执行前，执行拦截器的相关方法（pre） if(!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span></div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 执行HandlerAdapter对象的handle方法，返回ModelAndView</span></div><div class="line">                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</div><div class="line">                    <span class="keyword">if</span>(asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">this</span>.applyDefaultViewName(processedRequest, mv);</div><div class="line">                   <span class="comment">// 在controller方法执行后，执行拦截器的相关方法（post）</span></div><div class="line">                   mappedHandler.applyPostHandle(processedRequest, response, mv);</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception var19) &#123;</div><div class="line">                    dispatchException = var19;</div><div class="line">                &#125;</div><div class="line">               <span class="comment">// 进行视图解析</span></div><div class="line">               <span class="keyword">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception var20) &#123;</div><div class="line">                <span class="keyword">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var20);</div><div class="line">            &#125; <span class="keyword">catch</span> (Error var21) &#123;</div><div class="line">                <span class="keyword">this</span>.triggerAfterCompletionWithError(processedRequest, response, mappedHandler, var21);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span>(asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">                <span class="keyword">if</span>(mappedHandler != <span class="keyword">null</span>) &#123;</div><div class="line">                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(multipartRequestParsed) &#123;</div><div class="line">                <span class="keyword">this</span>.cleanupMultipart(processedRequest);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>上面是整体的流程，下面我们具体到对MVC架构的三个模块的分析：</p>
<h2 id="Control（C）"><a href="#Control（C）" class="headerlink" title="Control（C）"></a>Control（C）</h2><p>Spring MVC的Control主要由HandlerMapping和HandlerAdapters两个组件提供。</p>
<p>HandlerMapping并没有规定这个URL与应用的处理类如何映射，在这个接口中只定义了根据URL必须返回一个由HandlerExecutionChain代理的处理链，我们可以在这里处理链中添加任意的HandlerAdapters实例来处理这个URL对应的请求。这个和Servlet规范中的filter处理是类似的。</p>
<h3 id="HandlerMapping的初始化"><a href="#HandlerMapping的初始化" class="headerlink" title="HandlerMapping的初始化"></a>HandlerMapping的初始化</h3><p><strong>（可以参照HandlerMapping的子类SimpleUrlHandlerMapping里面的initApplicationContext方法代码）</strong></p>
<p>HandlerMapping的初始化工作完成的两个最重要的工作就是将URL与Handler的对应关系保存在handlerMap集合中，并将所有的<strong>interceptors</strong>对象保存在adaptedInterceptors数组中，等到请求到来时执行所有的adaptedInterceptors数组中的Interceptor对象，所有的Interceptor对象必须实现HandlerInterceptor接口。</p>
<h3 id="HandlerAdapter-可以看成Controller-的初始化"><a href="#HandlerAdapter-可以看成Controller-的初始化" class="headerlink" title="HandlerAdapter(可以看成Controller)的初始化"></a>HandlerAdapter(可以看成Controller)的初始化</h3><p><strong>（可以参照HandlerAdapter的子类SimpleControllerHandlerAdapter里面的代码）</strong></p>
<p>HandlerAdapter的初始化工作主要是创建一个HandlerAdapter对象，将这个HandlerAdapter对象保存在DispatcherServlet的HandlerAdapters集合中。当SpringMVC将某个URL对应到某个Handler时，在HandlerAdapters集合中查询那个HandlerAdapters对象supports这个Handler，那么HandlerAdapters就会被返回（设计模式），并调用这个HandlerAdapters接口对应的方法。如果这个HandlerAdapters对象是SimpleControllerHandlerAdapter，则将调用其ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)方法。如果用户没有定义HandlerAdapter的实现类，默认的为：HttpRequestHandlerAdapter、SimpleControllerHandlerAdapter、ThrowawayControllerAdapter、AnnotationMethodHandlerAdapter。</p>
<h3 id="Control的调用逻辑"><a href="#Control的调用逻辑" class="headerlink" title="Control的调用逻辑"></a>Control的调用逻辑</h3><p>根据DispatcherServlet的doDispath方法我们可以看到通过getHandler方法匹配到某个Handler并返回这个Handler的处理链HandlerExecutionChain对象，而这个HandlerExecutionChain对象将会包含一个匹配上的HandlerAdapter以及用户自定义的多个HandlerInterceptor对象。我们先看HandlerInterceptor接口，在HandlerInterceptor接口中有三个方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</div><div class="line">    <span class="comment">// 在Handler执行前</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">    <span class="comment">// 在Handler执行后</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3, ModelAndView var4)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">    <span class="comment">// 在View渲染完成后，DispatchServlet返回之前执行。</span></div><div class="line">    <span class="comment">// PS：当preHandler返回false时，当前的请求将在执行完该方法后直接返回，Handler不再执行</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3, Exception var4)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们然后看看HandlerExecutionChain类的getHandler方法，你会发现返回的是Object对象，所以在这里Handler对象是没有类型的，Handler的类型是由HandlerAdapter（匹配到的）决定的。接下里执行Handler对象的具体方法，如果Handler对象的相应方法返回一个ModelAndView对象，接下去就去执行View渲染。</p>
<h2 id="Model（M）"><a href="#Model（M）" class="headerlink" title="Model（M）"></a>Model（M）</h2><p>Model实例既在业务逻辑层被使用，也在渲染页面中被使用，我们这里主要讲一下在页面模板渲染中的使用。</p>
<p>如果Handler返回了ModelAndView对象，那么说明Handler需要传一个Model实例给View去渲染模板。可以说ModelAndView对象就是连接业务逻辑层与View视图层的桥梁，对SpringMVC来说它也是连接Handler与View的桥梁。</p>
<p>ModelAndView对象会持有一个ModelMap对象和一个View对象（可以查看ModelAndView的源码），ModelMap对象就是执行模板渲染时所需要的变量对应的实例（对应到Struts2的值栈），如JSP通过request.getAttribute(String)获得JSTL标签名对应的对象。ModelMap其实也是个Map，在Handler中将模板需要的对象存在这个Map中，然后传递到View对应的ViewResolvers中。</p>
<h2 id="View（V）"><a href="#View（V）" class="headerlink" title="View（V）"></a>View（V）</h2><p>Spring MVC的View主要由RequestToViewNameTranslator和ViewResolver两个组件提供。</p>
<ul>
<li>RequestToViewNameTranslator支持用户自定义对ViewName的解析，如加上前缀或者后缀等。</li>
<li>ViewResolver会根据用户的请求的ViewName创建合适的模板引擎（解析器）来渲染最终的页面。ViewResolver会根据ViewName创建一个View对象，调用View对象的render方法渲染页面。</li>
</ul>
<p>我们重点关注这个ViewResolver，先看他的类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/deeplearningSSH/png/viewResolver.png" alt="ViewResolver"></p>
<p>我们从UrlBaseViewResolver对象的loadView方法-&gt;buildView方法可以看到如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> AbstractUrlBasedView <span class="title">buildView</span><span class="params">(String viewName)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    AbstractUrlBasedView view = (AbstractUrlBasedView)BeanUtils.instantiateClass(<span class="keyword">this</span>.getViewClass());</div><div class="line">    view.setUrl(<span class="keyword">this</span>.getPrefix() + viewName + <span class="keyword">this</span>.getSuffix());</div><div class="line">    String contentType = <span class="keyword">this</span>.getContentType();</div><div class="line">    <span class="keyword">if</span>(contentType != <span class="keyword">null</span>) &#123;</div><div class="line">        view.setContentType(contentType);</div><div class="line">    &#125;</div><div class="line">    ... 省略</div><div class="line">    <span class="keyword">return</span> view;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结合类图可以发现不同的解析器生成的View对象是不一样的。</p>
<p>获得View对象之后就可以调用View对象的render方法渲染页面。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《深入分析Java Web技术内幕》</li>
<li><a href="https://blog.csdn.net/lang_programmer/article/details/71598042" target="_blank" rel="external">一步步分析SpringMVC源码</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：现在基于所有的Web应用都离不开Spring，用了Spring，你自然会去用他家的MVC框架——SpringMVC！所以掌握SpringMVC也是非常重要的。
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://bestlixiang.site/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Spring(四)_Spring设计模式</title>
    <link href="http://bestlixiang.site/2018/04/12/%E6%B7%B1%E5%85%A5SSM/%E6%8F%AD%E7%A7%98Spring-%E5%9B%9B-Spring%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/04/12/深入SSM/揭秘Spring-四-Spring设计模式/</id>
    <published>2018-04-12T13:07:10.000Z</published>
    <updated>2018-04-12T13:10:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：说完了IOC和AOP（虽然可能还是不够深入，不够全面，但是对于自己还是有一定的收获，日后有新的领悟再来调整），再来说说Spring这么优秀的框架所使用的的设计模式，可谓遍地都是，我就自己看到写一下。<a id="more"></a></p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">设计模式之禅——单例模式</a>。</p>
<p>Spring应用到的单例模式可以在org.springframework.beans.factory.config.AbstractFactoryBean类中看到这个逻辑。看看它的getObject方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 如果是单例且已经初始化，就直接返回</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.isSingleton()?(<span class="keyword">this</span>.initialized?<span class="keyword">this</span>.singletonInstance:<span class="keyword">this</span>.getEarlySingletonInstance()):<span class="keyword">this</span>.createInstance();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>工厂方法模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">设计模式之禅——工厂方法模式</a>。</p>
<p>Spring应用到的工厂方法模式可以在org.springframework.beans.factory.BeanFactory类中看到这个逻辑。我们看到下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</div><div class="line">    <span class="comment">// 根据唯一标识来获得Bean对象</span></div><div class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String var1)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">设计模式之禅——抽象工厂模式</a>。</p>
<p>Spring应用到的抽象工厂模式可以在org.springframework.beans.factory.BeanFactory类中看到这个逻辑。通过它的实现，我们可以从Spring的容器访问bean。根据采用的策略，getBean方法可以返回已创建的对象（共享实例，单例作用域）或初始化新的对象（原型作用域）。在BeanFactory的实现中，我们可以区分：ClassPathXmlApplicationContext，XmlWebApplicationContext，StaticWebApplicationContext，StaticPortletApplicationContext，GenericApplicationContext，StaticApplicationContext，相当于不同的Creator。</p>
<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式之禅——建造者模式</a>。</p>
<p>Spring应用到的建造者模式可以在org.springframework.beans.factory.support.BeanDefinitionBuilder类中检索这个逻辑。这是一个允许我们以编程方式定义bean的类。BeanDefinitionBuilder包含几个方法，它们为AbstractBeanDefinition抽象类的相关实现设置值，比如作用域，工厂方法，属性等。想看看它是如何工作的，请查看以下这些方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionBuilder</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> AbstractBeanDefinition beanDefinition;</div><div class="line"></div><div class="line">  <span class="comment">// 设置Bean的父类名</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setParentName</span><span class="params">(String parentName)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.setParentName(parentName);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 设置Bean的工厂方法</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setFactoryMethod</span><span class="params">(String factoryMethod)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.setFactoryMethodName(factoryMethod);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 设置Bean的构造函数参数</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">addConstructorArgValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(</div><div class="line">                    <span class="keyword">this</span>.constructorArgIndex++, value);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 添加Bean的属性值</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">addPropertyValue</span><span class="params">(String name, Object value)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.getPropertyValues().add(name, value);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 设置Bean的初始化方法</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setInitMethodName</span><span class="params">(String methodName)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.setInitMethodName(methodName);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 返回建造好的对象</span></div><div class="line">  <span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">getBeanDefinition</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.beanDefinition.validate();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinition;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>原型模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">设计模式之禅——原型模式</a>。</p>
<p>Spring应用到的原型模式可以在org.springframework.beans.factory.support.AbstractBeanFactory类中看到这个逻辑。它使用一种特定的原型设计模式，它先初始化bean原型作用域(克隆)。新对象基于配置文件中的bean定义。</p>
<h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><p>模板模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">设计模式之禅——模板模式</a>。</p>
<p>Spring应用到的模板模式可以在org.springframework.context.support.AbstractApplicationContext类以及它的实现类中看到这个逻辑。它的模板方法是refresh方法，而refreshBeanFactory以及getBeanFactory等方法都由子类具体实现。</p>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><p>访问者模式模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式之禅——访问者模式</a>。</p>
<p>Spring应用到的访问者模式可以在org.springframework.beans.factory.config.BeanDefinitionVisitor类中看到这个逻辑。该对象用于解析bean元数据并将其解析为String（例如：具有作用域或工厂方法名称的XML属性）或Object（例如：构造函数定义中的参数）。已解析的值在与分析的bean关联的BeanDefinition实例中进行判断设置。具体的源码请看BeanDefinitionVisitor的代码片段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionVisitor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitBeanDefinition</span><span class="params">(BeanDefinition beanDefinition)</span> </span>&#123;</div><div class="line">      visitParentName(beanDefinition);</div><div class="line">      visitBeanClassName(beanDefinition);</div><div class="line">      visitFactoryBeanName(beanDefinition);</div><div class="line">      visitFactoryMethodName(beanDefinition);</div><div class="line">      visitScope(beanDefinition);</div><div class="line">      visitPropertyValues(beanDefinition.getPropertyValues());</div><div class="line">      ConstructorArgumentValues cas = beanDefinition.</div><div class="line">        getConstructorArgumentValues();</div><div class="line">      visitIndexedArgumentValues(cas.</div><div class="line">        getIndexedArgumentValues());</div><div class="line">      visitGenericArgumentValues(cas.</div><div class="line">        getGenericArgumentValues());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">visitParentName</span><span class="params">(BeanDefinition beanDefinition)</span> </span>&#123;</div><div class="line">      String parentName = beanDefinition.getParentName();</div><div class="line">      <span class="keyword">if</span> (parentName != <span class="keyword">null</span>) &#123;</div><div class="line">        String resolvedName = resolveStringValue(parentName);</div><div class="line">        <span class="keyword">if</span> (!parentName.equals(resolvedName)) &#123;</div><div class="line">          beanDefinition.setParentName(resolvedName);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式的的原理可以参照<a href="http://bestlixiang.site/2018/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">设计模式之禅——代理模式</a>。</p>
<p>Spring应用到的代理模式可以在org.springframework.aop.framework.ProxyFactoryBean类中看到这个逻辑。详细说明可以参照上一篇文章。</p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">设计模式之禅——策略模式</a>。</p>
<p>Spring应用到的策略模式可以在org.springframework.aop.framework.DefaultAopProxyFactory类中看到这个逻辑。看一下这个类的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !<span class="keyword">this</span>.hasNoUserSuppliedProxyInterfaces(config)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</div><div class="line">            <span class="keyword">if</span>(targetClass == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: Either an interface or a target is required for proxy creation."</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 根据目标类是否有接口而采取不同的策略</span></div><div class="line">                <span class="keyword">return</span> (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass)?<span class="keyword">new</span> ObjenesisCglibAopProxy(config):<span class="keyword">new</span> JdkDynamicAopProxy(config));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>适配器模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">设计模式之禅——适配器模式</a>。</p>
<p>Spring应用到的适配器模式可以在org.springframework.aop.framework.adapter.DefaultAdvisorAdapterRegistry类中看到这个逻辑，Spring需要将每个Advice（通知）都封装成对应的拦截器类型，返回给容器，所以需要使用适配器模式对Advice进行转换。下面我们看看具体的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Adaptee</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">BeforeAdvice</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable</span>;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Target</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvisorAdapter</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span></span>;  </div><div class="line"></div><div class="line">    <span class="function">MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span></span>;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Adapter</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceAdapter</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapter</span>, <span class="title">Serializable</span> </span>&#123;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> (advice <span class="keyword">instanceof</span> MethodBeforeAdvice);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;  </div><div class="line">        MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodBeforeAdviceInterceptor(advice);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式之禅——观察者模式</a>。</p>
<p>Spring应用到的观察者模式可以应用程序上下文相关的事件传输看到这个逻辑，具体一点在AbstractApplicationContext与org.springframework.context.ApplicationListener以及org.springframework.context.event.ApplicationEventMulticaster中看到，我们可以看到下面的相关代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span>, <span class="title">DisposableBean</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义传播者，用来传播消息</span></div><div class="line">    <span class="keyword">private</span> ApplicationEventMulticaster applicationEventMulticaster;</div><div class="line">    <span class="comment">// 注册监听者</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationEventMulticaster</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addApplicationListenerBean</span><span class="params">(String var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeApplicationListenerBean</span><span class="params">(String var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeAllListeners</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(ApplicationEvent var1)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(ApplicationEvent var1, ResolvableType var2)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><p>解释器模式的的原理可以参照<a href="http://bestlixiang.site/2018/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/">设计模式之禅——解释器模式</a>。</p>
<p>Spring应用到的解释器模式主要以Spring Expression Language（SpEL）为例。SpEL是一种由Spring的org.springframework.expression.ExpressionParser实现分析和执行的语言。这些实现使用作为字符串给出的Spel表达式，并将它们转换为org.springframework.expression.Expression的实例。上下文组件由org.springframework.expression.EvaluationContext实现表示，例如：StandardEvaluationContext。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>参考了超级多，都快忘了，各位大佬不要介意！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：说完了IOC和AOP（虽然可能还是不够深入，不够全面，但是对于自己还是有一定的收获，日后有新的领悟再来调整），再来说说Spring这么优秀的框架所使用的的设计模式，可谓遍地都是，我就自己看到写一下。
    
    </summary>
    
      <category term="深入SSM" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5SSM/"/>
    
    
      <category term="Spring" scheme="http://bestlixiang.site/tags/Spring/"/>
    
  </entry>
  
</feed>
