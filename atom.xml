<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rex note</title>
  <subtitle>雨过，云过</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bestlixiang.site/"/>
  <updated>2018-09-07T06:09:05.357Z</updated>
  <id>http://bestlixiang.site/</id>
  
  <author>
    <name>rex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDK源码分析——ThreadLocal</title>
    <link href="http://bestlixiang.site/2018/09/07/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ThreadLocal/"/>
    <id>http://bestlixiang.site/2018/09/07/JDK源码分析/JDK源码分析——ThreadLocal/</id>
    <published>2018-09-07T02:18:38.000Z</published>
    <updated>2018-09-07T06:09:05.357Z</updated>
    
    <content type="html"><![CDATA[<p>引：可能大家对ThreadLocal这个类既熟悉又陌生，看到得多用到得少。<a id="more"></a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>该类提供了线程局部 (thread-local) 变量。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</p>
<p>每个线程都保持对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收（除非存在对这些副本的其他引用）</p>
<p><strong>应用</strong>：在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都要传递一个Connection对象。由于JDBC的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将JDBC的连接保存到ThreadLocal对象中，每个线程都会拥有属于自己的连接。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ThreadLocal&lt;String&gt; myThreadLocal = <span class="keyword">new</span> MyThreadLocal&lt;String&gt;();</div><div class="line"></div><div class="line">        <span class="comment">// 输出leonard</span></div><div class="line">        System.out.println(myThreadLocal.get());</div><div class="line"></div><div class="line">        myThreadLocal.set(<span class="string">"rex"</span>);</div><div class="line">        <span class="comment">// 输出rex</span></div><div class="line">        System.out.println(myThreadLocal.get());</div><div class="line"></div><div class="line">        myThreadLocal.remove();</div><div class="line">        <span class="comment">// 输出leonard</span></div><div class="line">        System.out.println(myThreadLocal.get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (T) <span class="string">"leonard"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="get"><a href="#get" class="headerlink" title="get"></a>get</h1><p>返回线程局部变量的当前线程副本中的值。如果当前线程中保存的变量副本没有值，则先将调用 initialValue() 方法初始化然后返回值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 拿到当前线程</span></div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    <span class="comment">// 拿到 ThreadLocalMap 这个Map</span></div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 拿到节点</span></div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            <span class="comment">// 返回保存的值</span></div><div class="line">            T result = (T)e.value;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 不存在这样的map，则设置初始化，然后返回值</span></div><div class="line">    <span class="keyword">return</span> setInitialValue();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 拿到与ThreadLocal关联的Map</span></div><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="comment">// 与当前线程绑定</span></div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div><div class="line"><span class="comment">// ThreadLocal的数据结构是一个HashMap</span></div><div class="line"><span class="comment">// 节点是继承了 WeakReference(弱引用)</span></div><div class="line"><span class="comment">// 如果一个对象具有弱引用，在GC线程扫描内存区域的过程中，不管当前内存空间足够与否，都会回收内存</span></div><div class="line"><span class="comment">// 我们关注getEntry方法</span></div><div class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    <span class="comment">// 拿到数组下标</span></div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</div><div class="line">    Entry e = table[i];</div><div class="line">    <span class="comment">// Hash值没有冲突</span></div><div class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    <span class="comment">// Hash值冲突</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 拿到节点对应的ThreadLocal(key) 弱引用</span></div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">        <span class="keyword">if</span> (k == key)</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</div><div class="line">            <span class="comment">// 清理数组</span></div><div class="line">            expungeStaleEntry(i);</div><div class="line">        <span class="comment">// 存储到下一个下标里（处理Hash冲突采用的是线性探测法）</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            i = nextIndex(i, len);</div><div class="line">        e = tab[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 设置初始化的值，然后返回</span></div><div class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 拿到初始值</span></div><div class="line">    T value = initialValue();</div><div class="line">    <span class="comment">// 拿到当前线程</span></div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    <span class="comment">// 拿到当前线程的ThreadLocalMap</span></div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="comment">// Map已经存在</span></div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        <span class="comment">// 设置ThreadLocal对应的值</span></div><div class="line">        map.set(<span class="keyword">this</span>, value);</div><div class="line">    <span class="comment">// Map不存在，创建Map</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">    <span class="comment">// 返回该值</span></div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>将线程局部变量在当前线程副本中的值设置为指定值。大部分子类不需要重写此方法，它们只依靠 initialValue() 方法来设置线程局部变量的值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    <span class="comment">// 拿到当前线程</span></div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    <span class="comment">// 拿到当前线程的ThreadLocalMap</span></div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="comment">// 如果Map不为空，则直接设置值</span></div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);</div><div class="line">    <span class="comment">// 如果Map为空，则创建Map，然后设置值</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</div><div class="line">    <span class="comment">// 设置初始容量，默认16</span></div><div class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</div><div class="line">    <span class="comment">// 找到下标</span></div><div class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</div><div class="line">    <span class="comment">// 设置值</span></div><div class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</div><div class="line">    <span class="comment">// 设置size</span></div><div class="line">    size = <span class="number">1</span>;</div><div class="line">    <span class="comment">// 设置阈值</span></div><div class="line">    setThreshold(INITIAL_CAPACITY);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">    <span class="comment">// 设置阈值为 16 * 2 / 3 = 10</span></div><div class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们再来看看Map的set方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</div><div class="line"></div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    <span class="comment">// 根据 ThreadLocal 的 HashCode 得到对应的下标</span></div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</div><div class="line">    <span class="comment">// 首先通过下标找对应的entry对象</span></div><div class="line">    <span class="keyword">for</span> (Entry e = tab[i];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">        <span class="comment">// 改变其值</span></div><div class="line">        <span class="keyword">if</span> (k == key) &#123;</div><div class="line">            e.value = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果key被 GC 回收了，就会变为null（因为是软引用），则创建一个新的 entry 对象填充该槽</span></div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 这个方法可以好好看看</span></div><div class="line">            replaceStaleEntry(key, value, i);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 对象不存在，则创建一个新的 entry对象</span></div><div class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</div><div class="line">    <span class="comment">// size + 1</span></div><div class="line">    <span class="keyword">int</span> sz = ++size;</div><div class="line">    <span class="comment">// 如果没有清除多余的entry 并且数组长度达到了阀值，则扩容</span></div><div class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</div><div class="line">        <span class="comment">// 扩容</span></div><div class="line">        rehash();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 清楚陈旧的节点</span></div><div class="line">    expungeStaleEntries();</div><div class="line"></div><div class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></div><div class="line">    <span class="comment">// 如果size大于0.75倍阈值。原来是2/3， 则负载因子相当于为0.5，这是在第一次的时候</span></div><div class="line">    <span class="comment">// 在首次扩容之后，负载因子还是0.75</span></div><div class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</div><div class="line">        resize();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entry[] oldTab = table;</div><div class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</div><div class="line">    <span class="comment">// 扩容为原来的两倍</span></div><div class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</div><div class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</div><div class="line">        Entry e = oldTab[j];</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</div><div class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</div><div class="line">                    h = nextIndex(h, newLen);</div><div class="line">                newTab[h] = e;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setThreshold(newLen);</div><div class="line">    size = count;</div><div class="line">    table = newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="romove"><a href="#romove" class="headerlink" title="romove"></a>romove</h1><p>移除此线程局部变量在当前线程的值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 得到当前线程的Map</span></div><div class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</div><div class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</div><div class="line">        m.remove(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用ThreadLocalMap的remove方法</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</div><div class="line">    <span class="comment">// 通过线性探测法找到 key 对应的 entry</span></div><div class="line">    <span class="keyword">for</span> (Entry e = tab[i];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</div><div class="line">            <span class="comment">// 将ThreadLocal设置为null</span></div><div class="line">            e.clear();</div><div class="line">            <span class="comment">// 清理所有的 key 为 null 的 entry</span></div><div class="line">            expungeStaleEntry(i);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ThreadLocal无限好，但是也会有问题，比如内存泄漏的问题（可以在后面的参考理解这个问题），为了防止这个问题，我们需要每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/80284438bb97" target="_blank" rel="external">并发编程之 ThreadLocal 源码剖析</a></li>
<li><a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/" target="_blank" rel="external">深入分析 ThreadLocal 内存泄漏问题</a></li>
<li><a href="http://ifeve.com/%E4%BD%BF%E7%94%A8threadlocal%E4%B8%8D%E5%BD%93%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/" target="_blank" rel="external">使用ThreadLocal不当可能会导致内存泄露</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：可能大家对ThreadLocal这个类既熟悉又陌生，看到得多用到得少。
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="http://bestlixiang.site/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析——LinkedHashMap</title>
    <link href="http://bestlixiang.site/2018/09/06/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94LinkedHashMap/"/>
    <id>http://bestlixiang.site/2018/09/06/JDK源码分析/JDK源码分析——LinkedHashMap/</id>
    <published>2018-09-06T01:40:43.000Z</published>
    <updated>2018-09-06T06:31:28.751Z</updated>
    
    <content type="html"><![CDATA[<p>引：如果有这样一种情形，我们需要按照元素插入的顺序来访问元素，这个时候LinkedHashMap大展身手了，它保存着元素插入的顺序，并且可以按照我们插入的顺序进行访问。<a id="more"></a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>LinkedHashMap 继承自 HashMap，在 HashMap 基础上，通过维护一条双向链表，解决了 HashMap 不能随时保持遍历顺序和插入顺序一致的问题。除此之外，LinkedHashMap 对访问顺序也提供了相关支持。在一些场景下，该特性很有用，比如缓存。在实现上，LinkedHashMap 很多方法直接继承自 HashMap，仅为维护双向链表覆写了部分方法。</p>
<p>它的结构示意图如下：<br><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166338955699.jpg" alt="LinkedHashMap"></p>
<h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>主要就是设置初始容量、负载因子和迭代顺序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 双向链表的头，最久访问的</span></div><div class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</div><div class="line"><span class="comment">// 双向链表的尾，最新访问的</span></div><div class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</div><div class="line"><span class="comment">// 默认为false，迭代顺序是按照插入顺序，当为true时，迭代顺序是按照访问信息，最近访问在尾部</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></div><div class="line">                     <span class="keyword">float</span> loadFactor,</div><div class="line">                     <span class="keyword">boolean</span> accessOrder) &#123;</div><div class="line">    <span class="comment">// 后面和HashMap一样</span></div><div class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><p>LinkedHashMap 本身并没有覆写父类的 put 方法，而是直接使用了父类的实现。但在 HashMap 中，put 方法插入的是 HashMap 内部类 Node 类型的节点，该类型的节点并不具备与 LinkedHashMap 内部类 Entry 及其子类型节点组成链表的能力。下面将展示建立链表的逻辑，其中和HashMap相同的代码这里就不多说，不知道的可以在先阅读在后面参考提到的HashMap解析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 调用HashMap的put方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 调用HashMap的putVal方法</span></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">                   <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// 关键就在这里，这里会触发多态，去调用LinkedHashMap的方法</span></div><div class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 3. 多态调用LinkedHashMap的newNode方法</span></div><div class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</div><div class="line">    <span class="comment">// 生成LinkedHashMap需要的节点</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</div><div class="line">    <span class="comment">// 将 Entry 接在双向链表的尾部</span></div><div class="line">    linkNodeLast(p);</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 我们可以看一下这种节点的数据结构</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 拥有前后指针</span></div><div class="line">    Entry&lt;K,V&gt; before, after;</div><div class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">super</span>(hash, key, value, next);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 4. 将新建的节点接在双向链表的尾部</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</div><div class="line">    <span class="comment">// 拿到为节点</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</div><div class="line">    tail = p;</div><div class="line">    <span class="comment">// 如果尾节点不存在，则代表了链表未生成</span></div><div class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</div><div class="line">        head = p;</div><div class="line">    <span class="comment">// 设置指针</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        p.before = last;</div><div class="line">        last.after = p;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 5. 后面的内容就和HashMap一毛一样了</span></div></pre></td></tr></table></figure></p>
<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><p>与插入操作一样，LinkedHashMap 删除操作相关的代码也是直接用父类的实现。在删除节点时，父类的删除逻辑并不会修复 LinkedHashMap 所维护的双向链表。维护操作都在删除及节点后的回调方法 afterNodeRemoval 中。LinkedHashMap 覆写该方法，并在该方法中完成了移除被删除节点的操作。分析方法同上。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 调用HashMap的remove方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 调用HashMap的removeNode方法</span></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></div><div class="line">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// 对应各种类型的节点删除。这些都不会改变链表的结构</span></div><div class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</div><div class="line">                     (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</div><div class="line">    <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</div><div class="line">        ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</div><div class="line">        tab[index] = node.next;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        p.next = node.next;</div><div class="line">    ++modCount;</div><div class="line">    --size;</div><div class="line">    <span class="comment">// 关键的来了，这个操作在HashMap是没有实现的，但是在LinkedHashMap中实现了</span></div><div class="line">    afterNodeRemoval(node);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 3. 调用LinkedHashMap方法的afterNodeRemoval操作来调整链表结构</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></div><div class="line">    <span class="comment">// 拿到删除节点以及它的前驱节点和后继节点</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">    <span class="comment">// 将这两个指针置空</span></div><div class="line">    p.before = p.after = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 如果前驱节点为空，则为头节点</span></div><div class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</div><div class="line">        head = a;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="comment">// 连接前后两个界定啊</span></div><div class="line">        b.after = a;</div><div class="line">    <span class="comment">// 如果前驱节点为空，则为尾节点</span></div><div class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</div><div class="line">        tail = b;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        a.before = b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="改"><a href="#改" class="headerlink" title="改"></a>改</h1><p>与插入操作一样，LinkedHashMap 改操作相关的代码也是直接用父类的实现。分析方法同上。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 调用HashMap的replace方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="comment">// 前面的操作都和HashMap一致</span></div><div class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</div><div class="line">        V oldValue = e.value;</div><div class="line">        e.value = value;</div><div class="line">        <span class="comment">// 重点在修改之后会执行这样一个回调操作</span></div><div class="line">        afterNodeAccess(e);</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 调用LinkedHashMap的afterNodeAccess访问回调方法来调整链表位置</span></div><div class="line"><span class="comment">// 将最近访问的节点，放在链表最后</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</div><div class="line">    <span class="comment">// 当accessOrder为ture 且 访问的不是尾部节点时才进行下面的一顿操作</span></div><div class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</div><div class="line">        <span class="comment">// 拿到访问节点以及它的前驱节点和后继节点</span></div><div class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">        <span class="comment">// 后继节点置空</span></div><div class="line">        p.after = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 前驱节点为头节点</span></div><div class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</div><div class="line">            head = a;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            b.after = a;</div><div class="line">        <span class="comment">// 这里的if/else感觉也都没用，因为都确定不是尾节点了</span></div><div class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</div><div class="line">            a.before = b;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            last = b;</div><div class="line">        <span class="comment">// 表示不会会空，因为都访问到元素了</span></div><div class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</div><div class="line">            head = p;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            p.before = last;</div><div class="line">            last.after = p;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 将访问节点放到尾部</span></div><div class="line">        tail = p;</div><div class="line">        ++modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><p>查操作覆盖了HashMap的方法，但是也只是添加afterNodeAccess操作判断。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 唯一不同的地方，当accessOrder为true时，则调整链表，和在改操作的分析一样</span></div><div class="line">    <span class="keyword">if</span> (accessOrder)</div><div class="line">        afterNodeAccess(e);</div><div class="line">    <span class="keyword">return</span> e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="实现-LRU-缓存"><a href="#实现-LRU-缓存" class="headerlink" title="实现 LRU 缓存"></a>实现 LRU 缓存</h1><p><strong>LRU 缓存</strong>：LRU（Least Recently Used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
<p>大家看到上面的定义就能想到就是在一定条件下删除Head节点嘛，因为最近访问过的都会被放在链表尾部，最近最少使用的一定是投节点。那么LinkedHashMap在哪里为我们留下了实现的接口，我们看看下面的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 可用于实现LRU缓存，evict就表示删除的意思</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</div><div class="line">    <span class="comment">// 根据条件判断是否移除最近最少被访问的节点，主要就是removeEldestEntry方法</span></div><div class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</div><div class="line">        K key = first.key;</div><div class="line">        <span class="comment">// 删除节点</span></div><div class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 默认返会false，就是不删除</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 当然在源码注释中也为我们重写提供了例子</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</div><div class="line">  <span class="comment">// 当大于某个阈值，就移除最老的</span></div><div class="line">  <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://segmentfault.com/a/1190000012964859" target="_blank" rel="external">LinkedHashMap 源码详细分析（JDK1.8）</a></li>
<li><a href="http://todorex.com/2018/09/03/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94HashMap/" target="_blank" rel="external">JDK源码分析——HashMap</a></li>
<li><a href="https://www.jianshu.com/p/06a0fd962e0b" target="_blank" rel="external">Java 中最大的数据结构：LinkedHashMap 了解一下？</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：如果有这样一种情形，我们需要按照元素插入的顺序来访问元素，这个时候LinkedHashMap大展身手了，它保存着元素插入的顺序，并且可以按照我们插入的顺序进行访问。
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="LinkedHashMap" scheme="http://bestlixiang.site/tags/LinkedHashMap/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析——TreeMap</title>
    <link href="http://bestlixiang.site/2018/09/06/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94TreeMap/"/>
    <id>http://bestlixiang.site/2018/09/06/JDK源码分析/JDK源码分析——TreeMap/</id>
    <published>2018-09-06T00:32:02.000Z</published>
    <updated>2018-09-07T02:19:19.434Z</updated>
    
    <content type="html"><![CDATA[<p>引：你想利用的Map高效的查找效率，又想拥有一个有序的Map，这个时候就需要用到TreeMap了!<a id="more"></a></p>
<p>详细注释：<a href="https://github.com/todorex/JDK" target="_blank" rel="external">源码分析地址</a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>TreeMap集合是基于红黑树（Red-Black tree）的 NavigableMap实现。该Map根据其键的自然顺序进行排序，或者根据创建Map时提供的 Comparator 进行排序，具体取决于使用的构造方法。你可以根据自己的需要选择排序的方式。</p>
<p>关于不同步都和之前解析的非同步容器类似。</p>
<h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>在概览中说到我们可以在它构造时传递Comparator来决定排序的方法，所以我们就看看这个构造方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 比较器</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</div><div class="line"><span class="comment">// 根节点</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</div><div class="line"><span class="comment">// 集合大小</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.comparator = comparator;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><p>我们看出在构造方法中只是设置了属性，并没有真正构建红黑树，那么它一定在第一次put操作里。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取根节点</span></div><div class="line">    Entry&lt;K,V&gt; t = root;</div><div class="line">    <span class="comment">// 如果根节点为空，则该元素置为根节点</span></div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</div><div class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></div><div class="line">        <span class="comment">// 新建节点</span></div><div class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</div><div class="line">        <span class="comment">// 改变集合大小和修改次数</span></div><div class="line">        size = <span class="number">1</span>;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cmp;</div><div class="line">    Entry&lt;K,V&gt; parent;</div><div class="line">    <span class="comment">// split comparator and comparable paths</span></div><div class="line">    <span class="comment">// 获得key比较器</span></div><div class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</div><div class="line">    <span class="comment">// 如果比较器对象不为空，也就是自定义了比较器</span></div><div class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="comment">// 循环比较并确定元素应插入的位置(也就是找到该元素的父节点)</span></div><div class="line">            parent = t;</div><div class="line">            cmp = cpr.compare(key, t.key);</div><div class="line">            <span class="comment">// 待插入元素的key小于当前位置元素的key，则查询左子树</span></div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="comment">// 待插入元素的key大于当前位置元素的key，则查询右子树</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                t = t.right;</div><div class="line">            <span class="comment">// 相等则替换其value</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果比较器对象为空，使用默认的比较机制</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 默认机制下不允许设置 null key</span></div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">        <span class="comment">// 和上面的循环做同样的事</span></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            parent = t;</div><div class="line">            cmp = k.compareTo(t.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                t = t.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 根据key找到父节点后新建一个节点</span></div><div class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</div><div class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">        parent.left = e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        parent.right = e;</div><div class="line">    <span class="comment">// 调整红黑树</span></div><div class="line">    fixAfterInsertion(e);</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大概的流程如下：</p>
<ol>
<li>判断根节点是否为空，为空，则该节点就是根节点</li>
<li>根据比较器(可能是外部传进来的，也可能是默认的)，找到父节点。</li>
<li>插入节点之后，就需要用红黑树的修正了。</li>
</ol>
<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">// 利用比较器二分查找</span></div><div class="line">    Entry&lt;K,V&gt; p = getEntry(key);</div><div class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    V oldValue = p.value;</div><div class="line"></div><div class="line">    <span class="comment">// 红黑树删除</span></div><div class="line">    deleteEntry(p);</div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></div><div class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="comment">// 普通的二分查找</span></div><div class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">            p = p.left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">            p = p.right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        K k = (K) key;</div><div class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</div><div class="line">    <span class="comment">// 普通的二分查找</span></div><div class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</div><div class="line">        Entry&lt;K,V&gt; p = root;</div><div class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                p = p.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                p = p.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="改"><a href="#改" class="headerlink" title="改"></a>改</h1><p>找到该key对应的节点，然后替换该值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">// 找到节点</span></div><div class="line">    Entry&lt;K,V&gt; p = getEntry(key);</div><div class="line">    <span class="comment">// 替换值</span></div><div class="line">    <span class="keyword">if</span> (p!=<span class="keyword">null</span>) &#123;</div><div class="line">        V oldValue = p.value;</div><div class="line">        p.value = value;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><p>一批以getFirstEntry()，getLastEntry()为基础的获取头和尾元素的方法，其中包括：firstKey()，lastKey()；firstEntry()，lastEntry()；pollFirstEntry()，pollLastEntry()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  返回第一个节点(值最小的节点)</span></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getFirstEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</div><div class="line">        <span class="comment">// 一直遍历左子树</span></div><div class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</div><div class="line">            p = p.left;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 返回最后一个节点(值最大的节点)</span></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getLastEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</div><div class="line">        <span class="comment">// 一直遍历右子树</span></div><div class="line">        <span class="keyword">while</span> (p.right != <span class="keyword">null</span>)</div><div class="line">            p = p.right;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：你想利用的Map高效的查找效率，又想拥有一个有序的Map，这个时候就需要用到TreeMap了!
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="HashMap" scheme="http://bestlixiang.site/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析——HashSet</title>
    <link href="http://bestlixiang.site/2018/09/06/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94HashSet/"/>
    <id>http://bestlixiang.site/2018/09/06/JDK源码分析/JDK源码分析——HashSet/</id>
    <published>2018-09-06T00:04:49.000Z</published>
    <updated>2018-09-06T00:24:30.280Z</updated>
    
    <content type="html"><![CDATA[<p>引：如果用来有个去重的需求，你肯定会想到用HashSet，那我们看看它的实现！<a id="more"></a></p>
<p>详细注释：<a href="https://github.com/todorex/JDK" target="_blank" rel="external">源码分析地址</a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>它是由哈希表（实际上是一个<strong>HashMap</strong>实例）支持，是不是有点意思？它不保证set的迭代顺序，有且只允许一个null元素，当然其他元素不能重复。</p>
<p>它不是同步容器。如果多个线程同时访问一个哈希set，而其中至少一个线程修改了该 set，那么它必须保持外部同步。这通常是通过对自然封装该set的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” set。最好在创建时完成这一操作，以防止对该set进行意外的不同步访问。</p>
<p>所有这个类的方法返回的迭代器都是快速失败的 ：如果映射在迭代器创建之后的任何时间被结构地修改，除了通过迭代器自己的remove方法之外，迭代器将抛出一个ConcurrentModificationException。（老生长谈）</p>
<h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>关于HashSet的操作(下面都是)，基本上都是直接调用底层HashMap的相关方法来完成。所以在后面参考找到自己关于HashMap的文章。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 真的操作的执行者</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</div><div class="line"><span class="comment">// 定义一个"虚拟"的Object对象作为HashMap的value</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line"><span class="comment">// 构造HashMap</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><p>在HashMap新增一个键值对<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><p>在HashMap删除一个键值对<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><p>在HashMap查找key是否存在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.containsKey(o);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>水文一篇，只要记住一点，就是只要理解了HashMap，HashSet is so easy！！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://todorex.com/2018/09/03/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94HashMap/" target="_blank" rel="external">JDK源码分析——HashMap</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：如果用来有个去重的需求，你肯定会想到用HashSet，那我们看看它的实现！
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="HashSet" scheme="http://bestlixiang.site/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析——ConcurrentHashMap</title>
    <link href="http://bestlixiang.site/2018/09/04/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ConcurrentHashMap/"/>
    <id>http://bestlixiang.site/2018/09/04/JDK源码分析/JDK源码分析——ConcurrentHashMap/</id>
    <published>2018-09-04T05:08:53.000Z</published>
    <updated>2018-09-04T13:02:09.721Z</updated>
    
    <content type="html"><![CDATA[<p>引：HashMap是我们平时开发过程中用的比较多的集合，但它是非线程安全的。解决方案有Hashtable和Collections.synchronizedMap(hashMap)，不过这两个方案基本上是对读写进行加锁操作，性能可想而知。所以感谢<strong>Doug Lea</strong>给我们带来了并发安全的ConcurrentHashMap。<a id="more"></a></p>
<p>详细注释：<a href="https://github.com/todorex/JDK" target="_blank" rel="external">源码分析地址</a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。它采用CAS操作和内置锁synchronized来实现同步</p>
<h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>主要就是设置初始容量和负载因子。（很多在HashMap中介绍过的变量和常量，这里就不再次介绍了）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认为null，初始化发生在第一次插入操作，默认大小为16的数组，用来存储Node节点数据，扩容时大小总是2的幂次方</span></div><div class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</div><div class="line"><span class="comment">// 默认为null，扩容时新生成的数组，其大小为原数组的两倍</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</div><div class="line"><span class="comment">// 默认为0，用来控制table的初始化和扩容操作</span></div><div class="line"><span class="comment">// -1：表示table正在初始化</span></div><div class="line"><span class="comment">// -N：表示有N-1个线程正在进行扩容操作</span></div><div class="line"><span class="comment">// 非负情况</span></div><div class="line"><span class="comment">// 如果table未初始化，表示table需要初始化的大小</span></div><div class="line"><span class="comment">// 如果table初始化完成，表示table的阈值，默认是table大小的0.75倍</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</div><div class="line"></div><div class="line"><span class="comment">// 根据initialCapacity初始化</span></div><div class="line"><span class="comment">// initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)没看懂，知道的请call me（难道和0.75有关系？）</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</div><div class="line">               MAXIMUM_CAPACITY :</div><div class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</div><div class="line">    <span class="comment">// 复制给 sizeCtl</span></div><div class="line">    <span class="keyword">this</span>.sizeCtl = cap;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><p>新增节点，可能会（并发）扩容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过Unsafe拿到sizeCtl的地址</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SIZECTL;</div><div class="line"><span class="comment">// 通过Unsafe拿到baseCount的地址</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASECOUNT;</div><div class="line"><span class="comment">// 移动节点的hash值，只在transfer(扩容方法中)新建ForwardingNode设置</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="comment">// 对hashCode进行再散列</span></div><div class="line">    <span class="comment">// 算法为(h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS(0x7fffffff)</span></div><div class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</div><div class="line">    <span class="comment">// 准备遍历table</span></div><div class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 这边加了一个循环，就是不断的尝试</span></div><div class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</div><div class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">            <span class="comment">// 初始化table</span></div><div class="line">            tab = initTable();</div><div class="line">        <span class="comment">// 获取对应下标节点，如果是空，直接插入</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// CAS 进行插入</span></div><div class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</div><div class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</div><div class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果 hash 冲突了</span></div><div class="line">        <span class="comment">// 且 hash 值为 -1(MOVED)，说明是 ForwardingNode 对象（这是一个占位符对象，保存了扩容后的容器）</span></div><div class="line">        <span class="comment">// 表示了正在扩容，需要帮助 Map 进行扩容，以加快速度</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</div><div class="line">            tab = helpTransfer(tab, f);</div><div class="line">        <span class="comment">// 如果 hash 冲突了，且 hash 值不为 -1</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            V oldVal = <span class="keyword">null</span>;</div><div class="line">            <span class="comment">// 同步 f 节点，防止增加链表的时候导致链表成环(会出现死循环)</span></div><div class="line">            <span class="keyword">synchronized</span> (f) &#123;</div><div class="line">                <span class="comment">// 如果对应的下标位置 的节点没有改变</span></div><div class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                    <span class="comment">// 并且 f 节点的hash 值 大于0</span></div><div class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        <span class="comment">// 链表长度</span></div><div class="line">                        binCount = <span class="number">1</span>;</div><div class="line">                        <span class="comment">// 死循环，直到将值添加到链表尾部，并计算链表的长度</span></div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                            K ek;</div><div class="line">                            <span class="comment">// 遇到重复的key，根据标志位覆盖</span></div><div class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                                ((ek = e.key) == key ||</div><div class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                oldVal = e.val;</div><div class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                    e.val = value;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                            Node&lt;K,V&gt; pred = e;</div><div class="line">                            <span class="comment">// 尾部插入</span></div><div class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                          value, <span class="keyword">null</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 如果 f 节点的 has 小于0 并且f 是 树类型</span></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                        Node&lt;K,V&gt; p;</div><div class="line">                        binCount = <span class="number">2</span>;</div><div class="line">                        <span class="comment">// 插入树中</span></div><div class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</div><div class="line">                            oldVal = p.val;</div><div class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                p.val = value;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 链表长度大于等于8时，将该节点改成红黑树树</span></div><div class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                    treeifyBin(tab, i);</div><div class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> oldVal;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 判断是否需要扩容CAS</span></div><div class="line">    addCount(<span class="number">1L</span>, binCount);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 初始化table</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</div><div class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 如果一个线程发现sizeCtl&lt;0，意味着另外的线程执行CAS操作成功</span></div><div class="line">        <span class="comment">// 当前线程只需要让出cpu时间片</span></div><div class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</div><div class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></div><div class="line">        <span class="comment">// CAS 修改 sizeCtl 的值为-1</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// sc 在初始化的时候用户可能会自定义，如果没有自定义，则是默认的16</span></div><div class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</div><div class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</div><div class="line">                    table = tab = nt;</div><div class="line">                    <span class="comment">// 计算后作为扩容的阀值(相当于乘以0.75)</span></div><div class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                sizeCtl = sc;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tab;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Helps transfer if a resize is in progress.</div><div class="line"> * 如果正在扩容，则帮助扩容</div><div class="line"> */</div><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</div><div class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</div><div class="line">    <span class="comment">// 如果 table 不是空 且 node 节点是转移节点</span></div><div class="line">    <span class="comment">// // 且 node 节点的 nextTable（新 table） 不是空</span></div><div class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</div><div class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 根据 length 得到一个标识符号</span></div><div class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</div><div class="line">        <span class="comment">// 如果 nextTab 没有被并发修改 且 tab 也没有被并发修改 且 sizeCtl  &lt; 0 （说明还在扩容）</span></div><div class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</div><div class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</div><div class="line">             <span class="comment">// 如果 sizeCtl 无符号右移  16 不等于 rs （ sc前 16 位如果不等于标识符，则标识符变化了）</span></div><div class="line">             <span class="comment">// 或者 sizeCtl == rs + 1  （扩容结束了，不再有线程进行扩容）（默认第一个线程设置 sc ==rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。这个时候，sc 就等于 rs + 1）</span></div><div class="line">             <span class="comment">// 或者 sizeCtl == rs + 65535  （如果达到最大帮助线程的数量，即 65535）</span></div><div class="line">             <span class="comment">// 或者转移下标正在调整 （扩容结束）</span></div><div class="line">             <span class="comment">// 结束循环，返回 table</span></div><div class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</div><div class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="comment">// 如果以上都不是, 将 sizeCtl + 1, （表示增加了一个线程帮助其扩容）</span></div><div class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</div><div class="line">                <span class="comment">// 扩容</span></div><div class="line">                transfer(tab, nextTab);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nextTab;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> table;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 判断是否需要扩容，需要则进行扩容</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</div><div class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</div><div class="line">    <span class="comment">// 如果计数盒子不是空 或者 修改 baseCount 失败</span></div><div class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</div><div class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</div><div class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</div><div class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">// 如果计数盒子是空（尚未出现并发）或者 随机取余一个数组位置为空</span></div><div class="line">        <span class="comment">// 或者 修改这个槽位的变量失败（出现并发了）</span></div><div class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</div><div class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</div><div class="line">            !(uncontended =</div><div class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</div><div class="line">            <span class="comment">// CAS增加</span></div><div class="line">            fullAddCount(x, uncontended);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="comment">// 统计size</span></div><div class="line">        s = sumCount();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果需要检查,检查是否需要扩容，在 putVal 方法调用时，默认就是要检查的。</span></div><div class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</div><div class="line">        <span class="comment">// 如果map.size() 大于 sizeCtl（达到扩容阈值需要扩容）</span></div><div class="line">        <span class="comment">// 且table 不是空；且 table 的长度小于 1 &lt;&lt; 30。（可以扩容）</span></div><div class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</div><div class="line">            <span class="keyword">int</span> rs = resizeStamp(n</div><div class="line">            <span class="comment">// 如果正在扩容</span></div><div class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 如果 sc 的低 16 位不等于 标识符（校验异常 sizeCtl 变化了）</span></div><div class="line">                <span class="comment">// 如果 sc == 标识符 + 1 （扩容结束了，不再有线程进行扩容）（默认第一个线程设置 sc ==rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。这个时候，sc 就等于 rs + 1）</span></div><div class="line">                <span class="comment">// 如果 sc == 标识符 + 65535（帮助线程数已经达到最大）</span></div><div class="line">                <span class="comment">// 如果 nextTable == null（结束扩容了）</span></div><div class="line">                <span class="comment">// 如果 transferIndex &lt;= 0 (转移状态变化了)</span></div><div class="line">                <span class="comment">// 结束循环</span></div><div class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</div><div class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</div><div class="line">                    transferIndex &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="comment">// 如果可以帮助扩容，那么将 sc 加 1. 表示多了一个线程在帮助扩容</span></div><div class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</div><div class="line">                    <span class="comment">// 扩容(有点复杂，设计到并发扩容，可以在后面的参考找到文章，这里就不分析了)</span></div><div class="line">                    transfer(tab, nt);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果不在扩容，将 sc 更新：标识符左移 16 位 然后 + 2. 也就是变成一个负数。高 16 位是标识符，低 16 位初始是 2.</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</div><div class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</div><div class="line">                <span class="comment">// 更新 sizeCtl 为负数后，开始扩容。</span></div><div class="line">                transfer(tab, <span class="keyword">null</span>);</div><div class="line">            <span class="comment">// 统计size</span></div><div class="line">            s = sumCount();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><p>根据key删除键值对，如果key不存在，什么也不做<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 用新cv取代原来的value，如果value是null，就代表删除</span></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</div><div class="line">    <span class="comment">// 计算key的hash值</span></div><div class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</div><div class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</div><div class="line">        <span class="comment">// table为空 或 容量为0 或 不存在</span></div><div class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</div><div class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">// 正在扩容</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</div><div class="line">            <span class="comment">// 协助扩容</span></div><div class="line">            tab = helpTransfer(tab, f);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            V oldVal = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">// 同步删除</span></div><div class="line">            <span class="keyword">synchronized</span> (f) &#123;</div><div class="line">                <span class="comment">// 桶中的第一个结点没有发生变化</span></div><div class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                    <span class="comment">// 替换链表中的节点</span></div><div class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        validated = <span class="keyword">true</span>;</div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;;) &#123;</div><div class="line">                            K ek;</div><div class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                                ((ek = e.key) == key ||</div><div class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                V ev = e.val;</div><div class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</div><div class="line">                                    (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</div><div class="line">                                    oldVal = ev;</div><div class="line">                                    <span class="comment">// value不为null，替换</span></div><div class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</div><div class="line">                                        e.val = value;</div><div class="line">                                    <span class="comment">// value为null，删除</span></div><div class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</div><div class="line">                                        <span class="comment">// 前驱的后继为e的后继，即删除了e结点</span></div><div class="line">                                        pred.next = e.next;</div><div class="line">                                    <span class="keyword">else</span></div><div class="line">                                        setTabAt(tab, i, e.next);</div><div class="line">                                &#125;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                            pred = e;</div><div class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 替换红黑树中的节点</span></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                        validated = <span class="keyword">true</span>;</div><div class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class="line">                        TreeNode&lt;K,V&gt; r, p;</div><div class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                            (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</div><div class="line">                            V pv = p.val;</div><div class="line">                            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</div><div class="line">                                (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</div><div class="line">                                oldVal = pv;</div><div class="line">                                <span class="comment">// value不为null，替换</span></div><div class="line">                                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</div><div class="line">                                    p.val = value;</div><div class="line">                                <span class="comment">// value为null，删除</span></div><div class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</div><div class="line">                                    <span class="comment">// 返回为true，去树化</span></div><div class="line">                                    setTabAt(tab, i, untreeify(t.first));</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (validated) &#123;</div><div class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</div><div class="line">                        <span class="comment">// 总数-1</span></div><div class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</div><div class="line">                    <span class="keyword">return</span> oldVal;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="改"><a href="#改" class="headerlink" title="改"></a>改</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || oldValue == <span class="keyword">null</span> || newValue == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="comment">// 对于replaceNode方法在删除操作中已经解析过了</span></div><div class="line">    <span class="keyword">return</span> replaceNode(key, newValue, oldValue) != <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><p>根据key获取value<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</div><div class="line">    <span class="comment">// 计算key的hash</span></div><div class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</div><div class="line">    <span class="comment">// table不为空</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 判断头节点是否符合</span></div><div class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</div><div class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</div><div class="line">                <span class="keyword">return</span> e.val;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 在树中查找，小于0的代表了树的根节点，因为树的根节点的哈希值为TREEBIN（-2）</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</div><div class="line">            <span class="comment">// 调用红黑树的查找方法</span></div><div class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 在链表中查找</span></div><div class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</div><div class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</div><div class="line">                <span class="keyword">return</span> e.val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ConcurrentHashMap 是 Doug Lea 的神作，可以说是精彩绝伦，总的来说，使用了 CAS（扩容并发） 和 synchronized 来保证了 put 操作并发时的危险（特别是链表，防止了死循环的发生），在读方法完全没有锁，完全并发，相比其他线程安全的Map，它的性能真是杠杠滴。写完才发现自己只是打了注释，还没有概括性的话语，缺少了总结，以后需要注意。除此之外，ConcurrentHashMap肯定不是一遍文章就能说完了，以后还需要基础回顾，继续补充。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/d3fda02d4cae" target="_blank" rel="external">java内存模型</a></li>
<li><a href="https://www.jianshu.com/p/a16d638bc921" target="_blank" rel="external">java中的Unsafe</a></li>
<li><a href="https://www.jianshu.com/p/fb6e91b013cc" target="_blank" rel="external">深入浅出CAS</a></li>
<li><a href="https://www.jianshu.com/p/d8eeb31bee5c" target="_blank" rel="external">深入浅出java同步器AQS</a></li>
<li><a href="https://www.jianshu.com/p/4358b1466ec9" target="_blank" rel="external">深入浅出ReentrantLock</a></li>
<li><a href="https://blog.csdn.net/u010771890/article/details/73732648" target="_blank" rel="external">Java并发容器ConcurrentHashMap原理及HashMap死循环原因的分析</a></li>
<li><a href="https://www.jianshu.com/p/29d8e66bc3bf" target="_blank" rel="external">ConcurrentHashMap 源码阅读小结</a></li>
<li><a href="https://www.jianshu.com/p/c0642afe03e0" target="_blank" rel="external">深入浅出ConcurrentHashMap1.8</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：HashMap是我们平时开发过程中用的比较多的集合，但它是非线程安全的。解决方案有Hashtable和Collections.synchronizedMap(hashMap)，不过这两个方案基本上是对读写进行加锁操作，性能可想而知。所以感谢&lt;strong&gt;Doug Lea&lt;/strong&gt;给我们带来了并发安全的ConcurrentHashMap。
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="ConcurrentHashMap" scheme="http://bestlixiang.site/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析——HashMap</title>
    <link href="http://bestlixiang.site/2018/09/03/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94HashMap/"/>
    <id>http://bestlixiang.site/2018/09/03/JDK源码分析/JDK源码分析——HashMap/</id>
    <published>2018-09-03T04:01:02.000Z</published>
    <updated>2018-09-04T01:24:17.117Z</updated>
    
    <content type="html"><![CDATA[<p>引：在Collection接口中用的最多的是ArrayList，在Map接口中用的最多的一定是HashMap，我们今天就来看看HashMap！<a id="more"></a></p>
<p>详细注释：<a href="https://github.com/todorex/JDK" target="_blank" rel="external">源码分析地址</a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>它是基于哈希表实现的Map接口，允许null的值和null键。</p>
<p>HashMap的一个实例有两个影响其性能的参数： 初始容量和负载因子。容量是哈希表中的桶数，初始容量只是创建哈希表时的容量。 负载因子是在容量自动增加之前允许哈希表充满程度的度量。 当在散列表中的条目的数量超过了负载因数和容量的乘积，哈希表将被重新散列 （即内部数据结构被重建），使得哈希表具有桶的大约两倍。</p>
<p>作为一般规则，默认负载因子（0.75）提供了时间和空间成本之间的良好折中。 更高的值会降低空间开销，但会增加查找成本（反映在HashMap类的大部分操作中，包括get和put ）。 在设置其初始容量时，应考虑Map中预期的条目数及其负载因子，以便最小化重新散列操作的数量。 如果初始容量大于最大条目数除以负载因子，则不会发生重新散列操作。</p>
<p>注意，HashMap不同步。 如果多个线程同时访问哈希映射，并且至少有一个线程在结构上修改了映射，那么它必须在外部进行同步。 （结构修改是添加或删除一个或多个映射的任何操作;仅改变与实例已经包含的Key相关联的值不是结构修改。）这通常通过对自然地封装映射的一些对象（ConcurrentMap等）进行同步来实现。 如果没有这样的对象存在，应该使用Collections.synchronizedMap方法“包装”。</p>
<p>所有这个类的方法返回的迭代器都是快速失败的 ：如果映射在迭代器创建之后的任何时间被结构地修改，除了通过迭代器自己的remove方法之外，迭代器将抛出一个ConcurrentModificationException 。</p>
<h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>在构造方法中主要就是设置初始容量和负载因子，如下面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 最大容量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"><span class="comment">// 默认初始容量，一定是2的n次方，这里是16</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</div><div class="line"><span class="comment">// 默认负载因子，这里是0.75</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"><span class="comment">// 这里是Map存放条目的阈值</span></div><div class="line"><span class="keyword">int</span> threshold;</div><div class="line"><span class="comment">// 初始的节点数组，这里Node是个双向节点链表（下面注释中会直接说table）</span></div><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...                                  </span></div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    <span class="comment">// 可能大家觉得阈值应该需要乘以负载因子，先别急，往后看</span></div><div class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 根据所给的目标容量返回大于或等于2的幂次方</span></div><div class="line"><span class="comment">// 感觉这里吊炸天，看不懂的可以看后面参考的博客</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">    <span class="comment">// 这里一定要减1，不然对于本来就是2的幂次方的数，会变成原来的两倍</span></div><div class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里解答一下为什么要是2的幂次方？首先提一个东西就是散列到HashMap中是通过下面的公式：<br><code>hash &amp;(cap-1)</code></p>
<p>假设cap容量为15、16，那么他们减1之后的二进制表达为1110、1111，那么0001、0011、0101、0111, 1001、1011、1101这些桶将永远不会被用到。所以我们需要2的幂次方。</p>
<p>这里既然看到了hash我们就看一下HashMap的hash函数优化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="comment">// 这里叫扰动函数(加入高位特征)，减少hash碰撞，具体的可以看后面参考里的文章</span></div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><p>这里会有很多细节，需要耐心慢慢看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// hash冲突的链表树化阈值（至少为8）</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</div><div class="line"><span class="comment">// 从树还原为链表阈值（小于6）</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</div><div class="line"></div><div class="line"><span class="comment">// 增加键值对，如果key已存在，则覆盖</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">// 返回生成的节点</span></div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="comment">// 初始节点数组table为空或者长度为0</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        <span class="comment">// 生成节点数组（这里会涉及到初始化table或扩容，下面会说），并返回长度</span></div><div class="line">        n = (tab = resize()).length;</div><div class="line">    <span class="comment">// //如果新存放的hash值没有冲突，则放入tab</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 否则就是产生了hash冲突</span></div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="comment">// 如果hash值相等且key值相等, 则令e指向冲突的头节点</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        <span class="comment">// 如果头节点的key值与新插入的key值不等, 并且头结点是TreeNode类型,说明该hash值冲突是采用红黑树进行处理</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">            <span class="comment">// 强转为TreeNode，插入黑红树(本篇文章不谈黑红树的操作，具体的黑红树操作看后续博文，下同)</span></div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="comment">// 否则就是采用链表处理hash值冲突</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 遍历冲突链表, binCount记录hash值冲突链表中节点个数</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="comment">// //当遍历到冲突链表的尾部时</span></div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">// 冲突链表节点大于8个</span></div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        <span class="comment">// 红黑树化</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果在冲突链表中找到相同key值的节点，直接用新的value覆盖原来的value值即可</span></div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="comment">// 判断onlyIfAbsent是否覆盖</span></div><div class="line">            <span class="comment">// true表示仅当&lt;key,value&gt;不存在时进行插入, 为false表示强制覆盖</span></div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            <span class="comment">// 处理访问回调动作</span></div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 修改次数自增</span></div><div class="line">    ++modCount;</div><div class="line">    <span class="comment">// 当键值对数量size达到临界值threhold后, 需要进行扩容操作</span></div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    <span class="comment">// 处理插入回调动作</span></div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>初始化table或者对table进行扩容(默认2倍)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    <span class="comment">// //oldTab变量指向原来的数组</span></div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    <span class="comment">// 用来判断是扩容还是初始化</span></div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line">    <span class="comment">// oldThr变量保存原来数组的阈值</span></div><div class="line">    <span class="keyword">int</span> oldThr = threshold;</div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 如果原来就有东西，就进行扩容操作</span></div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 当大于最大容量时，不扩容，只是改变阈值</span></div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span> oldTab;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// &lt;&lt; 表示乘以2，变为原来的2倍（在操作默认大小的情况下）</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            <span class="comment">// 新阈值也变为原来的2倍</span></div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// oldCap=0, 说明原来的table数组为null，开始初始化</span></div><div class="line">    <span class="comment">// 新创建的容器容量为原来容器中设定的临界值（16）</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line">        newCap = oldThr;</div><div class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line">        <span class="comment">// 在没有设置阈值的情况下</span></div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        <span class="comment">// 初始阈值=默认负载因子*默认初始化容量</span></div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 这里对应的设置了阈值的情况下的初始化，设置阈值</span></div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 给threshold复制，这里应该也就解答了再构造那节提出的疑问了</span></div><div class="line">    threshold = newThr;</div><div class="line">    <span class="comment">// 创建新数组</span></div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 如果原来的数组中存在值, 需要将原来数组中的值保存到新数组中</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;、</div><div class="line">                <span class="comment">// 释放的对象及时置空，等待gc回收</span></div><div class="line">                oldTab[j] = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                    <span class="comment">// 重新hash进入新的数组</span></div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">                    <span class="comment">//如果原来这个节点已经转化为红黑树了，</span></div><div class="line">                    <span class="comment">//那么我们去将树上的节点rehash之后根据hash值放到新地方</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">                    <span class="comment">// 这说明原来数组中保存的hash值存在冲突, 但是并没有采用红黑树对冲突的Hash值进行管理, 而是采用Node链表进行管理</span></div><div class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        <span class="comment">// 如果为真，表明在扩容后(e.hash &amp; (newCap - 1))还会和e.hash &amp; (oldCap - 1)一样</span></div><div class="line">                        <span class="comment">// 如果为假，表名这些节点将hash在（当前下标 + oldCap）下</span></div><div class="line">                        <span class="comment">// 不懂的可以在思考🤔一下,使用这种操作，可以减少重新Hash计算</span></div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                loHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                hiHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        loTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        hiTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// //返回新数组的引用</span></div><div class="line">    <span class="keyword">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//删除key对应的键值对</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</div><div class="line">        <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 删除节点</span></div><div class="line"><span class="comment">// 参数hash为key的hash值;</span></div><div class="line"><span class="comment">// 参数key为要删除的key键;</span></div><div class="line"><span class="comment">// 参数value为key对应的value;</span></div><div class="line"><span class="comment">// 参数matchValue为true表明只有key在HashMap中对应值为value时才删除; 为false表示强制删除;</span></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></div><div class="line">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</div><div class="line">    <span class="comment">// 在table中查找对应hash值</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</div><div class="line">        <span class="comment">// 当头节点就匹配到了</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            node = p;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 如果头节点是个树节点</span></div><div class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                <span class="comment">// 从红黑树中找取节点</span></div><div class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 从链表中找取节点</span></div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key ||</div><div class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">                        node = e;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    p = e;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 匹配找到的节点的值</span></div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</div><div class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</div><div class="line">            <span class="comment">// 树中</span></div><div class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</div><div class="line">                <span class="comment">// 首节点</span></div><div class="line">                tab[index] = node.next;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="comment">// 链表中</span></div><div class="line">                p.next = node.next;</div><div class="line">            ++modCount;</div><div class="line">            --size;</div><div class="line">            afterNodeRemoval(node);</div><div class="line">            <span class="comment">// 返回删除的节点</span></div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="改"><a href="#改" class="headerlink" title="改"></a>改</h1><p>改变对应key的值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e; V v;</div><div class="line">    <span class="comment">// 根据key找出节点</span></div><div class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">        ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</div><div class="line">        e.value = newValue;</div><div class="line">        afterNodeAccess(e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">    <span class="comment">// 找出桶的头结点</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 判断头节点</span></div><div class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 在树中找</span></div><div class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">            <span class="comment">// 在链表中找</span></div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><p>根据key查找值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="comment">// 这里的getNode和上面解析的一样</span></div><div class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="external">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）</a></li>
<li><a href="https://www.cnblogs.com/zhengwang/p/8136164.html" target="_blank" rel="external">HashMap中的hash函数</a></li>
<li><a href="https://blog.csdn.net/carson_ho/article/details/79373134" target="_blank" rel="external">强推👍：Java源码分析：关于 HashMap 1.8 的重大更新</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在Collection接口中用的最多的是ArrayList，在Map接口中用的最多的一定是HashMap，我们今天就来看看HashMap！
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="HashMap" scheme="http://bestlixiang.site/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析——ArrayList</title>
    <link href="http://bestlixiang.site/2018/09/02/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ArrayList/"/>
    <id>http://bestlixiang.site/2018/09/02/JDK源码分析/JDK源码分析——ArrayList/</id>
    <published>2018-09-02T02:16:31.000Z</published>
    <updated>2018-09-02T05:03:20.173Z</updated>
    
    <content type="html"><![CDATA[<p>引：大家在集合框架中用的最多一定是ArrayList吧，今天我们就来一探究竟！<a id="more"></a></p>
<p>详细注释：<a href="https://github.com/todorex/JDK" target="_blank" rel="external">源码分析地址</a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>ArrayList是基于可变数组实现了，允许包括 null 在内的所有元素。</p>
<p>每个 ArrayList 实例都有一个容量。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向 ArrayList 中不断添加元素，其容量也自动增长。</p>
<p>在添加大量元素前，应用程序可以使用 ensureCapacity 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。</p>
<p><strong>注意：</strong> 此实现不是同步的。如果多个线程同时访问一个 ArrayList 实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。（结构上的修改是指任何添加或删除一个或多个元素的操作，或者显式调整底层数组的大小；仅仅设置元素的值不是结构上的修改。）这一般通过对自然封装该列表的对象进行同步操作来完成。如果不存在这样的对象，则应该使用 Collections.synchronizedList 方法将该列表“包装”起来。这最好在创建时完成，以防止意外对列表进行不同步的访问。</p>
<p>此类的 iterator 和 listIterator 方法返回的迭代器是快速失败的：在创建迭代器之后，除非通过迭代器自身的 remove 或 add 方法从结构上对列表进行修改，否则在任何时间以任何方式对列表进行修改，迭代器都会抛出 ConcurrentModificationException。</p>
<p>ArrayList从类 java.util.AbstractList 继承了字段 modCount，在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。</p>
<h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认数组初始大小为10</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 返回空数组</span></div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 新增元素</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="comment">// 确保容量足够</span></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// 如果是默认创建的数组，则和容量默认值比较</span></div><div class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 确保容量足够</span></div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// 修改操作加1</span></div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="comment">// 如果需要的容量比数组长度大，则进行扩容</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>) grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="comment">// 新容量将使原来的1.5倍</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">    <span class="comment">// 1.5倍还不够的话，就将容量设置为需要的大小</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) newCapacity = minCapacity;</div><div class="line">    <span class="comment">// 如果新容量比最大的数组容量（Integer.MAX_VALUE - 8;）还要大，则创建更大的容量（Integer.MAX_VALUE）</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">    <span class="comment">// Arrays.copyOf() 是把原数组整个复制到新数组，这个代价很高</span></div><div class="line">    <span class="comment">// 因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">        Integer.MAX_VALUE :</div><div class="line">        MAX_ARRAY_SIZE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><p>删除需要将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，所以ArrayList 删除元素的代价是非常高的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// 验证index是否超出size大小</span></div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// 拿到值</span></div><div class="line">    E oldValue = elementData(index);</div><div class="line">    <span class="comment">// 统计要移动的位数</span></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        <span class="comment">// 调用系统方法开始拷贝</span></div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    <span class="comment">// 即时放开引用，等待GC</span></div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line">    <span class="comment">// 返回被删除的元素</span></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="改"><a href="#改" class="headerlink" title="改"></a>改</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    <span class="comment">// 验证index是否超出size大小</span></div><div class="line">    rangeCheck(index);</div><div class="line">    <span class="comment">// 拿出原值</span></div><div class="line">    E oldValue = elementData(index);</div><div class="line">    <span class="comment">// 设置新值</span></div><div class="line">    elementData[index] = element;</div><div class="line">    <span class="comment">// 返回被替换的值</span></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// 验证index是否超出size大小</span></div><div class="line">    rangeCheck(index);</div><div class="line">    <span class="keyword">return</span> elementData(index);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// 拿出值</span></div><div class="line">    <span class="keyword">return</span> (E) elementData[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化</span></div><div class="line"><span class="keyword">transient</span> Object[] elementData;</div><div class="line"></div><div class="line"><span class="comment">// 序列化</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></div><div class="line">    <span class="keyword">throws</span> java.io.IOException&#123;</div><div class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></div><div class="line">    <span class="comment">// 记录修改次数，后面可以根据他判断结构是否发生了变化</span></div><div class="line">    <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line">    <span class="comment">// 写入非静态，非暂时数据到流中</span></div><div class="line">    s.defaultWriteObject();</div><div class="line"></div><div class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></div><div class="line">    <span class="comment">// 写入元素个数</span></div><div class="line">    s.writeInt(size);</div><div class="line"></div><div class="line">    <span class="comment">// Write out all elements in the proper order.</span></div><div class="line">    <span class="comment">// 写入元素</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">        s.writeObject(elementData[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。</span></div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 反序列化</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></div><div class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</div><div class="line">    elementData = EMPTY_ELEMENTDATA;</div><div class="line"></div><div class="line">    <span class="comment">// Read in size, and any hidden stuff</span></div><div class="line">    s.defaultReadObject();</div><div class="line"></div><div class="line">    <span class="comment">// Read in capacity</span></div><div class="line">    s.readInt(); <span class="comment">// ignored</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></div><div class="line">        ensureCapacityInternal(size);</div><div class="line"></div><div class="line">        Object[] a = elementData;</div><div class="line">        <span class="comment">// Read in all elements in the proper order.</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">            a[i] = s.readObject();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：大家在集合框架中用的最多一定是ArrayList吧，今天我们就来一探究竟！
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://bestlixiang.site/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="ArrayList" scheme="http://bestlixiang.site/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架类图</title>
    <link href="http://bestlixiang.site/2018/09/02/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%B1%BB%E5%9B%BE/"/>
    <id>http://bestlixiang.site/2018/09/02/Java基础/Java集合框架类图/</id>
    <published>2018-09-02T00:27:20.000Z</published>
    <updated>2018-09-02T00:54:16.648Z</updated>
    
    <content type="html"><![CDATA[<p>引：在阅读集合源码之前，我想先理解其中各个接口以及类图的关系。只要理清了各种关系，你大致的影响就有了，剩下的就是深入源码，去看具体实现。<a id="more"></a></p>
<h1 id="集合接口图"><a href="#集合接口图" class="headerlink" title="集合接口图"></a>集合接口图</h1><p><img src="http://o6plzvjf2.bkt.clouddn.com//java-collection/collection-implement.png" alt="collection-implement"></p>
<h1 id="集合类图"><a href="#集合类图" class="headerlink" title="集合类图"></a>集合类图</h1><p><img src="http://o6plzvjf2.bkt.clouddn.com//java-collection/collection-class.png" alt="collection-class"></p>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>后面我也将围绕这些类及周边类做出JDk源码分析！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在阅读集合源码之前，我想先理解其中各个接口以及类图的关系。只要理清了各种关系，你大致的影响就有了，剩下的就是深入源码，去看具体实现。
    
    </summary>
    
      <category term="Java基础" scheme="http://bestlixiang.site/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://bestlixiang.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>RPC知识</title>
    <link href="http://bestlixiang.site/2018/08/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1/RPC%E7%9F%A5%E8%AF%86/"/>
    <id>http://bestlixiang.site/2018/08/10/微服务/RPC知识/</id>
    <published>2018-08-10T06:17:52.000Z</published>
    <updated>2018-08-10T06:22:16.008Z</updated>
    
    <content type="html"><![CDATA[<p>引：转自<a href="https://www.cnkirito.moe" target="_blank" rel="external">徐靖峰|个人博客</a>的<a href="https://www.cnkirito.moe/categories/RPC/" target="_blank" rel="external">RPC专栏</a>，了解这些才能去看看RPC框架！！！<a id="more"></a></p>
<h1 id="RPC系列博客"><a href="#RPC系列博客" class="headerlink" title="RPC系列博客"></a>RPC系列博客</h1><ol>
<li><a href="https://www.cnkirito.moe/easy-know-rpc/" target="_blank" rel="external">简单了解RPC实现原理</a></li>
<li><a href="https://www.cnkirito.moe/rpc-serialize-1/" target="_blank" rel="external">深入理解RPC之序列化篇–Kryo</a></li>
<li><a href="深入理解RPC之序列化篇--总结篇">深入理解RPC之序列化篇–总结篇</a></li>
<li><a href="https://www.cnkirito.moe/rpc-dynamic-proxy/" target="_blank" rel="external">深入理解RPC之动态代理篇</a></li>
<li><a href="https://www.cnkirito.moe/rpc-transport/" target="_blank" rel="external">深入理解 RPC 之传输篇</a></li>
<li><a href="https://www.cnkirito.moe/motan-async/" target="_blank" rel="external">Motan中使用异步RPC接口</a></li>
<li><a href="https://www.cnkirito.moe/rpc-protocol/" target="_blank" rel="external">深入理解RPC之协议篇</a></li>
<li><a href="https://www.cnkirito.moe/rpc-registry/" target="_blank" rel="external">深入理解RPC之服务注册与发现篇</a></li>
<li><a href="https://www.cnkirito.moe/rpc-cluster/" target="_blank" rel="external">深入理解 RPC 之集群篇</a></li>
<li><a href="https://www.cnkirito.moe/rpc-interface-design/" target="_blank" rel="external">设计RPC接口时，你有考虑过这些吗？</a></li>
</ol>
<h1 id="简单RPC"><a href="#简单RPC" class="headerlink" title="简单RPC"></a>简单RPC</h1><p>可以参考<a href="https://github.com/todorex/rex_rpc" target="_blank" rel="external">todorex/rex_rpc</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：转自&lt;a href=&quot;https://www.cnkirito.moe&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;徐靖峰|个人博客&lt;/a&gt;的&lt;a href=&quot;https://www.cnkirito.moe/categories/RPC/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RPC专栏&lt;/a&gt;，了解这些才能去看看RPC框架！！！
    
    </summary>
    
      <category term="微服务" scheme="http://bestlixiang.site/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="rpc" scheme="http://bestlixiang.site/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码之编码器</title>
    <link href="http://bestlixiang.site/2018/08/06/Netty%E6%BA%90%E7%A0%81/Netty%E6%BA%90%E7%A0%81%E4%B9%8B%E7%BC%96%E7%A0%81%E5%99%A8/"/>
    <id>http://bestlixiang.site/2018/08/06/Netty源码/Netty源码之编码器/</id>
    <published>2018-08-06T08:07:52.000Z</published>
    <updated>2018-08-06T08:19:22.107Z</updated>
    
    <content type="html"><![CDATA[<p>引：上一篇博文讲了解码器对应了读事件，这次就讲一下编码器，对应了写事件。<a id="more"></a></p>
<h1 id="编码器基类"><a href="#编码器基类" class="headerlink" title="编码器基类"></a>编码器基类</h1><p>在Netty中解码器的基类是<strong>MessageToByteEncoder<i> </i></strong>，然后我们要明白的是MessageToByteEncoder其实是一个ChannelOutboundHandlerAdapter。</p>
<p>我们在使用的过程中主要就是覆写它的encode方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, I msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception</span>;</div></pre></td></tr></table></figure>
<p>一个编码器编码的过程主要有如下6个步骤：</p>
<ol>
<li>匹配对象</li>
<li>分配内存</li>
<li>编码实现</li>
<li>释放对象</li>
<li>传播数据</li>
<li>释放内存</li>
</ol>
<p>当我们知道MessageToByteEncoder是一个Handler的时候，我们就会去找它对事件的处理方法，主要是写事件，所以我们找到写事件处理方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    ByteBuf buf = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 判断是否能够处理该对象</span></div><div class="line">        <span class="comment">// step 2</span></div><div class="line">        <span class="keyword">if</span> (acceptOutboundMessage(msg)) &#123;</div><div class="line">            <span class="comment">// 能处理</span></div><div class="line">            I cast = (I) msg;</div><div class="line">            <span class="comment">// 内存分配(默认分配堆外内存 )</span></div><div class="line">            buf = allocateBuffer(ctx, cast, preferDirect);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 开始调用我们覆写的encode方法了</span></div><div class="line">                encode(ctx, cast, buf);</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="comment">// 释放对象</span></div><div class="line">                ReferenceCountUtil.release(cast);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (buf.isReadable()) &#123;</div><div class="line">                <span class="comment">// 传播数据，一直传播到head节点处理</span></div><div class="line">                ctx.write(buf, promise);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 如果编码没有成功，则是否内存</span></div><div class="line">                buf.release();</div><div class="line">                ctx.write(Unpooled.EMPTY_BUFFER, promise);</div><div class="line">            &#125;</div><div class="line">            buf = <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 不能处理，则继续传播</span></div><div class="line">            ctx.write(msg, promise);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span>(EncoderException e) &#123;</div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125; <span class="keyword">catch</span>(Throwable e) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EncoderException(e);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</div><div class="line">            buf.release();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> TypeParameterMatcher matcher;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acceptOutboundMessage</span><span class="params">(Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    <span class="keyword">return</span> matcher.match(msg);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// 主要就是判断msg是否是MessageToByteEncoder&lt;I&gt;中的I类型</span></div><div class="line">    <span class="keyword">return</span> type.isInstance(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h1><p>之前自己在ChannelPipeline那章分析到HeadContext的write方法，没有继续往下分析，我们在这里分析：</p>
<p>它主要有这么几个过程：</p>
<ol>
<li>direct化ByteBuf</li>
<li>插入写链表</li>
<li>设置写状态</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    unsafe.write(msg, promise);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</div><div class="line">	<span class="comment">// 该对象负责缓冲写进来的数据</span></div><div class="line">    估算出需要写入的ByteBuf的size outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">    <span class="keyword">int</span> size;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 将待写入的对象过滤,把所有的非直接内存转换成直接内存DirectBuffer</span></div><div class="line">        <span class="comment">// step 3</span></div><div class="line">        msg = filterOutboundMessage(msg);</div><div class="line">        <span class="comment">// 估算出需要写入的ByteBuf的size</span></div><div class="line">        size = pipeline.estimatorHandle().size(msg);</div><div class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</div><div class="line">            size = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span>(Throwable t) &#123;</div><div class="line">        safeSetFailure(promise, t);</div><div class="line">        ReferenceCountUtil.release(msg);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 将信息添加到估算出需要写入的ByteBuf的size</span></div><div class="line">    <span class="comment">// step 4</span></div><div class="line">    outboundBuffer.addMessage(msg, size, promise);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">filterOutboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</div><div class="line">        ByteBuf buf = (ByteBuf) msg;</div><div class="line">        <span class="keyword">if</span> (buf.isDirect()) &#123;</div><div class="line">            <span class="keyword">return</span> msg;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 转换成直接内存DirectBuffer</span></div><div class="line">        <span class="keyword">return</span> newDirectBuffer(buf);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FileRegion) &#123;</div><div class="line">        <span class="keyword">return</span> msg;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4 ChannelOutboundBuffer</span></div><div class="line"><span class="comment">// 一个链表</span></div><div class="line"><span class="comment">// Entry(flushedEntry) --&gt; ... Entry(unflushedEntry) --&gt; ... Entry(tailEntry)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 指向第一个已经flush的节点</span></div><div class="line"><span class="keyword">private</span> Entry flushedEntry;</div><div class="line"><span class="comment">// 指向第一个未flush的节点</span></div><div class="line"><span class="keyword">private</span> Entry unflushedEntry;</div><div class="line"><span class="comment">// 指向末尾节点</span></div><div class="line"><span class="keyword">private</span> Entry tailEntry;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMessage</span><span class="params">(Object msg, <span class="keyword">int</span> size, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 关注这三个指针tailEntry、tailEntry、unflushedEntry</span></div><div class="line">    <span class="comment">// 先包装成一个Entry</span></div><div class="line">    Entry entry = Entry.newInstance(msg, size, total(msg), promise);</div><div class="line">    <span class="comment">// 插入链表</span></div><div class="line">    <span class="keyword">if</span> (tailEntry == <span class="keyword">null</span>) &#123;</div><div class="line">        flushedEntry = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Entry tail = tailEntry;</div><div class="line">        tail.next = entry;</div><div class="line">    &#125;</div><div class="line">    tailEntry = entry;</div><div class="line">    <span class="keyword">if</span> (unflushedEntry == <span class="keyword">null</span>) &#123;</div><div class="line">        unflushedEntry = entry;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 统计当前需要写入到Socket缓存区的字节</span></div><div class="line">    <span class="comment">// step 5</span></div><div class="line">    incrementPendingOutboundBytes(entry.pendingSize, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 5</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">incrementPendingOutboundBytes</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">boolean</span> invokeLater)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(<span class="keyword">this</span>, size);</div><div class="line">    <span class="comment">// 默认缓冲区不能超过64个字节</span></div><div class="line">    <span class="keyword">if</span> (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) &#123;</div><div class="line">        <span class="comment">// 设置写状态</span></div><div class="line">        setUnwritable(invokeLater);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 6</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUnwritable</span><span class="params">(<span class="keyword">boolean</span> invokeLater)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldValue = unwritable;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newValue = oldValue | <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (UNWRITABLE_UPDATER.compareAndSet(<span class="keyword">this</span>, oldValue, newValue)) &#123;</div><div class="line">            <span class="keyword">if</span> (oldValue == <span class="number">0</span> &amp;&amp; newValue != <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 传播不能写事件</span></div><div class="line">                fireChannelWritabilityChanged(invokeLater);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="flush"><a href="#flush" class="headerlink" title="flush()"></a>flush()</h1><p>write不能写了就需要flush了，我们同样也从HeadContext的flush方法开始分析：</p>
<p>它主要有这么几个步骤：</p>
<ol>
<li>添加刷新标志并设置写状态</li>
<li>遍历buffer队列，过滤ByteBuf</li>
<li>调用JDK底层的API进行自旋写</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    unsafe.flush();</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</div><div class="line">    ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    outboundBuffer.addFlush();</div><div class="line">    <span class="comment">// step 5</span></div><div class="line">    flush0();</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFlush</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 指向unflushedEntry</span></div><div class="line">    Entry entry = unflushedEntry;</div><div class="line">    <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (flushedEntry == <span class="keyword">null</span>) &#123;</div><div class="line">            flushedEntry = entry;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="comment">// 设置flush的数量</span></div><div class="line">            flushed++;</div><div class="line">            <span class="keyword">if</span> (!entry.promise.setUncancellable()) &#123;</div><div class="line">                <span class="keyword">int</span> pending = entry.cancel();</div><div class="line">                <span class="comment">// step 4</span></div><div class="line">                decrementPendingOutboundBytes(pending, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">            &#125;</div><div class="line">            entry = entry.next;</div><div class="line">        &#125; <span class="keyword">while</span> ( entry != <span class="keyword">null</span> );</div><div class="line">		<span class="comment">// 将unflushedEntry设置为null</span></div><div class="line">        unflushedEntry = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementPendingOutboundBytes</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">boolean</span> invokeLater, <span class="keyword">boolean</span> notifyWritability)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(<span class="keyword">this</span>, -size);</div><div class="line">    <span class="comment">// 默认缓冲区低于32个字节，则可设置可写</span></div><div class="line">    <span class="keyword">if</span> (notifyWritability &amp;&amp; newWriteBufferSize &lt; channel.config().getWriteBufferLowWaterMark()) &#123;</div><div class="line">        <span class="comment">// 设置可写状态</span></div><div class="line">        setWritable(invokeLater);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 5</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">flush0</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</div><div class="line">    <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span> || outboundBuffer.isEmpty()) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">    <span class="comment">// step 6</span></div><div class="line">    doWrite(outboundBuffer);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 6 NioSocketChannel</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 拿到底层的SocketChannel准备开始底层的操作</span></div><div class="line">    SocketChannel ch = javaChannel();</div><div class="line">    <span class="comment">// 获取循环次数，相当于一个自旋锁，默认16</span></div><div class="line">    <span class="keyword">int</span> writeSpinCount = config().getWriteSpinCount();</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="comment">// 如果buffer里空的</span></div><div class="line">        <span class="keyword">if</span> ( in .isEmpty()) &#123;</div><div class="line">            <span class="comment">// 清理OP_WRITE，防止Reacotr线程再次处理这个Channel</span></div><div class="line">            clearOpWrite();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获取聚合写的最大字节数，默认Integer.MAX_VALUE</span></div><div class="line">        <span class="keyword">int</span> maxBytesPerGatheringWrite = ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();</div><div class="line">        <span class="comment">// 把ByteBuf里的数据写到原生Buffer里</span></div><div class="line">        <span class="comment">// step 7</span></div><div class="line">        ByteBuffer[] nioBuffers = in.nioBuffers(<span class="number">1024</span>, maxBytesPerGatheringWrite);</div><div class="line">        <span class="keyword">int</span> nioBufferCnt = in.nioBufferCount();</div><div class="line">        <span class="comment">// 对非Buffer对象（FileRegion）的数据进行普通的读写</span></div><div class="line">        <span class="keyword">switch</span> (nioBufferCnt) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">0</span>:    </div><div class="line">            <span class="comment">// 没成功，自旋一次</span></div><div class="line">            writeSpinCount -= doWrite0( in );</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">                <span class="comment">// JDK NIO 支持一次写单个ByteBuffer 以及 一次写多个ByteBuffer的聚集写模式</span></div><div class="line">                <span class="comment">// 如果只有一个buffer的情况下，直接把这个buffer写进去</span></div><div class="line">                ByteBuffer buffer = nioBuffers[<span class="number">0</span>];</div><div class="line">                <span class="keyword">int</span> attemptedBytes = buffer.remaining();</div><div class="line">                <span class="comment">// 调用JDK底层的API进行写，完毕</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> localWrittenBytes = ch.write(buffer);</div><div class="line">                <span class="keyword">if</span> (localWrittenBytes &lt;= <span class="number">0</span>) &#123;</div><div class="line">                    incompleteWrite(<span class="keyword">true</span>);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);</div><div class="line">                <span class="comment">// 释放缓存对象</span></div><div class="line">                in.removeBytes(localWrittenBytes);</div><div class="line">                --writeSpinCount;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            &#123;</div><div class="line">                 <span class="comment">// 多个buffer的情况下，写nioBufferCnt个buffer进去</span></div><div class="line">                <span class="keyword">long</span> attemptedBytes = in.nioBufferSize();</div><div class="line">                <span class="keyword">final</span> <span class="keyword">long</span> localWrittenBytes = ch.write(nioBuffers, <span class="number">0</span>, nioBufferCnt);</div><div class="line">                <span class="keyword">if</span> (localWrittenBytes &lt;= <span class="number">0</span>) &#123;</div><div class="line">                    incompleteWrite(<span class="keyword">true</span>);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                adjustMaxBytesPerGatheringWrite((<span class="keyword">int</span>) attemptedBytes, (<span class="keyword">int</span>) localWrittenBytes, maxBytesPerGatheringWrite); in .removeBytes(localWrittenBytes); --writeSpinCount;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">while</span> ( writeSpinCount &gt; <span class="number">0</span> );</div><div class="line"></div><div class="line">    incompleteWrite(writeSpinCount &lt; <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>知道write和flush那么就很容易理解writeAndFlush啦！！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/feaeaab2ce56" target="_blank" rel="external">etty源码分析之writeAndFlush全解析</a></li>
<li><a href="http://wyj.shiwuliang.com/2018/06/28/Netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94flush%E6%B5%81%E7%A8%8B/" target="_blank" rel="external">Netty源码分析——flush流程</a></li>
<li><a href="https://www.jianshu.com/p/a3443cacd081" target="_blank" rel="external">Netty 源码解析 ——— writeAndFlush流程分析</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：上一篇博文讲了解码器对应了读事件，这次就讲一下编码器，对应了写事件。
    
    </summary>
    
      <category term="Netty源码" scheme="http://bestlixiang.site/categories/Netty%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Netty" scheme="http://bestlixiang.site/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码之解码器</title>
    <link href="http://bestlixiang.site/2018/08/06/Netty%E6%BA%90%E7%A0%81/Netty%E6%BA%90%E7%A0%81%E4%B9%8B%E8%A7%A3%E7%A0%81%E5%99%A8/"/>
    <id>http://bestlixiang.site/2018/08/06/Netty源码/Netty源码之解码器/</id>
    <published>2018-08-06T08:07:37.000Z</published>
    <updated>2018-08-06T08:14:29.964Z</updated>
    
    <content type="html"><![CDATA[<p>引：Netty在帮我们解决性能的同时，也提供了丰富的编解码器来为我们业务上提供便利，这次我们就来看看Netty的解码器。<a id="more"></a></p>
<h1 id="解码器基类"><a href="#解码器基类" class="headerlink" title="解码器基类"></a>解码器基类</h1><p><strong>解码：</strong>就是将二进制数据流解码为自定义数据包。</p>
<p>在Netty中解码器的基类是<strong>ByteToMessageDecoder</strong>，然后我们要明白的是ByteToMessageDecoder其实是一个ChannelInboundHandlerAdapter。</p>
<p>一个解码器解码的过程主要有如下三个步骤：</p>
<ol>
<li>累加字节流</li>
<li>调用子类的decode方法进行解析</li>
<li>将解析到的ByteBuf向下传播</li>
</ol>
<p>当我们知道ByteToMessageDecoder是一个Handler的时候，我们就会去找它对事件的处理方法，主要是读事件，所以我们找到读事件处理方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line">ByteBuf cumulation;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 解码器是相对于ByteBuf进行解码的(在入站的时候已经封装好了，可以参考自己之前关于Pipeline的博文)</span></div><div class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</div><div class="line">        <span class="comment">// 存储解码后的数据 List</span></div><div class="line">        CodecOutputList out = CodecOutputList.newInstance();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ByteBuf data = (ByteBuf) msg;</div><div class="line">            <span class="comment">// 是否是第一次累加</span></div><div class="line">            first = cumulation == <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (first) &#123;</div><div class="line">                <span class="comment">// 第一次</span></div><div class="line">                cumulation = data;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 不是第一次，则进行累加</span></div><div class="line">                <span class="comment">// 我们看看这个累加器的cumulate方法 step 2</span></div><div class="line">                cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 调用子类的decode方法进行解析</span></div><div class="line">            <span class="comment">// step 3</span></div><div class="line">            callDecode(ctx, cumulation, out);</div><div class="line">        &#125; <span class="keyword">catch</span>(DecoderException e) &#123;</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(e);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">int</span> size = out.size();</div><div class="line">            decodeWasNull = !out.insertSinceRecycled();</div><div class="line">            <span class="comment">// 将解析到的对象向下继续传播</span></div><div class="line">            <span class="comment">// step 5</span></div><div class="line">            fireChannelRead(ctx, out, size);</div><div class="line">            <span class="comment">// 回收list</span></div><div class="line">            out.recycle();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 不是ByteBuf就直接向下传播</span></div><div class="line">        ctx.fireChannelRead(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">cumulate</span><span class="params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in )</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ByteBuf buffer;</div><div class="line">    <span class="comment">// 当buf的数据大于cumulation的剩余容量时</span></div><div class="line">    <span class="keyword">if</span> (cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes() || cumulation.refCnt() &gt; <span class="number">1</span> || cumulation.isReadOnly()) &#123;</div><div class="line">		<span class="comment">// 进行扩容(扩容其实就是一个内存拷贝操作)</span></div><div class="line">        buffer = expandCumulation(alloc, cumulation, in.readableBytes());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 不然就不扩容</span></div><div class="line">        buffer = cumulation;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将数据写入buf</span></div><div class="line">    buffer.writeBytes(in);</div><div class="line">    <span class="comment">// 释放传入的buf</span></div><div class="line">    in.release();</div><div class="line">    <span class="keyword">return</span> buffer;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">callDecode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in , List &lt; Object &gt; out)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> ( in .isReadable()) &#123;</div><div class="line">        <span class="keyword">int</span> outSize = out.size();</div><div class="line">        <span class="comment">// 看list是否有对象</span></div><div class="line">        <span class="keyword">if</span> (outSize &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 有对象则将list传播出去</span></div><div class="line">            fireChannelRead(ctx, out, outSize);</div><div class="line">            <span class="comment">// 并清空list</span></div><div class="line">            out.clear();</div><div class="line">            outSize = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 记录可读长度</span></div><div class="line">        <span class="keyword">int</span> oldInputLength = in.readableBytes();</div><div class="line">        <span class="comment">// 开始调用decode方法了</span></div><div class="line">        <span class="comment">// step 4</span></div><div class="line">        decodeRemovalReentryProtection(ctx, in, out);</div><div class="line">        <span class="comment">// 什么都没有解析出来时</span></div><div class="line">        <span class="keyword">if</span> (outSize == out.size()) &#123;</div><div class="line">            <span class="comment">// 代表当前的数据不能拼装成一个完整的数据包，break准备等待下一次数据包</span></div><div class="line">            <span class="keyword">if</span> (oldInputLength == in.readableBytes()) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">decodeRemovalReentryProtection</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in , List &lt; Object &gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">    <span class="comment">// 开始调用解码器子类的decode方法了</span></div><div class="line">    decode(ctx, in, out);</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// step 5</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fireChannelRead</span><span class="params">(ChannelHandlerContext ctx, CodecOutputList msgs, <span class="keyword">int</span> numElements)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements; i++) &#123;</div><div class="line">        <span class="comment">// msgs.getUnsafe(i)保证成byteBuf</span></div><div class="line">        <span class="comment">// 这里可能就会传播到业务的处理器</span></div><div class="line">        ctx.fireChannelRead(msgs.getUnsafe(i));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="LineBasedFrameDecoder"><a href="#LineBasedFrameDecoder" class="headerlink" title="LineBasedFrameDecoder"></a>LineBasedFrameDecoder</h1><p>我们挑选了基于分隔符解码器LineBasedFrameDecoder来分析，它可以同时处理 \n以及\r\n两种类型的行分隔符，我们看看它的decode方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1 (解码器模板)</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in , List &lt; Object &gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    Object decoded = decode(ctx, in);</div><div class="line">    <span class="keyword">if</span> (decoded != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 拆除一个数据包就放进List里</span></div><div class="line">        out.add(decoded);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2 LineBasedFrameDecoder</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> discarding;</div><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf buffer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 找到换行符位置</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> eol = findEndOfLine(buffer);</div><div class="line">    <span class="comment">// 第一次拆包不在丢弃模式下</span></div><div class="line">    <span class="keyword">if</span> (!discarding) &#123;</div><div class="line">        <span class="comment">// 非丢弃模式下</span></div><div class="line">        <span class="comment">// 找到分隔符</span></div><div class="line">        <span class="keyword">if</span> (eol &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">final</span> ByteBuf frame;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> length = eol - buffer.readerIndex();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> delimLength = buffer.getByte(eol) == <span class="string">'\r'</span> ? <span class="number">2</span> : <span class="number">1</span>;</div><div class="line">			<span class="comment">// 判断拆包的长度是否大于允许的最大长度，maxLength构造时传入</span></div><div class="line">            <span class="keyword">if</span> (length &gt; maxLength) &#123;</div><div class="line">                <span class="comment">// 超出最大长度则丢弃这段数据，抛出异常</span></div><div class="line">                buffer.readerIndex(eol + delimLength);</div><div class="line">                fail(ctx, length);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">			<span class="comment">// 解码数据是否要包含分隔符</span></div><div class="line">            <span class="keyword">if</span> (stripDelimiter) &#123;</div><div class="line">                <span class="comment">// 不包含</span></div><div class="line">                frame = buffer.readRetainedSlice(length);</div><div class="line">                buffer.skipBytes(delimLength);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 包含</span></div><div class="line">                frame = buffer.readRetainedSlice(length + delimLength);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 返回拆包后封装成的帧</span></div><div class="line">            <span class="keyword">return</span> frame;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 没找到分隔符</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> length = buffer.readableBytes();</div><div class="line">            <span class="keyword">if</span> (length &gt; maxLength) &#123;</div><div class="line">                <span class="comment">// 如果大于最大长度，进入丢弃模式</span></div><div class="line">                <span class="comment">// 保存丢弃长度</span></div><div class="line">                discardedBytes = length;</div><div class="line">                buffer.readerIndex(buffer.writerIndex());</div><div class="line">                discarding = <span class="keyword">true</span>;</div><div class="line">                offset = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span> (failFast) &#123;</div><div class="line">                    fail(ctx, <span class="string">"over "</span> + discardedBytes);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 不大于，则返回null</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 丢弃模式下</span></div><div class="line">        <span class="keyword">if</span> (eol &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 找到分割符</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> length = discardedBytes + eol - buffer.readerIndex();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> delimLength = buffer.getByte(eol) == <span class="string">'\r'</span> ? <span class="number">2</span> : <span class="number">1</span>;</div><div class="line">            buffer.readerIndex(eol + delimLength);</div><div class="line">            discardedBytes = <span class="number">0</span>;</div><div class="line">            discarding = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (!failFast) &#123;</div><div class="line">                fail(ctx, length);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 保存丢弃长度</span></div><div class="line">            discardedBytes += buffer.readableBytes();</div><div class="line">            <span class="comment">// 改变读指针位置</span></div><div class="line">            buffer.readerIndex(buffer.writerIndex());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其他的解码器也可以根据LineBasedFrameDecoder的思路去分析。当然我们最需要关注的还是整个解码器的设计思想。学会去抽象一类东西。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/dc26e944da95" target="_blank" rel="external">netty源码分析之拆包器的奥秘</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：Netty在帮我们解决性能的同时，也提供了丰富的编解码器来为我们业务上提供便利，这次我们就来看看Netty的解码器。
    
    </summary>
    
      <category term="Netty源码" scheme="http://bestlixiang.site/categories/Netty%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Netty" scheme="http://bestlixiang.site/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码之ChannelPipeline</title>
    <link href="http://bestlixiang.site/2018/08/06/Netty%E6%BA%90%E7%A0%81/Netty%E6%BA%90%E7%A0%81%E4%B9%8BChannelPipeline/"/>
    <id>http://bestlixiang.site/2018/08/06/Netty源码/Netty源码之ChannelPipeline/</id>
    <published>2018-08-06T08:07:14.000Z</published>
    <updated>2018-08-06T08:13:59.182Z</updated>
    
    <content type="html"><![CDATA[<p>引：其实前面就多次提到了ChannelPipeline，但是都没有详细说明ChannelPipeline是如何工作的，这里我们就具体看看这个管理处理逻辑的抽象以及处理逻辑的抽象ChannelHandler。<a id="more"></a></p>
<h1 id="ChannelPipeline的创建"><a href="#ChannelPipeline的创建" class="headerlink" title="ChannelPipeline的创建"></a>ChannelPipeline的创建</h1><p>通过前面的讲解，我们应该还记得一个Channel对应了一个ChannelPipeline，而ChannelPipeline也就是在创建Channel的时候随之创建的。我们就从那里开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1 AbstractChannel的创建</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.parent = parent;</div><div class="line">    id = newId();</div><div class="line">    unsafe = newUnsafe();</div><div class="line">    <span class="comment">// step 2 ChannelPipeline的创建</span></div><div class="line">    pipeline = newChannelPipeline();</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</div><div class="line">    <span class="comment">// 绑定channel</span></div><div class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</div><div class="line">    <span class="comment">// 默认创建一个由头尾节点的双向链表，我们可以看一下节点的类型</span></div><div class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</div><div class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</div><div class="line">    head.next = tail;</div><div class="line">    tail.prev = head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ChannelPipeline创建完毕！！</p>
<h1 id="节点的添加"><a href="#节点的添加" class="headerlink" title="节点的添加"></a>节点的添加</h1><p>节点的添加我们必然要从我们见过的ChannelPipeline的addLast(handler)方法开始分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    <span class="keyword">return</span> addLast(<span class="keyword">null</span>, handler);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(String name, ChannelHandler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    <span class="keyword">return</span> addLast(<span class="keyword">null</span>, name, handler);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</div><div class="line">    <span class="comment">// 同步</span></div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="comment">// 检查是否有重复节点</span></div><div class="line">        checkMultiplicity(handler);</div><div class="line">        <span class="comment">// 将handler包装成节点上下文 DefaultChannelHandlerContext</span></div><div class="line">        <span class="comment">// step 4</span></div><div class="line">        newCtx = newContext(group, filterName(name, handler), handler);</div><div class="line">        <span class="comment">// 添加节点 step 7</span></div><div class="line">        addLast0(newCtx);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 回调处理器被添加的方法</span></div><div class="line">    callHandlerAdded0(newCtx);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">newContext</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 5</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelHandlerContext(<span class="keyword">this</span>, childExecutor(group), name, handler);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 5</span></div><div class="line">DefaultChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) &#123;</div><div class="line">    <span class="comment">// step 6 isInBound,isOutBount已经确定了</span></div><div class="line">    <span class="keyword">super</span>(pipeline, executor, name, isInbound(handler), isOutbound(handler));</div><div class="line">	<span class="comment">// 绑定handler</span></div><div class="line">    <span class="keyword">this</span>.handler = handler;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 6</span></div><div class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name, <span class="keyword">boolean</span> inbound, <span class="keyword">boolean</span> outbound) &#123;</div><div class="line">    <span class="comment">// 设定名字</span></div><div class="line">    <span class="keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">"name"</span>);</div><div class="line">    <span class="comment">// 绑定pipeline</span></div><div class="line">    <span class="keyword">this</span>.pipeline = pipeline;</div><div class="line">    <span class="comment">// 绑定NioEventLoop</span></div><div class="line">    <span class="keyword">this</span>.executor = executor;</div><div class="line">    <span class="comment">// 表示自己是inbound处理器还是outbound处理器，后面根据这个值来判断</span></div><div class="line">    <span class="keyword">this</span>.inbound = inbound;</div><div class="line">    <span class="keyword">this</span>.outbound = outbound;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 7</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLast0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</div><div class="line">    <span class="comment">// 添加到Pipeline的那个双向链表中</span></div><div class="line">    AbstractChannelHandlerContext prev = tail.prev;</div><div class="line">    newCtx.prev = prev;</div><div class="line">    newCtx.next = tail;</div><div class="line">    prev.next = newCtx;</div><div class="line">    tail.prev = newCtx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="节点的删除"><a href="#节点的删除" class="headerlink" title="节点的删除"></a>节点的删除</h1><p>和ChannelPipeline的addLast(handler)一样，我们可以找到ChannelPipeline的remove(handler)方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">remove</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">// 我们知道节点是保证了handler的AbstractChannelHandlerContext</span></div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    remove(getContextOrDie(handler));</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">remove</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> ctx != head &amp;&amp; ctx != tail;</div><div class="line">	<span class="comment">// 同步</span></div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="comment">// step 3</span></div><div class="line">        remove0(ctx);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 回调节点的删除方法</span></div><div class="line">    callHandlerRemoved0(ctx);</div><div class="line">    <span class="keyword">return</span> ctx;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove0</span><span class="params">(AbstractChannelHandlerContext ctx)</span> </span>&#123;</div><div class="line">    <span class="comment">// 就是双向链表的删除</span></div><div class="line">    AbstractChannelHandlerContext prev = ctx.prev;</div><div class="line">    AbstractChannelHandlerContext next = ctx.next;</div><div class="line">    prev.next = next;</div><div class="line">    next.prev = prev;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="入站事件的传播"><a href="#入站事件的传播" class="headerlink" title="入站事件的传播"></a>入站事件的传播</h1><p>其实我们应该已经经历过了，源头都是在从Unsafe对象(它负责最底层的IO操作)出发的，所以我们从NioEventLoop的这一段代码出发：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">    <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 接受IO事件，这里需要注意的是在SeverSocketChannel和SocketChannel处理的事件是不一样的</span></div><div class="line">        <span class="comment">// 我们主要分析SocketChannel的读事件，对应的Unsafe对象是NioByteUnSafe</span></div><div class="line">        <span class="comment">// step 2</span></div><div class="line">        unsafe.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2 AbstractNioByteChannel的NioByteUnSafe</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ChannelConfig config = config();</div><div class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</div><div class="line">    <span class="comment">// 创建ByteBuf分配器</span></div><div class="line">    <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</div><div class="line">    <span class="comment">// 控制连接数</span></div><div class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</div><div class="line">    allocHandle.reset(config);</div><div class="line"></div><div class="line">    ByteBuf byteBuf = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="comment">// 分配一个byteBuf</span></div><div class="line">        byteBuf = allocHandle.allocate(allocator);</div><div class="line">        <span class="comment">// 读数据</span></div><div class="line">        allocHandle.lastBytesRead(doReadBytes(byteBuf));</div><div class="line">        allocHandle.incMessagesRead(<span class="number">1</span>);</div><div class="line">        readPending = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">// 触发读事件，这是我们要关注的重点</span></div><div class="line">        <span class="comment">// step 3</span></div><div class="line">        pipeline.fireChannelRead(byteBuf);</div><div class="line">        byteBuf = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">while</span> ( allocHandle . continueReading ());</div><div class="line"></div><div class="line">    allocHandle.readComplete();</div><div class="line">    <span class="comment">// 触发读完成事件</span></div><div class="line">    pipeline.fireChannelReadComplete();</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// 出发头节点的读事件</span></div><div class="line">    <span class="comment">// step 4</span></div><div class="line">    AbstractChannelHandlerContext.invokeChannelRead(head, msg);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">"msg"</span>), next);</div><div class="line">    <span class="comment">// 调用头节点的channelRead方法</span></div><div class="line">    <span class="comment">// step 5</span></div><div class="line">    next.invokeChannelRead(m);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 5</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// 调用头节点的channelRead方法</span></div><div class="line">    <span class="comment">// step 6</span></div><div class="line">    ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 6</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 继续传递读事件</span></div><div class="line">    <span class="comment">// step 7</span></div><div class="line">    ctx.fireChannelRead(msg);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 7</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// 找到下一个入站节点</span></div><div class="line">    <span class="comment">// step 8 findContextInbound</span></div><div class="line">    <span class="comment">// step 9 会重复这个过程，如果消息没有被释放，那么将一直传递到tail节点(最后一个inbound节点public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span></div><div class="line">    onUnhandledInboundMessage(msg);</div><div class="line">&#125;)</div><div class="line">    invokeChannelRead(findContextInbound(), msg);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 8</span></div><div class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">()</span> </span>&#123;</div><div class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        ctx = ctx.next;</div><div class="line">        <span class="comment">// 可以看到是根据标志位来判定的</span></div><div class="line">    &#125; <span class="keyword">while</span> (! ctx . inbound );</div><div class="line">    <span class="keyword">return</span> ctx;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 9 DefaultChannelPipeline的TailContext</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// step 10</span></div><div class="line">    onUnhandledInboundMessage(msg);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// 如果消息一直没有被释放，将在tail节点被释放</span></div><div class="line">    ReferenceCountUtil.release(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="出站事件的传播"><a href="#出站事件的传播" class="headerlink" title="出站事件的传播"></a>出站事件的传播</h1><p>出站事件一般是写事件，有两种写需要区别一下：（来自netty源码中telnet例子）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ChannelFuture future = ctx.channel().write(response);   <span class="comment">// 1</span></div><div class="line">ChannelFuture future = ctx.write(response); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>我们先看第一种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String request)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    ChannelFuture future = ctx.channel().write(response);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2 AbstractChannel</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    <span class="keyword">return</span> pipeline.write(msg);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3 DefaultChannelPipeline</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">write</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// 直接调用tail的写方法</span></div><div class="line">    <span class="comment">// step 4</span></div><div class="line">    <span class="keyword">return</span> tail.write(msg);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 5 AbstractChannelHandlerContext</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 6</span></div><div class="line">    <span class="keyword">return</span> write(msg, newPromise());</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 6 AbstractChannelHandlerContext</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(<span class="keyword">final</span> Object msg, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 加上是否flush的信息</span></div><div class="line">    <span class="comment">// step 7</span></div><div class="line">    write(msg, <span class="keyword">false</span>, promise);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 7</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 和进站相识，这里找的出站节点</span></div><div class="line">    AbstractChannelHandlerContext next = findContextOutbound();</div><div class="line">    <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</div><div class="line">    EventExecutor executor = next.executor();</div><div class="line">    <span class="keyword">if</span> (flush) &#123;</div><div class="line">        next.invokeWriteAndFlush(m, promise);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 调用下一个出站节点的写方法</span></div><div class="line">        next.invokeWrite(m, promise);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 7</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWrite</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 8    </span></div><div class="line">    invokeWrite0(msg, promise);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 8</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWrite0</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 9 会直接调用到HeadContext的write方法</span></div><div class="line">    ((ChannelOutboundHandler) handler()).write(<span class="keyword">this</span>, msg, promise);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 9</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 利用unsafe写入(明白流程就好，关于具体怎么写入将放到编码器的博文上)</span></div><div class="line">    unsafe.write(msg, promise);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String request)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    ChannelFuture future = ctx.write(response);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(<span class="keyword">final</span> Object msg, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">	<span class="comment">// 直接从当前节点写，后面就和第一种情况一样了</span></div><div class="line">    write(msg, <span class="keyword">false</span>, promise);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/6efa9c5fa702" target="_blank" rel="external">netty源码分析之pipeline(一)</a></li>
<li><a href="https://www.jianshu.com/p/087b7e9a27a2" target="_blank" rel="external">netty源码分析之pipeline(二)</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：其实前面就多次提到了ChannelPipeline，但是都没有详细说明ChannelPipeline是如何工作的，这里我们就具体看看这个管理处理逻辑的抽象以及处理逻辑的抽象ChannelHandler。
    
    </summary>
    
      <category term="Netty源码" scheme="http://bestlixiang.site/categories/Netty%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Netty" scheme="http://bestlixiang.site/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码之新连接接入</title>
    <link href="http://bestlixiang.site/2018/08/06/Netty%E6%BA%90%E7%A0%81/Netty%E6%BA%90%E7%A0%81%E4%B9%8B%E6%96%B0%E8%BF%9E%E6%8E%A5%E6%8E%A5%E5%85%A5/"/>
    <id>http://bestlixiang.site/2018/08/06/Netty源码/Netty源码之新连接接入/</id>
    <published>2018-08-06T08:06:57.000Z</published>
    <updated>2018-08-06T08:13:39.318Z</updated>
    
    <content type="html"><![CDATA[<p>引：之前对服务端和NioEventLoop都有了一定的分析，相信大家的服务端应该已经虚位以待了。好的，我们现在就开始分析<strong>新连接接入</strong>。<a id="more"></a></p>
<h1 id="新连接检测"><a href="#新连接检测" class="headerlink" title="新连接检测"></a>新连接检测</h1><p>用过NIO的人都会知道新连接检测应该在处理select出来的SelectedKey中出现，所以我们就从这开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</div><div class="line">    eventLoop = ch.eventLoop();</div><div class="line">    <span class="keyword">int</span> readyOps = k.readyOps();</div><div class="line">    <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> ops = k.interestOps();</div><div class="line">        ops &amp;= ~SelectionKey.OP_CONNECT;</div><div class="line">        k.interestOps(ops);</div><div class="line">        unsafe.finishConnect();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</div><div class="line">        ch.unsafe().forceFlush();</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 会进入到这里(接收连接)</span></div><div class="line">    <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// step 2</span></div><div class="line">        unsafe.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2 AbstractNioMessageChannel</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ChannelConfig config = config();</div><div class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</div><div class="line">    <span class="comment">// 控制读取连接的速率，默认一次读取16个连接</span></div><div class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</div><div class="line">    allocHandle.reset(config);</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="comment">// step 3</span></div><div class="line">        <span class="keyword">int</span> localRead = doReadMessages(readBuf);</div><div class="line">        <span class="comment">// 对连接数增加</span></div><div class="line">        allocHandle.incMessagesRead(localRead);</div><div class="line">    &#125; <span class="keyword">while</span> ( allocHandle . continueReading ());</div><div class="line"></div><div class="line">    <span class="keyword">int</span> size = readBuf.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        readPending = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">// 触发读事件，绑定到NioEventLoop</span></div><div class="line">        pipeline.fireChannelRead(readBuf.get(i));</div><div class="line">    &#125;</div><div class="line">    readBuf.clear();</div><div class="line">    allocHandle.readComplete();</div><div class="line">    pipeline.fireChannelReadComplete();</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List &lt; Object &gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 熟悉的accept方法，熟悉的javaChannel()拿到serverSocketChannel</span></div><div class="line">    <span class="comment">// step 4</span></div><div class="line">    SocketChannel ch = SocketUtils.accept(javaChannel());</div><div class="line">    <span class="comment">// 封装成NioSocketChannel，进入创建部分</span></div><div class="line">    buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">accept</span><span class="params">(<span class="keyword">final</span> ServerSocketChannel serverSocketChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    	<span class="comment">// 返回SocketChannel(新出来的AccessController还需要研究)</span></div><div class="line">        <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction &lt; SocketChannel &gt; () &#123;<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> SocketChannel <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">                <span class="keyword">return</span> serverSocketChannel.accept();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>检测完毕！！！</p>
<h1 id="创建Channel"><a href="#创建Channel" class="headerlink" title="创建Channel"></a>创建Channel</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1 NioSocketChannel</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(Channel parent, SocketChannel socket)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(parent, socket);</div><div class="line">    <span class="comment">// 同样创建一个config，这里设置了禁止Nagle算法(让数据尽快发出去，而不是让小数据包变大再发)</span></div><div class="line">    config = <span class="keyword">new</span> NioSocketChannelConfig(<span class="keyword">this</span>, socket.socket());</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2 AbstractNioByteChannel</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioByteChannel</span><span class="params">(Channel parent, SelectableChannel ch)</span> </span>&#123;</div><div class="line">    <span class="comment">// 这里要准备绑定读事件了</span></div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    <span class="keyword">super</span>(parent, ch, SelectionKey.OP_READ);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 4</span></div><div class="line">    <span class="keyword">super</span>(parent);</div><div class="line">    <span class="keyword">this</span>.ch = ch;</div><div class="line">    <span class="comment">// 设定为对读事件感兴趣</span></div><div class="line">    <span class="keyword">this</span>.readInterestOp = readInterestOp;</div><div class="line">	<span class="comment">// 设置为非阻塞</span></div><div class="line">    ch.configureBlocking(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.parent = parent;</div><div class="line">    <span class="comment">// 也给自己分配这些东西</span></div><div class="line">    id = newId();</div><div class="line">    unsafe = newUnsafe();</div><div class="line">    pipeline = newChannelPipeline();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Channel注册绑定"><a href="#Channel注册绑定" class="headerlink" title="Channel注册绑定"></a>Channel注册绑定</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1 DefaultChannelPipeline</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    AbstractChannelHandlerContext.invokeChannelRead(head, msg);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">"msg"</span>), next);</div><div class="line">    <span class="comment">// 还是那个线程生成器</span></div><div class="line">    EventExecutor executor = next.executor();</div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    next.invokeChannelRead(m);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 4 它会一直讲事件传播到再服务端启动过程中添加到Pipeline的ServerBootstrapAcceptor</span></div><div class="line">    ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4 ServerBootstrap里的ServerBootstrapAcceptor</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Channel child = (Channel) msg;</div><div class="line">	<span class="comment">// 设置一系列信息</span></div><div class="line">    child.pipeline().addLast(childHandler);</div><div class="line">    setChannelOptions(child, childOptions, logger);</div><div class="line">    <span class="keyword">for</span> (Entry &lt; AttributeKey &lt; ?&gt;, Object &gt; e: childAttrs) &#123;</div><div class="line">        child.attr((AttributeKey &lt; Object &gt; ) e.getKey()).set(e.getValue());</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 忽略细节，关注register方法(这里是childGroup)</span></div><div class="line">    <span class="comment">// step 5</span></div><div class="line">    childGroup.register(child);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 5 MultithreadEventLoopGroup</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</div><div class="line">    <span class="comment">// 这里的next方法会去拿到之前ServerChannel初始化的EventLoop数组的一个</span></div><div class="line">    <span class="comment">// step 6</span></div><div class="line">    <span class="keyword">return</span> next().register(channel);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 6 SingleThreadEventLoop</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</div><div class="line">    <span class="comment">// 看到这里会发现注册流程基本和ServerSocketChanne是一样的</span></div><div class="line">    <span class="comment">// step 7</span></div><div class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 7</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 看到这里，剩下的基本上就可以参考服务端启动流程了</span></div><div class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><code>ServerSocketChannel</code>绑定的EventLoop轮询到有新的连接进入</li>
<li>通过封装jdk底层的channel创建 <code>NioSocketChannel</code>以及一系列的netty核心组件</li>
<li>将该cahnnel通过chooser，选择一个EventLoop绑定上去</li>
<li>注册读事件，开始新连接的读写（可以参考服务端启动流程）</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/0242b1d4dd21" target="_blank" rel="external">netty源码分析之新连接接入全解析</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：之前对服务端和NioEventLoop都有了一定的分析，相信大家的服务端应该已经虚位以待了。好的，我们现在就开始分析&lt;strong&gt;新连接接入&lt;/strong&gt;。
    
    </summary>
    
      <category term="Netty源码" scheme="http://bestlixiang.site/categories/Netty%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Netty" scheme="http://bestlixiang.site/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码之NioEventLoop</title>
    <link href="http://bestlixiang.site/2018/08/06/Netty%E6%BA%90%E7%A0%81/Netty%E6%BA%90%E7%A0%81%E4%B9%8BNioEventLoop/"/>
    <id>http://bestlixiang.site/2018/08/06/Netty源码/Netty源码之NioEventLoop/</id>
    <published>2018-08-06T08:06:40.000Z</published>
    <updated>2018-08-06T08:12:39.114Z</updated>
    
    <content type="html"><![CDATA[<p>引：谈到Netty就避免不了去谈Reactor模式，不懂的同学同自行面向搜索引擎。在Netty中的Reactor线程的具体实现就是NioEventLoop。<a id="more"></a></p>
<h1 id="NioEventLoop创建"><a href="#NioEventLoop创建" class="headerlink" title="NioEventLoop创建"></a>NioEventLoop创建</h1><p>我们先总结这个过程的流程：</p>
<ol>
<li>设置EventLoop数量</li>
<li>创建线程创建器</li>
<li>创建NioEventLoop（配置selector和taskQueue等参数）</li>
<li>创建线程选择器</li>
</ol>
<p>我们回到上一个例子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>); <span class="comment">// 用于处理serverChannel</span></div><div class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">// 用于处理channel</span></div></pre></td></tr></table></figure>
<p>我们进入到NioEventLoopGroup的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">    <span class="comment">// 没有传递线程数，默认为0</span></div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    <span class="keyword">this</span>(nThreads, (Executor) <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor)</span> </span>&#123;</div><div class="line">    <span class="comment">// 绑定默认的SelectorProvider</span></div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    <span class="keyword">this</span>(nThreads, executor, SelectorProvider.provider());</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider)</span> </span>&#123;</div><div class="line">    <span class="comment">// 绑定默认的Selector策略工厂，可能select()阻塞或者重试</span></div><div class="line">    <span class="comment">// step 5</span></div><div class="line">    <span class="keyword">this</span>(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 5</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider, <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;</div><div class="line">    <span class="comment">// 调用父类MultithreadEventLoopGroup构造方法，绑定RejectedExecutionHandler(？？)</span></div><div class="line">    <span class="comment">// step 6</span></div><div class="line">    <span class="keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 6 MultithreadEventLoopGroup</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object...args)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 7 查看默认线程个数</span></div><div class="line">    <span class="comment">// step 8</span></div><div class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS: nThreads, executor, args);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 7</span></div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">    <span class="comment">// 我们发现是两倍的CPU核数(当然这里是workGroup)</span></div><div class="line">    DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(<span class="string">"io.netty.eventLoopThreads"</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 8</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object...args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 绑定了DefaultEventExecutorChooser工厂(该工厂默认轮询策略)</span></div><div class="line">    <span class="comment">// step 9</span></div><div class="line">    <span class="keyword">this</span>(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 9</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object...args)</span> </span>&#123;</div><div class="line">    <span class="comment">// ** 创建线程器生成器</span></div><div class="line">    <span class="comment">// step 10</span></div><div class="line">    executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</div><div class="line">    <span class="comment">// 事件执行器数组</span></div><div class="line">    children = <span class="keyword">new</span> EventExecutor[nThreads];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;  </div><div class="line">        <span class="comment">// ** 创建 NioEventLoop</span></div><div class="line">        <span class="comment">// step 11</span></div><div class="line">        children[i] = newChild(executor, args);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// ** 创建线程选择器</span></div><div class="line">    <span class="comment">// step 15</span></div><div class="line">    chooser = chooserFactory.newChooser(children);</div><div class="line">    Set &lt; EventExecutor &gt; childrenSet = <span class="keyword">new</span> LinkedHashSet &lt; EventExecutor &gt; (children.length);</div><div class="line">    Collections.addAll(childrenSet, children);</div><div class="line">    readonlyChildren = Collections.unmodifiableSet(childrenSet);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 10</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPerTaskExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</div><div class="line">		<span class="comment">// 绑定线程工厂</span></div><div class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">        threadFactory.newThread(command).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 11</span></div><div class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object...args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 绑定SelectStrategy和RejectedExecutionHandler</span></div><div class="line">    <span class="comment">// step 12</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>], ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>]);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 12 NioEventLoop</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> ioRatio = <span class="number">50</span>;</div><div class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</div><div class="line">    <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</div><div class="line">    <span class="comment">// 保存selectorProvider</span></div><div class="line">    provider = selectorProvider;</div><div class="line">    <span class="comment">// 这里创建selector，里面创建了SelectedSelectionKeySet</span></div><div class="line">    <span class="keyword">final</span> SelectorTuple selectorTuple = openSelector();</div><div class="line">    <span class="comment">// 保存selector 一个selector会与一个EventLoop做唯一的绑定</span></div><div class="line">    selector = selectorTuple.selector;</div><div class="line">    <span class="comment">// 保存unwrappedSelector(这个在前一篇博文的时候用到了)</span></div><div class="line">    unwrappedSelector = selectorTuple.unwrappedSelector;</div><div class="line">    selectStrategy = strategy;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 13 SingleThreadEventLoop</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventLoop</span><span class="params">(EventLoopGroup parent, Executor executor, <span class="keyword">boolean</span> addTaskWakesUp, <span class="keyword">int</span> maxPendingTasks, RejectedExecutionHandler rejectedExecutionHandler)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 14</span></div><div class="line">    <span class="keyword">super</span>(parent, executor, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler);</div><div class="line">    <span class="comment">// 保存了一个任务队列</span></div><div class="line">    tailTasks = newTaskQueue(maxPendingTasks);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 14 SingleThreadEventExecutor</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventExecutor</span><span class="params">(EventExecutorGroup parent, Executor executor, <span class="keyword">boolean</span> addTaskWakesUp, <span class="keyword">int</span> maxPendingTasks, RejectedExecutionHandler rejectedHandler)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(parent);</div><div class="line">    <span class="keyword">this</span>.addTaskWakesUp = addTaskWakesUp;</div><div class="line">    <span class="keyword">this</span>.maxPendingTasks = Math.max(<span class="number">16</span>, maxPendingTasks);</div><div class="line">    <span class="comment">// 保存 线程器生成器</span></div><div class="line">    <span class="keyword">this</span>.executor = ObjectUtil.checkNotNull(executor, <span class="string">"executor"</span>);</div><div class="line">    <span class="comment">// 任务队列</span></div><div class="line">    taskQueue = newTaskQueue(<span class="keyword">this</span>.maxPendingTasks);</div><div class="line">    rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, <span class="string">"rejectedHandler"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 15</span></div><div class="line"><span class="function"><span class="keyword">public</span> EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span> </span>&#123;</div><div class="line">    <span class="comment">// 这里根据eventLoop的个数进行了优化(自行了解)</span></div><div class="line">    <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PowerOfTwoEventExecutorChooser(executors);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericEventExecutorChooser(executors);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建完成！！！</p>
<h1 id="NioEventLoop启动"><a href="#NioEventLoop启动" class="headerlink" title="NioEventLoop启动"></a>NioEventLoop启动</h1><p>它的第一次启动还是要回到前一篇博文的这一个步骤中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1 AbstractBootstrap</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line"> 	<span class="comment">// 拿到之前绑定的eventLoop</span></div><div class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</div><div class="line">    <span class="comment">// step 2 进入inEventLoop方法中</span></div><div class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</div><div class="line">        register0(promise);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 所以进入这里了</span></div><div class="line">        <span class="comment">// step 4</span></div><div class="line">        eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                register0(promise);</div><div class="line">              &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2 AbstractEventExecutor</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inEventLoop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 这个时候当前线程为主线程</span></div><div class="line">    <span class="comment">// step 3     </span></div><div class="line">    <span class="keyword">return</span> inEventLoop(Thread.currentThread());</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3 SingleThreadEventExecutor</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inEventLoop</span><span class="params">(Thread thread)</span> </span>&#123;</div><div class="line">    <span class="comment">// 该类中的thread为null，所有返回false</span></div><div class="line">    <span class="keyword">return</span> thread == <span class="keyword">this</span>.thread;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</div><div class="line">    <span class="comment">// 还是主线程，还是false</span></div><div class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</div><div class="line">    <span class="comment">// 将任务添加到队列</span></div><div class="line">    addTask(task);</div><div class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</div><div class="line">        <span class="comment">// 开启线程</span></div><div class="line">        <span class="comment">// step 4</span></div><div class="line">        startThread();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</div><div class="line">        wakeup(inEventLoop);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// state 默认为ST_NOT_STARTED没有启动</span></div><div class="line">    <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</div><div class="line">        <span class="comment">// 原子更新为开始</span></div><div class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</div><div class="line">            <span class="comment">// step 5</span></div><div class="line">            doStartThread();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 5</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 还记得那个executor吗，就是那个线程生成器</span></div><div class="line">    <span class="comment">// step 6</span></div><div class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            thread = Thread.currentThread();</div><div class="line">        	<span class="comment">// 执行自己的run方法</span></div><div class="line">        	<span class="comment">// step 8</span></div><div class="line">            SingleThreadEventExecutor.<span class="keyword">this</span>.run();            </div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 6 ThreadPerTaskExecutor</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">    <span class="comment">// 创建线程并开启线程</span></div><div class="line">    <span class="comment">// step 7 newThread()</span></div><div class="line">    <span class="comment">// start() 返回到run() step 6</span></div><div class="line">    threadFactory.newThread(command).start();</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 7</span></div><div class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">    <span class="comment">// 这里可以看出两点，1，返回了一个优化过的FastThreadLocalRunnable；2，看到了线程名</span></div><div class="line">    <span class="comment">// 线程名的由来可以百度</span></div><div class="line">    Thread t = newThread(FastThreadLocalRunnable.wrap(r), prefix + nextId.incrementAndGet());</div><div class="line">    <span class="keyword">return</span> t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>启动完毕了！！！</p>
<h1 id="NioEventLoop执行"><a href="#NioEventLoop执行" class="headerlink" title="NioEventLoop执行"></a>NioEventLoop执行</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1 这里就是真的reactor线程真正开始干活的地方</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 死循环，干三件事</span></div><div class="line">    <span class="comment">// 1. select</span></div><div class="line">    <span class="comment">// 2. process selected keys</span></div><div class="line">    <span class="comment">// 3. run tasks</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 还有任务在执行等着，没有了，就开始select</span></div><div class="line">            <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</div><div class="line">            <span class="keyword">case</span> SelectStrategy.CONTINUE:</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">case</span> SelectStrategy.SELECT:</div><div class="line">                <span class="comment">// 1. 轮询注册到EventLoop的Selector上的所有channelIO事件</span></div><div class="line">                <span class="comment">// wakenUp 表示是否应该唤醒正在阻塞的select操作，每次开始都置为false</span></div><div class="line">                <span class="comment">// step 2</span></div><div class="line">                select(wakenUp.getAndSet(<span class="keyword">false</span>));</div><div class="line">                <span class="keyword">if</span> (wakenUp.get()) &#123;</div><div class="line">                    selector.wakeup();</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// fall through</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 2. 处理产生IO事件的channel</span></div><div class="line">            <span class="comment">// step 3</span></div><div class="line">            processSelectedKeys();</div><div class="line">            <span class="comment">// 3. 处理任务队列，但是不能超过一个时间</span></div><div class="line">            <span class="comment">// step 8</span></div><div class="line">            runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;    </div><div class="line"></div><div class="line"><span class="comment">// step 2 轮询注册到EventLoop的Selector上的所有channelIO事件</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Selector selector = <span class="keyword">this</span>.selector;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</div><div class="line">        <span class="keyword">long</span> currentTimeNanos = System.nanoTime();</div><div class="line">        <span class="comment">// 设置截止时间(当前时间 + 定时任务的将要截止的时间)</span></div><div class="line">        <span class="comment">// netty里面定时任务队列是按照延迟时间从小到大进行排序</span></div><div class="line">       	<span class="comment">// delayNanos(currentTimeNanos)方法即取出第一个定时任务的延迟时间</span></div><div class="line">        <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</div><div class="line">            <span class="comment">// 如果超出截止时间0.5ms</span></div><div class="line">            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// 如果在跳出之前发现还没有进行过select操作就执行一次selectNow()(不会阻塞)</span></div><div class="line">                    selector.selectNow();</div><div class="line">                    selectCnt = <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 轮询过程中发现有任务加入，中断本次轮询</span></div><div class="line">            <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line">                selector.selectNow();</div><div class="line">                selectCnt = <span class="number">1</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">			<span class="comment">// 阻塞时轮询</span></div><div class="line">            <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis);</div><div class="line">            selectCnt++;</div><div class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</div><div class="line">                <span class="comment">// 这里还提供了4种方式来中断轮询</span></div><div class="line">                <span class="comment">// - 轮询到io事件,</span></div><div class="line">                <span class="comment">// - 用户主动唤醒</span></div><div class="line">                <span class="comment">// - 任务队列有任务</span></div><div class="line">                <span class="comment">// - 有定时任务需要被处理</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;            </div><div class="line">			<span class="comment">// 这里就很重要了，看看Netty是怎么解决JDK NIO的空轮训bug的</span></div><div class="line">            <span class="keyword">long</span> time = System.nanoTime();</div><div class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</div><div class="line">                <span class="comment">// 有效轮询，重置标志位</span></div><div class="line">                selectCnt = <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</div><div class="line">				<span class="comment">// 当空轮训的次数超过SELECTOR_AUTO_REBUILD_THRESHOLD(默认512)时，就开始重建Selector</span></div><div class="line">                <span class="comment">// step 3</span></div><div class="line">                rebuildSelector();</div><div class="line">                selector = <span class="keyword">this</span>.selector;</div><div class="line">                <span class="comment">// Select again to populate selectedKeys.</span></div><div class="line">                selector.selectNow();</div><div class="line">                selectCnt = <span class="number">1</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            currentTimeNanos = time;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;      </div><div class="line"></div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rebuildSelector</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// step 4</span></div><div class="line">    rebuildSelector0();</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebuildSelector0</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Selector oldSelector = selector;</div><div class="line">    <span class="keyword">final</span> SelectorTuple newSelectorTuple;</div><div class="line">	<span class="comment">// 创建一个新的selector</span></div><div class="line">    newSelectorTuple = openSelector();</div><div class="line">    <span class="keyword">int</span> nChannels = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (SelectionKey key: oldSelector.keys()) &#123;</div><div class="line">        Object a = key.attachment();</div><div class="line">		<span class="keyword">int</span> interestOps = key.interestOps();</div><div class="line">        <span class="comment">// 取消key在旧的selector上的事件注册</span></div><div class="line">		key.cancel();</div><div class="line">		<span class="comment">// 将所有channel重新注册到新的selector上</span></div><div class="line">		SelectionKeynewKey = key.channel().register(newSelectorTuple.unwrappedSelector, 		interestOps, a);</div><div class="line">		nChannels++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// eventLoop绑定新的seletor</span></div><div class="line">    selector = newSelectorTuple.selector;</div><div class="line">    unwrappedSelector = newSelectorTuple.unwrappedSelector;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 5</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 可定不为空，因为在NioEventLoop 的 openSelector方法中创建了</span></div><div class="line">    <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 为什么说SelectedKeys是优化过的，是因为原生的SelectedKeys是Set，添加一个事件为O(logn)</span></div><div class="line">        <span class="comment">// 优化过后使用数组来操作，添加一个事件为O(1)</span></div><div class="line">        <span class="comment">// 具体的可以参考闪电侠的博客，我这里就不多说了</span></div><div class="line">        <span class="comment">// step 6</span></div><div class="line">        processSelectedKeysOptimized();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        processSelectedKeysPlain(selector.selectedKeys());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 6</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selectedKeys.size; ++i) &#123;</div><div class="line">        <span class="keyword">final</span> SelectionKey k = selectedKeys.keys[i];</div><div class="line">        <span class="comment">// 让对象可以被GC</span></div><div class="line">        selectedKeys.keys[i] = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">final</span> Object a = k.attachment();</div><div class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</div><div class="line">            <span class="comment">// 拿到携带的channel</span></div><div class="line">            <span class="comment">// step 7</span></div><div class="line">            processSelectedKey(k, (AbstractNioChannel) a);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) NioTask &lt; SelectableChannel &gt; task = (NioTask &lt; SelectableChannel &gt; ) a;</div><div class="line">            processSelectedKey(k, task);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (needsToSelectAgain) &#123;</div><div class="line">            selectedKeys.reset(i + <span class="number">1</span>);</div><div class="line"></div><div class="line">            selectAgain();</div><div class="line">            i = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 7</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</div><div class="line">    <span class="comment">// 拿到NioEventLoop的Unsafe对象</span></div><div class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</div><div class="line">    <span class="comment">// 拿到NioEventLoop的eventLoop对象</span></div><div class="line">    eventLoop = ch.eventLoop();</div><div class="line">    <span class="comment">// 拿到事件</span></div><div class="line">    <span class="keyword">int</span> readyOps = k.readyOps();</div><div class="line">    <span class="comment">// 连接事件处理</span></div><div class="line">    <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> ops = k.interestOps();</div><div class="line">        <span class="comment">// 获得感兴趣的事件</span></div><div class="line">        ops &amp;= ~SelectionKey.OP_CONNECT;</div><div class="line">        <span class="comment">// 重新注册</span></div><div class="line">        k.interestOps(ops);</div><div class="line">        <span class="comment">// 完成链接</span></div><div class="line">        unsafe.finishConnect();</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 写事件处理</span></div><div class="line">    <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</div><div class="line">        ch.unsafe().forceFlush();</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 读事件(work)或者建立连接事件（boss）处理</span></div><div class="line">    <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 都是read方法，只是实现不同</span></div><div class="line">        unsafe.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// step 8 处理任务队列</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">(<span class="keyword">long</span> timeoutNanos)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将定时任务放入普通任务队列(它是一个多生产者单消费者队列)</span></div><div class="line">    <span class="comment">// step 9</span></div><div class="line">    fetchFromScheduledTaskQueue();</div><div class="line">    <span class="comment">// 拿出一个普通任务</span></div><div class="line">    Runnable task = pollTask();</div><div class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 运行收尾任务队列tailTasks</span></div><div class="line">        afterRunningAllTasks();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 计算出本次循环的能够运行的最多时间</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</div><div class="line">    <span class="keyword">long</span> runTasks = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> lastExecutionTime;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="comment">// 执行任务(这里一定要多调试几次才会有感觉，任务队列的感觉一下子就出来了)</span></div><div class="line">        <span class="comment">// step 10</span></div><div class="line">        safeExecute(task);</div><div class="line">        runTasks++;</div><div class="line">        <span class="comment">// 由于ScheduledFutureTask.nanoTime()比较耗时，所以没64次比较一次是否超时</span></div><div class="line">        <span class="keyword">if</span> ((runTasks &amp; <span class="number">0x3F</span>) == <span class="number">0</span>) &#123;</div><div class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</div><div class="line">            <span class="keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        task = pollTask();</div><div class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</div><div class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    afterRunningAllTasks();</div><div class="line">    <span class="keyword">this</span>.lastExecutionTime = lastExecutionTime;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 9</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fetchFromScheduledTaskQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> nanoTime = AbstractScheduledEventExecutor.nanoTime();</div><div class="line">    <span class="comment">// 定时任务队列是一个优先级队列，并且任务实现了compareTo方法，可以返回快需要被执行的定时任务</span></div><div class="line">    Runnable scheduledTask = pollScheduledTask(nanoTime);</div><div class="line">    <span class="keyword">while</span> (scheduledTask != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!taskQueue.offer(scheduledTask)) &#123;</div><div class="line">			<span class="comment">// 如果普通队列满了，就又放回去</span></div><div class="line">            scheduledTaskQueue().add((ScheduledFutureTask &lt; ?&gt;) scheduledTask);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 拿到定时任务</span></div><div class="line">        scheduledTask = pollScheduledTask(nanoTime);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 10</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">safeExecute</span><span class="params">(Runnable task)</span> </span>&#123;</div><div class="line">    <span class="comment">// 就只是运行这个任务，但是一个出错了，也会继续进行下去</span></div><div class="line">   	task.run();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行完毕！！！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然还是有很多细节没有调试到，但是大概的流程应该都走了一遍，希望多调试，然后才会深感EventLoop的吊！！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/0d0eece6d467" target="_blank" rel="external">netty源码分析之揭开reactor线程的面纱（一）</a></li>
<li><a href="https://www.jianshu.com/p/467a9b41833e" target="_blank" rel="external">netty源码分析之揭开reactor线程的面纱（二）</a></li>
<li><a href="https://www.jianshu.com/p/58fad8e42379" target="_blank" rel="external">netty源码分析之揭开reactor线程的面纱（三）</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：谈到Netty就避免不了去谈Reactor模式，不懂的同学同自行面向搜索引擎。在Netty中的Reactor线程的具体实现就是NioEventLoop。
    
    </summary>
    
      <category term="Netty源码" scheme="http://bestlixiang.site/categories/Netty%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Netty" scheme="http://bestlixiang.site/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码之服务端启动</title>
    <link href="http://bestlixiang.site/2018/08/06/Netty%E6%BA%90%E7%A0%81/Netty%E6%BA%90%E7%A0%81%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8/"/>
    <id>http://bestlixiang.site/2018/08/06/Netty源码/Netty源码之服务端启动/</id>
    <published>2018-08-06T08:05:45.000Z</published>
    <updated>2018-08-06T08:17:52.344Z</updated>
    
    <content type="html"><![CDATA[<p>引：Netty启动啦！开心脸！但是这又可能是一篇又臭又长由绕的文章，需要点耐心，需要点动手能力。无奈脸！！！<a id="more"></a></p>
<h1 id="Netty-Example"><a href="#Netty-Example" class="headerlink" title="Netty Example"></a>Netty Example</h1><p>我选择了Netty源码中的EchoServer来作为例子，它在<code>io.netty.example.echo</code>包下，代码如下所示（忽略细节，专注核心）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">"port"</span>, <span class="string">"8007"</span>));</div><div class="line">        <span class="comment">// 配置Server端</span></div><div class="line">        <span class="comment">// AbstractBootstrap的group</span></div><div class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</div><div class="line">        <span class="comment">// ServerBootstrap的childGroup</span></div><div class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">        <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 在它创建的过程中会绑定一个ServerBootstrapConfig保存它的属性</span></div><div class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</div><div class="line">            <span class="comment">// 方法链配置类，可以学习</span></div><div class="line">            <span class="comment">// 服务端的Bootstrap才有两个参数的group方法</span></div><div class="line">            b.group(bossGroup, workerGroup)</div><div class="line">                <span class="comment">// 设置AbstractBootstrap的channelFactory参数</span></div><div class="line">             .channel(NioServerSocketChannel.class)</div><div class="line">                <span class="comment">// 设置AbstractBootstrap的options参数(常量池实现，ConcurrentMap),可以学习</span></div><div class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</div><div class="line">                <span class="comment">// 设置AbstractBootstrap的handler参数，这里配置了一个日志处理类</span></div><div class="line">             .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</div><div class="line">                <span class="comment">// 设置ServerBootstrap的childHandler参数</span></div><div class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</div><div class="line">                 <span class="meta">@Override</span></div><div class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                     ChannelPipeline p = ch.pipeline();</div><div class="line">                     p.addLast(serverHandler);</div><div class="line">                 &#125;</div><div class="line">             &#125;);</div><div class="line">			<span class="comment">// 服务端启动(一切分析的源头)</span></div><div class="line">            ChannelFuture f = b.bind(PORT).sync();</div><div class="line">            <span class="comment">// 等待服务端关闭socket</span></div><div class="line">            f.channel().closeFuture().sync();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">// 优雅关闭两组死循环</span></div><div class="line">            bossGroup.shutdownGracefully();</div><div class="line">            workerGroup.shutdownGracefully();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>上面的例子的注释已经很清楚了，在启动之前主要就是在配置启动类ServerBootstrap。现在我就下面的启动方法开始深入分析(debug，代码展示会忽略细节)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ChannelFuture f = b.bind(PORT).sync();</div></pre></td></tr></table></figure>
<h2 id="Bootstrap相关"><a href="#Bootstrap相关" class="headerlink" title="Bootstrap相关"></a>Bootstrap相关</h2><p>我们可以看看这个类干了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span> </span>&#123;</div><div class="line">    <span class="comment">// 通过端口生成一个InetSocketAddress</span></div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    <span class="keyword">return</span> bind(<span class="keyword">new</span> InetSocketAddress(inetPort));</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</div><div class="line">    <span class="comment">// 验证group和channelFactory是否传进来了</span></div><div class="line">    validate();</div><div class="line">    <span class="comment">// 非空判断，这里只说一次，大的工程项目，必须通过防御性编程来增强鲁棒性</span></div><div class="line">    <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"localAddress"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    <span class="keyword">return</span> doBind(localAddress);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</div><div class="line">    <span class="comment">// 初始化serverChannel，并将eventloop注册到serverChannel上</span></div><div class="line">    <span class="comment">// step 4</span></div><div class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</div><div class="line">    <span class="comment">// 获取刚刚创建的serverChannel，由于之后都不会改变，所以这里可以用final修饰</span></div><div class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</div><div class="line">    <span class="comment">// 绑定地址</span></div><div class="line">	doBind0(regFuture, channel, localAddress, promise);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</div><div class="line">    Channel channel = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 生成一个serverChannel</span></div><div class="line">    <span class="comment">// 这里的channelFactory我们在例子介绍过，其实就是在工厂中利用反射生成对应的channel</span></div><div class="line">    <span class="comment">// 这里我们会在NioServerSocketChannel类中分析它构造时会发生什么(可以直接跳过去看)</span></div><div class="line">    channel = channelFactory.newChannel();</div><div class="line">    <span class="comment">// 初始化serverChannel</span></div><div class="line">    <span class="comment">// step 5</span></div><div class="line">    init(channel);</div><div class="line">    <span class="comment">// config().group()就是通过ServerBootstrapConfig拿到bossGroup没什么好说的，我们重点关注register方法，我们可以进入EventLoopGroup分析(可以直接跳过去看)</span></div><div class="line">    <span class="comment">// MultithreadEventLoopGroup的 step 1</span></div><div class="line">    ChannelFuture regFuture = config().group().register(channel);</div><div class="line">    <span class="keyword">return</span> regFuture;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// step 5 ServerBootstrap具体实现</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map &lt; ChannelOption &lt; ?&gt;,Object &gt; childOptions;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map &lt; AttributeKey &lt; ?&gt;,Object &gt; childOptions;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServerBootstrapConfig config = <span class="keyword">new</span> ServerBootstrapConfig(<span class="keyword">this</span>);</div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> EventLoopGroup childGroup;</div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ChannelHandler childHandler;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 拿到设置的AbstractBootstrap的options</span></div><div class="line">    <span class="keyword">final</span> Map &lt; ChannelOption &lt; ?&gt;,</div><div class="line">    Object &gt; options = options0();</div><div class="line">    <span class="comment">// 同步</span></div><div class="line">    <span class="keyword">synchronized</span>(options) &#123;</div><div class="line">        <span class="comment">// 设置options，跟下去我们会发现将options放入NioServerSocketChannelConfig中</span></div><div class="line">        setChannelOptions(channel, options, logger);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 同options设置</span></div><div class="line">    <span class="keyword">final</span> Map &lt; AttributeKey &lt; ?&gt;,</div><div class="line">    Object &gt; attrs = attrs0();</div><div class="line">    <span class="keyword">synchronized</span>(attrs) &#123;</div><div class="line">        <span class="keyword">for</span> (Entry &lt; AttributeKey &lt; ?&gt;, Object &gt; e: attrs.entrySet()) &#123;<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) AttributeKey &lt; Object &gt; key = (AttributeKey &lt; Object &gt; ) e.getKey();</div><div class="line">            channel.attr(key).set(e.getValue());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 拿到ChannelPipeline</span></div><div class="line">    ChannelPipeline p = channel.pipeline();</div><div class="line">    <span class="comment">// 拿到之前注入的childGroup和childHandler</span></div><div class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</div><div class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</div><div class="line">    <span class="comment">// 设置childOptions和childOptions，这些是应用于以后新接入的channel</span></div><div class="line">    <span class="keyword">final</span> Entry &lt; ChannelOption &lt; ?&gt;,</div><div class="line">    Object &gt; [] currentChildOptions;</div><div class="line">    <span class="keyword">final</span> Entry &lt; AttributeKey &lt; ?&gt;,</div><div class="line">    Object &gt; [] currentChildAttrs;</div><div class="line">    <span class="keyword">synchronized</span>(childOptions) &#123;</div><div class="line">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">synchronized</span>(childAttrs) &#123;</div><div class="line">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 加入新连接处理器</span></div><div class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer &lt; Channel &gt; () &#123;<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</div><div class="line">        	<span class="comment">// 将会获得最早之前设置的new LoggingHandler(LogLevel.INFO)</span></div><div class="line">            ChannelHandler handler = config.handler();</div><div class="line">			<span class="comment">// 新增一个新连接接入器ServerBootstrapAcceptor，具体的可以看之后的博文</span></div><div class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 6</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(<span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 又是异步任务，Netty随处可见</span></div><div class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</div><div class="line">                <span class="comment">// AbstractChannel step 11</span></div><div class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                promise.setFailure(regFuture.cause());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Channel相关"><a href="#Channel相关" class="headerlink" title="Channel相关"></a>Channel相关</h2><p>创建一个NioServerSocketChannel对象会发生什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();</div><div class="line"><span class="comment">// ServerSocketChannel的一系列配置属性</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannelConfig config;</div><div class="line"><span class="comment">// step 1(默认构造函数)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// step 2，step 3</span></div><div class="line">    <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 2</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</div><div class="line">	<span class="comment">// 利用JDK NIO 创建的SeveSocketrChannel</span></div><div class="line">    <span class="keyword">return</span> provider.openServerSocketChannel();</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 4</span></div><div class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</div><div class="line">    <span class="comment">// 配置NioServerSocketChannelConfig(初始化会用到)</span></div><div class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4 AbstractNioMessageChannel</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioMessageChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 5</span></div><div class="line">    <span class="keyword">super</span>(parent, ch, readInterestOp);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 5 AbstractNioChannel</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectableChannel ch;</div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> readInterestOp;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 6</span></div><div class="line">    <span class="keyword">super</span>(parent);</div><div class="line">    <span class="comment">// 保存原生的ServerSocketChannel</span></div><div class="line">    <span class="keyword">this</span>.ch = ch;</div><div class="line">    <span class="comment">// 保存感兴趣的事件(SelectionKey.OP_ACCEPT，1&lt;&lt;4)</span></div><div class="line">    <span class="keyword">this</span>.readInterestOp = readInterestOp;</div><div class="line">    <span class="comment">// 将Channel设置为非阻塞</span></div><div class="line">    ch.configureBlocking(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 6 AbstractChannel</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Channel parent;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelId id;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Unsafe unsafe;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultChannelPipeline pipeline;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.parent = parent;</div><div class="line">    <span class="comment">// 生成channel的唯一标识，自己可以去看看实现</span></div><div class="line">    id = newId();</div><div class="line">    <span class="comment">// 生成unsafe对象(进行底层的IO操作)，一个抽象方法，需要具体实现，它的抽象类也在AbstractChannel中</span></div><div class="line">    unsafe = newUnsafe();</div><div class="line">    <span class="comment">// 生成ChannelPipeline</span></div><div class="line">    <span class="comment">// step 7</span></div><div class="line">    pipeline = newChannelPipeline();</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 7</span></div><div class="line"><span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 我们将在DefaultChannelPipeline分析</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// step 8 AbstractChannel</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 绑定了eventLoop</span></div><div class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</div><div class="line">	<span class="comment">// ... 专注于核心</span></div><div class="line">    <span class="comment">// step 9</span></div><div class="line">    register0(promise);</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// step 9</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 当然是第一次注册，true    </span></div><div class="line">    <span class="keyword">boolean</span> firstRegistration = neverRegistered;</div><div class="line">    <span class="comment">// step 10    </span></div><div class="line">    doRegister();</div><div class="line">    <span class="comment">// 注册之后设置标志位</span></div><div class="line">    neverRegistered = <span class="keyword">false</span>;    </div><div class="line">    registered = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">// pipeline之后的博文会说    </span></div><div class="line">    pipeline.invokeHandlerAddedIfNeeded();</div><div class="line">    safeSetSuccess(promise);</div><div class="line">    <span class="comment">// 触发注册完成事件，还会传播pipeline.fireChannelActive();</span></div><div class="line">    pipeline.fireChannelRegistered();</div><div class="line">    <span class="comment">// 判断是否绑定，会调用底层NIO创建的channel，应该为false</span></div><div class="line">    <span class="comment">// 那么什么时候建立连接的呢，怎么找，可以参考后面列出的闪电侠的博文，这个函数分析完了</span></div><div class="line">    <span class="comment">// 我们应该回到AbstractBootstrap的 step 6 继续分析</span></div><div class="line">    <span class="keyword">if</span> (isActive()) &#123;</div><div class="line">        <span class="keyword">if</span> (firstRegistration) &#123;</div><div class="line">            pipeline.fireChannelActive();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</div><div class="line">            beginRead();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 10</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 利用jdk底层将channel注册到selector上，0表示不关心任何事件，this是为了当NIO检测到事件时可以对netty的channel进行操作</span></div><div class="line">    selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 11</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// DefaultChannelPipeline step 2</span></div><div class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 12</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 肯定还没有建立连接</span></div><div class="line">    <span class="keyword">boolean</span> wasActive = isActive();</div><div class="line">    <span class="comment">// step 13    </span></div><div class="line">    doBind(localAddress);</div><div class="line">	<span class="comment">// 这里isActive()应该要返回true了</span></div><div class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</div><div class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            	<span class="comment">// 触发端口绑定事件，我们将会触发HeadContext的channelActive方法</span></div><div class="line">            	<span class="comment">// ChannelPipeline step 5</span></div><div class="line">                pipeline.fireChannelActive();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    safeSetSuccess(promise);</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 13</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 到这里就是进行底层的绑定</span></div><div class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</div><div class="line">        javaChannel().bind(localAddress, config.getBacklog());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 14 AbstractChannel</span></div><div class="line"><span class="function"><span class="keyword">public</span> Channel <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// DefaultChannelPipeline step 7</span></div><div class="line">    pipeline.read();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 16 AbstractNioChannel的AbstractNioUnsafe</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 还记得在初始化AbstractNioChannel时保存的readInterestOp和在channel注册过程中的selectionKey吗，不记得往上看一看</span></div><div class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</div><div class="line">	<span class="comment">// 需要读</span></div><div class="line">    readPending = <span class="keyword">true</span>;</div><div class="line">	<span class="comment">// 拿到具体的值，1&lt;&lt;4=16</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</div><div class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</div><div class="line">		<span class="comment">// 准备告诉Selector需要关注SelectionKey.OP_ACCEPT事件</span></div><div class="line">        selectionKey.interestOps(interestOps | readInterestOp);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ChannelPipeline相关"><a href="#ChannelPipeline相关" class="headerlink" title="ChannelPipeline相关"></a>ChannelPipeline相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1 DefaultChannelPipeline</span></div><div class="line"><span class="keyword">final</span> AbstractChannelHandlerContext head;</div><div class="line"><span class="keyword">final</span> AbstractChannelHandlerContext tail;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</div><div class="line">    <span class="comment">// 绑定channel(如果为空则抛出异常，学习写工具类)</span></div><div class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</div><div class="line">	<span class="comment">// 默认的两个节点</span></div><div class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</div><div class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</div><div class="line">	<span class="comment">// 形成双向链表</span></div><div class="line">    head.next = tail;</div><div class="line">    tail.prev = head;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// step 2 DefaultChannelPipeline</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 这个tail之前就设置过了</span></div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// step 3 AbstractChannelHandlerContext</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 寻找tail之前的一个节点</span></div><div class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound();</div><div class="line">    EventExecutor executor = next.executor();</div><div class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</div><div class="line">        <span class="comment">// 调用下一个AbstractChannelHandlerContext的invokeBind方法，一直到找到HeadContext</span></div><div class="line">        <span class="comment">// step 4</span></div><div class="line">        next.invokeBind(localAddress, promise);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                next.invokeBind(localAddress, promise);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        promise, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 4</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 看到unsafe就知道要进行底层操作的</span></div><div class="line">    <span class="comment">// 进入 AbstractChannel的Unsafe step 12</span></div><div class="line">    unsafe.bind(localAddress, promise);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// step 5 DefaultChannelPipeline的HeadContext</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 绑定时间将会一直传播下去</span></div><div class="line">    ctx.fireChannelActive();</div><div class="line">    <span class="comment">// step 6 深入分析</span></div><div class="line">    readIfIsAutoRead();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// step 6 DefaultChannelPipeline的HeadContext</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 我们很容易看到isAutoRead()方法默认返回为1</span></div><div class="line">    <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</div><div class="line">        <span class="comment">// 进入 AbstractChannel step 14</span></div><div class="line">        <span class="comment">// 对于服务端channel的读来说就说可以绑定连接了</span></div><div class="line">        channel.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 7 DefaultChannelPipeline</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 从tail节点一直追寻到head，找到 unsafe.beginRead()</span></div><div class="line">    <span class="comment">// step 8</span></div><div class="line">    tail.read();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 8 DefaultChannelPipeline的HeadContext</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginRead</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 会一直找到AbstractNioChannel的AbstractNioUnsafe的doBeginRead step 16</span></div><div class="line">    doBeginRead();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="EventLoop相关"><a href="#EventLoop相关" class="headerlink" title="EventLoop相关"></a>EventLoop相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step 1 MultithreadEventLoopGroup</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</div><div class="line">    <span class="comment">// next()将会通过选择器（之后的博文会讲到）拿到一个EventLoop</span></div><div class="line">    <span class="comment">// step 2</span></div><div class="line">    <span class="keyword">return</span> next().register(channel);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// step2 SingleThreadEventLoop</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</div><div class="line">    <span class="comment">// step 3</span></div><div class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</div><div class="line">&#125;</div><div class="line"><span class="comment">// step 3</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 通过unsafe()方法得到Unsafe对象（绑定在channel上的那个）我们可以知道，它要开始底层操作注册了</span></div><div class="line">    <span class="comment">// 我们我们又要回到AbstractChannel去了，看看它的register注册方法</span></div><div class="line">    <span class="comment">// Channel step 8</span></div><div class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>设置启动类参数</li>
<li>创建服务端Channel，同时创建ChannelConfig,ChannelId,ChannelPipeline,ChannelHandler,Unsafe等</li>
<li>初始化服务端Channel，设置一些attr，option，以及设置子channel的attr，option，给服务端channel添加新channel接入器</li>
<li>将Channel注册到Selector，并触发addHandler,register等事件</li>
<li>进行端口绑定，并触发active事件，同时注册ACCEPT事件</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/c5068caab217" target="_blank" rel="external">netty源码分析之服务端启动全解析</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：Netty启动啦！开心脸！但是这又可能是一篇又臭又长由绕的文章，需要点耐心，需要点动手能力。无奈脸！！！
    
    </summary>
    
      <category term="Netty源码" scheme="http://bestlixiang.site/categories/Netty%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Netty" scheme="http://bestlixiang.site/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>摆脱烂代码之Effective Java Third Edition</title>
    <link href="http://bestlixiang.site/2018/07/23/%E6%91%86%E8%84%B1%E7%83%82%E4%BB%A3%E7%A0%81/%E6%91%86%E8%84%B1%E7%83%82%E4%BB%A3%E7%A0%81%E4%B9%8BEffective-Java-Third-Edition/"/>
    <id>http://bestlixiang.site/2018/07/23/摆脱烂代码/摆脱烂代码之Effective-Java-Third-Edition/</id>
    <published>2018-07-23T06:29:10.000Z</published>
    <updated>2018-07-23T11:26:42.834Z</updated>
    
    <content type="html"><![CDATA[<p>引：越学越迷茫，有所谓的重点吗？我反正现在还弄不清楚，既然弄不清楚，那就好好专注于脚下吧。我曾经看过一遍Effective Java第二版，可能那个时候的代码量还不够吧，不能理解其精髓，现在看看才能回味一点。刚好今年年初第三版（英文版）也出来，新增了Java7、8、9的一些条目，这里也就想列一些第三版的目录，供自己查找与实践，希望自己能够看到条目就能说出所以然来，也想翻译一下新增的一些条目。大家也可以互相交流。<a id="more"></a></p>
<h3 id="第一章-引言（重要）"><a href="#第一章-引言（重要）" class="headerlink" title="第一章 引言（重要）"></a>第一章 引言（重要）</h3><h3 id="第二章-创建和销毁对象"><a href="#第二章-创建和销毁对象" class="headerlink" title="第二章 创建和销毁对象"></a>第二章 创建和销毁对象</h3><h4 id="第1条-考虑用静态工厂方法代替构造器（Java8，9-更新）"><a href="#第1条-考虑用静态工厂方法代替构造器（Java8，9-更新）" class="headerlink" title="第1条 考虑用静态工厂方法代替构造器（Java8，9 更新）"></a>第1条 考虑用静态工厂方法代替构造器（Java8，9 更新）</h4><h4 id="第2条-遇到多个构造器参数时要考虑用建造者模式"><a href="#第2条-遇到多个构造器参数时要考虑用建造者模式" class="headerlink" title="第2条 遇到多个构造器参数时要考虑用建造者模式"></a>第2条 遇到多个构造器参数时要考虑用建造者模式</h4><h4 id="第3条-通过私有构造器或者枚举类型强化单例属性"><a href="#第3条-通过私有构造器或者枚举类型强化单例属性" class="headerlink" title="第3条 通过私有构造器或者枚举类型强化单例属性"></a>第3条 通过私有构造器或者枚举类型强化单例属性</h4><h4 id="第4条-通过私有构造器强化不可实例化的能力"><a href="#第4条-通过私有构造器强化不可实例化的能力" class="headerlink" title="第4条 通过私有构造器强化不可实例化的能力"></a>第4条 通过私有构造器强化不可实例化的能力</h4><h4 id="第5条-依赖注入优先硬连接资源（新增）"><a href="#第5条-依赖注入优先硬连接资源（新增）" class="headerlink" title="第5条 依赖注入优先硬连接资源（新增）"></a>第5条 依赖注入优先硬连接资源（新增）</h4><h4 id="第6条-避免创建不必要的对象（Java9-更新）"><a href="#第6条-避免创建不必要的对象（Java9-更新）" class="headerlink" title="第6条 避免创建不必要的对象（Java9 更新）"></a>第6条 避免创建不必要的对象（Java9 更新）</h4><h4 id="第7条-消除过期的对象引用"><a href="#第7条-消除过期的对象引用" class="headerlink" title="第7条 消除过期的对象引用"></a>第7条 消除过期的对象引用</h4><h4 id="第8条-避免使用总结方法和清理器（Java-7，9-更新）"><a href="#第8条-避免使用总结方法和清理器（Java-7，9-更新）" class="headerlink" title="第8条 避免使用总结方法和清理器（Java 7，9 更新）"></a>第8条 避免使用总结方法和清理器（Java 7，9 更新）</h4><h4 id="第9条-try-with-resources优先try-finally（Java-7-新增）"><a href="#第9条-try-with-resources优先try-finally（Java-7-新增）" class="headerlink" title="第9条 try-with-resources优先try-finally（Java 7 新增）"></a>第9条 try-with-resources优先try-finally（Java 7 新增）</h4><h3 id="第三章-所有对象通用的方法"><a href="#第三章-所有对象通用的方法" class="headerlink" title="第三章 所有对象通用的方法"></a>第三章 所有对象通用的方法</h3><h4 id="第10条-覆写equals时候请遵守通用规定"><a href="#第10条-覆写equals时候请遵守通用规定" class="headerlink" title="第10条 覆写equals时候请遵守通用规定"></a>第10条 覆写equals时候请遵守通用规定</h4><h4 id="第11条-覆写equals时候总要覆写hashCode"><a href="#第11条-覆写equals时候总要覆写hashCode" class="headerlink" title="第11条 覆写equals时候总要覆写hashCode"></a>第11条 覆写equals时候总要覆写hashCode</h4><h4 id="第12条-始终覆写toString"><a href="#第12条-始终覆写toString" class="headerlink" title="第12条 始终覆写toString"></a>第12条 始终覆写toString</h4><h4 id="第13条-谨慎得覆写clone"><a href="#第13条-谨慎得覆写clone" class="headerlink" title="第13条 谨慎得覆写clone"></a>第13条 谨慎得覆写clone</h4><h4 id="第14条-考虑实现Comparable接口"><a href="#第14条-考虑实现Comparable接口" class="headerlink" title="第14条 考虑实现Comparable接口"></a>第14条 考虑实现Comparable接口</h4><h3 id="第四章-类和接口"><a href="#第四章-类和接口" class="headerlink" title="第四章 类和接口"></a>第四章 类和接口</h3><h4 id="第15条-使类和成员可访问性最小化（Java9-更新）"><a href="#第15条-使类和成员可访问性最小化（Java9-更新）" class="headerlink" title="第15条 使类和成员可访问性最小化（Java9 更新）"></a>第15条 使类和成员可访问性最小化（Java9 更新）</h4><h4 id="第16条-在公有类中使用访问方法而非公有域"><a href="#第16条-在公有类中使用访问方法而非公有域" class="headerlink" title="第16条 在公有类中使用访问方法而非公有域"></a>第16条 在公有类中使用访问方法而非公有域</h4><h4 id="第17条-使可变性最小化"><a href="#第17条-使可变性最小化" class="headerlink" title="第17条 使可变性最小化"></a>第17条 使可变性最小化</h4><h4 id="第18条-复合优先于继承"><a href="#第18条-复合优先于继承" class="headerlink" title="第18条 复合优先于继承"></a>第18条 复合优先于继承</h4><h4 id="第19条-要么为继承而设计并提供文档，要么禁止继承（Java8，9-更新）"><a href="#第19条-要么为继承而设计并提供文档，要么禁止继承（Java8，9-更新）" class="headerlink" title="第19条 要么为继承而设计并提供文档，要么禁止继承（Java8，9 更新）"></a>第19条 要么为继承而设计并提供文档，要么禁止继承（Java8，9 更新）</h4><h4 id="第20条-接口优先于抽象类"><a href="#第20条-接口优先于抽象类" class="headerlink" title="第20条 接口优先于抽象类"></a>第20条 接口优先于抽象类</h4><h4 id="第21条-为后代设计接口（Java8-新增）"><a href="#第21条-为后代设计接口（Java8-新增）" class="headerlink" title="第21条 为后代设计接口（Java8 新增）"></a>第21条 为后代设计接口（Java8 新增）</h4><h4 id="第22条-接口只用于定义类型"><a href="#第22条-接口只用于定义类型" class="headerlink" title="第22条 接口只用于定义类型"></a>第22条 接口只用于定义类型</h4><h4 id="第23条-类层次优先于标签类"><a href="#第23条-类层次优先于标签类" class="headerlink" title="第23条 类层次优先于标签类"></a>第23条 类层次优先于标签类</h4><h4 id="第24条-优先考虑静态成员类而不是非静态成员类"><a href="#第24条-优先考虑静态成员类而不是非静态成员类" class="headerlink" title="第24条 优先考虑静态成员类而不是非静态成员类"></a>第24条 优先考虑静态成员类而不是非静态成员类</h4><h4 id="第25条-将源文件限制为单个顶层类（新增）"><a href="#第25条-将源文件限制为单个顶层类（新增）" class="headerlink" title="第25条 将源文件限制为单个顶层类（新增）"></a>第25条 将源文件限制为单个顶层类（新增）</h4><h3 id="第五章-泛型"><a href="#第五章-泛型" class="headerlink" title="第五章 泛型"></a>第五章 泛型</h3><h4 id="第26条-不要使用原生类型"><a href="#第26条-不要使用原生类型" class="headerlink" title="第26条 不要使用原生类型"></a>第26条 不要使用原生类型</h4><h4 id="第27条-消除非首检警告"><a href="#第27条-消除非首检警告" class="headerlink" title="第27条 消除非首检警告"></a>第27条 消除非首检警告</h4><h4 id="第28条-列表优先于数组"><a href="#第28条-列表优先于数组" class="headerlink" title="第28条 列表优先于数组"></a>第28条 列表优先于数组</h4><h4 id="第29条-优先考虑泛型"><a href="#第29条-优先考虑泛型" class="headerlink" title="第29条 优先考虑泛型"></a>第29条 优先考虑泛型</h4><h4 id="第30条-优先考虑泛型方法"><a href="#第30条-优先考虑泛型方法" class="headerlink" title="第30条 优先考虑泛型方法"></a>第30条 优先考虑泛型方法</h4><h4 id="第31条-使用有界通配符提升API灵活性"><a href="#第31条-使用有界通配符提升API灵活性" class="headerlink" title="第31条 使用有界通配符提升API灵活性"></a>第31条 使用有界通配符提升API灵活性</h4><h4 id="第32条-谨慎组合泛型和可变参数（Java-7，9-新增）"><a href="#第32条-谨慎组合泛型和可变参数（Java-7，9-新增）" class="headerlink" title="第32条 谨慎组合泛型和可变参数（Java 7，9 新增）"></a>第32条 谨慎组合泛型和可变参数（Java 7，9 新增）</h4><h4 id="第33条-优先考虑类型安全的异构容器"><a href="#第33条-优先考虑类型安全的异构容器" class="headerlink" title="第33条 优先考虑类型安全的异构容器"></a>第33条 优先考虑类型安全的异构容器</h4><h3 id="第六章-枚举和注解"><a href="#第六章-枚举和注解" class="headerlink" title="第六章 枚举和注解"></a>第六章 枚举和注解</h3><h4 id="第34条-用enum代替int常量"><a href="#第34条-用enum代替int常量" class="headerlink" title="第34条 用enum代替int常量"></a>第34条 用enum代替int常量</h4><h4 id="第35条-用实例域代替序数"><a href="#第35条-用实例域代替序数" class="headerlink" title="第35条 用实例域代替序数"></a>第35条 用实例域代替序数</h4><h4 id="第36条-用EnumSet代替位域"><a href="#第36条-用EnumSet代替位域" class="headerlink" title="第36条 用EnumSet代替位域"></a>第36条 用EnumSet代替位域</h4><h4 id="第37条-用EnumMap代替序数索引"><a href="#第37条-用EnumMap代替序数索引" class="headerlink" title="第37条 用EnumMap代替序数索引"></a>第37条 用EnumMap代替序数索引</h4><h4 id="第38条-用接口模拟可扩展的枚举"><a href="#第38条-用接口模拟可扩展的枚举" class="headerlink" title="第38条 用接口模拟可扩展的枚举"></a>第38条 用接口模拟可扩展的枚举</h4><h4 id="第39条-注解优于命名模式"><a href="#第39条-注解优于命名模式" class="headerlink" title="第39条 注解优于命名模式"></a>第39条 注解优于命名模式</h4><h4 id="第40条-坚持使用Override注解"><a href="#第40条-坚持使用Override注解" class="headerlink" title="第40条 坚持使用Override注解"></a>第40条 坚持使用Override注解</h4><h4 id="第41条-标记接口定义类型"><a href="#第41条-标记接口定义类型" class="headerlink" title="第41条 标记接口定义类型"></a>第41条 标记接口定义类型</h4><h3 id="第七章-Lambda表达式和流"><a href="#第七章-Lambda表达式和流" class="headerlink" title="第七章 Lambda表达式和流"></a>第七章 Lambda表达式和流</h3><h4 id="第42条-Lambda表达式优于匿名类（Java8-新增）"><a href="#第42条-Lambda表达式优于匿名类（Java8-新增）" class="headerlink" title="第42条 Lambda表达式优于匿名类（Java8 新增）"></a>第42条 Lambda表达式优于匿名类（Java8 新增）</h4><h4 id="第43条-方法引用优于Lambda表达式（Java8-新增）"><a href="#第43条-方法引用优于Lambda表达式（Java8-新增）" class="headerlink" title="第43条 方法引用优于Lambda表达式（Java8 新增）"></a>第43条 方法引用优于Lambda表达式（Java8 新增）</h4><h4 id="第44条-优先使用标准的函数式接口（Java8-新增）"><a href="#第44条-优先使用标准的函数式接口（Java8-新增）" class="headerlink" title="第44条 优先使用标准的函数式接口（Java8 新增）"></a>第44条 优先使用标准的函数式接口（Java8 新增）</h4><h4 id="第45条-谨慎使用流（Java8-新增）"><a href="#第45条-谨慎使用流（Java8-新增）" class="headerlink" title="第45条 谨慎使用流（Java8 新增）"></a>第45条 谨慎使用流（Java8 新增）</h4><h4 id="第46条-在流中优先使用无副作用的函数（Java8-新增）"><a href="#第46条-在流中优先使用无副作用的函数（Java8-新增）" class="headerlink" title="第46条 在流中优先使用无副作用的函数（Java8 新增）"></a>第46条 在流中优先使用无副作用的函数（Java8 新增）</h4><h4 id="第47条-在返回类型中Collection优先于Stream（Java8-新增）"><a href="#第47条-在返回类型中Collection优先于Stream（Java8-新增）" class="headerlink" title="第47条 在返回类型中Collection优先于Stream（Java8 新增）"></a>第47条 在返回类型中Collection优先于Stream（Java8 新增）</h4><h4 id="第48条-使用并行流的时候要小心（Java8-新增）"><a href="#第48条-使用并行流的时候要小心（Java8-新增）" class="headerlink" title="第48条 使用并行流的时候要小心（Java8 新增）"></a>第48条 使用并行流的时候要小心（Java8 新增）</h4><h3 id="第八章-方法"><a href="#第八章-方法" class="headerlink" title="第八章 方法"></a>第八章 方法</h3><h4 id="第49条-检查参数的有效性（Java7-更新）"><a href="#第49条-检查参数的有效性（Java7-更新）" class="headerlink" title="第49条 检查参数的有效性（Java7 更新）"></a>第49条 检查参数的有效性（Java7 更新）</h4><h4 id="第50条-必要时进行保护性拷贝（Java8-更新）"><a href="#第50条-必要时进行保护性拷贝（Java8-更新）" class="headerlink" title="第50条 必要时进行保护性拷贝（Java8 更新）"></a>第50条 必要时进行保护性拷贝（Java8 更新）</h4><h4 id="第51条-谨慎设计方法签名"><a href="#第51条-谨慎设计方法签名" class="headerlink" title="第51条 谨慎设计方法签名"></a>第51条 谨慎设计方法签名</h4><h4 id="第52条-慎用重载"><a href="#第52条-慎用重载" class="headerlink" title="第52条 慎用重载"></a>第52条 慎用重载</h4><h4 id="第53条-慎用可变参数"><a href="#第53条-慎用可变参数" class="headerlink" title="第53条 慎用可变参数"></a>第53条 慎用可变参数</h4><h4 id="第54条-返回空集合或者数组，而不是null"><a href="#第54条-返回空集合或者数组，而不是null" class="headerlink" title="第54条 返回空集合或者数组，而不是null"></a>第54条 返回空集合或者数组，而不是null</h4><h4 id="第55条-谨慎返回Optional（Java8-新增）"><a href="#第55条-谨慎返回Optional（Java8-新增）" class="headerlink" title="第55条 谨慎返回Optional（Java8 新增）"></a>第55条 谨慎返回Optional（Java8 新增）</h4><h4 id="第56条-为所有导出的API元素写文档注释（Java7，8，9-更新）"><a href="#第56条-为所有导出的API元素写文档注释（Java7，8，9-更新）" class="headerlink" title="第56条 为所有导出的API元素写文档注释（Java7，8，9 更新）"></a>第56条 为所有导出的API元素写文档注释（Java7，8，9 更新）</h4><h3 id="第九章-通用程序设计"><a href="#第九章-通用程序设计" class="headerlink" title="第九章 通用程序设计"></a>第九章 通用程序设计</h3><h4 id="第57条-将局部变量的作用域最小化"><a href="#第57条-将局部变量的作用域最小化" class="headerlink" title="第57条 将局部变量的作用域最小化"></a>第57条 将局部变量的作用域最小化</h4><h4 id="第58条-for-each循环优先于传统for循环"><a href="#第58条-for-each循环优先于传统for循环" class="headerlink" title="第58条 for-each循环优先于传统for循环"></a>第58条 for-each循环优先于传统for循环</h4><h4 id="第59条-了解和使用类库（Java7，9-更新）"><a href="#第59条-了解和使用类库（Java7，9-更新）" class="headerlink" title="第59条 了解和使用类库（Java7，9 更新）"></a>第59条 了解和使用类库（Java7，9 更新）</h4><h4 id="第60条-如果需要精确的答案，请避免使用float和double"><a href="#第60条-如果需要精确的答案，请避免使用float和double" class="headerlink" title="第60条 如果需要精确的答案，请避免使用float和double"></a>第60条 如果需要精确的答案，请避免使用float和double</h4><h4 id="第61条-基本类型优先于装箱基本类型"><a href="#第61条-基本类型优先于装箱基本类型" class="headerlink" title="第61条 基本类型优先于装箱基本类型"></a>第61条 基本类型优先于装箱基本类型</h4><h4 id="第62条-如果有其他类型更合适，则尽量避免使用String"><a href="#第62条-如果有其他类型更合适，则尽量避免使用String" class="headerlink" title="第62条 如果有其他类型更合适，则尽量避免使用String"></a>第62条 如果有其他类型更合适，则尽量避免使用String</h4><h4 id="第63条-当心String连接的性能"><a href="#第63条-当心String连接的性能" class="headerlink" title="第63条 当心String连接的性能"></a>第63条 当心String连接的性能</h4><h4 id="第64条-通过接口引用对象"><a href="#第64条-通过接口引用对象" class="headerlink" title="第64条 通过接口引用对象"></a>第64条 通过接口引用对象</h4><h4 id="第65条-接口优先于反射机制"><a href="#第65条-接口优先于反射机制" class="headerlink" title="第65条 接口优先于反射机制"></a>第65条 接口优先于反射机制</h4><h4 id="第66条-谨慎使用本地方法"><a href="#第66条-谨慎使用本地方法" class="headerlink" title="第66条 谨慎使用本地方法"></a>第66条 谨慎使用本地方法</h4><h4 id="第67条-谨慎地进行优化"><a href="#第67条-谨慎地进行优化" class="headerlink" title="第67条 谨慎地进行优化"></a>第67条 谨慎地进行优化</h4><h4 id="第68条-遵守普遍接受的命名惯例"><a href="#第68条-遵守普遍接受的命名惯例" class="headerlink" title="第68条 遵守普遍接受的命名惯例"></a>第68条 遵守普遍接受的命名惯例</h4><h3 id="第十章-异常"><a href="#第十章-异常" class="headerlink" title="第十章 异常"></a>第十章 异常</h3><h4 id="第69条-只针对异常的情况才使用异常"><a href="#第69条-只针对异常的情况才使用异常" class="headerlink" title="第69条 只针对异常的情况才使用异常"></a>第69条 只针对异常的情况才使用异常</h4><h4 id="第70条-对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#第70条-对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="第70条 对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>第70条 对可恢复的情况使用受检异常，对编程错误使用运行时异常</h4><h4 id="第71条-避免不必要地使用受检异常"><a href="#第71条-避免不必要地使用受检异常" class="headerlink" title="第71条 避免不必要地使用受检异常"></a>第71条 避免不必要地使用受检异常</h4><h4 id="第72条-优先使用标准的异常"><a href="#第72条-优先使用标准的异常" class="headerlink" title="第72条 优先使用标准的异常"></a>第72条 优先使用标准的异常</h4><h4 id="第73条-抛出与抽象相对应的异常"><a href="#第73条-抛出与抽象相对应的异常" class="headerlink" title="第73条 抛出与抽象相对应的异常"></a>第73条 抛出与抽象相对应的异常</h4><h4 id="第74条-每个方法抛出的异常都要有文档"><a href="#第74条-每个方法抛出的异常都要有文档" class="headerlink" title="第74条 每个方法抛出的异常都要有文档"></a>第74条 每个方法抛出的异常都要有文档</h4><h4 id="第75条-在细节消息中包含能捕获失败的信息"><a href="#第75条-在细节消息中包含能捕获失败的信息" class="headerlink" title="第75条 在细节消息中包含能捕获失败的信息"></a>第75条 在细节消息中包含能捕获失败的信息</h4><h4 id="第76条-努力使失败保持原子性"><a href="#第76条-努力使失败保持原子性" class="headerlink" title="第76条 努力使失败保持原子性"></a>第76条 努力使失败保持原子性</h4><h4 id="第77条-不要顾略异常"><a href="#第77条-不要顾略异常" class="headerlink" title="第77条 不要顾略异常"></a>第77条 不要顾略异常</h4><h3 id="第十一章-并发"><a href="#第十一章-并发" class="headerlink" title="第十一章 并发"></a>第十一章 并发</h3><h4 id="第78条-同步访问共享的可变数据"><a href="#第78条-同步访问共享的可变数据" class="headerlink" title="第78条 同步访问共享的可变数据"></a>第78条 同步访问共享的可变数据</h4><h4 id="第79条-避免过度同步"><a href="#第79条-避免过度同步" class="headerlink" title="第79条 避免过度同步"></a>第79条 避免过度同步</h4><h4 id="第80条-executors，task，stream优先于线程（Java7，8更新）"><a href="#第80条-executors，task，stream优先于线程（Java7，8更新）" class="headerlink" title="第80条 executors，task，stream优先于线程（Java7，8更新）"></a>第80条 executors，task，stream优先于线程（Java7，8更新）</h4><h4 id="第81条-并发工具优先于wait和notify"><a href="#第81条-并发工具优先于wait和notify" class="headerlink" title="第81条 并发工具优先于wait和notify"></a>第81条 并发工具优先于wait和notify</h4><h4 id="第82条-线程安全文档化"><a href="#第82条-线程安全文档化" class="headerlink" title="第82条 线程安全文档化"></a>第82条 线程安全文档化</h4><h4 id="第83条-慎用延迟初始化"><a href="#第83条-慎用延迟初始化" class="headerlink" title="第83条 慎用延迟初始化"></a>第83条 慎用延迟初始化</h4><h4 id="第84条-不要依赖线程调度器（Java7-更新）"><a href="#第84条-不要依赖线程调度器（Java7-更新）" class="headerlink" title="第84条 不要依赖线程调度器（Java7 更新）"></a>第84条 不要依赖线程调度器（Java7 更新）</h4><h3 id="第十二章-序列化"><a href="#第十二章-序列化" class="headerlink" title="第十二章 序列化"></a>第十二章 序列化</h3><h4 id="第85条-其他选择优先于Java序列化（新增）"><a href="#第85条-其他选择优先于Java序列化（新增）" class="headerlink" title="第85条 其他选择优先于Java序列化（新增）"></a>第85条 其他选择优先于Java序列化（新增）</h4><h4 id="第86条-谨慎实现Serializable接口"><a href="#第86条-谨慎实现Serializable接口" class="headerlink" title="第86条 谨慎实现Serializable接口"></a>第86条 谨慎实现Serializable接口</h4><h4 id="第87条-考虑使用自定义的序列化形式"><a href="#第87条-考虑使用自定义的序列化形式" class="headerlink" title="第87条 考虑使用自定义的序列化形式"></a>第87条 考虑使用自定义的序列化形式</h4><h4 id="第88条-保护性编写readObject方法"><a href="#第88条-保护性编写readObject方法" class="headerlink" title="第88条 保护性编写readObject方法"></a>第88条 保护性编写readObject方法</h4><h4 id="第89条-对于实例控制，枚举类型优先于readResolve"><a href="#第89条-对于实例控制，枚举类型优先于readResolve" class="headerlink" title="第89条 对于实例控制，枚举类型优先于readResolve"></a>第89条 对于实例控制，枚举类型优先于readResolve</h4><h4 id="第90条-考虑用序列化代理代替序列化实例"><a href="#第90条-考虑用序列化代理代替序列化实例" class="headerlink" title="第90条 考虑用序列化代理代替序列化实例"></a>第90条 考虑用序列化代理代替序列化实例</h4><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://my.oschina.net/u/2277632/blog/1618901" target="_blank" rel="external">Effective Java 第三版有什么新料 译</a></li>
<li><a href="https://www.jianshu.com/p/d29f85f0f93e" target="_blank" rel="external">《Effective Java 第三版》新条目介绍</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：越学越迷茫，有所谓的重点吗？我反正现在还弄不清楚，既然弄不清楚，那就好好专注于脚下吧。我曾经看过一遍Effective Java第二版，可能那个时候的代码量还不够吧，不能理解其精髓，现在看看才能回味一点。刚好今年年初第三版（英文版）也出来，新增了Java7、8、9的一些条目，这里也就想列一些第三版的目录，供自己查找与实践，希望自己能够看到条目就能说出所以然来，也想翻译一下新增的一些条目。大家也可以互相交流。
    
    </summary>
    
      <category term="摆脱烂代码" scheme="http://bestlixiang.site/categories/%E6%91%86%E8%84%B1%E7%83%82%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="Java" scheme="http://bestlixiang.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot+Git+Jenkins+Docker实现CI/CD</title>
    <link href="http://bestlixiang.site/2018/07/18/%E8%BF%90%E7%BB%B4/SpringBoot-Git-Jenkins-Docker%E5%AE%9E%E7%8E%B0CI-CD/"/>
    <id>http://bestlixiang.site/2018/07/18/运维/SpringBoot-Git-Jenkins-Docker实现CI-CD/</id>
    <published>2018-07-18T01:03:46.000Z</published>
    <updated>2018-07-18T02:56:30.888Z</updated>
    
    <content type="html"><![CDATA[<p>引：现在DevOps这么运行，你没有理由不去了解，不去实践，这次就以Springboot为底，利用Git，jenkins，Docker实现持续集成和持续部署！<a id="more"></a></p>
<h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>下面是常用的开发流程图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com//cicd/devops.jpg" alt="dev"></p>
<p>我们简单说说这张图：首先我们会将代码文件、测试文件以及Dockerfile都存在代码仓库里，版本控制利用git，这里代码仓库有很多选择，比如github、码云(本次使用)、Coding以及自己搭建的gitlab。然后由持续集成工具进行自动化构建，包括了测试、编译、打包、构建镜像、推送镜像到仓库（有很多选择，如docker官方仓库，时速运、自己搭建的Registry）、启动服务等操作，持续集成工具也有很多选择，比如Jenkins(这次使用)、Gitlab CI、Trivas CI。这里使用的容器是Docker，这里Docker的编排工具可以选择Swarm，也可以是K8S。</p>
<p>本次实现流程如下：</p>
<ol>
<li>push代码到码云触发WebHook</li>
<li>Jenkins从码云拉取代码</li>
<li>maven构建代码</li>
<li>build镜像</li>
<li>push镜像到镜像仓库</li>
<li>部署服务</li>
</ol>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>关于Jdk、Git、Maven的配置这里就不说，自己面向搜索引擎。这里主要说Jenkins和码云的配置。</p>
<h2 id="Jenkins安装配置"><a href="#Jenkins安装配置" class="headerlink" title="Jenkins安装配置"></a>Jenkins安装配置</h2><ol>
<li><a href="https://jenkins.io/download/" target="_blank" rel="external">下载Jenkins</a>（采用war包安装）</li>
<li>将war包放入Tomcat的webapps目录下</li>
<li>进入YourHostIp:8080/jenkins路径下进行Jenkins的初始化，我们进入 <strong>用户自定义插件</strong> 安装界面，你可以根据自己的构建方式选择需要安装的插件，本次使用的Pipelines方式进行构建，Pipelines方式是Jenkins2推荐的方式，所以我们构建Pipelines相关的插件进行安装，当然待会进入Jenkins安装也行。</li>
<li>配置用户名和密码</li>
<li>全局工具配置（从系统管理进入全局工具配置，配置Jdk、Git、Maven）</li>
<li><p>安全配置（从系统管理进入全局安全配置）,如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com//cici/jenkins_security.jpg" alt="jenkins_security"></p>
</li>
</ol>
<h2 id="Jenkins构建任务"><a href="#Jenkins构建任务" class="headerlink" title="Jenkins构建任务"></a>Jenkins构建任务</h2><ol>
<li>新建任务，构建一个流水线任务（Pipeline）</li>
<li><p>在配置里构建触发器，如下图：</p>
<p> <img src="http://o6plzvjf2.bkt.clouddn.com//cicd/jenkins_webhooks_url.jpg" alt="jenkins_webhooks_url"></p>
</li>
<li><p>构建Pipeline脚本（Pipeline脚本写法见参考）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">  #!groovy</div><div class="line">  pipeline&#123;</div><div class="line">    agent any</div><div class="line">    //定义仓库地址</div><div class="line">    environment &#123;</div><div class="line">        REPOSITORY=&quot;https://gitee.com/todorex/springboot_docker_git_jenkins_demo.git&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    stages &#123;</div><div class="line"></div><div class="line">        stage(&apos;获取代码&apos;)&#123;</div><div class="line">            steps &#123;</div><div class="line">                echo &quot;start fetch code from git:$&#123;REPOSITORY&#125;&quot;</div><div class="line">                // 清空当前目录</div><div class="line">                deleteDir()</div><div class="line">                // 拉取代码    </div><div class="line">                git &quot;$&#123;REPOSITORY&#125;&quot;</div><div class="line">                // 清空之前的容器</div><div class="line">                sh &apos;docker stop $(docker ps -a -q)&apos;</div><div class="line">                sh &apos;docker rm $(docker ps -a -q)&apos;</div><div class="line">            &#125;</div><div class="line">        &#125;       </div><div class="line"></div><div class="line">        stage(&apos;Maven 构建&apos;)&#123;</div><div class="line">            steps &#123;</div><div class="line">                echo &quot;start compile&quot;</div><div class="line">                // 切换目录</div><div class="line">                dir(&apos;demo&apos;) &#123;</div><div class="line">                    // 重新打包</div><div class="line">                    sh &apos;mvn -Dmaven.test.skip=true -U clean install&apos;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        stage(&apos;构建镜像&apos;)&#123;</div><div class="line">            steps &#123;</div><div class="line">                echo &quot;start build image&quot;</div><div class="line">                dir(&apos;demo&apos;) &#123;</div><div class="line">                    // build镜像</div><div class="line">                    sh &apos;docker build -t todorex/springboot_docker_git_jenkins_demo:1.0 .&apos;</div><div class="line">                    // 登录镜像仓库</div><div class="line">                    sh &apos;docker login -u your_username -p your_password&apos;</div><div class="line">                    // 推送镜像到镜像仓库</div><div class="line">                    sh &apos;docker push todorex/springboot_docker_git_jenkins_demo:1.0&apos;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        stage(&apos;启动服务&apos;)&#123;</div><div class="line">            steps &#123;</div><div class="line">                echo &quot;start demo&quot;</div><div class="line">                // 部署服务</div><div class="line">                sh &apos;docker run -d -p 8888:8888 --name=demo todorex/springboot_docker_git_jenkins_demo:1.0&apos;</div><div class="line">            &#125;</div><div class="line">        &#125;                </div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="SSH的配置"><a href="#SSH的配置" class="headerlink" title="SSH的配置"></a>SSH的配置</h2><p>为了避免jenkins拉取代码时需要输入密码，这里需要配置SSH免密码拉取。如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com//cicd/gitee_ssh.jpg" alt="gitee_ssh"></p>
<h2 id="WebHooks配置"><a href="#WebHooks配置" class="headerlink" title="WebHooks配置"></a>WebHooks配置</h2><p>当你每次对代码仓库进行push操作时，会自动通知jenkins进行构建<br><img src="http://o6plzvjf2.bkt.clouddn.com//cicd/gitee_webhooks.jpg" alt="gitee_webhooks"></p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>这次项目的代码仓库为：<a href="https://gitee.com/todorex/springboot_docker_git_jenkins_demo" target="_blank" rel="external">springboot_docker_git_jenkins_demo</a></p>
<p>关于Dockerfile以及docker-compose.yml的编写，自己也去面向搜索引擎看看吧。</p>
<p>当我们push代码之后，jenkins就会自动帮我们进行构建。如下图：<br><img src="http://o6plzvjf2.bkt.clouddn.com//cicd/jenkins_test.jpg" alt="jenkins_test"></p>
<p>PS：第一次比较慢是因为要安装Maven依赖，后面就好了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里只是展示了一个CI/CD的开发流程，关于具体技术细节，无论是Jenkins还是Docker都需要深入学习，加油，骚年！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://niocoder.com/2018/04/22/SpringBoot+Docker+Git+Jenkins%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%92%8C%E9%83%A8%E7%BD%B2/" target="_blank" rel="external">SpringBoot+Docker+Git+Jenkins实现简易的持续集成和持续部署</a></li>
<li><a href="http://www.cnblogs.com/fengjian2016/p/8227532.html" target="_blank" rel="external">Jenkins pipeline：pipeline 语法详解</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：现在DevOps这么运行，你没有理由不去了解，不去实践，这次就以Springboot为底，利用Git，jenkins，Docker实现持续集成和持续部署！
    
    </summary>
    
      <category term="运维" scheme="http://bestlixiang.site/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="SpringBoot" scheme="http://bestlixiang.site/tags/SpringBoot/"/>
    
      <category term="Git" scheme="http://bestlixiang.site/tags/Git/"/>
    
      <category term="Jenkins" scheme="http://bestlixiang.site/tags/Jenkins/"/>
    
      <category term="Docker" scheme="http://bestlixiang.site/tags/Docker/"/>
    
      <category term="CI" scheme="http://bestlixiang.site/tags/CI/"/>
    
      <category term="CD" scheme="http://bestlixiang.site/tags/CD/"/>
    
  </entry>
  
  <entry>
    <title>Maven使用整理</title>
    <link href="http://bestlixiang.site/2018/07/06/%E5%B7%A5%E5%85%B7/Maven%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/"/>
    <id>http://bestlixiang.site/2018/07/06/工具/Maven使用整理/</id>
    <published>2018-07-06T14:03:35.000Z</published>
    <updated>2018-07-06T14:06:36.067Z</updated>
    
    <content type="html"><![CDATA[<p>引：使用Java语言来开发你的项目，基本上都少不了Maven，因为有了它真是太方便了！<a id="more"></a></p>
<h1 id="什么是Maven"><a href="#什么是Maven" class="headerlink" title="什么是Maven"></a>什么是Maven</h1><p><a href="https://maven.apache.org/" target="_blank" rel="external">Maven</a>是一种用来管理Java项目的工具、但不是那种那种用来管理资源规划和调度的工具。相反，它处理的时一个具体的项目所涉及的各种任务，如编译、测试、打包以及部署。</p>
<p>Maven包括以下几个部分：</p>
<ul>
<li><p>一组用于处理管理依赖(从<a href="http://mvnrepository.com/" target="_blank" rel="external">中央仓库</a>拉取的jar包)、<a href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html" target="_blank" rel="external">目录结构</a>以及构建工作流的<strong>约定</strong>。</p>
<p>  基于这些约定实现的标准化可以极大地简化开发过程。例如，一个常用的目录结构使得开发者可以更加容易跟上不熟悉的项目的节奏。</p>
</li>
<li><p>一个用于项目配置的<a href="http://maven.apache.org/guides/introduction/introduction-to-the-pom.html" target="_blank" rel="external">XML Schema</a>：项目对象模型(Project Object Model)，简称POM。</p>
<p>  每一个Maven项目都拥有一个POM文件，并命名为pom.xml，包含Maven用于管理该项目的所有的配置信息。</p>
</li>
<li><p>一个委托外部组件来执行项目任务的<a href="https://maven.apache.org/plugins/index.html" target="_blank" rel="external">插件结构</a>。</p>
<p>  这简化了更新一集扩展Maven能力的过程。</p>
</li>
</ul>
<h1 id="Maven安装"><a href="#Maven安装" class="headerlink" title="Maven安装"></a>Maven安装</h1><p><strong>PS：</strong> 上面提到了Maven帮我们管理依赖，是通过从中央仓库拉取jar包(依赖)来实现，但是由于Maven的中央仓库在国外，拉取会比较慢，所以我们一般会通过配置阿里云镜像来加快速度，当然你也可以<a href="https://blog.sonatype.com/" target="_blank" rel="external">Nexus</a>搭建自己的私有仓库。</p>
<ol>
<li><a href="https://blog.csdn.net/ck4438707/article/details/53377413" target="_blank" rel="external">Maven安装教程</a></li>
<li><a href="https://blog.csdn.net/u012424449/article/details/77853983" target="_blank" rel="external">配置阿里云镜像仓库</a></li>
</ol>
<h1 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h1><p>POM文件大纲如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;project&gt; // 根元素</div><div class="line">    &lt;groupId/&gt;</div><div class="line">    &lt;artifactId/&gt;</div><div class="line">    &lt;version/&gt; // 上面三个(GAV坐标)唯一地定义Maven项目的值</div><div class="line">    &lt;packaging/&gt; // 项目打包方式，默认值是jar</div><div class="line">    &lt;properties/&gt; // 在POM中引用的属性，一般会放版本信息</div><div class="line">    &lt;dependencies/&gt; //构建当前项目所需要的其他Maven项目</div><div class="line">    &lt;build/&gt; // 构建改项目所需要执行的任务的配置</div><div class="line">    &lt;profiles/&gt; // 为不同的用例自定义POM，一般用来配置环境的切换</div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Maven构件"><a href="#Maven构件" class="headerlink" title="Maven构件"></a>Maven构件</h2><p>任何可以被Maven的坐标系统(GAV)唯一标识的对象都是一个Maven构件。</p>
<p>Maven构件的类型由pom文件的<packaging>元素指定。最常用的值是pom、jar、ear、war以及maven-plugin。</packaging></p>
<h2 id="POM文件使用方式"><a href="#POM文件使用方式" class="headerlink" title="POM文件使用方式"></a>POM文件使用方式</h2><ol>
<li>默认的：用于构建一个构件</li>
<li>父POM：提供一个由子项目继承的单个配置信息源，子项目通过声明这个pom文件作为它们的<parent>元素值</parent></li>
<li>聚合器：用于构建一组声明为<modules>的项目，这些子项目位于其当前聚合器项目的文件夹中，每个都包含有他自己的pom文件</modules></li>
</ol>
<p><strong>PS：</strong> 作为父pom或者聚合器的pom文件的<packaging>元素的值将是pom。</packaging></p>
<h2 id="GAV坐标"><a href="#GAV坐标" class="headerlink" title="GAV坐标"></a>GAV坐标</h2><p>POM定义了5种称为坐标的元素，用于标识Maven构件，首字母缩写GAV指的是必须始终指定的3个坐标<groupid>、<artifactid>、<version> 的首字母。</version></artifactid></groupid></p>
<p>下面的坐标是按照他们在坐标表达式中出现的顺序列出：</p>
<ol>
<li><groupid>是项目或者项目组的<strong>全局唯一标识符</strong>。这通常是Java源代码使员工的全限定的Java包名。例如，io.netty、com.google。</groupid></li>
<li><artifactid>用于标识和某个<groupdid>相关的不同的构件。例如，netty-all、netty-handler。</groupdid></artifactid></li>
<li><type>是指和项目相关的主要构件的类型(对应于构件的POM文件中的<packaging>值)。它的默认值是jar，此外还有pom、ear。</packaging></type></li>
<li><version>标识了构件的版本、例如1.1、2.0-SNAPSHOT、4.1.9.Final。</version></li>
<li><classifier>用于区分属于相同的POM但是却被以不同方式构建的构件。例如，javadock、sources、jdk16、jdk17。</classifier></li>
</ol>
<p>一个完整的坐标表达式具有如下格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">actifactId:groupId:packaging:version:classifier</div></pre></td></tr></table></figure></p>
<p>POM文件必须声明它所管理的构件的坐标，一个具有如下坐标的项目：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;groupId&gt;io.netty&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;netty-all&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;4.1.9.Final&lt;/version&gt;</div><div class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</div></pre></td></tr></table></figure></p>
<p>将会产生一个具有以下格式的名称的构件：<br><code>artifactId-&lt;version&gt;.&lt;packaging&gt;</code></p>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><h2 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h2><p>项目的依赖是指编译和执行它所需要的外部构件。在大多数情况下，你的项目的依赖项也会有它自己的依赖。我们称这些依赖为你的项目的<strong>传递依赖</strong>。一个负责的项目可能会有一个深层级的<strong>依赖树</strong>。Maven 提供了各种用于帮助理解和管理它的工具，如执行<code>mvn dependency:tree</code>。</p>
<p>Maven的<dependency>声明在POM的<dependencies>元素中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">  &lt;dependency&gt;</div><div class="line">    &lt;groupId/&gt;</div><div class="line">    &lt;artifactId/&gt;</div><div class="line">    &lt;version/&gt;</div><div class="line">    &lt;type/&gt;</div><div class="line">    &lt;scope/&gt;</div><div class="line">    &lt;systemPath/&gt;</div><div class="line">  &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure></dependencies></dependency></p>
<p>在<dependency>声明中，GAV坐标是必不可少的。type和scope元素对于那些值不分别是默认值jar和compile的依赖来说也是必须的。</dependency></p>
<p>关于scope指的是依赖范围，即classpath，Maven里有3类依赖范围：</p>
<ul>
<li>编译</li>
<li>测试</li>
<li>运行</li>
</ul>
<p><scope>元素具有以下值（依赖范围）：</scope></p>
<ul>
<li>compile：编译（默认）</li>
<li>runtime：运行</li>
<li>provided：对于编译和测试有效，运行时无效</li>
<li>test：测试</li>
<li>import：使用在<dependencymanagement>中，导入其他项目的<dependencymanagement></dependencymanagement></dependencymanagement></li>
<li>systemPath：与provided一直，但是需要指定依赖文件的绝对位置</li>
</ul>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>POM的<dependencymanagement>元素可以包含被其他项目使用的<dependency>声明（但不拉取），这样的POM的子项目会自动继承这些声明，其他项目可以用过使用<scope>元素值来导入他们。</scope></dependency></dependencymanagement></p>
<p>引用了<dependencymanagement>元素的项目可以使用它所声明的依赖，而不需要指定他们的<version>坐标，如果<dependencymanagement>中的<version>在稍后改变，则所有应用它的pom都会改变。</version></dependencymanagement></version></dependencymanagement></p>
<p><strong>最佳实践</strong>：在原POM中的所有版本都利用<properties>元素控制。</properties></p>
<h1 id="构件的生命周期"><a href="#构件的生命周期" class="headerlink" title="构件的生命周期"></a>构件的生命周期</h1><p>Maven的生命周期就是为了对所有的构建过程进行抽象和统一。这个生命周期包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有构建步骤。也就是说，几所所有的项目的构建，都能映射到这样一个生命周期上。</p>
<p>Maven拥有三套相互独立生命周期，他们分别为clean、default和site。clean生命周期的目的是清理项目、default生命周期的目的是构建项目、site生命周期的目的是建立项目站点。每个生命周期包含一些阶段，这些阶段是有顺序的，并且后面的阶段依赖于前面的阶段。但是三套生命周期本身是相互独立的。我们按照日常的需求，我们只说前两个。</p>
<h2 id="clean生命周期"><a href="#clean生命周期" class="headerlink" title="clean生命周期"></a>clean生命周期</h2><p>它包含三个阶段：</p>
<ol>
<li>pre-clean：执行清理前要完成的工作。</li>
<li>clean：清理上一次构建生成的文件。</li>
<li>post-clean：执行一些清理后需要完成的工作。</li>
</ol>
<h2 id="default生命周期"><a href="#default生命周期" class="headerlink" title="default生命周期"></a>default生命周期</h2><p>default生命周期定义了真正构建时所需要执行的而所有步骤，这里也只是列出重要的阶段：</p>
<ol>
<li>validate：检查项目是否正确</li>
<li>compile：编译项目的源代码</li>
<li>test：使用单元测试框架进行测试，测试代码不会被打包部署</li>
<li>package：将编译的代码打包为可发布的格式，如jar</li>
<li>verify：验证软件包是否有效</li>
<li>install：将包安装到本地仓库中，可以供本地其他Maven项目使用</li>
<li>deploy：将包复制到远程仓库中，可以供其他开发人员使用</li>
</ol>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>虽然Maven协调了所有构建生命周期阶段的执行，但是他并没有直接实现它们，而是将他们委托给了<strong>插件</strong>。这些插件是maven-plugin类型的构件(打包为JAR文件)。Maven为标准构件生命周期所定义的所有任务都提供了插件，但更多的是由第三方生产的，用于处理各种自定义的任务。</p>
<h2 id="插件目标"><a href="#插件目标" class="headerlink" title="插件目标"></a>插件目标</h2><p>每个插件都有很多功能，每个插件功能对应了插件一个目标。如我们之前分析依赖的maven-dependency-plugin，它就有十多个目标，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 命令行冒号前面是插件，冒号后面是目标（功能）</div><div class="line">mvn dependency:analyze</div><div class="line">mvn dependency:tree</div><div class="line">mvn dependency:list</div></pre></td></tr></table></figure></p>
<h2 id="插件绑定"><a href="#插件绑定" class="headerlink" title="插件绑定"></a>插件绑定</h2><p>Maven的生命周期与插件相互绑定，用以完成实际的构建任务。</p>
<h3 id="内置绑定"><a href="#内置绑定" class="headerlink" title="内置绑定"></a>内置绑定</h3><p>为了让用户几乎不用任何配置就能构建Maven项目，Maven为一些主要的生命周期阶段绑定了很多插件的目标，如：</p>
<ol>
<li>maven-clean-plugin:clean绑定了clean</li>
<li>maven-compiler-plugin:compile绑定了compile</li>
<li>maven-surefire-plugin:test绑定了test</li>
<li>maven-jar-plugin:jar绑定package默认</li>
<li>maven-install-plugin:install绑定了install</li>
</ol>
<h3 id="自定义绑定"><a href="#自定义绑定" class="headerlink" title="自定义绑定"></a>自定义绑定</h3><p>除了内置绑定之外，用户还能够自己选择将某个插件目标绑定到生命周期的某个阶段上。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;build&gt;</div><div class="line">    &lt;plugins&gt;</div><div class="line">        &lt;plugin&gt;</div><div class="line">           &lt;!--引入插件--&gt;</div><div class="line">           &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</div><div class="line">            &lt;version&gt;3.0.1&lt;/version&gt;</div><div class="line">            &lt;!--构建任务--&gt;</div><div class="line">            &lt;executions&gt;</div><div class="line">                &lt;execution&gt;</div><div class="line">                    &lt;id&gt;attach-source&lt;/id&gt;</div><div class="line">                    &lt;!--绑定阶段--&gt;</div><div class="line">                    &lt;phase&gt;verify&lt;/phase&gt;</div><div class="line">                    &lt;!--绑定目标--&gt;</div><div class="line">                    &lt;goals&gt;</div><div class="line">                        &lt;goal&gt;jar-no-fork&lt;/goal&gt;</div><div class="line">                    &lt;/goals&gt;</div><div class="line">                &lt;/execution&gt;</div><div class="line">            &lt;/executions&gt;</div><div class="line">        &lt;/plugin&gt;</div><div class="line">    &lt;/plugins&gt;</div><div class="line">&lt;/build&gt;</div></pre></td></tr></table></figure></p>
<p>很多插件的目标在编写是就已经定义了默认绑定阶段，可以利用maven-help-plugin查看插件详细信息，了解插件目标的默认绑定阶段。运行命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn help:describe -Dplugin=org.apache.maven.plugins:maven-source-plugin:3.0.1</div></pre></td></tr></table></figure></p>
<p>如果多个目标被绑定到同一个阶段的时候，这些插件声明的先后顺序决定了目标的执行顺序。</p>
<h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><h3 id="命令行插件配置"><a href="#命令行插件配置" class="headerlink" title="命令行插件配置"></a>命令行插件配置</h3><p>很多插件目标的参数都是支持命令行配置的，用户可以在Maven命令中使用-D参数，并伴随参数键=参数值的形式来配置插件目标的参数，如上<code>mvn help</code>。</p>
<h3 id="POM中插件全局配置"><a href="#POM中插件全局配置" class="headerlink" title="POM中插件全局配置"></a>POM中插件全局配置</h3><p>为了避免插件参数重复书写，我们可以在pom进行全局配置，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;3.0.1&lt;/version&gt;</div><div class="line">    &lt;configuration&gt;</div><div class="line">        &lt;!--编译Java1.8版本的源文件--&gt;</div><div class="line">        &lt;source&gt;1.8&lt;/source&gt;</div><div class="line">        &lt;!--生成与JVM1.8兼容的字节码文件--&gt;</div><div class="line">        &lt;target&gt;1.8&lt;/target&gt;</div><div class="line">    &lt;/configuration&gt;</div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure></p>
<h2 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h2><p>POM的<pluginmanagement>元素可以包含被其他项目使用的<plugin>声明（但不拉取），这样的POM的子项目会自动继承这些声明。</plugin></pluginmanagement></p>
<p>引用了<pluginmanagement>元素的项目可以使用它所声明的依赖，而不需要指定他们的<version>坐标，如果<pluginmanagement>中的<version>在稍后改变，则所有应用它的pom都会改变。</version></pluginmanagement></version></pluginmanagement></p>
<p><strong>最佳实践</strong>：在原POM中的所有版本都利用<properties>元素控制。</properties></p>
<h1 id="聚合和继承"><a href="#聚合和继承" class="headerlink" title="聚合和继承"></a>聚合和继承</h1><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>如果我们想要一次构建两个项目，而不是到两个模块的目录下分别执行mvn命令，那么我们可以使用<strong>Maven聚合</strong>。</p>
<p>我们先创建一个聚合构件（除了pom文件（packaging需要为pom），其他可以都不要），然后在聚合构件目录下创建两个构件，并在聚合构件下利用<modules>来声明，每个module的值都是一个当前目录的相对目录，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;modules&gt;</div><div class="line">    &lt;module&gt;email&lt;/module&gt;</div><div class="line">    &lt;module&gt;user&lt;/module&gt;</div><div class="line">&lt;/modules&gt;</div></pre></td></tr></table></figure></modules></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>如果两个项目有重复的依赖或插件，我们可以使用<strong>继承</strong>。</p>
<p>我们先创建一个父构件（除了pom文件（packaging需要为pom），其他可以都不要），然后在父构件目录下创建两个子构件，并在子构件下利用<parent>来声明继承关系，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;parent&gt;</div><div class="line">    &lt;groupId/&gt;</div><div class="line">    &lt;artifactId/&gt;</div><div class="line">    &lt;version/&gt;</div><div class="line">    &lt;relativePath&gt;父pom的相对路径&lt;/relativePath&gt;</div><div class="line">&lt;/parent&gt;</div></pre></td></tr></table></figure></parent></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/ck4438707/article/details/53377413" target="_blank" rel="external">Maven安装教程</a></li>
<li><a href="https://blog.csdn.net/u012424449/article/details/77853983" target="_blank" rel="external">配置阿里云镜像仓库</a></li>
<li>《Maven实战》</li>
<li><a href="https://www.cnblogs.com/dreamroute/p/6729147.html" target="_blank" rel="external">Maven <resource>标签</resource></a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：使用Java语言来开发你的项目，基本上都少不了Maven，因为有了它真是太方便了！
    
    </summary>
    
      <category term="工具" scheme="http://bestlixiang.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="http://bestlixiang.site/tags/Java/"/>
    
      <category term="Maven" scheme="http://bestlixiang.site/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Git使用整理</title>
    <link href="http://bestlixiang.site/2018/07/05/%E5%B7%A5%E5%85%B7/Git%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/"/>
    <id>http://bestlixiang.site/2018/07/05/工具/Git使用整理/</id>
    <published>2018-07-05T11:29:14.000Z</published>
    <updated>2018-07-10T13:29:20.198Z</updated>
    
    <content type="html"><![CDATA[<p>引：虽然日常使用git，但是有些时候总是会忘记一些操作，难免会面向搜索引擎查找。所以这里就总结一下。<a id="more"></a></p>
<h1 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h1><p>谈到Git，就需要先说说版本控制系统。<strong>版本控制系统</strong>就是能自动帮我们记录每次文件的改动的一个软件，而Git就是它的一种实现。想想我们写论文还是写代码，是不是有了他就很方便了，再也不用自己手动备份每一次修改了。版本控制系统又分为集中式和分布式。</p>
<h2 id="集中式（SVN）"><a href="#集中式（SVN）" class="headerlink" title="集中式（SVN）"></a>集中式（SVN）</h2><p><img src="http://o6plzvjf2.bkt.clouddn.com/tool/git/%E9%9B%86%E4%B8%AD%E5%BC%8F.jpg" alt="集中式"></p>
<p>集中式版本控制系统的版本库是集中存放在中央服务器的，而我们在干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。</p>
<p><strong>问题</strong>：必须联网才能工作；中央服务器要是出了问题，所有人都没法干活了</p>
<h2 id="分布式（Git）"><a href="#分布式（Git）" class="headerlink" title="分布式（Git）"></a>分布式（Git）</h2><p><img src="http://o6plzvjf2.bkt.clouddn.com/tool/git/%E5%88%86%E5%B8%83%E5%BC%8F.jpg" alt="仓库"></p>
<p>每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。在双方协作的时候，如果你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，而且如果你们俩不在一个局域网内，两台电脑也互相访问不了。所以分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
<h1 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h1><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>这里就不多说了，推荐廖雪峰的官方网站<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000" target="_blank" rel="external">安装教程</a>。</p>
<h2 id="Git区域"><a href="#Git区域" class="headerlink" title="Git区域"></a>Git区域</h2><p><img src="http://o6plzvjf2.bkt.clouddn.com/tool/git/%E5%8C%BA%E5%9F%9F.png" alt="Git区域"></p>
<ul>
<li>工作区（Workspace）：在计算机能看到的目录。</li>
<li>缓存区（Index/Stage）：临时保存我们的改动。</li>
<li>版本库（Repository）：工作区有一个隐藏的目录.git，它是Git的本地版本库。</li>
<li>远程仓库（Remote）：“Git中央服务器”，托管在网络中的项目的版本库，可供多人协作开发。（国外有<a href="https://gitee.com/" target="_blank" rel="external">基佬俱乐部Github</a>，国内有<a href="https://gitee.com/" target="_blank" rel="external">码云</a>、<a href="https://coding.net/" target="_blank" rel="external">Coding</a>、还有可个人或者公司定制的<a href="https://about.gitlab.com/" target="_blank" rel="external">GitLab</a>，请按需选择）</li>
</ul>
<h2 id="Git个人操作"><a href="#Git个人操作" class="headerlink" title="Git个人操作"></a>Git个人操作</h2><p>在上面的区域图中，其实我们已经看到很多操作，这里我再总结一下：</p>
<h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><ul>
<li><p>在当前目录新建一个Git仓库</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure>
</li>
<li><p>在当前目录克隆一个仓库</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone [url]</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="增加文件"><a href="#增加文件" class="headerlink" title="增加文件"></a>增加文件</h3><ul>
<li><p>添加指定文件/目录到暂存区</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add [file]/[dir]</div></pre></td></tr></table></figure>
</li>
<li><p>添加当前目录的所有文件到暂存区（慎用，尤其在IDE中，因为它会包含IDE的配置文件，如IDEA的.idea和iml文件）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add .</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><ul>
<li>提交缓存区的文件到仓库区  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m [改变信息]</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><ul>
<li><p>显示有变更的文件</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure>
</li>
<li><p>显示当前分支的版本历史</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log</div></pre></td></tr></table></figure>
</li>
<li><p>根据关键词搜索提交历史</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log -S [keyword]</div></pre></td></tr></table></figure>
</li>
<li><p>显示暂存区与工作区的差异</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff</div></pre></td></tr></table></figure>
</li>
<li><p>显示工作区与当前分支最新的commit之间的差异<br>  <code>git diff HEAD(当前最新commit)</code></p>
</li>
<li>上传本地指定分支到远程仓库  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push [remote] [branch]</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><ul>
<li><p>下载远程仓库的<strong>变动</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git fetch [remote远程仓库名] [分支]:[本地新分支]</div></pre></td></tr></table></figure>
</li>
<li><p>显示所有远程仓库</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote -v</div></pre></td></tr></table></figure>
</li>
<li><p>显示某个远程仓库的信息</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote show [branch]</div></pre></td></tr></table></figure>
</li>
<li><p>增加一个远程仓库并命名</p>
<p>  <code>git remote add [shortname=remote] [url]</code></p>
</li>
<li><p>上传本地指定分支到远程仓库</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push [remote] [branch]</div></pre></td></tr></table></figure>
</li>
<li><p>强行推送当前分支到远程仓库，即使有冲突<br>  <code>git push [remote] --force</code></p>
</li>
<li>推送所有分支到远程仓库<br>  <code>git push [remote] -all</code></li>
</ul>
<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><ul>
<li><p>恢复暂存区的指定文件到工作区</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout [file]</div></pre></td></tr></table></figure>
</li>
<li><p>恢复某个commit的指定文件到暂存区与工作区</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout [commit] [file]</div></pre></td></tr></table></figure>
</li>
<li><p>恢复暂存区的所有文件到工作区</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout .</div></pre></td></tr></table></figure>
</li>
<li><p>重置暂存区与工作区，与上一次commit保持一致<br>  <code>git reset --hard</code></p>
</li>
<li><p>重置当前分支的HEAD（指针，指向commit-id）为指定commit，同时重置暂存区和工作区，与指定commit一致<br>  <code>git reset --hard [commit]</code></p>
</li>
<li><p>后者的所有变化都将被前者抵消，并应用当前分支<br>  <code>git revert [commit]</code></p>
</li>
<li><p>暂时将未提交的变化移除，稍后再移入<br>  <code>git stash</code><br>  <code>git stash pop</code> </p>
</li>
</ul>
<h2 id="Git多人协作"><a href="#Git多人协作" class="headerlink" title="Git多人协作"></a>Git多人协作</h2><p>多人协作就会涉及到分支的概念（其实单人开发也会遇到，只是多人会更常见）</p>
<p>我们先看看下面的图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/tool/git/%E5%88%86%E6%94%AF.jpg" alt="多人协作"></p>
<p>这张图可以很清楚让我们认识到在工作中使用git工作流的开发流程。Master分支是线上分支，我们在开发新功能的时候不会去动它，Hotfix分支是如果出了bug就拉一条bug分支快速修复合并到master分支里。我们平时开发都是先从Master分支拉出一条Develop分支，在这个分支上进行开发。每个人一般都会负责项目的一个特性功能，所以我们又会从Develop分支拉出几个Feature分支。在开发测试完成后我们形成Release分支，再次检验后将它与Master分支合并，然后我们之后Release分支拉出Develop分支进行新一轮的开发。</p>
<h3 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h3><ul>
<li><p>列出所有本地分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch</div></pre></td></tr></table></figure>
</li>
<li><p>列出所有远程分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -r</div></pre></td></tr></table></figure>
</li>
<li><p>列出所有本地分支和远程分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -a</div></pre></td></tr></table></figure>
</li>
<li><p>新建一个分支，但依然停留在当前分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch [branch-name]</div></pre></td></tr></table></figure>
</li>
<li><p>新建一个分支，并切换到该分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b [branch]</div></pre></td></tr></table></figure>
</li>
<li><p>切换到当前指定分支，并指定工作区</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout [branch-name]</div></pre></td></tr></table></figure>
</li>
<li><p>切换到上一个分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -</div></pre></td></tr></table></figure>
</li>
<li><p>建立追踪关系，在现有分支与指定的远程分支之间</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch --set-upstream [branch] [remote-branch]</div></pre></td></tr></table></figure>
</li>
<li><p>合并指定分支到当前分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge [branch]</div></pre></td></tr></table></figure>
</li>
<li><p>删除远程分支</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d [branch-name]</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="协作冲突"><a href="#协作冲突" class="headerlink" title="协作冲突"></a>协作冲突</h3><p>在多人协作的过程中肯定会碰到这样的<strong>问题</strong>：如果你的小伙伴已经向一个分支推送了他的提交，而碰巧你也对同个分支的同样的文件作了修改，并试图推送，那么就会提交被拒绝，这个时候就需要先：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull</div></pre></td></tr></table></figure></p>
<p>等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git fetch temp(临时分支)</div><div class="line">git merge temp</div></pre></td></tr></table></figure></p>
<p>这个时候合git会将你们两个人对文件的修改都呈现在同一个文件中，你需要在与你的小伙伴商量出一个最终版，修改之后再提交上去。</p>
<h1 id="IDEA与Git"><a href="#IDEA与Git" class="headerlink" title="IDEA与Git"></a>IDEA与Git</h1><p>可能大家对使用命令行并不感冒，所以这里也为大家找了一份<a href="https://blog.csdn.net/lovecarpenter/article/details/54290045" target="_blank" rel="external">IDEA的git使用教程</a>，至此大家只要点点点就好了。当然这里还会有很多我没有涉及到的地方，就需要平时多积累了。</p>
<p>别急，别急！！还要最后一点就是 <strong>.gitignore</strong> 了！</p>
<p>我们发现在使用IDEA的时候，他默认会要求我们把所有的文件加入到git控制里，但是我们知道很多IDEA的自带配置文件是不用也没有必要加入git（之前在说git add . 的时候也说过），所以可以利用IDEA的.gitignore插件来帮助我们忽略这些没有必要的插件，这里也放一个<a href="https://blog.csdn.net/qq_34590097/article/details/56284935" target="_blank" rel="external">.gitignore教程</a>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的git教程</a></li>
<li><a href="https://blog.csdn.net/riddle1981/article/details/74938111" target="_blank" rel="external">详解git fetch与git pull的区别</a></li>
<li><a href="https://blog.csdn.net/lovecarpenter/article/details/54290045" target="_blank" rel="external">版本控制之IDEA使用Git</a></li>
<li><a href="https://blog.csdn.net/qq_34590097/article/details/56284935/" target="_blank" rel="external">如何在IntelliJ IDEA中使用.ignore插件忽略不必要提交的文件</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：虽然日常使用git，但是有些时候总是会忘记一些操作，难免会面向搜索引擎查找。所以这里就总结一下。
    
    </summary>
    
      <category term="工具" scheme="http://bestlixiang.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="IDEA" scheme="http://bestlixiang.site/tags/IDEA/"/>
    
      <category term="Git" scheme="http://bestlixiang.site/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的Java 网络IO</title>
    <link href="http://bestlixiang.site/2018/05/21/Java%E5%9F%BA%E7%A1%80/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java-%E7%BD%91%E7%BB%9CIO/"/>
    <id>http://bestlixiang.site/2018/05/21/Java基础/你不知道的Java-网络IO/</id>
    <published>2018-05-21T04:53:19.000Z</published>
    <updated>2018-05-21T04:54:17.420Z</updated>
    
    <content type="html"><![CDATA[<p>引：可能很多同学一看Java Java 网络IO，心里肯定会觉得这个有什么好讲的，不就是Socket吗，说对也对，因为他讲到了BIO(同步阻塞IO)，但是却不知还有NIO(同步非阻塞IO)，AIO(异步非阻塞IO)！<a id="more"></a></p>
<h1 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h1><p>关于BIO、NIO以及AIO的代码都放在github上了，注释应该很详细了，大家有需要的可以看一下：<a href="https://github.com/todorex/Java_IO" target="_blank" rel="external">你不知道的那些Java网络IO（BIO、NIO、AIO）</a></p>
<h1 id="同步or异步-阻塞or非阻塞"><a href="#同步or异步-阻塞or非阻塞" class="headerlink" title="同步or异步 阻塞or非阻塞"></a>同步or异步 阻塞or非阻塞</h1><p>在谈到IO的时候，避免不了听到同步、异步、阻塞、非阻塞这几个名词或者是他们的组合词，我们经常会感到迷惑不解。</p>
<h2 id="同步or异步"><a href="#同步or异步" class="headerlink" title="同步or异步"></a>同步or异步</h2><p>同步和异步是相对于IO事件(读写操作)而言的</p>
<ul>
<li>同步：在进行IO操作时，程序不能干别的事情，等着IO事件完成之后才能去做别的事情</li>
<li>异步：不关心IO处理操作(因为把IO操作交给操作系统干了)，在处理IO的时候，可以去做别的事情，然后等待IO事件处理完成的通知</li>
</ul>
<h2 id="阻塞or非阻塞"><a href="#阻塞or非阻塞" class="headerlink" title="阻塞or非阻塞"></a>阻塞or非阻塞</h2><p>阻塞和非阻塞是相对于数据而言的</p>
<ul>
<li>阻塞：如果数据没有准备好，程序就一直等待，直到数据准备好了才往下执行</li>
<li>非阻塞：不管数据有没有准备好，程序都往下进行</li>
</ul>
<p>这里是自己看到的一个例子，可以结合起来理解：</p>
<p>如果你想吃一份宫保鸡丁盖饭：</p>
<p><strong>同步阻塞</strong>：你到饭馆点餐，然后在那等着，还要一边喊：好了没啊！（IO操作[拿饭]没有干好，预想之外的事都不能干，数据[饭]没有好，就一直等着）</p>
<p><strong>同步非阻塞</strong>：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！（IO操作[拿饭]没有干好，预想之外的事都不能干，数据[饭]没有好，但是不用一直等着，可以继续干预先安排的事[遛狗]，但是需要时不时去问一下饭有没有好）</p>
<p><strong>异步阻塞</strong>：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。（IO操作[拿饭]没有干好，但是我想干啥就干啥，等着通知就好，数据[饭]没有好，就一直等着去拿饭）</p>
<p><strong>异步非阻塞</strong>：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。（IO操作[拿饭]没有干好，但是我想干啥就干啥，等着通知就好，数据[饭]没有好，但是不用一直等着，可以继续干预先安排的事）</p>
<h1 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h1><p>Unix定义了五种I/O模型，如下：</p>
<ul>
<li>阻塞I/O</li>
<li>非阻塞I/O</li>
<li>I/O复用（select、poll、linux 2.6种改进的epoll）</li>
<li>信号驱动IO（SIGIO）</li>
<li>异步I/O（POSIX的aio_系列函数）</li>
</ul>
<p>下图是五种I/O模型的比较：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/javaCore/jpg/unix_io_model.jpg" alt="unix_io_model"></p>
<p>POSIX把I/O操作划分成两类：</p>
<ul>
<li>同步I/O: 同步I/O操作<strong>导致请求阻塞</strong>，直至操作完成</li>
<li>异步I/O: 异步I/O操作<strong>不导致请求阻塞</strong></li>
</ul>
<p>从上面的图中可以看出Unix的前四种I/O模型都是同步I/O, 只有最后一种才是异步I/O。</p>
<p>我们在看看Java中的IO分类：</p>
<ul>
<li>传统的Java BIO (blocking I/O)是Unix I/O模型中的第一种。</li>
<li>Java NIO中如果不使用select模式，而只把channel配置成nonblocking则是第二种模型。</li>
<li>Java NIO select实现的是一种多路复用I/O。底层使用epoll或者相应的poll系统调用。</li>
<li>第四种模型JDK应该是没有实现。</li>
<li>Java NIO2增加了对第五种模型的支持，也就是AIO。</li>
</ul>
<h1 id="BIO网络编程"><a href="#BIO网络编程" class="headerlink" title="BIO网络编程"></a>BIO网络编程</h1><p>传统的同步阻塞模型(BIO)开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。</p>
<p>简单的描述一下BIO的服务端通信模型：采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理没处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答通信模型。如下图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/javaCore/jpg/bio.png" alt="bio"></p>
<p>该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1:1的正比关系，Java中的线程也是比较宝贵的系统资源，线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就<strong>死掉了</strong>。</p>
<p> <strong>为了改进这种一连接一线程的模型</strong>，我们可以使用<strong>线程池</strong>来管理这些线程（需要了解更多请参考前面提供的文章），实现1个或多个线程处理N个客户端的模型（但是底层还是使用的同步阻塞I/O），通常被称为“伪异步I/O模型“。伪异步I/O模型图如下：</p>
<p> <img src="http://o6plzvjf2.bkt.clouddn.com/javaCore/png/fake_aio.png" alt="fake_aio"></p>
<p> 我们知道，如果使用CachedThreadPool线程池，其实除了能自动帮我们管理线程（复用），看起来也就像是1:1的客户端：线程数模型，而使用FixedThreadPool我们就有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N:M的伪异步I/O模型。但是，正因为限制了线程数量，如果发生大量并发请求，超过最大数量的线程就只能等待，直到线程池中的有空闲的线程可以被复用。而对Socket的输入流就行读取时，会一直阻塞。  所以在读取数据较慢时（比如数据量大、网络传输慢等），大量并发的情况下，其他接入的消息，<strong>只能一直等待</strong>，这就是最大的弊端。</p>
<p> <strong>PS：</strong> 源码都在github上。</p>
<h1 id="NIO网络编程"><a href="#NIO网络编程" class="headerlink" title="NIO网络编程"></a>NIO网络编程</h1><p>NIO(同步非阻塞IO)提供了与传统BIO模型中的Socket和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现。<strong>新增的着两种通道都支持阻塞和非阻塞两种模式</strong>。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用NIO的非阻塞模式来开发。</p>
<p>在用NIO进行开发时，我们需要先了解一下NIO的几个核心概念：</p>
<h2 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区 Buffer"></a>缓冲区 Buffer</h2><p>Buffer是一个对象，包含一些要写入或者读出的数据。在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p>
<p>缓冲区实际上是一个数组，并提供了对数据结构化访问以及维护读写位置等信息。具体的缓存区有这些：ByteBuffe、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。他们实现了相同的接口：Buffer。</p>
<h2 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道 Channel"></a>通道 Channel</h2><p>我们对数据的读取和写入要通过Channel，它就像水管一样，是一个通道。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。底层的操作系统的通道一般都是全双工的，所以全双工的Channel比流能更好的映射底层操作系统的API。</p>
<p>Channel主要分两大类：</p>
<ul>
<li>SelectableChannel：用户网络读写</li>
<li>FileChannel：用于文件操作</li>
</ul>
<p>网络编程中涉及的ServerSocketChannel和SocketChannel都是SelectableChannel的子类。</p>
<h2 id="多路复用器-Selector"><a href="#多路复用器-Selector" class="headerlink" title="多路复用器 Selector"></a>多路复用器 Selector</h2><p>Selector提供选择已经就绪的任务的能力：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。</p>
<p>一个Selector可以同时轮询多个Channel(<strong>所以是非阻塞的</strong>)，因为JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制。所以，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。</p>
<h2 id="创建NIO服务端的通信流程"><a href="#创建NIO服务端的通信流程" class="headerlink" title="创建NIO服务端的通信流程"></a>创建NIO服务端的通信流程</h2><p>我们可以看下面这种通信序列图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/javaCore/png/nioServer.png" alt="nioServer"></p>
<p><strong>PS：</strong> 源码都在github上。</p>
<h1 id="AIO网络编程"><a href="#AIO网络编程" class="headerlink" title="AIO网络编程"></a>AIO网络编程</h1><p>异步的套接字通道是真正的异步非阻塞I/O，对应于UNIX网络编程中的事件驱动I/O（AIO）。他不需要过多的Selector对注册的通道进行轮询即可实现异步读写，从而简化了NIO的编程模型。</p>
<p>AIO(异步非阻塞IO)提供了与传统BIO模型中的Socket和ServerSocket相对应的AsynchronousSocketChannel和AsynchronousServerSocketChannel两种不同的套接字通道实现。</p>
<h2 id="异步的处理"><a href="#异步的处理" class="headerlink" title="异步的处理"></a>异步的处理</h2><p>异步无非是通知系统做一件事情。然后忘掉它，自己做其他事情去了。很多时候系统做完某一件事情后需要一些后续的操作。怎么办？这时候就是告诉异步调用如何做后续处理。通常有两种方式：</p>
<ul>
<li>将来式: 当你希望主线程发起异步调用，并轮询等待结果的时候使用将来式;</li>
<li>回调式: 常说的异步回调就是它。</li>
</ul>
<p><strong>PS：</strong> AIO的代码主要基于回调式，源码都在github上。</p>
<h1 id="BIO、NIO、AIO适用场景分析"><a href="#BIO、NIO、AIO适用场景分析" class="headerlink" title="BIO、NIO、AIO适用场景分析:"></a>BIO、NIO、AIO适用场景分析:</h1><ul>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/itismelzp/article/details/50886009" target="_blank" rel="external">Java中BIO,NIO,AIO的理解</a></li>
<li><a href="https://blog.csdn.net/mcgrady_tracy/article/details/47424149" target="_blank" rel="external">Linux select和poll系统调用</a></li>
<li><a href="http://colobu.com/2014/11/13/java-aio-introduction/" target="_blank" rel="external">java aio 编程</a></li>
<li><a href="https://blog.csdn.net/anxpp/article/details/51512200" target="_blank" rel="external">Java 网络IO编程总结（BIO、NIO、AIO均含完整实例代码）</a></li>
<li><a href="https://blog.csdn.net/huangwenyi1010/article/details/75577091?ref=myread" target="_blank" rel="external">Java之IO,BIO,NIO,AIO知多少？</a></li>
<li><a href="https://blog.csdn.net/an_tao/article/details/45914841" target="_blank" rel="external">ServerSocketChannel的用法详解</a></li>
<li><a href="https://www.jianshu.com/p/c5e16460047b" target="_blank" rel="external">(001)java中的AIO</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：可能很多同学一看Java Java 网络IO，心里肯定会觉得这个有什么好讲的，不就是Socket吗，说对也对，因为他讲到了BIO(同步阻塞IO)，但是却不知还有NIO(同步非阻塞IO)，AIO(异步非阻塞IO)！
    
    </summary>
    
      <category term="Java基础" scheme="http://bestlixiang.site/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="BIO" scheme="http://bestlixiang.site/tags/BIO/"/>
    
      <category term="NIO" scheme="http://bestlixiang.site/tags/NIO/"/>
    
      <category term="AIO" scheme="http://bestlixiang.site/tags/AIO/"/>
    
  </entry>
  
</feed>
