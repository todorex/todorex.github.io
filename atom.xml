<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rex note</title>
  <subtitle>雨过，云过</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bestlixiang.site/"/>
  <updated>2018-02-08T07:26:04.000Z</updated>
  <id>http://bestlixiang.site/</id>
  
  <author>
    <name>rex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之禅——建造者模式</title>
    <link href="http://bestlixiang.site/2018/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/02/08/设计模式之禅——建造者模式/</id>
    <published>2018-02-08T07:24:43.000Z</published>
    <updated>2018-02-08T07:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：生产一个产品，它必然有很多零部件，不同的组装顺序和零部件个数可能会导致不同的产品，通过控制这些顺序与个数可以达到快速生成不同产品的目的，就可以使用<strong>建造者模式</strong>。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>建造者模式也叫做生成器模式。</p>
<p><strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。——创造类</strong></p>
<p>通用类图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/builder.png" alt="builder"></p>
<p>在建造者模式中，有如下4个角色：</p>
<ul>
<li>Product产品类：通常是<strong>实现了模板方法模式</strong>，也就是有模板方法和基本方法。这个可以看之前写的模板方法模式。</li>
<li>Builder抽象建造者：规范产品的组件，一般是由子类实现。</li>
<li>ContreteBuilder具体建造者：实现抽象类定义的所有方法，并返回一个组建好的对象。</li>
<li>Director导演类：负责安排已有模块的顺序，然后告诉Builder开始建造。</li>
</ul>
<p>我们可以看到下面的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 产品类 通常由模板方法模式实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 一个方法相当于产品的一个零件</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 独立业务处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象建造者</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="comment">// 设置产品的不同部分(包括零件种类和顺序)，以获得不同的产品</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setPart</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 建造产品</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">bulidProduct</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体建造者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;   </div><div class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 产品类内部逻辑</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">buildProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> product;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 导演类，起到封装的作用，避免高层模块深入到建造者内部的实现类。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Builder builder = <span class="keyword">new</span> ContreteBuilder();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">        builder.setPart();</div><div class="line">        <span class="keyword">return</span> builder.buildProduct();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>封装性，使用建造者模式可以使客户端不必知道产品内部组成的细节。</li>
<li>建造者独立，容易扩展。</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>相同方法，不同执行顺序，产生不同事件结果时，可以采用建造者模式。</li>
<li>多个部件或零件，都可以装配到一个对象中，但是产生不同的效能，可以使用建造者模式。</li>
<li>产品类中的调用顺序不同产生不同的效能，可以使用建造者模式。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>建造者模式关注的是零件类型和装配工艺（顺序），这是它与工厂方法模式最大不同的地方。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>在使用建造者模式的时候考虑一下模板方法模式，别孤立地思考一个模式，僵化得套用一个模式会让你受害无穷。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：生产一个产品，它必然有很多零部件，不同的组装顺序和零部件个数可能会导致不同的产品，通过控制这些顺序与个数可以达到快速生成不同产品的目的，就可以使用&lt;strong&gt;建造者模式&lt;/strong&gt;。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——模板方法模式</title>
    <link href="http://bestlixiang.site/2018/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/02/08/设计模式之禅——模板方法模式/</id>
    <published>2018-02-08T04:06:26.000Z</published>
    <updated>2018-02-08T04:09:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：少写代码，大家一定觉得很有吸引力。而且还是先确定一个框架，再写其中的部分，这么结构清晰地写代码，大家一定会觉得更有吸引力，那么我想<strong>模板方法模式</strong>可以达到你的需求。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。——行为类</strong></p>
<p>下面是他的通用类图：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/templateMethod.png" alt="templateMethod"></p>
<p>其中AbstractClass叫做抽象模板，它的方法分为两类<br>：</p>
<ul>
<li>基本方法：由子类实现的方法，并且在模板方法被调用。</li>
<li>模板方法：一般是一个具体方法，实现对基本方法的调度，完成固定的逻辑。</li>
</ul>
<p>为了防止恶意的操作，一般模板方法都加上final关键字，不允许被覆写。</p>
<p>而ConcreteClass属于具体模板，实现父类所定义的抽象方法。</p>
<p>下面再看看他的通用代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象模板类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstrctClass</span> </span>&#123;</div><div class="line">    <span class="comment">// 基本方法</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 基本方法</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doAngthing</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 模板方法</span></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 调用基本方法，完成相关逻辑</span></div><div class="line">        <span class="keyword">this</span>.doAnything();</div><div class="line">        <span class="keyword">this</span>.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体模板类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContreteClass1</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</div><div class="line">    <span class="comment">// 实现基本方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doAngthing</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContreteClass2</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</div><div class="line">    <span class="comment">// 实现基本方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doAngthing</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</div><div class="line">       AbstractClass class1 = <span class="keyword">new</span> ConcreteClass1();</div><div class="line">       AbstractClass class2 = <span class="keyword">new</span> ConcreteClass2();</div><div class="line">       <span class="comment">// 调用模板方法</span></div><div class="line">       class1.templateMethod();</div><div class="line">       class2.templateMethod();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>抽象模板中的基本方法尽量设计为protected类型，符合迪米特原则。实现类若非必要，尽量不要扩大父类中的访问权限。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>封装不变部分，扩展可变部分。</li>
<li>提取公共部分代码，便于维护。</li>
<li>行为由父类控制，子类实现。符合开闭原则。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>是优点也是缺点：子类对父类产生了影响。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>多个子类有公有的方法，并且逻辑基本相同。</li>
<li>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。</li>
<li>重构时，模板方法模式一个常用的模式，把相同的代码抽取到父类中，然后通过<strong>钩子函数</strong>约束其行为。有了钩子方法的模板方法模式才是完美的。</li>
</ol>
<p>ps：钩子方法就是子类实现的一个方法，可以利用其返回值决定公共部分的执行结果。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ol>
<li><p>父类如何调用子类的方法（极度不建议这么做）</p>
<ul>
<li>把子类传递到父类的有参构造函数中，然后调用。</li>
<li>使用反射的方式调用。</li>
<li><p>父类调用子类的静态方法。</p>
<p>但是通过模板方法模式就可以变相地实现父类调用子类的方法。</p>
</li>
</ul>
</li>
<li>在开源框架中，它提供了一个抽象类，然后开源框架写了一堆子类。如果你需要扩展，可以继承这个抽象类，然后覆写protected方法，再调用一个类似execute方法，就完成了扩展开发。相信大家一定深有感触。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：少写代码，大家一定觉得很有吸引力。而且还是先确定一个框架，再写其中的部分，这么结构清晰地写代码，大家一定会觉得更有吸引力，那么我想&lt;strong&gt;模板方法模式&lt;/strong&gt;可以达到你的需求。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——抽象工厂模式</title>
    <link href="http://bestlixiang.site/2018/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/02/07/设计模式之禅——抽象工厂模式/</id>
    <published>2018-02-07T06:26:31.000Z</published>
    <updated>2018-02-07T06:26:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在开发应用的时候为了适应不同的操作系统以及不同数据库时，我们总会显得力不从心。而抽象工厂模式为了我们提供了优秀的解决方案。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>为创建一组相关或相互依赖的对象提供一个接口，而且无须指定他们的具体类。——创造类</strong></p>
<p>它的通用类图如下：</p>
<p><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/abstractFactory.png" alt="abstractFactory"></p>
<p>为了展示通用的源代码，将原来的通用类图扩展为如下类图：<br><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/abstractFactoryDemo.png" alt="abstractFactoryDemo"></p>
<p>下面是基于类图的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象产品类 ProductA与ProductB类似;1,2代表产品等级</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span> </span>&#123;</div><div class="line">    <span class="comment">// 每个产品共有方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shareMethod</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">    <span class="comment">// 每个产品相同方法，不同实现</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 产品A1的实现类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"产品A1的实现方法"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 产品A2的实现类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"产品A2的实现方法"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象工厂类 有N个产品族，在抽象工厂类就有N个创建方法</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCreator</span> </span>&#123;</div><div class="line">    <span class="comment">// 创建A产品家族</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 创建B产品家族</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 有M个产品等级就应该有M个实现工厂类，在每个实现工厂中，实现不同产品族的生产任务</span></div><div class="line"><span class="comment">// 产品等级1的实现类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator1</span> <span class="keyword">extends</span> <span class="title">AbstractCreator</span> </span>&#123;</div><div class="line">    <span class="comment">// 只生产产品等级为1的A产品</span></div><div class="line">    <span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="function">retrurn new <span class="title">ProductA1</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 只生产产品等级为1的B产品</span></div><div class="line">    <span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="function">retrurn new <span class="title">ProductB1</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 产品等级2的实现类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator2</span> <span class="keyword">extends</span> <span class="title">AbstractCreator</span> </span>&#123;</div><div class="line">    <span class="comment">// 只生产产品等级为2的A产品</span></div><div class="line">    <span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="function">retrurn new <span class="title">ProductA2</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 只生产产品等级为2的B产品</span></div><div class="line">    <span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="function">retrurn new <span class="title">ProductB2</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 定义两个工厂</span></div><div class="line">        AbstractCreator creator1 = <span class="keyword">new</span> Creator1();</div><div class="line">        AbstractCreator creator2 = <span class="keyword">new</span> Creator2();</div><div class="line">        <span class="comment">// 产生A1对象</span></div><div class="line">        AbstractProductA a1 = creator1.createProductA();</div><div class="line">        <span class="comment">// 产生A2对象</span></div><div class="line">        AbstractProductA a2 = creator2.createProductA();</div><div class="line">        <span class="comment">// 产生B1对象</span></div><div class="line">        AbstractProductB b1 = creator1.createProductB();</div><div class="line">        <span class="comment">// 产生B2对象</span></div><div class="line">        AbstractProductB b2 = creator2.createProductB();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要是要理解产品族以及产品等级的关系。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>封装性，它只需要了解接口。</li>
<li>产品族的约束为非公开状态。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>扩展非常困难。如果要新增一个产品，需要修改AbstractCreator类以及它的实现类。这严重<strong>违反了开闭原则</strong>。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>如果一个对象族都有相同的约束，就可以使用抽象工厂模式。例如linux和windows下得编辑器和不同数据库的规范操作。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>上面的扩展困难是指产品族扩展困难，但是产品等级扩展还是容易的。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>在涉及不同操作系统，不同数据库的时候非常适合抽象工厂模式，因为它可以屏蔽掉操作系统或数据库对应用的影响。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在开发应用的时候为了适应不同的操作系统以及不同数据库时，我们总会显得力不从心。而抽象工厂模式为了我们提供了优秀的解决方案。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——工厂方法模式</title>
    <link href="http://bestlixiang.site/2018/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/02/06/设计模式之禅——工厂方法模式/</id>
    <published>2018-02-06T13:37:09.000Z</published>
    <updated>2018-02-06T13:38:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在面向对象的思维中，万物皆对象，就像有女蜗造人，我们也可以用工厂方法模式造对象。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。——创造类</strong></p>
<p>工厂方法模式的通用类图如下：<br><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/factoryMethod.png" alt="FactoryMethod"></p>
<p>下面是一个比较实用的通用源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象产品类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="comment">// 产品类的公共方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//抽象方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体产品类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContreteProduct1</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContreteProduct2</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 业务逻辑处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象工厂类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 创建一个产品对象，其输入参数类型可以自行设置</div><div class="line">     * 通常为String, Enum, Class等，当然也可以为空</div><div class="line">     */</div><div class="line"></div><div class="line">     <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; c)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体工厂类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContreteCreator</span> <span class="keyword">extends</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; c)</span> </span>&#123;</div><div class="line">        Product product = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            product = (Product) Class.forName(c.getName()).newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="comment">// 异常处理</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> （T）product;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 场景类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Creator creator = <span class="keyword">new</span> ContreteCreate();</div><div class="line">        Product product = creator.createProduct(ContreteProduct1.class);</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 继续业务处理</div><div class="line">         */</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>良好的封装性，代码结构清晰。</li>
<li>扩展性非常优秀，要增加一个新的产品，只要实现Product接口。</li>
<li>屏闭产品类。只要关心产品的接口即可，例如换数据库只要换驱动即可。</li>
<li>符合迪米特法则（只要知道产品的接口即可）；符合依赖倒置原则（值依赖产品的抽象类即可）；符合里氏替换原则（使用产品子类可以替换产品父类）。</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>只要使用new的地方都可以使用工厂方法模式，但是要考虑代码的复杂度。</li>
<li>需要灵活的，可扩展的框架时（有多个产品可选且可以随时增加时），可以考虑工厂方法模式。</li>
<li>工厂方法模式可以用在异构项目中。</li>
<li>可以使用在测试驱动开发的框架下。</li>
</ol>
<h1 id="工厂方法模式的扩展"><a href="#工厂方法模式的扩展" class="headerlink" title="工厂方法模式的扩展"></a>工厂方法模式的扩展</h1><ol>
<li><p>缩小为简单工厂模式</p>
<p> 实质是去掉了创造者接口，使具体创造者直接依赖产品接口。缺点是扩展比较困难，不符合开闭原则。</p>
</li>
<li><p>升级为多个工厂类</p>
<p> 实质是为了结构清晰，我们为每个产品定义一个创造者，然后由调用者自己去选择与那个工厂方法关联。</p>
</li>
<li><p>替代单例模式</p>
<p> 代码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Class c1 = Class.forName(Singleton.class.getName());</div><div class="line">        <span class="comment">// 获得无参构造</span></div><div class="line">        Constructor constructor = c1.getDeclaredConstructor();</div><div class="line">        <span class="comment">//设置无参构造是可访问的</span></div><div class="line">        constructor.setAccessible(<span class="keyword">true</span>);</div><div class="line">        <span class="comment">// 产生一个实例对象</span></div><div class="line">        singleton = (Singleton) constructor.newInstance();</div><div class="line"></div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> singleton;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>延迟初始化</p>
<p> 所谓延迟初始化即一个对象被消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被使用。其实质，是利用一个Map保存创造过的对象，如果在Map容器已经有的对象，则直接取出返回；如果没有，则根据需要的类型产生一个对象并放入到Map容器中，以方便下次调用。</p>
</li>
</ol>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>孰能生巧，熟练掌握该设计模式，多思考工厂方法如和应用，而且工厂方法模式可以与其他模式混合使用，变化出无穷的优秀设计。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在面向对象的思维中，万物皆对象，就像有女蜗造人，我们也可以用工厂方法模式造对象。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅——单例模式</title>
    <link href="http://bestlixiang.site/2018/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2018/02/06/设计模式之禅——单例模式/</id>
    <published>2018-02-06T13:36:57.000Z</published>
    <updated>2018-02-06T13:37:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：如果每个人可以走的路只有一条，如果每个人想要的东西都是一个(单例模式)，那么人应该都不会迷茫了吧。虽然解决了迷茫，但是也抹杀了多样性，有好有坏，各有所见。<a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。——创造类</strong></p>
<p>下面是它的通用类图：<br><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/singleton.png" alt="singleton"></p>
<p>代码实现有两种，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 饿汉式单例 线程安全</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton = <span class="keyword">new</span> Singleton();</div><div class="line">    <span class="comment">// 限制产生多个对象</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">    <span class="comment">// 通过该方法获得实例对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 类中其他方法尽量是static</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> doSomething &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 懒汉式单例 线程不安全</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 限制产生多个对象</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">    <span class="comment">// 通过该方法获得实例对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (singleton = <span class="keyword">null</span>) &#123;</div><div class="line">            singleton = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 类中其他方法尽量是static</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> doSomething &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>减少内存开支</li>
<li>减少系统的性能开销</li>
<li>避免对资源的多重占用</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>扩展困难，由于它需要自行实例化</li>
<li>不利于测试，由于单例没完成，不能测试</li>
<li>与<strong>单一职责</strong>有冲突</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>要求生成唯一序列号的环境</li>
<li>在整个项目中需要一个共享访问带你或共享数据</li>
<li>创建一个对象需要消耗的资源过多，如访问IO和数据库</li>
<li>需要定义大量的静态常量和静态方法（如工具类）的环境</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>在高并发的情况下，请注意单例模式的线程同步问题，选择合适的实现模式。</li>
<li>不可以复制，即不实现Cloneable接口。</li>
</ol>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>在Spring中，每个Bean默认就是单例的，这样的优点是Spring容器可以管理这些Bean的生命周期，决定什么时候销魂，销毁的时候要如何处理，等等。如果采用非单例模式，则Bean初始化后的管理交由J2EE容器，Spring容器不在跟踪管理Bean的生命周期。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：如果每个人可以走的路只有一条，如果每个人想要的东西都是一个(单例模式)，那么人应该都不会迷茫了吧。虽然解决了迷茫，但是也抹杀了多样性，有好有坏，各有所见。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>先吹响口号_6大设计原则</title>
    <link href="http://bestlixiang.site/2018/02/01/%E5%85%88%E5%90%B9%E5%93%8D%E5%8F%A3%E5%8F%B7-6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://bestlixiang.site/2018/02/01/先吹响口号-6大设计原则/</id>
    <published>2018-02-01T04:01:04.000Z</published>
    <updated>2018-02-01T04:06:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：先有6大设计原则，后有23种设计模式。让我们先吹响这先行的口号。<a id="more"></a></p>
<h1 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则 SRP"></a>单一职责原则 SRP</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>就一个类或接口而言，应该有且只有一个原因引起类的变更。</strong></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>关于电话通话的接口，有三个过程：拨号、通话、挂机。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPhone</span> </span>&#123;</div><div class="line">    <span class="comment">//拨通电话</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dial</span><span class="params">(String phoneNumber)</span></span>;</div><div class="line">    <span class="comment">//通话</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chat</span><span class="params">(Onbject o)</span></span>;</div><div class="line">    <span class="comment">//挂机</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangup</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是IPhone这个接口不是只有一个职责，它包含了两个职责：一个是协议管理，一个是数据传送。所以我们改为下面设计的类图：<br><img src="http://o6plzvjf2.bkt.clouddn.com/designPattern/png/srp.png" alt="srp"></p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义</li>
<li>可读性提高，复杂度降低，那当然可读性提高了</li>
<li>可维护性提高，可读性提高了，那当然更容易维护了</li>
<li>变更引起的风险降低</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。</p>
<h1 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则 LSP"></a>里氏替换原则 LSP</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ol>
<li>正宗定义：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o2都代换成o1时，程序P的行为没有发生变化，那么类型S是类型T的子类型。（感觉《Java设计模式之禅》的翻译错误）</li>
<li>通俗定义：所有引用基类的地方必须能透明地使用其子类的对象（<strong>只要父类能出现得地方子类就可以出现</strong>；有子类出现的地方，父类未必能适应）。</li>
</ol>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ol>
<li>子类必须完全实现父类的方法。（如果子类不能完整地实现子类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚合、组合灯关系来代替继承。）</li>
<li>子类可以有自己的个性。</li>
<li>覆盖或实现父类的方法时输入参数可以被放大。（子类中方法的前置条件（方法中输入参数）必须与超类中被覆写的方法的前置条件相同或者更宽松。）</li>
<li>覆写或实现父类的方法时输出结果可以被缩小。</li>
</ol>
<h2 id="疑问（多态是否违背LSP？）"><a href="#疑问（多态是否违背LSP？）" class="headerlink" title="疑问（多态是否违背LSP？）"></a>疑问（多态是否违背LSP？）</h2><p>如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例时逻辑不一致的可能。</p>
<h2 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有了“个性”，这个子类和父类之间的关系就难调和，把子类当做父类使用，子类的“个性”被抺杀了，把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离–缺乏类替换的标准。</p>
<h1 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则 DIP"></a>依赖倒置原则 DIP</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节。细节应该依赖抽象。（不可以分割的原子逻辑就是底层模块，原子逻辑的再组装就是高层模块。抽象就是指接口或抽象类。细节就是实现类。）</p>
<p>Java语言表现：模块间的依赖通过抽象产生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。接口或抽象类不依赖实现类。实现类依赖接口或抽象类。——<strong>面向接口编程(OOD)</strong>。</p>
<h2 id="依赖的三种写法"><a href="#依赖的三种写法" class="headerlink" title="依赖的三种写法"></a>依赖的三种写法</h2><ol>
<li><p>构造函数传递依赖对象(构造函数注入)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDriver</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">implements</span> <span class="title">IDriver</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ICar car;</div><div class="line">    <span class="comment">//构造函数注入</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Drive</span><span class="params">(ICar _car)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.car = _car;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.car.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Setter方法传递依赖对象（Setter依赖注入）</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDriver</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(ICar car)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">implements</span> <span class="title">IDriver</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ICar car;</div><div class="line">    <span class="comment">//setter注入</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(ICar car)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.car = car;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.car.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>接口声明依赖对象(接口注入)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDriver</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(ICar car)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">implements</span> <span class="title">IDriver</span> </span>&#123;</div><div class="line">    <span class="comment">//接口注入</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(ICar car)</span> </span>&#123;</div><div class="line">        car.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="最佳实践-2"><a href="#最佳实践-2" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol>
<li>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备。</li>
<li>变量的表面类型（定义的类型）尽量是接口或者是抽象类。</li>
<li>任何类都不应该从具体类派生。</li>
<li>尽量不要覆写基类的方法。</li>
<li>结合里氏替换原则使用（多态）</li>
</ol>
<p>我们在实际的项目中使用依赖倒置原则需要审时度势，不哟啊抓住一个原则不放，每一个原则的优点都是有限度的，并不是放之四海而皆准的真理，所以别为了遵循一个原则而放弃了一个项目的终极目标：投产上线和盈利。</p>
<h1 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则 ISP"></a>接口隔离原则 ISP</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>客户端不应该依赖他不需要的接口。类间的依赖关系应该建立在最小的接口上。<br>（实例接口：class；类接口：interface）</p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ol>
<li>接口要尽量小。（根据接口隔离原则拆分接口时，首先必须要满足单一职责原则。）</li>
<li>接口要高内聚。（在接口中尽量少公布public方法。）</li>
<li>定制服务。（设计时需要为各个访问者定制服务（接口）。）</li>
<li>接口设计时有限度的。（接口的设计粒度要协调开发难度和可维护性。）</li>
</ol>
<h2 id="最佳实践-3"><a href="#最佳实践-3" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol>
<li>一个接口只服务于一个子模块或业务逻辑。</li>
<li>通过业务逻辑压缩接口中的public方法，经常回顾接口。</li>
<li>已经被污染的接口，尽量去修改，如果变更风险较大，则采用<strong>适配器模式</strong>进行转化处理。</li>
<li>了解环境，拒绝盲从。</li>
</ol>
<h1 id="迪米特法则-LoD-LKP"><a href="#迪米特法则-LoD-LKP" class="headerlink" title="迪米特法则 LoD LKP"></a>迪米特法则 LoD LKP</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>一个对象应该对其他对象有最少的了解。（类解耦）</p>
<h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><ol>
<li><p>只与朋友交流</p>
<p> 朋友类的定义：出现在成员变量、方法的输入输出参数的类称为成员朋友类。</p>
<p> 所以在原类的方法中不能出现非朋友的类，JDK API提供的类除外。</p>
</li>
<li><p>朋友间也是有距离的</p>
<p> 尽量不要对外公布太多的public方法和非静态的public变量。</p>
</li>
<li><p>是自己的就是自己的</p>
<p> 如果过一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。</p>
</li>
<li><p>谨慎使用Serializable</p>
<p> 防止客户端和服务器端类不同步。</p>
</li>
</ol>
<h2 id="最佳实践-4"><a href="#最佳实践-4" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>迪米特法则的核心是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。其要求的结果就是产生大量的中转或跳转类，导致系统的复杂性提高，同时也为维护带来了难度，在采用迪米特法则时需要反复权衡，既做到让结构清晰，又要做到高内聚低耦合。当一个类跳转两次以上才能访问到另一个类，就需要重构了。</p>
<h1 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则 OCP"></a>开闭原则 OCP</h1><h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>
<p>PS: 3W原则（what：是什么；why：为什么；How：怎么做）</p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>开闭原则告诉我们应该尽量通过<strong>扩展软件实体</strong>来实现变化，而不是通过修改已有的代码来完成变化，它是为软件实体的未来事件而制定的对现行开发设计进行的约束规则。</p>
<p>开闭原则对扩展开放，对修改关闭，并不以为着不做任何修改，低层模块的变更，必然要有高层模块的进行耦合，否则就是一个孤立无意义的代码片段。</p>
<p>一个项目的基本路径：项目开发、重构、测试、投产、运维，其中的重构可以对原有的设计和代码进行修改，<strong>运维尽量减少对原有代码的修改，保持历史代码的纯洁性</strong>，提高系统的稳定性。</p>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><ol>
<li>简化测试：如果改变软件内容, 需要将所有的测试流程都执行一遍, 如 单元测试, 功能测试, 集成测试等, 如果只是扩展, 只单独测试扩展部分即可。</li>
<li>提高复用性：所有逻辑都从原子逻辑组合, 原子逻辑粒度越小, 复用性越大; 这样避免相同逻辑存在, 修改时需要修改多个此相同逻辑。</li>
<li>提高可维护性：维护一个类最好的方式是扩展一个类, 而不是修改一个类, 如果需要修改需要读懂源码才能修改, 扩展的话只需要了解即可, 直接继承扩展。</li>
</ol>
<h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><ol>
<li><p>抽象约束</p>
<p> 通过接口或抽象类可以约束一组可能变化的行为，并且实现对扩展开放。其中包括三层含义：第一，通过接口或抽象类约束扩展，对扩展进行边界设定，不允许出现在接口或抽象类不存在的public方法；第二，参数类型，引用对象尽量使用接口或者抽象类，而不是实现类；第三，抽象层尽量保持稳定。</p>
</li>
<li><p>元数据控制模块行为</p>
<p> 通过配置参数（从文件或者数据库中来）来控制行为，例如spring配置文件的构造函数注入配置。</p>
</li>
<li><p>制定项目章程</p>
<p> 约定优于配置。</p>
</li>
<li><p>封装变化</p>
<p> 对变化的封装包含两层含义：第一，将相同的变化封装到一个接口或抽象类中；第二，将不同的变化封装到不同的接口或抽象类中。23个设计模式都是从各个不同的角度对变化进行封装的。</p>
</li>
</ol>
<h2 id="最佳实践-5"><a href="#最佳实践-5" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol>
<li>开闭原则只是一个原则，适当时候也可以进行补充。</li>
<li>项目规章非常重要。</li>
<li>预知变化，项目需要具有可扩展性。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>把上面6大原则的首字母（里氏替换原则和迪米特法则的首字母重复，只取一个）联合起来就是SOLID（稳定的），其代码的含义就是把这6个原则结合使用的好处：建立稳定灵活，健壮的设计，而开闭原则又是重中之中，是最基础的原则，是其他5大原则的精神领袖。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《设计模式之禅》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：先有6大设计原则，后有23种设计模式。让我们先吹响这先行的口号。
    
    </summary>
    
      <category term="设计模式" scheme="http://bestlixiang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://bestlixiang.site/tags/java/"/>
    
      <category term="设计模式" scheme="http://bestlixiang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>UML_Java类图</title>
    <link href="http://bestlixiang.site/2018/01/27/UML-Java%E7%B1%BB%E5%9B%BE/"/>
    <id>http://bestlixiang.site/2018/01/27/UML-Java类图/</id>
    <published>2018-01-27T13:38:28.000Z</published>
    <updated>2018-01-27T13:40:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在看源码或者很多技术书籍的时候都避免不了看到类图，时间长了总会忘了含义，在这里就总结一下，方便以后回顾。这里使用的工具是startUML。<a id="more"></a></p>
<h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><p><strong>UML：</strong> 统一建模语言（Unified Modeling Language）。在 UML 系统开发中有三个主要的模型：</p>
<ul>
<li>功能模型：从用户的角度展示系统的功能，包括用例图。</li>
<li>对象模型：采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类图、对象图、包图。</li>
<li>动态模型：展现系统的内部行为。包括时序图，活动图，状态图。</li>
</ul>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p>类图使用类来描述系统的静态结构，类图包含类和它们之间的关系，它描述系统内所声明的类，但它没有描述系统运行时类的行为。</p>
<p>在UML类图中，类一般由三部分组成：类名、属性以及操作。</p>
<h2 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h2><p>每个类都必须有一个名字，类名是一个字符串。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性是指类的性质，即类的成员变量。类可以有任意多个属性，也可以没有属性。</p>
<p>格式为： 【可见性】 属性名 【：类型】 【=初始值】 【{属性字符串}】</p>
<p>可见性：在UML中public类型用符号“+”表示，private类型用“-”表示，protected类型用“#”表示。</p>
<p>属性字符串：用来指定关于属性的其他信息，任何希望添加属性定义字符串但又没有合适地方可以加入的规则都可以放在属性字符串里，例如类变量。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>操作是类的任意一个实例对象都可以使用的行为，操作是类的成员方法。</p>
<p>格式为：【可见性】 操作名 【{参数列表}】 【：返回类型】 【{属性字符串}】</p>
<h1 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h1><h2 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h2><p>关联关系(Association)是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一个类与另一个类之间有联系。</p>
<p>在 UML 类图中，用实线连接有关联的的类。在实现关联关系时，通常将一个类的对象作为另一个类的属性。</p>
<h3 id="单向关联"><a href="#单向关联" class="headerlink" title="单向关联"></a>单向关联</h3><p>类的关联关系可以是单向的，单向关联用带箭头的实线表示。如下图：<br><img src="http://o6plzvjf2.bkt.clouddn.com/tool/png/derectAssociation.png" alt="derectAssociation"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Address address;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="双向关联"><a href="#双向关联" class="headerlink" title="双向关联"></a>双向关联</h3><p>默认情况下，关联是双向的。如下图：<br><img src="http://o6plzvjf2.bkt.clouddn.com/tool/png/association.png" alt="association"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Product product;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Order order;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h3><p>在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。如下图：<br><img src="http://o6plzvjf2.bkt.clouddn.com/tool/png/1slfeAssociation.png" alt="slfeAssociation"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Node node;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="重数性关联"><a href="#重数性关联" class="headerlink" title="重数性关联"></a>重数性关联</h3><p>重数性关联关系又称为多重性关联关系，表示一个类的对象与另一个类的对象连接的个数。在 UML 中多重性关系可以直接在关联直线上增加一个数字表示与之对应的另一个类的对象的个数。<br>如下图：<br><img src="http://o6plzvjf2.bkt.clouddn.com/tool/png/multiplicityAssociation.png" alt="multiplicityAssociation"></p>
<p>其中数字的种类及含义如下表：</p>
<table>
<thead>
<tr>
<th>表示方式</th>
<th>表示含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1..1</td>
<td>表示另一个类的一个对象只与一个该类对象有关系</td>
</tr>
<tr>
<td>0..*</td>
<td>表示另一个类的一个对象与零个或多个该类对象有关系</td>
</tr>
<tr>
<td>1..*</td>
<td>表示另一个类的一个对象与一个或多个该类对象有关系</td>
</tr>
<tr>
<td>0..1</td>
<td>表示另一个类的一个对象没有或只与一个该类对象有关系</td>
</tr>
<tr>
<td>m..n</td>
<td>表示另一个类的一个对象与最少m、最多n个该类对象有关系 (m&lt;=n)</td>
</tr>
</tbody>
</table>
<h2 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h2><p>聚合关系表示一个整体与部分的关系。通常在定义一个整体类后，再去找出这个整体类的一些成员类，该整体类和成员类之间就形成了聚合关系。</p>
<p>在聚合关系中，成员类是整体类的一部分，即成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。如下图：<br><img src="http://o6plzvjf2.bkt.clouddn.com/tool/png/aggregation.png" alt="aggregation"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Engine engine;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Engine engine)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.engine = engine;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">setEngine</span><span class="params">(Engine engine)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.engine = engine;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h2><p>组合关系也表示类之间整体和部分的关系，但是<strong>组合关系中部分和整体具有统一的生存期</strong>。一旦整体对象不存在，部分对象也将不存在，部分对象与整体对象之间具有同生共死的关系。</p>
<p>在组合关系中，成员类是整体类的一部分，而且整体类可以控制成员类的生命周期，即成员类的存在依赖于整体类。在UML中，组合关系用带实心菱形的直线表示。如下图：<br><img src="http://o6plzvjf2.bkt.clouddn.com/tool/png/composition.png" alt="composition"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Eye eye;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Head</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.eye = <span class="keyword">new</span> Eye();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eye</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>依赖关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。如下图：<br><img src="http://o6plzvjf2.bkt.clouddn.com/tool/png/dependency.png" alt="dependency"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">drive</span><span class="params">(Car car)</span> </span>&#123;</div><div class="line">        car.move();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h2><p>泛化关系也就是继承关系，也称为“is-a-kind-of”关系，泛化关系用于描述父类与子类之间的关系。在UML中，泛化关系用带空心三角形的直线来表示。如下图：<br><img src="http://o6plzvjf2.bkt.clouddn.com/tool/png/generalization.png" alt="generalization"></p>
<h2 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h2><p>实现关系是类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用<strong>带空心三角形的虚线</strong>(mac中的startUML画不出来，大家将就着看)来表示。如下图：<br><img src="http://o6plzvjf2.bkt.clouddn.com/tool/png/realization.png" alt="realization"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>理解类图有助于我们更好的去看技术书籍，以及源码，这是必备技能，get it！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://segmentfault.com/a/1190000011556007" target="_blank" rel="external">UML 及 StarUml</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在看源码或者很多技术书籍的时候都避免不了看到类图，时间长了总会忘了含义，在这里就总结一下，方便以后回顾。这里使用的工具是startUML。
    
    </summary>
    
      <category term="工具" scheme="http://bestlixiang.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="UML" scheme="http://bestlixiang.site/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>Java并发_12_原子变量与非阻塞同步机制</title>
    <link href="http://bestlixiang.site/2018/01/25/Java%E5%B9%B6%E5%8F%91-12-%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    <id>http://bestlixiang.site/2018/01/25/Java并发-12-原子变量与非阻塞同步机制/</id>
    <published>2018-01-25T03:14:44.000Z</published>
    <updated>2018-01-25T03:15:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：原子变量与非阻塞同步机制相比于基于锁的方案可以拥有更高的性能和可伸缩性。<a id="more"></a></p>
<h1 id="锁的劣势"><a href="#锁的劣势" class="headerlink" title="锁的劣势"></a>锁的劣势</h1><ul>
<li>通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有守护变量的锁，都能采用独占方式来访问这些变量，并且对变量的任何修改对随后获得这个锁的其他线程都是可见的。但是当在锁上存在激烈的竞争时，调度开销与工作开销的比值会非常高。</li>
<li>volatile变量是一种更轻量级的同步机制，但是虽然他们提供了相似的可见性保证，但不能用于构建原子的复合操作。因此，当一个变量依赖其他的变量时，或者当变量的新值依赖旧值时，就不能使用volatile。</li>
</ul>
<h1 id="硬件对并发的支持"><a href="#硬件对并发的支持" class="headerlink" title="硬件对并发的支持"></a>硬件对并发的支持</h1><ul>
<li>独占锁是一种悲观技术——它假设最坏的情况，并且只有在确保其他线程不会找出干扰的情况下才能执行下去。</li>
<li>比较并交换（CAS，硬件指令）是一种乐观的技术——通过这种方法可以在不发生干扰的情况下完成更新操作，不过这种方法需要借助检查机制来判断在更新过程中是否存在其他线程的干扰，如果存在，这个操作将失败，并且可以重试（也可以不重试）。</li>
</ul>
<p>下面是模拟CAS操作代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CAS含义：我认为V的值应该是A，如果是，那么把值更新为B，否则不修改并告诉V的值实际是多少</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimulatedCAS</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> oldValue = value;</div><div class="line">        <span class="keyword">if</span> (oldValue == expectedValue) &#123;</div><div class="line">            value = <span class="keyword">new</span> Value;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (expectedValue == compareAndSwap(expectedValue, newValue));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CAS的优点：当竞争程序不高时，性能远远高于基于锁的方案。</p>
<p>CAS的缺点：它将使调用者处理竞争问题（通过重试、回退、放弃），而在锁中能自动处理竞争问题（线程在获得锁之前将一直阻塞）。</p>
<h1 id="原子变量类"><a href="#原子变量类" class="headerlink" title="原子变量类"></a>原子变量类</h1><p>原子变量类在发生竞争的情况下能提供更高的可伸缩性，因为它直接利用了硬件对并发的支持（比较并交换指令）。</p>
<p>共有12个原子变量类：可分为四组：标量类、更新器类、数组类以及复合变量类。最常用的原子变量类就是标量类：AtomicInteger、AtomicLong、AtomicBoolean以及AtomicReference。</p>
<p><strong>原子变量与锁适用的不同并发场景：</strong></p>
<ul>
<li>在中低程序的竞争、锁占用时间不长的情况下，原子变量能提供更高的可伸缩性。</li>
<li>而在高强度的竞争下，锁能够更有效的地避免竞争。</li>
</ul>
<h1 id="非阻塞算法"><a href="#非阻塞算法" class="headerlink" title="非阻塞算法"></a>非阻塞算法</h1><p><strong>无阻塞算法：</strong> 如果在某种算法中，一个线程的失败或者挂起不会导致其他线程也失败或挂起，那么这种算法就被称为无阻塞算法。</p>
<p><strong>无锁算法：</strong> 如果在算法的每个步骤中都存在某个线程能够执行下去，那么这种算法被称为无锁算法。</p>
<p>如果在算法中仅将CAS用于协调线程之间的操作，并且能正确地实现，那么它既是无阻塞算法，又是无锁算法。</p>
<p>利用CAS并发指令可以实现非阻塞的同步容器，例如实现非阻塞的栈、非阻塞的链表以及原子的域更新器等。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>非阻塞算法通过底层的并发原语（例如比较并交换）来维持线程的安全性。这些底层的原语通过原子变量类向外公开，从而为整数和对象引用提供原子的更新操作。</li>
<li>在JVM从一个版本升级到下一个版本的过程中，并发性能主要提升都来自于对非阻塞算法的使用。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：原子变量与非阻塞同步机制相比于基于锁的方案可以拥有更高的性能和可伸缩性。
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发_11_构建自定义同步工具</title>
    <link href="http://bestlixiang.site/2018/01/24/Java%E5%B9%B6%E5%8F%91-11-%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/"/>
    <id>http://bestlixiang.site/2018/01/24/Java并发-11-构建自定义同步工具/</id>
    <published>2018-01-24T09:27:52.000Z</published>
    <updated>2018-01-24T09:28:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：创建状态依赖的类的最简单的方法通常是在类库中现有状态依赖类的基础上进行构造。但如果类库没有提供你需要的功能，我们还可以使用Java语言和类库提供的底层机制来构造自己的同步机制，包括内置的条件队列、显式的Condition对象以及AbstractQueuedSynchronizer框架。<a id="more"></a></p>
<h1 id="状态依赖性管理"><a href="#状态依赖性管理" class="headerlink" title="状态依赖性管理"></a>状态依赖性管理</h1><p>程序在做某一个操作之前，需要依赖另一个操作的完成或者状态的就绪，这样的一种关系就叫做“状态依赖”。</p>
<p>状态依赖的实现类,例如FutureTask、Semaphore和BlockingQueue等。在这些类的一些操作中有着基于状态的前提条件，例如，不能从一个空队列删除元素，或者获取一个尚未结束的任务的计算结果，在这些操作可以执行之前，必须等待队列进入“非空”状态，或者任务进入“已完成”状态。</p>
<p>依赖状态的操作可以一直阻塞直到可以继续执行，这比使他们先失败再实现起来要更为方便且更不容易出错。而内置的条件队列就可以是线程一直阻塞，直到对象进入某个线程可以继续执行的状态，并且当被阻塞的线程可以执行时再唤醒他们。</p>
<h1 id="使用条件队列"><a href="#使用条件队列" class="headerlink" title="使用条件队列"></a>使用条件队列</h1><p>条件队列：它使得一组线程（称之为等待线程集合）能够通过某种方式来等待特定的条件变为真。传统的队列是一个个数据，而与之不同的是，条件队列中的元素是一个个正在等待相关条件的线程。</p>
<ul>
<li>Object中的wait、notify和notifyAll方法构成了内部条件队列的API。</li>
<li>对象的内置锁与内部条件是相互关联的，要调用对象X中的条件队列的任何一个方法，必须持有对象X上的锁。</li>
<li>Object.wait会自动释放锁，并请求操作系统挂起当前线程，从而使其它线程能够获得这个锁并修改对象的状态。当被挂起的线路醒来时，它将在返回之前重新获取锁。（需要重新竞争，并没有优先获取权）</li>
</ul>
<p>使用条件队列构造有界缓存示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//未加任何约束的缓冲队列</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V[] buf;<span class="comment">//缓存</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;<span class="comment">//队尾</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;<span class="comment">//队首</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;<span class="comment">//元素个数</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BaseBoundedBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.buf = (V[]) <span class="keyword">new</span> Object[capacity];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(V v)</span> </span>&#123;<span class="comment">//入队</span></div><div class="line">        buf[tail] = v;<span class="comment">//在队尾添加</span></div><div class="line">        <span class="keyword">if</span> (++tail == buf.length)<span class="comment">//如果满了，从头开始</span></div><div class="line">            tail = <span class="number">0</span>;</div><div class="line">        ++count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> V <span class="title">doTake</span><span class="params">()</span> </span>&#123;<span class="comment">//出队</span></div><div class="line">        V v = buf[head];<span class="comment">//从队首取出</span></div><div class="line">        buf[head] = <span class="keyword">null</span>;<span class="comment">//GC</span></div><div class="line">        <span class="keyword">if</span> (++head == buf.length)<span class="comment">//如果到尾了，则从头开始</span></div><div class="line">            head = <span class="number">0</span>;</div><div class="line">        --count;</div><div class="line">        <span class="keyword">return</span> v;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;<span class="comment">//队列是否满</span></div><div class="line">        <span class="keyword">return</span> count == buf.length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;<span class="comment">//队列是否空</span></div><div class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@ThreadSafe</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 条件谓词：not-full(!isFull())</span></div><div class="line">    <span class="comment">// 条件谓词：not-empty(!isEmpty())</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123; <span class="keyword">super</span>(size); &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 阻塞并直到: not-full</span></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">while</span> (isFull())<span class="comment">//如果满，则等待</span></div><div class="line">            wait();</div><div class="line">        doPut(v);</div><div class="line">        notifyAll();<span class="comment">//并在放入后马上通知其他线程</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 阻塞并直到: not-empty</span></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span>  V <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">while</span> (isEmpty())<span class="comment">//如果为空，则等待</span></div><div class="line">            wait();</div><div class="line">        V v = doTake();</div><div class="line">        notifyAll();</div><div class="line">        <span class="keyword">return</span> v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="条件谓词"><a href="#条件谓词" class="headerlink" title="条件谓词"></a>条件谓词</h2><p><strong>条件谓词</strong>是使某个操作成为状态依赖操作的前提条件。在有界缓存中，只有当缓存不为空时，take方法才能执行，否则必须等待。对take方法来说，它的条件谓词就是“缓存不为空”，take方法在执行之前必须首先测试该条件谓词。</p>
<p><strong>条件等待存在的三元关系：</strong> 包括加锁、wait方法和一个条件谓词。在条件谓词中包含多个包含多个状态变量，而状态变量由一个锁来保护，因此在测试条件谓词之前必须先持有这个锁，锁对象与条件队列对象（即调用wait和notify等方法所在的对象）必须是同一个对象。</p>
<p><strong>每一次wait调用都会隐式地与特定的条件谓词关联起来。当调用某个特定条件谓词的wait时，调用者必须已经持有与条件队列相关的锁，并且这个锁必须保护着构成条件谓词的状态变量。</strong></p>
<h2 id="过早唤醒"><a href="#过早唤醒" class="headerlink" title="过早唤醒"></a>过早唤醒</h2><p>wait方法的返回并不一定意味着线程正在等待的条件谓词已经变真了，因为也许是因为与同一条件队列相关的另一个条件谓词变成了真。</p>
<p>当使用条件等待时要满足的条件（Object.wait或Condition.wait）</p>
<ul>
<li>通常都有一个条件谓词——包括一些对象状态的测试，线程在执行前必须首先通过这些测试。</li>
<li>在调用wait之前测试条件谓词，并且从wait中返回时再次进行测试。</li>
<li>在一个循环中调用wait。</li>
<li>确保使用与条件队列相关的锁来保护构成条件谓词的各个状态变量。</li>
<li>当调用wait/notify/notifyAll等方法时，一定要持有与条件队列相关的锁。</li>
<li>在检查条件谓词之后以及开始执行相应的操作之前，不要释放锁。</li>
</ul>
<h2 id="丢失的信号"><a href="#丢失的信号" class="headerlink" title="丢失的信号"></a>丢失的信号</h2><p><strong>丢失的信号：</strong> notify或者notifyAll操作发生在wait之前，就会造成通知信号的丢失，最终wait永远都得不到恢复或者不得不等待下一次重新通知而延迟了恢复时间。</p>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p><strong>每当在等待一个条件时，一定要确保在条件谓词变为真时通过某种方式发出通知</strong></p>
<p>发出通知的线程应该尽快地释放锁，从而确保正在等待的线程尽可能快地解除阻塞。如果这些等待中线程此时不能重新获得锁，那么无法从wait返回。</p>
<p>只有同时满足以下两个条件时，才能用单一的notify而不是notifyAll：</p>
<ul>
<li>所有等待线程的类型都相同。只有一个条件谓词与条件队列相关，并且每个线程在wait返回后将执行相同的操作。</li>
<li>单进单出。在条件变量上的每次通知，最多只能唤醒一个线程来执行。</li>
</ul>
<h1 id="显式的Condition对象"><a href="#显式的Condition对象" class="headerlink" title="显式的Condition对象"></a>显式的Condition对象</h1><p>内置条件队列的局限性：每个内置锁都只能有一个相关联的条件队列，因而在像BoundBuffer这种类中，多个线程可能在同一个条件队列上等待不同的条件谓词，并且在最常见的加锁模式下公开条件队列对象。</p>
<p>显示条件队列的优势：可以编写一个带有多个条件谓词的并发对象，或者获得除了条件队列可见性之外的更多控制权，这是一种灵活的选择；对于每个Lock，可以有任意数量的Condition对象。Condition对象继承了相关的Lock对象的公平性，对于公平的锁，线程会依照FIFO顺序从Condition await中释放。</p>
<p><strong>特别注意：Condition对象中，三个与条件队列相关的API是：await,signal,signalAll。</strong></p>
<p>下面是使用显示的Condition对象实现的有界缓存:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionBoundedBuffer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull    = lock.newCondition();<span class="comment">//条件：count &lt; items.length</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty  = lock.newCondition();<span class="comment">//条件：count &gt; 0</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T[] items = (T[]) <span class="keyword">new</span> Object[<span class="number">100</span>];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail, head, count;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (count == items.length)</div><div class="line">                notFull.await();<span class="comment">//等到条件count &lt; items.length满足</span></div><div class="line">            items[tail] = x;</div><div class="line">            <span class="keyword">if</span> (++tail == items.length)</div><div class="line">                tail = <span class="number">0</span>;</div><div class="line">            ++count;</div><div class="line">            notEmpty.signal();<span class="comment">//通知读取等待线程</span></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</div><div class="line">                notEmpty.await();<span class="comment">//等到条件count &gt; 0满足</span></div><div class="line">            T x = items[head];</div><div class="line">            items[head] = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (++head == items.length)</div><div class="line">                head = <span class="number">0</span>;</div><div class="line">            --count;</div><div class="line">            notFull.signal();<span class="comment">//通知写入等待线程</span></div><div class="line">            <span class="keyword">return</span> x;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h1><p>AbstractQueuedSynchronizer是一个用于构建锁和同步器的框架，许多同步器都可以通过AQS很容易并且高效地构造出来。例如：ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock、SynchronousQueue和FutureTask。</p>
<p>下面是AQS中获取操作和释放操作的标准形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span> (当前状态不允许获取操作)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (需要阻塞获取请求)</div><div class="line">        &#123;</div><div class="line">            如果当前线程不在队列中，则将其插入队列</div><div class="line">            阻塞当前线程</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            返回失败</div><div class="line">    &#125;</div><div class="line">    可能更新同步器的状态</div><div class="line">    如果线程位于队列中，则将其移出队列</div><div class="line">    返回成功</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    更新同步器的状态</div><div class="line">    <span class="keyword">if</span> (新的状态允许某个被阻塞的线程获取成功)</div><div class="line">        解除队列中一个或多个线程的阻塞状态</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要实现一个依赖状态的类——如果没有满足依赖状态的前提条件，那么这个类的方法必须阻塞，那么最好的方式是基于现有类库来构建，例如Semaphore.BlockingQueue或CountDownLatch。然而，有时候现有的类库不能提供足够的功能，在这种情况下，可以使用内置的条件队列、显式的Condition对象或者AbstractQueuedSynchronizer来构建自己的同步器。内置条件队列与内置锁是紧密绑定在一起的，这是因为管理状态依赖性的机制必须与确保状态一致性的机制关联起来。同样，显式的Condition与显式地Lock也是紧密地绑定在一起的，并且与内置条件队列相比，还提供了一个扩展的功能集，包括每个锁对应于多个等待线程集，可中断或不可中断的条件等待，公平或非公平的队列操作，以及基于时限的等待。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：创建状态依赖的类的最简单的方法通常是在类库中现有状态依赖类的基础上进行构造。但如果类库没有提供你需要的功能，我们还可以使用Java语言和类库提供的底层机制来构造自己的同步机制，包括内置的条件队列、显式的Condition对象以及AbstractQueuedSynchronizer框架。
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发_10_显示锁</title>
    <link href="http://bestlixiang.site/2018/01/24/Java%E5%B9%B6%E5%8F%91-10-%E6%98%BE%E7%A4%BA%E9%94%81/"/>
    <id>http://bestlixiang.site/2018/01/24/Java并发-10-显示锁/</id>
    <published>2018-01-24T06:21:40.000Z</published>
    <updated>2018-01-24T06:23:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：Java5.0以后提供了一种新的协调对共享对象的访问机制——ReentrantLock。它并不是用来替代内置锁的方法，而是当内置加锁不适用时，作为一种可选择的高级功能。<a id="more"></a></p>
<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>ReentrantLock实现了Lock接口，并提供了与synchronized相同的互斥性和内存可见性，但是通常能提供更好的活跃性或性能。下面是Lock接口代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为什么要创建一种与内置锁如此相似的新加锁价值？是由于内置锁具有以下的局限性：</p>
<ul>
<li>无法中断一个正在等待获取锁的线程。</li>
<li>内置锁必须在获取锁的代码块中释放，这就简化了编码工作，并且与异常处理操作实现了很好的互动，但却无法实现非阻塞结构的加锁规则。   </li>
</ul>
<p>下面是Lock接口的标准使用形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">...</div><div class="line">lock.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">//更新对象状态</span></div><div class="line">    <span class="comment">//捕获异常，并在必要时恢复不变性条件</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    lock.unlock(); <span class="comment">//“定时炸弹”，一定要记得释放Lock</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="轮询锁与定时锁"><a href="#轮询锁与定时锁" class="headerlink" title="轮询锁与定时锁"></a>轮询锁与定时锁</h2><p>可定时的与可轮询的锁获取模式是由tryLock方法实现的，与无条件的锁获取模式相比，它具有更完善的错误恢复机制。在内置锁中，死锁是一个严重的问题，恢复程序的唯一办法是重新启动程序，而防止死锁的唯一方法就是在构造程序时避免出现不一致的锁顺序。可定时的与可轮询的的锁提供了另一种选择，避免死锁的发生。通过重新获取及释放锁来避免死锁。</p>
<h2 id="可中断的锁操作获取操作"><a href="#可中断的锁操作获取操作" class="headerlink" title="可中断的锁操作获取操作"></a>可中断的锁操作获取操作</h2><p>可中断的锁操作获取操作是有lockInterruptibly或者tryLock方法实现的，如果在可中断的锁获取操作中抛出了InterruptedException，那么可以使用标准的try-finally加锁模式。</p>
<h2 id="非块结构的加锁"><a href="#非块结构的加锁" class="headerlink" title="非块结构的加锁"></a>非块结构的加锁</h2><p>我们通过Lock的使用结构可以知道，我们通过ReentrantLock可以灵活的实现锁的粒度。</p>
<h1 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h1><p>大多数情况下，非公平锁的性能要高于公平锁的性能，原因是后者为了实现公平，会有更多的线程上下文切换成本。</p>
<p>当持有锁的时间较长，或者请求锁的平均时间间隔较长，那么应该使用公平锁。在这些情况下，允许“插队”带来的吞吐量提升（当锁处于可用的状态时，线程却还处于被唤醒的过程中）则可能不会出现。</p>
<h1 id="在synchronized和ReentrantLock之间进行选择"><a href="#在synchronized和ReentrantLock之间进行选择" class="headerlink" title="在synchronized和ReentrantLock之间进行选择"></a>在synchronized和ReentrantLock之间进行选择</h1><p><strong>在一些内置锁无法满足需求的情况下，ReentrantLock可以作为一种高级工具。当需要一些高级功能时才应该使用ReentrantLock，这些功能包括：可定时的、可轮询的与可中断的锁获取操作，公平队列（默认非公平），以及非块结构的锁。否则，还是应该优先使用synchronized。</strong></p>
<h1 id="读-写锁"><a href="#读-写锁" class="headerlink" title="读-写锁"></a>读-写锁</h1><p>在读-写锁的加锁策略中，允许多个读操作同时进行，但每次只允许一个写操作。</p>
<p>ReentrantReadWriteLock为读锁和写锁都提供了可重入的加锁语义。ReentrantReadWriteLock在构造时可以选择是一个非公平的锁（默认）还是一个公平的锁。在公平的锁中，等待时间最长的线程将优先获得锁。在非公平的锁中，线程获得访问许可的顺序是不确定的。写线程可以降级为读线程，但是读线程不可以升级为写线程（因为多个读线程都不会放弃自己的读取锁而导致死锁）。</p>
<p><strong>适用场景：</strong> 当锁的持有时间较长并且大部分操作都不会修改被守护的资源时，那么读-写锁能提高并发性。如果写操作也很频繁，那可能独占锁更合适一些，因为写操作太多，竞争会很激烈，再加上协调读写锁，性能反而不如独占锁了。</p>
<p>下面展示用读-写锁来包装Map：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; map;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock r = lock.readLock();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock w = lock.writeLock();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadWriteMap</span><span class="params">(Map&lt;K, V&gt; map)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.map = map;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span> <span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        w.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> map. put(key, value);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            w.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 对remove(),putAll(),clear()等方法执行同样的操作</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        r.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> map.get(key);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            r.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 对其他只读的Map方法执行相同的操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>与内置锁相比，显示的Lock提供了一些扩展功能，在处理锁的不可用性方法有着更高的灵活性。但ReentrantLock不能完全替代synchronized，只有在synchronized无法满足需求时，才应该使用它。</li>
<li>读-写锁运行多个读线程并发地访问被保护的对象，当访问以读取操作为主的数据结构时，它能提高程序的可伸缩性。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：Java5.0以后提供了一种新的协调对共享对象的访问机制——ReentrantLock。它并不是用来替代内置锁的方法，而是当内置加锁不适用时，作为一种可选择的高级功能。
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发_9_性能和可伸缩性</title>
    <link href="http://bestlixiang.site/2018/01/24/Java%E5%B9%B6%E5%8F%91-9-%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7/"/>
    <id>http://bestlixiang.site/2018/01/24/Java并发-9-性能和可伸缩性/</id>
    <published>2018-01-24T02:12:31.000Z</published>
    <updated>2018-01-24T02:13:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：线程最主要的目的是提高程序的运行性能，虽然我们希望获得更好的性能，但始终要把安全性放在第一位。首先要保证程序的正常运行，然后仅当程序的性能需求和测试结果要求程序执行得更快时，才应该设法提高它的运行速度<a id="more"></a></p>
<h1 id="性能和可伸缩性"><a href="#性能和可伸缩性" class="headerlink" title="性能和可伸缩性"></a>性能和可伸缩性</h1><p><strong>提升性能</strong>意味着用更少的资源做更多的事。这些资源包括CPU时钟周期、内存、网络带宽、I/O带宽、数据库请求、磁盘空间以及其他资源。</p>
<p>尽管就是用多个线程的目标是提升整体性能，但与单线程相比，使用多个线程会引入一些额外的开销。造成这些开销的操作包括：线程之间的协调（例如加锁、触发信号以及内存同步等），增加上下文切换，线程的创建和销毁、以及线程的调度等。</p>
<p>为了通过并发获得更好的性能，需要：</p>
<ul>
<li>更有效地利用现有处理资源</li>
<li>在出现新的处理资源时使程序尽可能地利用这些新资源</li>
<li>从性能监视角度来看，CPU需要尽可能保持忙绿状态</li>
</ul>
<h2 id="应用程序性能的衡量指标"><a href="#应用程序性能的衡量指标" class="headerlink" title="应用程序性能的衡量指标"></a>应用程序性能的衡量指标</h2><ul>
<li>服务时间、等待时间用于衡量程序的“运行速度”，即某个指定的任务单元需要“多快”才能处理完成。</li>
<li>生产量、吞吐量用于衡量程序的“处理能力”，即在给定计算机资源的情况下，能完成“多少”工作。</li>
</ul>
<p>性能的提高就是使应用程序，1）对任务单元的处理速度更快，2）资源一定的情况下，完成更多的工作</p>
<h2 id="可伸缩性定义"><a href="#可伸缩性定义" class="headerlink" title="可伸缩性定义"></a>可伸缩性定义</h2><p>当增加计算资源时（例如CPU、内存、存储容量或I/O带宽），程序的吞吐量或者处理能力能相应地增加。</p>
<h2 id="评估各种性能权衡因素"><a href="#评估各种性能权衡因素" class="headerlink" title="评估各种性能权衡因素"></a>评估各种性能权衡因素</h2><p>服务器应用程序的指标是可伸缩性、吞吐量和生成量；交互式应用程序指标是多快。</p>
<p><strong>避免不成熟的优化（由于需求不明确），首先使程序正确，然后再提高运行速度——如果它还运行得不够快。</strong></p>
<h1 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h1><p><strong>Amdahl定律：</strong> 在增加计算资源的情况下，程序在理论上能够实现最高加速比，这个值取决于可并行组件与串行组件所占的比重。假定F是必须被串行执行的部分，那么根据Amdahl定律，在包含N个处理器的机器中，最高的加速比为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Speedup &lt;= <span class="number">1</span> / ( F + (<span class="number">1</span>-F) / N )</div></pre></td></tr></table></figure></p>
<p>当N趋近于无穷大时，最大的加速比趋近于1/F。因此，如果程序有50%的计算需要串行执行，那么最高的加速比只能是2（而不管有多少个线程可用）</p>
<p><strong>注意：在所有并发程序中都包含一些串行部分。</strong></p>
<p>我们评估一个算法时，要考虑算法在<strong>数百个或数千个处理器</strong>的情况下的性能表现，从而对可能出现的可伸缩性局限有一定程度的认识。</p>
<h1 id="线程引入的开销"><a href="#线程引入的开销" class="headerlink" title="线程引入的开销"></a>线程引入的开销</h1><p>在多个线程的调度和协调过程中都需要一定的性能开销：对于为了提升性能而引入的线程来说，并行带来的性能提升必须超过并发导致的开销。</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>如果可运行的线程数大于CPU数量，那么操作系统最终会将某个运行的线程调度出来，从而使其他线程能够使用CPU，这将导致一次上下文切换，在这个过程中将保存当前运行线程的执行上下文，并将新调度进来的线程的执行上下文设置为当前上下文。</p>
<p>当线程由于等待某个发生竞争的锁而被阻塞时，JVM通常会将这个线程挂起，并允许它被交换出去。如果线程频繁地发生阻塞，那么他们将无法使用完整的调度<strong>时间片</strong>。在程序中发生越多的阻塞，CPU密集型的程序就会发生越多的上下文切换，从而增加调度开销，并因此而降低吞吐量。</p>
<h2 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h2><p>同步操作的性能开销包括多个方面。在synchronized和volatile提供的可见性保证中可能会使用一些特殊的指令，即内存栅栏。内存栅栏可以刷新缓存，使缓存无效，刷新硬件的写缓冲，以及停止执行管道。内存栅栏可能同样会对性能带来间接地影响，应为它会抑制一些编译器的优化。在内存栅栏中，大多数操作是不能被重排序的。</p>
<p><strong>不要过度担心非竞争同步带来的开销。这个基本的机制已经非常快了，并且JVM还能进行额外的优化以进一步降低或开销。因此，我们应该将优化的重点放在那些发生锁竞争的地方。</strong></p>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>当在锁上发生竞争时，竞争失败的线程肯定会阻塞，JVM在实现阻塞行为时，可以采用自旋等待（指通过循环不断尝试获取锁，直到成功）或者通过操作系统挂起被阻塞的线程。这两种方式的效率高低，要取决于上下文切换的开销以及在成功获取锁之前需要等待的时间。</p>
<ul>
<li>等待时间较短：适合采用自旋等待方式</li>
<li>等待时间较长：适合采用线程挂起方式</li>
</ul>
<h1 id="减小锁的竞争"><a href="#减小锁的竞争" class="headerlink" title="减小锁的竞争"></a>减小锁的竞争</h1><p>串行操作会降低可伸缩性，并且上下文切换也会降低性能。在锁上发生竞争时将同时导致这两种问题，因此减少锁竞争会提高性能和可伸缩性。</p>
<p><strong>在并发程序中，对可伸缩性的最主要威胁就是独占方式的资源锁。</strong></p>
<p>有两个因素将影响在锁上发生竞争的可能性：</p>
<ul>
<li><strong>锁的请求频率</strong></li>
<li><strong>每次持有锁的时间</strong></li>
</ul>
<p>如果两者的乘积很小，那么大多数获取锁的操作都不会发生竞争。</p>
<p>有三种方式可以降低锁的竞争程度：</p>
<ul>
<li>减少锁的持有时间</li>
<li>降低锁的请求频率</li>
<li>使用带有协调机制的独占锁，这些机制允许更高的并发性</li>
</ul>
<h2 id="缩小锁的范围（“快进快出”）"><a href="#缩小锁的范围（“快进快出”）" class="headerlink" title="缩小锁的范围（“快进快出”）"></a>缩小锁的范围（“快进快出”）</h2><p>其实质是减少锁的持有时间。，同时根据Amdahl定律，这样消除了限制可伸缩性的一个因素，因为串行代码的总量减少了。</p>
<p><strong>注意：</strong> 在实际情况中，仅当可以将一些“大量”的计算或阻塞操作从同步代码块移出时，才应该考虑同步代码块的大小。</p>
<h2 id="减小锁的粒度"><a href="#减小锁的粒度" class="headerlink" title="减小锁的粒度"></a>减小锁的粒度</h2><p>另一种减小锁的持有时间的方式是降低线程请求的频率（从而减小发生竞争的可能性）。这可以通过锁分解和锁分段等技术来实现。</p>
<h3 id="锁分解"><a href="#锁分解" class="headerlink" title="锁分解"></a>锁分解</h3><p>如果一个需要保护多个相互独立的状态变量，那么可以将这个锁分解为多个锁，并且每个锁只保护一个变量，从而提高可伸缩性，并最终降低每个锁的请求频率。看到下面的代码变化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原代码：通过内置锁保护了users和queries两个状态变量</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerStatus</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Set&lt;String&gt; users;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Set&lt;String&gt; queries;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String u)</span> </span>&#123; users.add(u); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addQuery</span><span class="params">(String q)</span> </span>&#123; queries.add(q); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 修改代码：通过锁分解分开保护了users和queries两个状态变量</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerStatus</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Set&lt;String&gt; users;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Set&lt;String&gt; queries;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String u)</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (users) &#123;</div><div class="line">            users.add(u);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQuery</span><span class="params">(String q)</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (queries) &#123;</div><div class="line">            queries.add(q);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对<strong>竞争适中</strong>的锁进行分解时，实际上是把这些转变为非竞争的锁，从而有效地提高性能和可伸缩性。</p>
<h3 id="锁分段"><a href="#锁分段" class="headerlink" title="锁分段"></a>锁分段</h3><p>由于在一个拥有多个处理器的系统中，锁分解仍然无法给可伸缩性带来极大的提高，这个时候就出来锁分段技术。</p>
<p><strong>锁分段：</strong> 将锁分解技术进一步扩展为对一组对象上的锁进行分解。</p>
<p>例子：在ConcurentHashMap的实现中使用了一个包含16个锁的数组，每个锁保护所有散列桶的1/16，其中第N个散列桶有第（N mod 16）个锁来保护。正是这项技术使得CouncurentHashMap能够支持多达16个并发的写入器。</p>
<p>锁分段的劣势：与采用单个锁来实现独占访问相比，要获得多个锁来实现独占访问将更困难整个容器，例如当ConcurrentHashMap需要扩展映射范围等。</p>
<h2 id="避免热点域"><a href="#避免热点域" class="headerlink" title="避免热点域"></a>避免热点域</h2><p>如果将一些反复计算的结果缓存起来，那么将会引入一些“热点域”。而这些热点域往往会限制可伸缩性。</p>
<p>例子：参考ConcurrentHashMap里边将热点域size分成多个值，当我们需要获取全局size的时候，就临时把这些值加起来就是，虽然可能得不到一个准确的值，但大大提高了并发性，是划算的。</p>
<h2 id="一些代替独占锁的方法"><a href="#一些代替独占锁的方法" class="headerlink" title="一些代替独占锁的方法"></a>一些代替独占锁的方法</h2><p>放弃使用独占锁，从而有助于使用一种友好并发的方式来管理共享状态。例如，使用并发容器、<strong>读-写锁</strong>、不可变对象以及原子变量。                                </p>
<h2 id="监测CPU的利用率"><a href="#监测CPU的利用率" class="headerlink" title="监测CPU的利用率"></a>监测CPU的利用率</h2><p>当测试可伸缩性时，通常要确保处理器得到充分利用。</p>
<p>如果CPU没有得到充分利用，那么需要找出其中的原因（vmstat,mpstat查询CPU使用情况）。可能的原因如下：</p>
<ul>
<li>负载不充足。可以在测试时增加负载，并检查利用率，响应时间和服务时间等指标的变化。如果产生足够多的负载使应用程序达到饱和，那么可能需要大量的计算机能耗，并且问题可能在于客户端系统是否具有足够的能力，而不是被测试系统。</li>
<li>IO密集。可以通过iostat或者perfmon来判断某个应用程序是否是磁盘I/O密集型的，或者通过监测应用的通信流量来判断它是否需要高带宽。</li>
<li>外部限制。如果应用程序依赖于外部服务，比如数据库或web服务，那么性能瓶颈可能并不在你自己的代码中。</li>
<li>锁竞争。使用分析工具可以知道在程序中存在何种程度的锁竞争。比如进行线程栈帧转储，来观察是不是有“waiting to lock monitor”之类的关键字。</li>
</ul>
<p>在CPU保持忙碌状态之后，我们试试增加CPU的数量，比如从4核换到8核，看是否能增加处理能力，如此就可以得出结论：增加CPU可以提高程序的处理能力，类似的其它资源验证过程也是类似的。</p>
<h2 id="向对象池说“不”"><a href="#向对象池说“不”" class="headerlink" title="向对象池说“不”"></a>向对象池说“不”</h2><p>早期垃圾回收机制很慢，效率很低，很多程序通过对象池来降低垃圾回收的压力。但现在的垃圾回收机制已经很快了。在并发程序中，对象池的表现更加糟糕。</p>
<h1 id="减小上下文切换的开销"><a href="#减小上下文切换的开销" class="headerlink" title="减小上下文切换的开销"></a>减小上下文切换的开销</h1><p>传统网络模式下，同步阻塞IO将导致上下文切换，同时，一个连接一个线程将导致更多的上下文切换，改进方法如下：</p>
<ul>
<li>将阻塞IO操作从处理请求的线程分离出来，放到专门的线程中去处理。</li>
<li>使用nio，多路复用机制，实现可以由有限线程池来处理所有的连接请求。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于使用线程通常是为了充分利用多个处理器的计算能力，因此在并发程序性能的套路那种，通常更多地将重点放在吞吐量和可伸缩性上，而不是服务时间。Amdahl定律告诉我们，程序的可伸缩性取决于在所有代码中必须被串行化执行的代码比例。因为Java程序中串行操作的主要来源是独占方式的资源锁，因此通常可以通过以下方式来提高可伸缩性：减少锁的持有时间，降低锁的粒度，以及采用非独占的锁或非阻塞锁来代替独占锁。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
<li><a href="http://blog.csdn.net/chaozhi_guo/article/details/66476710" target="_blank" rel="external">并发编程实战学习笔记（八）——性能与可伸缩性</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：线程最主要的目的是提高程序的运行性能，虽然我们希望获得更好的性能，但始终要把安全性放在第一位。首先要保证程序的正常运行，然后仅当程序的性能需求和测试结果要求程序执行得更快时，才应该设法提高它的运行速度
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发_8_避免活跃性危险</title>
    <link href="http://bestlixiang.site/2018/01/22/Java%E5%B9%B6%E5%8F%91-8-%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9/"/>
    <id>http://bestlixiang.site/2018/01/22/Java并发-8-避免活跃性危险/</id>
    <published>2018-01-22T13:05:56.000Z</published>
    <updated>2018-01-22T13:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在安全性和活跃性之间通常存在着某些制衡。我们使用加锁机制来确保线程安全，但如果过度地使用加锁，则可能导致顺序死锁。同样，我们使用线程池和信号量来限制对资源的使用，但这些被限制的行为可能会导致资源死锁。Java应用程序无法从死锁中恢复过来，因此在设计时一定要排除那些可能导致死锁出现的条件。<a id="more"></a></p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>最简单的死锁：当线程A持有锁L并想获得锁M的同时，线程B持有锁M并尝试获得锁L，那么这两个线程将永远等待下去。</p>
<p><strong>数据库解决死锁问题：</strong> 当它检测到一组事务发生了死锁时（通过在表示等待关系的有向图中搜索循环），将选择一个牺牲者并放弃这个事务。作为牺牲者的事务会释放它所持有的资源，从而使其他事务继续进行。应用程序可以重新执行被强制终止的事务，而这个事务现在可以成功完成，因为所有跟它竞争资源的事务都已经完成了。</p>
<p><strong>JVM解决死锁问题：</strong><br>当一组Java线程发生死锁时，“游戏”将到此结束——这些线程永远不能使用了。</p>
<h2 id="锁顺序死锁"><a href="#锁顺序死锁" class="headerlink" title="锁顺序死锁"></a>锁顺序死锁</h2><p>示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意：容易发生死锁！</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftRightDeadLock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object left = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object right = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (left) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (right) &#123;</div><div class="line">                doSomething();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightLeft</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (right) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (left) &#123;</div><div class="line">                doSomething();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>解决方法：</strong> 如果所有线程以固定的顺序来获得锁，那么在程序中就不会出现锁顺序死锁问题。</p>
<h2 id="动态死锁问题"><a href="#动态死锁问题" class="headerlink" title="动态死锁问题"></a>动态死锁问题</h2><p>示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意：容易发生死锁！</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account fromAccount, Account toAccount, DollarAmount amount)</span>  <span class="keyword">throws</span> InsufficientFundsException</span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (fromAccount) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (fromAccount) &#123;</div><div class="line">            <span class="keyword">if</span> (fromAccount.getBalance().compareTo(amount)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                fromAccount.debit(amount);</div><div class="line">                toAccount.credit(amount);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>解决方法：</strong> 通过一致哈希算法或者其它方式来统一锁顺序，使未知顺序变为已知顺序。对于极少数的哈希冲突，可以使用“加时赛”锁来解决。解决代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object tieLock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(<span class="keyword">final</span> Account fromAcct,</span></span></div><div class="line">                                            <span class="keyword">final</span> Account toAcct,</div><div class="line">                                            <span class="keyword">final</span> DollarAmount amount)</div><div class="line">                           <span class="keyword">throws</span> InsufficientFundsException&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Helper</span></span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> transfer <span class="keyword">throws</span> InsufficientFundsException&#123;</div><div class="line">              <span class="keyword">if</span>(fromAcct.getBalance().compareTo(amount) &lt; <span class="number">0</span>)&#123;</div><div class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</div><div class="line">              &#125;<span class="keyword">else</span>&#123;</div><div class="line">                  fromAcct.debit(amount);</div><div class="line">                  toAcct.credit(amount);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> fromHash = System.identifyHashCode(fromAcct);</div><div class="line">    <span class="keyword">int</span> toHash = System.identityHashCode(toAcct);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(fromHash &lt; toHash)&#123;</div><div class="line">        <span class="keyword">synchronized</span>(fromAcct)&#123;</div><div class="line">            <span class="keyword">synchronized</span>(toAcct)&#123;</div><div class="line">                <span class="keyword">new</span> Helper.transfer();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (fromHash &gt; toHash) &#123;</div><div class="line">        <span class="keyword">synchronized</span>(toAcct)&#123;</div><div class="line">            <span class="keyword">synchronized</span>(fromAcct)&#123;</div><div class="line">                <span class="keyword">new</span> Helper().transfer();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">synchronized</span>(tieLock)&#123;<span class="comment">//加时赛锁来解决问题</span></div><div class="line">            <span class="keyword">synchronized</span>(fromAcct)&#123;</div><div class="line">                <span class="keyword">synchronized</span>(toAcct)&#123;</div><div class="line">                    <span class="keyword">new</span> Helper().transfer();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="在协作对象之间发生的死锁"><a href="#在协作对象之间发生的死锁" class="headerlink" title="在协作对象之间发生的死锁"></a>在协作对象之间发生的死锁</h2><p>示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意：同步方法获得的是对象锁</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> Point location, destination;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Taxi</span><span class="params">(Dispatcher dispatcher)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.dispatcher = dispatcher;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> location;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point location)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.location = location;</div><div class="line">        <span class="keyword">if</span> (location.equals(destination))</div><div class="line">        dispatcher.notifyAvailable(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getDestination</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> destination;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setDestination</span><span class="params">(Point destination)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.destination = destination;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</div><div class="line">        taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</div><div class="line">        availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</div><div class="line">        availableTaxis.add(taxi);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Image <span class="title">getImage</span><span class="params">()</span> </span>&#123;</div><div class="line">        Image image = <span class="keyword">new</span> Image();</div><div class="line">        <span class="keyword">for</span> (Taxi t : taxis)</div><div class="line">            image.drawMarker(t.getLocation());</div><div class="line">        <span class="keyword">return</span> image;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>尽管没有任何方法会显式地获得两个锁，但是setLocation和getImage等方法的调用者都会获得两个锁，所以有可能造成死锁。</p>
<p><strong>注意：</strong> 如果在持有锁的情况下调用某个外部方法时，那么就需要警惕死锁。</p>
<h2 id="开放调用"><a href="#开放调用" class="headerlink" title="开放调用"></a>开放调用</h2><p><strong>开放调用：</strong> 如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用。</p>
<p>通过开放调用解决在协作对象之间发生的死锁，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> Point location, destination;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> location;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point location)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> reachedDestination;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.location = location;</div><div class="line">            reachedDestination = location.equals(destination);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (reachedDestination)</div><div class="line">            dispatcher.notifyAvailable(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</div><div class="line">        availableTaxis.add(taxi);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Image <span class="title">getImage</span><span class="params">()</span> </span>&#123;</div><div class="line">        Set&lt;Taxi&gt; copy;</div><div class="line">        sychronized (<span class="keyword">this</span>) &#123;</div><div class="line">            copy = <span class="keyword">new</span>  HashSet&lt;Taxi&gt;(taxis);</div><div class="line">        &#125;</div><div class="line">        Image image = <span class="keyword">new</span> Image();</div><div class="line">        <span class="keyword">for</span> (Taxi t : copy)</div><div class="line">            image.drawMarker(t.getLocation());</div><div class="line">        <span class="keyword">return</span> image;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解决的方法思路就是：缩小锁的粒度。</p>
<p>缺点：可能丢失操作原子性，此时需要通过协议来实现原子性，而不是通过加锁。</p>
<h2 id="资源死锁"><a href="#资源死锁" class="headerlink" title="资源死锁"></a>资源死锁</h2><p><strong>独占</strong>类型的访问都可以和加锁操作类比，看起来就像需要获得锁才能访问。</p>
<ul>
<li>如果一个任务需要连接两个数据库，并且在请求这两个资源时不会始终遵循相同的顺序，那么线程A可能持有与数据库D1的连接，并等待与数据库D2的连接，而线程B持有D2的连接并等待与D1的连接。资源池越大，就越不容易出现这种类型的死锁。</li>
<li>线程饥饿死锁。如果某些任务需要等待其它任务的结果，那么这些任务往往是产生线程饥饿死锁的主要来源，有界线程池/资源池与相互依赖的任务不能一起使用。</li>
</ul>
<h1 id="死锁的避免与诊断"><a href="#死锁的避免与诊断" class="headerlink" title="死锁的避免与诊断"></a>死锁的避免与诊断</h1><p>如果必须获取多个锁，那么在设计时必须考虑锁的顺序：尽量减少潜在的加锁交互数量，将获取锁时需要遵循的协议写入正式文档并始终遵循这些协议。</p>
<p>在细粒度锁的程序中，可以通过一种两阶段策略来检查代码中的死锁：首先，找出在什么地方将获取多个锁（使这个集合尽量小），然后对所有这些实例进行全局分析，从而确保他们在整个程序中获取锁的顺序保持一致。尽可能使用开发调用。</p>
<h2 id="支持定时的锁"><a href="#支持定时的锁" class="headerlink" title="支持定时的锁"></a>支持定时的锁</h2><p>当定时锁失败时，你并不需要知道失败的原因。至少你能记录所发生的失败，以及关于这次操作的其它有用信息，并通过一种更平缓的方式来重新启动计算，而不是关闭整个进程。</p>
<p>如果在获取锁时超时，那么可以释放这个锁，然后后退并在一段时间后并再次尝试，从而消除了死锁发生的条件，使程序恢复过来。（这项技术只有在同时获取两个锁时才有效，如果在嵌套的方法调用中请求多个锁，那么即使你知道已经持有了外层的锁，也无法释放它。）</p>
<h2 id="通过线程转储信息来分析死锁"><a href="#通过线程转储信息来分析死锁" class="headerlink" title="通过线程转储信息来分析死锁"></a>通过线程转储信息来分析死锁</h2><p>JVM会通过线程转储来帮助是被死锁的发生。在生成线程转储信息之前，JVM将在等待关系图中通过搜索循环来找出死锁。如果发现了一个死锁，则获取相应的死锁信息，理由在死锁中涉及哪些锁和线程，以及这个锁的获取操作位于程序的哪些位置。</p>
<h1 id="其他活跃危险"><a href="#其他活跃危险" class="headerlink" title="其他活跃危险"></a>其他活跃危险</h1><h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><p>当线程由于无法访问它所需要的资源而不能继续执行时，就发生了“饥饿”，引发饥饿的最常见资源就是CPU时钟周期。</p>
<p><strong>要避免使用线程优先级，因为这会增加平台依赖性，并可能导致活跃性问题，在大多数并发应用程序中，都可以使用默认的线程优先级。</strong></p>
<h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><p>活锁是另一种形式的活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复执行相同的操作，而且总会失败。</p>
<p>活锁通常发生在处理事务消息的应用程序中：如果不能成功地处理某个消息，那么消息处理机制将会回滚整个事务，并将它重新放到队列的开头。如果消息处理器在处理某种特定类型的消息时存在错误并导致它失败，那么会出一直存在“处理-出错-回滚-处理”的循环中。</p>
<p>解决方法：在重试机制中引用随机性。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>活跃性故障是一个非常严重的问题，因为当出现活跃性故障时，除了中止应用程序之外没有其他任何机制可以帮助从这种故障恢复过来。最常见的活跃性故障是锁顺序死锁。在设计时应该避免锁顺序死锁：确保线程在获取多个锁采用一致的顺序。最好的解决方法是在程序中始终使用开放调用。这将大大减少需要同时持有多个锁的地方，也更容易发现这些地方。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在安全性和活跃性之间通常存在着某些制衡。我们使用加锁机制来确保线程安全，但如果过度地使用加锁，则可能导致顺序死锁。同样，我们使用线程池和信号量来限制对资源的使用，但这些被限制的行为可能会导致资源死锁。Java应用程序无法从死锁中恢复过来，因此在设计时一定要排除那些可能导致死锁出现的条件。
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发_7_线程池的使用</title>
    <link href="http://bestlixiang.site/2018/01/22/Java%E5%B9%B6%E5%8F%91-7-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://bestlixiang.site/2018/01/22/Java并发-7-线程池的使用/</id>
    <published>2018-01-22T09:39:53.000Z</published>
    <updated>2018-01-22T09:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：之前介绍了Executor任务执行框架的使用，它不仅简化了任务与线程的生命周期管理，而且还提供了一种简单灵活的方式将任务的提交和任务的执行策略解耦开来。但是深入下去，我们需要对线程池进行配置和调优，并且分析再使用任务执行框架时需要注意的各种危险。<a id="more"></a></p>
<h1 id="在任务与执行策略之间的隐性耦合"><a href="#在任务与执行策略之间的隐性耦合" class="headerlink" title="在任务与执行策略之间的隐性耦合"></a>在任务与执行策略之间的隐性耦合</h1><p>不是所有任务都能适用所有的执行策略的，有些类型的任务需要明确地指定执行策略，包括：</p>
<ul>
<li>依赖性任务：提交给线程池的任务需要依赖其他的任务，我们需要避免<strong>线程饥饿死锁</strong>。</li>
<li>使用线程封闭机制的任务：任务要求其执行策略所在的Executor是单线程的。</li>
<li>对响应时间敏感的任务：GUI应用程序对于响应时间是敏感的。</li>
<li>使用ThreadLocal的任务：Executor会重用线程，所偶一使用ThreadLocal会没有意义。</li>
</ul>
<p>只有当任务都是同类型的并且是相互独立时，线程池的性能才能达到最佳。</p>
<p><strong>在一些任务中，需要拥有或排除某种特定的执行策略。如果某些任务依赖于其他的任务，那么会要求线程池足够大，从而确保他们依赖任务不会被放入等待队列中或被拒绝，而采用线程封闭机制的任务需要串行执行。</strong></p>
<h2 id="线程饥饿死锁"><a href="#线程饥饿死锁" class="headerlink" title="线程饥饿死锁"></a>线程饥饿死锁</h2><p>在线程池中，如果任务依赖于其他任务，那么可能产生死锁。在单线程的Executor中，如果一个任务将另一个任务提交到同一个Executor，并且等待这个被提交任务的结果，那么通常会引发死锁。第二个任务停留在工作队列中，等待第一个任务完成，而第一个任务又无法完成，因为它在等待第二个任务的完成。在更大的线程池中，如果所有正在执行任务的线程都由于等待其他仍处于工作队列中的任务而阻塞，也会发生同样的问题。这种现象叫做<strong>线程饥饿死锁（Thread Starvation Deadlock）</strong>，只要线程池中的任务需要无限期等待一些必须由池中其他任务才能提供的资源或条件，例如某个任务等待另一个任务的返回值或执行结果，那么除非线程池足够大，否则将发生线程饥饿死锁。</p>
<p><strong>每当提交了一个有依赖性的Executor任务时，要清楚地知道可能会出现线程饥饿死锁，因此需要在代码或配置Executor的配置文件中记录线程池的大小限制或配置限制。</strong></p>
<h2 id="运行时间较长的任务"><a href="#运行时间较长的任务" class="headerlink" title="运行时间较长的任务"></a>运行时间较长的任务</h2><p>如果任务阻塞时间过长，那么即使不出现死锁，线程池的响应性也会变得糟糕。执行时间较长的任务不仅会造成线程池堵塞，甚至会增加执行时间较短任务的服务时间。如果线程池中的数量远小于在稳定状态下执行时间较长任务的数量，那么到最后可能所有线程都会运行这些执行时间较长的任务，从而影响整体的响应性。</p>
<p>缓解这个问题的技术就是限定等待资源的时间，而不是无限制等待。例如Thraed.join(),BlockingQueue.put()、CountDownLatch.await()等，如果等待超时，可以把任务标识为失败，然后终止任务或将任务重新放回队列以便随后执行。</p>
<h1 id="设置线程池的大小"><a href="#设置线程池的大小" class="headerlink" title="设置线程池的大小"></a>设置线程池的大小</h1><p>线程池的理想大小取决于被提交任务的类型以及所部署系统的特性。</p>
<p>只要避免过大和过小两种极端情况，如果线程池过大，那么大量的线程将在相对很少的CPU和内存资源上发生竞争，这不仅会导致更高的内存使用量，而且还可能耗尽资源。如果线程池过小，那么导致许多空闲的处理器无法执行工作，从而降低吞吐率。</p>
<p>要想正确设置线程池的大小，必须分析计算环境、资源预算和任务的特性。</p>
<p>对于计算密集型的任务，在拥有N个处理器的系统上，当线程池的大小为N + 1时，通常能实现最优的利用率。</p>
<p>对于包含I/O操作或者其他阻塞操作的任务，由于线程并不会一直执行，因此线程池的规模应该更大。要正确地设置线程池的大小，必须估算出任务的等待时间与计算时间的比值。有个公式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">N = CPU的数量 = Runtime.getRuntime().availableProcessors();</div><div class="line">U = 预期CPU利用率</div><div class="line">W/C = 等待时间,计算时间之比（wait time / compute time）</div><div class="line">线程池的最优大小 = N * U * （<span class="number">1</span> + W/C）</div></pre></td></tr></table></figure></p>
<h1 id="配置ThreadPoolExecutor"><a href="#配置ThreadPoolExecutor" class="headerlink" title="配置ThreadPoolExecutor"></a>配置ThreadPoolExecutor</h1><p>如果newCachedThreadPool、newFixedTheadPool和newScheduledTheadPool等工厂方法返回的ThreadPoolExecutor无法满足需求，可以通过ThreadPoolExecutor的构造函数来实例化一个对象，并根据自己需求来定制。构造函数如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, //线程池的基本大小</span></span></div><div class="line">                          <span class="keyword">int</span> maximumPoolSize, //最大大小</div><div class="line">                          <span class="keyword">long</span> keepAliveTime, //存活时间</div><div class="line">                          TimeUnit unit, //时间单位</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue, //工作队列</div><div class="line">                          ThreadFactory threadFactory, //线程工厂</div><div class="line">                          RejectedExecutionHandler handler) &#123;...&#125;</div></pre></td></tr></table></figure></p>
<h2 id="线程的创建与销毁"><a href="#线程的创建与销毁" class="headerlink" title="线程的创建与销毁"></a>线程的创建与销毁</h2><p>通过调节线程池的基本大小和存活时间，可以帮助线程池回收空闲线程占有的资源，从而使得这些资源可以用于执行其他工作。</p>
<h2 id="管理队列任务"><a href="#管理队列任务" class="headerlink" title="管理队列任务"></a>管理队列任务</h2><p>如果新请求的到达速率超过了线程池的处理速率，那么新到来的请求将会在一个由Executor管理的Runnable队列中等待，而不会像线程那样去竞争CPU资源。</p>
<p>ThreadPoolExecutor允许提供一个BlockingQueue来保存等待执行的任务。基本的任务排队方法有3种：无界队列、有界队列和同步移交。</p>
<p>一种更稳妥的资源管理策略时使用有界队列，例如ArrayBlockingQueue、有界LinkedBlockingQueue、PriorityBlockingQueue。有界队列有助于避免资源耗尽的情况发生，但又带来新的问题：当队列满后，新的任务怎么办？在使用有界的工作队列时，队列的大小和线程池的大小必须一起调节，如果线程池较小而队列较大，那么有助于减少内存使用量，降低CPU使用率，同时减少上下文切换，但代价是限制了吞吐量。</p>
<p>对于非常大的或者无界的线程池，可以使用SynchronousQueue来避免任务排队，它可以直接将任务从生产者移交给工作者线程。SynchronousQueue并不是一个真正的队列，而是一种在线程之间进行移交的机制。要将一个元素放入SynchronousQueue中，必须由另一个线程正在等待接受这个元素。如果没有线程正在等待，并且线程池的当前大小小于最大值，那么ThreadPoolExecutor会创建一个新的线程来处理这个任务。否则，根据饱和策略，这个任务将被拒绝。直接使用移交将更高效，因为任务直接移交给执行它的线程，而不是先放到队列，然后再由工作线程从队列中提取任务。只有当线程池是无界的或者可以拒绝任务时，SynchronousQueue才有实际价值。在newCachedThreadPool中就是使用了SynchronousQueue。</p>
<p>当使用像LinkedBlockingQueue或ArrayBlockingQueue这样FIFO队列时，任务的执行顺序与它们的到达顺序相同。如果想进一步控制任务执行顺序，还可以使用PriorityBlockingQueue，这个队列根据优先级来安排任务，任务的优先级是通过自然顺序或者Comparator来定义的。</p>
<p>只有当任务相互独立时，为线程池或工作队列设置界限才是合理的 。如果任务之间有依赖性，那么有界的线程池或队列会导致线程饥饿死锁问题，此时应该使用无界的线程池，如newCachedThreadPool。</p>
<p><strong>对于Executor，newCachedThreadPool工厂方法是一种很好的默认选择，他能提供比固定大小的线程池更好的排队性能。当需要限制当前任务的数量以满足资源管理需要求时，可以选择固定大小的线程池。</strong></p>
<h2 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h2><p>当有界队列被填满后，饱和策略开始发挥作用，ThreadPoolExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改。</p>
<p>当工作队列被填满后，没有预定义的饱和策略来阻塞ececute。通过使用Semaphore（信号量）来限制任务的到达率可以实现饱和策略的功能。</p>
<h2 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h2><p>每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的。在TheadFactory中只定义了一个方法newThread，每当线程池需要创建一个新线程时都会调用这个方法。</p>
<h2 id="在调用构造函数后再定制ThreadPoolExecutor"><a href="#在调用构造函数后再定制ThreadPoolExecutor" class="headerlink" title="在调用构造函数后再定制ThreadPoolExecutor"></a>在调用构造函数后再定制ThreadPoolExecutor</h2><p>在调用完ThreadPoolExecutor的构造函数后，仍然可以通过设置函数来修改大多数传递给他的构造函数的参数，如果Executor是通过Executors中的某个工厂方法创建的，那么可以通过将结果的类型转换为ThreadPoolExecutor以访问设置器。</p>
<h1 id="扩展ThreadPoolExecutor"><a href="#扩展ThreadPoolExecutor" class="headerlink" title="扩展ThreadPoolExecutor"></a>扩展ThreadPoolExecutor</h1><p>ThreadPoolExecutor是可扩展的，它提供了几个可以在子类化中改写的方法：beforeExcute，afterExecute和terminated，这些方法可以用于扩展ThreadPoolExecutor的行为。 在这里方法中可以添加日志、计时、监视或统计信息收集功能。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于并发执行的任务，Executor框架是一种强大且灵活的框架。它提供了大量可调节的选项。我们要根据实际情况对这些参数进行调节。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：之前介绍了Executor任务执行框架的使用，它不仅简化了任务与线程的生命周期管理，而且还提供了一种简单灵活的方式将任务的提交和任务的执行策略解耦开来。但是深入下去，我们需要对线程池进行配置和调优，并且分析再使用任务执行框架时需要注意的各种危险。
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发_6_取消与关闭</title>
    <link href="http://bestlixiang.site/2018/01/22/Java%E5%B9%B6%E5%8F%91-6-%E5%8F%96%E6%B6%88%E4%B8%8E%E5%85%B3%E9%97%AD/"/>
    <id>http://bestlixiang.site/2018/01/22/Java并发-6-取消与关闭/</id>
    <published>2018-01-22T06:13:10.000Z</published>
    <updated>2018-01-22T06:13:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：任务和线程的启动很容易，在大多数时候，我们都会让他们运行直到结束，然而，有时候我们希望提前结束任务或线程，但是Java没有提供任何机制来安全地终止线程，只是提供了中断，这是一种<strong>协作机制</strong>，能够使一个线程终止另一个线程的工作。所以需要我们能很完善地处理失败、关闭和取消等过程。<a id="more"></a></p>
<h1 id="任务取消"><a href="#任务取消" class="headerlink" title="任务取消"></a>任务取消</h1><p>如果外部代码能在某个操作正常完成之前将其置入“完成”状态，那么这个操作就可以称为可取消的。取消这个操作的原因有很多：</p>
<ol>
<li>用户请求取消。用户点击图形界面程序的“取消”按钮。</li>
<li>有时间限制的操作。某个程序需要在有限时间内完成搜索任务，当超时时，需要取消搜索任务。</li>
<li>错误。当一个爬虫程序发生错误时，那么搜索任务都会取消。</li>
<li>关闭。在立即关闭的过程中，当前的任务则可能被取消。</li>
</ol>
<p>在Java中没有一种安全的抢占式方法来停止线程，因此也就没有安全的抢占式方法来停止任务，只有一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。</p>
<p>其中一种协作机制能设置某个“已请求取消”标志，而任务将定期地查看该标志。如果设置了这个标志，那么任务将提前结束。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="title">implement</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 为了使这个过程能可靠得工作，标志cancelled必须为volatile类型</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span>(!cancelled) &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</div><div class="line">        cancelled = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>如果在上面代码中while里面出现了一个阻塞的方法，那么在调用cancel方法来设置cancelled状态，当却检查不到标志，因为它无法从阻塞的方法恢复过来。如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrokenPrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    BrokenPrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            BigInteger p = BigInteger.ONE;</div><div class="line">            <span class="keyword">while</span> (!cancelled) &#123;</div><div class="line">                <span class="comment">// 如果生产者的速度超过消费者的处理速度，队列将被填满，put方法会被阻塞</span></div><div class="line">                queue.put(p = p.nextProbablePrime());</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</div><div class="line">        cancelled = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以我们会想到一些线程中断这种协作机制，它利用了特殊的<strong>阻塞库</strong>用来是实现任务取消，注意：如果在取消之外的其他操作中使用中断，都是<strong>不合适</strong>的，并且很难支撑起更大的应用。下面是Thread的中断方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 每个线程都有一个boolean类型的中断状态，当中断线程时，这个线程的中断状态将被设置为true</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="comment">// 中断目标线程</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 清除当前线程的中断状态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 返回目标线程的中断状态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>阻塞库的方法，如Thread.sleep和Object.wait等都会检查线程何时中断，并且在发生中断时返回。响应中断执行的操作包括：清除中断状态，抛出InterruptedException。JVM不保证阻塞方法检测到中断的速度，但通常响应速度还是非常快的。</p>
<p>注意：调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。然后由线程在下一个合适的时刻中断自己（这些时刻也被称为取消点）。有些方法，例如wait、sleep和join等，将严格处理这种请求，当他们收到中断请求或者在开始执行时发现某个已被设置好的中断状态，将抛出一个异常。示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrokenPrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</div><div class="line"></div><div class="line">    BrokenPrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            BigInteger p = BigInteger.ONE;</div><div class="line">            <span class="comment">// 在阻塞的put方法调用中以及在循环开始处查询中断状态时，都会检查中断标志</span></div><div class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</div><div class="line">                queue.put(p = p.nextProbablePrime());</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</div><div class="line">        interrupt();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="中断策略"><a href="#中断策略" class="headerlink" title="中断策略"></a>中断策略</h2><p>最合理的中断策略是某种形式的线程级取消操作或者服务级取消操作：尽快退出，在必要时清理，通知某个<strong>所有者</strong>该线程已经退出。此外还可以建立其他的中断策略，例如暂停服务或重新开始服务。</p>
<p>任务不应该对执行该任务的线程的中断策略做出假设。无论任务把中断视为取消，还是其他某个中断响应操作，都应该小心的保存线程的中断状态，如果除了将InterruptException传递给调用者外还需要执行其他操作，那么应该在捕获InterruptException之后恢复中断状态。</p>
<p><strong>线程只能由其所有者中断，所有者可以将线程的中断策略信息封装到某个合适的取消机制中，例如关闭方法中。</strong></p>
<h2 id="响应中断"><a href="#响应中断" class="headerlink" title="响应中断"></a>响应中断</h2><p>在调用可中断的阻塞函数时，有两种实用策略可用于处理InterruptException：</p>
<ul>
<li>传递异常：从而使你的方法也称为了可中断的阻塞方法。</li>
<li>恢复中断状态：从而使调用栈中的上层代码能够对其进行处理。</li>
</ul>
<p><strong>只有是实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求。</strong></p>
<h2 id="通过Future来实现取消"><a href="#通过Future来实现取消" class="headerlink" title="通过Future来实现取消"></a>通过Future来实现取消</h2><p>使用ExecuorService.submit方法将返回一个Future来描述任务，Future有一个cancel方法。cancle方法有一个参数mayInterruptIfRunning,如果设置为true，那么就表示取消操作是否成功（这只是表示任务是否能够接受中断，而不是表示任务是否能够检测并处理中断）。如果为false，表示如果任务还没有运行，那么就不要运行它。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimedRun</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService taskExec = Executors.newCachedThreadPool();  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(Runnable r,<span class="keyword">long</span> timeout, TimeUnit unit)</span>  </span></div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;  </div><div class="line">        Future&lt;?&gt; task = taskExec.submit(r);  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            task.get(timeout, unit);  </div><div class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;  </div><div class="line">            <span class="comment">// 接下来任务将被取消  </span></div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;  </div><div class="line">            <span class="comment">// 如果在任务执行和中抛出了异常，那么重新抛出该异常  </span></div><div class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());  </div><div class="line">        &#125; <span class="keyword">finally</span> &#123;  </div><div class="line">            <span class="comment">//如果任务已经结束，那么执行取消操作也不会带来任何影响  </span></div><div class="line">            task.cancel(<span class="keyword">true</span>); <span class="comment">// 如果任务正在运行，那么将被中断  </span></div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="处理不可中断的阻塞"><a href="#处理不可中断的阻塞" class="headerlink" title="处理不可中断的阻塞"></a>处理不可中断的阻塞</h2><p>在java库中，很多阻塞的方法都是通过提前返回或者是抛出InterruptedException来响应中断请求的，然而并非所有的可阻塞方法或者阻塞机制都能响应中断。</p>
<p>比如一个线程由于执行同步的Socket IO 或者等待获得内置锁而阻塞，那么中断请求只能设置线程的中断状态，除此之外没有其他任何作用，对于那些执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，但这要求我们必须知道线程阻塞的原因，然后通过重写<strong>非标准的取消操作</strong>。</p>
<h1 id="停止基础线程的服务"><a href="#停止基础线程的服务" class="headerlink" title="停止基础线程的服务"></a>停止基础线程的服务</h1><p>应用程序通常会创建多个线程的服务，例如线程池。正确地封装原则是：除非拥有某个线程，否则不能对该线程进行操控，线程池是其工作线程的所有者，如果要中断这些线程，那么应该使用线程池。线程的所有权是不可以传递的：应用程序可以拥有服务，服务可以拥有工作者线程，但应用程序并不能拥有工作者线程，因此应用程序不能直接停止工作者线程。相反，服务应用提供生命周期方法来关闭它自己以及它所拥有的线程，在ExecutorService中提供了shutdown和shutdownNow方法。</p>
<ol>
<li><p>例子：日志服务</p>
<p> 方式：通过调用log方法将日志消息放入某个队列中，并由其他线程来处理；</p>
<p> 停止该服务的方式：通过原子方式来检查关闭请求，并且有条件地递增一个计数器来保存提交信息的权利；</p>
</li>
<li><p>关闭ExecutorService</p>
<p> Service封装在某个更高级别的服务中，并且该服务能提供其自己的生命周期方法。</p>
</li>
<li><p>毒丸对象</p>
<p> 毒丸是指一个放在队列上的对象，其含义是：当得到这个对象时，立即停止；</p>
<p> 限制：只有在生产者和消费者的数量都已知的情况下，才可以使用“毒丸”对象；</p>
<p> 当生产者和消费者数目较大时，这种方法变得难以使用。</p>
</li>
<li><p>例子：只执行一次的服务</p>
<p> 场景：某个方法需要处理一批任务，并且当所有任务都处理完后才返回，可以通过一个私有的Executor来简化服务的生命周期管理，其中该Executor的生命周期是由这个方法控制的</p>
</li>
<li><p>shutdownNow的局限性</p>
<p> 当通过shutdownNow来强行关闭ExecutorService时，尝试取消正在执行的任务，并返回所有已经提交但未开始的任务。但无法在关闭过程中知道正在执行的任务的状态。除非任务本身会执行某种检查。</p>
</li>
</ol>
<h1 id="处理非正常的线程终止"><a href="#处理非正常的线程终止" class="headerlink" title="处理非正常的线程终止"></a>处理非正常的线程终止</h1><p>在并发程序中,是无法做到一直观察控制台的, 例如:你的web应用部署到服务器上,难道你要派个人一直去观察控制台?</p>
<p>任何代码都可能抛出一个RuntimeExecption,每当调用另一个方法时,都要对它的行为保持怀疑,不要盲目地认为它一定会抛出在方法原型中声明的某个已检查异常。对调用的代码越不熟悉,就越应该对其代码行为保持怀疑。</p>
<h2 id="典型的线程池工作者线程结构"><a href="#典型的线程池工作者线程结构" class="headerlink" title="典型的线程池工作者线程结构"></a>典型的线程池工作者线程结构</h2><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">    Throwable <span class="keyword">throw</span> = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="keyword">while</span>(!isInterrupted)&#123;</div><div class="line">            runTask(getTaskFromWorkQueue());</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e)&#123;</div><div class="line">        thrown = e;</div><div class="line">    &#125; <span class="keyword">finally</span>&#123;</div><div class="line">        threadExited(<span class="keyword">this</span>,thrown);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果任务抛出了一个未检查的异常,那么它将使线程终结,但会首先通知框架该线程已经终结.然后,框架可能会用新的线程来代替这个工作线程。</p>
<h2 id="将异常写入日志的UncaughtExecptionHandler"><a href="#将异常写入日志的UncaughtExecptionHandler" class="headerlink" title="将异常写入日志的UncaughtExecptionHandler"></a>将异常写入日志的UncaughtExecptionHandler</h2><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span>.<span class="title">UncaughtExecptionHandler</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t,Throwable e)</span></span>&#123;</div><div class="line">        Logger logger = Logger.getAnonymousLogger();</div><div class="line">        Logger.log(Level.SEVERE,<span class="string">"Thread terminated with exception: "</span>+ t.getName(),e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在运行时间较长的应用程序中,通常会为所有线程的未捕获异常指定同一个异常处理器,并且该异常处理器至少会将异常信息记录到日志中。</p>
<h1 id="JVM关闭"><a href="#JVM关闭" class="headerlink" title="JVM关闭"></a>JVM关闭</h1><p>JVM既可以正常关闭，也可以强行关闭。正常关闭的触发方式有多种，包括：当最后一个“正常（非守护）”线程结束时，或者调用了System.exit时，或者通过其他特定于平台的方法关闭时（例如发送了SIGINT信号或Ctrl-C）。虽然可以通过这些标准方法来正常关闭JVM，但也可以通过调用Runtime.halt或者在操作系统中“杀死”JVM进程来强行关闭JVM。</p>
<h2 id="关闭钩子"><a href="#关闭钩子" class="headerlink" title="关闭钩子"></a>关闭钩子</h2><p>在正常关闭中，JVM首先调用所有已注册的关闭钩子，关闭钩子是指通过Runtime.addShutdownHook注册的但尚未开始的线程。JVM不能保证关闭钩子的调用顺序。在关闭应用程序线程时,如果有线程仍然在运行,那么这些线程接下来将与关闭进程并发执行.</p>
<p><strong>关闭钩子应该是线程安全:它们在访问共享数据时,必须使用同步机制,小心避免死锁。</strong></p>
<p>关闭钩子可以用于实现服务或应用程序的清理工作，例如删除临时文件，或者清除无法由操作系统自动清除的资源。</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>有时候，你希望创建一个线程来执行一些辅助工作，但又不希望这个线程阻碍了JVM的关闭，这种情况就需要使用守护线程。</p>
<p>线程分为两种: 普通线程和守护线程,在JVM启动时启动创建的所有线程中,除了主线程以外，其他的线程都是守护线程。例如垃圾回收器，当创建一个新的线程时，它将继承创建它的线程的类型。</p>
<p><strong>我们应该尽可能少地使用守护线程–很少有操作能够在不进行清理的情况下被安全地抛弃,特别是在执行I/O操作的任务,那么将是一种非常危险的行为; 并且守护线程不能用来替代应用程序管理程序中各个服务的生命周期</strong></p>
<h2 id="终结器"><a href="#终结器" class="headerlink" title="终结器"></a>终结器</h2><p>当不再需要内存资源时，可以通过垃圾回收器来回收它们，但对于其他一些资源，例如文件句柄或套接字句柄，当不再需要它们时,必须显式交还给操作系统。为了实现这个功能，垃圾回收器对那些定义了finalize方法的对象会进行特殊处理: 在垃圾回收期释放它们后，调用它们的finalize方法，从而保证一些持久化的资源被释放。</p>
<p>由于终结器可以在某个JVM管理的线程中运行，因此终结器访问任何状态都可能被多个线程访问，这样就必须对其访问操作进行同步。终结器并不能保证它们将在何时甚至是否会运行，并且复杂的终结器带来性能上的巨大开销。编写正确的终结器是非常困难的。在大多数情况下，通过使用finally代码块和显式的close方法能够比终结器更好的管理资源。</p>
<p><strong>避免使用终结器</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在任务、线程、服务以及应用程序等模块中的生命周期结束问题，可能会增加他们在设计和实现时的复杂性。Java并没有提供某种抢占式的机制来取消操作或者总结线程。相反，它提供了一种协作式的中断机制来实现取消操作，但这要依赖于如何构建取消操作的协议，以及能否始终遵循这些协议。通过使用<strong>FutureTask</strong>和<strong>Executor</strong>框架，可以帮助我们构建可取消的任务和服务。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：任务和线程的启动很容易，在大多数时候，我们都会让他们运行直到结束，然而，有时候我们希望提前结束任务或线程，但是Java没有提供任何机制来安全地终止线程，只是提供了中断，这是一种&lt;strong&gt;协作机制&lt;/strong&gt;，能够使一个线程终止另一个线程的工作。所以需要我们能很完善地处理失败、关闭和取消等过程。
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发_5_任务执行</title>
    <link href="http://bestlixiang.site/2018/01/15/Java%E5%B9%B6%E5%8F%91-5-%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/"/>
    <id>http://bestlixiang.site/2018/01/15/Java并发-5-任务执行/</id>
    <published>2018-01-15T03:02:09.000Z</published>
    <updated>2018-01-15T03:02:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：在大多数并发应用程序都是围绕“任务执行”来构造的：任务通常是一些抽象且离散的工作单元。通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。<a id="more"></a></p>
<h1 id="在线程中执行任务"><a href="#在线程中执行任务" class="headerlink" title="在线程中执行任务"></a>在线程中执行任务</h1><p>要使服务器应用程序同时表现出良好的吞吐量和快速的响应性，应该选择清晰的<strong>任务边界</strong>以及明确的任务<strong>执行策略</strong>（见后面）。</p>
<h2 id="串行地执行任务"><a href="#串行地执行任务" class="headerlink" title="串行地执行任务"></a>串行地执行任务</h2><p>最简单的调度任务策略就是在单个线程中串行地执行各项任务。但串行处理机制通常都无法提供高吞吐率或快速响应性。</p>
<h2 id="显示地为任务创建线程"><a href="#显示地为任务创建线程" class="headerlink" title="显示地为任务创建线程"></a>显示地为任务创建线程</h2><p>通过为每个请求创建一个新的线程来提供服务，从而实现更高的响应性。但为每个任务分配一个线程也存在一些缺陷。</p>
<h2 id="无限创建线程的不足"><a href="#无限创建线程的不足" class="headerlink" title="无限创建线程的不足"></a>无限创建线程的不足</h2><ul>
<li>线程生命周期的开销非常高。线程的创建过程需要时间，这就延迟了请求的处理，并且需要JVM和操作系统提供一些辅助操作。</li>
<li>资源消耗。如果可运行线程数量多于可用处理器的数量，那么有些线程会闲置就会占用许多内存，如果大量线程在竞争CPU还会产生其他的性能消耗。</li>
<li>稳定性。在可创建线程的数量上有一个阈值，这个阈值随着平台不同而不同，并且受多个因素制约，包括JVM的启动参数、Thread构造函数中请求的栈大小，以及底层操作系统对线程的限制等。如果超过这个限制，就很可能有OOM异常。</li>
</ul>
<h1 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h1><p><strong>线程池</strong>简化了线程的管理工作，并且java.util.concurrent提供了一种灵活的线程池作为Executor框架的一部分。在java类库中，任务执行的不是Thread，而是Executor。其代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Executor框架提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用Runnable来表示任务。Executor的实现还提供了对生命周期的支持，以及统计信息收集/应用程序管理机制和性能监视等机制。Executor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程相当于消费者。</p>
<h2 id="示例：基于Executor的Web服务器"><a href="#示例：基于Executor的Web服务器" class="headerlink" title="示例：基于Executor的Web服务器"></a>示例：基于Executor的Web服务器</h2><p>可以看到下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskExecutorWebServer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NTHREAD = <span class="number">100</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor exe = Executors.newFixedThreadPool(NTHREAD);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">final</span> Socket connection = socket.accept();</div><div class="line">            Runnable task = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    handleRequest(connection);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            exec.execute(task);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在TaskExecutionWebServer中，通过使用Executor，将请求处理任务的提交与任务的实际执行解耦开来，并且只需要采用另一种不同的Executor实现，就可以改变服务器的行为。</p>
<p>将TaskExecutorWebServer改为显示地为任务创建线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 为每个请求都创建新线程的Executor</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Thread(r).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将TaskExecutorWebServer改为串行地执行任务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 以同步方式执行所有任务的Executor</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WithinThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        r.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h2><p>各种执行策略都是一种资源管理工具，最佳策略取决于可用的计算资源以及对服务质量的需求。通过限制并发任务的数量，可以确保应用程序不会由于资源耗尽而失败，或者由于在稀缺资源发生竞争而严重影响性能。通过将任务的提交于任务的执行分离开来，有助于在部署阶段选择与可用硬件资源最匹配的执行策略。</p>
<p>每当看到下面形式的代码时，并且希望获得一种更灵活的执行策略时，考虑使用Executor来代替Thread：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(runnable).start();</div></pre></td></tr></table></figure></p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池是指管理一组相同工作线程的资源池。线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务。工作线程的任务很简单： 从工作队列中获取一个任务，执行任务，执行完后返回线程池并等待下一个任务。</p>
<p>“在线程池中执行任务”比“为每个任务分配一个线程”优势更多。通过重用现有的线程而不是创建新线程，可以减少在线程创建与销毁的开销。另一个好处是请求到来时，不会再因为要等待线程创建而延迟，也就提高了响应性。通过适当调整线程池的大小，可以创建足够多的线程以便处理器保持忙碌状态，同时还可以防止过多线程互相竞争资源而使应用程序耗尽内存。</p>
<p>类库提供了一个灵活的线程池以及一些有用的默认配置。可以通过调用Executors中的静态工厂方法之一来创建一个线程池：</p>
<ul>
<li>newFixedThreadPool：创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化。（如果某个线程由于发生了未预期的Exception而结束，那么线程池会补充一个新的线程）。</li>
<li>newCachedThreadPool：创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。</li>
<li>newSingleThreadExecutor：是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。它能确保依照任务在队列中的顺序来串行执行。</li>
<li>newScheduledThreadPool：创建了一个固定长度的线程池，而且以延迟或定时的方式执行任务，类似于Timer。</li>
</ul>
<p>从“为每个任务分配一个线程”策略变为基于线程池的策略，将对应用程序的稳定性产生重大影响：Web服务器不会再在高负载情况下失败。由于服务器不会创建数千个线程来争夺有限的CPU和内存资源，因此服务器的性能将平缓地降低。通过使用Executor，可以实现各种调优/管理/监视/记录日志/错误报告和其他功能，如果不使用任务执行框架，那么要增加这些功能是非常困难的。</p>
<h2 id="Executor的生命周期"><a href="#Executor的生命周期" class="headerlink" title="Executor的生命周期"></a>Executor的生命周期</h2><p>Executor的实现通常会创建线程来执行任务，但JVM只有在所有非守护线程全部终止之后才会退出，如果无法正确关闭Executor，那么JVM将无法结束。</p>
<p>由于Executor以异步方式来执行任务，因此在任何时刻，之前提交任务的状态不是立即可见的。有些任务可能已经完成，有些可能正在运行，而其他的任务可能在队列中等待执行。当关闭应用程序时，可能采用平缓的方式（完成所有已经启动的任务，并且不再接受任何新的任务），也可能采用粗暴方式（直接所有都关掉）。Executor视为应用程序提供服务的，因此它们也是可关闭的，并把在关闭操作中受影响的任务的状态返回给应用程序。</p>
<p>为了解决执行任务的生命周期问题，ExecutorService接口扩展了Executor，添加了一些用于生命周期管理的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutDownNow</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">    <span class="comment">// ......其他用于任务提交的便利方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ExectuorService的生命周期有三种状态：运行、关闭和已终止。ExecutorService在创建时处于运行状态，shutdown方法执行优雅地关闭:不再接受新的任务，同时等待已经提交的任务执行完成–包括那些还未开始执行的任务。shutdownNow方法执行粗暴的关闭：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。</p>
<p>例如支持关闭操作的Web服务器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleWebServer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = ...;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</div><div class="line">        <span class="keyword">while</span>(!exec.isShutdown()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">final</span> Socket conn = socket.accept();</div><div class="line">                exec.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        handleRequest(conn);</div><div class="line">                    &#125;</div><div class="line">                &#125; );</div><div class="line">           &#125; <span class="keyword">catch</span> (RejectedExecutonException e) &#123;</div><div class="line">                 <span class="keyword">if</span> (!exec.isShutdown()) &#123;</div><div class="line">                    log(<span class="string">"task submission rejected"</span>, e);</div><div class="line">                &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">          exec.shutdown();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Socket connection)</span> </span>&#123;</div><div class="line">          Request req = readRequest(connection);</div><div class="line">          <span class="keyword">if</span> (isShutdownRequest(req)) &#123;</div><div class="line">               stop();</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">               dispatchRequest(req);</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="延迟任务与周期任务"><a href="#延迟任务与周期任务" class="headerlink" title="延迟任务与周期任务"></a>延迟任务与周期任务</h2><p>Timer类负责管理延迟任务以及周期任务，然而，Timer存在一些缺陷，因此应该考虑使用ScheduledThreadPoolExecutor来代替它，可以通过ScheduledThreadPoolExecutor的构造函数或Executors.newScheduledThreadPool工厂方法来创建该类的对象。它很少被使用，主要的缺陷有：</p>
<ul>
<li>Time在执行所有定时任务时只会创建一个线程，会破坏其他TimeTask的定时精确性。</li>
<li>如果TimeTask抛出一个未检查的异常，那么Time将表现出糟糕的行为。</li>
</ul>
<h1 id="找出可利用的并行性"><a href="#找出可利用的并行性" class="headerlink" title="找出可利用的并行性"></a>找出可利用的并行性</h1><p>下面将展示一个逐步利用并行性的浏览器程序中的页面渲染功能，它的作用是将HTMl页面回执到图像缓存中。</p>
<p>最简单的方法是对HTML文档进行串行处理，遇到图像引用，就通过网络获取它，然后再将其绘制到图像缓存中。但是这种方式需要等待很长时间。</p>
<p>另一种串行方式是先绘制文本元素，然后再开始下载图像，如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 图片下载过程的部分时间都是在等待I/O操作执行完成，没有充分利用CPU</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadRenderer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</div><div class="line">        renderText(source);</div><div class="line">        List&lt;ImageData&gt; imageData = <span class="keyword">new</span> ArrayList&lt;ImageData&gt;();</div><div class="line">        <span class="keyword">for</span> (ImageInfo imageInfo : scanForImageInfo(source)) &#123;</div><div class="line">            imageData.add(imageInfo.downloadImage());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (ImageData data : imageData) &#123;</div><div class="line">            renderImage(data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Executor使用Runnable作为其基本的任务表示形式，但是Runnable是一种有很大局限的抽象，虽然run能写入到日志文件或者将结果放入到某个共享的数据结构，但它不能返回一个值或抛出一个受检查的异常。</p>
<p>许多任务实际上都是存在延迟的计算—— 执行数据库查询，从网络上获取资源，或者计算某个复杂的功能。对于这些任务，Callable是一种更好的抽象：它认为主入口点（即call）将返回一个值，并可能抛出一个异常。</p>
<p>Runnable和Callable描述的都是抽象的计算任务。这些任务通常都是有范围的，即都有一个明确的起点，并且最终会结束。Executor执行的任务又四个生命周期阶段：创建/提交/开始/完成。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当它们响应中断时，才能取消。</p>
<p>Future表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。在Future规范中包含的隐含意义是，任务的生命周期只能前进，不能后退。当某个任务完成后，它就永远停留在“完成”状态上。</p>
<p>可以通过许多方法创建一个Future来描述任务。<strong>ExecutorService中的所有submit方法都将返回一个Future，从而将一个Runnable或Callable提交给Executor，并得到一个Future用来获得任务的执行结果或者取消任务</strong>。还可以显式地为某个指定的Runnable或Callable实例化一个FutureTask。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// FutureReaderer使得渲染文本与下载图像数据的任务并发执行</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureRenderer</span> </span>&#123;</div><div class="line">    <span class="comment">// 1.创建ExecutorService</span></div><div class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> List&lt;ImageInfo&gt; imageInfos = scanFooImageInfo(source);</div><div class="line"></div><div class="line">        <span class="comment">// 2.创建Callable任务</span></div><div class="line">        Callable&lt;List&lt;ImageData&gt;&gt; task = <span class="keyword">new</span> Callable&lt;List&lt;ImageData&gt;&gt;() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> List&lt;ImageData&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                List&lt;ImageData&gt; result = <span class="keyword">new</span> ArrayList&lt;ImageData&gt;();</div><div class="line">                <span class="keyword">for</span> (ImageInfo imageInfo : imageInfos) &#123;</div><div class="line">                    result.add(imageInfo);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">// 3. 提交Callable任务，获得Future</span></div><div class="line">        Future&lt;List&lt;ImageData&gt;&gt; future = (Future) executorService.submit(task);</div><div class="line">        <span class="comment">// 渲染文本</span></div><div class="line">        renderText(source);</div><div class="line"></div><div class="line">        <span class="comment">// 4. 调用get获取结果，并处理异常</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            List&lt;ImageData&gt; imageData = future.get();</div><div class="line">            <span class="keyword">for</span> (imageData data : imageData) &#123;</div><div class="line">                RenderableImage(data);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            Thread.currentThread().interrupt();</div><div class="line">            future.cancel(<span class="keyword">true</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get方法的行为取决于任务的状态（尚未开始，正在执行，已完成）。如果任务已经完成，那么get会立即返回或者抛出一个Exception，如果任务没有完成，那么get将阻塞并直到任务完成。如果任务抛出了异常，那么get将该异常封装为ExecutionException并重新抛出。如果任务被取消，那么get将抛出CancellationException。</p>
<p>如果将两个任务A和B分配给两个工人，但A的执行时间是B的10倍，那么整个过程也只能加速9%。最后，当在多个工人之间分解任务时，还需要一定的任务协调开销：为了使任务分解能提高性能，这种开销不能高于并行性实现的提升。所以只有当大量互相独立且同构的任务可以并发进行处理时，才能体现出将程序的工作负载分配到多个任务中带来的真正性能提升。</p>
<p>如果向Executor提交了一组计算任务，并且希望在计算完成后获得结果，那么可以保留与每个任务关联的Future，然后反复使用get方法，同时将参数timeout指定为0，从而通过轮训来判断任务是否完成。这种方法虽然可行，但有些繁琐。幸好有CompletionService（完成服务）。</p>
<p>CompetionService将Executor和BlockingQueue的功能融合在一起，可以将Callable任务提交给它来执行，然后使用类似于队列操作的take和poll等方法来获得已完成的结果，而这些结果会在完成时被封装为Future。ExecutorCompletionService实现了CompletionService，并将计算部分委托给一个Executor。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过CompletionService从两方面来提高页面渲染器的性能：缩短总运行时间以及提高响应性。其实现是为每一幅图像都创建一个独立的任务。</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Renderer</span> </span>&#123;</div><div class="line">    <span class="comment">// 1.创建一个ExecutorService</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line"></div><div class="line">    Renderer(ExecutorService executor) &#123; <span class="keyword">this</span>.executor = executor; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span> <span class="params">(CharSequence source)</span> </span>&#123;</div><div class="line">        List&lt;ImageInfo&gt; info = scanForImageInfo(source);</div><div class="line">        <span class="comment">// 2. 创建ExecutorCompletionService</span></div><div class="line">        CompletionService&lt;ImageData&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;ImageData&gt;(executorService);</div><div class="line">        <span class="comment">// 3. 为每幅图片创建一个独立任务</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">final</span> ImageInfo imageInfo: info) &#123;</div><div class="line">            completionService.submit(<span class="keyword">new</span> Callable&lt;ImageData&gt;() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> ImageData <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> imageInfo.downloadImage();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 渲染文本</span></div><div class="line">        renderText(source);</div><div class="line">        <span class="comment">// 4. 获取Future，调用get</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, n=info.size(); t&lt;n; t++) &#123;</div><div class="line">                Future&lt;ImageData&gt; future = completionService.take();</div><div class="line">                ImageData imageData = future.get();</div><div class="line">                RenderImage(imageData);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            Thread.currentThread().interrupt();</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有时候，如果某个任务无法在指定时间内完成，那么将不再需要它的结果，此时可以放弃这个任务。在支持时间限制的Future.get中支持这种需求：当结果可用时，它将立即返回，如果在指定时限内没有计算出结果，那么将抛出TimeoutException。在使用限时任务时需要注意，当这些任务超时后应该立即停止，从而避免为继续计算一个不再使用的结果而浪费计算资源。Future如果一个限时的get方法抛出了TimeoutException，那么可以通过Future来取消任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">Page <span class="title">renderPageWithAd</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">long</span> endNanos = System.nanoTime() + TIME_BUDGET;</div><div class="line">    Future&lt;Ad&gt; future = exec.submit(<span class="keyword">new</span> FetchAdTask());</div><div class="line">    Page page = renderPageBody();</div><div class="line">    Ad ad;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">long</span> timeLeft = endNanos - System.nanoTime();</div><div class="line">        ad = f.get(timeLeft, NANOSECONDS); <span class="comment">// 设定时间</span></div><div class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">        ad = DEFAULT_AD;</div><div class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</div><div class="line">        ad = DEFAULT_AD;</div><div class="line">        f.cancel(<span class="keyword">true</span>); <span class="comment">//取消任务</span></div><div class="line">    &#125;</div><div class="line">    page.setAd(ad);</div><div class="line">    <span class="keyword">return</span> page;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Executor框架可以将任务提交与执行策略解耦开来，当需要创建线程来执行任务时，可以考虑使用Executor，同时考虑Callable和Future。要想将应用程序分解为不同的任务并发执行时，必须定义清晰的任务边界。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在大多数并发应用程序都是围绕“任务执行”来构造的：任务通常是一些抽象且离散的工作单元。通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发_4_基础构建模块</title>
    <link href="http://bestlixiang.site/2018/01/14/Java%E5%B9%B6%E5%8F%91-4-%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97/"/>
    <id>http://bestlixiang.site/2018/01/14/Java并发-4-基础构建模块/</id>
    <published>2018-01-14T11:30:08.000Z</published>
    <updated>2018-01-14T11:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：JDK提供的东西效率应该是可以保证的，所以我们要学会去使用JDK自带的并发基础构建模块，以及理解在使用这些模块来构建应用程序时的一些常用模式。<a id="more"></a></p>
<h1 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h1><p>同步容器类包括Vector和Hashtable。这些类实现线程安全的方式是：将他们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。</p>
<h2 id="同步容器类的问题"><a href="#同步容器类的问题" class="headerlink" title="同步容器类的问题"></a>同步容器类的问题</h2><p>先看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> list.get(lastIndex);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</div><div class="line">    list.remove(lastIndex);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这些方法看起来没有问题，但是如果线程A在执行deleteLast, 线程B在执行getLast，list中有10个元素，刚好B在执行list.size()和get(lastIndex)之间，线程A执行完了remove(lastIndex), 那么线程B在执行get(lastIndex)时就会抛出ArrayIndexOutOfBoundsException。</p>
<p>由于同步容器类要遵守同步策略，即客户端加锁，因此在创建一些新的操作时，只要我们知道应该使用哪一个锁，那么这些新操作就与容器的其他操作一样都是原子操作。如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(list) &#123;</div><div class="line">        <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> list.get(lastIndex);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(list) &#123;</div><div class="line">        <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</div><div class="line">       list.remove(lastIndex);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在调用size和相应的get之间，Vector的长度可能会发生变化，这种风险在对Vector中的元素进行迭代时仍然会出现，如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 可能抛出ArrayIndexOutOfBoundsException的迭代操作</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</div><div class="line">    doSomething(vetor.get(i));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以通过在客户端加锁来解决不可靠迭代的问题，但是要牺牲一些伸缩性。通过在迭代期间持有Vector的锁，可以防止其他线程在迭代期间修改Vector。如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">synchronized (vector) &#123;</div><div class="line">    for (int i = 0; i &lt; vector.size(); i++) &#123;</div><div class="line">        doSomething(vetor.get(i));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="迭代器与ConcurrentModificationException"><a href="#迭代器与ConcurrentModificationException" class="headerlink" title="迭代器与ConcurrentModificationException"></a>迭代器与ConcurrentModificationException</h2><p>对容器类进行迭代的标准方式是使用Iterator，然而，如果有其他线程并发地修改容器，那么即使是使用迭代器也无法避免地需要在同步容器上加锁。在设计同步容器类的迭代器时并没有考虑到并发修改的问题，它们的迭代器是“及时失败”的，所以当它们发现容器在迭代过程中发生变化，就会抛出一个ConcurrentModificationException异常。这种fail-fast机制并不是一种完备的处理机制，而只是“善意地”捕获并发错误，因此只能作为并发问题的预警指示器。它们采取的实现方式是将计数器变化与容器关联起来：如果在迭代期间计数器被修改，那么hasNext或next将抛出ConcurrentModificationException。然而，这种检查是在没有同步的情况下进行的，因此可能会看到失效的值，而迭代器可能并没有意识到已经发生了修改。要想避免出现ConcurrentModificationException，就必须在迭代过程中持有容器的锁。</p>
<p>然而，有时候开发人员并不希望在迭代器间对容器加锁。例如，某些线程在可以访问容器之前，必须等待迭代过程结束，如果容器规模很大，或者在每个元素上执行操作的时间很长，那么这些线程就需要长时间等待。持有锁的时间越长，那么在锁上的竞争就越激烈，如果许多线程都在等待锁被释放，那么将极大地降低吞吐量和CPU的利用率。</p>
<p>另一种替代方法是“克隆”容器，并在副本上进行迭代。由于副本被封闭在线程内，因此其他线程不会在迭代期间对其进行修改，这样就避免了抛出ConcurrentModificationException，不过在克隆过程中仍然要加锁（以防在此期间被克隆容器被其他线程修改，那样克隆出来的容器就是失效的容器），所以也会增加性能开销。所以这种方法的好坏取决于多个因素：容器的大小，在每个元素上执行的操作，迭代操作相对于容器上其他操作被调用的频率，以及在响应时间和吞吐量等方面的需求。</p>
<h2 id="隐藏迭代器"><a href="#隐藏迭代器" class="headerlink" title="隐藏迭代器"></a>隐藏迭代器</h2><p>虽然加锁可以防止迭代器抛出ConcurrentModificationException，但必须记住在所有对共享容器进行迭代的地方都需要加锁。实际情况更复杂，因为在某些情况下，迭代器会隐藏起来。</p>
<p>如下例，标准容器的toString方法将迭代容器，并在每个元素上调用toString来生成容器内容的格式化表示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenIterator</span> </span>&#123;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer i)</span> </span>&#123;</div><div class="line">        set.add(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Integer i)</span> </span>&#123;</div><div class="line">        set.remove(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTenThing</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random r = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            set.add(r.nextInt());</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"DEBUG: added ten elements to "</span> + set);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>addTenThings方法可能会抛出ConcurrentModificationException，因为toString对set进行了迭代，而且没加锁。如果状态与保护它的同步代码之间相隔越远，那开发人员就越容易忘记在访问状态时使用正确的同步。如果HiddenIterator用<br><strong>synchronizedSet</strong>来包装HashSet，并且对同步代码进行封装，那么就不会抛出异常了。容器的hashCode和equals等方法也会间接地执行迭代操作，同样，containsAll, removeAll和retainAll等方法，以及把容器作为参数的构造函数，都会对容器进行迭代，所有这些间接的迭代操作都可能抛出ConcurrentModificationException。</p>
<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><p>同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性，这样的代价就是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重降低。Java 5.0提供了多种并发容器类来改进同步容器的性能。通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。</p>
<p>Java 5.0增加了ConcurrentHashMap，用来替代基于hash的同步map，增加了CopyOnWriteArrayList，用来替代以遍历操作为主要操作的同步List。在新的ConcurrentMap接口中增加了一些常用的复合操作，例如“putIfAbsent”,replace, 和 conditional remove。</p>
<p>Java 5.0还增加了两个新的集合类型，Queue和BlockingQueue。</p>
<p>Java 6.0增加了ConcurrentSkipListMap来替换同步的SortedMap，增加了ConcurrentSkipListSet替换SortedSet（例如TreeMap和TreeSet）</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>与HashMap一样，ConcurrentHashMap也是一个基于HashCode的Map，但它使用了一种完全不同的加锁策略来提供更高的并发性和伸缩性。ConcurrentHashMap并不是将每个方法都在同一把锁上同步并使得每次只有一个线程访问容器，而是使用一个种粒度更细的加锁机制来时间共享，叫做<strong>分段锁</strong>。在这种机制下，任意数量的读取线程可以并发地访问这个map，执行读取操作的线程和执行写入操作的线程可以并发地访问map，并且一定数量的写入线程可以并发地修改Map。</p>
<p>而且ConcurrentHashMap提供的迭代器不会抛出ConcurrentModificationException，因此不需要再迭代过程中对容器加锁。它返回的迭代器具有弱一致性，而并非“及时失败”。弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以在迭代器被构造后将修改操作反映给容器。</p>
<p>与Hashtable和synchronized-Map相比，ConcurrentHashMap有着更多的优势以及更少的劣势。因此在大多数情况下，用ConcurrentHashMap来代替同步Map能进一步提高代码的可伸缩性，只有当应用程序需要给map加锁以进行独占访问时，才应该放弃使用ConcurrentHashMap。</p>
<h2 id="额外的原子Map操作"><a href="#额外的原子Map操作" class="headerlink" title="额外的原子Map操作"></a>额外的原子Map操作</h2><p>由于ConcurrentHashMap不能被加锁来执行独占访问，因此也无法使用客户端加锁来创建新的原子操作。但是一些常见的复合操作，如“如没有则添加（put-if-absent）”,”若相等则移除（remove-if-equals）”,”若相等则替换（replace-if-equals）”等，都已经在ConcurrentMap接口中有声明，所以如果需要为现有的同步Map添加这样的功能，就应该考虑使用ConcurrentMap了。</p>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>CopyOnWriteArrayList用于替代同步list，在某些情况下提供了更好的并发性能，并且在迭代器间不需要对容器进行加锁或复制。（类似地，CopyOnWriteArraySet的作用是替代同步set）</p>
<p>Copy-On-Write容器的线程安全性在于，只要正确地发布一个实际不可变的对象，那么在访问该对象时就不需要进一步的同步了。</p>
<p>Copy-On-Write从字面上看就是，Write的时候总是要Copy，所以在每次修改时，都会创建并重新发布一个新的容器副本。而CopyOnWriteArrayList容器的迭代器会保留一个指向原始数组的引用，遍历的也是原始数组，而其他线程修改的是这个原始数组的副本，所以也不会影响原始数组，原始数组不会改变，也就不会有ConcurrentModificationException了，并且返回的元素和迭代器创建时的元素完全一致。</p>
<p>显然，每当修改容器时都会复制原始数组，这需要一定开销，特别是当容器的规模较大时。仅当迭代器操作多于修改操作时，才应该使用“写入时复制”容器。</p>
<h1 id="阻塞队列和生产者-消费者模式"><a href="#阻塞队列和生产者-消费者模式" class="headerlink" title="阻塞队列和生产者-消费者模式"></a>阻塞队列和生产者-消费者模式</h1><p><strong>基于阻塞队列构建的生产者-消费者设计中</strong>：当数据生成时，生产者把数据放入队列，而当消费者准备处理数据时，将从队列中获取数据。阻塞队列简化了生产者-消费者设计的实现过程，它支持任意数量的生产者和消费者。</p>
<p>在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。</p>
<p>BlockingQueue有多种实现：LinkedBlockingQueue和ArrayBlockingQueue是FIFO队列，与LinkedList和ArrayList相似，但比同步list有更好的并发性能。PriorityBlockingQueue是一个按优先级排序的队列，当你希望按照某种顺序而不是FIFO来处理元素时，这个队列非常有用，PriorityBlockingQueue既可以根据元素的自然顺序来比较元素，也可以使用Comparator来比较。最后一个BlockingQueue是SynchronousQueue，它并不是一个真正的队列，因为它不会为队列中元素维护存储空间。它维护的是一组线程，这些线程在等待着把元素加入或移出队列。以洗盘子为例，相当于没有盘架，直接将洗好的盘子放入下一个空闲的烘干机中，它可以直接交付工作，从而降低了将数据从生产者移动到消费者的延迟。因为SynchronousQueue没有存储功能，因此put和take会一直阻塞，直到有另一个线程已经准备好参与到交付过程中。仅当有足够多的消费者，并且总有一个消费者准备好获取交付的工作时，才适合使用同步队列。</p>
<h2 id="串行线程封闭"><a href="#串行线程封闭" class="headerlink" title="串行线程封闭"></a>串行线程封闭</h2><p>对于可变对象，生产者-消费者这种设计与阻塞队列组合在一起使得把对象从生产者转移给消费者变得容易。线程封闭对象只能由单个线程拥有，但可以通过安全地发布该对象来转移所有权。在所有权转移后，就只有新线程能获得这个对象的访问权限，并且发布对象的线程不会再访问它。这种安全的发布确保了对象状态对于新的所有者来说是可见的，并且由于最初的所有者不会再访问它，所以这个对象又被封闭在新的线程中，新线程可以对该对象做任意修改，因为它具有独占的访问权。</p>
<p>对象池利用了串行线程封闭，将对象借给一个请求线程。只要对象池包含足够的内部同步来安全地发布池中的对象，并且只要客户代码本身不会发布池中的对象，或者在将对象返回给对象池后就不再使用它，那么就可以安全地在线程之间传递所有权。</p>
<h2 id="双端队列与工作密取"><a href="#双端队列与工作密取" class="headerlink" title="双端队列与工作密取"></a>双端队列与工作密取</h2><p>Java 6增加了两种容器类型，Deque&amp;BlockingQueue。Deque是一个双端队列，实现了在队列头和队列尾的高效插入和移除。</p>
<p>双端队列适用于另一种相关模式，即工作密取（Work Stealing）。（不懂）</p>
<h1 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h1><p>同步器可以是任何一个对象，只要它根据其自身的状态来协调线程的控制流就可以叫同步器。阻塞队列可以作为同步器，其他类型的同步器还包括信号量(Semaphore)/栅栏（Barrier）以及闭锁（Latch）。</p>
<p>所有的同步器都包含一些特定的结构化属性：它们封装了一些状态，这些状态将决定使用同步器的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用于高效地等待同步器进入到预期状态。</p>
<h2 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h2><p>闭锁时一种同步器，可以延迟线程的进度直到线程到达终止状态。闭锁的作用相当于一扇门：在闭锁到达terminal状态前，这扇门一直是关闭的，没有任何线程通过，而当到达terminal状态时，这扇门就会打开允许所有线程通过。当闭锁达到terminal状态，它的状态就不会再改变，因此这扇门会永远打开。闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。例如：</p>
<ul>
<li>确保某个计算在其需要的所有资源都初始化之后才继续执行</li>
<li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动</li>
<li>等待某个操作的所有参与者都就绪再继续执行</li>
</ul>
<p>CountDownLatch是一种灵活的闭锁，可以在上述各种情况中使用，它可以使一个或多个线程等待一组事件发生。countDown方法递减计数器，表示有一个事件已经发生了，而await方法等待计数器达到零，这表示所有需要等待的事件都已经发生。如果计数器的值非零，那么await会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。例如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHarness</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTasks</span><span class="params">(<span class="keyword">int</span> nThreads, <span class="keyword">final</span> Runnable task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThreads);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;</div><div class="line">            Thread t = <span class="keyword">new</span> Thread() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        startGate.await();</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            task.run();</div><div class="line">                        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                            endGate.countDown();</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            t.start();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        startGate.countDown();</div><div class="line">        endGate.await();</div><div class="line">        <span class="keyword">long</span> end = System.nanoTime();</div><div class="line">        <span class="keyword">return</span> end-start;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Runnable task = <span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"ing"</span>);</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">long</span> interval = <span class="keyword">new</span> TestHarness().timeTasks(<span class="number">3</span>, task);</div><div class="line">            System.out.println(interval);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动门将使得主线程能够同时释放所有工作线程，而结束门则使主线程能够等待最后一个线程执行完成。</p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>FutureTask也可以用作闭锁，它可以处于下面3种状态：等待运行、正在运行和运行完成。Future.get的行为取决于任务的状态，如果任务已经完成，那么get会立即返回结果，否则get将阻塞直到任务进行完成状态。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。</p>
<p>Semaphore管理着一组虚拟的permits，许可的初始数量通过构造函数指定。在执行操作前先acquire permits（只要有剩余的许可就可以），在使用完后会release这个许可。如果没有获得permit，acquire方法将一直阻塞到有许可或指导被中断或超时。release方法将返回一个permit给信号量。</p>
<p>Semaphore也可以将任何一种容器变成有界阻塞容器。信号量的计数值会初始化为容器容量的最大值，add操作在向容器添加一个元素之前，首先获取一个permit，然后再添加，如果添加失败，那么会释放许可，如果成功就不释放了。同样，remove操作会释放一个许可，来使更多的元素能够添加到容器中。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedHashSet</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; set;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedHashSet</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;T&gt;());</div><div class="line">        sem = <span class="keyword">new</span> Semaphore(bound);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        sem.acquire();</div><div class="line">        <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            wasAdded = set.add(o);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (!wasAdded) &#123;</div><div class="line">                sem.release();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> wasAdded;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> wasRemoved = set.remove(o);</div><div class="line">        <span class="keyword">if</span> (wasRemoved) &#123;</div><div class="line">            sem.release();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> wasRemoved;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h2><p>闭锁可以启动一组相关的操作，或者等待一组相关的操作结束。闭锁时一次性对象，一旦进入终止状态，就不能被重置。</p>
<p>栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于<strong>等待事件发生</strong>，而栅栏用于<strong>等待其他线程</strong>。</p>
<h1 id="构建高效且可伸缩的结果缓存"><a href="#构建高效且可伸缩的结果缓存" class="headerlink" title="构建高效且可伸缩的结果缓存"></a>构建高效且可伸缩的结果缓存</h1><p>下面的几个代码段将逐步构架一个高效且可伸缩的缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Memoizer1存在一个可伸缩的问题，每次只有一个线程能够执行compute。</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computable</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function">V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpensiveFunction</span> <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">String</span>, <span class="title">BigInteger</span>&gt;</span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> BigInteger <span class="title">compute</span><span class="params">(String arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">//在经过长时间的计算后</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(arg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer1</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> HashMap&lt;A, V&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer1</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.c = c;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        V result = cache.get(arg);</div><div class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">            result =  c.compute(arg);</div><div class="line">            cache.put(arg, result);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 会存在重复计算的问题</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer2</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;A, V&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer2</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.c = c;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        V result = cache.get(arg);</div><div class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">            result =  c.compute(arg);</div><div class="line">            cache.put(arg, result);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*利用FutureTask来减少重复计算的问题,但是由于if判断中依然存在非原子的“先检查再执行”的操作，</span></div><div class="line">所以还是会存在重复计算的问题*/             </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer3</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer3</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.c = c;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(<span class="keyword">final</span> A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        Future&lt;V&gt; f = cache.get(arg);</div><div class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</div><div class="line">            Callable&lt;V&gt; eval = <span class="keyword">new</span> Callable&lt;V&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">                    <span class="keyword">return</span> c.compute(arg);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;V&gt;(eval);</div><div class="line">            f = ft;</div><div class="line">            cache.put(arg,ft);</div><div class="line">            ft.run();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> f.get();</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 强制将未检查的Throwable转化为RuntimeException</div><div class="line">     * <span class="doctag">@param</span> t</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RuntimeException <span class="title">launderThrowable</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</div><div class="line">            <span class="keyword">return</span> (RuntimeException) t;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Error) &#123;</div><div class="line">            <span class="keyword">throw</span> (Error) t;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Not unchecked"</span>,t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// **最终版**</span></div><div class="line"><span class="comment">// 利用复合操作“若没有则添加”可以解决Memoizer3的问题</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer4</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer4</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.c = c;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(<span class="keyword">final</span> A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Future&lt;V&gt; f = cache.get(arg);</div><div class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</div><div class="line">                Callable&lt;V&gt; eval = <span class="keyword">new</span> Callable&lt;V&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">                        <span class="keyword">return</span> c.compute(arg);</div><div class="line">                    &#125;</div><div class="line">                &#125;;</div><div class="line">                FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;V&gt;(eval);</div><div class="line">                f = ft;</div><div class="line">                cache.putIfAbsent(arg, ft);</div><div class="line">                ft.run();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">return</span> f.get();</div><div class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                cache.remove(arg, f); <span class="comment">//为了解决缓存污染问题，当计算被取消或者失败时，就从缓存中remove</span></div><div class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                <span class="keyword">throw</span> launderThrowable(e.getCause());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>构建一个高效且具有伸缩性的基础模块还是有点难度的，我们要考虑的东西比较多，我们要利用已有的基础模块合理构建。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
<li><a href="http://www.cnblogs.com/IvySue/p/6862496.html" target="_blank" rel="external">《Java并发编程实践》（四）—- 构建阻塞</a></li>
<li><a href="http://www.cnblogs.com/xrq730/p/5020760.html" target="_blank" rel="external">图解集合3：CopyOnWriteArrayList</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：JDK提供的东西效率应该是可以保证的，所以我们要学会去使用JDK自带的并发基础构建模块，以及理解在使用这些模块来构建应用程序时的一些常用模式。
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发_3_对象的组合</title>
    <link href="http://bestlixiang.site/2018/01/13/Java%E5%B9%B6%E5%8F%91-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88/"/>
    <id>http://bestlixiang.site/2018/01/13/Java并发-3-对象的组合/</id>
    <published>2018-01-13T14:40:01.000Z</published>
    <updated>2018-01-13T14:40:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：我们不希望每一次访问内存都进行分析以确保程序是线程安全的，而是希望将一些现有的线程安全组件组合为更大规模的组件或程序。<a id="more"></a></p>
<h1 id="设计线程安全的类"><a href="#设计线程安全的类" class="headerlink" title="设计线程安全的类"></a>设计线程安全的类</h1><p> 在设计线程安全类的过程中，需要包含以下三个基本要素：</p>
<ul>
<li>找出构成对象状态的所有变量</li>
<li>找出约束状态变量的不变性条件</li>
<li>建立对象的并发访问管理策略</li>
</ul>
<p>同步策略规定了如何将不变性、线程封闭、加锁机制等结合起来以维护线程的安全性，并且规定了哪些变量由哪些锁来保护。要确保开发人员可以对这个类进行分析与维护，就必须将同步策略写成正式文档。</p>
<h2 id="收集同步需求"><a href="#收集同步需求" class="headerlink" title="收集同步需求"></a>收集同步需求</h2><p>要确保类的线程安全性，就需要确保它的不变性条件不会再并发访问时被破坏，这就需要对其状态进行推断。在许多类中都定义了一些不可变条件，用于判断状态是有效的还是无效的。同样，在操作中还包含一些后验条件来判断状态转换是否有效。当下一个状态需要依赖当前状态时，这个操作就必须是一个复合操作。如果不了解对象的不变性与后验条件，那么就不能确保线程安全性，要满足状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。</p>
<h2 id="依赖状态的操作"><a href="#依赖状态的操作" class="headerlink" title="依赖状态的操作"></a>依赖状态的操作</h2><p>类的不变性条件和后验条件限制了对象的有效状态已经状态转换的有效性。有些对象包含一些基于状态的先验条件，例如，不能从空队列中移除一个元素。如果在操作中包含基于状态的先验条件，那么这个操作就叫做依赖状态操作。</p>
<p>在并发程序中要一直等到先验条件为真然后再进行操作，可以使用现有库的类（阻塞队列<br>[Blocking Queue]或信号量[Semaphore]）来实现依赖状态的行为。</p>
<h2 id="状态的所有权"><a href="#状态的所有权" class="headerlink" title="状态的所有权"></a>状态的所有权</h2><p>多数情况下，所有权与封装性是相互关联的：对象封装它拥有的状态，也对它封装的状态拥有所有权。状态变量的所有者将决定采用何种加锁协议来维持变量状态的完整性。所有权意味着控制权。如果发布了某个可变对象的引用，那么原来的所有者就不再独占控制权了，就变成共享控制权了。</p>
<h1 id="实例封闭"><a href="#实例封闭" class="headerlink" title="实例封闭"></a>实例封闭</h1><p>封装简化了线程安全类的实现过程，它提供了一种<strong>实例封装机制</strong>，也简称为<strong>封闭</strong>。将数据封装在对象内部，就可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。</p>
<p>可以看下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ThreadSafe</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonSet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Person&gt; mySet = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(Person p)</span> </span>&#123;</div><div class="line">        mySet.add(p);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsPerson</span><span class="params">(Person p)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mySet.contains(p);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>PersonSet类说明了如何通过将mySet封闭在一个类属性中以及使用加锁机制使一个类成为线程安全的。PersonSet的状态由HashSet来管理，而HashSet不是线程安全的，但由于mySet是私有的并且不会逸出，因此HashSet被封闭在PersonSet中。唯一能访问mySet的代码路径是addPerson和containsPerson两个方法，在执行它们时都要获得PersonSet的内置锁，所以PersonSet的状态完全由它的内置锁保护，因而PersonSet是一个线程安全的类。</p>
<p>线程封闭的作用可以将非线程安全的类转化为线程安全的类。可以利用到<strong>装饰器模式</strong>。封闭机制更易于构造线程安全的类，因为在分析线程安全性时可以只分析该类而不用检查整个程序。</p>
<h2 id="Java监视器模式"><a href="#Java监视器模式" class="headerlink" title="Java监视器模式"></a>Java监视器模式</h2><p>Java的内置锁也称为监视器锁或监视器。所以使用内置锁来保证线程安全性的模式就叫做Java监视器模式。遵循Java监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。Java监视器模式仅仅是一种编写代码的乐队，对于任何一种锁对象，只要自始至终都使用该锁对象，都可以用来保护对象的状态。（不知道是不是只要读和写方法只要都保持同步就好了？）</p>
<h1 id="线程安全的委托（需要好好理解的，日后加深）"><a href="#线程安全的委托（需要好好理解的，日后加深）" class="headerlink" title="线程安全的委托（需要好好理解的，日后加深）"></a>线程安全的委托（需要好好理解的，日后加深）</h1><p>在某些情况下，通过多个线程类组合而成的类是线程安全的，而在某些情况下，这仅仅是一个好的开端，但却是线程不安全的（由于没有维持不变性约束）。</p>
<p>如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给这些状态变量。</p>
<p>如果一个状态变量是线程安全的，也不参与<strong>任何不变性条件</strong>，也没有操作上的状态变换，那这个变量就可以发布出去。</p>
<h1 id="在现有的线程安全类中添加功能"><a href="#在现有的线程安全类中添加功能" class="headerlink" title="在现有的线程安全类中添加功能"></a>在现有的线程安全类中添加功能</h1><p>Java类库包中包含许多有用的“基础模块”类，通常，我们应该优先选择重用这些现有的类而不是创建新的类：重用能降低开发工作量、开发风险（因为现有的类都已经通过测试）以及维护成本。我们需要在不破坏线程安全性的情况下添加一个新的操作。</p>
<p>要添加一个新的原子操作，最安全的方法是修改原始类，但这通常无法做到，因为可能无法访问或修改类的源代码。如果直接将新方法添加到类中，那么意味着实现同步策略的所有代码仍然处于一个源文件中，从而更容易维护。另一种方法是用子类扩展这个类，但这样的话同步策略的实现就分布在了多个需要单独维护的源文件中，如果父类修改了同步策略选择不同的锁来保护它的状态变量，那子类也需要跟着变。如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 扩展Vector并增加一个“若没有则添加”方法</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BetterVector</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> absent = !contains(x);</div><div class="line">        <span class="keyword">if</span> (absent) &#123;</div><div class="line">            add(x);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> absent</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="客户端加锁机制"><a href="#客户端加锁机制" class="headerlink" title="客户端加锁机制"></a>客户端加锁机制</h2><p>第三种策略是扩展类的功能，但并不是扩展类本身，而是将扩展方法放在一个辅助类（Helper class）中。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListHelper</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> absent = !list.contains(x);</div><div class="line">        <span class="keyword">if</span>(absent) &#123;</div><div class="line">            list.add(x);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> absent;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>putIfAbsent用的是ListHelper的内置锁，但list用的肯定不是ListHelper的锁，尽管所有的list操作都被声明为synchronized，但却是不一样的锁，这就无法确保当putIfAbsent执行时另一个线程不会修改这个list。</p>
<p>要想使这个方法正确执行，必须使list在实现客户端加锁或外部加锁时使用同一个锁。<strong>客户端加锁</strong>是指，对于使用某个对象X的客户端代码，使用X本身用于保护其状态的锁来保护这段客户端代码。要使用客户端加锁，就必须知道对象X使用的是哪一个锁。在Vector和同步封装器类的文档中指出，它们通过使用Vector或封装器容器的内置锁来支持客户端加锁。所以修改后的putIfAbsent如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListHelper</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(list) &#123;</div><div class="line">            <span class="keyword">boolean</span> absent = !list.contains(x);</div><div class="line">            <span class="keyword">if</span>(absent) &#123;</div><div class="line">                list.add(x);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> absent;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>更好地为现有类添加原子操作的方法是：<strong>组合</strong>。示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImprovedList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> list&lt;T&gt; list;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImprovedList</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(T x)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> contains = list.contains(x);</div><div class="line">        <span class="keyword">if</span>(!contains) &#123;</div><div class="line">            list.add(x);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> !contains;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">       list.clear();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ImprovedList通过自身的内置锁增加了一层额外的加锁。它并不关心List是否是线程安全的，即使List不是线程安全的或者修改了它的加锁实现，ImprovedList也会提供一致的加锁机制来实现线程安全性。事实上，我们使用了Java监视器模式来封装现有的List，并且只要在类中拥有指向底层List的唯一外部引用，就能确保线程安全性。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>设计一个线程安全的类方法有很多种，这里提到了三点：实例封闭、线程委托、复用现有基础类。但是具体实现线程安全都不一样，需要按实际情况来确定。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：我们不希望每一次访问内存都进行分析以确保程序是线程安全的，而是希望将一些现有的线程安全组件组合为更大规模的组件或程序。
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发_2_对象的共享</title>
    <link href="http://bestlixiang.site/2018/01/13/Java%E5%B9%B6%E5%8F%91-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB/"/>
    <id>http://bestlixiang.site/2018/01/13/Java并发-2-对象的共享/</id>
    <published>2018-01-13T09:58:17.000Z</published>
    <updated>2018-01-13T09:58:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：为了能够安全地由多个线程同时访问某个对象，我们就需要学会在共享和发布对象时，构建一个线程安全类或者通过java.util.concurrent类库来构建。<a id="more"></a></p>
<h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p>在读操作和写操作在不同线程执行时，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，所谓“不可见”。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p>
<p>先看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoVisibility</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span>(!ready) &#123;</div><div class="line">                Thread.yield();</div><div class="line">            &#125;</div><div class="line">            System.out.println(number);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> ReaderThread().start();</div><div class="line">        number = <span class="number">42</span>;</div><div class="line">        ready = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码不能保证输出42，可能输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入的number的值，这种现象称为“重排序”，它的意思是代码的顺序可能因为优化而发生重排序。</p>
<h2 id="失效数据"><a href="#失效数据" class="headerlink" title="失效数据"></a>失效数据</h2><p>失效数据：当读线程查看一个变量是，可能会得到一个已经失效的值。除非在每次访问变量时都使用同步，否则很可能获得该变量的一个失效值。更糟糕的是，失效值可能不会同时出现：一个线程可能得到某个变量的最新值，而获得另一个变量的失效值。</p>
<p>下面的代码不是线程安全的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NonThreadSafe</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableInteger</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>get和set都是在没有同步的情况下访问value，所以失效值问题很容易出现：如果某个线程在调用了get，那么另一个正在调用get的线程可能会看到更新后的value值，也可能看不到。要使MutableInteger成为一个线程安全的类，必须对set和get都进行同步。</p>
<h2 id="非原子的64位操作"><a href="#非原子的64位操作" class="headerlink" title="非原子的64位操作"></a>非原子的64位操作</h2><p>最低安全性（out-of-thin-air-safety）:当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。</p>
<p>例外：对于非volatile类型的long和double变量，JVM允许64位的读操作和写操作分解为两个32位的操作。那么很有可能会读到某个值的高32位和另一个值的低32位。所以在多线程程序中使用共享且可变的long和double等类型的变量是不安全的，除非使用关键字volatile来声明他们，或者用锁保护起来。</p>
<h2 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h2><p>volatile变量可以确保将变量的更新操作通知到其他线程。并且会禁止重排序，因此在读取volatile类型的变量时总会返回最新写入的值。volatile通常用作某个操作完成。发生中断或者状态的标志。它只能保证可见性，但是不能保证原子性。</p>
<p>当且仅当满足所有条件时，才应该使用volatile变量：</p>
<ol>
<li>对变量的写入操作不依赖变量的当前值（比读到的还要新的值），或者你能保证只有当个线程更新变量的值。</li>
<li>该变量不会与其他状态变量一起纳入不变性条件中。</li>
<li>在访问变量时不需要加锁。</li>
</ol>
<h1 id="发布和逸出"><a href="#发布和逸出" class="headerlink" title="发布和逸出"></a>发布和逸出</h1><p><strong>“发布（Publish）”对象</strong>：使对象能够在当前作用域之外的代码中使用。例如：将一个指向该对象的引用保存到其他代码可以访问的地方（公有的静态变量中）</p>
<p><strong>“逸出（Escape）”</strong>：当某个不应该发布的对象被发布。例如：在对象构造完成之前就发布对象</p>
<p>发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象，如下面代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Secret&gt; knownSecrets;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">    knownSecrets = <span class="keyword">new</span> HashSet&lt;Secret&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当发布某个对象时，可能会间接地发布其他对象。如果将一个Secret对象添加到集合knownSecrets中，那么同样会发布这个对象，因为任何代码都可以遍历这个集合，并获得对这个新Secret对象的引用。同样，如果从非私有方法中返回一个引用，那么同样会发布返回的对象。如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeStates</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String[] states = <span class="keyword">new</span> String[] &#123;<span class="string">"AK"</span>,<span class="string">"AL"</span>...&#125;;</div><div class="line">    <span class="keyword">public</span> String[] getStates() &#123;</div><div class="line">        <span class="keyword">return</span> states;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另一种将一个对象或者它内部的状态publish出去的方式就是publish这个对象所在类的内部类，如下例子,但是会将this对象的引用escape出去。因为当ThisEscape将EventListener　publish出去，它就显示地将外部类ThisEscape实例对象也公布出去了，因为内部类实例保存了外部类实例的隐藏引用。所以会把this　escape出去。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span> </span>&#123;</div><div class="line">        source.registerListener(  </div><div class="line">                <span class="keyword">new</span> EventListener() &#123;</div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event o)</span> </span>&#123;</div><div class="line">                        doSomething(o);<span class="comment">// 由于这个线程是异步的，所有EventSource可能还没有构造完</span></div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当内部EventListener实例发布时，在外部封装的ThisEscape实例也逸出了，当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态。一个常见的使this引用在构造过程中逸出的错误是在构造函数中启动一个线程。如果想在构造函数中注册一个事件监听器或启动线程，可以使用一个私有的构造函数和一个公共的工厂方法，从而避免不正确的构造过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeListener</span><span class="params">()</span> </span>&#123;</div><div class="line">        listener = <span class="keyword">new</span> EventListener() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event o)</span> </span>&#123;</div><div class="line">                doSomething(o);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title">newInstance</span><span class="params">(EventSource source)</span> </span>&#123;</div><div class="line">        SafeListener safeListener = <span class="keyword">new</span> SafeListener();</div><div class="line">        source.registerListener(safeListener);</div><div class="line">        <span class="keyword">return</span> safeListener;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h1><p>当访问共享的可变数据时，通常需要同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭。</p>
<p>线程封闭的一个常见应用是从池中拿JDBC Connection。在典型的服务器应用中，一个线程从池中获取connection对象，用它来处理一个单独的请求，处理完后归还该connection，又放入池中。Connection池是不会把相同的connection对象分配给不同的线程的，这种模式就显式地将那个connection封闭在一个线程中。</p>
<p>局部变量和ThreadLocal类就是用来维护线程封闭特性的，但即便有这些现成的特性，程序员仍有义务去保证封闭在线程中的对象不会从线程中逸出</p>
<h2 id="Ad-hoc线程封闭"><a href="#Ad-hoc线程封闭" class="headerlink" title="Ad-hoc线程封闭"></a>Ad-hoc线程封闭</h2><p>这种线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。这种技术很脆弱，因此程序中尽量少用它。</p>
<h2 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h2><p>栈封闭式线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问这个栈。栈封闭比Ad-hoc线程封闭更易于维护，也更加健壮。可以看看下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadTheArk</span><span class="params">(Collections&lt;Animal&gt; candidates)</span> </span>&#123;</div><div class="line">        SortedSet&lt;Animal&gt; animals;</div><div class="line">        <span class="keyword">int</span> numPairs = <span class="number">0</span>;</div><div class="line">        Animals candidate = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        animals = <span class="keyword">new</span> TreeSet&lt;Animal&gt;(<span class="keyword">new</span> SpeciesGenderComparator());</div><div class="line">        animals.addAll(candidates);</div><div class="line">        <span class="keyword">for</span>(animals a : animals) &#123;</div><div class="line">            <span class="keyword">if</span> (candidate == <span class="keyword">null</span> || !candidate.isPotentialMate(a)) &#123;</div><div class="line">                candidate = a;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ark.load(<span class="keyword">new</span> AnimalPair(candidate, a));</div><div class="line">                ++numPairs;</div><div class="line">                candidate = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> numPairs;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中的numPairs不会破坏线程封闭性，因为任何方法都无法获得对基本类型的引用，所以基本类型的局部变量始终封闭在线程内。但是对于对象引用的线程封闭，就需要一些额外的工作确保对象引用不会逸出。在上例中实例化了一个TreeSet,并用animals引用指向它，因为只有一个引用指向这个Set，而且这个引用是局部变量，所以这个对象引用也被封闭在线程中。但是如果把这个animals公布（publish）出去，线程封闭性就会破化。</p>
<h2 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h2><p>维护线程封闭性的一种更规范的方式是使用ThreadLocal. ThreadLocal提供了get和set方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。</p>
<p>例如，在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都要传递一个Connection对象。由于JDBC的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将JDBC的连接保存到ThreadLocal对象中，每个线程都会拥有属于自己的连接，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="keyword">new</span> ThreadLocal&lt;&gt;()&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> connectionHolder.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 当某个线程初次调用ThreadLocal.get方法时，会调用initialValue()方法来获取初始值。从概念上讲，可以将ThreadLocal<t>视为包含了Map<thread, t="">对象，其中保存了只属于该线程的值。当线程终止后，这些值就会作为垃圾被回收掉。</thread,></t></p>
<h1 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h1><p>如果某个对象在创建之后状态就不能被修改，那这个对象就被称为<strong>不可变对象</strong>。不可变对象一定是线程安全的。不可变对象只有一种状态，而且这种状态由构造函数来控制。</p>
<p>当满足一下条件的时候，对象才是不可变的：</p>
<ul>
<li>对象创建以后其状态就不能修改</li>
<li>对象的所有域都是final类型</li>
<li>对象是正确创建的（在对象的创建过程中，this引用没有逸出）</li>
</ul>
<p>不可变对象仍然可以在内部使用可变对象来管理它们的状态。如下例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Immutable</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeStooges</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; stooges = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeStooges</span><span class="params">()</span> </span>&#123;</div><div class="line">        stooges.add(<span class="string">"Moe"</span>);</div><div class="line">        stooges.add(<span class="string">"Larry"</span>);</div><div class="line">        stooges.add(<span class="string">"Curly"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStooge</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> stooges.contains(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Final域"><a href="#Final域" class="headerlink" title="Final域"></a>Final域</h2><p>正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”一样，“除非需要某个域是可变的，否则应将其声明为final域”也是一个良好的编程习惯。</p>
<h2 id="使用Volatile类型来发布不可变对象"><a href="#使用Volatile类型来发布不可变对象" class="headerlink" title="使用Volatile类型来发布不可变对象"></a>使用Volatile类型来发布不可变对象</h2><p>为了保证操作的原子性，可以将多个状态转化为包含多个状态的不可变对象，然后使用volatile来保持可见性，从而保证了线程安全。如下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache = <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</div><div class="line">        BigInteger i = extractFromRequest(req);</div><div class="line">        BigInteger[] factors = cache.getFactors(i);</div><div class="line">        <span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</div><div class="line">            factors = factor(i);</div><div class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</div><div class="line">        &#125;</div><div class="line">        encodeIntoResponse(resp, factors);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactos;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i, BigInteger[] factors)</span> </span>&#123;</div><div class="line">        lastNumber = i;</div><div class="line">        lastFactos = Arrays.copyOf(factors, factors.length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</div><div class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> Arrays.copyOf(lastFactos, lastFactos.length);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h1><p>在某些情况下我们希望在多个线程间共享对象，此时必须确保安全地进行共享。</p>
<h2 id="不正确的发布：可见性出现问题"><a href="#不正确的发布：可见性出现问题" class="headerlink" title="不正确的发布：可见性出现问题"></a>不正确的发布：可见性出现问题</h2><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Holder hoder;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">    holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.n = n;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertSanity</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(n != n) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"This statement is false"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为除了发布对象的线程外，其他线程可以看到的Holder域可能是一个失效值。</p>
<h2 id="不可变对象与初始化安全性"><a href="#不可变对象与初始化安全性" class="headerlink" title="不可变对象与初始化安全性"></a>不可变对象与初始化安全性</h2><p>任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。</p>
<h2 id="安全发布的常用模式"><a href="#安全发布的常用模式" class="headerlink" title="安全发布的常用模式"></a>安全发布的常用模式</h2><p>要安全地发布一个对象，那它的引用和状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式安全地发布：</p>
<ul>
<li>在静态初始化函数中初始化对象的引用</li>
<li>把对象的引用保存在volatile类型的域或者AtomicReference对象中</li>
<li>将对象的引用保存到某个正确构造的final对象的域中</li>
<li>将对象的引用保存到一个由锁保护的域中</li>
</ul>
<p>使用静态初始化函数通常是最简单最安全的发布方式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Holder holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</div></pre></td></tr></table></figure></p>
<p>静态初始化器由JVM在类的初始化阶段执行，由于JVM内部存在在同步机制，因此通过这种方式初始化的任何对象都哦可以被安全发布。</p>
<h2 id="事实不可变对象"><a href="#事实不可变对象" class="headerlink" title="事实不可变对象"></a>事实不可变对象</h2><p>如果对象在技术上来看是可变的，但其状态在发布之后不会再改变，那么这种对象成为“实际不可变对象”，在这些对象发布之后，程序之需要将它们视为不可变对象即可。所以如果确认某些对象是实际不可变对象，就可以简化开发减少同步从而提升性能。</p>
<h2 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h2><p>如果对象在构造后可以被修改，那么安全发布只能确保这个对象在发布当时状态的可见性，为了保证线程安全，就需要在每次对象访问时也使用同步来确保后续修改操作的可见性。对象的发布方式取决于它的可变性：</p>
<ul>
<li>不可变对象可以通过任何机制来发布；</li>
<li>事实不可变对象必须通过安全方式来发布</li>
<li>可变对象必须通过安全方式来发布，并且必须是线程安全的或由某个锁保护起</li>
</ul>
<h2 id="安全的共享对象"><a href="#安全的共享对象" class="headerlink" title="安全的共享对象"></a>安全的共享对象</h2><p>在并发程序中使用共享对象是，可以使用一些实用的策略：</p>
<ul>
<li>线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。</li>
<li>只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和实际不可变对象。</li>
<li>线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。</li>
<li>保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于对象需要共享，所以要注意发布的安全性，以及对不可以变对象的合理应用。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
<li><a href="https://www.2cto.com/kf/201405/298701.html" target="_blank" rel="external">java并发编程实践学习（四）对象的发布和逸出之this逃逸</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：为了能够安全地由多个线程同时访问某个对象，我们就需要学会在共享和发布对象时，构建一个线程安全类或者通过java.util.concurrent类库来构建。
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发_1_线程安全性</title>
    <link href="http://bestlixiang.site/2018/01/12/Java%E5%B9%B6%E5%8F%91-1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>http://bestlixiang.site/2018/01/12/Java并发-1-线程安全性/</id>
    <published>2018-01-12T05:58:09.000Z</published>
    <updated>2018-01-12T06:00:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对“共享的(Shared)”和“可变的(Mutable)”状态的访问。而对象的状态是指存储在状态变量（类变量和成员变量）中的数据。“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期可以发生变化。<a id="more"></a></p>
<h1 id="什么是线程的安全性"><a href="#什么是线程的安全性" class="headerlink" title="什么是线程的安全性"></a>什么是线程的安全性</h1><p>线程安全性简单点说就是<strong>所见即所知</strong>，这是对正确性的认识。在书中还有一个比较长的定义：</p>
<pre><code>当多个线程访问某个类时，不管运行时环境采用何种调度方法或者这些线程将如何交替执行，
并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确地行为，
那么这个类是线程安全的。
</code></pre><p>自己再开始也简单介绍了对象的状态，这里需要明确一点：</p>
<pre><code>无状态的对象一定是线程安全的。
</code></pre><h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><ol>
<li>原子操作：不可再分割为几个操作的操作</li>
<li>竞态条件：由于不恰当的执行时序而出现不正确的结果（不是原子操作引起的）</li>
<li>竞态条件的类型：<ul>
<li>先检查后执行，例如延迟初始化</li>
<li>读取-修改-写入，例如统计命中数操作</li>
</ul>
</li>
<li>复合操作：将几个操作变为一个原子操作，在java.util.concurrent.atomic包中包含了一些原子变量类，用于实现在数值和对象引用上的原子状态转换。</li>
<li>在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。</li>
</ol>
<h1 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h1><p>要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。</p>
<h2 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h2><p>Java提供了一种内置的锁机制来支持原子性：同步代码块。同步代码块包括两部分：一个“作为锁”的对象引用，一个“作为由这个锁保护”的代码块。这个锁称为内置锁或监视器锁。线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁。Java的内置锁相当于一种互斥体，最多只有一个线程能够持有这种锁。由于每次只能有一个线程执行内置锁保护的代码块，因此，有这个锁保护的同步代码块会以原子方式执行。</p>
<h2 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h2><p>内置锁是可重入的，如果某个线程试图获得一个已经有它自己持有的锁，这个请求将会成功，“重入”意味着获取锁的操作的粒度是“线程”。</p>
<p>重入的一种是实现方法是：为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减，当计数值为0时，这个锁将被释放。</p>
<h2 id="用锁来保护状态"><a href="#用锁来保护状态" class="headerlink" title="用锁来保护状态"></a>用锁来保护状态</h2><ol>
<li>只把复合操作包装在synchronized块中并不够，如果对一个变量的访问需要使用同步，那所有访问该变量的地方都要加上同步。而且在使用锁来实现对变量的同步时，所有访问该变量的地方都要使用同一把锁。</li>
<li>获取一个对象关联的锁并不能阻止其他线程访问该对象，只有所有线程都获取的是相同的锁才能确保该对象被串行访问。所以每个共享的可变变量要被同一把锁保护。并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。</li>
<li>一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码进行同步，使得在该对象上不会发生并发访问。</li>
</ol>
<h1 id="活跃性与性能"><a href="#活跃性与性能" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h1><p>这里展示两个代码：</p>
<p>利用同步方法实现锁的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.math.BigInteger;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="keyword">this</span>) <span class="keyword">private</span> BigInteger lastNumber;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="keyword">this</span>) <span class="keyword">private</span> BigInteger[] lastFactors;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</div><div class="line">        BigInteger i = extractFromRequest(req);</div><div class="line">        <span class="keyword">if</span>(i.equals(lastNumber)) &#123;</div><div class="line">            encodeIntoResponse(resp, lastFactors);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            BigInteger[] factors = factor(i);</div><div class="line">            lastNumber = i;</div><div class="line">            lastFactors = factors.clone();</div><div class="line">            encodeIntoResponse(resp, factors);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过缩小同步代码块的作用范围实现锁的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.math.BigInteger;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.IF_ACMPEQ;</div><div class="line"></div><div class="line"><span class="meta">@ThreadSafe</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span></span>&#123;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="keyword">this</span>) <span class="keyword">private</span> BigInteger lastNumber;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="keyword">this</span>) <span class="keyword">private</span> BigInteger[] lastFactors;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="keyword">this</span>) <span class="keyword">private</span> <span class="keyword">long</span> hits;</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="keyword">this</span>) <span class="keyword">private</span> <span class="keyword">long</span> cacheHits;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getHits</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> hits;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">double</span> <span class="title">getCachedHits</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)cacheHits /(<span class="keyword">double</span>) hits;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</div><div class="line">        BigInteger i = extractFromRequest(req);</div><div class="line">        BigInteger[] factors = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            ++hits;</div><div class="line">            <span class="keyword">if</span>(i.equals(lastNumber)) &#123;</div><div class="line">                ++cacheHits;</div><div class="line">                factors = lastFactors.clone();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(factors == <span class="keyword">null</span>) &#123;</div><div class="line">            factors = factor(i); <span class="comment">//花费时间长的代码不要持有锁，相当于两个同步代码块的界限</span></div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                lastNumber = i;</div><div class="line">                lastFactors = factors.clone();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        encodeIntoResponse(resp, factors);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要判断同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性（这个需求必须要满足）、简单性和性能。我们需要权衡。</p>
<pre><code>tip：当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>安全性需要保证，活跃性和性能也要在权衡之中。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Java并发编程实战》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对“共享的(Shared)”和“可变的(Mutable)”状态的访问。而对象的状态是指存储在状态变量（类变量和成员变量）中的数据。“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期可以发生变化。
    
    </summary>
    
      <category term="Java并发编程实战" scheme="http://bestlixiang.site/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="并发" scheme="http://bestlixiang.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>人生之语言与数学</title>
    <link href="http://bestlixiang.site/2018/01/11/%E4%BA%BA%E7%94%9F%E4%B9%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%95%B0%E5%AD%A6/"/>
    <id>http://bestlixiang.site/2018/01/11/人生之语言与数学/</id>
    <published>2018-01-11T14:15:41.000Z</published>
    <updated>2018-01-11T14:21:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>引：其实最近自己一直都在准备考试，结果突然脑海出现了关于对人生的杂想（可能想的高度太高了），自己没有及时写下来，现在基本上考完了，所以就想认真谈一下自己的思考。<a id="more"></a></p>
<h1 id="人生"><a href="#人生" class="headerlink" title="人生"></a>人生</h1><p>我想大部人都是想着<strong>成功</strong>得过完这一生的，但是每个人都会迷茫，都会在某个时刻不知道自己想要什么，或者该怎么做。我想简单得把世界上的人归为这样两类。</p>
<h2 id="话人生"><a href="#话人生" class="headerlink" title="话人生"></a>话人生</h2><p>这里有一类人他们是靠<strong>情商</strong>和<strong>努力</strong>来获得成功的，说的通俗点就是走上行政或者做生意的，这类人对我们的世界是十分重要的，能说会道的人在哪都能吃得开吧。</p>
<h3 id="行政人生"><a href="#行政人生" class="headerlink" title="行政人生"></a>行政人生</h3><p>行政现在对学历的要求也越来越高了，所以不管怎么样，我觉得这样的人还是要对考试保持敬畏，我个人觉得锻炼应试能力是十分有必要的，因为在升学或者入职，这都将起着置关重要的作用，我想也许不用把每块知识都弄的那么深，那么透，反而应该是学会总结，学会归类，学会预测以便花最少的时间或者最佳的结果。这里要提一下就是我们从小的学的语文这门科目了，不能说它多有用，但是对于提高我们的文笔还是很有帮助的，还有就是书写能力也会显得十分重要。</p>
<h3 id="生意人生"><a href="#生意人生" class="headerlink" title="生意人生"></a>生意人生</h3><p>做生意或者说做销售，其实大部分的人都能感觉到实业越来越难做了，或者说是太稳固，墙外面的人很难挤进去，反而随着互联网的发展，线上的生意火好一些。这只是一种形式。真正想做大做好，你除了能说会道，我想掌握一口标准的普通话和一口流利的英语口语对生意的广度和未来都会有很好的帮助，所以语言能力需要好好的get。</p>
<h2 id="学人生"><a href="#学人生" class="headerlink" title="学人生"></a>学人生</h2><p>还有这一种人那就是通过<strong>学习</strong>和<strong>努力</strong>来改变人生，或者说是走技术路线的，当然这里也会分为两种人。</p>
<h3 id="科研人生"><a href="#科研人生" class="headerlink" title="科研人生"></a>科研人生</h3><p>世界需要进步，那进步从何而来，我想其中的核心是来自一部分占比不高的人（科学家，至少是个博士吧）的努力。这里数学就会显得那么重要。当然数学会分很多方面，之前听到过一种说法就是数学其实一门哲学，信了它就是对的，不信它就是错的。说的其实也是十分的有道理，数学的对错其实是相对的，不是绝对的，要根据所处的领域基础，但是对于大部分我们所认识到的数学大多数还是同一个基础，就是我们大部分人从小到大所学的数学。然后我想说说自己对于数学的认知，我想说数学其实是一个工具，它对于无论是哪方面的科研都是很重要的，无论是工科还是经济学科。所以也就诞生了那么多交叉学科。这里又想提到计算机科学，其实计算机科学在科研方便起到的只是减少人类的工作量以及提高人所需要的计算能力。就像大数据其实是属于统计学科，但是结合到计算机，那么就变成了计算机的热门学科了。</p>
<h3 id="经验人生"><a href="#经验人生" class="headerlink" title="经验人生"></a>经验人生</h3><p>世界的进步需要科学家，但是也少不了靠经验解决问题的专家，比如架构师，我想大概就是通过不断的实践来提高自己的解决问题的能力，而这不需要多好的科研能力或者说绝对的创新能力，只要多做多想，学会快又准确地解决问题就好了。我相信大部分人的智商都是差不多的，所以想在经验人生上取的小小的成功，真的是需要花很多时间来提升自己的经验。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：其实最近自己一直都在准备考试，结果突然脑海出现了关于对人生的杂想（可能想的高度太高了），自己没有及时写下来，现在基本上考完了，所以就想认真谈一下自己的思考。
    
    </summary>
    
      <category term="生活" scheme="http://bestlixiang.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="人生" scheme="http://bestlixiang.site/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
</feed>
