<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rex note</title>
  <subtitle>雨过，云过</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bestlixiang.site/"/>
  <updated>2020-12-03T14:17:20.106Z</updated>
  <id>http://bestlixiang.site/</id>
  
  <author>
    <name>rex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《微服务架构模式》</title>
    <link href="http://bestlixiang.site/2020/12/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bestlixiang.site/2020/12/03/读书笔记/微服务架构设计模式/</id>
    <published>2020-12-03T14:14:12.000Z</published>
    <updated>2020-12-03T14:17:20.106Z</updated>
    
    <content type="html"><![CDATA[<p>引：目前微服务大行其道，当我们在谈微服务的时候，我们究竟在谈什么，我们究竟要思考哪些方面？那么这本书刚好能解答微服务的方方面面！<a id="more"></a></p>
<p>Java开发者社区的意见领袖Chris Richardson，涵盖44个架构设计模式，系统解决服务拆分、事务管理、查询和夸服务通信的难题。</p>
<ol>
<li><p>要记住微服务不是解决所有问题的万能“银弹”</p>
</li>
<li><p>编写整洁的代码和使用自动化测试至关重要，因为这是现代软件开发的基础</p>
</li>
<li><p>关注微服务的本质，即服务的分解和定义，而不是技术，如容器和其他工具</p>
</li>
<li><p>确保你的服务松耦合、并且可以独立开发、测试和部署，不要搞成分布式单体，那将是巨大的灾难</p>
</li>
<li><p>不能只是在技术上采用微服务架构。拥抱DevOps的原则和时间在组织结构上实现跨职能的自治团队，必不可少</p>
</li>
<li><p>实现微服务架构并不是你的布标，你的目标是加速大型复杂应用程序的开发</p>
</li>
</ol>
<p><strong>软件的架构设计，就是选择和取舍。</strong>然后架构师就是做出取舍的人。</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h1 id="逃离单体地域"><a href="#逃离单体地域" class="headerlink" title="逃离单体地域"></a>逃离单体地域</h1><p>描述“单体地域”的症状，以及如何通过微服务架构规避，并概述了微服务架构的模式语言。</p>
<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>《The Art of Scalability》 提出了一个非常可用的三维可扩展模型：扩展立方体，该模型描述了扩展一个应用程序的三种维度：X/Y/Z</p>
<p>x轴扩展：在多个实例之间实现请求的负载均衡，这是提高应用程序吞吐量的可用性的好方法。</p>
<p>Z轴扩展：根据请求的属性路由请求，他也需要运行单体应用程序的多个实例，但是每个实例仅复杂数据的一个子集，比如根据租户ID，或者用户ID，对于应用程序需要处理增加的事务和数据量时，Z轴扩展是一种很好的扩展方式。</p>
<p>Y轴扩展：根据功能把应用拆分为服务，Y轴扩展把一个单体应用分成了一组服务，服务实现一组相关的功能。</p>
<p><strong>微服务架构的概括性定义：</strong> 把应用 程序功能性分解为一组服务的架构风格。每一个服务都是有一组专注的、内聚的功能职责组成。</p>
<p><strong>微服务架构与SOA的异同：</strong></p>
<ol>
<li><p>SOA：服务间通信（智能管道，例如ESB、往往采用重量级协议，例如SOAP）；数据管理（全局数据模型并共享数据库）；典型服务规模（较大的单体应用）</p>
</li>
<li><p>微服务：服务间通信（哑管道，例如消息代理或者服务之间点对点通信，例如使用REST或gRPC类的轻量级协议）；数据管理（每个服务都有自己的数据模型和数据库）；典型服务的规模（较小的服务）</p>
</li>
</ol>
<h2 id="微服务架构的好处和弊端"><a href="#微服务架构的好处和弊端" class="headerlink" title="微服务架构的好处和弊端"></a>微服务架构的好处和弊端</h2><p><strong>好处：</strong></p>
<ol>
<li>使大型的复杂应用程序可以持续交付和持续部署</li>
<li>每个服务都相对较小并容易维护</li>
<li>服务可以独立部署</li>
<li>服务可以独立扩展</li>
<li>微服务架构可以实现团队的自治</li>
<li>更容易实验和采纳新的技术</li>
<li>更好的容错性</li>
</ol>
<p><strong>弊端：</strong></p>
<p>没有一项技术可以被称为“银弹”</p>
<ol>
<li>服务的拆分和定义是一项挑战（噩梦：分布式单体应用）</li>
<li>分布式系统带来的各种复杂性（（挑战：跨服务的事务（saga）和查询（API组合和CQRS视图）））、使开发、测试和部署变得更困难（自动化部署工具，Paas平台，docker容器编排）</li>
<li>当部署跨越多个服务的功能时需要谨慎协调更多开发团队。（必须制定一个发布计划，把服务按照依赖关系进行排序）</li>
<li>开发者需要思考到底在应用的什么阶段使用微服务架构。</li>
</ol>
<h2 id="微服务架构的模式语言"><a href="#微服务架构的模式语言" class="headerlink" title="微服务架构的模式语言"></a>微服务架构的模式语言</h2><p><strong>模式：</strong> 是针对特定上下文中发生的问题的可重用解决方案。</p>
<p><strong>模式语言：</strong> 解决特定领域内问题的相关模式的集合。</p>
<p><strong>模式结构：</strong> </p>
<ol>
<li><p>需求</p>
<p>需求部分描述了必须解决的问题和围绕这个问题的特定上下文环境。需求有时候是互相冲突的。把所有的需求明确列出是非常有帮助的，因为它可以清晰展现哪些问题需要被（优先）解决。</p>
</li>
<li><p>结果上下文</p>
<p>结果上下文部分描述了这个模式的结果，他包含好处（这个模式的好处和他解决了什么需求）、弊端（这个模式的弊端和他没有解决哪些需求）、问题（使用这个模式所引入的新问题），结果上下文提供了更加完整、不偏不倚的视角来描述解决方案，这有助于更好的决策。</p>
</li>
<li><p>相关模式</p>
<p>相关模式部分描述了这个模式和其他模式之间的关系。模式之间存在5种关系：前导（前导模式是催生这个模式的需求的模式）、后续（后续模式是指用来解决当前模式引入的新问题的模式，如果采用了微服务架构模式，你需要一系列的后续模式来解决诸如服务发现、断路器等微服务带来的新问题）、替代（当前模式的替代模式）、泛化（针对一个问题的一般性解决方案）、特化（针对特定模式的具体解决方案）</p>
</li>
</ol>
<p><strong>微服务架构模式分为三组：</strong></p>
<ol>
<li>基础设施相关模式组：这些模式解决通常是在开发环节和基础设施相关的问题</li>
<li>应用基础设施相关模式组：这些模式解决应用层面的基础设施相关问题</li>
<li>应用相关模式组：这些模式解决开发人员面对具体技术和架构问题</li>
</ol>
<p>换种分组：</p>
<ol>
<li><p>服务拆分的相关模式</p>
<p>根据业务能力分解模式、根据子域分解模式</p>
</li>
<li><p>通信的相关模式</p>
<p>通信风格、服务发现、可靠性、事务性消息、外部API</p>
</li>
<li><p>实现事务管理的数据一致性相关模式</p>
<p>2pc、saga</p>
</li>
<li><p>在微服务架构中查询数据的相关模式</p>
<p>API组合、CQRS</p>
</li>
<li><p>服务部署的相关模式</p>
<p>serverless部署、每主机单/多服务部署</p>
</li>
<li><p>可观测的相关模式</p>
<p>健康检查API、日志聚合、分布式追踪、异常跟踪、应用指标、审计日志（埋点）</p>
</li>
<li><p>实现服务自动化测试的相关模式</p>
<p>消费端驱动的契约测试、消费端锲约测试、服务组件测试</p>
</li>
<li><p>解决基础设施和边界问题的相关模式</p>
</li>
<li><p>安全相关的模式</p>
</li>
</ol>
<p><strong>服务之上：流程和组织</strong></p>
<p>流程：DevOps</p>
<p>组织：小而自治的团队</p>
<p>康威定律：应用程序的架构往往反映了开发他的组织的结构</p>
<p>逆向的康威定律：设计你的企业组织，使其结构和微服务的结构意义对应</p>
<h1 id="服务的拆分策略"><a href="#服务的拆分策略" class="headerlink" title="服务的拆分策略"></a>服务的拆分策略</h1><p>描述可用于将应用程序分解为服务集合的模式</p>
<h2 id="微服务架构到底是什么"><a href="#微服务架构到底是什么" class="headerlink" title="微服务架构到底是什么"></a>微服务架构到底是什么</h2><p><strong>软件架构的定义：</strong>计算机系统的软件架构是构建这个系统锁需要的一组结构，包括<strong>软件元素</strong>、他们之间的<strong>关系</strong>以及两者的<strong>属性</strong>。</p>
<p>应用程序的架构可以从多个视角来看：逻辑视图（由开发人员创建，元素：类和包，关系，他们之间的关系）、实现视图（由构建编译系统创建、元素：模块（jar）和组件(war)，关系：他们之间的依赖关系）、进程视图（运行的组件，元素（进程），关系（进程间关系））、部署视图（运行在机器上的进程，元素（机器和进程），关系（网络）），最后通过场景将这4个视图串联起来。</p>
<p><strong>应用程序的需求：</strong>一个层面是<strong>功能性</strong>需求（通常包含在用例usecase、user story）、一个层面是<strong>非功能性</strong>需求（质量属性需求，比如可扩展性和可部署性）</p>
<p><strong>架构风格：</strong>根据结构组织模式定义了一系列此类系统。特定的架构风格提供了<strong>有限的元素（组件）</strong> 和<strong>关系（连接器）</strong>，你可以从中定义应用程序架构的视图。应用程序通常使用多种架构风格的组合。比如分层架构、六边形架构（描述微服务架构中每个服务的架构的好方法）</p>
<p><strong>微服务架构：</strong> 他的实现视图是一组可执行文件或war包，组件是服务，连接器是使这些服务能够协作的通信协议。每个服务都有自己的逻辑视图架构，通常是六边形架构。</p>
<p><strong>服务：</strong> 服务具有封装实现的API。API定义了由客户端调用的操作。有两种类型的操作：命令用来更新数据，查询用来检索数据。当服务的数据发生更改时，服务会发布可供客户端订阅的时间。服务最基本的要求是具有API并且可以独立部署。</p>
<p><strong>松耦合：</strong> 微服务架构最核心特性是服务之间的松耦合性。但是一般共享库就是耦合的来源。更好的方式是使用共享服务。如果一定要使用共享库，那么他一定是不太会改变的功能。</p>
<h2 id="为程序定义微服务架构"><a href="#为程序定义微服务架构" class="headerlink" title="为程序定义微服务架构"></a>为程序定义微服务架构</h2><p>根所有的软件开发过程一样，一开始我们需要拿到领域专家或有现有应用的需求文档。下面是一种常用的定义应用程序架构的三步式流程：</p>
<ol>
<li><p>定义系统操作（从需求开始，通常是用户故事，然后定义出一个系统操作，代表一个外部的请求），可以是更新数据的命令，也可以是检索数据的查询，每个命令的行为都是根据抽象领域模型定义的，抽象领域模型也是从需求中派生出来的。</p>
<ol>
<li>创建一个抽象领域模型 （主要来源于用户故事中提及的名词；或者使用事件风暴）</li>
<li>定义系统操作，这些操作是更具领域模型定义的（主要来源于用户故事中提及的动词）</li>
</ol>
</li>
<li><p>定义服务</p>
<ol>
<li><p>一种策略是源于业务架构学院的策略（定义域业务能力相对应的服务）</p>
<p>业务能力是指一些能够为公司产生价值的商业活动。</p>
<p>组织的业务能力通常是指这个组织的业务是做什么的，他们通常是稳定的，而业务能力的实现方式是随着时间不短变化的。</p>
<p>一个组织有哪些业务能力，是通过对组织目标、结构和商业流程的分析得来的。每个业务能力都可以被任务是一个服务。业务能力通常是集中在特定的业务对象上。</p>
<p>围绕能力组织服务的一个关键好处是，他们是稳定的。</p>
</li>
<li><p>另一种是围绕领域驱动设计的子域来分解和设计服务</p>
<p>领域驱动为每一个子域定义单独的领域模型。子域是领域的一部分，领域是DDD中用来描述应用程序问题域的一个术语。识别子域的方式和识别业务能力一样：分析业务并识别业务的不同专业领域。DDD把领域模型的边界称为界限上下文。当使用微服务架构时，每一个界限上下文对应一个或者一组服务。</p>
</li>
</ol>
<p><strong>拆分服务的指导原则：</strong> 单一职责原则（SRP）、闭包原则（CCP，调整需要在包内）还有上面的按业务能力和子域。</p>
<p><strong>拆分单体应用为服务的难点：</strong> 网络延迟（批处理API解决，或者合并服务）、同步进程间通信导致可用性降低（使用异步消息）、在服务之间维持数据的一致性（Saga）、获取一致的数据视图（很少带来问题）、上帝类阻碍了拆分（使用DDD防腐层，每个服务都只需要保留上上帝类较少的属性）</p>
</li>
<li><p>定义服务API和协作方式（通信方式）</p>
<p>定义服务的API就是定义服务的操作和事件。操作分为两种：外部客户端调用和其他服务调用，服务通过对外发布事件，使其能够与其他服务协作，也可使用WebSocket将事件传递给浏览器。</p>
<ol>
<li>把系统操作分配给服务，大部分情况下，将操作分配给具有处理它所需信息的服务，但是有些情况也可以分配给需要操作所提供信息的服务</li>
<li>确定支持服务<strong>协作</strong>所需要的API</li>
</ol>
</li>
</ol>
<h1 id="微服务架构中的进程通信"><a href="#微服务架构中的进程通信" class="headerlink" title="微服务架构中的进程通信"></a>微服务架构中的进程通信</h1><p>介绍了微服务架构中强大的进程间通信的几种模式，解释了为什么异步和基于消息的通信通常是最佳选择。</p>
<p>一个理想的微服务架构应该是咋内部由松散耦合的若干服务组成，这些服务使用异步消息相互通信。REST等同步协议主要用于服务于外部其他应用程序的通信。</p>
<h2 id="微服务架构中的进程通信-1"><a href="#微服务架构中的进程通信-1" class="headerlink" title="微服务架构中的进程通信"></a>微服务架构中的进程通信</h2><p>不同的进程间通信技术，可以是同步，也可以异步，然后通信时的数据格式也不同，可以是json，也可以pb</p>
<ol>
<li><p>交互方式</p>
<p>交互方式的选择会影响应用程序的可用性，也可以影响你选择更合适的集成策略策略。交互的方式有以下两个维度：</p>
<ul>
<li>一对一，一对多</li>
<li>同步（紧耦合）或异步</li>
</ul>
</li>
<li><p>在微服务架构中定义API</p>
<p>服务的API是服务于其客户端之间的契约。服务的API由客户端结构可以调用的方法和服务发布的事件组成，方法具有名称、参数和返回类型、事件具有一个类型和一组字段。</p>
<p>无论哪种选择哪种进程间通信机制，使用某种<strong>接口定义语言（IDL）</strong>精确定义服务的API都很重要 （定义方式和事件）</p>
<p><strong>API优先设计：</strong> 在开发时，先编写接口定义。</p>
</li>
<li><p>API的演化</p>
<p>API不可能是一层不变的，所以在演变过程中需要注意</p>
<ul>
<li>语义化版本控制</li>
<li>进行次要并且向后兼容的改变（添加字段）</li>
<li>进行主要并且不向后兼容的改变（增加版本）</li>
</ul>
</li>
<li><p>消息的格式</p>
<ul>
<li>文本：json、xml 可读性高，兼容性高，缺点是过度冗长</li>
<li>二进制消息格式：protocol Buffers，会序列化成二进制</li>
</ul>
</li>
</ol>
<h2 id="基于同步远程过程调用的通信"><a href="#基于同步远程过程调用的通信" class="headerlink" title="基于同步远程过程调用的通信"></a>基于同步远程过程调用的通信</h2><p><strong>远程过程调用：</strong> 客户端使用同步的远程过程调用协议（如Rest）来调用服务</p>
<ol>
<li><p>使用REST （使用HTTP协议的进程间通信机制）</p>
<ol>
<li><p>REST成熟度模型</p>
<ul>
<li>LEVEL 0（大部分）： 客户端只是向服务断点发起HTTP POST请求，进行服务调用，每个请求都指明需要执行的操作，和必要的参数</li>
<li>LEVEL 1：引入资源的概念，要执行对资源的操作，客户端需要发出制定要执行的操作和包含任何参数的POST请求</li>
<li>LEVEL 2： 使用HTTP动词来执行操作，GET、POST、PUT</li>
<li>LEVEL 3： 基于HATEOAS原则设计，基本思想是又GET请求返回的资源信息中包含连接，这些连接能够执行该资源允许的操作。（感觉很奇怪）</li>
</ul>
</li>
<li><p>定义REST API</p>
<p>使用Swagger</p>
</li>
<li><p>在一个请求中获取多个资源的调整</p>
<ul>
<li>在获取资源的URL，加入需要的资源的信息</li>
<li>使员工GraphQL、Netflix Falcor</li>
</ul>
</li>
<li><p>把操作映射为HTTP动词的挑战</p>
<p>我们会面临HTTP动词不够用的情况，比如使用PUT更新，但是更新可能是取消订单，也可以是更新订单，这个时候需要将动词指定为URL的参数。</p>
<p>这个时候发现好像REST不太行？？</p>
</li>
<li><p>好处和弊端</p>
<p>好处：简单、可以使用curl等工具测试、支持请求和响应的方式通信、防火墙友好，不需要代理</p>
<p>弊端：只支持请求和响应的方式通信，可能导致可用性降低（没有代理来缓冲消息），客户端必须知道服务实例的位置（URL），在单个请求中获取多个资源（多个模型）具有挑战性，有时很难将多个更新操作映射到HTTP动词。</p>
</li>
</ol>
</li>
<li><p>使用GRPC（使用HTTP/2以PB格式通信的进程间通信机制）</p>
<ol>
<li><p>好处</p>
<ul>
<li>设计具有复杂更新操作的API非常简单</li>
</ul>
</li>
</ol>
<ul>
<li>他具有高效、紧凑的进程间通信机制，尤其是在交换大量消息时<ul>
<li>支持在远程过程调用和消息传递过程中使用<strong>双向流式消息方式</strong></li>
</ul>
</li>
<li>他实现了客户端和用<strong>各种语言</strong>编写的服务端之间的互操作性</li>
</ul>
<ol>
<li>弊端<ul>
<li>与基于REST/JOSN的API机制相比，JavaScript客户端使用基于grpc的API需要更多的工作</li>
<li>旧式防火墙之鞥呢不支持HTTP/2</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><strong>使用断路器模式处理局部故障</strong>（A-&gt;B-&gt;C, 不能因为C的故障而导致B的完全不可用）</p>
<p><strong>断路器模式：</strong> 断路器是一个远程过程调用的代理，在连续失败次数超过指定阈值后的一段时间内，这个代理会立即拒绝其他调用。</p>
<p>断路器模式的实现：监控客户端发出的请求的成功和失败数量，如果失败的比例超过一定的阈值，就启动断路器，让后续的调用立刻失效。在经过一定的时间后，客户端应该继续尝试，如果调用成功，则接触短路器。Java的Hystrix。</p>
<p>在考虑完如何保证自己服务不挂的同时，还需要考虑如何<strong>降级（报错或者走缓存）</strong>，避免客户端完全失败  ​。</p>
<p><strong>使用服务发现处理单机故障</strong></p>
<p>实现服务发现有以下两种方式：</p>
<ol>
<li><p>服务及其客户直接与服务注册表交互（服务端自注册，服务注册表定期心跳检测，客户端发现并进行负载均衡）。 Eureka+Ribbon</p>
<ul>
<li>优点：服务可以多平台部署</li>
<li>缺点：服务如果夸语言，则每个语言都要实现sdk，同时开发需要自己维护服务注册表</li>
</ul>
</li>
<li><p>通过部署基础设施来处理服务发现。（更棒）</p>
<p>部署平台包括一个服务注册表，用于跟踪已部署服务的IP地址</p>
<ul>
<li>优点： 服务发现的所有方面都完全由部署平台处理。服务和客户端都不包含任何服务发现代码，而且夸语言和框架。</li>
<li>缺点：仅限于支持使用该平台部署的服务。</li>
</ul>
</li>
</ol>
<h2 id="基于异步消息模式的通信"><a href="#基于异步消息模式的通信" class="headerlink" title="基于异步消息模式的通信"></a>基于异步消息模式的通信</h2><p>使用消息机制时，服务之间采用异步交换消息的方式完成。一种是使用消息代理，另一种无代理架构（反而不像消息）。基于消息机制的应用程序通常使用<strong>消息代理</strong>。</p>
<p><strong>消息</strong></p>
<p>消息由消息头部和消息主题组成。消息头部有描述正在发送的数据的元数据（感觉没有），以及基础设施生成的<strong>唯一消息ID</strong>，以及可选的<strong>返回地址</strong>（改地址指定发送回复的消息通道）。消息正文是以文本或二进制格式发送的数据。消息有一下几种不同的类型：</p>
<ul>
<li>文档：仅包含数据的通用消息。接收者决定如何解释它。对命令式消息的恢复是文档消息的一种使用场景。（像是我们大多的使用场景）</li>
<li>命令：一条等同与RPC请求的消息。它指定要调用的操作及其参数。（定时调度的消息）</li>
<li>事件：表示发送方这一段发啥了重要的时间。事件通常是领域事件，表示领域对象的状态变更。</li>
</ul>
<p><strong>消息通道</strong></p>
<ul>
<li>点对点通道：向正在向通道读取的一个 消费者传递消息。服务使用点对点通道来实现前面描述的一对一的交互方式。命令式消息。</li>
<li>发布-订阅通道将一条消息发给所有订阅的接收方。服务使用发布-订阅通道来实现前面描述的一对多的交互方式。事件式消息。</li>
</ul>
<p><strong>使用机制实现交互方式</strong></p>
<ul>
<li>实现请求/响应和异步请求/响应：主要是客户端提供一个可回复的地址。</li>
<li>实现单向通知。</li>
<li>实现发布/订阅。服务使用发布/订阅发布领域事件，领域事件代表领域对象的更改。发布领域事件的服务拥有自己的发布/订阅通道，通道的名称往往派生自领域类。比如OrderService将Order事件发布到Order通道。对特定领域对象的事件感新校区的服务只需订阅响应的通道。</li>
<li>实现发布/异步响应</li>
</ul>
<p><strong>为基于消息机制的服务API创建API规范</strong></p>
<p>服务的异步API包含供<strong>客户端调用的操作</strong>和<strong>由服务对外发布的事件</strong></p>
<p>记录异步操作</p>
<ul>
<li>请求/异步响应式API：包括服务的命令消息通道、服务接受的命令式消息的具体类型和格式，以及服务发送的恢复消息的类型和格式。</li>
<li>单向通知式API：包括服务的命令消息通道，以及服务接受的命令式消息的具体类型和格式。</li>
</ul>
<p>基于事件发布</p>
<ul>
<li>对外发布事件：包括事件通道，以及服务发布到通道的事件式消息的具体类型和格式</li>
</ul>
<p><strong>使用消息代理</strong></p>
<p>基于消息传递对的应用程序通常使用<strong>消息代理</strong>，即服务通信的基础设施服务。基于消息代理的架构不是唯一的消息架构，还可以使用无代理的消息架构（比如ZeroMQ），无代理的消息架构服务是直接相互通信的，无代理架构更像是同步通信很相似（有client和server），有机会可以看看。下面主要看看基于代理的消息架构。</p>
<p><strong>消息代理</strong>是所有消息的中介节点。发送方将消息写入消息代理，消息代理将消息发送给接收方。使用消息代理的一个重要好处是发送方不需要知道接收方的网络位置。另一个好处是消息代理缓冲消息，直到接收方能够处理他们。比如ActiveMQ、RabbitMQ、Kafka、RocketMQ</p>
<p>选择消息代理时，需要考虑各种因素：</p>
<ul>
<li>支持的编程语言，因为需要client</li>
<li>支持的消息标准，比如AMQP和STOMP</li>
<li>消息排序</li>
<li>投递保证</li>
<li>持久性</li>
<li>耐久性</li>
<li>可扩展性</li>
<li>延迟</li>
<li>竞争性（并发）接收方</li>
</ul>
<p>一般来说，消息顺序和可扩展性是必不可少的。</p>
<p>基于代理的消息的好处：</p>
<ul>
<li>松耦合</li>
<li>消息缓存</li>
<li>灵活的通信</li>
<li>明确的进程间通信（有点不能体会）</li>
</ul>
<p>基于代理的消息的弊端：</p>
<ul>
<li>潜在的性能瓶颈</li>
<li>潜在的单点故障</li>
<li>额外的操作复杂性（需要支持一个消息系统）</li>
</ul>
<p><strong>处理并发和消息顺序</strong></p>
<p>为了同时处理处理消息，提高应用系统的吞吐量，使用多个线程和服务实例来处理消息是很常见的事情。但是这样带来的挑战是如何<strong>确保每个消息只被处理一次，并且是按照他们发送的顺序来处理的</strong>。</p>
<p>常用的解决方案是使用<strong>分片（分区）</strong>通道：</p>
<ol>
<li>分片通道由两个或者多个分片组成，每个分片的行为类型一个通道</li>
<li>发送方在消息头部指定分片键，通常是任意字符串或字节序列。消息代理使用分片键将消息分配给特定的分片。例如，它可以通过计算分片键的散列来选择分片。</li>
<li>消息代理将接收方的多个实例组合在一起，并将他们视为相同的逻辑接收方（消费组）。消息代理将每个分片分配给单个接收器。他在接收方启动和关闭时重新分配分片（感觉还是会出现不有序的情况）。</li>
</ol>
<p><strong>处理重复消息</strong></p>
<p>使用消息消息机制时必须解决的另一个挑战是处理重复消息。理想情况下，消息情况下，消息代理应该只传递一次消息，但保证有且仅有一次的消息传递通常成本很高，相反，大多数消息代理<strong>承诺至少成功传递一次消息</strong>。</p>
<p>理想情况下，你应该使用消息代理，在重新传递消息时保留排序（A B C， A重投，B C也要跟着重投）</p>
<p>处理重复消息有以下两种不同的方法：</p>
<ul>
<li>编写幂等消息处理程序（太难了）</li>
<li>跟踪消息并丢弃重复项：消息接收方使用message id（来个表，或者将message id 放入应用表中的一列）跟踪它已处理的消息并丢弃任何重复项。</li>
</ul>
<p><strong>事务性消息</strong></p>
<p><strong>服务通常需要在更新数据库的事务中发送消息（领域事件）</strong>。在这个时候，数据库更新和消息发送都必须在事务中运行。否则服务可能在更新数据库，然后在发送消息之前崩溃。如果服务不以原子方式执行这两个操作，则类似的故障可能使系统处于不一致状态。</p>
<p>传统的解决方案是在数据库和消息代理之间使用<strong>分布式事务</strong>。下面是可替代的方案：</p>
<ol>
<li><p>使用数据库表作为消息队列</p>
<p>使用数据库表作为临时消息队列，发送消息服务有个消息数据库表（对于NoSql，可作为文档的一个属性），作为创建、更新和删除业务对象的数据库事务的一部分，服务通过将消息插入到消息数据库表中来发送消息，这样就利用了本地事务来保证了原子性。此时消息数据库表充当了临时消息队列，然后通过一个称为MessageRelay的服务读取消息并将消息发送到消息代理。</p>
</li>
<li><p>关于MessageRelay的实现有下面一种实现：</p>
<ul>
<li><p>通过轮询模式发布事件</p>
<p>通过轮询轮询数据库的消息，把消息发送给消息dialing，然后把完成发送的消息从消息表中移除。轮询数据库是一种在小规模下运行良好的简单方法。弊端是经常轮询数据库可能造成数据库性能下降。由于这些弊端和限制，通常在某些情况下，更好的方法是使用更复杂和高性能的方法，来拖尾数据库事务日志。</p>
</li>
<li><p>使用事务日志拖尾模式发布事件</p>
<p>每次应用程序提交到数据库的更新都对应着数据库事务日志的一个条目。事务日志挖掘器可以读取事务日志，把每条更消息有关的记录发送给消息代理。具体实现有：Debezium（kafka）、linkedIn databus、DynamoDB streams、 Eventuate Tram（binlog kafka）</p>
</li>
</ul>
</li>
</ol>
<h2 id="使用异步消息提高可用性"><a href="#使用异步消息提高可用性" class="headerlink" title="使用异步消息提高可用性"></a>使用异步消息提高可用性</h2><p>由于采用同步通信机制作为请求处理的一部分，会对系统的可用性带来影响。因此，应该竟可能选择一部通信机制来处理服务之间的调用。</p>
<p><strong>同步通信会降低可用性</strong></p>
<p>比如 A -&gt; B -&gt; C 这样的请求，同步通信要求3个服务都需要同时在线，如果每个服务的可用性是99.5，那么这个系统的可用性就是99.5 <em> 99.5 </em> 99.5 = 98.5了（系统整体的可用性是所有参与方的乘积）</p>
<p><strong>消除同步交互</strong></p>
<ol>
<li><p>使用异步交互模式</p>
<p>想想很美好，但是很多情况下的API都要求对请求立刻做出影响</p>
</li>
<li><p>复制数据</p>
<p>通过维护B的数据副本，来减去对B的调用，但是弊端是有时候复制的数据量巨大，会导致效率低下</p>
</li>
<li><p>暂缓服务与其他服务的交互</p>
<p>立即响应请求，通过消息异步处理一些调用，然后通过前端轮询状态</p>
</li>
</ol>
<h1 id="使用Saga管理事务"><a href="#使用Saga管理事务" class="headerlink" title="使用Saga管理事务"></a>使用Saga管理事务</h1><p>介绍如何使用Saga模式维护服务间的数据一致性 （有时间可以自己实现一把）</p>
<h2 id="微服务架构下的事务管理"><a href="#微服务架构下的事务管理" class="headerlink" title="微服务架构下的事务管理"></a>微服务架构下的事务管理</h2><p>由于微服务架构下的事务往往需要横跨多个服务，每个服务都有属于自己的私有数据库，所以传统的分布式事务管理（2PC，直接操纵两个数据库）不是微服务架构下选择。我们需要一些更为高级的事务管理机制来管理事务。</p>
<p>传统的分布式事务的挑战：不是所有数据库和消息代理都支持分布式事务，同时分布式事务是同步调用，会降低系统的可用性。</p>
<p>但是我们可以通过Saga模式来维护数据的一致性。一个Saga表示需要更新多个服务数据的一个系统操作。Saga由一连串的本地事务组成，每一个本地事务复杂更新它所在服务的私有数据库，这些操作仍然依赖于我们所熟悉的ACID事务框架。同时Saga使用补偿事务来回滚多个服务所做出的的改变。</p>
<h2 id="Saga的协调模式"><a href="#Saga的协调模式" class="headerlink" title="Saga的协调模式"></a>Saga的协调模式</h2><p>Saga的实现包含协调Saga步骤的逻辑。当通过系统命令启动Saga时，协调逻辑选择并通知第一个Saga参与方执行本地事务。一旦该事务完成，Saga协调选择并调用下一个Saga参与方。这个过程一直持续到Saga执行完所有步骤。如果任何本地事务失败，则Saga必须以相反的顺序执行补偿事务。下面是几种Saga的协调逻辑：</p>
<ol>
<li><p>协同式</p>
<p>把Saga的决策和执行顺序逻辑分布在Saga的每个参与方中，他们通过交换事件的方式来进行沟通</p>
<p>好处：</p>
<ul>
<li>简单：服务在创建、更新或删除业务对象时发布事件</li>
<li>松耦合</li>
</ul>
<p>弊端：</p>
<ul>
<li>更难理解：无法理解Saga是如何工作的</li>
<li>服务之间的循环依赖关系：Saga参与方订阅彼此的时间，这通常会导致循环依赖关系。</li>
<li>紧耦合的风险：每个Saga参与方都需要订阅所有影响他们的事件</li>
</ul>
</li>
<li><p>编排式</p>
<p>把Saga的决策和执行顺序逻辑集中在一个Saga编排器类中，Saga编排器发出<strong>命令式消息</strong>给各个Saga参与方，指示这些参与方服务完成具体的操作（本地事务）</p>
<p>把Saga编排器视为一个状态机。状态机是建模Saga编排器的一个好方法。<strong>状态机由一组状态和一组由事件触发的状态之间的转换而成</strong>。每个转换都可以有一个动作，对Saga来说，动作就是对某个参与方的调用。状态之间的转换由Saga参与方执行的本地事务完成触发。当前状态和本地事务的特定结果决定了状态转换以及执行的动作。</p>
<p>好处：</p>
<ul>
<li>更简单的依赖关系，Saga编排器调用Saga参与方，但参与方不会调用编排器</li>
<li>较少的耦合：每个服务实现供编排器调用的API</li>
<li>改善关注点隔离，简化业务逻辑 （领域对象更加简单）</li>
</ul>
<p>弊端：</p>
<ul>
<li>编排器中集中过多的业务逻辑的风险。</li>
</ul>
</li>
</ol>
<h2 id="解决隔离问题"><a href="#解决隔离问题" class="headerlink" title="解决隔离问题"></a>解决隔离问题</h2><p>使用Saga的挑战在于他们缺乏ACID事务的隔离属性。这是因为一旦该事务提交，每个Saga的本地事务所做的更新都会立即被其他Sagas看到。</p>
<p><strong>缺乏隔离导致的问题</strong></p>
<ol>
<li>丢失更新：一个Saga没有读取更新，而是直接覆盖了另一个Saga所做的改变</li>
<li>脏读：一个事务或一个Saga读取了尚未完成的Saga所做的更新。</li>
<li>不可重复读/幻读：一个Saga的两个步骤读取相同的数据却获得了不同的结果。</li>
</ol>
<p><strong>Saga模式下实现隔离的对策</strong></p>
<p>Saga事务模型是ACD，他缺乏隔离可能导致的异常，从而导致应用程序行为错误。开发人员你有责任以一种防止异常或最小化对业务异常的方式来编写Saga。</p>
<p>一个有用的Saga结构模型，包含三种类型的事务：</p>
<ul>
<li>可补偿性事务：可以使用补偿事务回滚的事务</li>
<li>关键性事务：Saga执行过程的关键点。如果关键性事务成功，则Saga将一直运行到完成。他可以是最后一个可补偿的事务或第一个可重复的事务</li>
<li>可重复性事务：在关键性事务之后的事务，保证成功</li>
</ul>
<p>然后分析一下对策：</p>
<ul>
<li><p>语义锁</p>
<p>使用语义锁对策时，Saga的可补偿性事务会在其创建或更新任何记录中设置标记，该标记表示该记录<strong>未提交且可能发生更改</strong>，该标记可以是组织其他事务访问记录的锁，也可以是指示其他事务应该谨慎地处理该记录的一个警告。这个标记会被一个可重复事务清除，这表示Saga成功完成；或通过补偿事务清除，这表示Saga发生了回滚。比如Order.state的各种*_PENDING状态。</p>
<p>管理语义锁只是问题的一半，还需要根据具体情况决定一个Saga应该如何处理已被锁定的记录。一个选择是让另一个saga失败并之后重试，另一个是让其阻塞，知道其他Saga释放语义锁。（如果是后一种就需要自己实现锁，并且实现死锁检测算法）</p>
</li>
<li><p>交换式更新</p>
<p>将更新操作设计为可交换的。如果可以按任何顺序执行，则操作是可交换的。（比如不考虑透支的情况的加减钱）</p>
</li>
<li><p>悲观视图</p>
<p>重新排序Saga的步骤，以最大限度得降低由于脏读而导致的业务风险。</p>
</li>
<li><p>重读值</p>
<p>Saga在更新之前重新读取记录，验证他是否未更改，然后更新记录，如果记录已经更改，则Saga将中止并可能重新启动。这是乐观锁的一种形式。</p>
</li>
<li><p>版本文件</p>
<p>记录对数据的操作（不太理解实现）</p>
</li>
<li><p>对业务风险评级</p>
<p>最终的决策是<strong>基于价值（业务风险）</strong>对策。对低风险请求，使用Saga，对于高风险请求，使用分布式事务。</p>
</li>
</ul>
<h1 id="微服务架构中的业务逻辑设计"><a href="#微服务架构中的业务逻辑设计" class="headerlink" title="微服务架构中的业务逻辑设计"></a>微服务架构中的业务逻辑设计</h1><p>介绍如何使用领域驱动设计（DDD）的聚合和领域事件等模式为服务设计业务逻辑</p>
<p><strong>企业应用程序的核心是业务逻辑，业务逻辑实现了业务规则。开发复杂的业务逻辑总是充满挑战。</strong></p>
<p>在微服务架构下，由于业务逻辑散布在多个服务上。我们需要解决两个关键问题：</p>
<ol>
<li>需要避免夸服务边界的对象引用</li>
<li>必须处理分布式事务问题，比如Saga</li>
</ol>
<h2 id="业务逻辑组织模式"><a href="#业务逻辑组织模式" class="headerlink" title="业务逻辑组织模式"></a>业务逻辑组织模式</h2><p>在六边形架构中，主要由业务逻辑和各种适配器组成，一般业务逻辑会有以下适配器：</p>
<ol>
<li>Rest API Adapter（RPC Adapter）：入站适配器，实现Rest API，这些API会调用业务逻辑</li>
<li>CommandHandler：入站适配器，他接受来自消息通道的命令式消息，并调用业务逻辑</li>
<li>Database Adapter：由业务逻辑调用以访问数据库的出站适配器</li>
<li>Domain Event Publishing Adapter：将事件发布到消息代理的出站适配器</li>
</ol>
<p>组织业务逻辑有两种模式：</p>
<ul>
<li><p>面向过程的事务脚本模式</p>
<p>通过实现行为的类和存储状态的类组成</p>
</li>
<li><p>面向对象的领域建模模式</p>
<p>有些类只有行为（Domain Service / Repository）、有些类只有状态（Value Object）、更多的类同时拥有行为和状态（Entity / Aggregate）</p>
</li>
</ul>
<h2 id="使用聚合模式设计领域模型"><a href="#使用聚合模式设计领域模型" class="headerlink" title="使用聚合模式设计领域模型"></a>使用聚合模式设计领域模型</h2><p>边界在业务逻辑处理中很重要，通过聚合显示将边界突出。然后在聚合上施加一些<strong>不变量</strong>。</p>
<p><strong>聚合</strong>：将领域模型组织为聚合的集合，每个聚合都是可以作为一个单元进行处理的一组对象构成的图。</p>
<p>在领域驱动设计中，设计领域模型的关键部分是识别聚合，以及他们的边界和根。聚合内部结构的细节是次要的。聚合的机制不仅仅是帮助我们设计模块化的领域模型，更重要的是聚合必须遵守某些规则。</p>
<p><strong>聚合规则</strong></p>
<p>领域驱动设计要求聚合遵守一组规则。这些规则确保聚合是一个可以强制执行各种不变量约束的自包含单元。</p>
<ul>
<li><p>只引用聚合根</p>
<p>聚合根是聚合唯一可以被外部类引用的部分，客户端只能调用聚合根上的方法（包含不变量约束）来更新聚合</p>
</li>
<li><p>聚合间的引用必须使用主键</p>
</li>
<li><p>在一个事务中，只能创建或更新一个聚合</p>
<p>在单个服务维护多个聚合的一致性的另一种方法是打破聚合规则，在一个事务中更新多个聚合。这是在关系型数据库才能拥有的。</p>
</li>
</ul>
<p><strong>聚合的颗粒度</strong></p>
<p>在开发领域模型时，你必须做出关键决策是决定每个聚合的大小。</p>
<ol>
<li>如果聚合小，则再序列化的还是性能好，同时降低了两个用户尝试更新一个聚合而引发冲突的可能性</li>
<li>如果聚合大，使特定的聚合更新满足事务的原子性</li>
</ol>
<p><strong>使用聚合设计业务逻辑</strong></p>
<p>在典型的微服务中，大部分业务逻辑由聚合组成。其余的业务逻辑存在于领域服务和Saga中。Saga编排本地事务的序列（如果没有Saga，就是用UseCase层替代），以确保数据的一致性。</p>
<p>业务逻辑：Aggregate、DomainService、Repository和一个或者多个Saga组成。DomainService调用Repository来保存和加载Aggregate，对于能在服务内部完成护理的简单请求，服务直接更新Aggregate，如果需要请求跨越多个服务，DomainService将创建一个Saga。</p>
<h2 id="发布领域事件"><a href="#发布领域事件" class="headerlink" title="发布领域事件"></a>发布领域事件</h2><p>在领域驱动设计的上下文中，领域事件是聚合发送的事情。他由领域模型的一个类表示。事件通常表示状态的变化。</p>
<p><strong>领域事件</strong>：聚合在被创建时，或发生其他重大改变时发布领域事件。下面是一些可能的使用场景</p>
<ol>
<li>使用基于编排的Saga维护领域服务之间的数据一致性</li>
<li>通知维护数据副本的服务，源数据已经发生了更改，这种方法称为命令查询执行隔离（CRQS）</li>
<li>通过Webhook或消息代理通知不同的应用程序，以触发下一步业务流程</li>
<li>按顺序通知同一应用程序的不同组件</li>
<li>向用户发送短信或电子邮件通知</li>
<li>监控领域事件以验证应用功能程序是否正常运行 （event store）</li>
<li>分析领域事件，为用户行为建模（事件风暴）</li>
</ol>
<p><strong>什么是领域事件</strong></p>
<p>在命名领域事件时，我们往往选择动词的过去分词。</p>
<p><strong>事件增强</strong></p>
<p>事件内容有两种选择：</p>
<ol>
<li>只保留聚合根ID，当订阅方需要更多信息的时候，通过访问聚合服务获取</li>
<li>事件增强，事件包含接收方需要所有信息，该方法简化了接收方，但缺点是使领域事件的稳定性降低，每当接收方的需求发生变更时，事件类都可能需要修改，降低可维护性。</li>
</ol>
<p><strong>识别领域事件</strong></p>
<p>事件风暴，具体方法是：把领域专家聚集在一个屋子里，准备大量便签和一个大白板。事件风暴的结果是一个以时间为中心的领域模型，它由聚合和事件组成。</p>
<p>事件风暴包括三个主要步骤：</p>
<ol>
<li>头脑风暴：请求领域专家集体讨论领域事件。领域事件由（橙色便签）表示，这些便签子啊白板上按照时间轴顺序摆放。</li>
<li>识别事件触发器：请求领域专家确定每个事件的触发器，如用户操作（蓝色便签）、外部系统（紫色便签）、另一个领域事件、时间流逝。</li>
<li>识别聚合：请求领域专家识别哪些使用命令的聚合并发出响应的领域事件。聚合由（黄色便签）表示。</li>
</ol>
<p><strong>生成和发布领域事件</strong></p>
<ol>
<li><p>生成领域事件</p>
<p>领域事件由聚合负责发布。聚合知道其状态合适发生变化，从而知道要发布的事件。下面是几种方式：</p>
<ul>
<li>聚合直接调用消息传递API，缺点：由于聚合不能使用依赖注入，所以消息传递API需要作为方法参数传递，这会把基础设施和业务逻辑交织在一起是非常不可取的。</li>
<li>在聚合方法的返回值中包含一个事件列表，然后通过调用他的服务发送</li>
<li>在聚合根内部的一个字段内部累计保持事件，然后通过调用他的服务发送</li>
</ul>
</li>
<li><p>发布领域事件</p>
<p>服务必须使用事务性消息来发布事件，以确保领域事件是作为更新数据库中聚合的事务的一部分对外发布。</p>
</li>
</ol>
<p><strong>消费领域事件</strong></p>
<p>定义消费Handler</p>
<h1 id="使用事件溯源开发业务逻辑"><a href="#使用事件溯源开发业务逻辑" class="headerlink" title="使用事件溯源开发业务逻辑"></a>使用事件溯源开发业务逻辑</h1><p>解释了如何使用事件溯源模式开发业务逻辑</p>
<p><strong>事件溯源（Event Sourcing）</strong>是一种以事件为中心的编写业务逻辑和持久化领域对象的方法。</p>
<h2 id="使用事件溯源模式开发业务逻辑"><a href="#使用事件溯源模式开发业务逻辑" class="headerlink" title="使用事件溯源模式开发业务逻辑"></a>使用事件溯源模式开发业务逻辑</h2><p><strong>传统持久化技术的问题</strong></p>
<ol>
<li>对象和关系的”阻抗失调” ：关系型数据库的表格结构模式与领域模型及其复杂关系的图状结构之间，存在基本的概念不匹配问题。</li>
<li>缺乏聚合历史</li>
<li>实施审计功能将非常繁琐且容易出错</li>
<li>事件发布凌驾于业务之上</li>
</ol>
<p><strong>什么是事件溯源</strong></p>
<p><strong>事件溯源</strong>是构建业务逻辑和持久化聚合的另一种选择。它将聚合以一系列事件的方式持久化保存。每个事件代表聚合的一次状态变化。应用程序通过重放事件来重新创建聚合的当前状态。</p>
<p>当应用程序创建或更新聚合时，他会将聚合发出的事件插入到EVNNTS表汇总。应用程序通过事件存储中检索并重发事件来加载聚合。加载聚合包含以下三个步骤：</p>
<ol>
<li>加载聚合的事件</li>
<li>使用其默认构造函数创建聚合实例</li>
<li>调用apply方法遍历事件</li>
</ol>
<p>事件溯源对领域事件提出了新的需求。之前我们将领域事件定义为一种机制，它用来通知订阅者聚合发生了改变。事件可以包含少量的数据，也可以包含对典型事件接收方有用的数据。但是，在事件溯源的情况下，聚合主要决定事件及其结构。同时使用事件溯源时，事件不再是可有可无的。包括创建在内的每一个聚合状态变化，都必须由领域事件表示。每当聚合的状态发生变化时，它必须发出一个事件。而且事件中必须包含聚合执行状态变化所需的数据。聚合的状态由构成聚合对象的字段值组成。</p>
<p>创建聚合的步骤如下：（process和apply是多个重载的方法，属于聚合类）</p>
<ol>
<li>使用聚合的默认构造函数实例化聚合根</li>
<li>调用process方法以生成新事件</li>
<li>遍历新生成的事件，并调用apply方法来更新聚合的状态</li>
<li>将时间保持在事件存储库中</li>
</ol>
<p>更的聚合的步骤如下：</p>
<ol>
<li>从事件存储库加载聚合事件</li>
<li>使用其默认构造函数实例化聚合根</li>
<li>遍历加载的事件，并在聚合根上调用apply方法</li>
<li>调用process方法以生成新事件</li>
<li>遍历新生成的事件，并调用apply方法来更新聚合的状态</li>
<li>将时间保持在事件存储库中</li>
</ol>
<p><strong>使用乐观锁处理并发更新</strong></p>
<p>通过数据库的带有version列的表来作为乐观锁</p>
<p><strong>事件溯源和发布事件</strong></p>
<p>事件溯源将聚合作为事件进行持久化，并从这些事件中重建聚合的当前状态。同时可以将事件溯源作为可靠的事件发布机制。</p>
<p><strong>使用快照提升性能</strong></p>
<p>对于长生命周期的聚合可能会有大量时间，比如Account聚合，常见的解决方案是定期持久保存聚合的快照。</p>
<p>使用快照，将从快照创建聚合实例（SNAPSHOTS数据库表），而不是使用其默认的构造函数来创建聚合实例。如果聚合具有简单、易于串行化的结构，则快照可以使用JSON序列化。复杂结构的聚合可以使用Memento模式（备忘录模式）进行快照。</p>
<p><strong>幂等方式的消息处理</strong></p>
<ol>
<li>如果应用程序使用基于关系型数据库的事件存储库，则他可以将消息ID插入Precessed_Messages表，作为Events表的事件的事务的一部分。</li>
<li>如果应用程序使员工的是NoSQL的事件存储库，则他可以吧消息的ID存在处理它时的事件中。他通过验证聚合聚合的所有事件中是否包含该消息ID来做重复检测。</li>
</ol>
<p><strong>事件溯源的好处</strong></p>
<ol>
<li>可靠地发布领域事件</li>
<li>保留聚合的历史</li>
<li>最大限度地避免对象与关系的”阻抗失调”的问题</li>
<li>为开发者提供一个“时光机”</li>
</ol>
<p><strong>事件溯源的弊端</strong></p>
<ol>
<li>这类编程模式有一定的学习曲线</li>
<li>基于消息传递的应用程序的复杂性</li>
<li>处理事件的演化（前后兼容）有一定难度</li>
<li>删除数据存在一定难度</li>
<li>查询事件存储库非常有挑战性 （根据某个属性的值来查询）</li>
</ol>
<h2 id="实现事件存储库"><a href="#实现事件存储库" class="headerlink" title="实现事件存储库"></a>实现事件存储库</h2><p>看看作者的Eventuate 框架实现</p>
<h2 id="整合Saga和基于事件溯源的业务逻辑"><a href="#整合Saga和基于事件溯源的业务逻辑" class="headerlink" title="整合Saga和基于事件溯源的业务逻辑"></a>整合Saga和基于事件溯源的业务逻辑</h2><p>有时间实现一把Saga</p>
<h1 id="在微服务架构中实现查询"><a href="#在微服务架构中实现查询" class="headerlink" title="在微服务架构中实现查询"></a>在微服务架构中实现查询</h1><p>如何使用API组合模式或命令查询职责隔离（CQRS）模式，这两个模式用来查询分散在多个服务中的数据</p>
<p>在微服务架构中实现查询操作有两种不同的模式：</p>
<ol>
<li>API组合模式：这是最简单的方法，应尽可能使用。他的工作原理是让拥有数据的服务的客户端负责调用服务，并组合服务返回的查询结果</li>
<li>命令查询职责隔离（CQRS）模式：它比API组合模式更强大，但也更复杂。他维护一个或多个数据库视图，并组合服务返回的查询结果。</li>
</ol>
<h2 id="使用API组合模式进行查询"><a href="#使用API组合模式进行查询" class="headerlink" title="使用API组合模式进行查询"></a>使用API组合模式进行查询</h2><p><strong>什么是API组合模式</strong></p>
<p>API组合模式通过调用拥有数据的服务并组合结果来实现查询操作。他有两种类型的参与者：</p>
<ol>
<li>API组合器：他通过查询数据提供方的服务来实现查询操作</li>
<li>数据提供方服务：拥有查询返回部分数据的服务</li>
</ol>
<p><strong>API组合模式的设计缺陷</strong></p>
<p>使用此模式，你必须解决两个设计问题：</p>
<ul>
<li><p>确定架构中的哪个组件是查询操作的API组合器（可以是客户端、API Gateway、独立的服务）</p>
<p>API组合器要尽可能使用并行调用提供方服务，最大限度地缩短查询操作的响应时间，可以使用Java的CompletableFuture、RxJava等响应式API</p>
</li>
<li><p>如何编写有效的聚合逻辑</p>
</li>
</ul>
<p><strong>API组合模式的好处和弊端</strong></p>
<ul>
<li><p>好处</p>
<p>简单直观</p>
</li>
<li><p>弊端</p>
<ul>
<li>增加了额外的开销</li>
<li>带来了可用性降低的风险（需要涉及多个服务，这个使用可以使用缓存，或者返回不完整的数据）</li>
<li>缺乏事务数据一致性（因为没有隔离性，所以可能存在返回的数据一致性的情况）</li>
<li>不能解决大规模数据查询，因为需要内存连接</li>
</ul>
</li>
</ul>
<h2 id="使用CQRS模式实现查询"><a href="#使用CQRS模式实现查询" class="headerlink" title="使用CQRS模式实现查询"></a>使用CQRS模式实现查询</h2><p>当使用API组合无法有效实现多服务查询的时候，我们就需要考虑使用CQRS了，比如订单历史列表。</p>
<p>不同目的的查询需要的数据库可能是不一样的，如果有地址范围查询就适合mongo，如果数据有多个副本，那么调整就转变成了原始数据发生变化使其保持最新状态。</p>
<p><strong>什么是CQRS</strong></p>
<p>当在微服务架构中实现查询时经常遇到下面三个问题的时候，就可以开始考虑CQRS模式：</p>
<ul>
<li>使用API组合模式检索分散在多个服务中的数据会导致崩溃、低效的内存中的连接 </li>
<li>拥有数据的服务将数据存储在不能有效支持所需查询的表单或数据库中</li>
<li>隔离问题的考虑意味着，拥有数据的服务不一定是会实现查询操作的服务</li>
</ul>
<p>CQRS将持久化数据模型和使用数据的模块分为两部分：命令端和查询端。命令端模块和数据实现创建、更新和删除操作（CUD）。查询模块和数据模型实现查询（R）。查询端通过订阅命令端发布的事件，使其数据模型和命令端模式保持同步。查询端可能存在多个查询模型，与需要的查询类型一一对应。</p>
<p><strong>CQRS的好处和弊端</strong></p>
<ul>
<li>好处<ul>
<li>在微服务架构中高效地实现查询</li>
<li>高效地实现多种不同的查询类型</li>
<li>在基于事件溯源技术的应用程序中实现查询</li>
<li>更进一步地实现问题隔离（CQS）</li>
</ul>
</li>
<li>弊端<ul>
<li>更加复杂的架构</li>
<li>处理数据复制导致的延迟<ul>
<li>命令端你和查询端API提供版本信息，使其能够判断查询端是否过时，客户端可以轮询查询端的视图，知道他是最新的。</li>
<li>客户端在针对聚合的命令执行成功后，更新其本地版本的领域模型，而不必发出查询来克服复制可能带来的延迟。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>设计CQRS视图</strong></p>
<p>CQRS视图模块包括由一个或多个查询操作组成的API。他通过订阅由一个或多个服务发布的事件来更新它的数据库视图。</p>
<p>在开发视图模块时，你必须做出一些重要的设计决策：</p>
<ul>
<li>必须选择合适的底层数据库，并设计数据结构（文档数据库、文本搜索引擎、图数据库、关系型数据库（支持复杂的条件））</li>
<li>在设计数据访问模块时，需要确保更新是幂等的，并且能够处理并发更新（ES）</li>
<li>必须实现一种机制，可以高效的构建或重建视图（保存快照，做增量式构建）</li>
<li>决定如何设计视图的客户端，以应对复制延迟</li>
</ul>
<p>视图模块由数据访问对象（DAO）和辅助类组成，Dao实现又时间处理程序调用的更新操作以及查询模块调用的查询操作，<strong>同时它还必须处理并发更新并确保更新是幂等的</strong>。</p>
<h1 id="外部API模式"><a href="#外部API模式" class="headerlink" title="外部API模式"></a>外部API模式</h1><p>介绍了处理来自各种外部客户端请求的外部API模式</p>
<p><strong>不同客户端通常需要不同的数据，同时内网访问和外网访问也不一样，这个时候会发现，拥有单一、适合所有的API通常没有意义。</strong></p>
<h2 id="外部API的设计难题"><a href="#外部API的设计难题" class="headerlink" title="外部API的设计难题"></a>外部API的设计难题</h2><ol>
<li>多次客户端请求导致用户体验不加（一般也不会用）</li>
<li>缺乏封装导前端开发做出的代码修改影响后端（后端API和前端耦合了）</li>
<li>服务可能选用对客户端不友好的进程间通信机制（grpc、消息，前端需要http、websocket）</li>
</ol>
<p>当然会有很多问题，开发中都会遇到</p>
<h2 id="API-Gateway模式"><a href="#API-Gateway模式" class="headerlink" title="API Gateway模式"></a>API Gateway模式</h2><p><strong>模式：API Gateway</strong>：实现一个服务，该服务是外部API客户端进入基于微服务应用程序的入口点。他负责请求路由、API组合、身份验证和协议转化等各项功能。</p>
<p><strong>API Gateway的架构</strong> </p>
<p>API Gateway具有分层的模块化架构。其架构由两层组成：API层和公共层。API层由一个或多个独立的API模块组成。每个API模块都为特定客户端实现API。公共层实现共享功能，包括边缘功能：身份验证、访问授权、速率限制、缓存、指标收集、请求日志。</p>
<p><strong>API Gateway的好处和弊端</strong></p>
<ul>
<li><p>好处</p>
<p>封装了应用程序的内部结构。客户端不必调用特定服务，而是与API Gateway通信。</p>
</li>
<li><p>弊端</p>
<p>业务团队需要开发、部署和管理一个高可用的API Gateway组件。</p>
</li>
</ul>
<p><strong>API Gateway的设计难题</strong></p>
<ul>
<li>性能和可扩展性（Node实现的BFF）</li>
<li>使用响应式编程抽象编写可维护的代码（响应式是基于回调的，需要避免回调地狱）</li>
<li>处理局部故障（断路器）</li>
<li>成为应用程序架构中的好公民（可观测）</li>
</ul>
<h2 id="实现一个API-Gateway"><a href="#实现一个API-Gateway" class="headerlink" title="实现一个API Gateway"></a>实现一个API Gateway</h2><p>实现API Gateway有两种不同的方法：</p>
<ul>
<li><p>使用现成的API Gateway产品或服务</p>
<p>好处是不需要代码开发，但是灵活性最低，通常不支持API组合</p>
</li>
<li><p>使用API Gateway框架或Web框架作为起点，开发属于自己的API Gateway</p>
<p>灵活，但是需要开发工作；现有的API Gateway框架：Kong、Tracefix、Netflix Zuul、Spring Cloud Gateway或者使用基于图形的GraphQL</p>
</li>
</ul>
<h1 id="微服务架构中的测试策略"><a href="#微服务架构中的测试策略" class="headerlink" title="微服务架构中的测试策略"></a>微服务架构中的测试策略</h1><p>测试测试 <strong>TDD</strong></p>
<h2 id="微服务架构中的测试策略-1"><a href="#微服务架构中的测试策略-1" class="headerlink" title="微服务架构中的测试策略"></a>微服务架构中的测试策略</h2><p><strong>什么是测试</strong></p>
<p>测试是自动化测试，测试的目的是验证被测系统的行为。一组相关的测试用例集构成一个测试套件。</p>
<p>自动化测试通常包括四个阶段：</p>
<ol>
<li>设置环境</li>
<li>执行测试</li>
<li>验证结果</li>
<li>清理环境</li>
</ol>
<p><strong>使用模拟和桩进行测试</strong></p>
<p>如果我们的被测系统存在依赖，就会把测试复杂化，这个时候我们需要用<strong>测试替身</strong>来消除被测系统的依赖性。</p>
<p>有两种类型的测试替身：桩（stub，代替依赖性向被测系统发送调用的返回值）和模拟（mock，用来验证被测系统是否正确调用了依赖项），通常可以互相使用。</p>
<p><strong>测试的不同类型</strong>（基于范围）</p>
<ol>
<li>单元测试：测试服务的一小部分，例如类</li>
<li>集成测试：验证服务是否可以与集成设施服务（如数据库）或其他应用程序服务进行交互</li>
<li>组件测试：单个服务的验收测试</li>
<li>端到端测试：整个应用程序的验收测试</li>
</ol>
<p><strong>使用测试象限进行分类</strong></p>
<p>测试象限按两个维度对测试进行分类：</p>
<ul>
<li>测试是面向业务还是面向技术</li>
<li>测试的目标是协助开发还是寻找产品缺陷</li>
</ul>
<p>基于上面，有是中共不同的测试类别：</p>
<ol>
<li>Q1协助开发/面向技术：单元和继承测试</li>
<li>Q2协助开发/面向业务：组件和端到端测试</li>
<li>Q3寻找产品缺陷/面向业务：易用性和探索性测试</li>
<li>Q4寻找产品缺陷/面向技术：非功能性验收测试，如性能测试</li>
</ol>
<p><strong>消费者驱动的锲约测试</strong></p>
<p>服务消费者要为服务提供者提交锲约测试，防止服务提供者出现不兼容升级</p>
<p>两个流行的企业级契约测试框架是：Spring Cloud Contract、Pact系列框架</p>
<p><strong>部署流水线</strong></p>
<p>jenkins CI</p>
<h2 id="为服务编写单元测试"><a href="#为服务编写单元测试" class="headerlink" title="为服务编写单元测试"></a>为服务编写单元测试</h2><p>有两种类型的单元测试：</p>
<ul>
<li>独立型单元测试：使用针对类的依赖性模拟对象隔离测试类，控制器和服务类、消息处理器</li>
<li>协作型单元测试：测试一个类及其依赖项，领域对象（实例，值对象，saga），实体一般依赖值对象</li>
</ul>
<ol>
<li>为实体编写单元测试</li>
<li>为值对象编写单元测试</li>
<li>为saga编写单元测试</li>
<li>为领域服务编写单元测试</li>
<li>为控制器编写单元测试</li>
<li>为时间和消息处理程序编写单元测试</li>
</ol>
<h2 id="编写集成测试"><a href="#编写集成测试" class="headerlink" title="编写集成测试"></a>编写集成测试</h2><p>集成测试必须验证服务是否可以与其客户端和依赖性进行通信</p>
<ol>
<li>针对持久化层的集成测试（最好使用Docker）</li>
<li>针对基于REST的请求/响应式交互的集成测试 （契约）</li>
<li>针对发布/订阅式交互的集成测试</li>
<li>针对异步请求/响应式交互的集成契约测试</li>
</ol>
<h2 id="编写组件测试"><a href="#编写组件测试" class="headerlink" title="编写组件测试"></a>编写组件测试</h2><p>组件测试（验收测试）是针对软件组件的面向业务的测试。他们从组件客户端而不是内部实现的角度描述了所需的外部行为，这些测试源自用户故事或用例。Gherkin框架</p>
<p><strong>设计组件测试</strong></p>
<ul>
<li>进程内组件测试：使用常驻内存的 桩和模拟 代替器依赖性的服务，内存数据库什么的</li>
<li>进程外组件测试：使用容器</li>
</ul>
<h2 id="端到端测试"><a href="#端到端测试" class="headerlink" title="端到端测试"></a>端到端测试</h2><p>组件分别测试每个服务，端到端测试会测试整个应用程序。（docker compose 、k8s）</p>
<h1 id="开发面向生产环境的微服务应用"><a href="#开发面向生产环境的微服务应用" class="headerlink" title="开发面向生产环境的微服务应用"></a>开发面向生产环境的微服务应用</h1><p>介绍开发生产就绪服务的各个方面：安全性、外部化配置模式、服务可观测性模式（日志聚合、应用指标、分布式追踪）</p>
<h2 id="开发安全的服务"><a href="#开发安全的服务" class="headerlink" title="开发安全的服务"></a>开发安全的服务</h2><p>应用程序开发人员主要负责安全性的四个不同方面：</p>
<ol>
<li>身份验证：证明身份，放在API Gateway，可以使用oauth2</li>
<li>访问授权：控制权限，放在服务</li>
<li>审计：记录操作</li>
<li>安全的进程间通信：加密</li>
</ol>
<p>对于身份验证和访问授权在微服务中要集中，比如放在API Gateway中。</p>
<h2 id="设计可配置的服务"><a href="#设计可配置的服务" class="headerlink" title="设计可配置的服务"></a>设计可配置的服务</h2><p>服务中有很多配置，比如消息队列broker的位置，db的用户名和密码</p>
<p>外部化配置机制在运行时向服务实例提供配置属性值。主要有两种方法：</p>
<ul>
<li><p>推送模型：部署基础设施通过类似操作系统环境变量或配置文件，将配置属性传递给服务实例。</p>
<p>这种模型对于重新配置正在运行的服务很难</p>
</li>
<li><p>拉取模型：服务实例从配置服务器读取它所需要的配置属性。</p>
<p>配置服务器的实现有：版本控制系统如git、SQL和Nosql数据库，专用配置服务器 spring cloud config server</p>
</li>
</ul>
<h2 id="设计可观测的服务"><a href="#设计可观测的服务" class="headerlink" title="设计可观测的服务"></a>设计可观测的服务</h2><p>可以通过以下模式来设计可观测的服务：</p>
<ul>
<li>健康检查API：公开返回服务运行状况的接口。比如定期轮询healthy接口</li>
<li>日志聚合：记录服务活动并将日志写入集中式日志记录服务器，该服务器提供搜索和告警。比如graylog，elk</li>
<li>分布式跟踪：为每一个在服务之间跳转的外部请求分配唯一ID，并跟踪请求。比如jager，zipkin，可以用来看请求性能，利用aop（sleuth）</li>
<li>异常跟踪：向异常服务报告异常，该异常跟踪服务可以对异常进行重复数据删除（聚类），向开发人员发出报警并跟踪每个异常的解决方案。比如sentry</li>
<li>应用程序指标：服务运维指标，例如计数器和指标（包括基础设施的相关指标，如CPU、内存、磁盘利用率；应用程序级别的指标，如服务请求延迟和执行的请求数），并将他们公开给指标服务器。服务有两种方式向指标服务器提供数据：拉取或推动。比如prometheus（拉取），metircs</li>
<li>审计日志记录：记录用户操作，实现审计日志记录的方法：将审计日志记录代码添加到业务逻辑中，使用AOP，使用事件溯源。比如oplog。</li>
</ul>
<h2 id="使用微服务基底模式开发服务"><a href="#使用微服务基底模式开发服务" class="headerlink" title="使用微服务基底模式开发服务"></a>使用微服务基底模式开发服务</h2><p><strong>微服务基底：</strong> 异常追踪、日志记录、监控检测、外部化配置和分布式追踪是微服务架构需要解决的共性问题，我们需要在能够处理那些共性问题的<strong>框架或框架集合</strong>上构建服务。</p>
<p>Java：Spring Boot 和Spring Cloud；Golang：Go Kit和Micro</p>
<p>使用微服务基底的一个弊端：开发者必须需要保证使用的编程语言/平台组合，有与之对应的服务基底框架或类库。当前，微服务基底实现的许多功能很有可能由<strong>基础设施实现</strong>，比如网络相关的功能将由所谓的<strong>服务网格</strong>处理。</p>
<p><strong>服务网格：</strong> 把所有进出服务的网络流程通过一个网络层进行路由，这个网络层负责解决包括断路器、分布式追踪、服务发现、负载均衡和基于规则的流量路由等具有共性的需求。</p>
<p>当前的服务网格实现：Istio、Linkerd、Conduit</p>
<h1 id="部署微服务应用"><a href="#部署微服务应用" class="headerlink" title="部署微服务应用"></a>部署微服务应用</h1><p>介绍可用于部署服务的各种部署模式：虚拟机、容器、Serverless模式、服务网格</p>
<p><strong>部署</strong>包括两个相互关联的概念：部署流程和部署架构</p>
<p>物理机-&gt;虚拟机-&gt;容器-&gt;severless</p>
<p>生成环境必须包括四个关键的功能：</p>
<ol>
<li>服务管理接口，是开发人员能够创建、更新和配置服务</li>
<li>运行时服务管理：确保始终运行这所需数量的服务实例，必要时可以重启</li>
<li>监控：包括日志文件和各种应用指标</li>
<li>请求路由：将用户的请求路由到服务</li>
</ol>
<p>下面是四种重要的部署选项：</p>
<h2 id="编程语言特定的发布包格式"><a href="#编程语言特定的发布包格式" class="headerlink" title="编程语言特定的发布包格式"></a>编程语言特定的发布包格式</h2><p>Java：Jar包或War包</p>
<p>Node：源代码目录</p>
<p>Golang：可执行文件</p>
<p><strong>好处</strong></p>
<ul>
<li>快速部署，启动时间短</li>
<li>高效的资源利用，在同一台机器或同一进程汇中运行多个实例</li>
</ul>
<p><strong>弊端</strong></p>
<ul>
<li>缺乏对技术栈的封装</li>
<li>无法约束服务实例消耗的资源</li>
<li>在同一计算机上运行多个服务实例时缺少隔离</li>
<li>很难自动判定放置服务实例的位置（放在哪个服务器上，根据资源需要抉择）</li>
</ul>
<h2 id="将服务部署为虚拟机"><a href="#将服务部署为虚拟机" class="headerlink" title="将服务部署为虚拟机"></a>将服务部署为虚拟机</h2><p>将服务打包为机器镜像</p>
<p><strong>好处</strong></p>
<ul>
<li>虚拟机镜像封装了技术栈</li>
<li>隔离的服务实例</li>
<li>使用成熟的云计算基础设施</li>
</ul>
<p><strong>弊端</strong></p>
<ul>
<li>资源利用效率低（Java可能还怕资源不够，Node和Golang可能觉得有点浪费）</li>
<li>部署相对缓慢（构建虚拟机镜像通常需要几分钟，从镜像实例化虚拟机也需要时间）</li>
<li>系统管理的额外开销（给操作系统打补丁）</li>
</ul>
<h2 id="将服务部署为容器"><a href="#将服务部署为容器" class="headerlink" title="将服务部署为容器"></a>将服务部署为容器</h2><p>容器是一种更现代、更轻量级的部署机制，是一种操作系统级的虚拟化机制。</p>
<p>将服务打包为容器镜像，每个服务实例都是一个容器（container）。</p>
<p>创建容器时，可以指定它的CPU资源和内存资源，以及依赖于容器实现的I/O资源等。</p>
<p>在开发和测试阶段中，可以使用Docker Compose编排工具（单机），在生成环境中，需要配合类似K8s的容器编排工具（计算机资源池）。最后利用服务网格类似istio实现将部署流程（发布到生成环境）和发布流程（将正式流程切到新服务版本）分离。</p>
<p><strong>好处</strong></p>
<ul>
<li>封装技术栈，可以用容器的API实现对服务的管理</li>
<li>服务实例是隔离的</li>
<li>服务实例的资源受到限制</li>
</ul>
<p><strong>弊端</strong></p>
<p>需要承担大量的容器镜像管理工作</p>
<h2 id="Serverless-部署"><a href="#Serverless-部署" class="headerlink" title="Serverless 部署"></a>Serverless 部署</h2><p>终于可以不用管理系统了。（假笑）</p>
<p>使用公有云提供的Serverless部署机制部署服务。</p>
<p>开源Serverless框架 Apache Openwhisk和Fission For Kubernates</p>
<p>Serverless 的一种实现Fass，常用的场景：</p>
<ol>
<li>HTTP请求</li>
<li>事件</li>
<li>定时调用</li>
<li>直接使用API调用</li>
</ol>
<p>不同的公有云对Fass的支持不一样，我们要具体来看。</p>
<h1 id="微服务架构的重构策略"><a href="#微服务架构的重构策略" class="headerlink" title="微服务架构的重构策略"></a>微服务架构的重构策略</h1><p>“绞杀者”</p>
<h2 id="重构到微服务需要考虑的问题"><a href="#重构到微服务需要考虑的问题" class="headerlink" title="重构到微服务需要考虑的问题"></a>重构到微服务需要考虑的问题</h2><p><strong>为什么要重构单体应用</strong></p>
<p>单例地狱而引发的业务问题：</p>
<ul>
<li>交付缓慢：应用程序难以理解、维护和测试，开发人员你的工作效率低</li>
<li>充满故障的软件交付：缺乏可测试性意味着软件会经常出错</li>
<li>可扩展性差：</li>
</ul>
<p><strong>绞杀单体应用</strong></p>
<p><strong>绞杀者应用模式：</strong> 通过在遗留系统程序周围逐步开发新的（绞杀）应用程序来来实现应用程序的现代化。</p>
<ol>
<li><p>尽早并且频繁的体现出价值（为了让产品同意）</p>
<p>可以先将应用程序的高价值部分迁移到微服务架构。</p>
</li>
<li><p>尽可能对单体做出修改</p>
</li>
<li><p>部署基础设施不用太早</p>
</li>
</ol>
<h2 id="将单体应用重构为微服务架构的若干策略"><a href="#将单体应用重构为微服务架构的若干策略" class="headerlink" title="将单体应用重构为微服务架构的若干策略"></a>将单体应用重构为微服务架构的若干策略</h2><ol>
<li><p>将新功能实现为服务</p>
<p>需要考虑新功能能否作为一个服务，如果不能则继续在单体应用中开发，然后将该功能以及其他相关功能提取到自己的服务中</p>
</li>
<li><p>隔离表现层和后端</p>
<p>隔离之后就可以按API拆分后端服务</p>
</li>
<li><p>通过将功能提取到服务中来分解单体</p>
<p><strong>提取服务时会遇到以下这些调整</strong>：</p>
<ul>
<li>拆解领域模型（使用聚合，分离聚合）</li>
<li>重构数据库（使用领域事件数据复制，小数据频率低的通过RESTAPI访问）</li>
</ul>
<p>确定提取何种服务以及何时提取</p>
<ul>
<li>提取有益的服务（为了加速开发、解决性能、可扩展或可靠性问题、允许提取一些其他服务）</li>
<li>在确定应用模块（独立的域）之后排好优先级，跟着业务需求走</li>
</ul>
</li>
</ol>
<h1 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h1><p>很多实例可以回头再看看！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：目前微服务大行其道，当我们在谈微服务的时候，我们究竟在谈什么，我们究竟要思考哪些方面？那么这本书刚好能解答微服务的方方面面！
    
    </summary>
    
      <category term="读书笔记" scheme="http://bestlixiang.site/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="微服务" scheme="http://bestlixiang.site/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>《领域驱动设计——洞见》</title>
    <link href="http://bestlixiang.site/2020/11/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E6%B4%9E%E8%A7%81/"/>
    <id>http://bestlixiang.site/2020/11/17/读书笔记/领域驱动设计——洞见/</id>
    <published>2020-11-17T15:58:28.000Z</published>
    <updated>2020-11-17T15:59:26.020Z</updated>
    
    <content type="html"><![CDATA[<p>引：读完《实现领域驱动设计》，对于实践还是有些模糊，那就再通过《领域驱动设计——洞见系列》加加餐！<a id="more"></a></p>
<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><h2 id="DDD战略篇：架构设计的影响力"><a href="#DDD战略篇：架构设计的影响力" class="headerlink" title="DDD战略篇：架构设计的影响力"></a>DDD战略篇：架构设计的影响力</h2><p>系统健壮（能适应各种不确定性） 》 稳定 </p>
<p>软件设计共识：通过<strong>组件化</strong>完成<strong>关注点分离</strong>从而<strong>降低局部复杂度</strong> </p>
<p>软件架构设计的实质：让系统能够更快得响应外接业务的变化，并且使得系统能够持续演进</p>
<p>面向业务变化的架构：要求首先理解业务的核心问题，即由针对性的进行关注点分离来找到相对内聚的业务活动形成子问题域</p>
<p>打造架构响应力的方法：DDD通过下面两个方法（模式）解决：</p>
<ol>
<li>让团队中各个角色（从业务到开发测试）都能够采用<strong>统一的架构语言</strong>，从而避免组件划分过程中的边界错误</li>
<li><strong>让业务架构和系统架构形成绑定关系</strong>，从而建立针对业务变化的高响应力架构。（业务架构（描述功能）和系统(技术)架构的区别）</li>
</ol>
<h2 id="DDD战术篇：领域模型的应用"><a href="#DDD战术篇：领域模型的应用" class="headerlink" title="DDD战术篇：领域模型的应用"></a>DDD战术篇：领域模型的应用</h2><p>DDD构建的元模型元素脑图（可以想象的）提供了一个元模型体系，通过这个元模型我们会对战略建模过程冲识别出来的问题子域进行抽象，而通过抽象来知道最后的落地实现。</p>
<p><strong>业务对象的抽象：</strong> 通过对业务问题的子域划分，我们找到了一些关键的<strong>业务对象</strong>，在开始抽象前一个必须的步骤就是<strong>讲故事</strong>！故事是关于这个子域的<strong>业务问题</strong>或者<strong>提供的业务能力</strong>的故事。<strong>故事必须有清晰的业务场景和业务对象之间的交互</strong>。只有当我们能够讲清楚业务场景的时候，才应该开始抽象的的步骤。对于一个业务对象，常见的抽象可以是“实体（Entity）”和“值对象（Value Object）”。这两个抽象方式在定义上的区别是。实体需要给予一个唯一标识，值对象不需要。当更常用的区别是<strong>实体应该使用有一个连续的生命周期。然后在生命周期保持实体状态的一致性。</strong> 所以会发现实体的成本会很大，值对象的成本会低一些，所以会优先考虑值对象建模。</p>
<p><strong>聚合的封装：</strong> 聚合可以让我们把多个实体和值对象的业务封装封装起来。识别聚合是认知潜在核心业务规则的过程。而定义出来的聚合是在大家共识基础上对核心业务规则的封装。</p>
<p><strong>领域服务的定义：</strong> 例子（转账、订单消息通知）</p>
<p><strong>Repositories的使用：</strong> 更多的是粗颗粒度的对象。在DDD这个方法里可以认为映射对象是我们的聚合。然后针对聚合里的实体创建出对应的DAO（可能和ORM框架有关）。这里要注意：不是有一个查询就一定又一个repo与之对应，未尝不可以让服务直接对数据存储实现。记住我们抽象的目标是让建模更加简单，抽象的过程中应该保持灵活。</p>
<p><strong>界限上下文的意义：</strong> DDD通过对子问题域的划分依据进行了对业务能力的分解。而界限上下文在解决方案域中完成了进一步分解。我们不能认为子问题域和界限上下文有严格的一对一的关系，但大多数情况下一个子问题域会被设计成一个或多个界限上下文。我们的重点在区分子问题域和解决方案域。这是落地DDD最困难的地方，也是判断一个架构师能力进阶的分水岭。</p>
<p><strong>战略上要藐视敌人，战术上要重视敌人</strong>。</p>
<p>业务需求是我们的朋友，<strong>战略上要重视朋友，战术上要简化建模</strong></p>
<h2 id="DDD实战篇：分层架构的代码结构"><a href="#DDD实战篇：分层架构的代码结构" class="headerlink" title="DDD实战篇：分层架构的代码结构"></a>DDD实战篇：分层架构的代码结构</h2><p>领域驱动设计DDD，提出了从业务设计到代码实现一致性的要求，不再对分析模型和实现模型进行区分。</p>
<p>在整个DDD的建模过程中，我们更多的是关注核心领域模型的建立，我们认为<strong>完成业务需求</strong>就是在领域模型上的一些列操作（应用）。这些包括了对核心实体状态的改变、领域事件的存储，领域服务的调用等。</p>
<p><strong>分层架构：</strong></p>
<p>Service Layer -&gt; Domain -&gt; Repositories</p>
<p>当我们谈论代码结构的时候，针对的是一个经过DDD建模后的子问题域，这是明确的组件化边界。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">domain</span><br><span class="line">gateways</span><br><span class="line">interface</span><br><span class="line">repositores</span><br><span class="line">services</span><br></pre></td></tr></table></figure>
<p>领域模型一定要可测试，测试的核心原则是让用例尽量测试业务需求而不是实现方式本身。满足业务需求是我们的目标，实现方式可能有多种。不要让持续重构的代码影响到测试用例。</p>
<p>DDD从更高的视角，TDD从更低的视角。</p>
<p>我们反对前期设计的大而全，但是我们认可前期对核心领域模型的分析和设计，这样能够帮助我们更快的响应后续业务的业务变化（即核心模型之上的应用），以为核心的模型变化的频率较外部应用会低很多。如果核心领域模型变化剧烈，那么可能我们业务发生了根本性的变化，需要建立新的模型。</p>
<h2 id="DDD的终极大招——By-Experience"><a href="#DDD的终极大招——By-Experience" class="headerlink" title="DDD的终极大招——By Experience"></a>DDD的终极大招——By Experience</h2><p>架构设计的最后终极大招还是By Exprience——考经验吃饭。从战略角度的subdomain（子问题域的分化）到战术建模层面的Entity和VO的选择，最终的决策很可能不是完全理性，经验这个感性的东西发挥这很大的作用。</p>
<h1 id="通用语言、领域、界限上下文"><a href="#通用语言、领域、界限上下文" class="headerlink" title="通用语言、领域、界限上下文"></a>通用语言、领域、界限上下文</h1><h2 id="如何说好一门通用语言"><a href="#如何说好一门通用语言" class="headerlink" title="如何说好一门通用语言"></a>如何说好一门通用语言</h2><p>在DDD中，通用语言是以界限上下文为边界的。如果一个产品或者项目有个多个界限上下文，我们就需要为每个界限上细问定义通用语言。界限上下文提供了一个语义边界，来保持通用语言和领域概念的意义对应关系。</p>
<p>通过添加约束消除通用语言的歧义。在构建通用语言时，有两个额外的约束条件：子域和界限上下文。</p>
<p><strong>在DDD中，软件的核心是其为客户解决领域相关的问题的能力。</strong></p>
<p>为了分解问题域的复杂度，问题域又会被拆解为多个子域，每个子域都要明确待解决的业务问题和业务流程，以及通过解决业务问题为企业带来了什么样的业务价值。</p>
<p>对于通用语言而言，<strong>子域</strong>解释了通用语言和现实业务活动的关系；<strong>界限上下文</strong>提供了一个语义边界，来保持通用语言和领域模型的一一对应关系；<strong>上下文映射</strong>则提供了不同界限上下文中的通用语言的转换关系。</p>
<h2 id="当Subdomain遇见Bound-Context"><a href="#当Subdomain遇见Bound-Context" class="headerlink" title="当Subdomain遇见Bound Context"></a>当Subdomain遇见Bound Context</h2><p>《领域驱动设计精粹》</p>
<p><strong>区分问题和解决方案是一个老大难问题</strong></p>
<p>区分SubDomain的重要性，比如淘宝专注解决吸引消费者，京东专注解决物流速度。</p>
<p>雷布斯：不要用战术上的勤奋掩盖战略上的懒惰</p>
<p><strong>Subdomain和Bound Context的对应关系</strong></p>
<p>一对多的映射可能是最优的选择。</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="从三明治到六边形"><a href="#从三明治到六边形" class="headerlink" title="从三明治到六边形"></a>从三明治到六边形</h2><p>现实世界的软件开发时复杂的，复杂性并不体现在具体的技术栈上。软件真正复杂的部分往往在是业务本身。</p>
<p>三明治：展现层、应用层（服务层）、数据访问层</p>
<p>六边形（端口和适配器）：内部是业务的核心，即DDD中强调的领域模型；外部则是类似RestFul API、SOAP、AMQP、数据库、内存、文件系统、以及自动化测试</p>
<h2 id="端口和适配器架构——DDD好帮手"><a href="#端口和适配器架构——DDD好帮手" class="headerlink" title="端口和适配器架构——DDD好帮手"></a>端口和适配器架构——DDD好帮手</h2><p>如何快速获取经验？无非是多练，但是练了要讨论和总结</p>
<p><strong>架构的定义：</strong> 应用应能<strong>平等</strong>地被用户、其他程序、自动化测试或脚本<strong>驱动</strong>，也可以<strong>独立</strong>于其最终的运行时设备和数据进行<strong>开发和测试</strong>。</p>
<p>端口和适配器架构由端口和适配器组成，端口是指应用的入口和出口（入口可以理解为usecase，出口可以理解为Repository吧）。而适配器分为两种，主适配器（Driving Adapter）代表用户如何使用应用，即接受用户输入；次适配器（Driven Adapter）实现应用功能的出口端口，向外部工具执行操作。</p>
<p><img src="https://static001.infoq.cn/resource/image/fa/5d/fa3131fdcf3f5241442ecd9e8b00105d.png" alt="img"></p>
<p><img src="https://static001.infoq.cn/resource/image/57/4d/576a56f06a82ca80a7ccafd0e537df4d.png" alt="img"></p>
<p>端口和适配器的优势是突出了分层不是重点，技术实现隔离才是关键</p>
<p><img src="https://static001.infoq.cn/resource/image/16/f1/161e6eb5d57c46af94d5947928b9f2f1.png" alt="img"></p>
<h1 id="领域事件"><a href="#领域事件" class="headerlink" title="领域事件"></a>领域事件</h1><h2 id="识别领域事件"><a href="#识别领域事件" class="headerlink" title="识别领域事件"></a>识别领域事件</h2><p><strong>领域事件</strong>是用特定方式（已发生的事态）表达发生在问题域中的重要事情，是领域通用语言的一部分。</p>
<p>在DDD建模过程中，以领域事件为线索逐步得到领域模型已经成为了主流的时间，即：<strong>事件风暴</strong>。</p>
<p>事件风暴是以更专注的方式发现与提取领域事件，并将以领域事件为中心的概念模型组件演化成以聚合为中心的领域模型。</p>
<p>不同场景产生领域事件的方式不一样</p>
<h2 id="在微服务中使用领域事件"><a href="#在微服务中使用领域事件" class="headerlink" title="在微服务中使用领域事件"></a>在微服务中使用领域事件</h2><p>在DDD中有一条原则：一个业务用例对应一个事务，一个事务对应一个聚合根，也即在一次事务中，只能对一个聚合根进行操作。但是对于一个用例操作两个聚合根的时候就容易违背上面的原则。通过引入领域事件，我们可以很好解决上诉问题。总的来说，领域事件给我们带来了以下好处：</p>
<ul>
<li>解耦微服务（界限上下文）</li>
<li>帮助我们深入理解领域模型</li>
<li>提供审计和报告的数据来源</li>
<li>迈向事件溯源ES和CQRS等</li>
</ul>
<p><strong>事件风暴</strong>是一项团队活动，旨在通过领域事件识别出聚合根，进而划分微服务的界限上下文。在活动中，团队先通过头脑风暴罗列出领域中所有的领域事件，整合之后形成最终的领域事件集合。然后对于每一个事件，标注出导致该事件的命令（Command），在然后为每个事件标注出命令发起方的角色，命令可以是用户发起，也可以是第三方调用或者定时器触发等。最后对事件进行分类整理出聚合根以及界限上下文。</p>
<p><strong>发布领域事件</strong></p>
<p>在使用领域事件时，我们通常采用”发布-订阅“的方式来集成不同的模块或系统。在单个微服务的内部，我们可以使领域事件来集成不同的功能组件。</p>
<p>通常，领域事件产生与领域对象中，或者更准确的说是产出与聚合根中，在具体编码实现时，有多种方式可用于发布领域事件，一种直接的方式是在聚合根中直接调用发布事件的service对象。另一种方式是使用EventPublisher的静态方法来发布领域事件。还有一种是采用在聚合根中临时保存领域事件。在Repository发布事件，并及时清楚events集合。还有一种是在聚合根方法中直接返回领域事件</p>
<p><strong>业务操作和时间发布的原子性</strong></p>
<p>虽然在不同的聚合根之间我们采用了基于领域事件的最终一致性，我是在业务操作和事件发布之间我们依然采用强一致性。我们可以使用本地事件表来保证。当然最重要的还是将事件的消费方创建为幂等的。</p>
<h2 id="事件驱动是什么？"><a href="#事件驱动是什么？" class="headerlink" title="事件驱动是什么？"></a>事件驱动是什么？</h2><p>在领域内有变化发生时，发送事件消息来通知其他系统。时间通知的一个关键点是源系统并不关心外部系统的响应。通常它根本不期待任何结果，及时有也是间接的。发送事件的逻辑流与响应该事件的逻辑流之间会有显著的而格力。</p>
<p><strong>事件不需要包含太多数据</strong>，通常只有一些ID信息和一个指向发送方、可供查询更多信息的链接。接收方知道他已经变化，并且接受到关于变化的最少信息，随后向发送方发出请求，已决定下一步该做什么。</p>
<p><strong>CQRS</strong> 命令查询职责分离是指读取和写入分别拥有单独的数据结构。和事件没有关系</p>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="DDD-amp-MicroServices"><a href="#DDD-amp-MicroServices" class="headerlink" title="DDD &amp; MicroServices"></a>DDD &amp; MicroServices</h2><p>Microservices（微服务架构）和DDD（领域驱动设计）是时下最炙手可热的两个技术词汇。它们之间的关系是什么呢？</p>
<p>DDD是Eric Evans于2003年出版的书名，同时也是这个架构设计方法名的起源。DDD的想法是让我们的软件实现和一个演进的架构模型保持一致，而这个演进的模型来自于我们的业务需求。</p>
<p>每个人能够认知的复杂度都是有限的，在面对高复杂度的时候我们会做<strong>关注点分离</strong>，这是一个最基本的哲学原则。显然在针对复杂业务场景进行建模时，我们也会应用此原则。这个时候去<strong>分离关注点</strong>一般可以从两个维度出发：</p>
<ul>
<li>技术维度分离，类似MVC这样的分层思想是我们广泛接受的。</li>
<li>业务维度分离，根据不同的业态划分系统，比如按售前、销售、售后划分。</li>
</ul>
<p>从本质上作为一种<strong>架构设计方法</strong>的DDD和作为一种<strong>架构风格</strong>的Microservices都是为着追求高响应力目标而从业务视角去分离复杂度的手段。</p>
<p><strong>为了解释清楚这个问题让我们极简化架构设计为以下三个层面工作</strong>：</p>
<ul>
<li>业务架构：根据业务需求设计业务模块及交互关系。</li>
<li>系统架构：根据业务需求设计系统和子系统的模块。</li>
<li>技术架构：根据业务需求决定采用的技术及框架。</li>
</ul>
<p><img src="http://insights.thoughtworkers.org/wp-content/uploads/2017/07/layers.png" alt="img"></p>
<p><strong>DDD的核心诉求就是能够让业务架构和系统架构形成绑定关系，从而当我们去响应业务变化调整业务架构时，系统架构的改变是随之自发的。</strong></p>
<p>这个变化的结果有两个：</p>
<ul>
<li>业务架构的梳理和系统架构的梳理是同步渐进的，其结果是划分出的业务上下文和系统模块结构是绑定的。</li>
<li>技术架构是解耦的，可以根据划分出来的业务上下文的系统架构选择最合适的实现技术。</li>
</ul>
<p><strong>值得一提的是采用DDD这种架构设计方法并不一定就产生Mircoservices这种架构风格</strong>，往往会推荐用大颗粒度的服务来包含业务分析过程中发现的不确定点，以避免拆分后变化过度频繁带来的双向修改成本。</p>
<p><strong>DDD成功运用的基础就是创造让业务和系统这两种不同认知模型逐步统一的环境。</strong></p>
<p><strong>成功的DDD方法运用是贯穿系统的整个生命周期的，这个过程中业务和技术的协作是持续发生的。</strong></p>
<h2 id="服务拆分与架构演进"><a href="#服务拆分与架构演进" class="headerlink" title="服务拆分与架构演进"></a>服务拆分与架构演进</h2><p>企业想要实施微服务架构，经常问到的第一个问题是，怎么拆？如何从单体到服务化的结构？第二个问题是拆完后业务变了增加了怎么办？另外，我们想要改变的系统往往已经成功上线，并有着活跃的用户。那么对其拆分还需要考虑现有的系统运行，如何以安全最快最低成本的方式拆分也是在这个过程中需要回答的问题。</p>
<p>架构演进路上，我们遇到的主要挑战如下：</p>
<ul>
<li><p>如何拆？即如何正确理解业务，将单体结构拆分为服务化架构？</p>
<p>首先需要将客户、体验设计师、业务分析师、技术人员集结在一起对业务需求进行沟通，随后对其进行领域划分，确定限界上下文 (Boundary Context)，也称<strong>战略建模</strong>。</p>
<p><img src="https://static001.infoq.cn/resource/image/e0/c0/e086a4aa43a176a855f32102753567c0.png" alt="img"></p>
<p>一个业务领域或子域是一个企业中的业务范围以及在其中进行的活动，核心子域指业务成功的主要促成因素，是企业的核心竞争力；通用子域不是核心，但被整个业务系统所使用；支撑子域不是核心，不被整个系统使用，该能力可从外部购买。<strong>一个业务领域和子域可以包括多个业务能力，一个业务能力对应一个服务。领域的边界即限界上下文，也是服务的边界，它封装了一系列的领域模型</strong>。</p>
<p>一个业务流程代表了企业的一个业务领域，<strong>业务流程所涉及的数据或角色或是通用子域，或是支撑子域，由其在企业的核心竞争力的角色所决定</strong>。比如企业有统一身份认证，决策不同部门负责不同的流程任务，那么身份认证子域并不产生业务价值，不是业务成功的促成因素，但是所有流程的入口，因而为通用子域，可为单独服务；<strong>而部门负责的业务则为核心子域</strong>。</p>
<p><strong>“旧的不变，新的创建，一步切换，旧的再见”</strong></p>
<p>通过识别内部的被拆模块，对其增加接口层，将旧的引用改为新接口调用；随后将接口封装为 API，并将对接口的引用改为本地 API 调用；最后将新服务部署为新进程，调用改为真正的服务 API 调用。</p>
<p><strong>在拆分步骤上我们更多的推荐数据库先行，通过重复schema 同步数据，对数据库的读写操作分别进行迁移。如下图所示：</strong></p>
<p><img src="https://static001.infoq.cn/resource/image/e7/6d/e77532693b03492dd321c94723046a6d.jpg" alt="img"></p>
</li>
</ul>
<ul>
<li><p>拆完后业务变了增加了怎么办？即在业务需求不断发展变化的前提下，如何持续快速地演进？</p>
<p>客户的业务是在变化的，我们对业务的认知也是逐渐的过程，所以 Martin Fowler 在他的文章中提出，系统的初期建议以单体结构开始，随业务发展决定其是否被拆分或合并。那么这也意味着这样构建的服务在它的生命周期中必然会持续被拆分或合并。那么为了实现这样一个目标，使系统拥有快速的响应力，也要求这样的拆分必然是高效的低成本的。</p>
<p>因此，服务的设计需要满足如下的原则：</p>
<ul>
<li><strong>服务要有明确的业务边界，以单体开始并不意味着没有边界。 服务要有边界，即使以单体开始也要定义单体时期的边界</strong>。</li>
<li>服务要有明确清晰的契约设计，即对外提供的业务能力。（提供各种版本）</li>
<li>服务内部要保持高度模块化，才能够容易的被拆分。</li>
<li>可测试。</li>
</ul>
</li>
<li><p>如何安全地持续地拆？即如何在不影响当下系统运行状态的前提下，持续安全地演进？</p>
<p>一场架构层次的重构，在这样的路上同样需要：</p>
<ul>
<li>坏味道驱动，架构的坏味道是代码坏味道在更高层次的展现，也就意味着架构的混乱程度同样反映了该系统代码层的质量问题。</li>
<li>安全小步的重构。</li>
<li>有足够的测试进行保护 - 契约测试。</li>
<li>持续验证演进的方向。</li>
</ul>
</li>
<li><p>如何保证拆对了？</p>
<p>拆分不能没有目标，尤其在具有风险的架构层次拆分更需谨慎。</p>
<p>其实要回答这个问题，还是要回到拆分之初：为什么而拆？，可能是因为政治原因、业务发展需要，系统集成驱动</p>
</li>
<li><p>拆完了怎么保证不被破坏？</p>
</li>
</ul>
<p>最后，<strong>勿忘初心、且行且演进</strong></p>
<h2 id="微服务案例回顾"><a href="#微服务案例回顾" class="headerlink" title="微服务案例回顾"></a>微服务案例回顾</h2><p>架构的关键在于构造合理的封装抽象。</p>
<p>在<strong>分布式系统</strong>中我们关注组件、组件间的通信以及伴随的工程实践。<strong>微服务</strong>在企业应用的上下文中就<strong>技术约束和业务价值间达成了更好的平衡</strong>。</p>
<p>服务的设计不只聚焦于当下需求，更需要考虑价值定位和产品愿景。</p>
<p>如今我们对服务的定义已经超越了技术组件，领先的组织已经在尝试将design thinking, business operating model应用到微服务设计中。<strong>业务逻辑</strong></p>
<p><strong>服务间的集成应该依赖封装好的显示接口，而不是数据库这种实现细节</strong>。我们应该在兼顾数据一致性的情况下，为每个微服务分配独立的db schema甚至db instance。</p>
<p><strong>Technologies come and go, Principles stay forever。</strong></p>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="开发者的第0个迭代"><a href="#开发者的第0个迭代" class="headerlink" title="开发者的第0个迭代"></a>开发者的第0个迭代</h2><ol>
<li><p>从写好Readme开始</p>
<ul>
<li>项目简介：用一两句话简单描述该项目实现的业务功能</li>
<li>技术选型：列出项目技术栈、包括语言和中间件等</li>
<li>本地构建：列出本地开发过程中所用到的工具命令</li>
<li>领域模型：核心领域模型概念，比如电商系统来说有Order、Product等</li>
<li>测试策略：自动化测试如何分类，哪些必须写测试，哪些没有必要写测试</li>
<li>技术架构：技术架构图</li>
<li>部署架构：部署架构图</li>
<li>外部依赖：项目运行时所依赖的外部集成方，比如订单系统会依赖会员系统</li>
<li>环境信息：各个环境的访问方式，数据库连接等</li>
<li>编码实践：统一的编码实践，比如一次处理原则、分页封装等</li>
<li>FAQ：开发过程中常见问题的解答</li>
</ul>
</li>
<li><p>一键式本地构建</p>
<ul>
<li>生成IDE工程：idea.sh，生成IntelliJ工程问题并自动打开InteliJ</li>
<li>本地运行：run.sh，本地启动项目，自动 启动本地数据库，监听调试端口5005</li>
<li>本地构建：local-build.sh，有本地构建成功才能提交代码</li>
</ul>
</li>
<li><p>目录结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gradle</span><br><span class="line">src</span><br><span class="line">idea.sh</span><br><span class="line">local-build.sh</span><br><span class="line">run.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于业务分包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">order</span><br><span class="line">  model</span><br><span class="line">common</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动化测试分类</p>
<ul>
<li>单元测试：核心的领域模型，包括领域对象、Factory类、领域服务类</li>
<li>组件测试（集成测试）：不适合写单元测试但是又必须测试的类，如Repository</li>
<li>API测试：模拟客户端测试各种API接口，需要启动程序</li>
</ul>
</li>
<li><p>日志处理</p>
<ul>
<li>在日志中加入请求标识，便于链路追踪，如logback的MDC功能</li>
<li>集中式日志管理，在多节点部署的场景下，各个节点的日志是分散的，为此可以引入ELK、Graylog之类的工具将日志统一输出到ElasticSearch中</li>
</ul>
</li>
<li><p>异常处理</p>
<ul>
<li>向客户端提供格式统一的异常返回</li>
<li>异常信息中应该包含足够多的上下文信息，最好是结构化的数据以便与客户端解析</li>
<li>不同类型的异常应该包含唯一标识，以便客户端精确识别</li>
<li>异常处理通常有两种方式，一种是层级式，即每种具体的异常都对应了一个异常类，这个类最终继承自某个父类；另一种是单一式，即整个程序中只有一个异常类，再以一个字段拿来区分不同的异常场景。</li>
</ul>
</li>
<li><p>后台任务与分布式锁</p>
</li>
<li><p>统一代码风格</p>
<ul>
<li>客户端的请求数据类统一使用相同后缀，比如Command</li>
<li>返回给客户端的数据统一使用相同后缀，比如Representation</li>
<li>统一对请求处理的流程框架，比如采用传统的3层架构或者DDD战术模式</li>
<li>提供一直的异常返回</li>
<li>提供统一的分页结构类</li>
<li>明确测试分类以及统一的测试基础类</li>
</ul>
</li>
<li><p>静态代码检查</p>
</li>
<li><p>健康检查</p>
</li>
<li><p>API文档 swagger</p>
</li>
<li><p>数据库迁移 ddl文件</p>
</li>
<li><p>多环境构建</p>
<ul>
<li>local</li>
<li>ci</li>
<li>dev</li>
<li>qa</li>
<li>uat</li>
<li>prod</li>
<li>cors 跨域</li>
</ul>
</li>
</ol>
<h2 id="领域驱动设计（DDD）编码实践"><a href="#领域驱动设计（DDD）编码实践" class="headerlink" title="领域驱动设计（DDD）编码实践"></a>领域驱动设计（DDD）编码实践</h2><p>战略设计更偏向于软件架构，战术设计更偏向于编码实践</p>
<p><strong>实现业务的三种常见方式</strong></p>
<ol>
<li><p>基于”Service + 贫血模型”的实现</p>
<p>特点：存在一个贫血的领域对象，业务逻辑通过一个Service类实现，然后通过setter方法更新领域对象、最后通过DAO保存到数据库中 （业务逻辑泄漏）</p>
</li>
<li><p>基于事务脚本的实现</p>
<p>领域对象都没有存在的必要，但是增加了更多的DAO方法，此时DAO不再是对持久化的封装，而且也会包含业务逻辑</p>
</li>
<li><p>基于领域对象的实现</p>
</li>
</ol>
<p><strong>基于业务的分包</strong></p>
<p>业务分包即通过软件锁实现的业务功能进行模块划分，而不是从技术角度划分（比如划分出service和infrastructure）。在战术实践中，所采用的原则逃离不了“内聚性”和“职责分离”等基本原则。</p>
<p>在DDD中，聚合根是主要业务逻辑的承载体，也是内聚性原则的典型代表，因此通常的做法便是基于聚合根进行顶层包的划分。比如电商项目的两个聚合根对象Order和Product。</p>
<p><strong>领域模型的门面——应用服务</strong></p>
<p>在DDD实践中，自然应该采用自顶向下的实现方式。ApplicationService实现遵循一个很简单的原则，即一个业务用例对应ApplicaitonSerivce上一个业务方法。<strong>在应用服务上实现事务</strong>。</p>
<p>Application需要遵循以下原则：</p>
<ul>
<li>业务方法与业务用例一一对应</li>
<li>也无法方法与事务一一对应：每一个业务方法均构成独立的事务边界</li>
<li>本身不应该包含业务逻辑</li>
<li>与UI和通信协议无关</li>
</ul>
<p><strong>业务的载体——聚合根</strong></p>
<p>除了内聚性和一致性，聚合根还有以下特征：</p>
<ol>
<li>聚合根的实现应该与框架无关</li>
<li>聚合根之间的应用通过ID完成，一次业务用例只会更新一个聚合根，所以在聚合根去引用其他聚合根的整合没有任何好处</li>
<li>聚合根内部的所有变更都必须通过聚合根改成，为了保证聚合根的一致性，同时避免聚合根内部逻辑向外泄露。</li>
<li>如果一个事务要更新多个聚合根，要考虑引用消息机制和事件驱动架构，异步更新其他聚合根</li>
<li>聚合根不应该引用基础设施</li>
<li>外接不应该只有聚合根内部的数据结构</li>
<li>尽量使用小聚合</li>
</ol>
<p><strong>实体vs值对象</strong></p>
<p>实体：ID唯一，具有变化的生命周期</p>
<p>值对象：值是不可变的</p>
<p><strong>聚合根的家——资源库</strong></p>
<p>在所有对象对象中，只有聚合根才配得上拥有Repository，而DAO没有这种约束</p>
<p>有的DDD实践者，任务一个纯粹的Repository值应该包含这两个方法（Save和ByID）</p>
<p><strong>创生之柱——工厂</strong></p>
<p>创建聚合根通常通过设计模式的工厂模式完成</p>
<p>聚合根的创建可简单可复杂，有时可能直接调用构造函数即可，而有时却存在一个复杂的构造流程，比如需要调用其他系统获取数据，通过来说，Factory有两种实现方式：</p>
<ol>
<li>直接在聚合根中实现Factory方法，常用于简单创建过程</li>
<li>独立的Factory类，用于一定复杂度的创建过程，或者创建逻辑不适合放在聚合根上（比如IDGenerator）</li>
</ol>
<p><strong>必要的妥协——领域服务</strong></p>
<p>DomainService用来处理聚合根不能处理的业务方法，越少越好。</p>
<p><strong>Command对象</strong></p>
<p>从技术上将，Command对象是一种类型的DTO对象，在controller中所接受写操作都需要通过Command进行包装，在Command比较简单（比如只有一两个字段）的情况下Controller可以将Command解开，将其中的数据直接传给ApplicationService、而在Command中数据字段比较多的时候，可以将Command对象直接传递给ApplicationService。<strong>具体怎么传只是一个编码习惯上的选择</strong>。</p>
<p><strong>写操作</strong></p>
<ol>
<li>通过聚合根完成业务请求</li>
<li>通过Factory完成聚合根的创建</li>
<li>通过DomainService完成业务请求</li>
</ol>
<p><img src="https://insights.thoughtworks.cn/wp-content/uploads/2019/06/6.-DDD%E5%AE%9E%E7%8E%B0%E8%BD%AF%E4%BB%B622%E5%86%99%E6%93%8D%E4%BD%9C22%E7%9A%843%E7%A7%8D%E5%9C%BA%E6%99%AF.png" alt="DDD实现软件&quot;写操作&quot;的3种场景"></p>
<p>创建聚合根通过Factory完成，业务逻辑优先在聚合根边界内完成，聚合根中不合适放置的业务逻辑才考虑放在DomainService中。</p>
<p><strong>读操作</strong></p>
<p>在DDD的写操作中，我们需要严格按照应用服务-&gt;聚合根-&gt;资源库的接口进行编码，而在读操作往往采用下面的方式：</p>
<ol>
<li><p>基于领域模型的读操作</p>
<p>优点：直接使用Repository读取数据即可</p>
<p>缺点：读操作完全束缚与聚合根的边界划分，繁琐低效；基于不同的查询条件返回数据，导致Repository处理太多查询逻辑，偏离Repository应该承担的责任</p>
</li>
<li><p>基于数据模型的读操作</p>
<p>绕开资源库和聚合，直接从数据库中读取客户端所需要的数据，此时写操作和读操作共享的只是数据库。通过一个专门的XXRepresentationService直接从数据库中读取数据。（用这种吧）</p>
</li>
<li><p>CQRS</p>
<p>与“基于数据模型的读操作”不同的是，在CRQS中写操作和读操作使用不同的数据库，数据从写模型数据库同步到读模型数据库，<strong>通常通过领域事件的形式同步变更信息</strong>。</p>
<p><img src="https://insights.thoughtworks.cn/wp-content/uploads/2019/06/7.-CQRS%E6%9E%B6%E6%9E%84.png" alt="CQRS架构"></p>
<p>这样依赖，读操作便可以根据自身所需独立设计数据结构，而不用受写模型数据结构的牵制。</p>
<p><img src="https://insights.thoughtworks.cn/wp-content/uploads/2019/06/8.-DDD%E8%AF%BB%E6%93%8D%E4%BD%9C%E7%9A%843%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.png" alt="DDD读操作的3种实现方式"></p>
</li>
</ol>
<p>无论哪种读操作，都需要遵循一个原则：领域模型中的对象不能直接返回给客户端。</p>
<p>在读操作汇总，我们通过Represention进行展现数据的统一</p>
<h2 id="事件驱动架构（EDA）编码实践"><a href="#事件驱动架构（EDA）编码实践" class="headerlink" title="事件驱动架构（EDA）编码实践"></a>事件驱动架构（EDA）编码实践</h2><h3 id="领域事件的建模"><a href="#领域事件的建模" class="headerlink" title="领域事件的建模"></a>领域事件的建模</h3><p>领域事件是DDD中的一个概念，表示的是在一个领域中所发生的一次对业务有价值的事情，落到技术层面就是在一个业务实体对象(通常来说是聚合根)的状态发生了变化之后需要发出一个领域事件。</p>
<p><strong>创建领域事件</strong></p>
<p>在建模领域事件时，首先需要记录事件的一些通用信息，比如唯一标识ID和创建时间等</p>
<p>在DDD场景下，领域事件一般随着聚合根状态的更新而产生，另外，在事件的消费方，有时我们希望监听发生在某个聚合根下的所有事件，为此笔者建议为每一个聚合根对象创建相应的事件基类，其中包含聚合根的ID，比如对于订单(Order)类</p>
<p>在创建领域事件时，需要注意2点：</p>
<ul>
<li>领域事件本身应该是不变的(Immutable)；</li>
<li>领域事件应该携带与事件发生时相关的上下文数据信息，但是并不是整个聚合根的状态数据</li>
</ul>
<p><strong>发布领域事件</strong></p>
<p>发布领域事件有多种方式，比如可以在应用服务(ApplicationService)中发布，也可以在资源库(Repository)中发布，还可以引入事件表的方式。</p>
<p>当前，一种比较受推崇的方式是引入事件表，其流程大致如下：</p>
<ol>
<li>在更新业务表的同时，将领域事件一并保存到数据库的事件表中，此时业务表和事件表在同一个本地事务中，即保证了原子性，又保证了效率。</li>
<li>在后台开启一个任务，将事件表中的事件发布到消息队列中，发送成功之后删除掉事件。</li>
</ol>
<p>在事件表场景下，一种常见的做法是将领域事件保存到聚合根中，然后在Repository保存聚合根的时候，将事件保存到事件表中。这种方式对于所有的Repository/聚合根都采用的方式处理，因此可以创建对应的抽象基类。</p>
<p><strong>消费领域事件</strong></p>
<p>在事件消费时，除了完成基本的消费逻辑外，我们需要重点关注以下两点：</p>
<ol>
<li>消费方的幂等性</li>
<li>消费方有可能进一步产生事件</li>
</ol>
<p>对于“消费方的幂等性”，在上文中我们讲到事件的发送机制保证的是“至少一次投递”，为了能够正确地处理重复消息，要求消费方是幂等的，即多次消费事件与单次消费该事件的效果相同。为此，<strong>在消费方创建一个事件记录表，用于记录已经消费过的事件，在处理事件时，首先检查该事件是否已经被消费过，如果是则不做任何消费处理。</strong></p>
<p>在消费领域事件的过程中，程序需要更新业务表、事件记录表以及事件发送表，这3个操作过程属于同一个本地事务。</p>
<p><strong>事件驱动架构的3种风格</strong></p>
<ol>
<li><p>事件通知</p>
<p>\1. 发布方发布事件<br>\2. 消费方接收事件并处理<br>\3. 消费方调用发布方的API以获取事件相关数据<br>\4. 消费方更新自身状态</p>
</li>
<li><p>事件携带状态转移(Event-Carried State Transfer)</p>
</li>
<li><p>事件溯源</p>
</li>
</ol>
<p>对于发布方来说，作为一种数据提供者的“自我修养”，事件应该包含足够多的上下文数据，而对于消费方来讲，可以根据自身的实际情况确定具体采用哪种风格。在同一个系统中，同时采用2种风格是可以接受的。比如，对于基于事件的CQRS而言，可以采用“事件通知”，此时的事件只是一个“触发器”，一个聚合下的所有事件所触发的结果是一样的，即都是告知消费方需要从源系统中同步数据，（因此此时的消费方可以对聚合下的所有事件一并处理，而不用为每一种事件单独开发处理逻辑。）？？？</p>
<h3 id="实例项目"><a href="#实例项目" class="headerlink" title="实例项目"></a>实例项目</h3><p>该电商系统包含3个微服务，分别是：<br>- 订单(Order)服务：用于用户下单<br>- 产品(Product)服务：用于管理/展示产品信息<br>- 库存(Inventory)服务：用于管理产品对应的库存</p>
<p>整个系统中涉及到的领域事件如下：</p>
<p><img src="https://insights.thoughtworks.cn/wp-content/uploads/2019/08/6.png" alt="img"></p>
<p>其中：</p>
<ul>
<li>Order服务自己消费了自己产生的所有<code>OrderEvent</code>用于CQRS同步读写模型；</li>
<li>Inventory服务消费了Order服务的<code>OrderCreatedEvent</code>事件，用于在下单之后即时扣减库存；</li>
<li>Inventory服务消费了Product服务的<code>ProductCreatedEvent</code>和<code>ProductNameChangedEvent</code>事件，用于同步产品信息；</li>
<li>Product服务消费了Inventory服务的<code>InventoryChangedEvent</code>用于更新产品库存。</li>
</ul>
<h2 id="简单可用的CQRS编码实践"><a href="#简单可用的CQRS编码实践" class="headerlink" title="简单可用的CQRS编码实践"></a>简单可用的CQRS编码实践</h2><p>软件模型中存在读模型和写模型之分，CQRS便为此而生</p>
<p>20多年前，Bertrand Meyer在他的《Object-Oriented Software Construction》一书中提出了CQS（Command Query Seperation，命令查询分离）的概念，指出：</p>
<p>Every method should either be a command that performs an action, or a query that returns data to the caller, but never both. (一个<strong>方法</strong>要么作为一个“命令”执行一个操作，要么作为一次“查询”向调用方返回数据，但两者不能共存。）这里的“命令”可以理解为更新软件状态的写操作，Martin Fowler将此称为“Modifier”；而“查询”即为读操作，是无副作用的。</p>
<p>后来，Greg Young在此基础上提出了CQRS（Command Query Resposibility Segregation，命令查询职责分离），<strong>将CQS的概念从方法层面提升到了模型层面</strong>，即“命令”和“查询”分别使用不同的对象模型来表示。</p>
<p>采用CQRS的驱动力除了从CQS那里继承来的好处之外，还旨在解决软件中日益复杂的查询问题，比如有时我们希望从不同的维度查询数据，或者需要将各种数据进行组合后返回给调用方。此时，将查询逻辑与业务逻辑糅合在一起会使软件迅速腐化，诸如逻辑混乱、可读性变差以及可扩展性降低等等一些列问题。</p>
<p>对于Command侧，主要的讲究是将业务用例建模成对应的Command对象，然后在对Command的处理流程中应用核心的业务逻辑，其中最重要的是领域模型的建模。下面着重介绍Query侧的编码实践。</p>
<p><strong>CQRS究其本意只是要求“读写模型的分离”，并未要求使用Event Sourcing</strong>；再者，Event Sourcing会极大地增加软件的复杂度，而本文追求的是“简单可用的CQRS”</p>
<p><strong>另外需要指出的是，读写模型的分离并不一定意味着数据存储的分离</strong>，不过在实际应用中，数据存储分离是一种常见的CQRS实践模式，在这种模式中，写模型的数据会同步到读模型数据存储中，同步过程通常通过消息机制完成，在DDD场景下，消息通常承载的是领域事件（Domain Event）。</p>
<p><strong>查询模型的数据来源</strong></p>
<p>所读数据的来源形式大致分为以下几种：</p>
<ul>
<li>所读数据来源于同一个进程空间的单个实体（后文简称“<strong>单进程单实体</strong>”），这里的进程空间指某个单体应用或者单个微服务；</li>
<li>所读数据来源于同一个进程空间中的多个实体（后文简称“<strong>单进程跨实体</strong>”）；</li>
<li>所读数据来源于不同进程空间中的多个实体（后文简称“<strong>跨进程跨实体</strong>”）。</li>
</ul>
<p><strong>读写模型的分离形式</strong></p>
<p>CQRS中的读写分离存在2个层次，<strong>一层是代码中的模型是否需要分离</strong>，<strong>另一层是数据存储是否需要分离</strong>，总结下来有以下几种：</p>
<ul>
<li><strong>共享存储/共享模型：</strong>读写模型共享数据存储（即同一个数据库），同时也共享代码模型，数查询据通过模型转换后返回给调用方，事实上这不能算CQRS，但是对于很多中小型项目而言已经足够；</li>
<li><strong>共享存储/分离模型：</strong>共享数据存储，代码中分别建立写模型和读模型，读模型通过最适合于查询的方式进行建模；</li>
<li><strong>分离存储/分离模型：</strong>数据存储和代码模型都是分离的，这种方式通常用于需要聚合查询多个子系统的情况，比如微服务系统。</li>
</ul>
<p>将以上“查询模型的数据来源”与“读写模型的分离形式”相组合，我们可以得到以下不同的CQRS模式及其适用范围，有以下几种常见做法：</p>
<ul>
<li><strong>单进程单实体 + 共享存储/共享模型</strong></li>
<li><strong>单进程单实体 + 共享存储/分离模型</strong></li>
<li><strong>单进程跨实体 + 共享存储/分离模型</strong></li>
<li><strong>单进程跨实体 + 分离存储/分离模型</strong></li>
<li><strong>跨进程跨实体 + 分离存储/分离模型</strong></li>
</ul>
<p>可以为查询单独起一个服务，通过接受领域事件来构建读模型</p>
<p>不管在架构层面还是编码层面，采用CQRS的都会增加程序的复杂度和代码量，不过，这种复杂性可以在很大程度上被其所带来的“条理性”所抵消，“有条理的多”恰恰是为了简单。</p>
<h2 id="用DDD实现打卡系统"><a href="#用DDD实现打卡系统" class="headerlink" title="用DDD实现打卡系统"></a>用DDD实现打卡系统</h2><p>可以参考</p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><h2 id="DDD该如何学"><a href="#DDD该如何学" class="headerlink" title="DDD该如何学"></a>DDD该如何学</h2><ol>
<li>《领域驱动设计》</li>
<li>《企业应用架构》</li>
<li>《实现领域驱动设计》</li>
<li>《领域驱动设计模式、原理与实践》</li>
<li>《领域驱动设计精粹》</li>
</ol>
<p>相信我，光学习理论是没有用的，你必须将其应用于实践，在自己的真实项目里演练DDD，最后通过By Experience 实践来出真知。</p>
<h2 id="领域驱动设计（DDD）实现之路"><a href="#领域驱动设计（DDD）实现之路" class="headerlink" title="领域驱动设计（DDD）实现之路"></a>领域驱动设计（DDD）实现之路</h2><p>一个软件系统是否真正可用是通过它所提供的业务价值体现出来的，因此，与其每天钻在哪些永远也学不完的技术中，何不将我们的关注点向软件系统所提供的业务价值方向思考。这也是DDD所试图解决的问题。</p>
<p><strong>DDD有战略设计和战术设计之分</strong>。<strong>战略设计</strong>主要从高层<strong>俯视</strong>我们的软件系统，帮助我们精准地划分领域以及处理各个领域之间的关系；而<strong>战术设计</strong>则从技术实现的层面教会我们如何具体得实施DDD。</p>
<p><strong>战略设计</strong></p>
<ol>
<li>领域/子域</li>
<li>通用语言</li>
<li>界限上下文（概念边界）</li>
<li>架构风格（使用六边形架构（端口和适配器的组合）：抽象不应该依赖于细节，细节应该依赖于抽象）</li>
</ol>
<p><strong>战术设计</strong></p>
<p>战术设计将战略设计进行具体化和细节化</p>
<ol>
<li><p>实体</p>
<p>实体表示哪些具有生命周期并且会在生命周期中发生改变的东西，通过唯一标识来判断相等。</p>
</li>
<li><p>值对象</p>
<p>起描述性作用并且可以相互替换的概念，通过数据的值来判断相等。</p>
</li>
<li><p>聚合</p>
<p>一个聚合可以包含多个实体和值对象，聚合所包含的对象具有密不可分的联系。聚合是持久化的基本单位，他和资源库就有一一对应的关系。聚合之间的引用应该通过ID。使用聚合的首要原则为在一次事务中，最多只能更改一个聚合的状态。如果一次业务操作涉及到了对多个聚合状态的更改，应该采用发布领域事件的方式通知响应的绝活，此时数据的一致性从事务一致性变成了最终一致性。</p>
</li>
<li><p>领域服务</p>
<p>当无法把概念放在实体或值对象的时候，就可以放在领域服务上了</p>
</li>
<li><p>资源库</p>
<p>资源库用于保存和获取对象。我们要区分Repository和DAO。所有实体都有对应的DAO，只有聚合才有资源库。有两种实现方式：基于集合、基于持久化。</p>
</li>
<li><p>领域事件</p>
<p>为了<strong>使用聚合的首要原则为在一次事务中，最多只能更改一个聚合的状态</strong>问题，我们通过领域事件来保持最终一致性。领域事件的命名为“名词+动词过去分词”格式，表示先前发生过的一件事。同时领域事件还可用于CQRS软件系统中的写模型和读模型之间的数据同步。再进一步是形成Event Sourcing</p>
</li>
</ol>
<h2 id="从四色建模法到界限纸笔建模法"><a href="#从四色建模法到界限纸笔建模法" class="headerlink" title="从四色建模法到界限纸笔建模法"></a>从四色建模法到界限纸笔建模法</h2><h3 id="四色建模法"><a href="#四色建模法" class="headerlink" title="四色建模法"></a>四色建模法</h3><ol>
<li><p>寻找要追溯的事件</p>
<p>谁，在什么时候，干了什么</p>
</li>
<li><p>识别”时标对象”</p>
<p>按照时间发展的先后顺序，用红色表示起到“追溯单据”作用的“时标”概念</p>
</li>
<li><p>寻找时标对象周围的“人、地、物”，也标上红色</p>
</li>
<li><p>在3图里添加表示<strong>角色</strong>的黄色</p>
</li>
<li><p>在4图中添加表示<strong>描述</strong>的蓝色（一般给时标对象）对应了值对象</p>
</li>
</ol>
<h3 id="界限纸笔建模法"><a href="#界限纸笔建模法" class="headerlink" title="界限纸笔建模法"></a>界限纸笔建模法</h3><p>利用四色建模法可以按照时间发展的先后顺序，识别出起到“追溯单据”作用的时标概念。这种识别方法直达业务核心数据，简便有效。</p>
<p>此外，界限纸笔建魔法可以继续进行以下三项建模工作：</p>
<ol>
<li>划分界限上下文、避免模型发展成“大泥球架构”</li>
<li>强调“聚合根”的概念，更好保证数据的完整性</li>
<li>寻找“恰好够用”的概念，避免过度设计，降低所建模型的复杂性</li>
</ol>
<p>流程：</p>
<ol>
<li>根据”追溯单据”的价值识别核心领域</li>
<li>确定核心领域之间的领域关系</li>
<li>用纸和笔画表格并写实例</li>
<li>确认”聚合根”</li>
<li>以”人以群分”的原则抽取新的聚集</li>
</ol>
<p>3个优势：</p>
<ol>
<li>划分核心领域有助于”分为治之”：一旦确定核心领域，界限上下文也就确定了，不同的界限上下文之间通过”翻译器（反腐层）”来彼此工程并屏蔽干扰。</li>
<li>“聚合根”有助于数据完整性：每个界限上下文都有一个“聚合根”的概念，外界对其下属概念的访问都必须通过它来进行，这样既方便定位职责，也有助于数据的完整性。</li>
<li>用“纸和笔”画恰好够用的概念有助于避免过度设计。</li>
</ol>
<h2 id="可视化架构设计——C4介绍"><a href="#可视化架构设计——C4介绍" class="headerlink" title="可视化架构设计——C4介绍"></a>可视化架构设计——C4介绍</h2><p>当我们看待真实世界的“架构图”时候，也是要不停的缩放，在每一个层次可以忽略一些细节才能表达好当前抽象层次的信息，所以架构也有四个抽象层次：</p>
<p>系统System Context、容器Container、组件Component、代码Code</p>
<p>图元素：关系-线；元素-方块和角色；关系的表述-线上的文字、元素的描述-方块里的文字，虚线框</p>
<h2 id="架构可视化入门到抽象坏味道"><a href="#架构可视化入门到抽象坏味道" class="headerlink" title="架构可视化入门到抽象坏味道"></a>架构可视化入门到抽象坏味道</h2><p>从C4图中如果有下面几个迹象就表示我们有可视化的坏味道</p>
<ol>
<li>一张图上过分密码的线：合成更大的元素</li>
<li>一张图上太过多的元素（方块）：合成各大的元素</li>
<li>一张图上太少的元素，比如角色特别少</li>
<li>每个图上文字表达不契合，有的太泛泛，有的太细节：通过制定主体，限制文字的抽象层次</li>
<li>无限制的画更多张图，基本上也失去了使用图形化表达的意义：只画重要的图，剩下的交流的时候再画</li>
</ol>
<h2 id="技术债治理的四条原则"><a href="#技术债治理的四条原则" class="headerlink" title="技术债治理的四条原则"></a>技术债治理的四条原则</h2><p><strong>技术债</strong> 用来描述理想中的解决方案和当前解决方案中间的差距所隐含的潜在成本。</p>
<p>这种隐喻和金融债务非常类似，这也是这个隐喻的高明之处：为了解决短期的资金压力，获得短期收益，个人或企业向银行或他人借款，从而产生债务，这种债务需要付出的额外代价是利息。</p>
<p>如果把技术债的产生也看做一种投资，那么获得的短期收益可能是快速上线带来的商业利益，比如新的功能吸引了更多的付费用户，解决了短期之内的资金缺口问题；赶在竞争对手之前上线了杀手级应用，并快速地抢占了市场。</p>
<p>不可否认，技术债的存在的确有很多积极的意义，但是我们经常会过度关注积极的因素，而忽略了技术债长期存在所导致的“利息”问题。</p>
<p><strong>技术负载全景图</strong></p>
<p><img src="https://insights.thoughtworks.cn/wp-content/uploads/2019/05/1-Tech-Debt-Landscape.png" alt="img"></p>
<p>这个全景图从两个方向来分析技术债对于软件的影响：<strong>可维护性（Maintainability）</strong>、<strong>可演进性（Evolvability）</strong>，同时结合问题的可见性（Visibility）分析技术债对于软件开发过程的影响。</p>
<p>这里的可维护性（Maintainability）主要指的是狭义上的代码问题，即代码本身可读性如何、是否容易被他人所理解、是否有明显的代码坏味道、是否容易扩展和增强。</p>
<p>其中可演进性（Evolvability）指的是系统适应变化的能力。</p>
<p><strong>技术债治理的困境</strong></p>
<ol>
<li><p>团队对于技术改进缺少战略思考</p>
<p>没有让改进方向和业务的战略方向保持一致</p>
</li>
<li><p>代码可维护性问题很难说服客户买单</p>
<p>代码级别的技术债的影响和收益难以衡量</p>
</li>
<li><p>效果不明显，客户信心不足</p>
<p>没有解决实质性问题，比如领域模型设计是否合理</p>
</li>
</ol>
<p><strong>技术债治理的四条原则</strong></p>
<ol>
<li>核心领域由于其他子域</li>
<li>可演进性优于可维护性</li>
<li>明确清晰的责任定义由于松散无序的任务分配</li>
<li>主动预防由于被动响应<ul>
<li>对于代码可维护性方面，很多比较成熟的静态代码扫描工具都可以自动识别这类问题，同时需要和团队一起自定义扫描规则，并把检查代码扫描报告作为代码审查的一部分，逐步形成一种正向的反馈机制。</li>
<li>可演进性：低耦合</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：读完《实现领域驱动设计》，对于实践还是有些模糊，那就再通过《领域驱动设计——洞见系列》加加餐！
    
    </summary>
    
      <category term="读书笔记" scheme="http://bestlixiang.site/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DDD" scheme="http://bestlixiang.site/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>《实现领域驱动设计》读书笔记</title>
    <link href="http://bestlixiang.site/2020/11/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>http://bestlixiang.site/2020/11/06/读书笔记/实现领域驱动设计/</id>
    <published>2020-11-05T16:03:11.000Z</published>
    <updated>2020-11-05T16:05:25.258Z</updated>
    
    <content type="html"><![CDATA[<p>引：《领域驱动设计》为我们提供各种方式来更好的建模，以及更高视角来对待系统模型，同时还提供一组领域建模词汇库。但是关于如何使用，还差了点点点意思，而《实现领域驱动设计》更能让我们付诸实践。本书从顶向下，从战略到战术用一个虚构的案例贯穿全书。冲冲冲！<a id="more"></a></p>
<h1 id="DDD入门"><a href="#DDD入门" class="headerlink" title="DDD入门"></a>DDD入门</h1><p>介绍DDD的好处，以及DDD的使用，用一个例子开篇</p>
<p><strong>什么是领域模型？</strong>: 领域模型是关于某个特定领域的软件模型。通常，领域模型通过对象模型来实现，这些对象同时包含了数据和行为，并且表达了准确的业务含义。</p>
<p>初级开发者：按照DDD去组织一部分代码</p>
<p>中级开发者：按照DDD去组织一个项目</p>
<p>高级开发者：按照DDD去组织一个系统</p>
<p>领域专家：按照DDD去沟通</p>
<p>项目经理：按照DDD去组织一个系统（包括技术和业务）</p>
<p><strong>贫血对象的失忆症</strong>： Java Bean的get/set方法让人不知道业务属性，从而忘了该方法创建出来的作用。</p>
<p><strong>如何DDD</strong>: 如果不谈实现细节，那么DDD最重要的东西就是通用语言和界限上下文。界限上下文是整个应用程序之内的一个概念性边界，这个边界之内的每种领域术语、词组和句子（通用语言），都有确定的上下文含义。</p>
<p><strong>如何判断掌握通用语言</strong>：</p>
<ul>
<li>同时绘制物理模型图和概念模型图，并标以名字和行为</li>
<li>创建一个包含简单定义的术语表</li>
<li>让团队检查成果</li>
</ul>
<p><strong>DDD的业务价值</strong>：</p>
<ol>
<li>获得了一个非常有用的领域模型</li>
<li>业务得到了更准确的定义和理解</li>
<li>领域专家可以为软件设计做出贡献</li>
<li>更好的用户体验</li>
<li>清晰的模型边界</li>
<li>更好的企业架构</li>
<li>敏捷、迭代式和持续建模</li>
<li>使用战略和战术新工具</li>
</ol>
<p><strong>实施DDD所面临的挑战</strong>:</p>
<ul>
<li>为创建通用语言腾出时间和精力</li>
<li>持续地将领域专家引入项目</li>
<li>改变改开发者对领域的思考方式</li>
</ul>
<p>哈哈哈 <strong>例子有点意思</strong>，从小拉大，以小应用作为突破点，给整体带来增长</p>
<h1 id="领域、子域和界限上下文"><a href="#领域、子域和界限上下文" class="headerlink" title="领域、子域和界限上下文"></a>领域、子域和界限上下文</h1><p>战略设计：用界限上下文分离出子域和核心域</p>
<p><strong>领域：</strong> 即是一个组织所做的事情以及其中所包含的一切。当时一个领域太大了，我们需要划分为若干<strong>子域</strong>，领域模型在<strong>界限上下文</strong>中开发。在开发一个领域模型时，我们关注的通常只是这个业务系统的某个子域。</p>
<p>对于一个零售商来说，主要分为4个主要的子域：产品目录，订单，发票和物流，库存</p>
<p>虚线表示不同的子域、实线表示界限上下文，不同子域和上下文之间的直线表示集成关系。</p>
<p>在DDD中，简单的子域可以以<strong>模块</strong>的形式从核心域分离出来</p>
<p>在一个好的界限上下文中，每个术语应该仅表示的一种领域概念，例如订单子域和产品目录子域对于顾客的含义是不一样的。</p>
<p>一个业务系统领域包含：核心域（业务成功的主要促成因素）、支撑子域、通用子域（被应用于整个业务系统）</p>
<p>协作模型中真正重要的是角色，而不是所谓的权限，要区分出一个对象在不同上下文中概念的不同，然后进行隔离</p>
<p>在一个系统中，子域和界限上下文之间很难存在一对一的映射关系</p>
<p>一个界限上下文不只包含领域模型，还包含了一种业务服务。</p>
<p>如果数据库和领域模型不能完全对应，就要区分出两个不同的上下文。</p>
<p>TODO：画一个上下文</p>
<p>一个团队，一个界限上下文</p>
<p>SasSOvation的拆分：敏捷项目管理（核心域）；协作（支撑）；<strong>身份与访问（通用，一定要区分开来）</strong></p>
<p>协作上下文：论坛、共享日历、博客、即时消息、wiki、留言板、文档管理、通知与提醒、活动跟踪和RSS订阅</p>
<p><strong>问题空间：</strong> 我们思考的是业务所面临的挑战，对问题的空间的开发将产生一个新的核心域，对问题空间的评估应该同时考虑已有的子域和额外所需子域。因此问题空间是核心域和其他子域的组合。</p>
<p><strong>解决方案：</strong>我们思考的是如何实现软件以解决这些业务挑战，解决方案空间包括一个或多个界限上下文，即一组特定的软件模型。</p>
<h1 id="上下文映射图"><a href="#上下文映射图" class="headerlink" title="上下文映射图"></a>上下文映射图</h1><p>上下文映射图帮助我们理解业务领域、模型间的边界，以及这些边界之间的集成方式。</p>
<p>集成关系用上游和下游表示（上游的改变会影响下游）</p>
<p>通过<strong>开放主机</strong>这种上下文关系区分出 协作上下文和身份和访问上下文，开发主机通过固定的协议与其他服务通信，这个协议可以包括（XML、JSON、Protocol Buffer、Thrift、消息（发布语言））等等。</p>
<p>通过<strong>反腐层</strong>保护住协作上下文和敏捷项目管理上下文，<strong>下游的反腐层将返回内容翻译成本地上下文的领域对象</strong></p>
<p>为了实现<strong>自治</strong>，敏捷项目管理上下文可能将保留本地模型（使用值对象），并通过事件的方式或者周期调用URL进行同步</p>
<p>总结：</p>
<p>对于一个上下文需要考虑到底要不要自治</p>
<p>如果是自治，那就会存上游服务的内容，是一个值对象</p>
<p>如果不是自治，那么这边就不会存上游服务的内容，用ID表示</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>各种架构  <strong>用例驱动架构</strong></p>
<p>分层架构中使用依赖导致原则（整洁架构），可以在测试中轻易替换UI层和基础设施层</p>
<h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><p>用户界面层 -》 应用层-》 领域层 -》 基础设施层</p>
<p>原则：每层只能与位于其下方的层发生耦合，事实上，较低层也是可以和较高层发送耦合的，但这只局限与观察者模式或中介者模式？？？？</p>
<p><strong>用户界面层：</strong>用户界面只用于处理用户系那是和用户请求，他不应该包含领域或业务逻辑，这里不包括对领域模型的验证，如果用户界面层使用了领域模型中的对象，那么此时的领域对象仅限于数据的渲染展示。这个时候，可以采用展现模型（Presentation Model，可能我们更喜欢叫View Object VO）。由于业务可能是人，也可能是其他系统，有时用户界面层将采用开发主机服务的方式向外提供API。</p>
<p><strong>应用层：</strong> 应用服务位于应用层（也可以叫Usercase层）应用服务可以用于控制化事务和安全认证，或者向其他系统发送基于事件的消息通知。应用服务本身并不处理业务逻辑（这里特指领域服务）。他是领域模型的直接客户。应用服务</p>
<p>应该给是很轻量的，他主要用于协调对领域对象的操作，比如聚合？？。同时应用服务是表达用例和用户故事的主要手段。因此，应用服务的通常用途是：接受来自用户界面的输入参数，再通过资源库获取到聚合实例，然后执行相应的命令操作。</p>
<p><strong>基础设施层：</strong>在传统的分层架构中，将基础架构层放在最底层是有确定的，因为他适合写单元测试。一般会通过依赖倒置让基础设施层依赖高层模块。依赖倒置一般通过依赖注入来实现，而依赖注入一般交由依赖注入框架实现。</p>
<h2 id="六边形架构（端口与适配器）"><a href="#六边形架构（端口与适配器）" class="headerlink" title="六边形架构（端口与适配器）"></a>六边形架构（端口与适配器）</h2><p>分为外部区域（各种<strong>适配器</strong>，这里可以是HTTP、RPC、MQ的输入或者是各种存储的输出）和内部区域（用例以及领域模型）</p>
<p>其实和整洁架构很像，哈哈哈哈</p>
<h2 id="面向服务架构"><a href="#面向服务架构" class="headerlink" title="面向服务架构"></a>面向服务架构</h2><p>服务设计原则：</p>
<ol>
<li>服务契约：通过锲约文档，服务阐述自身的目的与功能</li>
<li>松耦合：服务将依赖关系最小化</li>
<li>服务抽象：服务只发布契约，而向客户隐藏内部逻辑</li>
<li>服务可重用性：一种服务可以被其他服务所重用</li>
<li>服务自治性：服务自行控制环境与资源以保持独立性？？？感觉上肯定会有各种依赖</li>
<li>服务无状态性：服务负责消费方的状态管理？？？</li>
<li>服务可发现性：客户可以通过服务元数据来查找服务和理解服务</li>
<li>服务组合性：一种服务可以由其他的服务组合而成，而不管其他服务的大小和复杂性如何</li>
</ol>
<h2 id="命令和查询职责分离——CQRS"><a href="#命令和查询职责分离——CQRS" class="headerlink" title="命令和查询职责分离——CQRS"></a>命令和查询职责分离——CQRS</h2><p>当我们需要从不同的Repository获取聚合实例数据的时候，我们将需要将这些实例数据组成成一个数据传输对象（Data Transfer Object, DTO）</p>
<p><strong>CQRS</strong>是将紧缩对象（或组件）设计原则和命令——查询（CQS）应用在架构模式中的结果，具体解释是：一个方法要么是执行某种动作的命令，要么是返回数据的查询，而不能两者皆是。在对象层面，这意味着：</p>
<ol>
<li>如果一个方法修改了对象的状态，该方法便是一个命令（Command），他不应该返回数据。但是好像还是一般返回ID？？？（对应命令处理器），一个命令执行执行结束可能发出领域事件，这个时候可能有另外一个实例同步更新，这个时候需要保持最终一致性</li>
<li>如果一个方法返回了数据，该方法便是一个查询（Query），此时他不应该通过直接或者间接的手段修改对象的状态。（对应查询模型，读库，一种是利用数据库自带的同步机制，另外一种是通过领域事件（事件源）来更新查询模型，还有一种是通过ETL将数据经过转化加载到查询模型）</li>
</ol>
<p>这样好像能够读写分离，但是现实中还是会有写后读的场景。</p>
<p>大部分命令模型和查询模型之间的不同步并不是什么大问题，但是我们也可以通过其他方式来解决，比如通过引入观察者模式（？？）或者分布式缓存（这个可以理解）</p>
<p>如果用户界面并不过去复杂，或者我们只需要在当个视图中处理聚合，那么引入CQRS反而会增加额外的复杂性（？？不太懂，感觉都挺好的样子）</p>
<h2 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h2><p>事件驱动架构是一种用于处理事件的生成、发现和处理等任务的软件架构。</p>
<p>该架构可以通过消息机制完成对所有系统的解耦。</p>
<p>对于不同的界限上下文来说，不同的领域事件具有不同的含义，也有可能没有任何含义（如果使用消息过滤器或者路由关键字，消息订阅方可以避免接收对自己无意义的消息）</p>
<h3 id="管道和处理器"><a href="#管道和处理器" class="headerlink" title="管道和处理器"></a>管道和处理器</h3><p>下面是基于消息的管道和过滤器处理过程的基本特征</p>
<ol>
<li>管道是消息通道：过滤器通过输入管道接收数据，过道输出管道发送数据</li>
<li>端口连接过滤器和管道：过滤器通过端口连接到输入和输出管道。端口使得六边形架构成为首选的架构</li>
<li>过滤器即是处理器：过滤器可以对消息进行处理，而不见得一定对消息进行过滤</li>
<li>分离处理器：每个过滤处理器都是一个分离的组件</li>
<li>松耦合：每个过滤器都是相对独立的参与处理过程，处理器组合可以通过配置完成</li>
<li>可换性：更具用例需要，我们可以重新组织不同处理器的处理顺序，这同样是通过配置完成</li>
<li>过滤器可以使用多个管道：消息过滤器可以从不同的管道中读写数据</li>
<li>并行使用同种类型的过滤器：对于最繁忙的和最慢的过滤器来说，我们可以并行地采用多个相同类型的过滤器来增加处理量</li>
</ol>
<h3 id="长时处理过程（Saga）"><a href="#长时处理过程（Saga）" class="headerlink" title="长时处理过程（Saga）"></a>长时处理过程（Saga）</h3><p>在某个消息发出之后，走入不同的管道，最后回到同一个处理器</p>
<p>这里有执行器（并行），最后的处理器（状态跟踪器），如果超时，则再发出一个取消事件（这是完成一致性）</p>
<p>感觉这是一个分布式事务实现方案，但是书里却说和分布式事务没有什么关系（不懂？？？）</p>
<h3 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a>事件源</h3><p>为了了解实体的变更，每个领域事件都将被保存到<strong>事件存储</strong>，然后如果要读取，则根据发生在改聚合上的历史事件来重建改聚合实例，事件的作用顺序应该与他们的产出顺序相同（<strong>有序消息</strong>）</p>
<p>为了避免<strong>聚合事件操作</strong>对于业务操作繁忙的模型产生影响，我们可以通过聚合状态的<strong>快照</strong>的方式进行优化。快照并不是随意创建的，而是可以在所发生的时间达到某个数量时才创建的。</p>
<p>下面是事件源技术所带来的业务优势：</p>
<ol>
<li>用新的或者修改后的时间存储打补丁可以修正许多问题。</li>
<li>我们可以通过重放一组事件的方式来重做或测校对模型的修改、</li>
<li>有了所有事件的历史信息，并基于此可以做很多事</li>
</ol>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>通过事件重建缓存，然后走缓存来实现查询模型</p>
<h1 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h1><p><strong>实体</strong>是一个唯一的东西，并且可以在相当长的一段时间内持续的变化。</p>
<p>在设计实体时，我们首先需要考虑<strong>实体的本质特征</strong>，特别是<strong>实体的唯一标识和对实体的查找</strong>，而不是一开始变关注实体的属性和行为。只有在对实体的本质特征有用的情况下，才加入相应的属性和行为。</p>
<p>一些常用的创建实体身份标识的策略，从简单到复杂依次为：</p>
<ol>
<li>用户提供一个或多个初始唯一值作为程序输入，程序应该保证这些初始值的唯一 （比如用户创建一个用户名）</li>
<li>程序内部通过某种算法自动生成身份识别，此时可以使用一些类库或框架，（UUID/snowflake雪花算法）</li>
<li>程序依赖持久化存储，比如数据库来生成唯一标识（自增ID）</li>
<li>另一个界限上下文（系统）已经决定出一个唯一标识，这作为程序的输入，用户可以在一组标识进行选择（比如邮箱、手机号）</li>
</ol>
<p>为了发布领域事件，我们需要提前发布领域事件（又让我想起了某个项目的某个坑）</p>
<p>通过分析用例（或者说需求），提炼出实体、实体行为、值对象和领域服务</p>
<p>所谓的Setter方法也要变成带有领域行为色彩的方法名</p>
<p>建模的一个方面便是<strong>发现对象的角色和职责</strong>。通常来说，对角色和职责分析是可以应用在领域对象上的。</p>
<p>角色就是接口？？？一个对象可以有多个角色，对应不同的职责活动</p>
<p>验证：验证的主要目的在于检查模型的正确性、检查的对象可以是某个属性（采用自封装性），也可以是整个对象（使用规范或者策略（单独的验证类）来验证，延迟验证），甚至是多个对象的组合。</p>
<p>跟踪变化：实体是可以变化的，在整个生命周期中，对于领域专家来说可能会更关心发生在模型中一些重要的事件，在实际的实现上，最实用的方式就是领域事件和时间存储了，文中说订阅方将事件保存在实践存储中（？？）</p>
<h1 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a>值对象</h1><p>值对象的优点：值对象用于度量和描述事务，我们可以非常容易的对值对象进行创建、测试、使用、优化和维护。</p>
<p>我们应该尽量使用值对象来建模而不是实体对象。</p>
<p>当你只关心某个对象的属性是，该对象便可以成为一个值对象。为其添加有意义的属性，并赋予他相应的行为。我们需要将值对象看出不变对象，不要给他任何身份标识、还应该避免想实体对象一样的复杂性。</p>
<p>当你决定一个领域概念是否是一个值对象时，你需要考虑是否拥有以下特征：</p>
<ol>
<li>他<strong>度量或者描述</strong>领域中的一件东西</li>
<li>他可以作为不变量（只暴露初始化方法）</li>
<li>他将不同的相关的属性组合成一个概念整体（概念必须是整体的）</li>
<li>当度量和描述改变时，可以用另一个值对象予以替换 （是替换（a=3 =&gt; a = 4），不是修改(a= 3 =》 a = a + 1)）</li>
<li>他可以和其他值对象进行相等性比较（属性都相等，那么这个值对象就是相等的）</li>
<li>他不会对协作对象造成副作用（不修改对象的状态）</li>
</ol>
<p>在函数式编程中：只允许无副作用的行为存在，并且要求所有闭包只能接受和产生不变的值对象</p>
<p><strong>最小化继承</strong>：在模型概念从上游上下文流入到下游上下文中，尽量使用值对象来表示这些概念。使用不变的值对象是的我们做更少的职责假设。</p>
<p><strong>用值对象表示标准类型</strong>：就是类型的定义使用值对象，枚举；我们需要每组标准类型创建一个领域服务或工厂。</p>
<p><strong>测试值对象</strong>：<strong>行为测试</strong>可以驱动对领域模型的设计。所以测试也应该具有领域含义。</p>
<p><strong>实现值对象</strong>：拥有两个构造函数，一个是所有属性的构造函数，一个是拷贝构造函数（用于验证不变形）</p>
<p><strong>持久化值对象</strong>：不应该使持久化机制影响到对值对象的建模，根据领域模型来设计数据模型，而不是根据数据模型来设计领域模型。（有时候可以将值对象放在实体一起进行数据库建模，对于List，可以json化后作为一列，这自然违反了数据库建模范式，但是好处是明显的，缺点是：数据库的列宽，必须查询，需要自定义类型；；；或者采用<strong>层超模型</strong>，隐藏值对象在数据库中的ID）</p>
<h1 id="领域服务"><a href="#领域服务" class="headerlink" title="领域服务"></a>领域服务</h1><p>领域中的服务表示一个无状态的操作，他用于实现特定在某个领域的任务。当某个操作不适合放在聚合和值对象上时，最好的方式便是使用领域服务。</p>
<p><strong>尽量避免在聚合中使用Repository</strong> </p>
<p><strong>应用服务不关心业务逻辑、领域服务处理业务逻辑</strong></p>
<p>我们可以使用<strong>领域服务</strong>进行下面的操作：</p>
<ol>
<li>执行一个显著的业务操作过程（需要多个聚合的输入）</li>
<li>对领域对象进行转换</li>
<li>以多个领域对象作为输入进行<strong>计算</strong>，结果产生一个值对象 （比如计算统计结果？？）</li>
</ol>
<p>比如认证就可以放在领域服务中 （需不需要独立的接口，看是否有多个实现）</p>
<p><strong>在应用服务层关心事务</strong></p>
<h1 id="领域事件"><a href="#领域事件" class="headerlink" title="领域事件"></a>领域事件</h1><p>聚合本身将发布领域事件</p>
<p>使用<strong>领域事件</strong>来捕获发送在领域中的一些事情。领域事件时一个功能强大的建模工具，一旦使用了他，你便爱不释手（哈哈哈，解耦太舒服了），但是在你开始使用领域事件时，你要做的是对不同的事件进行<strong>定义</strong>。</p>
<p><strong>领域事件：</strong> 领域专家锁关系的发生在领域中的一些事件。将领域中所发生的活动建模成一系列的离散事件，每个事件都用领域对象来表示，领域事件是领域模型的组成部分，表示领域中所发生的事情。</p>
<p>注意听下面的话语：</p>
<ol>
<li>当…..</li>
<li>如果发生….</li>
<li>当….的时候，请通知我 （发出事件）</li>
<li>发生….时</li>
</ol>
<p>当领域事件到达目的地之后，无论是本地系统还是外部系统，我们通常将领域事件用于维护事件的<strong>一致性</strong>，这是有意而为之的，这样可以消除两阶段提交（全局事务），还可以支持<strong>聚合</strong>原则。聚合的其中一个原则是，只允许对一个聚合实例进行修改，由此产生的其他改变必须在单独的事务中完成（所以应该将事务放在应用服务层吗？？）。因此，本地界限上下文中的其他聚合实例便可以通过领域事件的方式予以同步。另外，领域事件还可以用于使远程依赖系统与本地系统保持一致。本地系统和远程系统的解耦有助于提高双方协作服务的可伸缩性。</p>
<p>对于批处理处理，可以利用领域事件，将一个大事务拆分成较小的处理单元。</p>
<p><strong>命名：</strong>我们应该根据界限上下文中的通用语言来命名事件及其属性。如果事件由聚合上的命令操作产生，那么我们通常根据该操作方法的名字来命名领域事件。</p>
<p><strong>组成：</strong>可以有一个公共的父类用于保证一些基本的信息，然后属性基本是各个ID；TenantID在Saas应用中是必须的</p>
<p><strong>存在的方式：</strong> 有时，领域事件并不由<strong>聚合中的命令方法</strong>产生，而是直接由客户方所放出的请求产生，此时，领域事件可以建模成一个<strong>聚合（落库）</strong>，并且可以拥有自己的资源库。他也应该有自己的唯一表示（因为没有ID，不能判断是否是重复事件），客户方可以通过调用<strong>领域服务</strong>来创建事件，然后将其添加到资源库。然后通过发送事件。</p>
<p><strong>发送：</strong>在聚合汇总添加一个简单的服务，该服务用于通知订阅费所发生的的领域事件，如果是在当个线程内，可以通过ThreadLocal来实现发布-订阅，可能在聚合中发出事件，也有可能在领域服务中发出</p>
<p><strong>订阅：</strong> 通常来说，注册订阅方这种功能由应用服务完成，有时也有领域服务完成。</p>
<p><strong>消息设施的一致性</strong>：有下面三种基本的方式：</p>
<ol>
<li>领域模型和消息设施共享持久化存储</li>
<li>领域模型的持久化存储和消息的持久化存储由全局的XA事务（两阶段提交）</li>
<li>在领域模型的持久化存储中，创建一个特殊的存储区域（比如一张数据库表，该区域用于存储领域事件），然后创建一个<strong>消息外发组件（可以利用binlog）</strong>将时间存储中的所有消息通过消息机制发送出去（这种方式很常用）</li>
</ol>
<p>通过异步的消息，服务可能达到更高层次——自治性，但是有些团队只提供RPC的方式</p>
<p><strong>事件存储：</strong>对于单个界限上下文的所有领域事件来说，为他们维护一个事件存储是有好处的  （订阅方存储事件也是有好处的）</p>
<p><strong>实现：</strong> 可以参考书本，利用RocketMQ + TimberMBean 或者 Quartz</p>
<p><strong>事件去重：</strong> 这个就很常见啦，我们要保持<strong>幂等消费</strong>，一种方式就是通过持有久化存储事件，在每次消费之前都查看事件是否已经被消费</p>
<p><strong>领域事件集成的两种方式：</strong>1. 基于REST的消息通知；2. 消息中间件</p>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>可以看场的Java的命名空间，包 import</p>
<p>在DDD中，模型中的<strong>模块</strong>表示了一个命名的容器，用于存放领域中内聚在一起的类。将类放在不同模块中的目的在于达到<strong>松耦合性</strong>。下面是模块的设计原则：</p>
<ol>
<li>模块应该和领域概念保持协调一致：通常对于一个或一组内聚的聚合来说，我们都相应地创建一个模块。</li>
<li>根据通用语言来命名模块：这也是DDD的基本目标</li>
<li>不要机械式的根据通用的组件类型和模式来创建模块：就是不要把领域放在一个模块，把工厂放在一个模块</li>
<li>设计松耦合的模块：模块间的松耦合性与类间的松耦合性具有相同的好处。</li>
<li>当同层模块间出现耦合时，我们应该杜绝循环依赖：比如产品依赖开发团队，但是开发团队不依赖于产品</li>
<li>在父模块和子模块之间放松原则：尽量避免</li>
<li>不要将模块设计成一个静态的概念，而是与模型中的对象一道进行建模</li>
</ol>
<p><strong>命名：</strong> 上下文 + 分层 + 模型 + 模块 </p>
<p>领域服务可用来当防腐层</p>
<p>先考虑模块，再考虑界限上下文</p>
<p>如果没有明确的上下文边界，使用模块即可</p>
<h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><p>这里特别关注<strong>事务处理</strong>和<strong>保证最终一致性；淡然这些都是建立在用例之上的</strong></p>
<p>聚合的粒度是需要关注的，因为他会影响性能，比如为了并发安全，采用多个聚合时候的时候，原来的最大的聚合更多时候变成了工厂。</p>
<p><strong>一致性原则</strong>往往是聚合边界条件，为了保持一致性，意味着客户请求应该只在一个聚合实例上执行一个命令方法</p>
<p><strong>设计小聚合</strong>往往是因为要考虑性能，可以减少失误的提交冲突</p>
<p><strong>原则：通过唯一标识引用其他聚合  </strong> 对于在单个事务更新多个值对象的情况，可能应该通过最终一致性来保证，但是这种可能有性能问题，但是好处是增强模型的可伸缩性</p>
<p><strong>原则：在边界之外使用最终一致性  </strong> 只要延迟可以接受 <strong>通过领域事件实现</strong></p>
<p><strong>指导原则：</strong> 对于一个用例，问问是否应该由执行该用例的用户来保证数据的一致性。如果是，请使用事务一致性，当然此时已然遵循其他聚合原则，如果需要其他用户或者<strong>系统</strong>来保证数据一致性，请使用最终一致性。</p>
<p><strong>打破原则的理由</strong> 有时我们确实会选择在单个事务中更新多个聚合实例，下面是一些理由：</p>
<ol>
<li>方便用户界面：对于有公共属性的多个对象</li>
<li>缺乏技术机制：没有消息，定时器或者后台线程之类的技术</li>
<li>全局事务：使用全局事务，使系统很难有好的伸缩性</li>
<li>查询性能</li>
</ol>
<p>在分析具体的聚合根的时候，可以考虑将XXID作为值对象显示描述出来</p>
<p><strong>实现：</strong> 使用<strong>迪米特法则</strong>和<strong>“告诉而非询问”原则</strong></p>
<p><strong>迪米特法则（最小知识原则）：</strong>任何对象的任何方法只能调用以下对象的方法，该对象自身，它所创建的对象、自身所包含的对象、所传入的对象</p>
<p><strong>告诉而非询问原则：</strong> 客户端对象不应该首先询问服务对象，然后根据询问结构，调用服务对象中的方法，而是应该通过调用服务对象的公共接口的方式来告诉服务对象所要执行的原则。</p>
<p>尽量不要在聚合中注入资源库和领域服务，我们可以向应用功能服务注册如资源库和领域服务</p>
<h1 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h1><p><strong>使用工厂的主要动机：</strong> 将创建复杂对象和聚合的职责分配给一个单独的对象，改对象本身并不承担模型中的职责。工厂应该提供一个创建对象的接口，改接口封装了所有创建对象的复杂操作过程，同时，它并不需要客户去应用那个实际被创建的对象。对于聚合来说，我们应该一次性创建整个聚合，并且确保他的不变条件得到满足。</p>
<p>领域服务有时候也会扮演工厂的角色（在领域服务中调用防腐层），或者使用聚合的工厂方法（会隐藏？？）。如果有一个类层级的对象，我们可以考虑使用抽象工厂模式来创建不同类型的对象。</p>
<h1 id="资源库"><a href="#资源库" class="headerlink" title="资源库"></a>资源库</h1><p>有两种类型的资源库设计：面向集合的设计 和 面向持久化的设计 （这两种风格我暂时分不出来）推荐面向持久化</p>
<p><strong>面向集合资源库</strong>：使用集合的方法 add, addAll,remove,removeAll,size</p>
<p>精要：一个资源库应该模拟一个Set集合，无论采用什么类型的持久化机制，我们都不应该允许多次添加一个聚合实例，另外，当从资源库获取到一个对象并对其进行修改时，我们并不需要”重新保存”该对象到资源库中。关于删除，需要注意逻辑删除。</p>
<p><strong>面向持久化资源库：</strong> 这是一种基于保存操作（Save）的资源库</p>
<p>精要：在向数据库存储中添加新建对象或修改既有对象时，我们都必须显示地调用put方法，该方法将以新的值来替换先前关联在某个键上的原子。这种类型的存储可以极大简化对聚合的读写。？？？？模拟的是一个Map</p>
<p>对于资源库的不同实现，基础设施的依赖不一样。</p>
<p><strong>下面是为资源库接口添加额外行为的原因：</strong></p>
<p>如果我们需要获取聚合根下的某些子聚合：我们不用先从资源库中获取聚合根，然后再从聚合根中获取这些子聚合，而<strong>是可以直接从资源库中返回</strong>。</p>
<p>如果我们需要在用户界面上显示数据，而这些数据来自于多个聚合，此时我们不用先分别获取到每个聚合，再从中提取出所需数据，而是可以使用<strong>用例优化查询</strong>的方法直接查询所需数据，然后将查询结果放在一个值对象返回</p>
<p><strong>管理事务：</strong>对事务的管理绝对不应该放在领域模型和领域层中，通常来说，我们将事务放在<strong>应用层</strong>中。然后为每个主要的用例创建一个门面（保证事务方法），我们一般会采用<strong>声明事务</strong>。Spring使用声明式事务真方面，有空可以看看它的实现。</p>
<p><strong>资源库和数据访问对象（DAO）的区别</strong>：一个DAO主要从数据库表的角度来看待问题，更适合事务脚本程序。一个Repository更加偏向于对象，被用于领域模型中</p>
<p><strong>测试资源库：</strong> 首先，我们需要测试资源库本身是能正常工作的，其次还要测试对资源库的使用，以保障能够正确的保存和获取聚合实例（使用内存）。</p>
<h1 id="集成界限上下文"><a href="#集成界限上下文" class="headerlink" title="集成界限上下文"></a>集成界限上下文</h1><p>上下文映射图存在的两种主要形式，一种是通过绘制一些简单的框图来展示他们之间的集成关系；另外一种则是通过代码来实现这些集成关系。</p>
<p><strong>集成方式</strong> RPC or 消息 or HTTP REST</p>
<ol>
<li><p><strong>RPC</strong> ：一种集成方式就是在一个界限上下文中暴露应用程序接口（API），然后在另一个界限上下文中通过RPC的方式访问该API。在RPC需要考虑自治。</p>
</li>
<li><p><strong>消息</strong>：通过消息队列进行发布-订阅，这个方式能获得更高层次的自治性。事件命名（Topic）应该是模块+事件名；对于事件消费的第一步必然是对事件的过滤，有些时候需要保证消息的有序。<strong>要控制上下文事件的边界，尤其是对长时处理系统（可以再看看）</strong></p>
</li>
<li><p><strong>HTTP REST: </strong>和RPC不同的是，通过URI来表示资源</p>
</li>
</ol>
<p><strong>分布式计算原则</strong>：</p>
<ol>
<li>网络是不可靠的</li>
<li>总是存在时间延迟，有时非常严重</li>
<li>带宽是有限的</li>
<li>不要假设网络是安全的</li>
<li>网络拓扑结构将发生变化</li>
<li>知识和政策在多个管理员之间传播？？？</li>
<li>网络传输是有成本的</li>
<li>网络是异构的</li>
</ol>
<p><strong>共享内核：</strong> 是指可以直连数据库？？？</p>
<p><strong>开放主机服务：</strong> 当一个界限上下文以URI的方式提供了大量的REST资源，然后得到一个值对象</p>
<p><strong>防腐层：</strong> Service、Adapter、Translator、Facade（HTTP Client） (这个可以再理解理解，区别不同的子类)</p>
<p>感觉上，资源库也是一种防腐层的实现</p>
<h1 id="应用程序-系统-提供多个技术服务端口的业务服务"><a href="#应用程序-系统-提供多个技术服务端口的业务服务" class="headerlink" title="应用程序/系统/提供多个技术服务端口的业务服务"></a>应用程序/系统/提供多个技术服务端口的业务服务</h1><p>单个界限上下文的设计</p>
<p><strong>应用程序：</strong> 表示哪些支持”核心域”模型的组件，通常包括领域模型本身、用户界面、内部使用的应用服务和基础设施组件等。</p>
<p><strong>用户界面：</strong> Web用户界面、小程序、本地GUI</p>
<ol>
<li>渲染领域对象：用户界面可能需要渲染来自多个聚合实例的属性数据，但是在提交修改时，却只能一次修改一个实例</li>
<li>渲染数据传输对象：一个渲染多个聚合实例的方法就是使用<strong>数据传输对象（DTO）</strong>，DTO将包含需要显示的所有属性值。应用服务通过<strong>资源库</strong>读取所需的聚合实例。然后使用一个DTO组装器（DTO Assemble）将需要显示的属性值映射到DTO中。</li>
</ol>
<p><strong>用例优化资源库查询：</strong> 利用资源库返回值对象。而不是聚合</p>
<p><strong>处理不同类型的客户端：</strong> 通过在用例服务中插入一个数据转换器</p>
<p><strong>基础设施：</strong> 框架也算一种基础设施（我之前的理解好像有点错？？比如HibenateXXXRepository）</p>
<p>对于资源库的查找，可以通过<strong>依赖注入</strong>或者<strong>服务工厂</strong>隐式完成。</p>
<h1 id="聚合和事件源"><a href="#聚合和事件源" class="headerlink" title="聚合和事件源"></a>聚合和事件源</h1><p><strong>事件源（Event Sourcing）</strong> 通过事件来表示一个<strong>聚合</strong>的完整状态，这里的事件时自聚合创建以来的一系列<strong>事件</strong>。通过按照产生时的顺序重放这些事件，我们可以重建聚合的状态。</p>
<p>使用事件源维护聚合状态的方式称为A+ES（Aggregate + Event Source）</p>
<p>优势：</p>
<ol>
<li>事件源确保每次聚合改变的原因都不会丢失。这种方式是具有长远的优势：可靠性、短期/长期商业智能化、数据分析、全日志记录和调试等。</li>
<li>只追加（append-only）特性使事件源具有很高的性能（？？），并且支持不同对的数据复制方案。</li>
<li>这种以事件为中心的聚合设计方式使得开发者将关注点集中于<strong>通用语言</strong>所表达的行为上，因此此时并不存在ORM的阻抗失配。（但是感觉这样查询麻烦多了）</li>
</ol>
<p>缺点：</p>
<ol>
<li>为A+ES设计事件需要我们对业务领域具有很深的了解</li>
<li>实现A+ES几乎必然得需要某种形式的命令-查询职责分离，我们很难对事件流进行查询（使用读模型投射）</li>
</ol>
<h1 id="Just-Do-It"><a href="#Just-Do-It" class="headerlink" title="Just Do It"></a>Just Do It</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：《领域驱动设计》为我们提供各种方式来更好的建模，以及更高视角来对待系统模型，同时还提供一组领域建模词汇库。但是关于如何使用，还差了点点点意思，而《实现领域驱动设计》更能让我们付诸实践。本书从顶向下，从战略到战术用一个虚构的案例贯穿全书。冲冲冲！
    
    </summary>
    
      <category term="读书笔记" scheme="http://bestlixiang.site/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DDD" scheme="http://bestlixiang.site/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>《领域驱动设计》读书笔记</title>
    <link href="http://bestlixiang.site/2020/10/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>http://bestlixiang.site/2020/10/22/读书笔记/领域驱动设计/</id>
    <published>2020-10-21T16:09:41.000Z</published>
    <updated>2020-10-21T16:10:02.086Z</updated>
    
    <content type="html"><![CDATA[<p>引：业务开发必不可少！！<a id="more"></a></p>
<p>本书<strong>为设计决策提供了一个框架</strong>，并且为讨论领域设计提供了一个<strong>技术词汇库</strong>。</p>
<p>很多应用程序最主要的复杂性并不在技术上，而是来源于领域本身、用户的活动和业务（后续逻辑）。</p>
<p>本书有两个前提：</p>
<ol>
<li>在大多数软件项目中，主要的焦点应该是领域和领域逻辑</li>
<li>复杂的领域设计应该基于模型</li>
</ol>
<p>领域驱动设计的实质就是消化吸收大量知识、最后产生一个<strong>反应深层次领域支持</strong>，并聚焦关键概念的<strong>模型</strong>。</p>
<h1 id="运用领域模型"><a href="#运用领域模型" class="headerlink" title="运用领域模型"></a>运用领域模型</h1><p><strong>提出领域驱动开发的基本目标</strong>， 这些目标是后面讨论的实践的驱动因素。</p>
<p>用户应用软件的<strong>问题区域</strong>就是软件的<strong>领域</strong>，有些领域是无形的，比如会计程序的金融领域，源代码控制系统的领域是软件开发本身，领域驱动设计，让我们主动寻找领域模型，然后进行设计，然后形成解决某个领域的软件产品，<strong>软件的核心就是其为用户解决领域相关的问题的能力</strong>。</p>
<p><strong>模型</strong>在领域驱动设计中的作用</p>
<ol>
<li>模型和设计相互影响</li>
<li>模型是通用语言</li>
<li>模型是浓缩的知识</li>
</ol>
<h2 id="消化知识，形成模型"><a href="#消化知识，形成模型" class="headerlink" title="消化知识，形成模型"></a>消化知识，形成模型</h2><p>领域知识，这是从领域专家或者领域用户来的，而不是开发脑子想的，我们需要不断用用户获取知识，完善开发的领域知识，更好的建模。</p>
<p><strong>对于开发人员既要完善技术知识，也要培养一般的领域建模技巧。</strong></p>
<p><strong>模型用于不是“发现名词”， 业务活动(Usecase)以及规则（domain service）和实体同样重要</strong></p>
<p>关于一些规则不能放在业务活动的一个判断里，更应该将一些规则放到领域服务里</p>
<p>领域知识 -》 领域建模技术 -》领域模型</p>
<h2 id="模型对应了通用语言"><a href="#模型对应了通用语言" class="headerlink" title="模型对应了通用语言"></a>模型对应了通用语言</h2><p>领域模型可称为软件项目通用语言的核心</p>
<p>通用语言的词汇包括类（领域对象）和主要操作（领域服务）的名称</p>
<p><strong>对于通用语言的修改，就是对模型的修改，就是对代码的修改</strong></p>
<p>对于不同的系统，模型可能是不同的，虽然他们对于现实的东西是一样的，所以我们需要定义不同系统和模型之间关系的<strong>界限上下文</strong></p>
<p>讨论系统要结合模型，并使用模型进行交流，就会将这些模型和想法记录到图和代码中。</p>
<p>关于文档和图，在讨论完模型（包括类和操作）之后，我们总是会以文档或图来展现，我们倾向于展现一些简单的小图（不是所以的编码对象），设计的重要谢姐应该在代码中体现出来。</p>
<p>对于解释性模型，不一定是UML图，但是是有关联的，解释性模型是为了让人更好理解。</p>
<h2 id="绑定领域模型和实现"><a href="#绑定领域模型和实现" class="headerlink" title="绑定领域模型和实现"></a>绑定领域模型和实现</h2><p><strong>领域模型驱动设计</strong> 要求模型不仅能够知道早期的分析工作（面向领域专家、面向产品），还应该成为设计的基础（面向开发）</p>
<p>为了实现在模型和设计对应关系，所以我们一般会使用<strong>面向对象语言</strong> ，哈哈哈哈哈哈，所以<strong>面向对象设计就是目前大多数项目所使用的建模范式</strong></p>
<p>软件开发就是一个不断净化模型、设计、和代码的统一的迭代过程</p>
<p>将建模和编程过程完全分离是行不通的。</p>
<h1 id="模型驱动设计的构造块"><a href="#模型驱动设计的构造块" class="headerlink" title="模型驱动设计的构造块"></a>模型驱动设计的构造块</h1><p><strong>将面向对象领域建模中的一些核心最佳实践提炼为一组基本的构造块</strong>，消除模型和实际运行的软件（实现）之间的鸿沟，同时可作为一些基本术语。</p>
<p><strong>将领域设计与软件系统中的其他关注点分离</strong>会使设计与模型之间的关系更加清晰，根据不同的特征来定义模型元素则会使元素的意义更加鲜明。</p>
<p>下面是在领域设计中基本元素的导航图：</p>
<p><img src="https://i.imgur.com/WF7LSrD.jpg" alt="领域驱动设计读书笔记PART I &amp; II | El Psy Congroo"></p>
<h2 id="分离领域"><a href="#分离领域" class="headerlink" title="分离领域"></a>分离领域</h2><p>我们需要将<strong>领域对象与系统中的其他功能分离</strong>，这样才能避免将领域概念和其他的软件技术相关概念搞混了。</p>
<p><img src="https://yyang.io/2015/12/31/DDD-and-Layered-Architecture/layered-architecture.png" alt="DDD与分层架构| 秋水逍遥"></p>
<p>要想创建能够处理复杂任务的程序，需要做到<strong>关注点分离</strong> ，使设计中的每个部分都得到单独的关注，在分离的同时，也需要维持系统内部复杂的交互关系。</p>
<p>为了实现关注点分离，一般会采用上图的<strong>分层架构</strong> （整洁架构也是其中一种）， <strong>分层架构的基本原则是层汇总的任何元素都仅依赖于本层的其他元素或其下层的元素，向上的通信必须通过间接的方式进行</strong>。（间接的方式是什么？？？回调模式或观察者模式？？这是不还是直接调用？？）</p>
<p>上图的四层主要是：</p>
<ol>
<li>用户界面层（表示层）：负责向用户显示信息和解释用户的指令，这里的用户可是另一个计算机系统（RPC调用）对于我们现在的微服务架构，就是<strong>服务接口层</strong>。</li>
<li>应用层：<strong>定义软件要完成的任务</strong>，并且指挥表达领域概念的对象来解决问题，<strong>具有商业价值的一层</strong></li>
<li>领域层（模型层）：<strong>负责表达业务的概念，业务的状态信息以及业务规则（特别是业务规则）</strong> 尽管保存业务状态的技术细节是由基础设施层完成的，但是反应业务情况的状态是由本层控制并且使用的。<strong>领域层是业务软件的核心</strong></li>
<li>基础设置层：为上面各层提供通用的技术能力：为应用层传递消息，为领域层提供持久化机制等等，基础设置层还能够通过<strong>架构框架</strong>来支持4个层次的交互模式。不过不对具体的基础设置产生依赖，一般会采用<strong>依赖导致</strong>，让基础设施层去依赖领域层。</li>
</ol>
<p>SMART_UI模式：就是将应用程序分成小的功能模块，分别将他们实现成用户界面，并嵌入业务规则。用关系数据库作为共享的数据存储库。一对一，没有任务复用，优点：简单，能快速实现程序，在原型简单可以使用，维护程序员你可以迅速重写他们不明白的代码端，因为修改代码只会影响到代码所在的用户界面。缺点：不通过数据库很难继承模块，没有对行为的重用，也没有对业务问题的抽象，每当操作用到业务规则时，都必须重复这些规则。</p>
<h2 id="软件中使用的模型"><a href="#软件中使用的模型" class="headerlink" title="软件中使用的模型"></a>软件中使用的模型</h2><p>为了不削弱模型驱动设计能力，我们需要将模型和实现个各个细节意义联系起来。</p>
<p>对象之间的<strong>关联</strong>很容易想象出来，也很容易画出来，但是实现他们却存在很多潜在的麻烦，<strong>关联</strong>也表明了具体的<strong>实现决策</strong>在模型驱动设计中的重要性。</p>
<p>在模型驱动设计中，用于表示模型的三个元素：</p>
<ol>
<li>Entity(实体)：具有连续性和标识的实物（可能就有不同的状态）</li>
<li>Value Object(值对象)：描述某种状态的属性</li>
<li>Service(服务，业务规则)：描述某项<strong>无状态</strong>的活动</li>
</ol>
<p>对象之间的<strong>关联</strong>是的建模和实现之间的交互更加复杂，如果一对多，多对一，多对多等等，为了使关联更易于控制，有下面这样的规定：</p>
<ol>
<li>规定一个遍历方向（虽然可以双向遍历的，但是从使用角度只保留一个方向）</li>
<li>添加一个限定符（美国在1970年（1970就是限定符）的总统是乔治*华盛顿，把1对多，变成了一对一），通过增加限定条件（可以理解成一个查询条件）变成一对一</li>
<li>消除不必要的关联 （识别出不重要的关联）</li>
</ol>
<h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>很多对象不是通过属性定义的，而是通过连续性（虽然属性变化，但是本质没有变）和<strong>标识</strong>（人的身份证号）定义的。</p>
<p><strong>Entity</strong>：主要由<strong>标识</strong>定义的对象，这个标识是领域中的标识，而不是技术上的表示，比如对象的ID，地址等，对于标识的定义，有时需要根据应用的上下文来确定。</p>
<h4 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h4><p>抓住Entity定义的最本质的特征，尤其是那些用于识别、查找或匹配对象的特征，只添加对概念至关重要的<strong>行为</strong>和这些行为所必须的<strong>属性</strong>，此外还应该将行为和属性转移到与核心实体关联的对象中。</p>
<p>除了标识问题外，实体往往通过协调其关联对象的操作来完成自己的职责</p>
<h4 id="设计标识操作"><a href="#设计标识操作" class="headerlink" title="设计标识操作"></a>设计标识操作</h4><p>需要理解领域，可能是一个属性唯一键，也可能是多个属性组成的唯一键，当都没有的时候就需要为对象增加一个唯一符号（系统生成的一个数字或者字符串）作为属性，如订单号</p>
<h3 id="Value-Object"><a href="#Value-Object" class="headerlink" title="Value Object"></a>Value Object</h3><p><strong>value object</strong>: 用于描述领域的某个方面二本身<strong>没有概念标识</strong>的对象，识别还是要更具上下文来看的。</p>
<p>值对象经常作为参数在对象之间传递消息，往往是临时对象，同时它也用作Entity的一个属性。Value Object应该是不可变的，如果变了就是另外一个Value Object。</p>
<p>Value Object可以是用于复制，也可以是共享（如果可变则不能共享），看实现性能需求。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>有些重要的<strong>领域操作</strong> 无法放到Entity或者Value Object中，这当中有些操作从本质上讲是一些活动或者操作，而不是事物。</p>
<p>一些领域该你啊你不合适被建模为对象，如果勉强吧这些重要的<strong>领域功能</strong>归为Entity或Value Object的职责，就会破坏真正的对象。</p>
<p><strong>Service</strong> 是作为借口提供的一种操作，他在模型是独立的，并且不像Entity和Value Object那样具有封装的<strong>状态</strong> 他强调的是与其他对象关系，往往是以一个活动动词来命名，Service应该有定义的职责，这种职责以及履行它的接口也应该给作为模型的一部分来加以定义。操作名称应该来源于统一语言，没有则加入统一语言，<strong>参数和结果都应该是领域对象</strong></p>
<p>好的Service有以下三个特征：</p>
<ol>
<li>与领域概念相关的操作不是Entity或ValueObject的一个自然组成部分，如果是，更应该放到Entity或Value Object当中</li>
<li>接口是更具模型领域的其他元素定义的</li>
<li>操作是无状态 的</li>
</ol>
<p>由于<strong>Service</strong>太过常见，有应用层的Service，领域层的Service，基础设施层的Service，所以我们要认真识别，只将有领域概念的Service当做领域层的Service，具体的例子可以参考书本。<strong>除了表示领域操作，很多时候领域层的Service也用来防止领域组件粒度过细，将领域信息外泄，将细粒度的对象包装为中等粒度的对象传递出去。</strong></p>
<p>关于Service访问：我们很多时候会使用依赖注入的方式来利用接口访问，但是要考虑业务的复杂性，如果简单，可以直接使用单例，而不使用依赖注入框架，但是现在感觉大部分都挺复杂的，还是用了好。</p>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>module之间是低耦合的，module之内是高内聚的，我们要联系紧密的领域元素放在一个module里面。可以理解为模块。领域层不可分割，至少作为一个单独的module</p>
<p>这个要站在更好的维度去思考！他也算是一个统一语言，group模块，org模块</p>
<h3 id="建模范式"><a href="#建模范式" class="headerlink" title="建模范式"></a>建模范式</h3><p><strong>模型驱动设计</strong>要求使员工一种与<strong>建模范式</strong>协调的实现技术</p>
<p>主流的范式是<strong>面向对象设计</strong></p>
<p>对于不适合使用面向对象范式的部分，可以使用其他范式，但是要通过<strong>统一语言</strong>来保持上下文</p>
<p>规则引擎、工作流引擎不适合用对象方式来建模？？？（不太理解意思？？？？），然后是核心模型不应该包括业务信息，关于工作流引擎，业务信息变化太快，所以要抽离处理，还是不太懂</p>
<h2 id="领域对象的生命周期"><a href="#领域对象的生命周期" class="headerlink" title="领域对象的生命周期"></a>领域对象的生命周期</h2><p>每个对象都有生命周期，对象自创建后，可能会经历各种不同的状态，直到最终消亡——要么存档，要么删除、对于临时对象来说，就是通过构造函数创建，做一些计算，然后由垃圾收集器回收。对于一些对象，比如Entity对象，他的生命周期更长，会经历一些状态变化，变化会遵守一些固定规则。大部分对象会经历下面的流程：</p>
<p><img src="https://img2020.cnblogs.com/blog/702098/202003/702098-20200321120427928-2072921799.png" alt="六领域驱动设计-领域对象的生命周期- fingersnow - 博客园"></p>
<p>管理这些对象主要的挑战如下：</p>
<ol>
<li>在整个生命周期维护完整性（完整性是指删除一个对象，也要删除属于它的对象）</li>
<li>防止模型陷入管理生命周期复杂性造成的困境（应对不同的基础设施以及对象转换）</li>
</ol>
<p>为了解决上面的挑战，会使用到下面3中模式：</p>
<ol>
<li>聚合根（Aggregate）：定义清晰的所属关系和边界，并避免混乱、错综复杂的对象关系网，这对于维护生命周期哥各个阶段的完整性很有效果</li>
<li>工厂（Factory）：使用工厂创建和重建复杂对象和聚合根，从而封装他们的内部结构，（主要是做数据库表示到领域对象的转换）</li>
<li>存储库（Repository）：用来提供查找和检索持久化对象并封装庞大的基础设施</li>
</ol>
<h3 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h3><p>在具有复杂关联的模型中，要想保证对象的更改的一致性是苦难的，不仅互不关联的对象需要遵守一些固定规则，而且紧密联系的各组对象也要遵守一些固定规则，然而国语谨慎的<strong>锁定机制</strong>又会导致多个用户之间毫无意义的相互干扰（顺序加锁），从而使系统不可用。</p>
<p>要想找到解决上面的方法，需要对领域有更加深刻的理解，比如要了解特定类实例之间的<strong>更改频率</strong>这样的深层次因素，我们需要找到一个<strong>使对象间冲突较少而固定规则联系更紧密</strong>的模型。</p>
<p>我们需要一个抽象来封装模型中的引用。<strong>Aggregate</strong>就是一组相关对象的集合，我们把它作为数据修改的单元。每个<strong>Aggregate</strong>都有一个<strong>根</strong>（root）和一个<strong>边界</strong>（boundary），边界定义了Aggregate内部都有什么。根则是Aggregate所包含的一个特定的Entity。对Aggregate而言，外部对象只可以引用根，而边界内部的对象之间则可以互相引用。除了根以后的其他Enttiy都有本地标识。</p>
<p><strong>固定规则</strong> 是指在数据变化时必须保持一致性的规则，其涉及Aggregate成员之内的内部关系。而跨越Aggregate的骨子额将不要求每时每刻都保持最终状态，通过事件处理或其他更新机制，保持最终一致性就好了。但是<strong>在每个事务完成时，Aggregate内部所应用的固定规则必须得到满足</strong>。</p>
<p>为了实现上诉概念的Aggregate，我们需要所有事务应用一组规则：</p>
<ul>
<li>根Entity具有全局标识，他复杂检查固定规则</li>
<li>根Enttiy具有全局标识，边界内的Entitty具有本地表示，这些表示只在Aggregate内部才是唯一的。</li>
<li>Aggregate外部的对象不能引用除根Entity之外的任何内部对象，根Entity可以吧对内部Entity引用传递给他们，但是这些对象只能临时使用这些引用，而不能保持引用。（不太理解保持引用的意思，是指不能单独修改？？？？），根可以吧一个Value Object的副本传递给另一个对象，而不必关心他们发生什么变化。</li>
<li>只有Aggregate的根才能直接通过数据库查询获取，其他对象必须通过遍历关联来发现。</li>
<li>Aggregate内部的对象可以保持队其他Aggregate根的引用。</li>
<li>删除操作必须一次删除Aggregate边界之内的所有对象（垃圾收集机制会自动实现，对于数据库要删除所有记录）</li>
<li>当提交对Aggregate边界内部的任何对象的修改是，整个Aggregate的所有固定规则都必须被满足。</li>
</ul>
<p><strong>我们要通过合理改变模型，可减少数据库锁的争用</strong></p>
<h3 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h3><p>对象的功能主要体现在其<strong>复杂的配置以及关联</strong>方面。一个对象在他的生命周期中药承担大量职责，如果再让复杂的对象负责自身的创建，那么<strong>职责过载</strong>将导致问题。<strong>我们需要将装配复杂的复合对象的工作和对象要执行的工作分开</strong>。</p>
<p>Factory通常不表示模型的任何部分，但是他们是领域设计的一部分，能使对象更明确地表示除模型。</p>
<p>复杂对象的创建和装配对应于领域中的重要事件（开立银行账户），对于这种具有领域概念的创建，我们需要一种新的元素，就是<strong>Factory</strong></p>
<p><strong>Factory</strong>封装了创建复杂对象或Aggregate所需的知识，他提供了反应客户目标的接口，以及被创建对象的抽象视图。</p>
<p>从设计模式角度考虑主要下面三种3种创建模式：1. 工厂方法（Factory Method）；2. 抽象工厂（Abstract Factory）；3. 构建器（Builder）</p>
<p>任何好的工厂都需要满足两个基础要求：</p>
<ol>
<li>每个创建方法都是原子的，而且要保证被创建对象或Aggregate的所有固定规则。Factory生成的对象要处于一致的状态。如果无法创建，需要抛出Exception或error</li>
<li>Factroy应用被抽象为所需的类型，而不是所要创建的具体类（？？？？）</li>
</ol>
<h4 id="Factory的应用位置"><a href="#Factory的应用位置" class="headerlink" title="Factory的应用位置"></a>Factory的应用位置</h4><p>Factory的作用是隐藏创建对象的细节，而且我们把Factory用在那些需要隐藏细节的地方，这些决定通常与<strong>Aggregate</strong>有关。</p>
<p>两个常见应用位置：</p>
<ol>
<li>如果需要向一个已存在的Aggregate添加元素，可以在Aggregate的根上创建一个工厂方法，这样就可以把Aggregate的内部实现细节隐藏起来</li>
<li>通过一个对象的创建主要使用另一个对象的数据时，前者不属于后者，可以在后者的对象上创建一个工厂方法，这样就不必将后者的信息提取到其他地方来创建前者。</li>
</ol>
<p>当有些细节需要隐藏而又找不到合适的地方来隐藏他们时，必须创建一个专用的<strong>Factory对象或Service</strong>。整个Aggreate通常需要一个独立的Factory来创建，Factory负责把根对应的引用传递出去，并确保创建出的Aggregate满足特定规则。</p>
<h4 id="直接使用构造函数的位置"><a href="#直接使用构造函数的位置" class="headerlink" title="直接使用构造函数的位置"></a>直接使用构造函数的位置</h4><p>Factory会使那些不具有多态性的简单对象复杂化。在以下情况下最好使用简单、公共的构造函数：</p>
<ol>
<li>没有通过接口实现多态的类</li>
<li>客户关心的实现，可能是将其作为选择策略的一种方式（？？？？不懂）</li>
<li>客户可以访问对象的所有属性，因此<strong>向客户公开的构造函数中没有嵌套的对象创建</strong></li>
<li>构造不复杂</li>
<li>公共构造函数必须遵守Factory的相同规则：它必须是原子操作，而且要满足被创建对象的所有固定规则</li>
</ol>
<p>不要在构造函数中调用其他类的构造函数，如果需要，则使用Aggregate，使用Factory</p>
<p><strong>构造函数和Factory可以共存，比如Java集合类库</strong></p>
<h4 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h4><p>在设计Factory的方法签名时，无论是独立的Factory还是Factory Method，都要记住下面两点：</p>
<ol>
<li>每个操作必须是原子的</li>
<li>Factory将与其参数发生耦合，所以尽量依赖其抽象类，而不依赖其具体类</li>
</ol>
<h4 id="固定规则的相关逻辑放在哪里"><a href="#固定规则的相关逻辑放在哪里" class="headerlink" title="固定规则的相关逻辑放在哪里"></a>固定规则的相关逻辑放在哪里</h4><p>Factory复杂确保他所创建的对象或Aggregate满足所有固定规则。Factroy可以将固定规则的检查工作委托给被穿件对象，这通常是最佳选择。</p>
<p>对于聚合根，将固定规则相关逻辑放在Factory是比较好，可以让被创建的对象的职责更加清晰。</p>
<p>固定规则不适合放到那些与其他领域对象关联的Factroy Method中 （？？？？）</p>
<p>对于Entity Factory，需要在Factory来分配标识符ID</p>
<h4 id="重建已存储的对象"><a href="#重建已存储的对象" class="headerlink" title="重建已存储的对象"></a>重建已存储的对象</h4><p>用于重建对象的Factory与用于创建对象的Factroy很类似，但是有以下两点不同：</p>
<ol>
<li>用于重建对象的Entity Factory不会分配新的标识ID，标识属性必须是输入参数的一部分</li>
<li>当规则未被满足时，重建的Factory采用不同的处理方式，创建Factory时直接报错，对于重建，我们还需修复数据（这肯定是有脏数据了）</li>
</ol>
<h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><p>无论要用对象执行什么操作，都需要保持一个对它的应用，如果获得引用，一个方法是<strong>创建</strong>对象，另一个方法是<strong>遍历关联</strong>，从一个已知对象作为起点，向他请求一个关联的对象。还有第三种方案，基于对象的属性执行查询来找到对象，或者找到对象的组成部分，然后<strong>重建</strong>它。</p>
<p><strong>如果基础设施提供了一种简单的方式获取已存在的领域对象的引用，那么开发人员就会增加很多遍历关系的关联，那么模型就会混乱。另一方面，如果开发人员直接从数据库提取他们所需的对象，而不是通过Aggregate来获取对象，那么会使模型变得不重要，我们需要很好的折中。</strong></p>
<p>下面是一些原则：</p>
<p>在所有持久化的对象中，有一<strong>小部分</strong>必须通过对象属性的搜索来<strong>全局访问</strong>，当很难通过遍历方式来访问某些Aggregate根的时候，就需使用这种方式。他们通常是Entity，有时候是具有复杂结构的Value Object，还有可能是枚举值（这个不懂）。而其他对象不宜还是员工这种访问方式。</p>
<p>有大量的技术可以用来解决数据库访问的技术难题，如将SQL封装到Query Object中或者利用ORM进行对象和表之前的转换等。而<strong>Repository</strong>是一个概念框架，用于封装这些解决方案，让我们把注意力重新拉回到模型上。</p>
<p><strong>Repository</strong> 将某种类型的所有对象表示为一个概念集合，他具有CRUD功能。这些功能提供了对Aggregate根的整个生命周期的全称访问。</p>
<h4 id="Repository查询"><a href="#Repository查询" class="headerlink" title="Repository查询"></a>Repository查询</h4><p>大多数查询都返回一个对象或对象集合，但返回某些类型的汇总计算也符合Repository的概念，如对象数据，或者属性求和</p>
<p><strong>一般我们需要一个支持灵活查询的Repository框架。基于Specification（规格）的查询是将Repository的好方法。但是很多框架不提供，需要自己实现，或者全都使用硬编码的方式</strong></p>
<h4 id="Repository实现"><a href="#Repository实现" class="headerlink" title="Repository实现"></a>Repository实现</h4><p>将存储、检索和查询机制封装起来是Repository实现最基本的特征，客户不管先数据是存在数据库还是文件还是内存当中。</p>
<p>在Repository实现的注意事项：</p>
<ol>
<li>对类型进行抽象</li>
<li>充分利用与客户解耦的优点 ，这让我们可以很容易更改Repository的实现</li>
<li><strong>将事务的控制权留给客户</strong>   （这个怎么做？？？？）</li>
</ol>
<p>这里还需要处理一点，<strong>Repository的对象和数据库的对象有时候会不同，这个时候我们需要进行一层转化</strong></p>
<h4 id="Repository和Factory的关系"><a href="#Repository和Factory的关系" class="headerlink" title="Repository和Factory的关系"></a>Repository和Factory的关系</h4><p>Factory负责处理对象生命周期的开始（是创建，不包括重建），Repository帮助管理生命周期的中间和结束。Factroy负责制造新对象，Repository负责查找重建已有对象。同时Repository也可以委托Factroy来创建一个对象（这种情况很少很少，我还没想到？？？？）</p>
<h3 id="为数据库设计对象"><a href="#为数据库设计对象" class="headerlink" title="为数据库设计对象"></a>为数据库设计对象</h3><p><strong>最常用的非对象组件就是关系数据库</strong> 他不是一个对象，他是用来描述一系列CRUD操作</p>
<p>数据库对象和领域对象存在不一致，所以需要映射，对于映射来说，映射要保持透明，并且易于理解</p>
<p>大多数情况下关系数据库是面向对象领域中的持久化存储形式，因此简单的对应关系是最好的，表中的一行包含一个对象，也可能还包含Aggregate的一些附属项。表中的外键应该转化为对另外一个Entity对象的引用。</p>
<p>但是事与愿违，领域对象和数据库对象往往存在不一致，这样会失去透明性，这样会增加处理的复杂度。</p>
<h2 id="一个扩展的示例"><a href="#一个扩展的示例" class="headerlink" title="一个扩展的示例"></a>一个扩展的示例</h2><p><strong>这是在已有领域模型的基础，通过构造块来绑定实现的示例</strong></p>
<ol>
<li>隔离领域：引入应用层</li>
<li>将Entity和Value Object区别开</li>
<li>设计领域中的关联，关联（遍历方向）能反应出领域的馆观察，尽量使用单向关联，因为单向关联可以减少另一个方向遍历带来的理解和实现成为，当然也是会有双向关联的，这是业务所决定的</li>
<li>确定Aggregate边界，共享的Entity一般都是聚合根，拥有共同生命周期的一般是一个聚合根边界，关于聚合根的边界还要考虑锁竞争的问题，减少锁竞争就要缩小边界</li>
<li>选择Repository，在聚合根内部的Entity不能拥有Repository</li>
<li>对象的创建——Factory和构造函数</li>
<li>重构，按照业务需求和性能考虑，重新梳理构造块</li>
<li>module化，找出紧密联系的概念分成Module，虽然被划分成不同的模块，但是还是在同一个领域中，统一语言还是可以用的</li>
<li>引用新系统时，如何处理<ul>
<li>做一个反腐层，处理本领域到另外一个系统领域的翻译</li>
<li>业务规则必须在领域层执行，不应该放在应用层，如果业务规则属于另外一个系统则需要在另外一个系统执行</li>
<li>性能优化，如果另外一个系统的数据，可以使用缓存，避免多次请求，但是这又要维护缓存的一致性问题</li>
</ul>
</li>
</ol>
<p><strong>留了一个坑：分析模式——Enterprise Segment</strong></p>
<h1 id="通过重构来加深理解"><a href="#通过重构来加深理解" class="headerlink" title="通过重构来加深理解"></a>通过重构来加深理解</h1><p><strong>提供一些建模指导原则，将构造块装配为实用的模型</strong>，这是一个逐步的过程。</p>
<p><strong>真正的挑战是找到深层次的模型，这个模型不但能捕捉到领域专家的关注点，还可驱动切实可行的设计，这是一个需要不断重构的过程。</strong></p>
<p><strong>重构</strong>分为两种：</p>
<ol>
<li>代码本身重构：分为设计模式重构和代码细节重构，细节重构可以看看《重构》</li>
<li>代码模型重构：这里不是代码细节重构，但是也会用到一些设计模式，我们这里主要关注这个重构</li>
</ol>
<p>下面都会讨论一些<strong>改进领域模型</strong>的具体<strong>思考方式</strong>以及可<strong>实现这些领域模型</strong>的<strong>设计方法</strong>。</p>
<p>模型驱动设计，设计改进模型，达成一个闭环。</p>
<h2 id="突破"><a href="#突破" class="headerlink" title="突破"></a>突破</h2><p>如果有对了更深层理解，有了更深层次的模型请重构它，完成质的飞跃。</p>
<p>没太看懂文中的例子？？？</p>
<h2 id="将隐式概念转变成现实概念"><a href="#将隐式概念转变成现实概念" class="headerlink" title="将隐式概念转变成现实概念"></a>将隐式概念转变成现实概念</h2><p>深层建模听起来不错，因为他包含了领域的核心概念和抽象，能够以简单灵活的方式表达出基本的用户活动、问题以及解决方案。如何得到深层模型，我们需要一个思考过程。可是是下面这样的思考方式。</p>
<h3 id="概念挖掘"><a href="#概念挖掘" class="headerlink" title="概念挖掘"></a>概念挖掘</h3><p>一般开发设计都是”名词即对象”，但是我们要清楚理解这个名词真实含义，并转为为设计中的模型，形成统一语言。</p>
<p>概念怎么挖掘，通过与领域专家的交流以及查阅专业知识书籍等方式，还有就是阅读在此领域中有过开发经验的软件专业人员编写的资料，如《分析模式》</p>
<ol>
<li>与领域专家交流（靠谱的产品）</li>
<li>查阅专业知识书籍，主动了解领域概念以及领域约束</li>
<li>向做过的这个东西的人学习（经验丰富的同事）</li>
</ol>
<h3 id="为不太明显的概念建模"><a href="#为不太明显的概念建模" class="headerlink" title="为不太明显的概念建模"></a>为不太明显的概念建模</h3><h4 id="显示的约束"><a href="#显示的约束" class="headerlink" title="显示的约束"></a>显示的约束</h4><p>约束是概念模型中非常重要的类型。他们通常是隐含的，将他们显示的表现出来可以极大提高设计质量。</p>
<p>简单方法：将这种约束作为领域对象的一个方法，而不是通过一个if-else 来做，防止他的丢失。</p>
<p>如果约束的存在掩盖了对象的基本职责，或者如果约束在领域中非常突出但是在模型中却不明显，那么就可以将其提取到一个显示的对象中（约束类）。</p>
<h4 id="将过程建模为领域对象"><a href="#将过程建模为领域对象" class="headerlink" title="将过程建模为领域对象"></a>将过程建模为领域对象</h4><p>一般不希望将过程建模为模型的<strong>主要部分</strong>，但是将像算法这样的计算过程封装成对象，或者说策略能够让我们的设计更加清晰。上面说过将约束建模为对象，这里讲过程也可以建模为对象。</p>
<h4 id="Specification-规格"><a href="#Specification-规格" class="headerlink" title="Specification(规格)"></a>Specification(规格)</h4><p>将一些特定的规则（理解为谓词，表示真的，假的）表达为一个对象，可用来明确对象是否满足某些标准。这种规则的实现都有助于写出可测试的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvoiceDeliquency</span></span>&#123;</span><br><span class="line">	test(Invoice): <span class="keyword">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种规则就有扩展性，将几个规则组成一个规则，就可以用来描述复杂的规则。</p>
<p>这个规则可以有属性，属于值对象。</p>
<h4 id="Specification的应用和实现"><a href="#Specification的应用和实现" class="headerlink" title="Specification的应用和实现"></a>Specification的应用和实现</h4><p>有如下几种使用方式：</p>
<ol>
<li>验证对象，检查他是否能满足某些需求</li>
<li>对象选择，从集合中选择一个对象  （可以用来对通用查询做一次转化）</li>
<li>对象创建，创建的新对象必须满足某种需求</li>
</ol>
<h2 id="柔性设计"><a href="#柔性设计" class="headerlink" title="柔性设计"></a>柔性设计</h2><p><strong>软件的最终目的是为用户服务。但他首先必须为开发人员服务。在强调重构的软件开发过程中尤其如此。</strong></p>
<p>为了使项目能够随着开发工作的进行加速前进，而不会由于他自己的老化停滞不前，设计必须要让人们乐于使用，而且易于做出修改，这就是<strong>柔性设计</strong>。</p>
<p>为了获得柔性设计，我们需要采用一些方法（模式）</p>
<p><img src="https://oscimg.oschina.net/oscnet/3397ed64af078ec42bb40e6ab31d8f19202.png" alt="领域驱动设计》学习笔记- osc_ymlf86ez的个人空间- OSCHINA"></p>
<h3 id="Intention-Revealing-interfaces-意图明显的接口"><a href="#Intention-Revealing-interfaces-意图明显的接口" class="headerlink" title="Intention-Revealing interfaces (意图明显的接口)"></a>Intention-Revealing interfaces (意图明显的接口)</h3><p><strong>清楚表明了用途</strong></p>
<p><strong>这里的接口不是特别指<code>interface</code>,它可能指一个方法，一个类，一个接口</strong></p>
<p>如果开发人员为了使用一个组件而必须去去研究他的实现，那么就是去了封装的价值。</p>
<p><strong>在命名类和操作时要描述他们的效果和目的，而不要表露他们是通过何种方式达到目的的</strong>，这样可以使客户开发人员必去去理解内部细节，这些名词应该与统一语言一直。</p>
<p>对于命名困难的，一定要加好注释</p>
<h3 id="Side-Effect-Free-Function-无副作用函数"><a href="#Side-Effect-Free-Function-无副作用函数" class="headerlink" title="Side-Effect-Free Function(无副作用函数)"></a>Side-Effect-Free Function(无副作用函数)</h3><p>我们可以宽泛得把操作分为两个大的类别：命令和查询。查询是从系统获取信息，查询的方式可能只是简单访问变量中的数据，也可能是用这些数据进行计算得到返回值。命令（也称修改器）是修改系统的操作（如设置变量）。</p>
<p><strong>PS：</strong> “Side-Effect（副作用）”在标准英语中，这个词暗示着”意外的结果”，在计算机科学中，任何对系统状态产生印象的都叫做副作用。本书缩小含义：任何对未来操作产生印象的系统状态改变都可以成为副作用。</p>
<p>返回结果，而不产生副作用的操作成为<strong>无副作用函数</strong>，这个函数可以被多次调用，每次调用都返回相同的值。</p>
<p>在大多数软件系统中，命令的使用都是不可避免的，但是有两种方法可以减少命令产生的问题：</p>
<ol>
<li><p><strong>将命令和查询严格放在不同的操作中</strong>，确保导致状态改变的方法不返回领域数据，并尽可能保持简单。</p>
</li>
<li><p>使用新的模型和设计，他不要求对现有对象做任何修改，相反，他们创建并返回一个Value Object，用于表示计算结果。因为Value Object是不可变的，所以不会产生副作用。</p>
</li>
</ol>
<h3 id="Assertion-断言"><a href="#Assertion-断言" class="headerlink" title="Assertion(断言)"></a>Assertion(断言)</h3><p>把复杂的计算封装到无副作用的函数中可以简化问题，但实体仍然会留有一些有副作用的命令，使用这些Entity的人必须了解使用这些命令的后果，在这种情况下，使用<strong>Assertion（断言）</strong>可以把副作用明确的表示出来，使他们更易于处理。</p>
<p><strong>把操作的后置条件和类及Aggregate的固定规则描述清楚。如果在你的编程语言中不能直接编写Assertion(C++可以)，那么就把他们编写成自动的单元测试</strong></p>
<p>一个单元测试包括：前置条件，固定规则，后置条件</p>
<h3 id="Conceptual-Contour-概念轮廓"><a href="#Conceptual-Contour-概念轮廓" class="headerlink" title="Conceptual Contour(概念轮廓)"></a>Conceptual Contour(概念轮廓)</h3><p>把设计元素（操作、接口、类和Aggregate）分解为<strong>内聚单元</strong>，在这个过程中，你对领域中一切重要划分的直观认识也要考虑在内，在连续的重构过程中观察发送变化和<strong>保证稳定的规律性</strong>，并<strong>寻找能够解释这些变化的底层Conceptual contour</strong>（比如调度类？？？）。使模型与领域中那些一致的方面相匹配。</p>
<p>这个不太懂？？？</p>
<h3 id="Standalone-Class-独立的类"><a href="#Standalone-Class-独立的类" class="headerlink" title="Standalone Class(独立的类)"></a>Standalone Class(独立的类)</h3><p>互相依赖的模型和设计变得难以理解、测试和维护。而且，互相依赖很容易越积越多。</p>
<p>每个关联都是一种依赖，每个方法的类型也是一个依赖，每个返回值也是一个依赖。</p>
<p>Module和Aggregate的目的都是为了限制互相依赖的关系网。当我们识别出一个高度内聚的子领域并把他们提取到一个Module中的时候，一组对象也随着与系统其它部分解除了联系。</p>
<p>低耦合是对象设计一个基本要素，尽一切可能保持低耦合，把其他所有无关概念提取到对象之外，这样类就变得完全独立了。</p>
<p><strong>尽力最复杂的计算提取到独立的类中，实现此目的的一种方法就是存在大量依赖的类中将Value Object建模出来。 （可以看看例子）</strong></p>
<p>低耦合是减少概念过载最基本的方法。独立的类是低耦合的极致。</p>
<h3 id="Closure-Of-Operation-闭合操作"><a href="#Closure-Of-Operation-闭合操作" class="headerlink" title="Closure Of Operation(闭合操作)"></a>Closure Of Operation(闭合操作)</h3><p>依赖是必然存在的，当依赖是概念的一个基本属性时，他就不是坏事。</p>
<p>在适当的情况下，在定义操作时让他的返回类型与其参数的类型相同。如果实现者的状态在计算中会被用到，那么是实现者实际上就是操作的一个参数（底层也是这样实现的），因此参数和返回值应该与实现者有相同的类型。这样的操作就是在该类型的实例集合中的<strong>闭合操作</strong>，闭合操作提供了一个高层接口，同时又不会引入对其他概念的依赖。</p>
<p>这种模式更常用于Value Object的操作。</p>
<h3 id="声明式设计以及风格"><a href="#声明式设计以及风格" class="headerlink" title="声明式设计以及风格"></a>声明式设计以及风格</h3><p>声明式设计通常值一种编程方式——吧程序或程序的一部分写成一种可执行的规格（Specification），有点像元编程呀。</p>
<p>柔性设计能让我们的代码具有声明式风格。</p>
<p>实现声明式风格很难！！！</p>
<h3 id="切入问题的角度"><a href="#切入问题的角度" class="headerlink" title="切入问题的角度"></a>切入问题的角度</h3><p>下面是几种方法，让我们将上面的模式都结合起来使用</p>
<h4 id="分割子领域"><a href="#分割子领域" class="headerlink" title="分割子领域"></a>分割子领域</h4><p>将模型的某个部分看做单独子模块。重点突出某个部分</p>
<h4 id="尽可能利用已有的形式"><a href="#尽可能利用已有的形式" class="headerlink" title="尽可能利用已有的形式"></a>尽可能利用已有的形式</h4><p>对于不同的领域，如果有建立已久的概念系统，在复用的基础上，修改</p>
<h2 id="应用分析模式"><a href="#应用分析模式" class="headerlink" title="应用分析模式"></a>应用分析模式</h2><p>直接从一个已经具有良好的表达力和易实现的模型开始工作开始工作。</p>
<p>在《分析模式》一书中，martin fowler这样定义分析模式：</p>
<p><strong>分析模式一种概念集合</strong>，用来表示业务建模中的常见结构，他可能只与一个领域有关，也可能跨越多个领域。</p>
<p>分析模式最大的作用就是借鉴其他项目的经验。</p>
<h2 id="将设计模式应用于模型"><a href="#将设计模式应用于模型" class="headerlink" title="将设计模式应用于模型"></a>将设计模式应用于模型</h2><p>《设计模式》：设计模式是对一些交互的对象和类的描述，我们通过定制这些对象和类来解决特定上下文中的一半设计问题。</p>
<p>在《设计模式中》中，有些（但并非所有）模式可用作领域模式，但是这样使用的时候，需要变换一下重点。为了在<strong>领域驱动设计</strong>中重充分利用这些模式，我们必须从两个角度看待他们：<strong>从代码角度来看他们是技术设计模式，从模型的角度看他们是概念模式</strong></p>
<h3 id="Strategy-Policy-策略模式"><a href="#Strategy-Policy-策略模式" class="headerlink" title="Strategy/Policy (策略模式)"></a>Strategy/Policy (策略模式)</h3><p><img src="http://gdut_yy.gitee.io/doc-ddd/figures/ch12/12inf01.jpg" alt="img"></p>
<p>《设计模式》——策略模式：定义一组算法，将每个算法封装起来，并使他们可以互换。策略允许算法独立使用他的客户端而变化。</p>
<p>领域模型包含了一些并非用于解决技术问题的过程，将他们包含进来是因为他们对处理问题领域具有实际的价值。当必须从多个过程中进行选择是，选择的复杂性加上多个过程的复杂性会使局面失去控制。</p>
<p>我们需要的过程的<strong>易变部分</strong>提取到模型的一个单独策略对象中。将规则与它所控制的行为区分开来。按照策略模式来实现规则或可替换的过程。</p>
<p><strong>通常，作为设计模式的策略侧重于替换不同的算法的能力，而当其作为领域模式时，其侧重点是表示概念的能力，这里的概念通常是指过程或者策略规则</strong></p>
<h3 id="Composite-组合模式"><a href="#Composite-组合模式" class="headerlink" title="Composite(组合模式)"></a>Composite(组合模式)</h3><p><img src="http://gdut_yy.gitee.io/doc-ddd/figures/ch12/12inf02.jpg" alt="img"></p>
<p>《设计模式》——组合模式：将对象组织为数表示部分——整体的层次结构，利用组合，客户可以对单独的对象和对象的组合进行同样的处理。</p>
<p>定义一个把Composite的所有成员都包含在内抽象模型。在容器上实现那些查询信息的方法时，这些方法返回由容器内容所汇总的信息。而”叶“节点则基于他们自己的值来实现这些方法。客户只需要使用抽象类型，而无需区分”叶“和容器。</p>
<p>我感觉还是一个”技术模式”，做了一个很好的抽象。但是告诉我们在学会在领域模式里进行抽象组合。</p>
<h2 id="通过重构得到更深层的理解"><a href="#通过重构得到更深层的理解" class="headerlink" title="通过重构得到更深层的理解"></a>通过重构得到更深层的理解</h2><p>在做项目的过程中，我们总会随着理解的加深而去重构代码，下面重构时需要关注的点：</p>
<ol>
<li>以领域为本</li>
<li>用一种不同的方式来看待事务</li>
<li>始终坚持与领域专家对话</li>
</ol>
<h1 id="战略设计"><a href="#战略设计" class="headerlink" title="战略设计"></a>战略设计</h1><p><strong>站在更高维度，作为一个项目存在于一个大型系统时的设计原则（上下文、提炼、大型结构）</strong>，一般都是由多个团队共同设计。</p>
<p>当我们无法通过分析对象来理解系统的时候，就需要掌握一些<strong>操纵和理解大模型的技术</strong>了</p>
<p>有时，企业系统会继承各种不同来源的子系统，或者包含诸多不同的应用程序，以至于无法从同一个角度来看待领域。要把这些不同部分中隐含的模型统一起来可能要求过高了，通过为每个模型显示定义一个<strong>Bounded Context（界限上下文）</strong>，然后在必要的情况下定义它与<strong>其他上下文</strong>的关系，建模人员就可以避免模型变得混乱。</p>
<p>通过<strong>精炼</strong>可以减少混乱，并且把注意力集中到正确的地方。战略（系统的远景）精炼可以使大的模型保持清晰。有了更清晰的视图后，<strong>Core Domain</strong>的设计就会发挥更大的作用。</p>
<h2 id="保持模型的完整性"><a href="#保持模型的完整性" class="headerlink" title="保持模型的完整性"></a>保持模型的完整性</h2><p><strong>模型最基本的要求是保持内部的统一，不包含互相矛盾的规则。</strong>大型系统领域模型的完全统一既不可行，也不划算。</p>
<p>我们需要一种方式来标记处不同模型之间的边界和关系。下面将会介绍一些<strong>识别、沟通和选择模型边界和关系</strong>的技术。</p>
<p><img src="http://gdut_yy.gitee.io/doc-ddd/figures/ch14/fg14-1.jpg" alt="img"></p>
<p>Overlap: 重叠</p>
<p>Allied: 联盟</p>
<p>Unilaterally : 单方面的</p>
<p>insulate：隔离</p>
<h3 id="Bound-Context-界限上下文"><a href="#Bound-Context-界限上下文" class="headerlink" title="Bound Context(界限上下文)"></a>Bound Context(界限上下文)</h3><p><strong>明确定义模型所应用的上下文</strong>。根据团队的组织、软件系统的各个部分的用法以及物理表现（代码和数据库模式等）来设置<strong>模型的边界</strong>。在这些边界内严格保持模型的一致性，而不要收到边界之外的问题的干扰和混淆。</p>
<p>在一个系统中，系统的具体模型驱动的所有方方面面构成了其对应的<strong>Bouned Context</strong>，上下文包括模型对象、用于模型对象持久化的数据库模式以及应用程序。</p>
<p><strong>PS:</strong> Module不是上下文，多个Module可能是同一个上下文。</p>
<h3 id="Continuous-Intergration-持续集成"><a href="#Continuous-Intergration-持续集成" class="headerlink" title="Continuous Intergration (持续集成)"></a>Continuous Intergration (持续集成)</h3><p>当很多人在同一个上下文工作时，模型很容易发生分裂，团队越多，问题就越大，但是如果将系统分解为更小的上下文，又难以保持集成度和一致性。</p>
<p>持续集成是指把上下文中的所有工作<strong>足够频繁的合并咋一起</strong>，并使他们保持一致，以便当模型发生分裂时，可以迅速发现并纠正。在领域驱动设计中持续集成分成两个级别的操作：</p>
<ol>
<li>模型概念的集成</li>
<li>实现的集成</li>
</ol>
<h3 id="ContextMap-上下文地图"><a href="#ContextMap-上下文地图" class="headerlink" title="ContextMap(上下文地图)"></a>ContextMap(上下文地图)</h3><p>只有一个Bound Context并不能提供全局的视图，其他模型的上下文可能仍不清楚而且还在不断变化。这个时候需要一个<strong>ContextMap上下文地图</strong>。</p>
<p>上下文之间的代码重用是很危险的，应该避免。功能和数据的集成必须通过转换去实现。</p>
<p><strong>描述模型之间的联系点，明确所有通信需要做的转换，并突出任何共享的内容</strong></p>
<h4 id="测试Context的边界"><a href="#测试Context的边界" class="headerlink" title="测试Context的边界"></a>测试Context的边界</h4><p>通过测试有租户解决转换时所存在的一些细微问题以及弥补沟通上存在的不足。</p>
<h4 id="ContextMap的组织和文档化"><a href="#ContextMap的组织和文档化" class="headerlink" title="ContextMap的组织和文档化"></a>ContextMap的组织和文档化</h4><p>两个重点：</p>
<ol>
<li>Bounded Context 应该有名称，以便可以讨论他们，同时这些名称应该加入统一语言中</li>
<li>每个人都知道边界在哪里，而且应该能够分辨出任何代码端的Context，或者任何情况的Context中</li>
</ol>
<h3 id="Bounded-Context之间的关系"><a href="#Bounded-Context之间的关系" class="headerlink" title="Bounded Context之间的关系"></a>Bounded Context之间的关系</h3><p>把模型联系在一起之后，就能把整个企业包含在一起，下面有放多方法将两个模型关联起来</p>
<p>开发一个紧密集成的产品的优秀团队可以部署一个<strong>大的、统一的模型</strong>、如果团队需要为不同的用户群提供服务，或者团队的协调能力有限，可能就需要采用<strong>Share Kernel（共享内核）或Customer/Supplier（客户/供应商）关系</strong>。有时仔细研究需求之后可能发现集成并不重要，而系统最好采用<strong>Separate Way(各行其道)模式</strong>。当然，大多数项目都需要与遗留系统或外部系统进行一定程度的集成，这就需要使用<strong>Open Host Service（开放主机服务）或者Anticorruption Layer（防护层/防腐层）</strong></p>
<h3 id="Shared-Kernel（内核模式）"><a href="#Shared-Kernel（内核模式）" class="headerlink" title="Shared Kernel（内核模式）"></a>Shared Kernel（内核模式）</h3><p><strong>从领域模型中选出两个团队都统一共享的子集，除了这个模型子集以外，还包括与该模型部分相关的代码子集，或数据设计的子集</strong>。这部分明确共享的内容具有特殊的地位，一个团队在没与另一个团队商量的情况下不应擅自更改它。</p>
<p>如果这个共享子集发生修改是，两个团队都要运行测试。</p>
<p><strong>Shared Kernel通常是Core Domain、或是一组Generic SubDomain（通用子领域）。他可以是两个团队都需要的任何一部分模型。</strong></p>
<p><strong>使用Shared Kernel的目的是减少重复（并不是消除重复，因为只有在一个Bounded Context才能消除重复），并使两个子系统之间的集成变得相对容易一些。</strong></p>
<h3 id="Customer-Supplier-Development-Team"><a href="#Customer-Supplier-Development-Team" class="headerlink" title="Customer/Supplier Development Team"></a>Customer/Supplier Development Team</h3><p><strong>这里上下游和调用的上下游好像是相反的，这里的上下游更像是数据的流向</strong></p>
<p>这里是让下游成为”客户”，上游成为”服务者”；下游团队要参加上游团队的计划会议，上游团队直接与他们的”客户”讨论和权衡其所需的任务。</p>
<p><strong>在两个团队之间建立一种明确额客户/供应商关系，在计划会议汇总，下游团队相当于团队的客户。根据下游团队的需求来协商需要执行的任务并未这些任务做预算，以便每个人都知道双方的约定和进度。</strong></p>
<p><strong>两个团队都需要自动化测试。</strong></p>
<p><strong>当下游不能完全使用上游的完整的Bounded Context，就不能把把上游当做Shared Kernel</strong></p>
<h3 id="Conformist-跟随者"><a href="#Conformist-跟随者" class="headerlink" title="Conformist(跟随者)"></a>Conformist(跟随者)</h3><p>当两个具有上游/下游关系的团队不归一个管理者指挥时，Costomer/Supplier Development Team这种合作模式就不容易奏效。哈哈哈哈哈哈哈。</p>
<p>如果上游不能很好的支持下游，那么有以下三种解决方式：</p>
<ol>
<li>完全放弃对上游的依赖，使用Separate Way（各行其道）的方式开发</li>
<li>必须要依赖，而且上游的设计很难使用，那么下游团队仍然需要自己开发自己的模型，而且还要担负起转化层的全部责任，这就是Anticorruption layer</li>
<li>必须要依赖，而且上游的设计还行，而且对上游依赖很大的情况下，使用Comfirmist（跟随者）模式</li>
</ol>
<p><strong>通过严格遵守上游团队的模型，可以消除在Bouned Context之间的转换的复杂性。尽管这会限制下游设计人员的风格，但选择Conformits可以极大简化集成</strong></p>
<p>这个有点像Shared Kernel模式，都有一个重叠区域模型是相同的。但区别是Shared Kernel是两个合作模式，Comformist是一个团队依附另一个团队。</p>
<h3 id="Anticorruption-Layer"><a href="#Anticorruption-Layer" class="headerlink" title="Anticorruption Layer"></a>Anticorruption Layer</h3><p>新系统与老系统集成是很常见的。但边界发生渗透时，转化层就要承担更多的防护责任。</p>
<p><strong>创建一个隔离层，以便根据自己的领域模型来为客户提供相关的功能，这个层主要通过另一个系统现有接口与其对话，而只需对那个系统做出很少的修改，甚至无需修改，在内部，这个层在两个模型之间进行必要的双向转化。</strong></p>
<h4 id="设计Anticorruption-Layer接口"><a href="#设计Anticorruption-Layer接口" class="headerlink" title="设计Anticorruption Layer接口"></a>设计Anticorruption Layer接口</h4><p><strong>Anticorruption Layer的公共接口通常以一组Service的形式出现</strong>，但偶尔也会采用Entity的形式。</p>
<p>构建一个全新的层来负责两个系统之间的语义转化使我们能够重新对另外一个系统的行为进行抽象，并<strong>按照我们的模型一致</strong>的方式把服务和信息提供给我们的系统。</p>
<h4 id="实现Anticorruption-Layer"><a href="#实现Anticorruption-Layer" class="headerlink" title="实现Anticorruption Layer"></a>实现Anticorruption Layer</h4><p>对Anticorruption Layer 进行组织的一种方法是把他实现为<strong>Facade、Adapter和转换器的组合</strong>。外加两个之间进行对话对话所需的通信和传输机制。</p>
<p><strong>Facade</strong>是一个子系统的一个可供替换的接口。Facade并不改变底层系统的模型，他应该严格按照另一个系统的模型来编写。Facade应该属于另外一个系统Bounded Context。他只是为了满足你的专门需要而呈现出的一个更友好的外观。一般Facade在另外一个子系统里面，如果另外一个子系统很简单或者有一个整洁的额接口，可能就需要Facade。</p>
<p><strong>Adapter</strong>是一个包装器。当客户向适配器发送一条消息是，Adapter把消息转为一条语义上等同的消息，并将其发送给”被适配者“。之后Adapter对响应消息进行转换，并将其发挥。</p>
<p><strong>Service</strong>都需要一个支持其接口的Adapter，这个适配器还需要怎么样才能向其他系统及其Facade发送相应的请求。</p>
<p><strong>Translator</strong>是一个转换器，他值属于它服务的Adapter，不需要用状态，他是负责将概念对象转为实际需要发送的对象。</p>
<h3 id="Separate-Way-各行其道"><a href="#Separate-Way-各行其道" class="headerlink" title="Separate Way(各行其道)"></a>Separate Way(各行其道)</h3><p>如果两组功能之间的关系并不必不可少，那么两者完全可以彼此独立。</p>
<p><strong>集成总是代价高昂，而有时收益却很小，此时声明一个与其他上下文毫无关联的Bounded Context，使开发人员在这个小范围内找到简单、专用的解决方案。</strong></p>
<h3 id="Open-Host-Service（开放主机）"><a href="#Open-Host-Service（开放主机）" class="headerlink" title="Open Host Service（开放主机）"></a>Open Host Service（开放主机）</h3><p><strong>定义一个协议，把你的子系统作为一组Service，供其他系统访问，开放这个协议，以便所有需要与你子系统集成的人都可以使用它，当有新的集成需求时，就增强并扩展这个协议，但个别团队的特殊需求除外。满足这种特殊需求方法是使用一次性的转换器来扩充协议，以便使共享协议简单而内聚。</strong></p>
<p>通过一种协议开放能力出去</p>
<h3 id="Published-Language"><a href="#Published-Language" class="headerlink" title="Published Language"></a>Published Language</h3><p><strong>把一个良好文档化的、能够表达出所需领域信息的公共语言作为公共的通信媒介，必要时在其他信息与该语言进行转换。</strong></p>
<p>XML、IDL？？</p>
<h3 id="选择你模型上下文策略"><a href="#选择你模型上下文策略" class="headerlink" title="选择你模型上下文策略"></a>选择你模型上下文策略</h3><p>在任何事件、绘制出Context Map来反应当前情况都是很重要的。但是，一旦绘制好Context Map之后，你很可能改变现状。现在，你可以开始有意识地选择<strong>Context的边界和关系</strong>，以下是一些指导原则。</p>
<ol>
<li>团队决策或更高层的决策：在实践中，团队之间的行政关系往往决定了系统的集成方式。</li>
<li>置身上下文中：自己根据所设计中系统，感受边界。</li>
<li>转换边界：是选择较大的Bouned Context(任务更流畅)，还是选择较小的Bouned Context(沟通更流畅)</li>
<li>接受那些我们无法更改的事务：描述外部系统，保持边界</li>
<li>与外部系统的关系：三种模式（Separate way（不需要集成）、Confirmist（外部系统很重要）、Anticorruption layer（另外的系统设计很糟））</li>
<li>设计中的系统：在自己设计的系统的Bouned Context，持续集成，保持统一，如果团队扩大，就要考虑Shared Kernel、Customer/Supplier Development team、Separate way。（一般一个团队对一个Bouned Context）</li>
<li>用不同的模型满足不同的需求</li>
<li>部署：不同的上下文关系，部署不一样</li>
<li>权衡：我们需要在<strong>无缝功能集成的溢出和额外的协调和沟通</strong>成为做出权衡 ，不同关系对系统的控制程度以及团队的交流能力要求不同。</li>
</ol>
<h3 id="项目进行时"><a href="#项目进行时" class="headerlink" title="项目进行时"></a>项目进行时</h3><p>先确定一个ContextMap和组织架构。及时调整ContextMap，并及时调整团队组织架构。</p>
<h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>一般而言，分割Context是很容易的，但合并他们或者改变他们之间的关系是比较难的。下面是几种有代表性的修改。</p>
<ol>
<li>合并Context：Separate Way -》 Shared Kernel</li>
<li>合并Context：Shared Kernel -》 Continue Integration （单Context）</li>
<li>逐步淘汰遗留系统</li>
<li>Open Host Service -》 Publish Language （解决通信问题）</li>
</ol>
<h2 id="精炼"><a href="#精炼" class="headerlink" title="精炼"></a>精炼</h2><p><strong>精炼</strong>是把一堆混杂在一起的组件分开的过程，以便通过某种形式从中提取出最重要的内容。</p>
<p><img src="http://gdut_yy.gitee.io/doc-ddd/figures/ch15/fg15-1.jpg" alt="img"></p>
<h3 id="Core-Domain（核心领域）"><a href="#Core-Domain（核心领域）" class="headerlink" title="Core Domain（核心领域）"></a>Core Domain（核心领域）</h3><p><strong>为了使领域模型成为有价值的资产，必须整齐地梳理出模型的真正核心，并完全更具这个核心来创建应用程序的功能。</strong></p>
<p><strong>如果软件的核心模型实现的很差，那么无论技术基础设施有多好，无论支持功能有多完善，应用程序都不会为用户提供真正有吸引力的功能。</strong></p>
<p><strong>对模型进行精炼，找到Core Domain并提供一种易于区分的方法把他与那些起辅佐作用的模型和代码分开。最有价值和最专业的概念要轮廓分明。尽量压缩Core Domain。</strong></p>
<p>下面是方法能够让我们更容易发现、使用、修改Core Domain</p>
<h4 id="发现核心"><a href="#发现核心" class="headerlink" title="发现核心"></a>发现核心</h4><p>如果某个设计部分需要保密以便保持竞争优势，那么他就是你的<strong>Core Domain。</strong></p>
<p>我们需要关注的是那些能够表示业务领域并解决业务问题的模型问题部分。</p>
<h4 id="工作分配"><a href="#工作分配" class="headerlink" title="工作分配"></a>工作分配</h4><p>建立一支有核心开发人员和以为或多维领域专家组成的团队。</p>
<h3 id="Generic-SubDomain-通用子领域"><a href="#Generic-SubDomain-通用子领域" class="headerlink" title="Generic SubDomain (通用子领域)"></a>Generic SubDomain (通用子领域)</h3><p>模型中充斥着大量周知的<strong>一般原则</strong>，或者是<strong>专门的细节</strong>，这些细节不是我们的主要关注点，而只是起到支持作用。然而无论他们是多么通用的元素，他们对实现系统功能和充分表达模型都是极为重要的，这就是<strong>Generic SubDomain。</strong></p>
<p>识别出那些与<strong>项目意图无关</strong>的内聚子领域。把这些子领域的通用模型提取出来，并放到单独的Module中。任何专有的东西都不应用放在这些模块中。 比如调度中心、比如工作流？</p>
<p>把他们分离出来，在继续开发的过程中，他们的优先级应低于Core Domain的优先级，并且不要分配核心开发人员来完成这些任务，此外，还可以考虑为这些Generic SubDomain使用现成的解决方案或者”公开发布的模型”。</p>
<h4 id="通用不等于不可重用"><a href="#通用不等于不可重用" class="headerlink" title="通用不等于不可重用"></a>通用不等于不可重用</h4><p><strong>通用不一定是代码的重用，模型的重用是更高级的重用。</strong></p>
<h3 id="Domain-Version-Statement（愿景说明）"><a href="#Domain-Version-Statement（愿景说明）" class="headerlink" title="Domain Version Statement（愿景说明）"></a>Domain Version Statement（愿景说明）</h3><p>Domain Version Statement：<strong>写一份Core Domain的简短描述以及它将创造的价值，展示出领域模型是如何实现和均衡各方利益的</strong>。它可以用来作为一个指南，帮助开发团队在精炼模型和代码的过程中保持统一的方向。</p>
<h3 id="Highlighted-Core（突出核心）"><a href="#Highlighted-Core（突出核心）" class="headerlink" title="Highlighted Core（突出核心）"></a>Highlighted Core（突出核心）</h3><p>有了Domain Version Statement，团队成员大体上知道核心领域是什么构成的。但却不知道Core Domain到底包含哪些元素。</p>
<p><strong>对代码所做的重大结构性改变是识别Core Domain的理想方式，但这些改动往往无法再短期完成，</strong> 这个时候我们需要其他方式。</p>
<h4 id="精炼文档"><a href="#精炼文档" class="headerlink" title="精炼文档"></a>精炼文档</h4><p>创建一个单独的文档来描述和解释Core Domain。这个文档可能会很简单，只是最核心的概念对象的清单。它可能是一组描述这些对象的图、显示了他们最重要的关系（<strong>核心模型</strong>）、他可能在抽象层次上火通过示例来描述基本的交互过程（<strong>核心用例</strong>）。</p>
<h3 id="Cohesive-Mechanism-封装机制"><a href="#Cohesive-Mechanism-封装机制" class="headerlink" title="Cohesive Mechanism (封装机制)"></a>Cohesive Mechanism (封装机制)</h3><p><strong>把算法计算封装到一个单独的轻量级的框架中，然后用Intention-Revealing interface接口暴露出来</strong></p>
<p>比如组织架构相关问题变成图的计算、还有构造一个Specification框架，提供基本的组合操作</p>
<p>Generic SubDomain 还是以模型为主，只是没有Core Domain 重要，而Cohesive Mecheanism是为了提出来解决一些复杂的计算问题。</p>
<p>Cohesive Mecheanism可以是Core Domain的一部分，因为他很重要，在合适的时候也可以从新纳入Core Domain中。</p>
<h3 id="Segregated-Core（分离核心）"><a href="#Segregated-Core（分离核心）" class="headerlink" title="Segregated Core（分离核心）"></a>Segregated Core（分离核心）</h3><p>通过重构得到Segregated Core的一般步骤如下所示：</p>
<ol>
<li>识别出一个Core子领域（可能是从精炼文档中得到的）</li>
<li>把相关的类移到新的Module当中，并为模块命名</li>
<li>对代码进行重构，吧哪些不直接表示概念的数据和功能分离出来，</li>
<li>对新的Segregated Core Module进行重构，使其中的关系和交互变得交单</li>
<li>对另一个Core子领域重复这个过程</li>
</ol>
<p>如果当系统有一个很大的、非常重要的Bouned Context时，但模型的关键部分被大量支持特性功能掩盖了，那么就需要创建Segregated Core了</p>
<p><strong>看书上的例子， 很重要</strong></p>
<h3 id="Abstract-Core-（抽象核心）"><a href="#Abstract-Core-（抽象核心）" class="headerlink" title="Abstract Core （抽象核心）"></a>Abstract Core （抽象核心）</h3><p><strong>把模型中最基本的概念识别出来，并分离到不同的类、抽象类、或接口中。设计这个抽象模型使之能够表达出重要组件之间的大部分交互。把这个完整的抽象模型放到他自己的Module中。而专用的、详细的实现类则留在各个子领域定义的Module中。</strong> （多态）</p>
<p>现在，大部分专用的类都将应用Abstract Core Module，而不是其他专用的Module。Abstract Core提供了主要概念及其交互的简化视图。</p>
<p>应用是啥，SPI ？？？</p>
<h3 id="选择重构目标"><a href="#选择重构目标" class="headerlink" title="选择重构目标"></a>选择重构目标</h3><p>如果能重构Core Domain一定要接受挑战重构他。然后把支持性的子领域提炼成通用子领域。</p>
<h2 id="大型架构"><a href="#大型架构" class="headerlink" title="大型架构"></a>大型架构</h2><p><strong>在一个大的系统中，如果因为缺少一个全局性的原则而使人们无法根据元素在Bounded Context的角色来解释这些元素，那么就容易陷入”只见树木，不见森林”的境地。</strong></p>
<p>设计一种应用功能与整个系统的规则（或角色和关系）方法，使人们可以通过它在一定程度上了解各个部分在整理中所处的位置。这些方法如下：</p>
<p><img src="http://gdut_yy.gitee.io/doc-ddd/figures/ch16/fg16-1.jpg" alt="img"></p>
<p>大部分大型结构都无法用UML来表示，这些大型结构是用来勾画和解释模型和设计的。</p>
<h3 id="Evolving-Order-演变的顺序"><a href="#Evolving-Order-演变的顺序" class="headerlink" title="Evolving Order(演变的顺序)"></a>Evolving Order(演变的顺序)</h3><p>让概念上的大型架构随着应用程序一起演变。在选择大型架构的时候，应该侧重于整体模型的管理。</p>
<p>下面是几种常见的大型架构：</p>
<h3 id="System-MetaPhor（系统隐喻）"><a href="#System-MetaPhor（系统隐喻）" class="headerlink" title="System MetaPhor（系统隐喻）"></a>System MetaPhor（系统隐喻）</h3><p>System Metaphor是一种松散的、抑郁理解的大型架构。</p>
<p>完全看不懂，这到底是啥、？？</p>
<h3 id="Repsonsibility-Layer（职责层）最常用"><a href="#Repsonsibility-Layer（职责层）最常用" class="headerlink" title="Repsonsibility Layer（职责层）最常用"></a>Repsonsibility Layer（职责层）最常用</h3><p><strong>如果每个对象的职责都是人为分配的，将没有统一的指导原则和一致性，也无法把领域作为一个整体来处理，为了保持大模型的一致，有必要再职责上分配一定的结构化控制。</strong></p>
<p><strong>注意观察模型中的概念依赖性，以及领域中不同部分的变化频率和变化的原因。如果在领域中发现了自然的层次结构，就把他们转化为宽泛的抽象职责。这些职责应该描述系统的高层目标。对模型进行重构，使每个领域怼、Aggregate和Module的职责都清晰地位于一个职责层当中。</strong></p>
<p>主要观察依赖，依赖总是从上往下。</p>
<p>在为每个新模型定义层是不一定总是要从头开始。在一系列的相关领域中，有些层是固定的。</p>
<ol>
<li>潜能层。我们能做什么 （基础服务）</li>
<li>作业做。我们在做什么（领域能力）</li>
<li>决策支持层。应该采用什么行动或指定什么策略 ？？？</li>
<li>策略层。规则和目标是什么？？</li>
</ol>
<p>没太看懂为什么一般从策略层依赖到潜能层？？？</p>
<h3 id="Knowledge-Level（知识层）"><a href="#Knowledge-Level（知识层）" class="headerlink" title="Knowledge Level（知识层）"></a>Knowledge Level（知识层）</h3><p>Knowledge level是reflection（反射）模型在领域层的一种应用。</p>
<p><strong>创建一组不同的对象，用他们来描述和约束基本模型的结构和行为。并把这些对象分层两个”级别“，一个是非常具体的级别，另外一个级别则提供了一些可供用户或超级用户定制的规则和知识。</strong></p>
<p>看不太懂？？？大概就是提供一些可配置的规则层（知识层），然后另外是一个具体的类型，我也感觉知识层和策略层很像。</p>
<h3 id="Pluggable-Component-Framework（可插入组件框架）"><a href="#Pluggable-Component-Framework（可插入组件框架）" class="headerlink" title="Pluggable Component Framework（可插入组件框架）"></a>Pluggable Component Framework（可插入组件框架）</h3><p>通常只有在同一个领域中实现了多个应用程序，才有机会使用可插入式组件框架。</p>
<p>从结构和交互中提炼出一个Abstract Core，并创建一个框架，这个框架要允许这些接口的各种不同实现被自由替换。</p>
<p>他的缺点是它是一种非常难以使用的模式，他需要高精度的接口设计和一个非常深入的模型，以便把一些必要的行为捕获到Abstract Core中。另外一个缺点是它只为应用程序提供了优先的选择。</p>
<p>感觉很像大量使用SPI的框架。</p>
<h2 id="领域设计的综合运用"><a href="#领域设计的综合运用" class="headerlink" title="领域设计的综合运用"></a>领域设计的综合运用</h2><p>战略设计的3个基本原则（上下文、精炼、和大型架构）并不是可以互相代替的，而是互为补充的，并且以多种方式进行互动。</p>
<h3 id="大型结构和Bounded-Context结合"><a href="#大型结构和Bounded-Context结合" class="headerlink" title="大型结构和Bounded Context结合"></a>大型结构和Bounded Context结合</h3><p>例如，一种大型架构可以存在于一个Bounded Context中，也可以跨域多个Bounded Context存在，并用于组织Context Map。</p>
<h3 id="大型结构与精炼结合起来使用"><a href="#大型结构与精炼结合起来使用" class="headerlink" title="大型结构与精炼结合起来使用"></a>大型结构与精炼结合起来使用</h3><p>例如，大型架构可以帮助解释Core Domain内部的关系以及Generic SubDomain之间的关系</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>保持持续迭代</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：业务开发必不可少！！
    
    </summary>
    
      <category term="读书笔记" scheme="http://bestlixiang.site/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DDD" scheme="http://bestlixiang.site/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>一段时间的思考</title>
    <link href="http://bestlixiang.site/2020/04/04/%E7%94%9F%E6%B4%BB/%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://bestlixiang.site/2020/04/04/生活/一段时间的思考/</id>
    <published>2020-04-04T06:14:41.000Z</published>
    <updated>2020-04-04T09:07:58.549Z</updated>
    
    <content type="html"><![CDATA[<p>引：每次实习的时间都不是特别长，以为实习就是有活干，把自己手上的东西弄清楚就完事了，但是总感觉现在这样是不行的，我们总需要额外做一些事情，我想只有这样才能更好的进步吧。所以这里也就简单梳理一下自己理解的方向，找出一点先干下去！<a id="more"></a></p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>基础这个，自己是应该好好继续务实的，毕竟基础不牢，地动山摇！每次在深入研究一个东西的时候，就会感觉到自己对基础的不熟，导致自己“被迫”放弃，这种感觉实属打击，希望以后“被迫”放弃来的少一些。</p>
<p>所谓基础也就是大家公认的基础：</p>
<ul>
<li><p>计算机组成原理</p>
</li>
<li><p>计算机网络</p>
</li>
<li><p>数据结构</p>
</li>
<li><p>操作系统</p>
</li>
<li><p>编译原理</p>
</li>
</ul>
<p><strong>不求快，但求实</strong></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>自己也算经历过js、java、python、go等语言，可能真正熟悉的也只有java，其次是go。虽然go也支持oop，但是真正写时，还是会感觉有很大的不同。</p>
<p>上面提到基础也是为了让我们写出更适合计算机运行的代码，除此之后好的代码更找到是给人看的，最近也参加了很多code review，其实会发现其实真正能写出”代码自译”的代码是很难的，但是我们不能放弃，我们要以此为目标。</p>
<p>不同语言写出来的代码风格是不一样的（这个要多写，多看，写总结），但是前人总结出的设计模式是不会错的。说到设计模式，大家一定能到大名鼎鼎的23种设计模式，但是我们现实中说到的设计模式是包含但不仅包含这23种。但是认真去看会发现这些设计模式都在传递一个概念”<strong>高内聚，低耦合</strong>“。按照这个概念写出来的代码一定是质量比较高的。</p>
<p>最近，身边的人经常提到单元测试，想到自己现在写的代码测试，基本属于单个”集成测试”，哈哈，只是为了避免点点点。这个需要尽力改正。之前也看到过一篇文章，大意就是：当你写出了<strong>可测试的代码</strong>，基本代码也就符合了”<strong>高内聚，低耦合</strong>“。很多概念总是环环相扣。</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>关于架构，我想的是主要分为技术架构和业务架构，这里简单说说，在下菜鸡。</p>
<ul>
<li>技术架构：可能又要分为IO密集型架构和CPU密集型架构<ul>
<li>IO密集型架构：我想主要在数据处理，比如如何减少rpc时间，多机房容灾，利用mq异步处理，数据库的选型等等</li>
<li>CPU密集型架构：我想主要利用AI算力，了解微乎其微</li>
</ul>
</li>
<li>业务架构：我想最重要的就是分析问题（常见case），整理出需求，抽象出能力，然后划分为业务领域(服务)，最后在各个服务细化。这里再划分出业务利用我们可以有效的利用DDD来帮助我们确定服务边界。DDD在具体实现上，我个人觉得是比较难完全落地的，但是对于确定业务边界是很有帮助的。最后再多个产品的实现过程中，我们要抽离出通用的基础服务，以便更好地在有新产品需求的时候，能快速落地。当然在利用DDD划分业务领域的时候需要强大的业务背景，这是需要不断积累的。这也是业务背景带来的价值。</li>
</ul>
<h1 id="SRE"><a href="#SRE" class="headerlink" title="SRE"></a>SRE</h1><p>前面讲的是从在接到需求之后，我们确定技术架构，业务架构，语言选型，以及代码书写等方面。但是我们在写完代码之后，这不是项目的结束，而是新的开始，如何保证代码的质量，以及后续的迭代开发，以及保证服务的稳定性都是一个好的产品，一个质量高的软件项目需要考虑的事情，这里需要很多很多工具来支持。下面也简单说说我遇到的一些内容。</p>
<ul>
<li><p>日志系统：这里很重要，毕竟我们查问题，第一想到的就是利用日志，每家公司都有自己的日志系统，日志系统的实现都是基础都是利用ES等技术，比如graylog。在打日志的时候我们也需要在合适的位置，打上合适的日志，不要多，不要少。这个要根据自己的需要，带上合适的信息。</p>
</li>
<li><p>监控系统：我们不能保证系统一直不出问题，但是我们要及时发现问题，这里就需要监控，监控又会分为业务监控和系统监控，系统监控主要包含运行软件的物理设施状态，比如cpu、内存、磁盘等等的报警，业务监控主要包含业务系统定义的错误，这些业务错误需要上报，主要利用时序数据库来存储这些信息，最后我们可以利用grafana来可视化这些数据，利用sentry来进行业务报警通知。</p>
</li>
<li><p>代码质量：这里可能需要从代码源头开始，比如在IDE上加上一个lint来保证编写时的代码质量，然后用比如sonar之类的软件来监控代码质量，还有在发布前我们可能需要像tesla质量的软件来跑一些主要流程的集成测试，关于这里测试我们又可以用jenkins之类的CI工具来帮助我们来自动化执行我们这些流程。最后关于代码这里的底线就要是做到利用git之类的工具做到版本控制。</p>
</li>
<li><p>部署：这一块我们主要是利用docker和k8s来进行CD，在k8s的帮助下，我们可以做到动态的扩容或者缩容，当然要是能做到自动扩容是最好的。然后在发布的时候我们也要支持灰度发布，蓝绿发布等等，这样能保证在升级的时候遇到问题尽可能做到影响最小。</p>
</li>
</ul>
<p>上面都是自己的理解的理解，问题可能会很多，也有错误的地方，自己以后感觉到不会的时候，或者有补充的时候也会来及时打补丁。</p>
<h1 id="技术之外"><a href="#技术之外" class="headerlink" title="技术之外"></a>技术之外</h1><p>之前讲的都是技术相关，这里想讲一下技术之外的事情， 比如自己薄弱的沟通能力。</p>
<p>加粗：<strong>所有将不清楚的事情都是因为自己没理解</strong></p>
<p>这里只能对自己说：自己需要在理解事情之后主动沟通，尽早暴露出问题，尽早解决问题。手动狗头！！</p>
<p>太难了，我！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：每次实习的时间都不是特别长，以为实习就是有活干，把自己手上的东西弄清楚就完事了，但是总感觉现在这样是不行的，我们总需要额外做一些事情，我想只有这样才能更好的进步吧。所以这里也就简单梳理一下自己理解的方向，找出一点先干下去！
    
    </summary>
    
      <category term="生活" scheme="http://bestlixiang.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="思考" scheme="http://bestlixiang.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>JVM问题解决思路总结</title>
    <link href="http://bestlixiang.site/2019/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://bestlixiang.site/2019/07/11/深入理解Java虚拟机/JVM问题解决思路总结/</id>
    <published>2019-07-11T00:41:21.000Z</published>
    <updated>2019-07-11T00:40:16.174Z</updated>
    
    <content type="html"><![CDATA[<p>引：JVM对于大部分没有看过源码的人(包括我)来说是抽象的，自然也就看不见真相。此时我们所谓的”真相”更多是来自于博客和别人的话语，当这些抽象的概念被重复多次之后也就变成了我们所理解的”真相”，下面我们就来看看这些”真相”！并理解这些”真相”去解决问题。<a id="more"></a></p>
<h1 id="前置真相"><a href="#前置真相" class="headerlink" title="前置真相"></a>前置真相</h1><ol>
<li><p>JVM运行时内存结构，重点是<strong>堆的结构</strong>(最基础的，这里就不多说了)</p>
</li>
<li><p>Java垃圾收集器，重点是<strong>CMS收集器</strong>(看参考的那边文章就够啦)</p>
</li>
<li><p>对象<strong>从内存分配到垃圾回收</strong>，下面是自己的总结：</p>
<ul>
<li><p>内存分配</p>
<ol>
<li><p>对象如果开启TLAB先分配在TLAB(Thread Local Allocation Buffer)，不然分配在Eden区</p>
</li>
<li><p>大对象直接配置在老年代(具体参数为PretenureSizeThreshold)</p>
</li>
</ol>
</li>
<li><p>垃圾收集</p>
<p>发生MinorGC，会将没死的对象复制在Survivor区，这里有两种情况：</p>
<ol>
<li>如果有相同年龄的对象大于Survivor区的一半，则进入老年代</li>
<li>如果survivior区的对象年龄超过默认15（具体参数为MaxTenuringThreshold，这里可能会动态调整），进入老年代</li>
</ol>
<p>在进行MinorGC之前，有个空间担保的概念（老年代要放得下新生代的对象）的判断：</p>
<p>如果老年代连续空间的大小 <strong>大于</strong> 新生代总大小或者历次晋升到老年代的平均大小 就会进行Minor GC，否则将进行Full GC</p>
<p>进行FullGC还有下面几种情况：</p>
<ol>
<li>发生concurrent mode failure（由于并发清除阶段，用户线程产生的对象进入老年代）会引起Full GC，这种情况下会使用Serial Old收集器</li>
<li>Minor GC后发生的担保失败（promotion failed）会触发FullGC</li>
<li>永久代空间（Metaspace）不足会触发Full GC</li>
<li>System.gc()引起的Full GC(一般会禁掉)</li>
<li>老年代不足会触发FullGC</li>
</ol>
<p>这里再说一点，所谓的Full GC其实很多时候是和MajorGC相等的，只有在CMS的时候才有会MajorGC，因为只有它需要在老年代达到一定大小的时候会触发MajorGC(对应参数CMSInitiatingOccupancyFraction，默认92%)，其他都是发送在老年代满的时候发生FullGC，这时候包括MajorGC和MinorGC。</p>
</li>
</ul>
</li>
</ol>
<p>上面这些”真相”对我们来说是解决问题的基础。</p>
<h1 id="实践工具"><a href="#实践工具" class="headerlink" title="实践工具"></a>实践工具</h1><p>JDK的bin目录下提供了很多工具，我们可以利用这些工具来处理数据，这些<strong>数据</strong> 包括： 运行日志、异常堆栈、GC日志、线程快照(threaddump/javacore文件)、堆转储快照(heapdump/hprof文件)等。</p>
<p>简单介绍几个工具：</p>
<ol>
<li>jps ：虚拟机进程状况工具，获得java进程</li>
<li>jstat：虚拟机信息监控工具，可以获得类装载、内存、垃圾收集、JIT编译参数</li>
<li>jinfo：配置信息工具，实时查看和调整虚拟机的各项参数</li>
<li>jmap：内存映像工具，可以获得堆内存信息以及获得堆转储快照</li>
<li>jstack：堆栈跟踪工具，可以获得线程快照</li>
</ol>
<p>上面都是命令行工具，下面说两个图形界面工具：</p>
<ol>
<li>VisualVM：多合一故障处理工具，通过插件扩展可以做到：<ul>
<li>显示虚拟机进程以及配置信息(jps、jinfo)</li>
<li>监控应用程序的CPU、GC、堆、方法区(Metaspace)、以及现场的信息(jstat、jstack)</li>
<li>dump以及分析堆转储快照(jmap、jhat)</li>
</ul>
</li>
<li>GC easy：图形化GC 日志</li>
</ol>
<h1 id="问题探索"><a href="#问题探索" class="headerlink" title="问题探索"></a>问题探索</h1><p>在我们拥有了相关”真相”知识和数据，还有工具，我们就可以解决很多问题，如下：</p>
<h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><p>调优一般步骤可以概括为：确定目标、优化参数、验收结果</p>
<p>明确应用程序的系统需求是性能优化的基础，系统的需求是指应用程序运行时某方面的要求，譬如： </p>
<ul>
<li>高可用，可用性达到几个9</li>
<li>低延迟，请求必须多少毫秒内完成响应</li>
<li>高吞吐，每秒完成多少次事务</li>
</ul>
<p>对于大部分应用来说，主要考虑两点：<strong>高可用和低延迟</strong>，其他再小一点就是<strong>低延迟</strong>，这也是我们为什么会使用<strong>ParNew+CMS</strong>的原因。</p>
<p>对于低延迟，主要有两个考量：<strong>GC的次数和GC的时间 </strong>，所以下面列举几个需要优化的点：</p>
<h3 id="MajorGC"><a href="#MajorGC" class="headerlink" title="MajorGC"></a>MajorGC</h3><p>虽然MajorGC 发生STW(stop the world)的时候比较短，但是次数多了影响也比价大，这里我们主要是减少它的次数，为了减少它的次数直接方法就是增加Eden区的大小，但是增加Eden区的大小会增加STW的时间，所以我们这里需要做一个权衡。下面是一个例子：</p>
<ul>
<li>扩容前：新生代容量为R ，假设对象A的存活时间为750ms，Minor GC间隔500ms，那么本次Minor GC时间= T1（扫描新生代R）+T2（复制对象A到S）。</li>
<li>扩容后：新生代容量为2R ，对象A的生命周期为750ms，那么Minor GC间隔增加为1000ms，此时Minor GC对象A已不再存活，不需要把它复制到Survivor区，那么本次GC时间 = 2 × T1（扫描新生代R），没有T2复制时间。</li>
</ul>
<p>对于虚拟机来说，复制对象的成本要远高于扫描成本。因此如果堆<strong>短期对象很多</strong>，那么扩容新生代，单次Minor GC时间不会显著增加。关于这个周期就需要观察自己的应用代码以及GC日志或者利用Visual VM直接看扩容后MinorGC之后新生代内存的变化。增加了Eden的大小，还有一个好处就是老年代的对象也会减少。在《Java性能优化指南》的指导下，我们一般设置新生代的初始化为堆的3/8。</p>
<h3 id="CMS的Remark"><a href="#CMS的Remark" class="headerlink" title="CMS的Remark"></a>CMS的Remark</h3><p>CMS垃圾收集器在Remark阶段是STW的，所以我们要尽力减少这段时间，由于新生代对象持有老年代中对象的引用，所以会扫描新生代和老年代，这个时候如果<strong>新生代的对象很多</strong>，会严重影响Remark阶段的耗时。由于新生代中对象的生命周期很短，这样如果在Remark前执行一次Minor GC，大部分对象就会被回收，可以很好的减少Remark阶段的耗时。<strong>为此CMS在Remark前增加了一个可中断的并发预清理阶段</strong>，该阶段主要工作仍然是并发标记对象是否存活，只是这个过程可被中断。此阶段在Eden区使用超过2M时启动，当然2M是默认的阈值，可以通过参数修改（在参考中CMS那边博客有详细说明）。如果此阶段执行时等到了Minor GC，那么新生代的部分对象将被回收，Reamark阶段需要扫描的对象就少了。除此之外CMS为了避免这个阶段没有等到Minor GC而陷入无限等待，提供了参数<strong>CMSMaxAbortablePrecleanTime </strong>，默认为5s，含义是如果可中断的预清理执行超过5s，不管发没发生Minor GC，都会中止此阶段，进入Remark阶段。 这个时候如果Remark时新生代中仍然有很多对象，耗时还是会很长，CMS提供<strong>CMSScavengeBeforeRemark</strong>参数，用来保证Remark前强制进行一次Minor GC。</p>
<h3 id="FullGC"><a href="#FullGC" class="headerlink" title="FullGC"></a>FullGC</h3><p>对于CMS来说，FullGC的STW时间主要集中在Remark阶段，上面也只是减少GC时间，我们还有另外一个考量：GC次数。这次要用到我们刚开始说的”真相”了——FullGC发生的情况。通过GC日志，我们很容易确定发生FullGC的原因。我们可以根据具体的原因来调整参数。这里有一点就是如果是<strong>老年代不足会触发FullGC</strong>，我们就需要分析是否有<strong>内存泄漏</strong>，我们放在下面说。</p>
<h2 id="内存溢出异常"><a href="#内存溢出异常" class="headerlink" title="内存溢出异常"></a>内存溢出异常</h2><p>这个会分为以下几种情况：</p>
<ol>
<li>堆溢出：这里我们需要分析代码中是否有大对象没有即时置空或者是否有内存泄漏，一般在堆溢出的时候我们会dump出堆转储快照，我们可以利用工具进行分析，具体分析可以在参考中找到，如果我们两次dump出文件对比发现有同样的对象都没有被回收，我们就需要看看是否有内存泄漏的可能性。</li>
<li>栈溢出：栈溢出一般会在<strong>运行日志</strong>中输出异常堆栈，我们可以从异常堆栈中找到提示信息，最近我就遇到过一次，原因是下游系统提供的api中打印了利用fastjson序列化的一个SpringBean🤣，fastjson是递归去序列化的，而这个bean层级太深 ，也就到导致了栈溢出。这里也告诉我们一定要注意<strong>递归深度</strong>。</li>
<li>Metaspace溢出：Metaspace主要是存一些类信息，在JDK8中它已经移动到直接内存中，这也表明了它受限于系统内存，一般情况下是不会溢出的。</li>
<li>直接内存溢出：直接内存的溢出基本是由于DirectByteBuffer类和MappedByteBuffer类，堆外内存在VisualVM的Buffer Pools插件也可以监控得到。在参考中也有一篇文章是分析直接内存溢出的。</li>
</ol>
<h2 id="CPU飚高"><a href="#CPU飚高" class="headerlink" title="CPU飚高"></a>CPU飚高</h2><p>Java应用导致CPU飚高的有下面几种情况：</p>
<ol>
<li><p>程序计算比较密集，如FullGC频繁</p>
</li>
<li><p>程序死循环</p>
</li>
<li><p>程序逻请求堵塞，自旋</p>
</li>
<li>IO读写太高 </li>
</ol>
<p>有了上面的”真相”，我们解决问题起来也很好办了。主要是先找出cpu使用率高的线程(利用top命令)，然后利用jstack或者Visual VM找到相应的堆栈信息，根据堆栈信息定位代码，解决问题。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnblogs.com/littleLord/p/5380624.html" target="_blank" rel="noopener">详解CMS垃圾回收机制</a></li>
<li><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">从实际案例聊聊Java应用的GC优化</a></li>
<li><a href="https://blog.csdn.net/kl28978113/article/details/53817827" target="_blank" rel="noopener">JVisualVM简介与内存泄漏实战分析</a></li>
<li>《深入理解Java虚拟机》</li>
<li>《Java性能优化指南》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：JVM对于大部分没有看过源码的人(包括我)来说是抽象的，自然也就看不见真相。此时我们所谓的”真相”更多是来自于博客和别人的话语，当这些抽象的概念被重复多次之后也就变成了我们所理解的”真相”，下面我们就来看看这些”真相”！并理解这些”真相”去解决问题。
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://bestlixiang.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://bestlixiang.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>文件读写哪家强？</title>
    <link href="http://bestlixiang.site/2019/07/07/Java%E5%9F%BA%E7%A1%80/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E5%93%AA%E5%AE%B6%E5%BC%BA%EF%BC%9F/"/>
    <id>http://bestlixiang.site/2019/07/07/Java基础/文件读写哪家强？/</id>
    <published>2019-07-07T11:11:27.000Z</published>
    <updated>2019-07-07T06:51:32.351Z</updated>
    
    <content type="html"><![CDATA[<p>引：最近看了零拷贝相关的内容，自然而然就会引申到文件的读写，文件读写无处不在，因为数据很重要，需要持久化。刚好最近也看看RocketMq，里面也有关于消息文件的读写，想狠狠了解一番，但是最终结果是只知道了性能结果，但是却不明白为什么，留下一些线索，等待回头<strong>证明</strong> ！徐大佬说要去看linux源码可能才有了解，先溜了！渴望c大神带我看一遍！<a id="more"></a></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>Java 中的文件读写接口大致可以分为三类：</p>
<ol>
<li>标准 IO 读写，位于 java.io 包下，相关类：FileInputStream，FileOuputStream，RandomAccessFile</li>
<li>NIO 读写，位于 java.nio 包下，相关类：FileChannel，ByteBuffer</li>
<li>Mmap 内存映射，位于 java.nio 包下，相关类：FileChannel，MappedByteBuffer</li>
</ol>
<p>标准 IO 读写这里就不说，毕竟大家一开始学的都是这个，下面说说其他两种。</p>
<h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得FileChannel</span></span><br><span class="line">FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"data"</span>), <span class="string">"rw"</span>).getChannel();</span><br><span class="line"><span class="comment">// 写</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">1024L</span>;</span><br><span class="line"><span class="comment">//指定 position 写入 4kb 的数据</span></span><br><span class="line">fileChannel.write(ByteBuffer.wrap(data), position);</span><br><span class="line"><span class="comment">//从当前文件指针的位置写入 4kb 的数据</span></span><br><span class="line">fileChannel.write(ByteBuffer.wrap(data));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读 </span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">1024L</span>;</span><br><span class="line"><span class="comment">//指定 position 读取 4kb 的数据</span></span><br><span class="line">fileChannel.read(buffer,position)；</span><br><span class="line"><span class="comment">//从当前文件指针的位置读取 4kb 的数据</span></span><br><span class="line">fileChannel.read(buffer);</span><br></pre></td></tr></table></figure>
<p>上面的<code>ByteBuffer</code> 也可以替换为<code>DirectByteBuffer</code>，这里不替换，在最后写入的时候也会替换，具体为什么，可以参考徐大佬的博客。</p>
<h2 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得MappedByteBuffer</span></span><br><span class="line">FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"data"</span>), <span class="string">"rw"</span>).getChannel();</span><br><span class="line">MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, filechannel.size());</span><br><span class="line"><span class="comment">// 写</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> position = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//从当前 mmap 指针的位置写入 4b 的数据</span></span><br><span class="line">mappedByteBuffer.put(data);</span><br><span class="line"><span class="comment">//指定 position 写入 4b 的数据</span></span><br><span class="line">MappedByteBuffer subBuffer = mappedByteBuffer.slice();</span><br><span class="line">subBuffer.position(position);</span><br><span class="line">subBuffer.put(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> position = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//从当前 mmap 指针的位置读取 4b 的数据</span></span><br><span class="line">mappedByteBuffer.get(data)；</span><br><span class="line"><span class="comment">//指定 position 读取 4b 的数据</span></span><br><span class="line">MappedByteBuffer subBuffer = mappedByteBuffer.slice();</span><br><span class="line">subBuffer.position(position);</span><br><span class="line">subBuffer.get(data);</span><br></pre></td></tr></table></figure>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>自己跟着@莫那——鲁道的benchmark过了一遍，结论统一(原因不知)：</p>
<table>
<thead>
<tr>
<th>数据包大小</th>
<th>读</th>
<th>写</th>
<th>force写</th>
</tr>
</thead>
<tbody>
<tr>
<td>小于4kb</td>
<td>mmap</td>
<td></td>
<td></td>
</tr>
<tr>
<td>大于4kb</td>
<td>FileChannel</td>
<td></td>
<td></td>
</tr>
<tr>
<td>小于64b</td>
<td></td>
<td>FileChannel</td>
<td>FileChannel</td>
</tr>
<tr>
<td>大于64b</td>
<td></td>
<td>Mmap</td>
<td>FileChannel</td>
</tr>
</tbody>
</table>
<h1 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h1><p>普通人一生必经的四个阶段：</p>
<p>心比天高的无知与快乐</p>
<p>愧不如人的奋斗与煎熬</p>
<p>毫无回报的愤懑与失望</p>
<p>坦然自若的平凡与颓废</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/d0b4ac90dbcb" target="_blank" rel="noopener">MappedByteBuffer VS FileChannel 孰强孰弱？</a></li>
<li><a href="https://www.cnkirito.moe/mq-million-queue/" target="_blank" rel="noopener">天池中间件大赛百万队列存储设计总结【复赛】</a></li>
<li><a href="https://www.cnkirito.moe/file-io-best-practise/" target="_blank" rel="noopener">文件IO操作的一些最佳实践</a></li>
<li><a href="https://www.cnkirito.moe/nio-buffer-recycle/" target="_blank" rel="noopener">一文探讨堆外内存的监控与回收</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：最近看了零拷贝相关的内容，自然而然就会引申到文件的读写，文件读写无处不在，因为数据很重要，需要持久化。刚好最近也看看RocketMq，里面也有关于消息文件的读写，想狠狠了解一番，但是最终结果是只知道了性能结果，但是却不明白为什么，留下一些线索，等待回头&lt;strong&gt;证明&lt;/strong&gt; ！徐大佬说要去看linux源码可能才有了解，先溜了！渴望c大神带我看一遍！
    
    </summary>
    
      <category term="Java基础" scheme="http://bestlixiang.site/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="IO" scheme="http://bestlixiang.site/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>零拷贝</title>
    <link href="http://bestlixiang.site/2019/07/07/Java%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <id>http://bestlixiang.site/2019/07/07/Java基础/零拷贝/</id>
    <published>2019-07-07T03:19:21.000Z</published>
    <updated>2019-07-07T03:21:14.647Z</updated>
    
    <content type="html"><![CDATA[<p>引：<strong>零拷贝</strong>是在文件读写以及数据传输中必须了解的优化措施。在 Java 程序员的世界，常用的零拷贝有 mmap 和 sendFile。自己之前也总是模模糊糊的了解，这次看到一篇文章让自己印象很深刻，下面我将会是翻译一下并加以引申！<a id="more"></a></p>
<h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><p><a href="https://www.linuxjournal.com/article/6345" target="_blank" rel="noopener">Zero Copy I: User-Mode Perspective</a></p>
<h1 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h1><p>如今几乎每个人都听说过在Linux下的零拷贝功能，但是我经常遇到人没有充分理解这个问题的。因此，我决定写一些文章深入研究得深一些,希望能解开这个有用的功能。在本文中，我们将从用户空间应用程序的角度来看看<strong>零拷贝</strong>,所以复杂的内核级细节是故意省略了的。</p>
<p><strong>零拷贝是什么? </strong>　　</p>
<p>为了更好地理解一个问题的解决方案，我们首先需要了解问题本身。让我们来看看数据存储在一个文件中通过网络发送应用简单过程。这里有一些示例代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>
<p>看起来很简单，你会认为没有多少开销，只有这两个系统调用。在现实中，这两个系统调用数据被复制至少四次，而且做了很多的用户/内核执行上下文切换(实际上这个过程要复杂得多,但我想保持它简单)。看看下图。顶部显示上下文切换，底部显示复制操作。</p>
<p><img src="https://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/063/6345/6345f1.jpg" alt="系统调用"></p>
<p>第一步: read系统调用会导致从用户模式到内核模式的上下文切换。第一次复制是利用DMA从磁盘读取文件内容，并将它们存储到一个内核地址空间缓冲区。</p>
<p>第二步：数据从内核缓冲区拷贝到用户缓冲区。同时read系统调用返回，该调用的返回引发了内核模式到用户模式的上下文切换。现在数据被储存在用户地址空间缓冲区,</p>
<p>第三步：write系统调用会导致用户模式到内核模式的上下文切换。同时将数据复制到内核地址空间缓冲区。这一次,数据放入不同的缓冲，这个缓冲与套接字相关联。</p>
<p>第四步：系统调用返回，发生了第4次上下文切换。同时DMA独立且异步将数据从内核缓冲区复制到网卡。你可能会问自己，”独立和异步?不是在返回用户模式之前调用吗？”，事实上，这里并不保证传输，它甚至不保证传输的开始。这仅仅意味着以太网驱动程序的队列有空位，并接受了我们的数据传输。可能会有众多的数据排在我们的数据之前。(分叉的DMA复制在图中说明了这个事实，最后复制可以延迟)。</p>
<p>正如您可以看到的，大量的数据复制并不是必需的东西。某些冗余可以被消除，以减少开销和提高性能。作为硬件驱动程序开发人员，有一些很高级的特性。一些硬件可以完全绕开内存,将数据直接传送给另一个设备。这个特性消除了系统内存复制，是一个好事，但并不是所有的硬件支持。为了减少开销，我们可以从消除内核和用户缓冲区之间的复制。</p>
<p>消除一个复制的一个方法是调用<strong>mmap系统调用</strong>读。例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmp_buf = mmap(file, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>
<p><img src="https://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/063/6345/6345f2.jpg" alt="系统调用读"></p>
<p>第一步：mmap系统调用会利用DMA将文件内容复制到内核缓冲区的。内核缓冲去与用户缓存区共享一个空间，没有任何复制内存在内核和用户空间之间进行。</p>
<p>第二步：write系统调用会导致内核数据从原来的内核缓冲区复制到与套接字相关联的内核缓冲区。</p>
<p>第三步：DMA将数据从内核套接字缓冲区复制到网卡。</p>
<p>用mmap而不是read，我们可以减少一半内核复制的数据量。当拷贝数据量很大时，无疑提升了效率。但是使用mmap是有代价的。当你使用mmap时，你可能会遇到一些隐藏的陷阱。例如，当你的程序map了一个文件，但是当这个文件被另一个进程截断(truncate)时, write系统调用会因为访问非法地址而被SIGBUS信号终止。SIGBUS信号默认会杀死你的进程并产生一个coredump,如果你的服务器这样被中止了，那会产生一笔损失。 通常我们使用以下两种解决方案避免这种问题：</p>
<p>第一种方式是<strong>为SIGBUS信号建立信号处理程序 </strong>。当遇到SIGBUS信号时，信号处理程序简单地返回，write系统调用在被中断之前会返回已经写入的字节数，并且errno会被设置成success,但是这是一种糟糕的处理办法，因为你并没有解决问题的实质核心。 </p>
<p>第二种方式是<strong>使用文件租借锁</strong> 通常我们使用这种方法，在文件描述符上使用租借锁，我们为文件向内核申请一个租借锁，当其它进程想要截断这个文件时，内核会向我们发送一个实时的RT_SIGNAL_LEASE信号，告诉我们内核正在破坏你加持在文件上的读写锁。这样在程序访问非法内存并且被SIGBUS杀死之前，你的write系统调用会被中断。write会返回已经写入的字节数，并且置errno为success。 我们应该在mmap文件之前加锁，并且在操作完文件后解锁。下面是一些示例代码显示如何从内核:获得租借锁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fcntl(fd, F_SETSIG, RT_SIGNAL_LEASE) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"kernel lease set signal"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* l_type can be F_RDLCK F_WRLCK */</span></span><br><span class="line"><span class="keyword">if</span>(fcntl(fd, F_SETLEASE, l_type))&#123;</span><br><span class="line">    perror(<span class="string">"kernel lease set type"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消除一个复制的一个方法是<strong>Sendfile</strong></p>
<p>在内核版本2.1中，介绍了sendfile系统调用来简化数据的传输。引入sendfile不仅降低了数据复制，它还可以减少上下文切换。使用它是这样的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendfile(socket, file, len);</span><br></pre></td></tr></table></figure>
<p><img src="https://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/063/6345/6345f3.jpg" alt="sendfile"></p>
<p>第一步：sendfile系统调用会利用DMA让文件内容复制到内核缓冲区。然后由内核的数据复制到与套接字相关联的内核缓冲区。</p>
<p>第二步：第三次复制发生在DMA将数据从内核套接字缓冲区复制到网卡。</p>
<p>你可能会好奇，在我们调用sendfile时，如果有其它进程截断了文件会发生什么呢？假设我们没有设置任何信号处理程序，sendfile调用仅仅返回它在被中断之前已经传输的字节数，errno会被置为success。如果我们在调用sendfile之前给文件加了锁，sendfile的行为仍然和之前相同，我们还会收到RT_SIGNAL_LEASE的信号。</p>
<p>目前为止，我们已经减少了数据拷贝的次数了，但是仍然存在一次CPU拷贝，就是内核缓冲去到socket缓冲区的拷贝。那么能不能把这个拷贝也省略呢？借助于硬件上的帮助，我们是可以办到的。之前我们是把页缓存的数据拷贝到socket缓存中，实际上，我们仅仅需要把缓冲区描述符传到socket缓冲区，再把数据长度传过去，这样DMA可以直接将内核缓存区中的数据打包发送到网络中就可以了。如下图：</p>
<p><img src="https://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/063/6345/6345f4.jpg" alt="零拷贝"></p>
<p>这种是需要硬件的支持。步骤如下：<br>第一步：sendfile系统调用会利用DMA让文件内容复制到内核缓冲区。</p>
<p>第二步：没有内核缓冲区和与套接字相关联的内核缓冲区之间的复制，而是把缓冲区描述符和数据长度传到socket缓冲区。DMA会直接将内核缓存区的数据复制到网卡，这样就减少了最后一次CPU复制。</p>
<p>由于数据仍然存在是从磁盘复制到内存和从内存复制到网卡，有些人可能会认为这不是一个真正的零拷贝。但是从操作系统的角度来看,这是零拷，,因为内核缓冲区之间的数据不重复。使用零拷贝时，不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 CPU 缓存伪共享以及无 CPU 校验和计算。</p>
<p><strong>后面的实践部分就不翻译了</strong></p>
<h1 id="Java的应用"><a href="#Java的应用" class="headerlink" title="Java的应用"></a>Java的应用</h1><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>在Java不支持mmap的用法，但是提供一个<code>MappedByteBuffer</code> 文件内存映射，它可以加快读写，强行使用来文件拷贝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mmapTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String dir = <span class="string">"/Users/rex/data/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RandomAccessFile memoryMappedFileIn = <span class="keyword">new</span> RandomAccessFile(dir + <span class="string">"testIn.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        RandomAccessFile memoryMappedFileOut = <span class="keyword">new</span> RandomAccessFile(dir + <span class="string">"testOut.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        MappedByteBuffer mappedByteBufferOut = memoryMappedFileOut.getChannel().map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">byte</span>[] temp = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">        memoryMappedFileIn.read(temp);</span><br><span class="line">        mappedByteBufferOut.put(temp);</span><br><span class="line">        mappedByteBufferOut.force();</span><br><span class="line">        memoryMappedFileIn.close();</span><br><span class="line">        memoryMappedFileOut.close();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"mmap时间："</span> + (end - start));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sendFile"><a href="#sendFile" class="headerlink" title="sendFile"></a>sendFile</h2><p>在Java很好的实现了sendFile，其对应的实现是<code>FileChannel#transferTo()</code>，（有兴趣的可以去看对应的native实现）可以对应于文件拷贝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendFileTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String dir = <span class="string">"/Users/rex/data/"</span>;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RandomAccessFile memoryMappedFileIn = <span class="keyword">new</span> RandomAccessFile(dir + <span class="string">"testMmapIn.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        RandomAccessFile memoryMappedFileOut = <span class="keyword">new</span> RandomAccessFile(dir + <span class="string">"testMmapOut.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel fileChannelIn = memoryMappedFileIn.getChannel();</span><br><span class="line">        FileChannel fileChannelOut = memoryMappedFileOut.getChannel();</span><br><span class="line">        fileChannelIn.transferTo(<span class="number">0</span>, memoryMappedFileIn.length(), fileChannelOut);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"sendFile时间："</span> + (end - start));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间来说必然是下面的快，所以我们很多工具包中都能看到<code>FileChannel#transferTo()</code>的身影。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>个人觉得只要减少了拷贝都属于零拷贝！请大佬们指正！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.linuxjournal.com/article/6345" target="_blank" rel="noopener">Zero Copy I: User-Mode Perspective</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：&lt;strong&gt;零拷贝&lt;/strong&gt;是在文件读写以及数据传输中必须了解的优化措施。在 Java 程序员的世界，常用的零拷贝有 mmap 和 sendFile。自己之前也总是模模糊糊的了解，这次看到一篇文章让自己印象很深刻，下面我将会是翻译一下并加以引申！
    
    </summary>
    
      <category term="Java基础" scheme="http://bestlixiang.site/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="零拷贝" scheme="http://bestlixiang.site/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>Java应用的优雅停机</title>
    <link href="http://bestlixiang.site/2019/07/06/Java%E5%9F%BA%E7%A1%80/Java%E5%BA%94%E7%94%A8%E7%9A%84%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA/"/>
    <id>http://bestlixiang.site/2019/07/06/Java基础/Java应用的优雅停机/</id>
    <published>2019-07-06T02:00:19.000Z</published>
    <updated>2019-07-06T02:05:54.553Z</updated>
    
    <content type="html"><![CDATA[<p>引：对于一个鲁棒的Java应用来说，<strong>优雅停机</strong> 必不可少的。下面我将先介绍Java优雅停机的实现方式，然后介绍在Dubbo中的服务是如何实现优雅停机的。<a id="more"></a></p>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>在Linux中，信号是进程间通讯的一种方式，它采用的是异步机制。当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行。</p>
<h2 id="信号的响应动作"><a href="#信号的响应动作" class="headerlink" title="信号的响应动作"></a>信号的响应动作</h2><p>每个信号都有自己的响应动作，当接收到信号时，进程会根据信号的响应动作执行相应的操作，信号的响应动作有以下几种：</p>
<ul>
<li>中止进程(Term)</li>
<li>忽略信号(Ign)</li>
<li>中止进程并保存内存信息(Core)</li>
<li>停止进程(Stop)</li>
<li>继续运行进程(Cont)</li>
</ul>
<h2 id="停机信号"><a href="#停机信号" class="headerlink" title="停机信号"></a>停机信号</h2><p>在linux上，我们停机主要是使用 kill 的方式。关于停机对应的信号主要有下面两个，也是我们平时经常使用的两种：</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>值</th>
<th>动作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>Term</td>
<td>结束程序(可以被捕获、阻塞或忽略) kill的默认信号</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>Term</td>
<td>无条件结束程序(不能被捕获、阻塞或忽略)</td>
</tr>
</tbody>
</table>
<h1 id="Java停机方式"><a href="#Java停机方式" class="headerlink" title="Java停机方式"></a>Java停机方式</h1><p><strong>优雅停机</strong>：指的是在应用关闭时能够处理一下“善后”的逻辑，比如</p>
<ol>
<li>关闭 socket 链接</li>
<li>清理临时文件</li>
<li>发送消息通知给订阅方，告知自己下线</li>
<li>将自己将要被销毁的消息通知给子进程</li>
<li>各种资源的释放</li>
</ol>
<p>我们知道在执行<code>kill -9 pid</code>时是无条件结束程序的，所以在这种情况下我们无法优雅停机，只有在执行<code>kill -15 pid</code> 或者<code>kill pid</code>时才能实现。但是如果发现：<code>kill -15 pid</code> 无法关闭应用，则可以考虑使用<code>kill -9 pid</code>，但请事后务必排查出是什么原因导致<code>kill -15 pid</code> 无法关闭。所以在编写停机脚本时也要先<code>kill -15 pid</code> ，如果关闭失败，再执行<code>kill -9 pid</code>。</p>
<h2 id="Shutdown-Hook"><a href="#Shutdown-Hook" class="headerlink" title="Shutdown Hook"></a>Shutdown Hook</h2><p>先看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> DbShutdownWork());</span><br><span class="line">        System.out.println(<span class="string">"JVM 已启动"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DbShutdownWork</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭数据库连接"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们执行<code>kill pid</code>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JVM 已启动</span><br><span class="line">关闭数据库连接</span><br></pre></td></tr></table></figure>
<p>Shutdown Hook 会保证 JVM 一直运行，直到 hook 终止。</p>
<h2 id="SignalHandler"><a href="#SignalHandler" class="headerlink" title="SignalHandler"></a>SignalHandler</h2><p>先看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 信号处理实例</span></span><br><span class="line">        DbSignalHandler mySignalHandler = <span class="keyword">new</span> DbSignalHandler();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册对指定信号的处理</span></span><br><span class="line">        Signal.handle(<span class="keyword">new</span> Signal(<span class="string">"TERM"</span>) ,mySignalHandler);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"JVM 已启动"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DbSignalHandler</span> <span class="keyword">implements</span> <span class="title">SignalHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Signal signal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 信号量名称</span></span><br><span class="line">        String name = signal.getName();</span><br><span class="line">        <span class="comment">// 信号量数值</span></span><br><span class="line">        <span class="keyword">int</span> number = signal.getNumber();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(name.equals(<span class="string">"TERM"</span>) &amp;&amp; number == <span class="number">15</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭数据库连接"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SignalHandler是在<code>sun.misc</code>下的，就是JDK提供的各种后面啦。</p>
<p>看了上面两种方法，其实实质都是一样的，都是利用信用，在捕获终止信号的时候做一些操作来实现优雅停机。</p>
<h1 id="Dubbo优雅停机"><a href="#Dubbo优雅停机" class="headerlink" title="Dubbo优雅停机"></a>Dubbo优雅停机</h1><p>先引入官方文档：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 原理</span></span><br><span class="line"><span class="section">## 服务提供方</span></span><br><span class="line"><span class="bullet">* </span>停止时，先标记为不接收新请求，新请求过来时直接报错，让客户端重试其它机器。</span><br><span class="line"><span class="bullet">* </span>然后，检测线程池中的线程是否正在运行，如果有，等待所有线程执行完成，除非超时，则强制关闭。</span><br><span class="line"></span><br><span class="line"><span class="section">## 服务消费方</span></span><br><span class="line"><span class="bullet">* </span>停止时，不再发起新的调用请求，所有新的调用在客户端即报错。</span><br><span class="line"><span class="bullet">* </span>然后，检测有没有请求的响应还没有返回，等待响应返回，除非超时，则强制关闭。</span><br><span class="line"></span><br><span class="line"><span class="section">## 设置方式</span></span><br><span class="line">设置优雅停机超时时间，缺省超时时间是 10 秒，如果超时则强制关闭。</span><br><span class="line">dubbo.properties</span><br><span class="line">dubbo.service.shutdown.wait=15000</span><br><span class="line">如果 ShutdownHook 不能生效，可以自行调用，使用tomcat等容器部署的場景，建议通过扩展ContextListener等自行调用以下代码实现优雅停机：</span><br><span class="line">ProtocolConfig.destroyAll();</span><br></pre></td></tr></table></figure>
<p>我们看到了熟悉的ShutdownHook，所以下面我们需要去找ShutdownHook是在哪添加的？</p>
<h2 id="ShutdownHook"><a href="#ShutdownHook" class="headerlink" title="ShutdownHook"></a>ShutdownHook</h2><p>Dubbo 的优雅停机 <strong>ShutdownHook</strong> 在 <code>AbstractConfig</code> 的静态代码块初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到<code>DubboShutdownHook</code>继承于<code>Thread</code>，所以我们需要去看的run方法，就能知道在停机时需要干什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    destroyAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!destroyed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭注册中心</span></span><br><span class="line">    AbstractRegistryFactory.destroyAll();</span><br><span class="line">    <span class="comment">// 标记为不接收新请求，同时不再发起新的调用请求</span></span><br><span class="line">    destroyProtocols();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RegistryDestroy"><a href="#RegistryDestroy" class="headerlink" title="RegistryDestroy"></a>RegistryDestroy</h2><p>上面我们看到停机之后主要做了两件事情，我们先来看第一件事情，关闭注册中心连接，，取消服务中的服务提供者和消费者的<strong>订阅</strong>与<strong>注册</strong>。 我们以<code>Zookeeper</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.dubbo.registry.zookeeper.ZookeeperRegistry</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 调用父类FailbackRegistry的destroy方法</span></span><br><span class="line">      <span class="keyword">super</span>.destroy();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">// 关闭zkClient的连接</span></span><br><span class="line">          zkClient.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          logger.warn(<span class="string">"Failed to close zookeeper client "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.dubbo.registry.support.FailbackRegistry</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 调用父类AbstractRegistry的destroy方法</span></span><br><span class="line">      <span class="keyword">super</span>.destroy();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">// 关闭心跳重试任务</span></span><br><span class="line">          retryFuture.cancel(<span class="keyword">true</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          logger.warn(t.getMessage(), t);</span><br><span class="line">      &#125;</span><br><span class="line">    	<span class="comment">// 待会解析</span></span><br><span class="line">      ExecutorUtil.gracefulShutdown(retryExecutor, retryPeriod);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.dubbo.registry.support.AbstractRegistry</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 取消注册</span></span><br><span class="line">      Set&lt;URL&gt; destroyRegistered = <span class="keyword">new</span> HashSet&lt;URL&gt;(getRegistered());</span><br><span class="line">      <span class="keyword">if</span> (!destroyRegistered.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">for</span> (URL url : <span class="keyword">new</span> HashSet&lt;URL&gt;(getRegistered())) &#123;</span><br><span class="line">              <span class="keyword">if</span> (url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">// 取消注册</span></span><br><span class="line">                      unregister(url);</span><br><span class="line">                      <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                          logger.info(<span class="string">"Destroy unregister url "</span> + url);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                      logger.warn(<span class="string">"Failed to unregister url "</span> + url + <span class="string">" to registry "</span> + getUrl() + <span class="string">" on destroy, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 取消订阅</span></span><br><span class="line">      Map&lt;URL, Set&lt;NotifyListener&gt;&gt; destroySubscribed = <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed());</span><br><span class="line">      <span class="keyword">if</span> (!destroySubscribed.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : destroySubscribed.entrySet()) &#123;</span><br><span class="line">              URL url = entry.getKey();</span><br><span class="line">              <span class="keyword">for</span> (NotifyListener listener : entry.getValue()) &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">// 取消订阅</span></span><br><span class="line">                      unsubscribe(url, listener);</span><br><span class="line">                      <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                          logger.info(<span class="string">"Destroy unsubscribe url "</span> + url);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                      logger.warn(<span class="string">"Failed to unsubscribe url "</span> + url + <span class="string">" to registry "</span> + getUrl() + <span class="string">" on destroy, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="ProtocolDestroy"><a href="#ProtocolDestroy" class="headerlink" title="ProtocolDestroy"></a>ProtocolDestroy</h2><p>现在我们来看第二件事：标记为不接收新请求，同时不再发起新的调用请求，即销毁所有通信 ExchangeClient 和 ExchangeServer，其实最终就是关闭NettyServer和Client，这里以Dubbo协议为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destroyProtocols</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ExtensionLoader&lt;Protocol&gt; loader = ExtensionLoader.getExtensionLoader(Protocol.class);</span><br><span class="line">      <span class="keyword">for</span> (String protocolName : loader.getLoadedExtensions()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Protocol protocol = loader.getLoadedExtension(protocolName);</span><br><span class="line">              <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) &#123;</span><br><span class="line">                	<span class="comment">// 关闭服务</span></span><br><span class="line">                  protocol.destroy();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">              logger.warn(t.getMessage(), t);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 销毁所有 ExchangeServer</span></span><br><span class="line">      <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(serverMap.keySet())) &#123;</span><br><span class="line">          ExchangeServer server = serverMap.remove(key);</span><br><span class="line">          <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                      logger.info(<span class="string">"Close dubbo server: "</span> + server.getLocalAddress());</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 调用 HeaderExchangeServer#close</span></span><br><span class="line">                  server.close(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                  logger.warn(t.getMessage(), t);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 销毁所有 ExchangeClient</span></span><br><span class="line">      <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(referenceClientMap.keySet())) &#123;</span><br><span class="line">          ExchangeClient client = referenceClientMap.remove(key);</span><br><span class="line">          <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                      logger.info(<span class="string">"Close dubbo connect: "</span> + client.getLocalAddress() + <span class="string">"--&gt;"</span> + client.getRemoteAddress());</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 调用 ReferenceCountExchangeClient#close</span></span><br><span class="line">                  client.close(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                  logger.warn(t.getMessage(), t);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 销毁所有幽灵 ExchangeClient</span></span><br><span class="line">      <span class="comment">// 幽灵Client，是指在获取链接的时候，链接为空或者已经被关闭了</span></span><br><span class="line">      <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(ghostClientMap.keySet())) &#123;</span><br><span class="line">          ExchangeClient client = ghostClientMap.remove(key);</span><br><span class="line">          <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                      logger.info(<span class="string">"Close dubbo connect: "</span> + client.getLocalAddress() + <span class="string">"--&gt;"</span> + client.getRemoteAddress());</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 调用 LazyConnectExchangeClient#close</span></span><br><span class="line">                  client.close(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                  logger.warn(t.getMessage(), t);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      stubServiceMethodsMap.clear();</span><br><span class="line">      <span class="comment">// 调用父类AbstractProtocol的destroy方法</span></span><br><span class="line">      <span class="keyword">super</span>.destroy();</span><br><span class="line">  &#125;	</span><br><span class="line"><span class="comment">// org.apache.dubbo.rpc.protocol.AbstractProtocol</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 不再发起新的调用请求</span></span><br><span class="line">      <span class="keyword">for</span> (Invoker&lt;?&gt; invoker : invokers) &#123;</span><br><span class="line">          <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">              invokers.remove(invoker);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                      logger.info(<span class="string">"Destroy reference: "</span> + invoker.getUrl());</span><br><span class="line">                  &#125;</span><br><span class="line">                  invoker.destroy();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                  logger.warn(t.getMessage(), t);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    	<span class="comment">// 标记为不接收新请求</span></span><br><span class="line">      <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(exporterMap.keySet())) &#123;</span><br><span class="line">          Exporter&lt;?&gt; exporter = exporterMap.remove(key);</span><br><span class="line">          <span class="keyword">if</span> (exporter != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                      logger.info(<span class="string">"Unexport service: "</span> + exporter.getInvoker().getUrl());</span><br><span class="line">                  &#125;</span><br><span class="line">                  exporter.unexport();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                  logger.warn(t.getMessage(), t);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="ExecutorUtil"><a href="#ExecutorUtil" class="headerlink" title="ExecutorUtil"></a>ExecutorUtil</h2><p>其实我们在分析中会看到<code>ExecutorUtil#gracefulShutdown()</code>这样一个方法，它其实对应的是<strong>检测线程池中的线程是否正在运行，如果有，等待所有线程执行完成，除非超时，则强制关闭</strong>。文档说它用的是Java自带的线程池关闭策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gracefulShutdown</span><span class="params">(Executor executor, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不是 ExecutorService ，或者已经关闭，忽略</span></span><br><span class="line">    <span class="keyword">if</span> (!(executor <span class="keyword">instanceof</span> ExecutorService) || isTerminated(executor)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ExecutorService es = (ExecutorService) executor;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 禁止新的任务提交，将原有任务执行完，这些都是自带线程池的机制</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex2) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException ex2) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 等待原有任务执行完。若等待超时，强制结束所有任务，默认为10秒</span></span><br><span class="line">        <span class="keyword">if</span> (!es.awaitTermination(timeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">          	<span class="comment">// 抛弃队列中的任务，并中断所有工作线程</span></span><br><span class="line">            es.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">        <span class="comment">// 发生 InterruptedException 异常，也强制结束所有任务</span></span><br><span class="line">        es.shutdownNow();</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若未关闭成功，新开线程去关闭</span></span><br><span class="line">    <span class="keyword">if</span> (!isTerminated(es)) &#123;</span><br><span class="line">        newThreadToCloseExecutor(es);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="https://www.cnblogs.com/3me-linux/p/3927221.html" target="_blank" rel="noopener">linux信号调用机制</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/1110765" target="_blank" rel="noopener">研究优雅停机时的一点思考</a></p>
</li>
<li>精尽 Dubbo 源码解析 —— 优雅停机</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：对于一个鲁棒的Java应用来说，&lt;strong&gt;优雅停机&lt;/strong&gt; 必不可少的。下面我将先介绍Java优雅停机的实现方式，然后介绍在Dubbo中的服务是如何实现优雅停机的。
    
    </summary>
    
      <category term="Java基础" scheme="http://bestlixiang.site/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="优雅停机" scheme="http://bestlixiang.site/tags/%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA/"/>
    
      <category term="Dubbo" scheme="http://bestlixiang.site/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat源码分析——类加载机制</title>
    <link href="http://bestlixiang.site/2019/07/02/Tomcat%E6%BA%90%E7%A0%81/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://bestlixiang.site/2019/07/02/Tomcat源码/Tomcat源码分析——类加载机制/</id>
    <published>2019-07-02T07:32:48.000Z</published>
    <updated>2019-07-02T10:23:43.354Z</updated>
    
    <content type="html"><![CDATA[<p>引：相信大家对于Java类加载的认识最开始都是来自于《深入理解Java虚拟机》，可能觉得就一个<strong>双亲委派机制</strong>嘛，没什么东西！但是具体到实际应用，对于类加载器却有所不同，今天我们就跟着Tomcat源码来分析一下它的类加载机制！<a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个说到Tomcat源码，在看源码之前，我们都需要先理解它的架构与一些设计原理，如果图快，可以从最后的参考中快速消化一下Tomcat的架构，但是如果是想系统看一下看Tomcat的全貌，我建议可以好好去看看《深入剖析Tomcat》，虽然他对应的版本对于现在来说有点老了，但是核心思想是不变的，相信很多人看完之后会和我一样有一种恍然大悟的感觉。关于怎么看Tomcat源码也可以在最后的参考中找到相关链接。</p>
<h1 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h1><p>在说Tomcat的类加载机制之前，我们一定要先看看Java自己的类加载机制，之前自己对《深入理解Java虚拟机》中描述的Java类加载机制一篇总结文章，可以先看看：<a href="http://todorex.com/2017/12/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-9-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" target="_blank" rel="noopener">深入理解JVM<em>9</em>类加载器</a></p>
<h1 id="Tomcat类加载机制"><a href="#Tomcat类加载机制" class="headerlink" title="Tomcat类加载机制"></a>Tomcat类加载机制</h1><p>Tomcat使用类加载器的原因有3条：(待会会在源码中看出)</p>
<ol>
<li>为了在载入类指定某些规则</li>
<li>为了缓存已经载入的类</li>
<li>为了实现类的预加载，方便使用</li>
</ol>
<h2 id="设计图"><a href="#设计图" class="headerlink" title="设计图"></a>设计图</h2><p><img src="https://upload-images.jianshu.io/upload_images/10354196-fff334f481929cad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/462/format/webp" alt="Tomcat类加载机制设计"></p>
<ul>
<li>commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；</li>
<li>catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；</li>
<li>sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；</li>
<li>WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；</li>
<li>JasperLoader: 每一个JSP文件对应一个Jsp类加载器，实现热加载；</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Tomcat启动"><a href="#Tomcat启动" class="headerlink" title="Tomcat启动"></a>Tomcat启动</h3><p>如果看过Tomcat的架构和设计，就应该知道Tomcat的启动时运行<code>main</code>方法作为入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// daemon就是bootstrap，当初始化完成之后会赋值给daemon</span></span><br><span class="line">    <span class="keyword">if</span> (daemon == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化</span></span><br><span class="line">            bootstrap.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleThrowable(t);</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        daemon = bootstrap;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 设置线程上下文类加载器继续加载，保持一致</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要知道daemon初始化干了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// Tomcat 自己的类加载器结构</span></span><br><span class="line">      initClassLoaders();</span><br><span class="line">      <span class="comment">// 将 catalinaLoader 类加载器设置为当前线程上下文类加载器.</span></span><br><span class="line">      Thread.currentThread().setContextClassLoader(catalinaLoader);</span><br><span class="line">      <span class="comment">// 并设置线程安全类加载器进行类加载</span></span><br><span class="line">      SecurityClassLoad.securityClassLoad(catalinaLoader);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Load our startup class and call its process() method</span></span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">          log.debug(<span class="string">"Loading startup class"</span>);</span><br><span class="line">      <span class="comment">// 加载启动对象</span></span><br><span class="line">      Class&lt;?&gt; startupClass = catalinaLoader.loadClass(<span class="string">"org.apache.catalina.startup.Catalina"</span>);</span><br><span class="line">      Object startupInstance = startupClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set the shared extensions class loader</span></span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">          log.debug(<span class="string">"Setting startup class properties"</span>);</span><br><span class="line">      <span class="comment">// 使用反射调用该实例的setParentClassLoader 方法, 参数为 sharedLoader</span></span><br><span class="line">      <span class="comment">// 表示该实例的父类加载器为 sharedLoader. </span></span><br><span class="line">    	<span class="comment">// 这里暗含了后面生成的WebappClassLoader的parent就是sharedLoader</span></span><br><span class="line">      String methodName = <span class="string">"setParentClassLoader"</span>;</span><br><span class="line">      Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">      paramTypes[<span class="number">0</span>] = Class.forName(<span class="string">"java.lang.ClassLoader"</span>);</span><br><span class="line">      Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">      paramValues[<span class="number">0</span>] = sharedLoader;</span><br><span class="line">      Method method =</span><br><span class="line">          startupInstance.getClass().getMethod(methodName, paramTypes);</span><br><span class="line">      method.invoke(startupInstance, paramValues);</span><br><span class="line">      <span class="comment">// 设置 catalinaDaemon 为该实例</span></span><br><span class="line">      catalinaDaemon = startupInstance;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键来了</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initClassLoaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// tomcat公用的类加载器 parent为null 违背了java自己的类加载机制</span></span><br><span class="line">          commonLoader = createClassLoader(<span class="string">"common"</span>, <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span>( commonLoader == <span class="keyword">null</span> ) &#123;</span><br><span class="line">              <span class="comment">// no config file, default to this loader - we might be in a 'single' env.</span></span><br><span class="line">              <span class="comment">// 找不到配置文件中的 key 的时候或者 key 对应的 value 为空的时候回返回 null</span></span><br><span class="line">              <span class="comment">// 如果返回 null, 那么就设置默认的类加载器为 common 类加载器.</span></span><br><span class="line">              commonLoader=<span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 调试可知：</span></span><br><span class="line">          <span class="comment">// 可以找不到配置文件中的 key, 所以他们直接返回父类加载器, 也就是说(默认情况下), 他们三个使用的是同一个类加载器.</span></span><br><span class="line">          catalinaLoader = createClassLoader(<span class="string">"server"</span>, commonLoader);</span><br><span class="line">          sharedLoader = createClassLoader(<span class="string">"shared"</span>, commonLoader);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          handleThrowable(t);</span><br><span class="line">          log.error(<span class="string">"Class loader creation threw exception"</span>, t);</span><br><span class="line">          System.exit(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建commonLoader</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(String name, ClassLoader parent)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 拿到资源（要加载类的路径）</span></span><br><span class="line">      <span class="comment">// common.loader 对应的 Value=$&#123;catalina.base&#125;/lib,$&#123;catalina.base&#125;/lib/*.jar,$&#123;catalina.home&#125;/lib,$&#123;catalina.home&#125;/lib/*.jar</span></span><br><span class="line">      String value = CatalinaProperties.getProperty(name + <span class="string">".loader"</span>);</span><br><span class="line">      <span class="comment">// 如果不存在, 返回 null</span></span><br><span class="line">      <span class="keyword">if</span> ((value == <span class="keyword">null</span>) || (value.equals(<span class="string">""</span>)))</span><br><span class="line">          <span class="keyword">return</span> parent;</span><br><span class="line">      <span class="comment">// 使用环境变量对应的目录替换字符串</span></span><br><span class="line">      value = replace(value);</span><br><span class="line">      <span class="comment">// Repository是ClassLoaderFactory 中的一个静态内部类</span></span><br><span class="line">      <span class="comment">// 有2个属性, location, type, 表示某个位置的某种类型的文件</span></span><br><span class="line">      List&lt;Repository&gt; repositories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">// 将路径变成一个数组</span></span><br><span class="line">      String[] repositoryPaths = getPaths(value);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (String repository : repositoryPaths) &#123;</span><br><span class="line">          <span class="comment">// Check for a JAR URL repository</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">              URL url = <span class="keyword">new</span> URL(repository);</span><br><span class="line">              repositories.add(</span><br><span class="line">                      <span class="keyword">new</span> Repository(repository, RepositoryType.URL));</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">              <span class="comment">// Ignore</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Local repository</span></span><br><span class="line">          <span class="keyword">if</span> (repository.endsWith(<span class="string">"*.jar"</span>)) &#123;</span><br><span class="line">              repository = repository.substring</span><br><span class="line">                  (<span class="number">0</span>, repository.length() - <span class="string">"*.jar"</span>.length());</span><br><span class="line">              repositories.add(</span><br><span class="line">                      <span class="keyword">new</span> Repository(repository, RepositoryType.GLOB));</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (repository.endsWith(<span class="string">".jar"</span>)) &#123;</span><br><span class="line">              repositories.add(</span><br><span class="line">                      <span class="keyword">new</span> Repository(repository, RepositoryType.JAR));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              repositories.add(</span><br><span class="line">                      <span class="keyword">new</span> Repository(repository, RepositoryType.DIR));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据给定的路径数组前去加载给定的 class 文件，生成URLClassLoader</span></span><br><span class="line">      <span class="keyword">return</span> ClassLoaderFactory.createClassLoader(repositories, parent);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>初始化完三个类加载之后，上面就会让catalinaLoader加载Tomcat所需要的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">securityClassLoad</span><span class="params">(ClassLoader loader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    securityClassLoad(loader, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">securityClassLoad</span><span class="params">(ClassLoader loader, <span class="keyword">boolean</span> requireSecurityManager)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requireSecurityManager &amp;&amp; System.getSecurityManager() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// securityClassLoad方法主要加载Tomcat容器所需的class</span></span><br><span class="line">    <span class="comment">// Tomcat核心class，即org.apache.catalina.core路径下的class</span></span><br><span class="line">    loadCorePackage(loader);</span><br><span class="line">    <span class="comment">// Tomcat连接器，即org.apache.coyote路径下的class</span></span><br><span class="line">    loadCoyotePackage(loader);</span><br><span class="line">    <span class="comment">// Tomcat应用类加载器, org.apache.catalina.loader.WebappClassLoader</span></span><br><span class="line">    loadLoaderPackage(loader);</span><br><span class="line">    <span class="comment">// org.apache.catalina.realm下的class</span></span><br><span class="line">    loadRealmPackage(loader);</span><br><span class="line">    <span class="comment">// org.apache.catalina.servlets下的class</span></span><br><span class="line">    loadServletsPackage(loader);</span><br><span class="line">    <span class="comment">// org.apache.catalina.session下的class；</span></span><br><span class="line">    loadSessionPackage(loader);</span><br><span class="line">    <span class="comment">// org.apache.catalina.util下的class</span></span><br><span class="line">    loadUtilPackage(loader);</span><br><span class="line">    <span class="comment">// org.apache.catalina.valves下的class</span></span><br><span class="line">    loadValvesPackage(loader);</span><br><span class="line">    <span class="comment">// javax.servlet.http.Cookie</span></span><br><span class="line">    loadJavaxPackage(loader);</span><br><span class="line">    <span class="comment">// org.apache.catalina.connector的class</span></span><br><span class="line">    loadConnectorPackage(loader);</span><br><span class="line">    <span class="comment">// org.apache.catalina.util路径下的class</span></span><br><span class="line">    loadTomcatPackage(loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里daemon就被创建完成了，启动也就结束了！</p>
<h3 id="WebappClassLoader创建"><a href="#WebappClassLoader创建" class="headerlink" title="WebappClassLoader创建"></a>WebappClassLoader创建</h3><p>上面说了Tomcat类加载机制中的三大加载器，但是对于Tomcat来说WebappClassLoader或许是最关键的，因为应用里的类都靠它加载。看过Tomcat架构的都知道WebappClassLoader是和容器StandardContext绑定在一起的。所以我们跟StandardContext生命周期的启动方法<code>startInternal</code>进去看看（该方法比较长，省略很多内容，只看关键）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getLoader() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 生成一个WebappLoader，parent为sharedClassLoader一直传递下去</span></span><br><span class="line">        WebappLoader webappLoader = <span class="keyword">new</span> WebappLoader(getParentClassLoader());</span><br><span class="line">        webappLoader.setDelegate(getDelegate());</span><br><span class="line">      	<span class="comment">// 绑定 StandardContext容器</span></span><br><span class="line">        setLoader(webappLoader);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            <span class="comment">// Start our subordinate components, if any</span></span><br><span class="line">            Loader loader = getLoader();</span><br><span class="line">            <span class="keyword">if</span> (loader <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">              	<span class="comment">// 这里执行生命的周期的start方法，最后会回调到WebappLoader的startInternal方法</span></span><br><span class="line">                ((Lifecycle) loader).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// org.apache.catalina.loader.WebappLoader </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建WebAppClassLoader，跟进去</span></span><br><span class="line">        classLoader = createClassLoader();</span><br><span class="line">        <span class="comment">// 设置其资源路径为当前Webapp下某个context的类资源</span></span><br><span class="line">        classLoader.setResources(context.getResources());</span><br><span class="line">        classLoader.setDelegate(<span class="keyword">this</span>.delegate);</span><br><span class="line">		<span class="comment">// 生命周期钩子</span></span><br><span class="line">        ((Lifecycle) classLoader).start();</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">private</span> WebappClassLoaderBase <span class="title">createClassLoader</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 通过反射实例化classLoader</span></span><br><span class="line">    <span class="comment">// 这里是ParallelWebappClassLoader</span></span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(loaderClass);</span><br><span class="line">    WebappClassLoaderBase classLoader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 这里父类加载器是Catalina实例中的sharedClassLoader</span></span><br><span class="line">    <span class="keyword">if</span> (parentClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        parentClassLoader = context.getParentClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt;[] argTypes = &#123; ClassLoader.class &#125;;</span><br><span class="line">    Object[] args = &#123; parentClassLoader &#125;;</span><br><span class="line">    Constructor&lt;?&gt; constr = clazz.getConstructor(argTypes);</span><br><span class="line">    classLoader = (WebappClassLoaderBase) constr.newInstance(args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> classLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，WebappClassLoader就被实例化完成了。</p>
<h3 id="WebappClassLoader类加载"><a href="#WebappClassLoader类加载" class="headerlink" title="WebappClassLoader类加载"></a>WebappClassLoader类加载</h3><p><code>WebappClassLoader</code>就被实例化完成了，接下来我们就需要看看它是如何加载类的？找到他的<code>loaderClass</code>方法，<code>ParallelWebappClassLoader</code>的<code>loadClass</code>是在其父类<code>WebappClassLoaderBase</code>中实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">      	</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (0) Check our previously loaded local class cache</span></span><br><span class="line">        <span class="comment">// 检查WebappClassLoader中是否加载过此类</span></span><br><span class="line">        <span class="comment">// 类中维护了一个resourceEntries的ConcurrentHashMap</span></span><br><span class="line">        clazz = findLoadedClass0(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                log.debug(<span class="string">"  Returning class from cache"</span>);</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (0.1) Check our previously loaded class cache</span></span><br><span class="line">        <span class="comment">// 检查JVM虚拟机中是否加载过该类</span></span><br><span class="line">        clazz = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                log.debug(<span class="string">"  Returning class from cache"</span>);</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (0.2) Try loading the class with the system class loader, to prevent</span></span><br><span class="line">        <span class="comment">//       the webapp from overriding Java SE classes. This implements</span></span><br><span class="line">        <span class="comment">//       SRV.10.7.2</span></span><br><span class="line">        <span class="comment">// 用应用类加载器加载该类（也就是当前JVM的ClassPath），为了防止覆盖基础类实现</span></span><br><span class="line">        String resourceName = binaryNameToPath(name, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        ClassLoader javaseLoader = getJavaseClassLoader();</span><br><span class="line">        <span class="keyword">boolean</span> tryLoadingFromJavaseLoader;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (tryLoadingFromJavaseLoader) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = javaseLoader.loadClass(name);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (resolve)</span><br><span class="line">                        resolveClass(clazz);</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先判断是否设置了delegate属性，设置为true，那么就会完全按照JVM的"双亲委托"机制流程加载类</span></span><br><span class="line">        <span class="keyword">boolean</span> delegateLoad = delegate || filter(name, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (1) Delegate to our parent if requested</span></span><br><span class="line">      	<span class="comment">// 双亲委派模式，从上到下加载</span></span><br><span class="line">        <span class="keyword">if</span> (delegateLoad) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                log.debug(<span class="string">"  Delegating to parent classloader1 "</span> + parent);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = Class.forName(name, <span class="keyword">false</span>, parent);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                        log.debug(<span class="string">"  Loading class from parent"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (resolve)</span><br><span class="line">                        resolveClass(clazz);</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (2) Search local repositories</span></span><br><span class="line">        <span class="comment">// 若是默认的话，是先使用WebappClassLoader自己处理加载类的</span></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">            log.debug(<span class="string">"  Searching local repositories"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过自定义findClass定义处理类加载规则</span></span><br><span class="line">            clazz = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                    log.debug(<span class="string">"  Loading class from local repository"</span>);</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (3) Delegate to parent unconditionally</span></span><br><span class="line">        <span class="comment">// 若是WebappClassLoader在/WEB-INF/classes、/WEB-INF/lib下还是查找不到class</span></span><br><span class="line">        <span class="comment">// 那么委托给Common类加载器去查找该类 ，这里满足双亲委派原则</span></span><br><span class="line">        <span class="keyword">if</span> (!delegateLoad) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                log.debug(<span class="string">"  Delegating to parent classloader at end: "</span> + parent);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = Class.forName(name, <span class="keyword">false</span>, parent);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                        log.debug(<span class="string">"  Loading class from parent"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (resolve)</span><br><span class="line">                        resolveClass(clazz);</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里总结一下delegate属性为false，即默认的情况下的加载顺序：</p>
<ol>
<li>检查本地缓存</li>
<li>如果没有，检查虚拟机缓存</li>
<li>如果没有，从AppClassLoader加载，这里会使用Java自己的类加载体系</li>
<li>如果没有，则从WebappClassLoader加载（按照WEB-INF/classes、WEB-INF/lib的顺序）</li>
<li>如果没有，则从父类加载器加载，由于父类加载器采用默认的委派模式，所以加载顺序是Common、Shared</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里用一到面试题结束：Tomcat的类加载机制是否违反了双亲委托原则？</p>
<p>答案：是，具体怎么破坏了看本文理解。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p>《深入剖析Tomcat》</p>
</li>
<li><p><a href="https://blog.csdn.net/qq_38245537/article/details/79009448" target="_blank" rel="noopener">四张图带你了解Tomcat系统架构</a></p>
</li>
<li><a href="https://yq.aliyun.com/articles/663198" target="_blank" rel="noopener">怎么读 Tomcat 源码？</a></li>
<li><a href="http://todorex.com/2017/12/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-9-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" target="_blank" rel="noopener">深入理解JVM<em>9</em>类加载器</a></li>
<li><a href="https://www.cnblogs.com/aspirant/p/8991830.html" target="_blank" rel="noopener">图解Tomcat类加载机制(阿里面试题)</a></li>
<li><a href="https://www.jianshu.com/p/69c4526b843d" target="_blank" rel="noopener">Tomcat源码分析 – Tomcat类加载器</a></li>
<li><a href="https://blog.csdn.net/yangcheng33/article/details/52631940" target="_blank" rel="noopener">真正理解线程上下文类加载器（多案例分析）</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：相信大家对于Java类加载的认识最开始都是来自于《深入理解Java虚拟机》，可能觉得就一个&lt;strong&gt;双亲委派机制&lt;/strong&gt;嘛，没什么东西！但是具体到实际应用，对于类加载器却有所不同，今天我们就跟着Tomcat源码来分析一下它的类加载机制！
    
    </summary>
    
      <category term="Tomcat源码" scheme="http://bestlixiang.site/categories/Tomcat%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Tomcat" scheme="http://bestlixiang.site/tags/Tomcat/"/>
    
      <category term="ClassLoader" scheme="http://bestlixiang.site/tags/ClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——事务消息</title>
    <link href="http://bestlixiang.site/2019/07/02/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/"/>
    <id>http://bestlixiang.site/2019/07/02/RocketMQ源码/RocketMQ源码分析——事务消息/</id>
    <published>2019-07-01T23:21:45.000Z</published>
    <updated>2019-07-02T02:38:28.274Z</updated>
    
    <content type="html"><![CDATA[<p>引：在前面的源码分析中，我们总是能在很多地方看到对于事务消息特别的逻辑，这次我们终于可以讲一下啦！同时对利用消息队列来实现分布式事务感兴趣的同学也是不可错过的！<a id="more"></a></p>
<h1 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h1><p>例子：通过购物车进行下单的流程中，用户入口在购物车系统，交易下单入口在交易系统，两个系统之间的数据需要保持最终一致，这时可以通过事务消息进行处理。交易系统下单之后，发送一条交易下单的消息到消息队列 RocketMQ，购物车系统订阅消息队列 RocketMQ 的交易下单消息，做相应的业务处理，更新购物车数据。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>消息队列 RocketMQ 事务消息交互流程如下所示：</p>
<p><img src="http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/43348/cn_zh/1557378341241/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.PNG" alt="交互流程"></p>
<ol>
<li>发送方向消息队列 RocketMQ 服务端发送消息。</li>
<li>服务端将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功，此时消息为半消息。</li>
<li>发送方开始执行本地事务逻辑。</li>
<li>发送方根据本地事务执行结果向服务端提交二次确认（Commit 或是 Rollback），服务端收到 Commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；服务端收到 Rollback 状态则删除半消息，订阅方将不会接受该消息。</li>
<li>在断网或者是应用重启的特殊情况下，上述步骤 4 提交的二次确认最终未到达服务端，经过固定时间后服务端将对该消息发起消息回查。</li>
<li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>发送方根据检查得到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤 4 对半消息进行操作。</li>
</ol>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>NameServer还是按照之前<code>环境搭建</code>篇启动，但是Broker不行，因为我们运行的test包下的broker，为了单元测试，官方利用<code>SPI</code></p>
<p>注入了<code>org.apache.rocketmq.broker.util.TransactionalMessageServiceImpl</code> ，这个不是我们想要的<code>TransactionalMessageService</code>，所以我们找到<code>rocketmq/broker/src/test/resources/META-INF/service/org.apache.rocketmq.broker.transaction.TransactionalMessageService</code> 这个文件把里面的东西删了就好了。对于生成者，自己魔改了官方事务消息的例子，因为我感觉不太好理解。对于消费者，我们可以直接使用<code>quickstart</code>包的例子。</p>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>核心在于实现一个<code>TransactionListener</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">        TransactionListener transactionListener = <span class="keyword">new</span> TransactionListenerImpl();</span><br><span class="line">        TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2000</span>), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">                thread.setName(<span class="string">"client-transaction-msg-check-thread"</span>);</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.setExecutorService(executorService);</span><br><span class="line">        producer.setTransactionListener(transactionListener);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Message msg =</span><br><span class="line">                    <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>, <span class="string">"KEY"</span> + i,</span><br><span class="line">                        (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                SendResult sendResult = producer.sendMessageInTransaction(msg, <span class="keyword">null</span>);</span><br><span class="line">                System.out.println(<span class="string">"发送: "</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger transactionIndex = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger checktimes = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Integer&gt; localTrans = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = transactionIndex.getAndIncrement();</span><br><span class="line">        <span class="keyword">int</span> status = value % <span class="number">3</span>;</span><br><span class="line">        localTrans.put(msg.getTransactionId(), status);</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">        Integer status = localTrans.get(msg.getTransactionId());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(msg.getBody())+<span class="string">" 回查"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != status) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(msg.getBody())+<span class="string">" 回查次数: "</span> + checktimes.incrementAndGet());</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="comment">// 消费者应该只能收到这一条消息</span></span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_4"</span>);</span><br><span class="line">        <span class="comment">// 指明Namesrv</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line"></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">              </span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h3><p><img src="https://upload-images.jianshu.io/upload_images/10354196-683c967f4c72ae62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tansaction-message-producer.png"></p>
<h3 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h3><p><img src="https://upload-images.jianshu.io/upload_images/10354196-612b0775065ab230.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="transaction-message-consumerpng.png"></p>
<p>根据我们代码逻辑，我们第一次发送本地事务都是执行失败的，所以所有消息都要进行回查，但是标识为0的消息回查会一直返回失败，所以会一直回查，这里因为时间问题只看到两次，最多默认回查15次，标识为1的消息回查之后会返回Commit，所以我们在消费者端看到了这条消息，标识为2的消息在回查之后返回Rollback，所以消费者端看不到了。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>我们的分析就是就是按照上面实现原理的交互流程走一遍，现在就来看看吧！</p>
<h2 id="TransactionMQProducer启动"><a href="#TransactionMQProducer启动" class="headerlink" title="TransactionMQProducer启动"></a>TransactionMQProducer启动</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// org.apache.rocketmq.client.producer.TransactionMQProducer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.defaultMQProducerImpl.initTransactionEnv();</span><br><span class="line">  		<span class="comment">// 其他和普通消息没有什么区别</span></span><br><span class="line">      <span class="keyword">super</span>.start();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 创建回查线程池</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initTransactionEnv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      TransactionMQProducer producer = (TransactionMQProducer) <span class="keyword">this</span>.defaultMQProducer;</span><br><span class="line">      <span class="keyword">if</span> (producer.getExecutorService() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.checkExecutor = producer.getExecutorService();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.checkRequestQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(producer.getCheckRequestHoldMax());</span><br><span class="line">          <span class="keyword">this</span>.checkExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">              producer.getCheckThreadPoolMinSize(),</span><br><span class="line">              producer.getCheckThreadPoolMaxSize(),</span><br><span class="line">              <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">              TimeUnit.MILLISECONDS,</span><br><span class="line">              <span class="keyword">this</span>.checkRequestQueue);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="TransactionMQProducer发送事务消息"><a href="#TransactionMQProducer发送事务消息" class="headerlink" title="TransactionMQProducer发送事务消息"></a>TransactionMQProducer发送事务消息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.producer.TransactionMQProducer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionSendResult <span class="title">sendMessageInTransaction</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> Object arg)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    	<span class="comment">// 事务监听器必须有，因为要提供Broker回查</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.transactionListener) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"TransactionListener is null"</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.defaultMQProducerImpl.sendMessageInTransaction(msg, <span class="keyword">null</span>, arg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TransactionSendResult <span class="title">sendMessageInTransaction</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        <span class="keyword">final</span> LocalTransactionExecuter localTransactionExecuter, <span class="keyword">final</span> Object arg)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">      <span class="comment">// 检查TransactionListener和回查线程池是否存在</span></span><br><span class="line">      TransactionListener transactionListener = getCheckListener();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == localTransactionExecuter &amp;&amp; <span class="keyword">null</span> == transactionListener) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"tranExecutor is null"</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 消息校验，校验topic和body长度</span></span><br><span class="line">      Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">      SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 设置消息的事务属性,为PREPARED消息以及发送的ProducerGroup</span></span><br><span class="line">      MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, <span class="string">"true"</span>);</span><br><span class="line">      MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, <span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 发送消息，和发送普通消息一样</span></span><br><span class="line">          sendResult = <span class="keyword">this</span>.send(msg);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"send message Exception"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">		</span><br><span class="line">      LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">      Throwable localException = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">switch</span> (sendResult.getSendStatus()) &#123;</span><br><span class="line">          <span class="comment">// 发送成功</span></span><br><span class="line">          <span class="keyword">case</span> SEND_OK: &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 当前Broker不会返回这个值</span></span><br><span class="line">                  <span class="keyword">if</span> (sendResult.getTransactionId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      msg.putUserProperty(<span class="string">"__transactionId__"</span>, sendResult.getTransactionId());</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 使用客户端生成的唯一id作为事务ID</span></span><br><span class="line">                  String transactionId = msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</span><br><span class="line">                  <span class="keyword">if</span> (<span class="keyword">null</span> != transactionId &amp;&amp; !<span class="string">""</span>.equals(transactionId)) &#123;</span><br><span class="line">                      msg.setTransactionId(transactionId);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 默认为空, 官方已标注为 @deprecated</span></span><br><span class="line">                  <span class="keyword">if</span> (<span class="keyword">null</span> != localTransactionExecuter) &#123;</span><br><span class="line">                      localTransactionState = localTransactionExecuter.executeLocalTransactionBranch(msg, arg);</span><br><span class="line">                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transactionListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      log.debug(<span class="string">"Used new transaction API"</span>);</span><br><span class="line">                      <span class="comment">// 调用transactionListener执行本地事务</span></span><br><span class="line">                      localTransactionState = transactionListener.executeLocalTransaction(msg, arg);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="keyword">null</span> == localTransactionState) &#123;</span><br><span class="line">                      localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) &#123;</span><br><span class="line">                      log.info(<span class="string">"executeLocalTransactionBranch return &#123;&#125;"</span>, localTransactionState);</span><br><span class="line">                      log.info(msg.toString());</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                  log.info(<span class="string">"executeLocalTransactionBranch exception"</span>, e);</span><br><span class="line">                  log.info(msg.toString());</span><br><span class="line">                  localException = e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 消息持久化失败，则事务回滚</span></span><br><span class="line">          <span class="keyword">case</span> FLUSH_DISK_TIMEOUT:</span><br><span class="line">          <span class="keyword">case</span> FLUSH_SLAVE_TIMEOUT:</span><br><span class="line">          <span class="keyword">case</span> SLAVE_NOT_AVAILABLE:</span><br><span class="line">              localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 发送结束事务消息（Commit/Rollback）</span></span><br><span class="line">          <span class="keyword">this</span>.endTransaction(sendResult, localTransactionState, localException);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          log.warn(<span class="string">"local transaction execute "</span> + localTransactionState + <span class="string">", but end broker transaction failed"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回事务发送结果</span></span><br><span class="line">      TransactionSendResult transactionSendResult = <span class="keyword">new</span> TransactionSendResult();</span><br><span class="line">      transactionSendResult.setSendStatus(sendResult.getSendStatus());</span><br><span class="line">      transactionSendResult.setMessageQueue(sendResult.getMessageQueue());</span><br><span class="line">      transactionSendResult.setMsgId(sendResult.getMsgId());</span><br><span class="line">      transactionSendResult.setQueueOffset(sendResult.getQueueOffset());</span><br><span class="line">      transactionSendResult.setTransactionId(sendResult.getTransactionId());</span><br><span class="line">      transactionSendResult.setLocalTransactionState(localTransactionState);</span><br><span class="line">      <span class="keyword">return</span> transactionSendResult;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送结束事务消息（Commit/Rollback）</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endTransaction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> SendResult sendResult,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> LocalTransactionState localTransactionState,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> Throwable localException)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException, UnknownHostException </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> MessageId id;</span><br><span class="line">      <span class="comment">// 获取消息在commitLog的offset</span></span><br><span class="line">      <span class="keyword">if</span> (sendResult.getOffsetMsgId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          id = MessageDecoder.decodeMessageId(sendResult.getMsgId());</span><br><span class="line">      &#125;</span><br><span class="line">      String transactionId = sendResult.getTransactionId();</span><br><span class="line">      <span class="comment">// 获取接收prepared消息的Broker地址</span></span><br><span class="line">      <span class="keyword">final</span> String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(sendResult.getMessageQueue().getBrokerName());</span><br><span class="line">      EndTransactionRequestHeader requestHeader = <span class="keyword">new</span> EndTransactionRequestHeader();</span><br><span class="line">      requestHeader.setTransactionId(transactionId);</span><br><span class="line">      requestHeader.setCommitLogOffset(id.getOffset());</span><br><span class="line">      <span class="comment">// 根据本地执行结果设置提交或回滚</span></span><br><span class="line">      <span class="keyword">switch</span> (localTransactionState) &#123;</span><br><span class="line">          <span class="keyword">case</span> COMMIT_MESSAGE:</span><br><span class="line">              requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> ROLLBACK_MESSAGE:</span><br><span class="line">              requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> UNKNOW:</span><br><span class="line">              requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">      <span class="comment">// 设置消息在broker上的queueOffset</span></span><br><span class="line">      requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());</span><br><span class="line">      requestHeader.setMsgId(sendResult.getMsgId());</span><br><span class="line">      String remark = localException != <span class="keyword">null</span> ? (<span class="string">"executeLocalTransactionBranch exception: "</span> + localException.toString()) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 使用Oneway方式发送结束事务消息RequestCode.END_TRANSACTION</span></span><br><span class="line">      <span class="comment">// Broker处理无论成功还是失败，Producer不会再做处理</span></span><br><span class="line">      <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark,</span><br><span class="line">          <span class="keyword">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Broker处理Prepared消息"><a href="#Broker处理Prepared消息" class="headerlink" title="Broker处理Prepared消息"></a>Broker处理Prepared消息</h2><p><strong>Broker处理Prepared消息</strong>是和普通消息用的同一个<code>SendMessageProcessor</code>，所以我们在之前的分析中看到很多穿插事务消息的代码，下面我们就看下针对事务消息的特殊处理逻辑（没有看过<code>SendMessageProcessor</code>，可以看看我之前的文章）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.broker.processor.SendMessageProcessor</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">final</span> RemotingCommand request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">final</span> SendMessageContext sendMessageContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">final</span> SendMessageRequestHeader requestHeader)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">      Map&lt;String, String&gt; oriProps = MessageDecoder.string2messageProperties(requestHeader.getProperties());</span><br><span class="line">      String traFlag = oriProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">      <span class="keyword">if</span> (traFlag != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(traFlag)) &#123;</span><br><span class="line">          <span class="comment">// 根据Broker是否支持事务消息判断是否拒绝事务消息</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</span><br><span class="line">              response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">              response.setRemark(</span><br><span class="line">                  <span class="string">"the broker["</span> + <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1()</span><br><span class="line">                      + <span class="string">"] sending transaction message is forbidden"</span>);</span><br><span class="line">              <span class="keyword">return</span> response;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 存储prepare消息</span></span><br><span class="line">          putMessageResult = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().prepareMessage(msgInner);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据存储结果设置repsonse状态，更新broker统计信息，成功则回复producer，更新context上下文</span></span><br><span class="line">      <span class="keyword">return</span> handlePutMessageResult(putMessageResult, response, request, msgInner, responseHeader, sendMessageContext, ctx, queueIdInt);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上面我们看到存储prepare消息和存储正常的消息走的不一样的路径，prepare消息调用了<code>TransactionalMessageService#prepareMessage()</code>，我们可以看一下，但是相信最终也只是存入CommitLog中而已：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImpl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">prepareMessage</span><span class="params">(MessageExtBrokerInner messageInner)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> transactionalMessageBridge.putHalfMessage(messageInner);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putHalfMessage</span><span class="params">(MessageExtBrokerInner messageInner)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 进行消息的转换</span></span><br><span class="line">      <span class="keyword">return</span> store.putMessage(parseHalfMessageInner(messageInner));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> MessageExtBrokerInner <span class="title">parseHalfMessageInner</span><span class="params">(MessageExtBrokerInner msgInner)</span> </span>&#123;</span><br><span class="line">      MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic());</span><br><span class="line">      MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID,</span><br><span class="line">          String.valueOf(msgInner.getQueueId()));</span><br><span class="line">      <span class="comment">// 清除sysFlag中的事务消息状态位</span></span><br><span class="line">      msgInner.setSysFlag(</span><br><span class="line">          MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), MessageSysFlag.TRANSACTION_NOT_TYPE));</span><br><span class="line">      <span class="comment">// 事务prepare消息放入统一的topic: RMQ_SYS_TRANS_HALF_TOPIC</span></span><br><span class="line">    	<span class="comment">// 这个topic是系统内置的，consumer不会订阅这个topic的消息</span></span><br><span class="line">      msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic());</span><br><span class="line">      <span class="comment">// queueId统一设置成0</span></span><br><span class="line">      msgInner.setQueueId(<span class="number">0</span>);</span><br><span class="line">      msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));</span><br><span class="line">      <span class="keyword">return</span> msgInner;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Broker处理Commit-Rollback消息"><a href="#Broker处理Commit-Rollback消息" class="headerlink" title="Broker处理Commit/Rollback消息"></a>Broker处理Commit/Rollback消息</h2><p><strong>Broker处理Commit/Rollback消息</strong>不再使用<code>SendMessageProcessor</code>，而是使用了<code>EndTransactionProcessor</code>来处理<code>Commit/Rollback</code> 消息，但是分析思路是不变的，先找到<code>org.apache.rocketmq.broker.processor.EndTransactionProcessor#processRequest()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">    RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> EndTransactionRequestHeader requestHeader =</span><br><span class="line">        (EndTransactionRequestHeader)request.decodeCommandCustomHeader(EndTransactionRequestHeader.class);</span><br><span class="line">    LOGGER.info(<span class="string">"Transaction request:&#123;&#125;"</span>, requestHeader);</span><br><span class="line">    <span class="keyword">if</span> (BrokerRole.SLAVE == brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SLAVE_NOT_AVAILABLE);</span><br><span class="line">        LOGGER.warn(<span class="string">"Message store is slave mode, so end transaction is forbidden. "</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 省略日志相关...</span></span><br><span class="line">  </span><br><span class="line">    OperationResult result = <span class="keyword">new</span> OperationResult();</span><br><span class="line">    <span class="comment">// 如果收到的是Commit事务消息</span></span><br><span class="line">    <span class="keyword">if</span> (MessageSysFlag.TRANSACTION_COMMIT_TYPE == requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">        <span class="comment">// 从commitLog中查出原始的prepared消息</span></span><br><span class="line">        <span class="comment">// 这要求了Producer在发送最终的Commit消息的时候一定要指定是同一个Broker</span></span><br><span class="line">        result = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().commitMessage(requestHeader);</span><br><span class="line">        <span class="keyword">if</span> (result.getResponseCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">            <span class="comment">// 检查获取到的消息是否和当前消息匹配</span></span><br><span class="line">            RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);</span><br><span class="line">            <span class="keyword">if</span> (res.getCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                <span class="comment">// 使用原始的prepared消息属性，构建最终发给consumer的消息</span></span><br><span class="line">                MessageExtBrokerInner msgInner = endMessageTransaction(result.getPrepareMessage());</span><br><span class="line">                msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback()));</span><br><span class="line">                msgInner.setQueueOffset(requestHeader.getTranStateTableOffset());</span><br><span class="line">                msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset());</span><br><span class="line">                msgInner.setStoreTimestamp(result.getPrepareMessage().getStoreTimestamp());</span><br><span class="line">                <span class="comment">// 调用MessageStore的消息存储接口提交消息，使用真正的topic和queueId</span></span><br><span class="line">                RemotingCommand sendResult = sendFinalMessage(msgInner);</span><br><span class="line">                <span class="keyword">if</span> (sendResult.getCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                    <span class="comment">// 设置Prepared消息的标记位为delete</span></span><br><span class="line">                    <span class="keyword">this</span>.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sendResult;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">        <span class="comment">// 如果收到的是Rollback事务消息</span></span><br><span class="line">        result = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().rollbackMessage(requestHeader);</span><br><span class="line">        <span class="keyword">if</span> (result.getResponseCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">            RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);</span><br><span class="line">            <span class="keyword">if</span> (res.getCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                <span class="comment">// 设置Prepared消息的标记位为delete</span></span><br><span class="line">                <span class="keyword">this</span>.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    response.setCode(result.getResponseCode());</span><br><span class="line">    response.setRemark(result.getResponseRemark());</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息Commit/Rollback后，理论上需要将原来的Prepared消息删除，这样Broker就能知道哪些消息一直没收到Commit/Rollback，需要去<code>Producer</code>回查状态。但是如果直接修改<code>CommitLog</code>文件，这个代价是很大的，所以<code>RocketMQ</code>是通过生成一个新的delete消息来标记的。这样，<code>Broker</code>在检查的时候只需要看下<code>Prepared</code>消息有没有对应的<code>delete</code>消息就可以了，我们看看这个这个操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImpl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deletePrepareMessage</span><span class="params">(MessageExt msgExt)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.transactionalMessageBridge.putOpMessage(msgExt, TransactionalMessageUtil.REMOVETAG)) &#123;</span><br><span class="line">          log.info(<span class="string">"Transaction op message write successfully. messageId=&#123;&#125;, queueId=&#123;&#125; msgExt:&#123;&#125;"</span>, msgExt.getMsgId(), msgExt.getQueueId(), msgExt);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.error(<span class="string">"Transaction op message write failed. messageId is &#123;&#125;, queueId is &#123;&#125;"</span>, msgExt.getMsgId(), msgExt.getQueueId());</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// org.apache.rocketmq.broker.transaction.queue.TransactionalMessageBridge</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putOpMessage</span><span class="params">(MessageExt messageExt, String opType)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//选择和Prepared消息相同的queue</span></span><br><span class="line">      MessageQueue messageQueue = <span class="keyword">new</span> MessageQueue(messageExt.getTopic(),</span><br><span class="line">          <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerName(), messageExt.getQueueId());</span><br><span class="line">      <span class="keyword">if</span> (TransactionalMessageUtil.REMOVETAG.equals(opType)) &#123;</span><br><span class="line">          <span class="keyword">return</span> addRemoveTagInTransactionOp(messageExt, messageQueue);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addRemoveTagInTransactionOp</span><span class="params">(MessageExt messageExt, MessageQueue messageQueue)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// message的topic为RMQ_SYS_TRANS_OP_HALF_TOPIC</span></span><br><span class="line">      <span class="comment">// 消息的tags值是d，body中存储的是prepared消息的queueOffset</span></span><br><span class="line">      Message message = <span class="keyword">new</span> Message(TransactionalMessageUtil.buildOpTopic(), TransactionalMessageUtil.REMOVETAG,</span><br><span class="line">          String.valueOf(messageExt.getQueueOffset()).getBytes(TransactionalMessageUtil.charset));</span><br><span class="line">      <span class="comment">// 写入CommitLog</span></span><br><span class="line">      writeOp(message, messageQueue);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Broker回查事务状态"><a href="#Broker回查事务状态" class="headerlink" title="Broker回查事务状态"></a>Broker回查事务状态</h2><p>在我们最开始展示的图中，当Broker未收到Commit/Rollback的消息时，会进行事务状态的回查。我们接下就看看这个逻辑，不知道大家还记得我们在<code>Broker启动</code>分析一文中提到了<code>transactionalMessageCheckService</code>这个类的启动，回查逻辑就在这里，这个类也继承<code>ServiceThread</code>，所以它也是一个线程，我们可以直接去看他的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      log.info(<span class="string">"Start transaction check service thread!"</span>);</span><br><span class="line">    	<span class="comment">// 默认1分钟，可配置</span></span><br><span class="line">      <span class="keyword">long</span> checkInterval = brokerController.getBrokerConfig().getTransactionCheckInterval();</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.waitForRunning(checkInterval);</span><br><span class="line">      &#125;</span><br><span class="line">      log.info(<span class="string">"End transaction check service thread!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">waitForRunning</span><span class="params">(<span class="keyword">long</span> interval)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 如果被通知了，就不等了</span></span><br><span class="line">      <span class="keyword">if</span> (hasNotified.compareAndSet(<span class="keyword">true</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">          <span class="keyword">this</span>.onWaitEnd();</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//entry to wait</span></span><br><span class="line">      waitPoint.reset();</span><br><span class="line">      <span class="comment">// 不然，就等待一段时间</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          waitPoint.await(interval, TimeUnit.MILLISECONDS);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          log.error(<span class="string">"Interrupted"</span>, e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          hasNotified.set(<span class="keyword">false</span>);</span><br><span class="line">        	<span class="comment">// 等待结束</span></span><br><span class="line">          <span class="keyword">this</span>.onWaitEnd();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onWaitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 事务检查超时时间 默认6s</span></span><br><span class="line">      <span class="keyword">long</span> timeout = brokerController.getBrokerConfig().getTransactionTimeOut();</span><br><span class="line">      <span class="comment">// 默认最大回查次数 默认15次</span></span><br><span class="line">      <span class="keyword">int</span> checkMax = brokerController.getBrokerConfig().getTransactionCheckMax();</span><br><span class="line">      <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">      log.info(<span class="string">"Begin to check prepare message, begin time:&#123;&#125;"</span>, begin);</span><br><span class="line">      <span class="comment">// 回查</span></span><br><span class="line">      <span class="keyword">this</span>.brokerController.getTransactionalMessageService().check(timeout, checkMax, <span class="keyword">this</span>.brokerController.getTransactionalMessageCheckListener());</span><br><span class="line">      log.info(<span class="string">"End to check prepare message, consumed time:&#123;&#125;"</span>, System.currentTimeMillis() - begin);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImpl</span></span><br><span class="line"><span class="comment">// 核心preparequeue 和 opqueue</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> transactionTimeout, <span class="keyword">int</span> transactionCheckMax,</span></span></span><br><span class="line"><span class="function"><span class="params">      AbstractTransactionalMessageCheckListener listener)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          String topic = MixAll.RMQ_SYS_TRANS_HALF_TOPIC;</span><br><span class="line">          <span class="comment">// 获取所有prepare消息队列，之前说过prepare消息的Topic为RMQ_SYS_TRANS_HALF_TOPIC</span></span><br><span class="line">          Set&lt;MessageQueue&gt; msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);</span><br><span class="line">          <span class="keyword">if</span> (msgQueues == <span class="keyword">null</span> || msgQueues.size() == <span class="number">0</span>) &#123;</span><br><span class="line">              log.warn(<span class="string">"The queue of topic is empty :"</span> + topic);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          log.info(<span class="string">"Check topic=&#123;&#125;, queues=&#123;&#125;"</span>, topic, msgQueues);</span><br><span class="line">          <span class="keyword">for</span> (MessageQueue messageQueue : msgQueues) &#123;</span><br><span class="line">              <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">              <span class="comment">// 拿到对应的opQueue</span></span><br><span class="line">              MessageQueue opQueue = getOpQueue(messageQueue);</span><br><span class="line">              <span class="comment">// 拿到prepare消息的offset</span></span><br><span class="line">              <span class="keyword">long</span> halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue);</span><br><span class="line">              <span class="comment">// 拿到对应的op消息的offset</span></span><br><span class="line">              <span class="keyword">long</span> opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue);</span><br><span class="line">              log.info(<span class="string">"Before check, the queue=&#123;&#125; msgOffset=&#123;&#125; opOffset=&#123;&#125;"</span>, messageQueue, halfOffset, opOffset);</span><br><span class="line">              <span class="keyword">if</span> (halfOffset &lt; <span class="number">0</span> || opOffset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                  log.error(<span class="string">"MessageQueue: &#123;&#125; illegal offset read: &#123;&#125;, op offset: &#123;&#125;,skip this queue"</span>, messageQueue,</span><br><span class="line">                      halfOffset, opOffset);</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              List&lt;Long&gt; doneOpOffset = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">              <span class="comment">// 将标记位delete的消息组成map进行优化</span></span><br><span class="line">              HashMap&lt;Long, Long&gt; removeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">              PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">null</span> == pullResult) &#123;</span><br><span class="line">                  log.error(<span class="string">"The queue=&#123;&#125; check msgOffset=&#123;&#125; with opOffset=&#123;&#125; failed, pullResult is null"</span>,</span><br><span class="line">                      messageQueue, halfOffset, opOffset);</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// single thread</span></span><br><span class="line">              <span class="keyword">int</span> getMessageNullCount = <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">long</span> newOffset = halfOffset;</span><br><span class="line">              <span class="keyword">long</span> i = halfOffset;</span><br><span class="line">              <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (System.currentTimeMillis() - startTime &gt; MAX_PROCESS_TIME_LIMIT) &#123;</span><br><span class="line">                      log.info(<span class="string">"Queue=&#123;&#125; process time reach max=&#123;&#125;"</span>, messageQueue, MAX_PROCESS_TIME_LIMIT);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 事务消息完成</span></span><br><span class="line">                  <span class="keyword">if</span> (removeMap.containsKey(i)) &#123;</span><br><span class="line">                      log.info(<span class="string">"Half offset &#123;&#125; has been committed/rolled back"</span>, i);</span><br><span class="line">                      removeMap.remove(i);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="comment">// 事务消息未完成，拿到prepare消息</span></span><br><span class="line">                      GetResult getResult = getHalfMsg(messageQueue, i);</span><br><span class="line">                      MessageExt msgExt = getResult.getMsg();</span><br><span class="line">                      <span class="comment">// ... </span></span><br><span class="line">                      <span class="comment">// 如果超过最大回查次数或者消息达到最大保留时间，默认3天</span></span><br><span class="line">                      <span class="keyword">if</span> (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) &#123;</span><br><span class="line">                          <span class="comment">// 报错提醒</span></span><br><span class="line">                          listener.resolveDiscardMsg(msgExt);</span><br><span class="line">                          newOffset = i + <span class="number">1</span>;</span><br><span class="line">                          i++;</span><br><span class="line">                          <span class="keyword">continue</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">										<span class="comment">//... 各种判断逻辑，比如prepare消息是否失效等，表示是否需要回查</span></span><br><span class="line">                      <span class="keyword">boolean</span> isNeedCheck = (opMsg == <span class="keyword">null</span> &amp;&amp; valueOfCurrentMinusBorn &gt; checkImmunityTime)</span><br><span class="line">                          || (opMsg != <span class="keyword">null</span> &amp;&amp; (opMsg.get(opMsg.size() - <span class="number">1</span>).getBornTimestamp() - startTime &gt; transactionTimeout))</span><br><span class="line">                          || (valueOfCurrentMinusBorn &lt;= -<span class="number">1</span>);</span><br><span class="line">                      <span class="comment">// 需要回查</span></span><br><span class="line">                      <span class="keyword">if</span> (isNeedCheck) &#123;</span><br><span class="line">                          <span class="comment">// 写入消息成功</span></span><br><span class="line">                          <span class="keyword">if</span> (!putBackHalfMsgQueue(msgExt, i)) &#123;</span><br><span class="line">                              <span class="keyword">continue</span>;</span><br><span class="line">                          &#125;</span><br><span class="line">                        	<span class="comment">// 调用相关发送逻辑</span></span><br><span class="line">                          listener.resolveHalfMsg(msgExt);</span><br><span class="line">                      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                          pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);</span><br><span class="line">                          log.info(<span class="string">"The miss offset:&#123;&#125; in messageQueue:&#123;&#125; need to get more opMsg, result is:&#123;&#125;"</span>, i,</span><br><span class="line">                              messageQueue, pullResult);</span><br><span class="line">                          <span class="keyword">continue</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  newOffset = i + <span class="number">1</span>;</span><br><span class="line">                  i++;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (newOffset != halfOffset) &#123;</span><br><span class="line">                  transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">long</span> newOpOffset = calculateOpOffset(doneOpOffset, opOffset);</span><br><span class="line">              <span class="keyword">if</span> (newOpOffset != opOffset) &#123;</span><br><span class="line">                  transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          log.error(<span class="string">"Check error"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.broker.transaction.AbstractTransactionalMessageCheckListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resolveHalfMsg</span><span class="params">(<span class="keyword">final</span> MessageExt msgExt)</span> </span>&#123;</span><br><span class="line">      executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 发送回查消息</span></span><br><span class="line">                  sendCheckMessage(msgExt);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  LOGGER.error(<span class="string">"Send check message error!"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>OK~到这里我们我们就介绍啦！！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="https://help.aliyun.com/document_detail/43348.html?spm=5176.doc43490.6.566.Zd5Bl7" target="_blank" rel="noopener">阿里云——事务消息</a></p>
</li>
<li><p><a href="[http://silence.work/2018/08/22/RocketMQ-4-3%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/](http://silence.work/2018/08/22/RocketMQ-4-3事务使用与分析/">RocketMQ 事务消息的使用与原理分析</a>)</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在前面的源码分析中，我们总是能在很多地方看到对于事务消息特别的逻辑，这次我们终于可以讲一下啦！同时对利用消息队列来实现分布式事务感兴趣的同学也是不可错过的！
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——顺序消息</title>
    <link href="http://bestlixiang.site/2019/07/01/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF/"/>
    <id>http://bestlixiang.site/2019/07/01/RocketMQ源码/RocketMQ源码分析——顺序消息/</id>
    <published>2019-07-01T00:13:12.000Z</published>
    <updated>2019-07-01T00:13:40.937Z</updated>
    
    <content type="html"><![CDATA[<p>引：在前面的源码分析中，我们总是能在很多地方看到对于顺序消息特别的逻辑，这次我们终于可以讲一下啦！<a id="more"></a></p>
<h1 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h1><h2 id="全局顺序"><a href="#全局顺序" class="headerlink" title="全局顺序"></a>全局顺序</h2><p>对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。</p>
<p><img src="http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/49319/cn_zh/1534917028902/%E5%85%A8%E5%B1%80%E9%A1%BA%E5%BA%8F.png" alt="全局顺序"></p>
<p>适用场景：性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景。</p>
<p>例子：数据库 <code>binlog</code> 同步</p>
<h2 id="局部顺序"><a href="#局部顺序" class="headerlink" title="局部顺序"></a>局部顺序</h2><p>对于指定的一个 Topic，所有消息根据 sharding key 进行区块分区。 同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念。</p>
<p><img src="http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/49319/cn_zh/1534917248438/%E5%88%86%E5%8C%BA%E9%A1%BA%E5%BA%8F2.png" alt="局部顺序"></p>
<p>适用场景：性能要求高，以 sharding key 作为分区字段，在<strong>同一个区块中严格的按照 FIFO 原则</strong>进行消息发布和消费的场景。</p>
<p>例子：假设有个下单场景，每个阶段需要发邮件通知用户订单状态变化。用户付款完成时系统给用户发送订单已付款邮件，订单已发货时给用户发送订单已发货邮件，订单完成时给用户发送订单已完成邮件。假设订单A的消息为A1，A2，A3，发送顺序也如此。订单B的消息为B1，B2，B3，A订单消息先发送，B订单消息后发送。我们不要求消费顺序一定A1，A2，A3，B1，B2，B3这样的全局顺序消息，因为严重降低了系统的并发度。</p>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>NameServer和Broker还是按照之前<code>环境搭建</code>篇启动，但是自己魔改了官方顺序消息的例子，因为我感觉不太好理解。</p>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">            producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">            producer.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> orderId = i % <span class="number">2</span>;</span><br><span class="line">                Message msg =</span><br><span class="line">                    <span class="keyword">new</span> Message(<span class="string">"TopicTestjjj"</span>,</span><br><span class="line">                        (<span class="string">"Hello RocketMQ "</span> + i + <span class="string">" in order "</span> + orderId).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 同一个订单号，使用同一个队列(分区)</span></span><br><span class="line">                      	Integer id = (Integer) arg;</span><br><span class="line">                        <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">                        <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, orderId);</span><br><span class="line"></span><br><span class="line">                System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            producer.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException | RemotingException | MQBrokerException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_3"</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(<span class="string">"TopicTestjjj"</span>, <span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p><img src="https://upload-images.jianshu.io/upload_images/10354196-3788df31eb50866e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="顺序消息.png"></p>
<p>从上面我们看到，虽然订单1和订单2之间是无序的，但是对于单个订单，他的消息是<strong>有序</strong>的。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>我们这里只分析<strong>局部顺序</strong>，全局顺序也是一样的。</p>
<p><strong>要保证消息的顺序消费</strong>，有三个关键点</p>
<ol>
<li>消息顺序发送</li>
<li>消息顺序存储</li>
<li>消息顺序消费</li>
</ol>
<h2 id="消息顺序发送"><a href="#消息顺序发送" class="headerlink" title="消息顺序发送"></a>消息顺序发送</h2><p>多线程发送的消息无法保证有序性，因此，需要业务方在发送时，<strong>针对同一个业务编号(如同一笔订单)的消息需要保证在一个线程内顺序发送</strong>，在上一个消息发送成功后，再进行下一个消息的发送。对于同一个业务编号，生产者消息发送方法必须使用同步发送，异步发送无法保证顺序性。</p>
<h2 id="消息顺序存储"><a href="#消息顺序存储" class="headerlink" title="消息顺序存储"></a>消息顺序存储</h2><p>mq的topic下会存在多个queue，要保证消息的顺序存储，<strong>同一个业务编号的消息需要被发送到一个queue中</strong>。所以需要使用MessageQueueSelector来选择要发送的queue，即对业务编号进行hash，然后根据队列数量对hash值取余，将消息发送到一个queue中，这就是实现<strong>局部顺序</strong>的关键，如果是<strong>全局顺序</strong>，大家应该都能想到就是要将所有的消息只发送到一个队列即可。</p>
<h2 id="消息顺序消费"><a href="#消息顺序消费" class="headerlink" title="消息顺序消费"></a>消息顺序消费</h2><p>要保证消息顺序消费，同一个queue就只能被一个消费者所消费，因此对broker中消费队列加锁是无法避免的。同一时刻，一个消费队列只能被一个消费者消费，消费者内部，也只能有一个消费线程来消费该队列。即<strong>同一时刻，一个消费队列只能被一个消费者中的一个线程消费</strong>。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h2><p>上面我们提到了保证消息的顺序发送和消息顺序存储都是在生产者端控制的，我们在使用方式中也有一定的体现，核心就是<code>MessageQueueSelector</code>。</p>
<p>关于<strong>生产者发送消</strong>息的解析，可以看我之前的文章，这里我们直接跳到和<code>MessageQueueSelector</code>相关的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl  </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendSelectImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">       Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">       MessageQueueSelector selector,</span></span></span><br><span class="line"><span class="function"><span class="params">       Object arg,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> CommunicationMode communicationMode,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> SendCallback sendCallback, <span class="keyword">final</span> <span class="keyword">long</span> timeout</span></span></span><br><span class="line"><span class="function"><span class="params">   )</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> beginStartTime = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line">       Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">       TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">       <span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">           MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 选择队列，使用Hash选择</span></span><br><span class="line">               mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"select message queue throwed exception."</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">long</span> costTime = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">           <span class="keyword">if</span> (timeout &lt; costTime) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendSelectImpl call timeout"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (mq != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 发送消息</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, <span class="keyword">null</span>, timeout - costTime);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"select message queue return null."</span>, <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"No route info for this topic, "</span> + msg.getTopic(), <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// org.apache.rocketmq.client.producer.selector.SelectMessageQueueByHash</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectMessageQueueByHash</span> <span class="keyword">implements</span> <span class="title">MessageQueueSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> value = arg.hashCode();</span><br><span class="line">         <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             value = Math.abs(value);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         value = value % mqs.size();</span><br><span class="line">         <span class="keyword">return</span> mqs.get(value);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h2><p>消费者的目标就是保证<strong>同一时刻，一个消费队列只能被一个消费者中的一个线程消费</strong>。</p>
<p>我们在使用方式中看到他有自己的<strong>顺序消费监听器</strong><code>MessageListenerOrderly</code>，如果忘了<strong>消息者是如何消费消息的</strong>，也可以回头看看我之前的文章，这里也直入主题。</p>
<h3 id="获取队列"><a href="#获取队列" class="headerlink" title="获取队列"></a>获取队列</h3><p>Consumer启动后会初始化一个<code>RebalanceImpl</code>做rebalance操作，从而得到当前这个consumer负责处理哪些queue的消息。</p>
<p>对于顺序消息的消费者，还要求在获取队列的时候去给消息队列加锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.impl.consumer.RebalanceImpl#updateProcessQueueTableInRebalance</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateProcessQueueTableInRebalance</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> Set&lt;MessageQueue&gt; mqSet,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">        List&lt;PullRequest&gt; pullRequestList = <span class="keyword">new</span> ArrayList&lt;PullRequest&gt;();</span><br><span class="line">        <span class="keyword">for</span> (MessageQueue mq : mqSet) &#123;</span><br><span class="line">            <span class="comment">// 如果是新加入的Queue</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.processQueueTable.containsKey(mq)) &#123;</span><br><span class="line">                <span class="comment">// 如果是顺序消费者，则去给消息队列加锁   **关键**</span></span><br><span class="line">                <span class="keyword">if</span> (isOrder &amp;&amp; !<span class="keyword">this</span>.lock(mq)) &#123;</span><br><span class="line">                    log.warn(<span class="string">"doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed"</span>, consumerGroup, mq);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从offset store中移除过时的数据</span></span><br><span class="line">                <span class="keyword">this</span>.removeDirtyOffset(mq);</span><br><span class="line">                ProcessQueue pq = <span class="keyword">new</span> ProcessQueue();</span><br><span class="line">                <span class="comment">// 获取起始消费offset</span></span><br><span class="line">                <span class="keyword">long</span> nextOffset = <span class="keyword">this</span>.computePullFromWhere(mq);</span><br><span class="line">                <span class="keyword">if</span> (nextOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 为新的Queue初始化一个ProcessQueue，用来缓存收到的消息</span></span><br><span class="line">                    ProcessQueue pre = <span class="keyword">this</span>.processQueueTable.putIfAbsent(mq, pq);</span><br><span class="line">                    <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        log.info(<span class="string">"doRebalance, &#123;&#125;, mq already exists, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.info(<span class="string">"doRebalance, &#123;&#125;, add a new mq, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                        <span class="comment">// 对新加的queue初始化一个PullRequest</span></span><br><span class="line">                        PullRequest pullRequest = <span class="keyword">new</span> PullRequest();</span><br><span class="line">                        pullRequest.setConsumerGroup(consumerGroup);</span><br><span class="line">                        pullRequest.setNextOffset(nextOffset);</span><br><span class="line">                        pullRequest.setMessageQueue(mq);</span><br><span class="line">                        pullRequest.setProcessQueue(pq);</span><br><span class="line">                        pullRequestList.add(pullRequest);</span><br><span class="line">                        changed = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.warn(<span class="string">"doRebalance, &#123;&#125;, add new mq failed, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分发pull request到PullMessageService拉取消息</span></span><br><span class="line">        <span class="keyword">this</span>.dispatchPullRequest(pullRequestList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//org.apache.rocketmq.client.impl.consumer.RebalanceImpl#lock</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span> </span>&#123;</span><br><span class="line">        FindBrokerResult findBrokerResult = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (findBrokerResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">            LockBatchRequestBody requestBody = <span class="keyword">new</span> LockBatchRequestBody();</span><br><span class="line">            requestBody.setConsumerGroup(<span class="keyword">this</span>.consumerGroup);</span><br><span class="line">            requestBody.setClientId(<span class="keyword">this</span>.mQClientFactory.getClientId());</span><br><span class="line">            requestBody.getMqSet().add(mq);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 请求Broker获得指定消息队列的分布式锁</span></span><br><span class="line">                Set&lt;MessageQueue&gt; lockedMq =</span><br><span class="line">                    <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, <span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 设置消息处理队列锁定成功</span></span><br><span class="line">                <span class="keyword">for</span> (MessageQueue mmqq : lockedMq) &#123;</span><br><span class="line">                    ProcessQueue processQueue = <span class="keyword">this</span>.processQueueTable.get(mmqq);</span><br><span class="line">                    <span class="keyword">if</span> (processQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        processQueue.setLocked(<span class="keyword">true</span>);</span><br><span class="line">                        processQueue.setLastLockTimestamp(System.currentTimeMillis());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> lockOK = lockedMq.contains(mq);</span><br><span class="line">                log.info(<span class="string">"the message queue lock &#123;&#125;, &#123;&#125; &#123;&#125;"</span>,</span><br><span class="line">                    lockOK ? <span class="string">"OK"</span> : <span class="string">"Failed"</span>,</span><br><span class="line">                    <span class="keyword">this</span>.consumerGroup,</span><br><span class="line">                    mq);</span><br><span class="line">                <span class="keyword">return</span> lockOK;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"lockBatchMQ exception, "</span> + mq, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们在之前分析<code>Consumer</code>的时候，我们说过在启动<code>DefaultMQPushConsumer</code>时会启动一个<code>ConsumeMessageService</code>，对应顺序消息它会启动对应的<code>ConsumeMessageOrderlyService</code>，看看它启动干了什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在集群模式下</span></span><br><span class="line">    <span class="keyword">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel())) &#123;</span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 定时给MQ加锁</span></span><br><span class="line">                ConsumeMessageOrderlyService.<span class="keyword">this</span>.lockMQPeriodically();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">1</span>, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockMQPeriodically</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.stopped) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumerImpl.getRebalanceImpl().lockAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h3><p><code>RebalanceImpl</code>在从Broker获取到消息后，会调用<code>ConsumeMessageOrderlyService</code>的<code>submitConsumeRequest()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitConsumeRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ProcessQueue processQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> MessageQueue messageQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">boolean</span> dispathToConsume)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dispathToConsume) &#123;</span><br><span class="line">        ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(processQueue, messageQueue);</span><br><span class="line">        <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ComsumeRequest</code>其实就是一个，我们就是把它丢进线程池进行处理，我们具体看看这个任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumeRequest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ProcessQueue processQueue;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> MessageQueue messageQueue;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConsumeRequest</span><span class="params">(ProcessQueue processQueue, MessageQueue messageQueue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.processQueue = processQueue;</span><br><span class="line">            <span class="keyword">this</span>.messageQueue = messageQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ProcessQueue <span class="title">getProcessQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> processQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">getMessageQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> messageQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                log.warn(<span class="string">"run, the message queue not be able to consume, because it's dropped. &#123;&#125;"</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取消息MessageQueue锁对象，加互斥锁，保证同一个MessageQueue同时只会有一个线程在处理消息</span></span><br><span class="line">            <span class="comment">// 就是将本地的MessageQueue对象与远程的分布式关联起来</span></span><br><span class="line">            <span class="keyword">final</span> Object objLock = messageQueueLock.fetchLockObject(<span class="keyword">this</span>.messageQueue);</span><br><span class="line">            <span class="keyword">synchronized</span> (objLock) &#123;</span><br><span class="line">                <span class="comment">// Cluster模式下同时判断processQueue也是被锁定的</span></span><br><span class="line">                <span class="keyword">if</span> (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel())</span><br><span class="line">                    || (<span class="keyword">this</span>.processQueue.isLocked() &amp;&amp; !<span class="keyword">this</span>.processQueue.isLockExpired())) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">boolean</span> continueConsume = <span class="keyword">true</span>; continueConsume; ) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                            log.warn(<span class="string">"the message queue not be able to consume, because it's dropped. &#123;&#125;"</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果没有获得锁，放入定时任务中待会重新加锁消费</span></span><br><span class="line">                        <span class="keyword">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel())</span><br><span class="line">                            &amp;&amp; !<span class="keyword">this</span>.processQueue.isLocked()) &#123;</span><br><span class="line">                            log.warn(<span class="string">"the message queue not locked, so consume later, &#123;&#125;"</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                            ConsumeMessageOrderlyService.<span class="keyword">this</span>.tryLockLaterAndReconsume(<span class="keyword">this</span>.messageQueue, <span class="keyword">this</span>.processQueue, <span class="number">10</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果锁过期，放入定时任务中待会重新加锁消费</span></span><br><span class="line">                        <span class="keyword">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel())</span><br><span class="line">                            &amp;&amp; <span class="keyword">this</span>.processQueue.isLockExpired()) &#123;</span><br><span class="line">                            log.warn(<span class="string">"the message queue lock expired, so consume later, &#123;&#125;"</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                            ConsumeMessageOrderlyService.<span class="keyword">this</span>.tryLockLaterAndReconsume(<span class="keyword">this</span>.messageQueue, <span class="keyword">this</span>.processQueue, <span class="number">10</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 当前周期消费时间超过连续时长</span></span><br><span class="line">                        <span class="comment">// 默认：60s，提交延迟消费请求。默认情况下，每消费1分钟休息10ms</span></span><br><span class="line">                        <span class="keyword">long</span> interval = System.currentTimeMillis() - beginTime;</span><br><span class="line">                        <span class="keyword">if</span> (interval &gt; MAX_TIME_CONSUME_CONTINUOUSLY) &#123;</span><br><span class="line">                            ConsumeMessageOrderlyService.<span class="keyword">this</span>.submitConsumeRequestLater(processQueue, messageQueue, <span class="number">10</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 从ProcessQueue获取一批消息</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> consumeBatchSize =</span><br><span class="line">                            ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line"></span><br><span class="line">                        List&lt;MessageExt&gt; msgs = <span class="keyword">this</span>.processQueue.takeMessags(consumeBatchSize);</span><br><span class="line">                        <span class="keyword">if</span> (!msgs.isEmpty()) &#123;</span><br><span class="line">                            <span class="keyword">final</span> ConsumeOrderlyContext context = <span class="keyword">new</span> ConsumeOrderlyContext(<span class="keyword">this</span>.messageQueue);</span><br><span class="line"></span><br><span class="line">                            ConsumeOrderlyStatus status = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                            ConsumeMessageContext consumeMessageContext = <span class="keyword">null</span>;</span><br><span class="line">                           	<span class="comment">// ...</span></span><br><span class="line">                            ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">                            <span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 获得消费锁，粒度更小，防止在消费时，有其他线程介入</span></span><br><span class="line">                                <span class="keyword">this</span>.processQueue.getLockConsume().lock();</span><br><span class="line">                                <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                                    log.warn(<span class="string">"consumeMessage, the message queue not be able to consume, because it's dropped. &#123;&#125;"</span>,</span><br><span class="line">                                        <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 调用用户自定义Listener处理消息</span></span><br><span class="line">                                status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                                log.warn(<span class="string">"consumeMessage exception: &#123;&#125; Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;"</span>,</span><br><span class="line">                                    RemotingHelper.exceptionSimpleDesc(e),</span><br><span class="line">                                    ConsumeMessageOrderlyService.<span class="keyword">this</span>.consumerGroup,</span><br><span class="line">                                    msgs,</span><br><span class="line">                                    messageQueue);</span><br><span class="line">                                hasException = <span class="keyword">true</span>;</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                <span class="comment">// 消费锁解锁</span></span><br><span class="line">                                <span class="keyword">this</span>.processQueue.getLockConsume().unlock();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">														<span class="comment">// ...</span></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            ConsumeMessageOrderlyService.<span class="keyword">this</span>.getConsumerStatsManager()</span><br><span class="line">                                .incConsumeRT(ConsumeMessageOrderlyService.<span class="keyword">this</span>.consumerGroup, messageQueue.getTopic(), consumeRT);</span><br><span class="line">                            <span class="comment">// 处理消费结果</span></span><br><span class="line">                            continueConsume = ConsumeMessageOrderlyService.<span class="keyword">this</span>.processConsumeResult(msgs, status, context, <span class="keyword">this</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            continueConsume = <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                        log.warn(<span class="string">"the message queue not be able to consume, because it's dropped. &#123;&#125;"</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ConsumeMessageOrderlyService.<span class="keyword">this</span>.tryLockLaterAndReconsume(<span class="keyword">this</span>.messageQueue, <span class="keyword">this</span>.processQueue, <span class="number">100</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理消费结果"><a href="#处理消费结果" class="headerlink" title="处理消费结果"></a>处理消费结果</h3><p>跟着上面走，<code>ConsumeMessageOrderlyService</code>是如何处理消费结果的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processConsumeResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ConsumeOrderlyStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ConsumeOrderlyContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ConsumeRequest consumeRequest</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> continueConsume = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">long</span> commitOffset = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">if</span> (context.isAutoCommit()) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        		<span class="comment">// ROLLBACK 、COMMIT 暂时只使用在 MySQL binlog 场景，官方将这两状态标记为 @Deprecated</span></span><br><span class="line">            <span class="keyword">case</span> COMMIT:</span><br><span class="line">            <span class="keyword">case</span> ROLLBACK:</span><br><span class="line">                log.warn(<span class="string">"the message queue consume result is illegal, we think you want to ack these message &#123;&#125;"</span>,</span><br><span class="line">                    consumeRequest.getMessageQueue());</span><br><span class="line">            <span class="keyword">case</span> SUCCESS:</span><br><span class="line">                <span class="comment">// 如果成功，则调用ProcessQueue的commit方法</span></span><br><span class="line">                commitOffset = consumeRequest.getProcessQueue().commit();</span><br><span class="line">                <span class="keyword">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUSPEND_CURRENT_QUEUE_A_MOMENT:</span><br><span class="line">                <span class="comment">// 检查重试次数，如果没超过则放到ProcessQueue中；如果超过则直接发到broker的Dead Queue中</span></span><br><span class="line">                <span class="comment">// ProcessQueue维护了一个msgTreeMap，保证了顺序</span></span><br><span class="line">                <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</span><br><span class="line">                <span class="keyword">if</span> (checkReconsumeTimes(msgs)) &#123;</span><br><span class="line">                    consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);</span><br><span class="line">                    <span class="keyword">this</span>.submitConsumeRequestLater(</span><br><span class="line">                        consumeRequest.getProcessQueue(),</span><br><span class="line">                        consumeRequest.getMessageQueue(),</span><br><span class="line">                        context.getSuspendCurrentQueueTimeMillis());</span><br><span class="line">                    continueConsume = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    commitOffset = consumeRequest.getProcessQueue().commit();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (commitOffset &gt;= <span class="number">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> continueConsume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里就结束啦~</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="https://help.aliyun.com/document_detail/49319.html" target="_blank" rel="noopener">顺序消息</a></p>
</li>
<li><p><a href="https://blog.csdn.net/hosaos/article/details/90675978" target="_blank" rel="noopener">RocketMQ-顺序消息Demo及实现原理分析</a></p>
</li>
<li><p><a href="http://www.iocoder.cn/RocketMQ/message-send-and-consume-orderly/" target="_blank" rel="noopener">RocketMQ 源码分析 —— Message 顺序发送与消费</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：在前面的源码分析中，我们总是能在很多地方看到对于顺序消息特别的逻辑，这次我们终于可以讲一下啦！
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>数据库调优</title>
    <link href="http://bestlixiang.site/2019/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98/"/>
    <id>http://bestlixiang.site/2019/06/29/数据库/数据库调优/</id>
    <published>2019-06-29T15:18:04.000Z</published>
    <updated>2019-06-29T15:19:51.204Z</updated>
    
    <content type="html"><![CDATA[<p>引：我恨自己当有问题出现时，没有立刻去把握它！今天看了很多关于Mysql索引优化器的东西，但是没有拿到结果！留下一些链接，希望下次出现索引优化的问题或者慢查询的问题，自己能好好分析一波！<a id="more"></a></p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ol>
<li><a href="https://dev.mysql.com/doc/internals/en/optimizer-tracing-typical-usage.html" target="_blank" rel="noopener">mysql手册</a></li>
<li><a href="[https://iluoy.com/articles/203#TRACE%E5%88%86%E6%9E%908](https://iluoy.com/articles/203#TRACE分析8">mysql之通过trace分析优化器如何选择执行计划</a>)</li>
<li><a href="https://www.kancloud.cn/taobaomysql/monthly/81380" target="_blank" rel="noopener">MySQL · 答疑解惑 · MySQL 优化器 range 的代价计算</a></li>
<li><a href="https://blog.csdn.net/angry_mills/article/details/87720396" target="_blank" rel="noopener">[官方] mysql 性能优化文档（中英文自译）</a></li>
<li><a href="https://blog.csdn.net/why15732625998/article/details/80388236" target="_blank" rel="noopener"> EXPLAIN用法和结果分析</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：我恨自己当有问题出现时，没有立刻去把握它！今天看了很多关于Mysql索引优化器的东西，但是没有拿到结果！留下一些链接，希望下次出现索引优化的问题或者慢查询的问题，自己能好好分析一波！
    
    </summary>
    
      <category term="数据库" scheme="http://bestlixiang.site/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://bestlixiang.site/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——Broker接收拉消息</title>
    <link href="http://bestlixiang.site/2019/06/29/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Broke%E6%8E%A5%E6%94%B6%E6%8B%89%E6%B6%88%E6%81%AF/"/>
    <id>http://bestlixiang.site/2019/06/29/RocketMQ源码/RocketMQ源码分析——Broke接收拉消息/</id>
    <published>2019-06-28T23:44:23.000Z</published>
    <updated>2019-07-01T00:12:04.392Z</updated>
    
    <content type="html"><![CDATA[<p>引：前面讲到了Broker对于不同的消息有自己不同的Processor，对于<code>PushConsumer</code>的Pull请求的时候，它对应的就是<code>PullMessageProcessor</code>~<a id="more"></a></p>
<h1 id="PullMessageProcessor"><a href="#PullMessageProcessor" class="headerlink" title="PullMessageProcessor"></a>PullMessageProcessor</h1><p>通过前面的分析，我们自然而然地就会想到去看<code>org.apache.rocketmq.broker.processor.PullMessageProcessor#processRequest()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">processRequest</span><span class="params">(<span class="keyword">final</span> Channel channel, RemotingCommand request, <span class="keyword">boolean</span> brokerAllowSuspend)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">        RemotingCommand response = RemotingCommand.createResponseCommand(PullMessageResponseHeader.class);</span><br><span class="line">        <span class="keyword">final</span> PullMessageResponseHeader responseHeader = (PullMessageResponseHeader) response.readCustomHeader();</span><br><span class="line">        <span class="keyword">final</span> PullMessageRequestHeader requestHeader =</span><br><span class="line">            (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);</span><br><span class="line"></span><br><span class="line">        response.setOpaque(request.getOpaque());</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"receive PullMessage request command, &#123;&#125;"</span>, request);</span><br><span class="line">        <span class="comment">// 判断Broker当前是否可读</span></span><br><span class="line">        <span class="keyword">if</span> (!PermName.isReadable(<span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerPermission())) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(String.format(<span class="string">"the broker[%s] pulling message is forbidden"</span>, <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1()));</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断consumerGroup是否存在</span></span><br><span class="line">        SubscriptionGroupConfig subscriptionGroupConfig =</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionGroupConfig) &#123;</span><br><span class="line">            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</span><br><span class="line">            response.setRemark(String.format(<span class="string">"subscription group [%s] does not exist, %s"</span>, requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断consumerGroup的消费状态是否Enable</span></span><br><span class="line">        <span class="keyword">if</span> (!subscriptionGroupConfig.isConsumeEnable()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(<span class="string">"subscription group no permission, "</span> + requestHeader.getConsumerGroup());</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> hasSuspendFlag = PullSysFlag.hasSuspendFlag(requestHeader.getSysFlag());</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> hasCommitOffsetFlag = PullSysFlag.hasCommitOffsetFlag(requestHeader.getSysFlag());</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> hasSubscriptionFlag = PullSysFlag.hasSubscriptionFlag(requestHeader.getSysFlag());</span><br><span class="line">				<span class="comment">// 获得挂起时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> suspendTimeoutMillisLong = hasSuspendFlag ? requestHeader.getSuspendTimeoutMillis() : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 判断请求的topic是否存在，并且可读，请求的queueId是否合法</span></span><br><span class="line">        TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">            log.error(<span class="string">"the topic &#123;&#125; not exist, consumer: &#123;&#125;"</span>, requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(channel));</span><br><span class="line">            response.setCode(ResponseCode.TOPIC_NOT_EXIST);</span><br><span class="line">            response.setRemark(String.format(<span class="string">"topic[%s] not exist, apply first please! %s"</span>, requestHeader.getTopic(), FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!PermName.isReadable(topicConfig.getPerm())) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(<span class="string">"the topic["</span> + requestHeader.getTopic() + <span class="string">"] pulling message is forbidden"</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (requestHeader.getQueueId() &lt; <span class="number">0</span> || requestHeader.getQueueId() &gt;= topicConfig.getReadQueueNums()) &#123;</span><br><span class="line">            String errorInfo = String.format(<span class="string">"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] consumer:[%s]"</span>,</span><br><span class="line">                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(), channel.remoteAddress());</span><br><span class="line">            log.warn(errorInfo);</span><br><span class="line">            response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">            response.setRemark(errorInfo);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SubscriptionData subscriptionData = <span class="keyword">null</span>;</span><br><span class="line">        ConsumerFilterData consumerFilterData = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 有设置subscribe flag,表示第一次pull或者需要更新filter</span></span><br><span class="line">        <span class="keyword">if</span> (hasSubscriptionFlag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              	<span class="comment">// 获得订阅信息，用于过滤消息</span></span><br><span class="line">                subscriptionData = FilterAPI.build(</span><br><span class="line">                    requestHeader.getTopic(), requestHeader.getSubscription(), requestHeader.getExpressionType()</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 是否使用了表达式过滤</span></span><br><span class="line">                <span class="keyword">if</span> (!ExpressionType.isTagType(subscriptionData.getExpressionType())) &#123;</span><br><span class="line">                    consumerFilterData = ConsumerFilterManager.build(</span><br><span class="line">                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getSubscription(),</span><br><span class="line">                        requestHeader.getExpressionType(), requestHeader.getSubVersion()</span><br><span class="line">                    );</span><br><span class="line">                    <span class="keyword">assert</span> consumerFilterData != <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.warn(<span class="string">"Parse the consumer's subscription[&#123;&#125;] failed, group: &#123;&#125;"</span>, requestHeader.getSubscription(),</span><br><span class="line">                    requestHeader.getConsumerGroup());</span><br><span class="line">                response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);</span><br><span class="line">                response.setRemark(<span class="string">"parse the consumer's subscription failed"</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有设置subscribe flag，表示之前已经订阅过了,对比订阅条件是否一致</span></span><br><span class="line">            <span class="comment">// 对于同一个ConsumerGroup下的多个consumer客户端，Broker要求订阅参数设置必须要是一致的，要不然会造成数据混乱</span></span><br><span class="line">            ConsumerGroupInfo consumerGroupInfo =</span><br><span class="line">                <span class="keyword">this</span>.brokerController.getConsumerManager().getConsumerGroupInfo(requestHeader.getConsumerGroup());</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == consumerGroupInfo) &#123;</span><br><span class="line">                log.warn(<span class="string">"the consumer's group info not exist, group: &#123;&#125;"</span>, requestHeader.getConsumerGroup());</span><br><span class="line">                response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);</span><br><span class="line">                response.setRemark(<span class="string">"the consumer's group info not exist"</span> + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!subscriptionGroupConfig.isConsumeBroadcastEnable()</span><br><span class="line">                &amp;&amp; consumerGroupInfo.getMessageModel() == MessageModel.BROADCASTING) &#123;</span><br><span class="line">                response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">                response.setRemark(<span class="string">"the consumer group["</span> + requestHeader.getConsumerGroup() + <span class="string">"] can not consume by broadcast way"</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            subscriptionData = consumerGroupInfo.findSubscriptionData(requestHeader.getTopic());</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionData) &#123;</span><br><span class="line">                log.warn(<span class="string">"the consumer's subscription not exist, group: &#123;&#125;, topic:&#123;&#125;"</span>, requestHeader.getConsumerGroup(), requestHeader.getTopic());</span><br><span class="line">                response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);</span><br><span class="line">                response.setRemark(<span class="string">"the consumer's subscription not exist"</span> + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (subscriptionData.getSubVersion() &lt; requestHeader.getSubVersion()) &#123;</span><br><span class="line">                log.warn(<span class="string">"The broker's subscription is not latest, group: &#123;&#125; &#123;&#125;"</span>, requestHeader.getConsumerGroup(),</span><br><span class="line">                    subscriptionData.getSubString());</span><br><span class="line">                response.setCode(ResponseCode.SUBSCRIPTION_NOT_LATEST);</span><br><span class="line">                response.setRemark(<span class="string">"the consumer's subscription not latest"</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ExpressionType.isTagType(subscriptionData.getExpressionType())) &#123;</span><br><span class="line">                consumerFilterData = <span class="keyword">this</span>.brokerController.getConsumerFilterManager().get(requestHeader.getTopic(),</span><br><span class="line">                    requestHeader.getConsumerGroup());</span><br><span class="line">                <span class="keyword">if</span> (consumerFilterData == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    response.setCode(ResponseCode.FILTER_DATA_NOT_EXIST);</span><br><span class="line">                    response.setRemark(<span class="string">"The broker's consumer filter data is not exist!Your expression may be wrong!"</span>);</span><br><span class="line">                    <span class="keyword">return</span> response;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (consumerFilterData.getClientVersion() &lt; requestHeader.getSubVersion()) &#123;</span><br><span class="line">                    log.warn(<span class="string">"The broker's consumer filter data is not latest, group: &#123;&#125;, topic: &#123;&#125;, serverV: &#123;&#125;, clientV: &#123;&#125;"</span>,</span><br><span class="line">                        requestHeader.getConsumerGroup(), requestHeader.getTopic(), consumerFilterData.getClientVersion(), requestHeader.getSubVersion());</span><br><span class="line">                    response.setCode(ResponseCode.FILTER_DATA_NOT_LATEST);</span><br><span class="line">                    response.setRemark(<span class="string">"the consumer's consumer filter data not latest"</span>);</span><br><span class="line">                    <span class="keyword">return</span> response;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ExpressionType.isTagType(subscriptionData.getExpressionType())</span><br><span class="line">            &amp;&amp; !<span class="keyword">this</span>.brokerController.getBrokerConfig().isEnablePropertyFilter()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">            response.setRemark(<span class="string">"The broker does not support consumer to filter message by "</span> + subscriptionData.getExpressionType());</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据订阅信息和过滤信息创建消息过滤器</span></span><br><span class="line">        MessageFilter messageFilter;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isFilterSupportRetry()) &#123;</span><br><span class="line">            messageFilter = <span class="keyword">new</span> ExpressionForRetryMessageFilter(subscriptionData, consumerFilterData,</span><br><span class="line">                <span class="keyword">this</span>.brokerController.getConsumerFilterManager());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            messageFilter = <span class="keyword">new</span> ExpressionMessageFilter(subscriptionData, consumerFilterData,</span><br><span class="line">                <span class="keyword">this</span>.brokerController.getConsumerFilterManager());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过messageStore读取消息（带上topic和queueId和offset和过滤器）</span></span><br><span class="line">        <span class="keyword">final</span> GetMessageResult getMessageResult =</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</span><br><span class="line">                requestHeader.getQueueId(), requestHeader.getQueueOffset(), requestHeader.getMaxMsgNums(), messageFilter);</span><br><span class="line">        <span class="keyword">if</span> (getMessageResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">            response.setRemark(getMessageResult.getStatus().name());</span><br><span class="line">            responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());</span><br><span class="line">            responseHeader.setMinOffset(getMessageResult.getMinOffset());</span><br><span class="line">            responseHeader.setMaxOffset(getMessageResult.getMaxOffset());</span><br><span class="line">            <span class="comment">// master读取比较慢的话，默认设置推荐从slave读取</span></span><br><span class="line">            <span class="keyword">if</span> (getMessageResult.isSuggestPullingFromSlave()) &#123;</span><br><span class="line">                responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">                <span class="keyword">case</span> ASYNC_MASTER:</span><br><span class="line">                <span class="keyword">case</span> SYNC_MASTER:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> SLAVE:</span><br><span class="line">                    <span class="comment">// 如果当前broker是slave，并且不支持read，则提示客户端从master读</span></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;</span><br><span class="line">                        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">                        responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果slave可读，覆盖之前的设置</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;</span><br><span class="line">                <span class="comment">// consume too slow ,redirect to another machine</span></span><br><span class="line">                <span class="keyword">if</span> (getMessageResult.isSuggestPullingFromSlave()) &#123;</span><br><span class="line">                    responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// consume ok</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将MessageStore读取的返回状态映射成repsonse的状态</span></span><br><span class="line">            <span class="keyword">switch</span> (getMessageResult.getStatus()) &#123;</span><br><span class="line">                <span class="keyword">case</span> FOUND:</span><br><span class="line">                    response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_WAS_REMOVING:</span><br><span class="line">                    response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> NO_MATCHED_LOGIC_QUEUE:</span><br><span class="line">                <span class="keyword">case</span> NO_MESSAGE_IN_QUEUE:</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> != requestHeader.getQueueOffset()) &#123;</span><br><span class="line">                        response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                        log.info(<span class="string">"the broker store no queue data, fix the request offset &#123;&#125; to &#123;&#125;, Topic: &#123;&#125; QueueId: &#123;&#125; Consumer Group: &#123;&#125;"</span>,</span><br><span class="line">                            requestHeader.getQueueOffset(),</span><br><span class="line">                            getMessageResult.getNextBeginOffset(),</span><br><span class="line">                            requestHeader.getTopic(),</span><br><span class="line">                            requestHeader.getQueueId(),</span><br><span class="line">                            requestHeader.getConsumerGroup()</span><br><span class="line">                        );</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> NO_MATCHED_MESSAGE:</span><br><span class="line">                    response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> OFFSET_FOUND_NULL:</span><br><span class="line">                    response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> OFFSET_OVERFLOW_BADLY:</span><br><span class="line">                    response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">                    <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                    log.info(<span class="string">"the request offset: &#123;&#125; over flow badly, broker max offset: &#123;&#125;, consumer: &#123;&#125;"</span>,</span><br><span class="line">                        requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> OFFSET_OVERFLOW_ONE:</span><br><span class="line">                    response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> OFFSET_TOO_SMALL:</span><br><span class="line">                    response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">                    log.info(<span class="string">"the request offset too small. group=&#123;&#125;, topic=&#123;&#125;, requestOffset=&#123;&#125;, brokerMinOffset=&#123;&#125;, clientIp=&#123;&#125;"</span>,</span><br><span class="line">                        requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueOffset(),</span><br><span class="line">                        getMessageResult.getMinOffset(), channel.remoteAddress());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果有回调函数</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 处理返回结果</span></span><br><span class="line">            <span class="keyword">switch</span> (response.getCode()) &#123;</span><br><span class="line">                <span class="keyword">case</span> ResponseCode.SUCCESS:</span><br><span class="line">                    <span class="comment">// 成功后更新统计信息</span></span><br><span class="line">                    <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incGroupGetNums(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</span><br><span class="line">                        getMessageResult.getMessageCount());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incGroupGetSize(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</span><br><span class="line">                        getMessageResult.getBufferTotalSize());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incBrokerGetNums(getMessageResult.getMessageCount());</span><br><span class="line">                    <span class="comment">// 如果是通过堆，则从文件中读取消息set到response body返回</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isTransferMsgByHeap()) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = <span class="keyword">this</span>.brokerController.getMessageStore().now();</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">byte</span>[] r = <span class="keyword">this</span>.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());</span><br><span class="line">                        <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),</span><br><span class="line">                            requestHeader.getTopic(), requestHeader.getQueueId(),</span><br><span class="line">                            (<span class="keyword">int</span>) (<span class="keyword">this</span>.brokerController.getMessageStore().now() - beginTimeMills));</span><br><span class="line">                        response.setBody(r);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 否则，利用netty直接读取内存映射文件，少一次copy</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            FileRegion fileRegion =</span><br><span class="line">                                <span class="keyword">new</span> ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult);</span><br><span class="line">                            channel.writeAndFlush(fileRegion).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    getMessageResult.release();</span><br><span class="line">                                    <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                                        log.error(<span class="string">"transfer many message by pagecache failed, &#123;&#125;"</span>, channel.remoteAddress(), future.cause());</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                            log.error(<span class="string">"transfer many message by pagecache exception"</span>, e);</span><br><span class="line">                            getMessageResult.release();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        response = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 没有读取到消息，则hold住请求，有新消息时唤醒</span></span><br><span class="line">                <span class="comment">// 等待超时后还是没读到brokerAllowSuspend=false</span></span><br><span class="line">                <span class="keyword">case</span> ResponseCode.PULL_NOT_FOUND:</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;</span><br><span class="line">                      	<span class="comment">// 默认长轮询时间为设置的挂起超时时间</span></span><br><span class="line">                        <span class="keyword">long</span> pollingTimeMills = suspendTimeoutMillisLong;</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">                          	<span class="comment">// 没有开启长轮询，则轮询时间为1s</span></span><br><span class="line">                            pollingTimeMills = <span class="keyword">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        String topic = requestHeader.getTopic();</span><br><span class="line">                        <span class="keyword">long</span> offset = requestHeader.getQueueOffset();</span><br><span class="line">                        <span class="keyword">int</span> queueId = requestHeader.getQueueId();</span><br><span class="line">                        PullRequest pullRequest = <span class="keyword">new</span> PullRequest(request, channel, pollingTimeMills,</span><br><span class="line">                            <span class="keyword">this</span>.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);</span><br><span class="line">                        <span class="comment">// 利用PullRequestHoldService hold住PullRequest</span></span><br><span class="line">                        <span class="keyword">this</span>.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</span><br><span class="line">                        response = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> ResponseCode.PULL_RETRY_IMMEDIATELY:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 消费开始的offset不正确</span></span><br><span class="line">                <span class="keyword">case</span> ResponseCode.PULL_OFFSET_MOVED:</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE</span><br><span class="line">                        || <span class="keyword">this</span>.brokerController.getMessageStoreConfig().isOffsetCheckInSlave()) &#123;</span><br><span class="line">                        MessageQueue mq = <span class="keyword">new</span> MessageQueue();</span><br><span class="line">                        mq.setTopic(requestHeader.getTopic());</span><br><span class="line">                        mq.setQueueId(requestHeader.getQueueId());</span><br><span class="line">                        mq.setBrokerName(<span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerName());</span><br><span class="line"></span><br><span class="line">                        OffsetMovedEvent event = <span class="keyword">new</span> OffsetMovedEvent();</span><br><span class="line">                        event.setConsumerGroup(requestHeader.getConsumerGroup());</span><br><span class="line">                        event.setMessageQueue(mq);</span><br><span class="line">                        event.setOffsetRequest(requestHeader.getQueueOffset());</span><br><span class="line">                        event.setOffsetNew(getMessageResult.getNextBeginOffset());</span><br><span class="line">                        <span class="keyword">this</span>.generateOffsetMovedEvent(event);</span><br><span class="line">                        log.warn(</span><br><span class="line">                            <span class="string">"PULL_OFFSET_MOVED:correction offset. topic=&#123;&#125;, groupId=&#123;&#125;, requestOffset=&#123;&#125;, newOffset=&#123;&#125;, suggestBrokerId=&#123;&#125;"</span>,</span><br><span class="line">                            requestHeader.getTopic(), requestHeader.getConsumerGroup(), event.getOffsetRequest(), event.getOffsetNew(),</span><br><span class="line">                            responseHeader.getSuggestWhichBrokerId());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());</span><br><span class="line">                        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">                        log.warn(<span class="string">"PULL_OFFSET_MOVED:none correction. topic=&#123;&#125;, groupId=&#123;&#125;, requestOffset=&#123;&#125;, suggestBrokerId=&#123;&#125;"</span>,</span><br><span class="line">                            requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getQueueOffset(),</span><br><span class="line">                            responseHeader.getSuggestWhichBrokerId());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">            response.setRemark(<span class="string">"store getMessage return null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> storeOffsetEnable = brokerAllowSuspend;</span><br><span class="line">        storeOffsetEnable = storeOffsetEnable &amp;&amp; hasCommitOffsetFlag;</span><br><span class="line">        storeOffsetEnable = storeOffsetEnable</span><br><span class="line">            &amp;&amp; <span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;</span><br><span class="line">        <span class="keyword">if</span> (storeOffsetEnable) &#123;</span><br><span class="line">            <span class="comment">// 记录消息读取位置</span></span><br><span class="line">            <span class="keyword">this</span>.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),</span><br><span class="line">                requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看出：我们会根据topic和queueId和offset和过滤器从<code>MessageStore</code>中读取消息，<strong>如果成功</strong>，我们可以从指向内存文件的<code>ByteBuffer</code>得到数据，根据配置有两种返回数据的方式，第一种是从<code>ByteBuffer</code>中将数据读取到response中（经过堆），然后返回。第二种是让netty直接读取<code>ByteBuffer</code>，将消息写给客户端，相对前一种，不需要将<code>ByteBuffer</code>中的数据copy到java Heap中，少一次内存copy。<strong>但是第二种方式无法记录监控信息，比如consumer消费延时（从代码看出）等指标</strong>；<strong>如果没有读取到消息</strong>，会判断是否是<code>PushConsumer</code>（参数<code>hasSuspendFlag</code>）以及是否允许挂起（参数<code>brokerAllowSuspend</code>），如果是的话，则将请求挂起，方式就是封装成<code>PullRequest</code>提交给<code>PullRequestHoldService</code>。</p>
<p>#MessageStore#getMessage</p>
<p>我们看看这个方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> GetMessageResult <span class="title">getMessage</span><span class="params">(<span class="keyword">final</span> String group, <span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">int</span> maxMsgNums,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> MessageFilter messageFilter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.shutdown) &#123;</span><br><span class="line">        log.warn(<span class="string">"message store has shutdown, so getMessage is forbidden"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.runningFlags.isReadable()) &#123;</span><br><span class="line">        log.warn(<span class="string">"message store is not readable, so getMessage is forbidden "</span> + <span class="keyword">this</span>.runningFlags.getFlagBits());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> beginTime = <span class="keyword">this</span>.getSystemClock().now();</span><br><span class="line">    <span class="comment">// 默认没有消息在队列</span></span><br><span class="line">    GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</span><br><span class="line">    <span class="keyword">long</span> nextBeginOffset = offset;</span><br><span class="line">    <span class="keyword">long</span> minOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> maxOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    GetMessageResult getResult = <span class="keyword">new</span> GetMessageResult();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> maxOffsetPy = <span class="keyword">this</span>.commitLog.getMaxOffset();</span><br><span class="line">    <span class="comment">// 找到对应的ConsumeQueue</span></span><br><span class="line">    ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);</span><br><span class="line">    <span class="keyword">if</span> (consumeQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        minOffset = consumeQueue.getMinOffsetInQueue();</span><br><span class="line">        maxOffset = consumeQueue.getMaxOffsetInQueue();</span><br><span class="line">        <span class="comment">// 一些offset不合法的情况</span></span><br><span class="line">        <span class="keyword">if</span> (maxOffset == <span class="number">0</span>) &#123;</span><br><span class="line">            status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</span><br><span class="line">            nextBeginOffset = nextOffsetCorrection(offset, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &lt; minOffset) &#123;</span><br><span class="line">            status = GetMessageStatus.OFFSET_TOO_SMALL;</span><br><span class="line">            nextBeginOffset = nextOffsetCorrection(offset, minOffset);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset == maxOffset) &#123;</span><br><span class="line">            status = GetMessageStatus.OFFSET_OVERFLOW_ONE;</span><br><span class="line">            nextBeginOffset = nextOffsetCorrection(offset, offset);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &gt; maxOffset) &#123;</span><br><span class="line">            status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == minOffset) &#123;</span><br><span class="line">                nextBeginOffset = nextOffsetCorrection(offset, minOffset);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextBeginOffset = nextOffsetCorrection(offset, maxOffset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 根据offset找到对应的ConsumeQueue的MappedFile（包含ByteBuf）</span></span><br><span class="line">            SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset);</span><br><span class="line">            <span class="keyword">if</span> (bufferConsumeQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> nextPhyFileStartOffset = Long.MIN_VALUE;</span><br><span class="line">                    <span class="keyword">long</span> maxPhyOffsetPulling = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// 能返回的最大信息大小，不能大于16M</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> maxFilterMessageCount = Math.max(<span class="number">16000</span>, maxMsgNums * ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> diskFallRecorded = <span class="keyword">this</span>.messageStoreConfig.isDiskFallRecorded();</span><br><span class="line">                    <span class="comment">// 封装CqExtUnit</span></span><br><span class="line">                    ConsumeQueueExt.CqExtUnit cqExtUnit = <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit();</span><br><span class="line">                    <span class="keyword">for</span> (; i &lt; bufferConsumeQueue.getSize() &amp;&amp; i &lt; maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">                        <span class="comment">// 对应了CQUnit的结构</span></span><br><span class="line">                        <span class="keyword">long</span> offsetPy = bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class="line">                        <span class="keyword">int</span> sizePy = bufferConsumeQueue.getByteBuffer().getInt();</span><br><span class="line">                        <span class="keyword">long</span> tagsCode = bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class="line"></span><br><span class="line">                        maxPhyOffsetPulling = offsetPy;</span><br><span class="line">                        <span class="comment">// 不是末尾的情况，offsetPy不正常则返回</span></span><br><span class="line">                        <span class="keyword">if</span> (nextPhyFileStartOffset != Long.MIN_VALUE) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (offsetPy &lt; nextPhyFileStartOffset)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">boolean</span> isInDisk = checkInDiskByCommitOffset(offsetPy, maxOffsetPy);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.isTheBatchFull(sizePy, maxMsgNums, getResult.getBufferTotalSize(), getResult.getMessageCount(),</span><br><span class="line">                            isInDisk)) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">boolean</span> extRet = <span class="keyword">false</span>, isTagsCodeLegal = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (consumeQueue.isExtAddr(tagsCode)) &#123;</span><br><span class="line">                            extRet = consumeQueue.getExt(tagsCode, cqExtUnit);</span><br><span class="line">                            <span class="keyword">if</span> (extRet) &#123;</span><br><span class="line">                                tagsCode = cqExtUnit.getTagsCode();</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// can't find ext content.Client will filter messages by tag also.</span></span><br><span class="line">                                log.error(<span class="string">"[BUG] can't find consume queue extend file content!addr=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;, topic=&#123;&#125;, group=&#123;&#125;"</span>,</span><br><span class="line">                                    tagsCode, offsetPy, sizePy, topic, group);</span><br><span class="line">                                isTagsCodeLegal = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                      	<span class="comment">// 关于过滤，可以在参考出找到大佬的文章膜拜一下</span></span><br><span class="line">                        <span class="comment">// 是否有根据tagsCode匹配的消息</span></span><br><span class="line">                        <span class="keyword">if</span> (messageFilter != <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : <span class="keyword">null</span>, extRet ? cqExtUnit : <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (getResult.getBufferTotalSize() == <span class="number">0</span>) &#123;</span><br><span class="line">                                status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 根据offset和size从CommitLog拿到具体的Message</span></span><br><span class="line">                        SelectMappedBufferResult selectResult = <span class="keyword">this</span>.commitLog.getMessage(offsetPy, sizePy);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">null</span> == selectResult) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (getResult.getBufferTotalSize() == <span class="number">0</span>) &#123;</span><br><span class="line">                                status = GetMessageStatus.MESSAGE_WAS_REMOVING;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            nextPhyFileStartOffset = <span class="keyword">this</span>.commitLog.rollNextFile(offsetPy);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 是否有根据内容匹配的消息</span></span><br><span class="line">                        <span class="keyword">if</span> (messageFilter != <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; !messageFilter.isMatchedByCommitLog(selectResult.getByteBuffer().slice(), <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (getResult.getBufferTotalSize() == <span class="number">0</span>) &#123;</span><br><span class="line">                                status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// release...</span></span><br><span class="line">                            selectResult.release();</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 增加一些统计信息</span></span><br><span class="line">                        <span class="keyword">this</span>.storeStatsService.getGetMessageTransferedMsgCount().incrementAndGet();</span><br><span class="line">                        <span class="comment">// 将Message放入结果集</span></span><br><span class="line">                        getResult.addMessage(selectResult);</span><br><span class="line">                        status = GetMessageStatus.FOUND;</span><br><span class="line">                        nextPhyFileStartOffset = Long.MIN_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (diskFallRecorded) &#123;</span><br><span class="line">                        <span class="keyword">long</span> fallBehind = maxOffsetPy - maxPhyOffsetPulling;</span><br><span class="line">                        brokerStatsManager.recordDiskFallBehindSize(group, topic, queueId, fallBehind);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 更新offset</span></span><br><span class="line">                    nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> diff = maxOffsetPy - maxPhyOffsetPulling;</span><br><span class="line">                    <span class="keyword">long</span> memory = (<span class="keyword">long</span>) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE</span><br><span class="line">                        * (<span class="keyword">this</span>.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / <span class="number">100.0</span>));</span><br><span class="line">                    getResult.setSuggestPullingFromSlave(diff &gt; memory);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    bufferConsumeQueue.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                status = GetMessageStatus.OFFSET_FOUND_NULL;</span><br><span class="line">                nextBeginOffset = nextOffsetCorrection(offset, consumeQueue.rollNextFile(offset));</span><br><span class="line">                log.warn(<span class="string">"consumer request topic: "</span> + topic + <span class="string">"offset: "</span> + offset + <span class="string">" minOffset: "</span> + minOffset + <span class="string">" maxOffset: "</span></span><br><span class="line">                    + maxOffset + <span class="string">", but access logic queue failed."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = GetMessageStatus.NO_MATCHED_LOGIC_QUEUE;</span><br><span class="line">        nextBeginOffset = nextOffsetCorrection(offset, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (GetMessageStatus.FOUND == status) &#123;</span><br><span class="line">        <span class="keyword">this</span>.storeStatsService.getGetMessageTimesTotalFound().incrementAndGet();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.storeStatsService.getGetMessageTimesTotalMiss().incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> eclipseTime = <span class="keyword">this</span>.getSystemClock().now() - beginTime;</span><br><span class="line">    <span class="keyword">this</span>.storeStatsService.setGetMessageEntireTimeMax(eclipseTime);</span><br><span class="line"></span><br><span class="line">    getResult.setStatus(status);</span><br><span class="line">    getResult.setNextBeginOffset(nextBeginOffset);</span><br><span class="line">    getResult.setMaxOffset(maxOffset);</span><br><span class="line">    getResult.setMinOffset(minOffset);</span><br><span class="line">    <span class="keyword">return</span> getResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果理解了Broker的信息存储，上面的这些代码粗略的看还是比较好懂的。</p>
<p>主要是先找到topic+queue对应的<code>ConsumeQueue</code>，根据<code>PullRequest</code>传入的offset找到<br>对应的<code>MappedFile</code>；从<code>MappedFile</code>中里面读取指定数量的<code>CQUnit</code>，根据TagsCode做下过滤，然后得到过滤后的<code>Commit log</code>的offset；然后根据offset从CommitLog中获取具体的Message；最后再根据消息内容再做一次过滤，然后返回结果。</p>
<h1 id="PullRequestHoldService-suspendPullRequest"><a href="#PullRequestHoldService-suspendPullRequest" class="headerlink" title="PullRequestHoldService#suspendPullRequest"></a>PullRequestHoldService#suspendPullRequest</h1><p>从Processor的处理来看，<strong>如果没有读取到消息</strong>，会判断是否是<code>PushConsumer</code>（参数<code>hasSuspendFlag</code>）以及是否允许挂起（参数<code>brokerAllowSuspend</code>），如果是的话，则将请求挂起，方式就是封装成<code>PullRequest</code>提交给<code>PullRequestHoldService</code>。所以我们这里看看它是如何挂起请求处理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.broker.longpolling.PullRequestHoldService</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspendPullRequest</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">      String key = <span class="keyword">this</span>.buildKey(topic, queueId);</span><br><span class="line">      <span class="comment">// pullRequest被放入一个以topic+queue为key的Map中， value为一个队列ManyPullRequest</span></span><br><span class="line">      ManyPullRequest mpr = <span class="keyword">this</span>.pullRequestTable.get(key);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == mpr) &#123;</span><br><span class="line">          mpr = <span class="keyword">new</span> ManyPullRequest();</span><br><span class="line">          ManyPullRequest prev = <span class="keyword">this</span>.pullRequestTable.putIfAbsent(key, mpr);</span><br><span class="line">          <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">              mpr = prev;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mpr.addPullRequest(pullRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们回想一下，我们是不是在BrokerController启动中看到了PullRequestHoldService(继承ServiceThread)被启动了，所以我们应该去看看PullRequestHoldService做了什么，所以首先去看他的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       log.info(<span class="string">"&#123;&#125; service started"</span>, <span class="keyword">this</span>.getServiceName());</span><br><span class="line">       <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 是否开启长轮询, 长轮询等待5秒，短轮询等待1秒</span></span><br><span class="line">         			<span class="comment">// 如何过被通知有消息了就不会等，没有就等待</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.waitForRunning(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">this</span>.waitForRunning(<span class="keyword">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills());</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">long</span> beginLockTimestamp = <span class="keyword">this</span>.systemClock.now();</span><br><span class="line">             	<span class="comment">// 时间到了，或者有消息了就去通知消息消息到达</span></span><br><span class="line">               <span class="keyword">this</span>.checkHoldRequest();</span><br><span class="line">               <span class="keyword">long</span> costTime = <span class="keyword">this</span>.systemClock.now() - beginLockTimestamp;</span><br><span class="line">               <span class="keyword">if</span> (costTime &gt; <span class="number">5</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">                   log.info(<span class="string">"[NOTIFYME] check hold request cost &#123;&#125; ms."</span>, costTime);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">               log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       log.info(<span class="string">"&#123;&#125; service end"</span>, <span class="keyword">this</span>.getServiceName());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkHoldRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (String key : <span class="keyword">this</span>.pullRequestTable.keySet()) &#123;</span><br><span class="line">           String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR);</span><br><span class="line">           <span class="keyword">if</span> (<span class="number">2</span> == kArray.length) &#123;</span><br><span class="line">               String topic = kArray[<span class="number">0</span>];</span><br><span class="line">               <span class="keyword">int</span> queueId = Integer.parseInt(kArray[<span class="number">1</span>]);</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">long</span> offset = <span class="keyword">this</span>.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 通知消息到达，这个时候可能有，也可能没有</span></span><br><span class="line">                   <span class="keyword">this</span>.notifyMessageArriving(topic, queueId, offset);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                   log.error(<span class="string">"check hold request failed. topic=&#123;&#125;, queueId=&#123;&#125;"</span>, topic, queueId, e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyMessageArriving</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> <span class="keyword">long</span> maxOffset, <span class="keyword">final</span> Long tagsCode,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">long</span> msgStoreTime, <span class="keyword">byte</span>[] filterBitMap, Map&lt;String, String&gt; properties)</span> </span>&#123;</span><br><span class="line">       String key = <span class="keyword">this</span>.buildKey(topic, queueId);</span><br><span class="line">       <span class="comment">// 拿到topic+queueId对应的所有PullRequest</span></span><br><span class="line">       ManyPullRequest mpr = <span class="keyword">this</span>.pullRequestTable.get(key);</span><br><span class="line">       <span class="keyword">if</span> (mpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// clone等待的List，同时会清空等待列表</span></span><br><span class="line">           List&lt;PullRequest&gt; requestList = mpr.cloneListAndClear();</span><br><span class="line">           <span class="keyword">if</span> (requestList != <span class="keyword">null</span>) &#123;</span><br><span class="line">               List&lt;PullRequest&gt; replayList = <span class="keyword">new</span> ArrayList&lt;PullRequest&gt;();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span> (PullRequest request : requestList) &#123;</span><br><span class="line">                   <span class="comment">// 判断等待的时间内有没有新的消息进来</span></span><br><span class="line">                   <span class="keyword">long</span> newestOffset = maxOffset;</span><br><span class="line">                   <span class="keyword">if</span> (newestOffset &lt;= request.getPullFromThisOffset()) &#123;</span><br><span class="line">                       newestOffset = <span class="keyword">this</span>.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 有消息到来</span></span><br><span class="line">                   <span class="keyword">if</span> (newestOffset &gt; request.getPullFromThisOffset()) &#123;</span><br><span class="line">                       <span class="comment">// 判断消息是否符合过滤条件</span></span><br><span class="line">                       <span class="keyword">boolean</span> match = request.getMessageFilter().isMatchedByConsumeQueue(tagsCode,</span><br><span class="line">                           <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit(tagsCode, msgStoreTime, filterBitMap));</span><br><span class="line">                       <span class="comment">// match by bit map, need eval again when properties is not null.</span></span><br><span class="line">                       <span class="keyword">if</span> (match &amp;&amp; properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           match = request.getMessageFilter().isMatchedByCommitLog(<span class="keyword">null</span>, properties);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 匹配到消息，重新通过PullRequestProcessor执行消息读取</span></span><br><span class="line">                       <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">                                   request.getRequestCommand());</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                               log.error(<span class="string">"execute request when wakeup failed."</span>, e);</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 如果requst等待超时，无论前一步是否符合条件，肯定会发给processor处理</span></span><br><span class="line">                   <span class="keyword">if</span> (System.currentTimeMillis() &gt;= (request.getSuspendTimestamp() + request.getTimeoutMillis())) &#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">                               request.getRequestCommand());</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                           log.error(<span class="string">"execute request when wakeup failed."</span>, e);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 未超时和没有匹配到消息的request，重新放入队列等待</span></span><br><span class="line">                   replayList.add(request);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!replayList.isEmpty()) &#123;</span><br><span class="line">                   mpr.addPullRequest(replayList);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="comment">// org.apache.rocketmq.broker.processor.PullMessageProcessor</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeRequestWhenWakeup</span><span class="params">(<span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">     	<span class="comment">// 封装成一个任务</span></span><br><span class="line">       Runnable run = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">final</span> RemotingCommand response = PullMessageProcessor.<span class="keyword">this</span>.processRequest(channel, request, <span class="keyword">false</span>);</span><br><span class="line">									<span class="comment">// 不为空就直接推给消费者</span></span><br><span class="line">                   <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       response.setOpaque(request.getOpaque());</span><br><span class="line">                       response.markResponseType();</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           channel.writeAndFlush(response).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                               <span class="meta">@Override</span></span><br><span class="line">                               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                   <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                                       log.error(<span class="string">"processRequestWrapper response to &#123;&#125; failed"</span>,</span><br><span class="line">                                           future.channel().remoteAddress(), future.cause());</span><br><span class="line">                                       log.error(request.toString());</span><br><span class="line">                                       log.error(response.toString());</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;);</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                           log.error(<span class="string">"processRequestWrapper process request over, but response failed"</span>, e);</span><br><span class="line">                           log.error(request.toString());</span><br><span class="line">                           log.error(response.toString());</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (RemotingCommandException e1) &#123;</span><br><span class="line">                   log.error(<span class="string">"excuteRequestWhenWakeup run"</span>, e1);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="keyword">this</span>.brokerController.getPullMessageExecutor().submit(<span class="keyword">new</span> RequestTask(run, channel, request));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在回想一下<code>PullRequestHoldService#notifyMessageArriving()</code>方法，我们是否似曾相识，对了，就是在<code>org.apache.rocketmq.store.DefaultMessageStore.ReputMessageService#doReput()</code>方法时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getBrokerRole()</span><br><span class="line">                                        &amp;&amp; DefaultMessageStore.<span class="keyword">this</span>.brokerConfig.isLongPollingEnable()) &#123;</span><br><span class="line">	<span class="comment">// 唤醒等待的PullReqeust接收消息                              </span></span><br><span class="line">  DefaultMessageStore.<span class="keyword">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</span><br><span class="line">                                              dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class="number">1</span>,</span><br><span class="line">                                              dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),</span><br><span class="line">                                              dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK！到这里，Broker就已经完成了PullMessage的接收啦！！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/f63c7836feb0" target="_blank" rel="noopener">RocketMQ源码解析(十一)-Broker#消息消费</a></li>
<li><a href="https://www.kunzhao.org/blog/2018/04/02/rocketmq-message-filter-flow/" target="_blank" rel="noopener">RocketMQ 消息过滤流程</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前面讲到了Broker对于不同的消息有自己不同的Processor，对于&lt;code&gt;PushConsumer&lt;/code&gt;的Pull请求的时候，它对应的就是&lt;code&gt;PullMessageProcessor&lt;/code&gt;~
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——Broker接收发送消息</title>
    <link href="http://bestlixiang.site/2019/06/26/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Broke%E6%8E%A5%E6%94%B6%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF/"/>
    <id>http://bestlixiang.site/2019/06/26/RocketMQ源码/RocketMQ源码分析——Broke接收发送消息/</id>
    <published>2019-06-25T23:30:53.000Z</published>
    <updated>2019-06-25T23:59:31.271Z</updated>
    
    <content type="html"><![CDATA[<p>引：前面我们说过了Producer和Consumer是如何发送消息的，当我们了解完Broker的消息存储之后，我们就可以看看Broker是如何接收发来的消息啦~<a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在分析完Producer和Consumer之后，我们知道无论是消费者还是生产者来说，Broker都是接受消息的一方，同时我们知道RocketMQ是通过Netty实现通信的，对应接收消息，我们很容易就会想到一定是一个ChannelHandler在处理，而在RocketMQ的设计中对应是<code>NettyRequestProcessor</code>，所以我们就可以分析一下接收消息的几种类型啦，有几种消息类型，就有几种Processor，如下图：<br><img src="https://upload-images.jianshu.io/upload_images/10354196-8900cd8452e3e0a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="broker-processor.png"></p>
<p>我们看到有很多种消息类型，我们这次只分析<code>SendMessage</code>。</p>
<h1 id="SendMessage"><a href="#SendMessage" class="headerlink" title="SendMessage"></a>SendMessage</h1><p>对于SendMessage有下面这几种可能：单条消息、批量消息、RETRY消息。Retry消息即consumer消费失败，要求broker重发的消息。失败的原因有两种，一种是业务端代码处理失败；还有一种是消息在consumer的缓存队列中待的时间超时，consumer会将消息从队列中移除，然后退回给Broker重发。</p>
<h1 id="SendMessageProcessor"><a href="#SendMessageProcessor" class="headerlink" title="SendMessageProcessor"></a>SendMessageProcessor</h1><p>我们肯定会找到<code>org.apache.rocketmq.broker.processor.SendMessageProcessor#processRequest()</code>这个方法，因为它实现自<code>NettyRequestProcessor</code>接口的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    SendMessageContext mqtraceContext;</span><br><span class="line">    <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line">            <span class="comment">// RETRY消息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.consumerSendMsgBack(ctx, request);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            SendMessageRequestHeader requestHeader = parseRequestHeader(request);</span><br><span class="line">            <span class="keyword">if</span> (requestHeader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mqtraceContext = buildMsgContext(ctx, requestHeader);</span><br><span class="line">            <span class="keyword">this</span>.executeSendMessageHookBefore(ctx, request, mqtraceContext);</span><br><span class="line"></span><br><span class="line">            RemotingCommand response;</span><br><span class="line">            <span class="keyword">if</span> (requestHeader.isBatch()) &#123;</span><br><span class="line">                <span class="comment">// 批量发送</span></span><br><span class="line">                response = <span class="keyword">this</span>.sendBatchMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 单条消息</span></span><br><span class="line">                response = <span class="keyword">this</span>.sendMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.executeSendMessageHookAfter(response, mqtraceContext);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Consumer的RETRY消息"><a href="#Consumer的RETRY消息" class="headerlink" title="Consumer的RETRY消息"></a>Consumer的RETRY消息</h1><p>对于Consumer的RETRY消息，我们可以找到<code>org.apache.rocketmq.broker.processor.SendMessageProcessor#consumerSendMsgBack()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">consumerSendMsgBack</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> RemotingCommand request)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">final</span> ConsumerSendMsgBackRequestHeader requestHeader =</span><br><span class="line">           (ConsumerSendMsgBackRequestHeader)request.decodeCommandCustomHeader(ConsumerSendMsgBackRequestHeader.class);</span><br><span class="line"></span><br><span class="line"> 			<span class="comment">// ...</span></span><br><span class="line">			<span class="comment">// consumer group是否存在</span></span><br><span class="line">       SubscriptionGroupConfig subscriptionGroupConfig =</span><br><span class="line">           <span class="keyword">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getGroup());</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionGroupConfig) &#123;</span><br><span class="line">           response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</span><br><span class="line">           response.setRemark(<span class="string">"subscription group not exist, "</span> + requestHeader.getGroup() + <span class="string">" "</span></span><br><span class="line">               + FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST));</span><br><span class="line">           <span class="keyword">return</span> response;</span><br><span class="line">       &#125;</span><br><span class="line">			<span class="comment">// ... </span></span><br><span class="line">       <span class="comment">// 获得重试队列Topic和queue</span></span><br><span class="line">       String newTopic = MixAll.getRetryTopic(requestHeader.getGroup());</span><br><span class="line">       <span class="keyword">int</span> queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % subscriptionGroupConfig.getRetryQueueNums();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> topicSysFlag = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (requestHeader.isUnitMode()) &#123;</span><br><span class="line">           topicSysFlag = TopicSysFlag.buildSysFlag(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(</span><br><span class="line">           newTopic,</span><br><span class="line">           subscriptionGroupConfig.getRetryQueueNums(),</span><br><span class="line">     	<span class="comment">// ...</span></span><br><span class="line">			<span class="comment">// 根据offset找到MessageExt</span></span><br><span class="line">       MessageExt msgExt = <span class="keyword">this</span>.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getOffset());</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == msgExt) &#123;</span><br><span class="line">           response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">           response.setRemark(<span class="string">"look message by offset failed, "</span> + requestHeader.getOffset());</span><br><span class="line">           <span class="keyword">return</span> response;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> String retryTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == retryTopic) &#123;</span><br><span class="line">           MessageAccessor.putProperty(msgExt, MessageConst.PROPERTY_RETRY_TOPIC, msgExt.getTopic());</span><br><span class="line">       &#125;</span><br><span class="line">       msgExt.setWaitStoreMsgOK(<span class="keyword">false</span>);</span><br><span class="line">			<span class="comment">// 查看延迟等级</span></span><br><span class="line">       <span class="comment">//  messageDelayLevel = "1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h"</span></span><br><span class="line">       <span class="keyword">int</span> delayLevel = requestHeader.getDelayLevel();</span><br><span class="line">			<span class="comment">// 最大重复次数16次</span></span><br><span class="line">       <span class="keyword">int</span> maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();</span><br><span class="line">       <span class="keyword">if</span> (request.getVersion() &gt;= MQVersion.Version.V3_4_9.ordinal()) &#123;</span><br><span class="line">           maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果大于重试次数，则放入DLQ死信队列</span></span><br><span class="line">       <span class="keyword">if</span> (msgExt.getReconsumeTimes() &gt;= maxReconsumeTimes</span><br><span class="line">           || delayLevel &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         	<span class="comment">// 将topic和queueid设置为死信队列的</span></span><br><span class="line">           newTopic = MixAll.getDLQTopic(requestHeader.getGroup());</span><br><span class="line">           queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % DLQ_NUMS_PER_GROUP;</span><br><span class="line"></span><br><span class="line">           topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic,</span><br><span class="line">               DLQ_NUMS_PER_GROUP,</span><br><span class="line">               PermName.PERM_WRITE, <span class="number">0</span></span><br><span class="line">           );</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">               response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">               response.setRemark(<span class="string">"topic["</span> + newTopic + <span class="string">"] not exist"</span>);</span><br><span class="line">               <span class="keyword">return</span> response;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     			<span class="comment">// 加三个等级的延迟</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="number">0</span> == delayLevel) &#123;</span><br><span class="line">               delayLevel = <span class="number">3</span> + msgExt.getReconsumeTimes();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           msgExt.setDelayTimeLevel(delayLevel);</span><br><span class="line">       &#125;</span><br><span class="line">			<span class="comment">// 将msgExt转化为MessageExtBrokerInner</span></span><br><span class="line">       MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">       msgInner.setTopic(newTopic);</span><br><span class="line">       msgInner.setBody(msgExt.getBody());</span><br><span class="line">       msgInner.setFlag(msgExt.getFlag());</span><br><span class="line">       MessageAccessor.setProperties(msgInner, msgExt.getProperties());</span><br><span class="line">       msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));</span><br><span class="line">       msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(<span class="keyword">null</span>, msgExt.getTags()));</span><br><span class="line"></span><br><span class="line">       msgInner.setQueueId(queueIdInt);</span><br><span class="line">       msgInner.setSysFlag(msgExt.getSysFlag());</span><br><span class="line">       msgInner.setBornTimestamp(msgExt.getBornTimestamp());</span><br><span class="line">       msgInner.setBornHost(msgExt.getBornHost());</span><br><span class="line">       msgInner.setStoreHost(<span class="keyword">this</span>.getStoreHost());</span><br><span class="line">       msgInner.setReconsumeTimes(msgExt.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       String originMsgId = MessageAccessor.getOriginMessageId(msgExt);</span><br><span class="line">       MessageAccessor.setOriginMessageId(msgInner, UtilAll.isBlank(originMsgId) ? msgExt.getMsgId() : originMsgId);</span><br><span class="line">       <span class="comment">// 存储消息</span></span><br><span class="line">       PutMessageResult putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line">       <span class="keyword">if</span> (putMessageResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">switch</span> (putMessageResult.getPutMessageStatus()) &#123;</span><br><span class="line">               <span class="keyword">case</span> PUT_OK:</span><br><span class="line">                   String backTopic = msgExt.getTopic();</span><br><span class="line">                   String correctTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line">                   <span class="keyword">if</span> (correctTopic != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       backTopic = correctTopic;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incSendBackNums(requestHeader.getGroup(), backTopic);</span><br><span class="line"></span><br><span class="line">                   response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">                   response.setRemark(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">return</span> response;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">           response.setRemark(putMessageResult.getPutMessageStatus().name());</span><br><span class="line">           <span class="keyword">return</span> response;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">       response.setRemark(<span class="string">"putMessageResult is null"</span>);</span><br><span class="line">       <span class="keyword">return</span> response;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Producer的单条消息"><a href="#Producer的单条消息" class="headerlink" title="Producer的单条消息"></a>Producer的单条消息</h1><p>对于Producer的单条消息，我们可以找到<code>org.apache.rocketmq.broker.processor.SendMessageProcessor#sendMessage()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> RemotingCommand request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> SendMessageContext sendMessageContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> SendMessageRequestHeader requestHeader)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(SendMessageResponseHeader.class);</span><br><span class="line">    <span class="keyword">final</span> SendMessageResponseHeader responseHeader = (SendMessageResponseHeader)response.readCustomHeader();</span><br><span class="line"></span><br><span class="line">    response.setOpaque(request.getOpaque());</span><br><span class="line"></span><br><span class="line">    response.addExtField(MessageConst.PROPERTY_MSG_REGION, <span class="keyword">this</span>.brokerController.getBrokerConfig().getRegionId());</span><br><span class="line">    response.addExtField(MessageConst.PROPERTY_TRACE_SWITCH, String.valueOf(<span class="keyword">this</span>.brokerController.getBrokerConfig().isTraceOn()));</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">"receive SendMessage request command, &#123;&#125;"</span>, request);</span><br><span class="line">    <span class="comment">// 判断当前时间broker是否提供服务，不提供则返回code为SYSTEM_ERROR的response</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTimstamp = <span class="keyword">this</span>.brokerController.getBrokerConfig().getStartAcceptSendRequestTimeStamp();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getMessageStore().now() &lt; startTimstamp) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(String.format(<span class="string">"broker unable to service, until %s"</span>, UtilAll.timeMillisToHumanString2(startTimstamp)));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.setCode(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 检查topic和queue，如果不存在且broker设置中允许自动创建，则自动创建</span></span><br><span class="line">    <span class="keyword">super</span>.msgCheck(ctx, requestHeader, response);</span><br><span class="line">    <span class="keyword">if</span> (response.getCode() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] body = request.getBody();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> queueIdInt = requestHeader.getQueueId();</span><br><span class="line">    <span class="comment">// 获取topic的配置</span></span><br><span class="line">    TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line">    <span class="comment">// 如果消息中的queueId小于0，则随机选取一个queue</span></span><br><span class="line">    <span class="keyword">if</span> (queueIdInt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % topicConfig.getWriteQueueNums();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新封装request中的message成MessageExtBrokerInner</span></span><br><span class="line">    MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">    msgInner.setTopic(requestHeader.getTopic());</span><br><span class="line">    msgInner.setQueueId(queueIdInt);</span><br><span class="line">    <span class="comment">// 对于RETRY消息的一些处理</span></span><br><span class="line">    <span class="keyword">if</span> (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转化消息为MessageExtBrokerInner</span></span><br><span class="line">    msgInner.setBody(body);</span><br><span class="line">    msgInner.setFlag(requestHeader.getFlag());</span><br><span class="line">    MessageAccessor.setProperties(msgInner, MessageDecoder.string2messageProperties(requestHeader.getProperties()));</span><br><span class="line">    msgInner.setPropertiesString(requestHeader.getProperties());</span><br><span class="line">    msgInner.setBornTimestamp(requestHeader.getBornTimestamp());</span><br><span class="line">    msgInner.setBornHost(ctx.channel().remoteAddress());</span><br><span class="line">    msgInner.setStoreHost(<span class="keyword">this</span>.getStoreHost());</span><br><span class="line">    msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == <span class="keyword">null</span> ? <span class="number">0</span> : requestHeader.getReconsumeTimes());</span><br><span class="line">    PutMessageResult putMessageResult = <span class="keyword">null</span>;</span><br><span class="line">    Map&lt;String, String&gt; oriProps = MessageDecoder.string2messageProperties(requestHeader.getProperties());</span><br><span class="line">    String traFlag = oriProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">    <span class="keyword">if</span> (traFlag != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(traFlag)) &#123;</span><br><span class="line">        <span class="comment">// 是否拒绝事务消息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(</span><br><span class="line">                <span class="string">"the broker["</span> + <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1()</span><br><span class="line">                    + <span class="string">"] sending transaction message is forbidden"</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        putMessageResult = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().prepareMessage(msgInner);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用MessageStore接口存储消息，这里就到我们之前分析的消息存储哪里了</span></span><br><span class="line">        putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据存储结果设置repsonse状态，更新broker统计信息，成功则回复producer，更新context上下文</span></span><br><span class="line">    <span class="keyword">return</span> handlePutMessageResult(putMessageResult, response, request, msgInner, responseHeader, sendMessageContext, ctx, queueIdInt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>其实我有个问题就是对于Producer的单条信息，为了要判断重试次数？？ 问题先放在这，等以后知道了，再来回答！！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="https://www.jianshu.com/p/0b4b1147366f" target="_blank" rel="noopener">RocketMQ源码解析(八)-Broker#消息发送</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/925a628f3f80" target="_blank" rel="noopener">RocketMQ消费失败消息深入分析（consumer,broker的具体处理逻辑）</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前面我们说过了Producer和Consumer是如何发送消息的，当我们了解完Broker的消息存储之后，我们就可以看看Broker是如何接收发来的消息啦~
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——Broker消息存储</title>
    <link href="http://bestlixiang.site/2019/06/22/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Broker%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/"/>
    <id>http://bestlixiang.site/2019/06/22/RocketMQ源码/RocketMQ源码分析——Broker消息存储/</id>
    <published>2019-06-22T06:23:01.000Z</published>
    <updated>2019-06-22T06:23:48.546Z</updated>
    
    <content type="html"><![CDATA[<p>引：消息存储对于一个消息队列来说是肯定要有的，在RocketMQ中，Broker将消息存储抽象成<code>MessageStore</code>接口，我们也将从这里入手~ <a id="more"></a></p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>美图：</p>
<p><img src="https://img-blog.csdn.net/20180322173040972?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjc1Mjk5MTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="MessageStore"></p>
<p>从上面我们可以看到几个核心的数据结构：</p>
<ul>
<li><strong>CommitLog</strong>：存储消息的数据结构，类似一个消息数组，按照消息收到的顺序，所有消息都存储在一起。每个消息存储后都会生成一个对应的offset，代表在commitLog中的字节偏移量。注意：CommitLog并不是一个文件，而是一系列文件（上图中的MappedFile）。每个MappedFile文件的大小都是固定的（默认1G），写满一个会生成一个新的文件，新文件的文件名就是它存储的第一条消息的offset。</li>
<li><strong>ConsumeQueue</strong>：之前说了所有消息都是存储在一个commitLog中的，但是consumer是按照topic+queue的维度来消费消息的，没有办法直接从commitLog中读取，所以针对每个topic的每个queue都会生成consumeQueue，ConsumeQueue中存储的是消息在commitLog中的offset，可以理解成一个按topic+queue建的索引，每条消息占用20字节（上图中的一个cq）。跟commitLog一样，每个Queue文件也是一系列连续的文件组成，每个文件默认放30w个offset索引。</li>
<li><strong>IndexFile</strong>：CommitLog的另外一种形式的索引文件，只是索引的是messageKey，每个MsgKey经过hash后计算存储的slot，然后将offset存到IndexFile的相应slot上。根据msgKey来查询消息时，可以先到IndexFile（slot+index类似一个hashmap）中查询offset，然后根据offset去commitLog中查询对应的消息。</li>
</ul>
<p>关于图中的过程我们后面会展开讲解~</p>
<h1 id="MessageStore启动"><a href="#MessageStore启动" class="headerlink" title="MessageStore启动"></a>MessageStore启动</h1><p>之前，我们在BrokerController的启动中看到了MessageStore启动，所以我们也从那里开始看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.store.DefaultMessageStore</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 构造文件锁，保证磁盘上的文件只会被一个messageStore读写</span></span><br><span class="line">      lock = lockFile.getChannel().tryLock(<span class="number">0</span>, <span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (lock == <span class="keyword">null</span> || lock.isShared() || !lock.isValid()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Lock failed,MQ already started"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      lockFile.getChannel().write(ByteBuffer.wrap(<span class="string">"lock"</span>.getBytes()));</span><br><span class="line">      lockFile.getChannel().force(<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">// 启动FlushConsumeQueueService(继承ServiceThread，是个单线程)</span></span><br><span class="line">      <span class="comment">// 定时将consumeQueue文件的数据刷新到磁盘，周期由参数flushIntervalConsumeQueue设置，默认1秒</span></span><br><span class="line">      <span class="keyword">this</span>.flushConsumeQueueService.start();</span><br><span class="line">      <span class="comment">// 启动CommitLog，对应了flushCommitLogService服务</span></span><br><span class="line">    	<span class="comment">// flushCommitLogService服务负责将CommitLog的数据flush到磁盘，有同步刷盘和异步刷盘两种方式</span></span><br><span class="line">      <span class="keyword">this</span>.commitLog.start();</span><br><span class="line">      <span class="comment">// 消息存储指标统计服务，RT，TPS等指标，admin可以用</span></span><br><span class="line">      <span class="keyword">this</span>.storeStatsService.start();</span><br><span class="line">      <span class="comment">// 针对master，启动延时消息调度服务，真的消费失败的情况</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.scheduleMessageService != <span class="keyword">null</span> &amp;&amp; SLAVE != messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.scheduleMessageService.start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 启动ReputMessageService，该服务负责将CommitLog中的消息offset记录到cosumeQueue文件中</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageStoreConfig().isDuplicationEnable()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.reputMessageService.setReputFromOffset(<span class="keyword">this</span>.commitLog.getConfirmOffset());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.reputMessageService.setReputFromOffset(<span class="keyword">this</span>.commitLog.getMaxOffset());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.reputMessageService.start();</span><br><span class="line">      <span class="comment">// 启动HAService，数据主从同步的服务</span></span><br><span class="line">      <span class="keyword">this</span>.haService.start();</span><br><span class="line">      <span class="comment">// 对于新的broker，初始化文件存储的目录</span></span><br><span class="line">      <span class="keyword">this</span>.createTempFile();</span><br><span class="line">      <span class="comment">// 启动定时任务</span></span><br><span class="line">      <span class="keyword">this</span>.addScheduleTask();</span><br><span class="line">      <span class="keyword">this</span>.shutdown = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后看看它起了哪些定时任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addScheduleTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定时清理过期的commitLog、cosumeQueue数据文件</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DefaultMessageStore.<span class="keyword">this</span>.cleanFilesPeriodically();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">60</span>, <span class="keyword">this</span>.messageStoreConfig.getCleanResourceInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="comment">// 定时自检commitLog和consumerQueue文件，校验文件是否完整。主要用于监控，不会做修复文件的动作</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DefaultMessageStore.<span class="keyword">this</span>.checkSelf();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">// 定时检查commitLog的Lock时长(因为在write或者flush时侯会lock)</span></span><br><span class="line">    <span class="comment">// 如果lock的时间过长，则打印jvm堆栈，用于监控。</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().isDebugLockEnable()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.commitLog.getBeginTimeInLock() != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">long</span> lockTime = System.currentTimeMillis() - DefaultMessageStore.<span class="keyword">this</span>.commitLog.getBeginTimeInLock();</span><br><span class="line">                        <span class="keyword">if</span> (lockTime &gt; <span class="number">1000</span> &amp;&amp; lockTime &lt; <span class="number">10000000</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            String stack = UtilAll.jstack();</span><br><span class="line">                            <span class="keyword">final</span> String fileName = System.getProperty(<span class="string">"user.home"</span>) + File.separator + <span class="string">"debug/lock/stack-"</span></span><br><span class="line">                                + DefaultMessageStore.<span class="keyword">this</span>.commitLog.getBeginTimeInLock() + <span class="string">"-"</span> + lockTime;</span><br><span class="line">                            MixAll.string2FileNotSafe(stack, fileName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="CommitLog"><a href="#CommitLog" class="headerlink" title="CommitLog"></a>CommitLog</h1><p>我们知道当Broker接收到消息会进行存储，首先存储的就是CommitLog，所以我们可以找到<code>org.apache.rocketmq.store.CommitLog#putMessage()</code>方法，这里可能有多条消息一起存储，我们这里主要说一下单条消息存储：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置存储时间戳</span></span><br><span class="line">    msg.setStoreTimestamp(System.currentTimeMillis());</span><br><span class="line">    <span class="comment">// 忽略加密</span></span><br><span class="line">    msg.setBodyCRC(UtilAll.crc32(msg.getBody()));</span><br><span class="line">    <span class="comment">// 构造返回结果</span></span><br><span class="line">    AppendMessageResult result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 拿到统计状态服务，后面会设置一些值</span></span><br><span class="line">    StoreStatsService storeStatsService = <span class="keyword">this</span>.defaultMessageStore.getStoreStatsService();</span><br><span class="line">    <span class="comment">// 拿到Topic和queue信息</span></span><br><span class="line">    String topic = msg.getTopic();</span><br><span class="line">    <span class="keyword">int</span> queueId = msg.getQueueId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">    <span class="comment">// 非事务消息</span></span><br><span class="line">    <span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE</span><br><span class="line">        || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">        <span class="comment">// Delay Delivery</span></span><br><span class="line">        <span class="comment">// 延时投放消息，变更topic为SCHEDULE_TOPIC_XXXX以及队列</span></span><br><span class="line">      	<span class="comment">// 被重发的Schedule任务读到</span></span><br><span class="line">        <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">                msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">            queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 备份之前的topic和queueId</span></span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">            msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">            msg.setTopic(topic);</span><br><span class="line">            msg.setQueueId(queueId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> eclipseTimeInLock = <span class="number">0</span>;</span><br><span class="line">    MappedFile unlockMappedFile = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取当前正在写入文件</span></span><br><span class="line">    MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile();</span><br><span class="line">    <span class="comment">// 获取写message的锁，可以是自旋锁或者可重入锁，看配置</span></span><br><span class="line">    putMessageLock.lock(); <span class="comment">//spin or ReentrantLock ,depending on store config</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> beginLockTimestamp = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now();</span><br><span class="line">        <span class="keyword">this</span>.beginTimeInLock = beginLockTimestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here settings are stored timestamp, in order to ensure an orderly</span></span><br><span class="line">        <span class="comment">// global</span></span><br><span class="line">        msg.setStoreTimestamp(beginLockTimestamp);</span><br><span class="line">        <span class="comment">// 如果文件不存在或者文件已经写满，新建一个mappedfile</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line">            mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>); <span class="comment">// Mark: NewFile may be cause noise</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 文件创建失败，则返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">            log.error(<span class="string">"create mapped file1 error, topic: "</span> + msg.getTopic() + <span class="string">" clientAddr: "</span> + msg.getBornHostString());</span><br><span class="line">            beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 消息写入文件，有一个回调，待会说</span></span><br><span class="line">        result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">        <span class="keyword">switch</span> (result.getStatus()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PUT_OK:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果文件已满，则新建一个文件继续</span></span><br><span class="line">            <span class="keyword">case</span> END_OF_FILE:</span><br><span class="line">                unlockMappedFile = mappedFile;</span><br><span class="line">                <span class="comment">// Create a new file, re-write the message</span></span><br><span class="line">                mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                    log.error(<span class="string">"create mapped file2 error, topic: "</span> + msg.getTopic() + <span class="string">" clientAddr: "</span> + msg.getBornHostString());</span><br><span class="line">                    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result);</span><br><span class="line">                &#125;</span><br><span class="line">                result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_SIZE_EXCEEDED:</span><br><span class="line">            <span class="keyword">case</span> PROPERTIES_SIZE_EXCEEDED:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);</span><br><span class="line">            <span class="keyword">case</span> UNKNOWN_ERROR:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eclipseTimeInLock = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</span><br><span class="line">        beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放获取到的锁</span></span><br><span class="line">        putMessageLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写消息时间过长, 警告</span></span><br><span class="line">    <span class="keyword">if</span> (eclipseTimeInLock &gt; <span class="number">500</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">"[NOTIFYME]putMessage in lock cost time(ms)=&#123;&#125;, bodyLength=&#123;&#125; AppendMessageResult=&#123;&#125;"</span>, eclipseTimeInLock, msg.getBody().length, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// unlock已经写满的文件，释放内存锁（系统锁）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != unlockMappedFile &amp;&amp; <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMessageStore.unlockMappedFile(unlockMappedFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PutMessageResult putMessageResult = <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PUT_OK, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些统计信息</span></span><br><span class="line">    storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).incrementAndGet();</span><br><span class="line">    storeStatsService.getSinglePutMessageTopicSizeTotal(topic).addAndGet(result.getWroteBytes());</span><br><span class="line">    <span class="comment">// flush数据到磁盘，分同步和异步</span></span><br><span class="line">    handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line">    <span class="comment">// 如果是SYNC_MASTER，则Master保存消息后，需要将消息同步给slave后才会返回结果</span></span><br><span class="line">    <span class="comment">// 如果ASYNC_MASTER，这里不会做任何操作，由HAService的后台线程做数据同步</span></span><br><span class="line">    handleHA(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> putMessageResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在之前的数据结构图中以及上面的代码中都看到了CommitLog是存储在MappedFile中，下面我们就看看写入消息到MappedFile的实现，对应了<code>org.apache.rocketmq.store.MappedFile#appendMessage()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">appendMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg, <span class="keyword">final</span> AppendMessageCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> appendMessagesInner(msg, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">appendMessagesInner</span><span class="params">(<span class="keyword">final</span> MessageExt messageExt, <span class="keyword">final</span> AppendMessageCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> messageExt != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">assert</span> cb != <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取当前的write position，用了原子计数器AtomicInteger</span></span><br><span class="line">    <span class="keyword">int</span> currentPos = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentPos &lt; <span class="keyword">this</span>.fileSize) &#123;</span><br><span class="line">        <span class="comment">// 获得NIO的BytBuffer，从writeBuffer或者mappedByteBuffer，这里就利用了零拷贝</span></span><br><span class="line">        <span class="comment">// 如果是writeBuffer，属于异步</span></span><br><span class="line">        <span class="comment">// CommitLog启动的时候初始化一块内存池(通过ByteBuffer申请的堆外内存)</span></span><br><span class="line">        <span class="comment">// 消息数据首先写入内存池中，然后后台有个线程定时将内存池中的数据commit到FileChannel中</span></span><br><span class="line">        <span class="comment">// 如果是mappedByteBuffer，属于同步</span></span><br><span class="line">        <span class="comment">// 在写入文件时，从FileChannel获取直接内存映射，收到消息后，将数据写入到这块内存中，内存和物理文件的数据交互由操作系统负责</span></span><br><span class="line">        ByteBuffer byteBuffer = writeBuffer != <span class="keyword">null</span> ? writeBuffer.slice() : <span class="keyword">this</span>.mappedByteBuffer.slice();</span><br><span class="line">        byteBuffer.position(currentPos);</span><br><span class="line">        AppendMessageResult result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBrokerInner) &#123;</span><br><span class="line">            <span class="comment">// 写单条消息到byteBuffer</span></span><br><span class="line">            result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBrokerInner) messageExt);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBatch) &#123;</span><br><span class="line">            <span class="comment">// 批量消息到byteBuffer</span></span><br><span class="line">            result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBatch) messageExt);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新write position，到最新值</span></span><br><span class="line">        <span class="keyword">this</span>.wrotePosition.addAndGet(result.getWroteBytes());</span><br><span class="line">        <span class="keyword">this</span>.storeTimestamp = result.getStoreTimestamp();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    log.error(<span class="string">"MappedFile.appendMessage return null, wrotePosition: &#123;&#125; fileSize: &#123;&#125;"</span>, currentPos, <span class="keyword">this</span>.fileSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在写入到MappedZFile的函数中，我们看到有个回调函数，好像也不算回调🤣，我们调用了这个函数的<code>#doAppend()</code>方法，我们看看它做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">doAppend</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> fileFromOffset, <span class="keyword">final</span> ByteBuffer byteBuffer, <span class="keyword">final</span> <span class="keyword">int</span> maxBlank,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> MessageExtBrokerInner msgInner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// STORETIMESTAMP + STOREHOSTADDRESS + OFFSET &lt;br&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// PHY OFFSET 消息偏移 文件的名的offset + bytebuffer的位置就是要写的offset</span></span><br><span class="line">    <span class="keyword">long</span> wroteOffset = fileFromOffset + byteBuffer.position();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.resetByteBuffer(hostHolder, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// 生成message ID, 前8位是host，后8位是wroteOffset,目的是便于使用msgID来查找消息</span></span><br><span class="line">    String msgId = MessageDecoder.createMessageId(<span class="keyword">this</span>.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record ConsumeQueue information</span></span><br><span class="line">    keyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">    keyBuilder.append(msgInner.getTopic());</span><br><span class="line">    keyBuilder.append(<span class="string">'-'</span>);</span><br><span class="line">    keyBuilder.append(msgInner.getQueueId());</span><br><span class="line">    String key = keyBuilder.toString();</span><br><span class="line">    <span class="comment">// 取得具体Queue的offset，值是当前是Queue里的第几条消息</span></span><br><span class="line">    Long queueOffset = CommitLog.<span class="keyword">this</span>.topicQueueTable.get(key);</span><br><span class="line">    <span class="comment">// 如果是这个queue的第一条消息，需要初始化queueOffset</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == queueOffset) &#123;</span><br><span class="line">        queueOffset = <span class="number">0L</span>;</span><br><span class="line">        CommitLog.<span class="keyword">this</span>.topicQueueTable.put(key, queueOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务消息需要特别的处理，略过</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msgInner.getSysFlag());</span><br><span class="line">    <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">        <span class="comment">// Prepared and Rollback message is not consumed, will not enter the</span></span><br><span class="line">        <span class="comment">// consumer queuec</span></span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">            queueOffset = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化消息</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] propertiesData =</span><br><span class="line">        msgInner.getPropertiesString() == <span class="keyword">null</span> ? <span class="keyword">null</span> : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> propertiesLength = propertiesData == <span class="keyword">null</span> ? <span class="number">0</span> : propertiesData.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propertiesLength &gt; Short.MAX_VALUE) &#123;</span><br><span class="line">        log.warn(<span class="string">"putMessage message properties length too long. length=&#123;&#125;"</span>, propertiesData.length);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> topicLength = topicData.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bodyLength = msgInner.getBody() == <span class="keyword">null</span> ? <span class="number">0</span> : msgInner.getBody().length;</span><br><span class="line">    <span class="comment">// 计算机序列化消息的长度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> msgLen = calMsgLength(bodyLength, topicLength, propertiesLength);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exceeds the maximum message</span></span><br><span class="line">    <span class="keyword">if</span> (msgLen &gt; <span class="keyword">this</span>.maxMessageSize) &#123;</span><br><span class="line">        CommitLog.log.warn(<span class="string">"message size exceeded, msg total size: "</span> + msgLen + <span class="string">", msg body size: "</span> + bodyLength</span><br><span class="line">            + <span class="string">", maxMessageSize: "</span> + <span class="keyword">this</span>.maxMessageSize);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果空间不足，magic code设置成-626843481,然后剩余字节随机，保证所有文件大小都是FileSize</span></span><br><span class="line">    <span class="keyword">if</span> ((msgLen + END_FILE_MIN_BLANK_LENGTH) &gt; maxBlank) &#123;</span><br><span class="line">        <span class="keyword">this</span>.resetByteBuffer(<span class="keyword">this</span>.msgStoreItemMemory, maxBlank);</span><br><span class="line">        <span class="comment">// 1 TOTALSIZE</span></span><br><span class="line">        <span class="keyword">this</span>.msgStoreItemMemory.putInt(maxBlank);</span><br><span class="line">        <span class="comment">// 2 MAGICCODE</span></span><br><span class="line">        <span class="keyword">this</span>.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);</span><br><span class="line">        <span class="comment">// 3 The remaining space may be any value</span></span><br><span class="line">        <span class="comment">// Here the length of the specially set maxBlank</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</span><br><span class="line">        byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, maxBlank);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),</span><br><span class="line">            queueOffset, CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() - beginTimeMills);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看到这里，CommitLog就已经被存入到ByteBuf里啦，等待被flush到文件里！！！！</p>
<h1 id="ConsumeQueue"><a href="#ConsumeQueue" class="headerlink" title="ConsumeQueue"></a>ConsumeQueue</h1><p>上面我们看到消息被放到了CommitLog中，但是consumer在消费消息的时候是按照topic+queue的维度来拉取消息的。为了方便读取，<code>MessageStore</code>将<code>CommitLog</code>中消息的offset按照topic+queueId划分后，存储到不同的文件中，这就是<code>ConsumeQueue</code>。</p>
<p>在上面MessageStore启动的时候，我们看到他会启动一个服务<code>ReputMessageService</code>将CommitLog中的消息按照topic+queueId划分后，存储到不同的ConsumerQueue中，所以我们也从<code>org.apache.rocketmq.store.DefaultMessageStore.ReputMessageService</code>开始看，既然是一个线程，所以我们首先会找到他的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">this</span>.doReput();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                DefaultMessageStore.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 从上面可以看到主要在执行doReput方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断commitLog的maxOffset是否比上次读取的offset大，大就代表了有新的消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">boolean</span> doNext = <span class="keyword">true</span>; <span class="keyword">this</span>.isCommitLogAvailable() &amp;&amp; doNext; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().isDuplicationEnable()</span><br><span class="line">                &amp;&amp; <span class="keyword">this</span>.reputFromOffset &gt;= DefaultMessageStore.<span class="keyword">this</span>.getConfirmOffset()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从上次的结束offset开始读取commitLog文件中的消息</span></span><br><span class="line">            SelectMappedBufferResult result = DefaultMessageStore.<span class="keyword">this</span>.commitLog.getData(reputFromOffset);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.reputFromOffset = result.getStartOffset();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> readSize = <span class="number">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</span><br><span class="line">                        <span class="comment">// 检查message数据完整性并封装成DispatchRequest</span></span><br><span class="line">                        DispatchRequest dispatchRequest =</span><br><span class="line">                            DefaultMessageStore.<span class="keyword">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">int</span> size = dispatchRequest.getMsgSize();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (dispatchRequest.isSuccess()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">// 分发消息到CommitLogDispatcher</span></span><br><span class="line">                                DefaultMessageStore.<span class="keyword">this</span>.doDispatch(dispatchRequest);</span><br><span class="line">                                <span class="comment">// 当Broker为Master的时候，分发消息到MessageArrivingListener,唤醒等待的PullReqeust接收消息</span></span><br><span class="line">                                <span class="keyword">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getBrokerRole()</span><br><span class="line">                                    &amp;&amp; DefaultMessageStore.<span class="keyword">this</span>.brokerConfig.isLongPollingEnable()) &#123;</span><br><span class="line">                                    DefaultMessageStore.<span class="keyword">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</span><br><span class="line">                                        dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class="number">1</span>,</span><br><span class="line">                                        dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),</span><br><span class="line">                                        dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 更新最新reput的offset</span></span><br><span class="line">                                <span class="keyword">this</span>.reputFromOffset += size;</span><br><span class="line">                                readSize += size;</span><br><span class="line">                                <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE) &#123;</span><br><span class="line">                                    DefaultMessageStore.<span class="keyword">this</span>.storeStatsService</span><br><span class="line">                                        .getSinglePutMessageTopicTimesTotal(dispatchRequest.getTopic()).incrementAndGet();</span><br><span class="line">                                    DefaultMessageStore.<span class="keyword">this</span>.storeStatsService</span><br><span class="line">                                        .getSinglePutMessageTopicSizeTotal(dispatchRequest.getTopic())</span><br><span class="line">                                        .addAndGet(dispatchRequest.getMsgSize());</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">// 如果读到文件结尾，则切换到新文件</span></span><br><span class="line">                                <span class="keyword">this</span>.reputFromOffset = DefaultMessageStore.<span class="keyword">this</span>.commitLog.rollNextFile(<span class="keyword">this</span>.reputFromOffset);</span><br><span class="line">                                readSize = result.getSize();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dispatchRequest.isSuccess()) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                log.error(<span class="string">"[BUG]read total count not equals msg total size. reputFromOffset=&#123;&#125;"</span>, reputFromOffset);</span><br><span class="line">                                <span class="keyword">this</span>.reputFromOffset += size;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                doNext = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.brokerConfig.getBrokerId() == MixAll.MASTER_ID) &#123;</span><br><span class="line">                                    log.error(<span class="string">"[BUG]the master dispatch message to consume queue error, COMMITLOG OFFSET: &#123;&#125;"</span>,</span><br><span class="line">                                        <span class="keyword">this</span>.reputFromOffset);</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">this</span>.reputFromOffset += result.getSize() - readSize;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放bytebuff，避免内存泄漏</span></span><br><span class="line">                    result.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                doNext = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面我们看到了消息被分发到了CommitLogDispatcher，这个是啥？找到<code>DefaultMessageStore#doDispatch()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(DispatchRequest req)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (CommitLogDispatcher dispatcher : <span class="keyword">this</span>.dispatcherList) &#123;</span><br><span class="line">          dispatcher.dispatch(req);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;CommitLogDispatcher&gt; dispatcherList;</span><br></pre></td></tr></table></figure>
<p>从上面看到是DefaultMessageStore的集合成员变量，那么这个集合是什么时候生成的呢？</p>
<p>我们在构造DefaultMessageStore会往里面添加两个CommitLogDispatcher，我们定位到DefaultMessageStore的构造函数，省略无关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.dispatcherList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">// consumeQueue构建Dispatcher</span></span><br><span class="line"><span class="keyword">this</span>.dispatcherList.addLast(<span class="keyword">new</span> CommitLogDispatcherBuildConsumeQueue());</span><br><span class="line"><span class="comment">// IndexFile构建Dispatcher</span></span><br><span class="line"><span class="keyword">this</span>.dispatcherList.addLast(<span class="keyword">new</span> CommitLogDispatcherBuildIndex());</span><br></pre></td></tr></table></figure>
<p>不知道大家还有没有印象，其实在说<a href="[http://todorex.com/2019/06/19/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Broker%E5%90%AF%E5%8A%A8/](http://todorex.com/2019/06/19/RocketMQ源码/RocketMQ源码分析——Broker启动/">Broker初始化</a>)的时候也提到过。我们省略下无关代码，再看一遍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"> 		<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 消息存取的核心接口初始化</span></span><br><span class="line">            <span class="keyword">this</span>.messageStore =</span><br><span class="line">                <span class="keyword">new</span> DefaultMessageStore(<span class="keyword">this</span>.messageStoreConfig, <span class="keyword">this</span>.brokerStatsManager, <span class="keyword">this</span>.messageArrivingListener,</span><br><span class="line">                    <span class="keyword">this</span>.brokerConfig);</span><br><span class="line">            <span class="comment">// 添加消息分发器，分发到布隆过滤器</span></span><br><span class="line">            <span class="keyword">this</span>.messageStore.getDispatcherList().addFirst(<span class="keyword">new</span> CommitLogDispatcherCalcBitMap(<span class="keyword">this</span>.brokerConfig, <span class="keyword">this</span>.consumerFilterManager));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">            log.error(<span class="string">"Failed to initialize"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们只分析<code>org.apache.rocketmq.store.DefaultMessageStore.CommitLogDispatcherBuildConsumeQueue</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildConsumeQueue</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(request.getSysFlag());</span><br><span class="line">          <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">              <span class="comment">// 非事务消息</span></span><br><span class="line">              <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">              <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                  <span class="comment">// 放位置offset信息</span></span><br><span class="line">                  DefaultMessageStore.<span class="keyword">this</span>.putMessagePositionInfo(request);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">              <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putMessagePositionInfo</span><span class="params">(DispatchRequest dispatchRequest)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 找到对应的ConsumeQueue，没有就创建一个新的MappedFile文件</span></span><br><span class="line">      ConsumeQueue cq = <span class="keyword">this</span>.findConsumeQueue(dispatchRequest.getTopic(), dispatchRequest.getQueueId());</span><br><span class="line">      cq.putMessagePositionInfoWrapper(dispatchRequest);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.store.ConsumeQueue</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putMessagePositionInfoWrapper</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 写入重试次数，最多30次</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> maxRetries = <span class="number">30</span>;</span><br><span class="line">      <span class="comment">// 判断CQ是否是可写的</span></span><br><span class="line">      <span class="keyword">boolean</span> canWrite = <span class="keyword">this</span>.defaultMessageStore.getRunningFlags().isCQWriteable();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxRetries &amp;&amp; canWrite; i++) &#123;</span><br><span class="line">          <span class="comment">// 拿到消息的Tag</span></span><br><span class="line">          <span class="keyword">long</span> tagsCode = request.getTagsCode();</span><br><span class="line">          <span class="keyword">if</span> (isExtWriteEnable()) &#123;</span><br><span class="line">              <span class="comment">// 如果需要写ext文件，则将消息的tagsCode写入，用于消息过滤，后面有机会再说</span></span><br><span class="line">              ConsumeQueueExt.CqExtUnit cqExtUnit = <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit();</span><br><span class="line">              cqExtUnit.setFilterBitMap(request.getBitMap());</span><br><span class="line">              cqExtUnit.setMsgStoreTime(request.getStoreTimestamp());</span><br><span class="line">              cqExtUnit.setTagsCode(request.getTagsCode());</span><br><span class="line"></span><br><span class="line">              <span class="keyword">long</span> extAddr = <span class="keyword">this</span>.consumeQueueExt.put(cqExtUnit);</span><br><span class="line">              <span class="keyword">if</span> (isExtAddr(extAddr)) &#123;</span><br><span class="line">                  tagsCode = extAddr;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  log.warn(<span class="string">"Save consume queue extend fail, So just save tagsCode! &#123;&#125;, topic:&#123;&#125;, queueId:&#123;&#125;, offset:&#123;&#125;"</span>, cqExtUnit,</span><br><span class="line">                      topic, queueId, request.getCommitLogOffset());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 写入CQ文件</span></span><br><span class="line">          <span class="keyword">boolean</span> result = <span class="keyword">this</span>.putMessagePositionInfo(request.getCommitLogOffset(),</span><br><span class="line">              request.getMsgSize(), tagsCode, request.getConsumeQueueOffset());</span><br><span class="line">          <span class="keyword">if</span> (result) &#123;</span><br><span class="line">              <span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setLogicsMsgTimestamp(request.getStoreTimestamp());</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">              log.warn(<span class="string">"[BUG]put commit log position info to "</span> + topic + <span class="string">":"</span> + queueId + <span class="string">" "</span> + request.getCommitLogOffset()</span><br><span class="line">                  + <span class="string">" failed, retry "</span> + i + <span class="string">" times"</span>);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  log.warn(<span class="string">""</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">      log.error(<span class="string">"[BUG]consume queue can not write, &#123;&#125; &#123;&#125;"</span>, <span class="keyword">this</span>.topic, <span class="keyword">this</span>.queueId);</span><br><span class="line">      <span class="keyword">this</span>.defaultMessageStore.getRunningFlags().makeLogicsQueueError();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">putMessagePositionInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">int</span> size, <span class="keyword">final</span> <span class="keyword">long</span> tagsCode,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">long</span> cqOffset)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (offset &lt;= <span class="keyword">this</span>.maxPhysicOffset) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 结构可以参考数据结构中图</span></span><br><span class="line">      <span class="keyword">this</span>.byteBufferIndex.flip();</span><br><span class="line">      <span class="comment">// 一个CQUnit的大小是固定的20字节</span></span><br><span class="line">      <span class="keyword">this</span>.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);</span><br><span class="line">      <span class="keyword">this</span>.byteBufferIndex.putLong(offset);</span><br><span class="line">      <span class="keyword">this</span>.byteBufferIndex.putInt(size);</span><br><span class="line">      <span class="keyword">this</span>.byteBufferIndex.putLong(tagsCode);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> expectLogicOffset = cqOffset * CQ_STORE_UNIT_SIZE;</span><br><span class="line">      <span class="comment">// 获取最后一个MappedFile, 没有就创建</span></span><br><span class="line">      MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(expectLogicOffset);</span><br><span class="line">      <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mappedFile.isFirstCreateInQueue() &amp;&amp; cqOffset != <span class="number">0</span> &amp;&amp; mappedFile.getWrotePosition() == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">this</span>.minLogicOffset = expectLogicOffset;</span><br><span class="line">              <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(expectLogicOffset);</span><br><span class="line">              <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(expectLogicOffset);</span><br><span class="line">              <span class="keyword">this</span>.fillPreBlank(mappedFile, expectLogicOffset);</span><br><span class="line">              log.info(<span class="string">"fill pre blank space "</span> + mappedFile.getFileName() + <span class="string">" "</span> + expectLogicOffset + <span class="string">" "</span></span><br><span class="line">                  + mappedFile.getWrotePosition());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (cqOffset != <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">long</span> currentLogicOffset = mappedFile.getWrotePosition() + mappedFile.getFileFromOffset();</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">          <span class="keyword">this</span>.maxPhysicOffset = offset;</span><br><span class="line">          <span class="comment">// CQUnit写入文件中, 使用filechannel写,同步写</span></span><br><span class="line">          <span class="keyword">return</span> mappedFile.appendMessage(<span class="keyword">this</span>.byteBufferIndex.array());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>看到这里，ConsumeQueue就被写入到文件中了！！！！</p>
<h1 id="IndexFile"><a href="#IndexFile" class="headerlink" title="IndexFile"></a>IndexFile</h1><p><code>MessageStore</code>中存储的消息除了通过<code>ConsumeQueue</code>提供给consumer消费之外，还支持通过MessageID或者MessageKey来查询消息。使用ID查询时，因为ID就是用broker+offset生成的，所以很容易就找到对应的<code>commitLog</code>文件来读取消息。对于用MessageKey来查询消息，<code>MessageStore</code>通过构建一个index来提高读取速度。</p>
<p>在上面的CommitLogDispatcher链表中，我们还看到一个CommitLogDispatcher——<code>CommitLogDispatcherBuildIndex</code></p>
<p>他就是用来创建IndexFile的，我们也将从那里入手：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildIndex</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.messageStoreConfig.isMessageIndexEnable()) &#123;</span><br><span class="line">              DefaultMessageStore.<span class="keyword">this</span>.indexService.buildIndex(request);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.store.index.IndexService</span></span><br><span class="line"><span class="comment">// 写入indexFile</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildIndex</span><span class="params">(DispatchRequest req)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 获取或者新建当前可写入的index file, 默认重试3次</span></span><br><span class="line">      IndexFile indexFile = retryGetAndCreateIndexFile();</span><br><span class="line">      <span class="keyword">if</span> (indexFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 获取当前indexFile中记录的最大offset</span></span><br><span class="line">          <span class="keyword">long</span> endPhyOffset = indexFile.getEndPhyOffset();</span><br><span class="line">          DispatchRequest msg = req;</span><br><span class="line">          String topic = msg.getTopic();</span><br><span class="line">          String keys = msg.getKeys();</span><br><span class="line">          <span class="keyword">if</span> (msg.getCommitLogOffset() &lt; endPhyOffset) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 过滤回滚消息</span></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">          <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">              <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">              <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">              <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 单条消息</span></span><br><span class="line">          <span class="keyword">if</span> (req.getUniqKey() != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 写入index</span></span><br><span class="line">              indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey()));</span><br><span class="line">              <span class="keyword">if</span> (indexFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  log.error(<span class="string">"putKey error commitlog &#123;&#125; uniqkey &#123;&#125;"</span>, req.getCommitLogOffset(), req.getUniqKey());</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 多条消息，循环写入index</span></span><br><span class="line">          <span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; keys.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              String[] keyset = keys.split(MessageConst.KEY_SEPARATOR);</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyset.length; i++) &#123;</span><br><span class="line">                  String key = keyset[i];</span><br><span class="line">                  <span class="keyword">if</span> (key.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                      indexFile = putKey(indexFile, msg, buildKey(topic, key));</span><br><span class="line">                      <span class="keyword">if</span> (indexFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">                          log.error(<span class="string">"putKey error commitlog &#123;&#125; uniqkey &#123;&#125;"</span>, req.getCommitLogOffset(), req.getUniqKey());</span><br><span class="line">                          <span class="keyword">return</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.error(<span class="string">"build index error, stop building index"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 接着看如何将MessageKey写入IndexFile</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> IndexFile <span class="title">putKey</span><span class="params">(IndexFile indexFile, DispatchRequest msg, String idxKey)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 重试写入</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">boolean</span> ok = indexFile.putKey(idxKey, msg.getCommitLogOffset(), msg.getStoreTimestamp()); !ok; ) &#123;</span><br><span class="line">          log.warn(<span class="string">"Index file ["</span> + indexFile.getFileName() + <span class="string">"] is full, trying to create another one"</span>);</span><br><span class="line"></span><br><span class="line">          indexFile = retryGetAndCreateIndexFile();</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">null</span> == indexFile) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          ok = indexFile.putKey(idxKey, msg.getCommitLogOffset(), msg.getStoreTimestamp());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> indexFile;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.store.index.IndexFile</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putKey</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">long</span> phyOffset, <span class="keyword">final</span> <span class="keyword">long</span> storeTimestamp)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 判断indexFile是否已满，已满返回失败</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getIndexCount() &lt; <span class="keyword">this</span>.indexNum) &#123;</span><br><span class="line">          <span class="comment">// 计算key的hashCode(非负)，调用的java String的hashcode方法</span></span><br><span class="line">          <span class="keyword">int</span> keyHash = indexKeyHashMethod(key);</span><br><span class="line">          <span class="comment">// 计算slot位置（第几个）</span></span><br><span class="line">          <span class="keyword">int</span> slotPos = keyHash % <span class="keyword">this</span>.hashSlotNum;</span><br><span class="line">          <span class="comment">// 计算slot的数据存储位置</span></span><br><span class="line">          <span class="keyword">int</span> absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize;</span><br><span class="line"></span><br><span class="line">          FileLock fileLock = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 之前说过slot+index类似一个hashmap，slot类似于hashmap的数组</span></span><br><span class="line">              <span class="comment">// 如果存在hash冲突，获取这个slot存的前一个index的计数，如果没有则值为0</span></span><br><span class="line">              <span class="keyword">int</span> slotValue = <span class="keyword">this</span>.mappedByteBuffer.getInt(absSlotPos);</span><br><span class="line">              <span class="keyword">if</span> (slotValue &lt;= invalidIndex || slotValue &gt; <span class="keyword">this</span>.indexHeader.getIndexCount()) &#123;</span><br><span class="line">                  slotValue = invalidIndex;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 计算当前msg的存储时间和第一条msg相差秒数</span></span><br><span class="line">              <span class="keyword">long</span> timeDiff = storeTimestamp - <span class="keyword">this</span>.indexHeader.getBeginTimestamp();</span><br><span class="line"></span><br><span class="line">              timeDiff = timeDiff / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getBeginTimestamp() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  timeDiff = <span class="number">0</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                  timeDiff = Integer.MAX_VALUE;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                  timeDiff = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 获取该条index实际存储position</span></span><br><span class="line">              <span class="keyword">int</span> absIndexPos =</span><br><span class="line">                  IndexHeader.INDEX_HEADER_SIZE + <span class="keyword">this</span>.hashSlotNum * hashSlotSize</span><br><span class="line">                      + <span class="keyword">this</span>.indexHeader.getIndexCount() * indexSize;</span><br><span class="line">              <span class="comment">// 生成一个index的unit内容(看图)</span></span><br><span class="line">              <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos, keyHash);</span><br><span class="line">              <span class="keyword">this</span>.mappedByteBuffer.putLong(absIndexPos + <span class="number">4</span>, phyOffset);</span><br><span class="line">              <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span>, (<span class="keyword">int</span>) timeDiff);</span><br><span class="line">              <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span> + <span class="number">4</span>, slotValue);</span><br><span class="line">              <span class="comment">// 更新slot中的值为本条消息的index(因为rocketmq觉得新消息被查询的机会更大)</span></span><br><span class="line">              <span class="keyword">this</span>.mappedByteBuffer.putInt(absSlotPos, <span class="keyword">this</span>.indexHeader.getIndexCount());</span><br><span class="line">              <span class="comment">// 如果是第一条消息，更新header中的起始offset和起始时间</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getIndexCount() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.indexHeader.setBeginPhyOffset(phyOffset);</span><br><span class="line">                  <span class="keyword">this</span>.indexHeader.setBeginTimestamp(storeTimestamp);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 更新header中的计数</span></span><br><span class="line">              <span class="keyword">this</span>.indexHeader.incHashSlotCount();</span><br><span class="line">              <span class="keyword">this</span>.indexHeader.incIndexCount();</span><br><span class="line">              <span class="keyword">this</span>.indexHeader.setEndPhyOffset(phyOffset);</span><br><span class="line">              <span class="keyword">this</span>.indexHeader.setEndTimestamp(storeTimestamp);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              log.error(<span class="string">"putKey exception, Key: "</span> + key + <span class="string">" KeyHashCode: "</span> + key.hashCode(), e);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (fileLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      fileLock.release();</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                      log.error(<span class="string">"Failed to release the lock"</span>, e);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.warn(<span class="string">"Over index file capacity: index count = "</span> + <span class="keyword">this</span>.indexHeader.getIndexCount()</span><br><span class="line">              + <span class="string">"; index max num = "</span> + <span class="keyword">this</span>.indexNum);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>看到这里，IndexFile就已经被存入到ByteBuf里啦，等待被flush到文件里！！！！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/qq_27529917/article/details/79595395" target="_blank" rel="noopener">RocketMQ消息存储流程图及数据结构图</a></li>
<li><a href="https://www.jianshu.com/p/7833f5c28ec7" target="_blank" rel="noopener">RocketMQ源码解析(九)-Broker#消息存储ConsumeQueue</a></li>
<li><a href="https://www.jianshu.com/p/606d4b77d504" target="_blank" rel="noopener">RocketMQ源码解析(十)-Broker#消息存储Index</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：消息存储对于一个消息队列来说是肯定要有的，在RocketMQ中，Broker将消息存储抽象成&lt;code&gt;MessageStore&lt;/code&gt;接口，我们也将从这里入手~
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——Broker启动</title>
    <link href="http://bestlixiang.site/2019/06/19/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Broker%E5%90%AF%E5%8A%A8/"/>
    <id>http://bestlixiang.site/2019/06/19/RocketMQ源码/RocketMQ源码分析——Broker启动/</id>
    <published>2019-06-19T11:46:01.000Z</published>
    <updated>2019-06-19T11:46:10.269Z</updated>
    
    <content type="html"><![CDATA[<p>引：前面讲了NameServer，Producer，Consumer，现在终于轮到Broker了，对于一个消息队列来说，Broker是当仁不让的核心~<a id="more"></a></p>
<h1 id="五大作用"><a href="#五大作用" class="headerlink" title="五大作用"></a>五大作用</h1><ul>
<li>存储消息</li>
<li>接收生产者提交的消息</li>
<li>回复consumer的消息拉取请求</li>
<li>主从节点间同步数据保证高可用</li>
<li>提供简单的api来查询磁盘上的临时数据</li>
</ul>
<p>之后我们也将从上面的作用来进行源码的探索！</p>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>真实使用当然是用命令行去部署，这里为了看源码，我们把<strong>环境搭建</strong>那篇文章的例子搬过来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 设置版本号，很关键，不然topic创建不成功</span></span><br><span class="line">      System.setProperty(RemotingCommand.REMOTING_VERSION_KEY, Integer.toString(MQVersion.CURRENT_VERSION));</span><br><span class="line">      <span class="keyword">final</span> BrokerConfig brokerConfig = <span class="keyword">new</span> BrokerConfig();</span><br><span class="line">      brokerConfig.setBrokerName(<span class="string">"broker-a"</span>);</span><br><span class="line">      brokerConfig.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line"></span><br><span class="line">      BrokerController brokerController = <span class="keyword">new</span> BrokerController(</span><br><span class="line">              brokerConfig,</span><br><span class="line">              <span class="keyword">new</span> NettyServerConfig(),</span><br><span class="line">              <span class="keyword">new</span> NettyClientConfig(),</span><br><span class="line">              <span class="keyword">new</span> MessageStoreConfig());</span><br><span class="line">      assertThat(brokerController.initialize());</span><br><span class="line">      brokerController.start();</span><br><span class="line">      <span class="comment">// 不让主方法结束</span></span><br><span class="line">      Thread.sleep(DateUtils.MILLIS_PER_DAY);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Broker启动"><a href="#Broker启动" class="headerlink" title="Broker启动"></a>Broker启动</h1><p>从上面的例子可以看出Broker启动实质就是<code>org.apache.rocketmq.broker.BrokerController</code>完成初始化和启动的过程。</p>
<h2 id="BrokerController初始化"><a href="#BrokerController初始化" class="headerlink" title="BrokerController初始化"></a>BrokerController初始化</h2><p>我们看到<code>org.apache.rocketmq.broker.BrokerController#initialize()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 从持久化文件中加载数据到内存中</span></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">this</span>.topicConfigManager.load();</span><br><span class="line"></span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.consumerOffsetManager.load();</span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.subscriptionGroupManager.load();</span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.consumerFilterManager.load();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 消息存取的核心接口初始化</span></span><br><span class="line">            <span class="keyword">this</span>.messageStore =</span><br><span class="line">                <span class="keyword">new</span> DefaultMessageStore(<span class="keyword">this</span>.messageStoreConfig, <span class="keyword">this</span>.brokerStatsManager, <span class="keyword">this</span>.messageArrivingListener,</span><br><span class="line">                    <span class="keyword">this</span>.brokerConfig);</span><br><span class="line">            <span class="comment">// messageStore的指标统计类，提供最近一天的消息吞吐量的统计数据</span></span><br><span class="line">            <span class="keyword">this</span>.brokerStats = <span class="keyword">new</span> BrokerStats((DefaultMessageStore) <span class="keyword">this</span>.messageStore);</span><br><span class="line">            <span class="comment">//load plugin</span></span><br><span class="line">            MessageStorePluginContext context = <span class="keyword">new</span> MessageStorePluginContext(messageStoreConfig, brokerStatsManager, messageArrivingListener, brokerConfig);</span><br><span class="line">            <span class="keyword">this</span>.messageStore = MessageStoreFactory.build(context, <span class="keyword">this</span>.messageStore);</span><br><span class="line">            <span class="comment">// 添加消息分发器，分发到布隆过滤器</span></span><br><span class="line">            <span class="keyword">this</span>.messageStore.getDispatcherList().addFirst(<span class="keyword">new</span> CommitLogDispatcherCalcBitMap(<span class="keyword">this</span>.brokerConfig, <span class="keyword">this</span>.consumerFilterManager));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">            log.error(<span class="string">"Failed to initialize"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// messageStore加载内存映射文件，commit log文件，consumer queue文件，index文件</span></span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.messageStore.load();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="comment">// 3. 初始化Netty Server</span></span><br><span class="line">        <span class="keyword">this</span>.remotingServer = <span class="keyword">new</span> NettyRemotingServer(<span class="keyword">this</span>.nettyServerConfig, <span class="keyword">this</span>.clientHousekeepingService);</span><br><span class="line">        NettyServerConfig fastConfig = (NettyServerConfig) <span class="keyword">this</span>.nettyServerConfig.clone();</span><br><span class="line">        <span class="comment">// 初始化VIP通道 Netty Server</span></span><br><span class="line">        fastConfig.setListenPort(nettyServerConfig.getListenPort() - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">this</span>.fastRemotingServer = <span class="keyword">new</span> NettyRemotingServer(fastConfig, <span class="keyword">this</span>.clientHousekeepingService);</span><br><span class="line">        <span class="comment">// 初始化一系列客户端指令执行的线程池，Netty处理的优化</span></span><br><span class="line">        <span class="keyword">this</span>.sendMessageExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getSendMessageThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getSendMessageThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.sendThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"SendMessageThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.pullMessageExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getPullMessageThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getPullMessageThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.pullThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"PullMessageThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.queryMessageExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getQueryMessageThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getQueryMessageThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.queryThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"QueryMessageThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.adminBrokerExecutor =</span><br><span class="line">            Executors.newFixedThreadPool(<span class="keyword">this</span>.brokerConfig.getAdminBrokerThreadPoolNums(), <span class="keyword">new</span> ThreadFactoryImpl(</span><br><span class="line">                <span class="string">"AdminBrokerThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.clientManageExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getClientManageThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getClientManageThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.clientManagerThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"ClientManageThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.heartbeatExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getHeartbeatThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getHeartbeatThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.heartbeatThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"HeartbeatThread_"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.endTransactionExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getEndTransactionThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getEndTransactionThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.endTransactionThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"EndTransactionThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.consumerManageExecutor =</span><br><span class="line">            Executors.newFixedThreadPool(<span class="keyword">this</span>.brokerConfig.getConsumerManageThreadPoolNums(), <span class="keyword">new</span> ThreadFactoryImpl(</span><br><span class="line">                <span class="string">"ConsumerManageThread_"</span>));</span><br><span class="line">        <span class="comment">// 将这些线程池添加到Netty Pipeline中</span></span><br><span class="line">        <span class="keyword">this</span>.registerProcessor();</span><br><span class="line">        <span class="comment">// 4. 打印broker的消息吞吐信息到日志文件定时任务，每天0点记录一次</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> initialDelay = UtilAll.computNextMorningTimeMillis() - System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> period = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>;</span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.getBrokerStats().record();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"schedule record error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, initialDelay, period, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="comment">//  记录consumerOffet到文件定时任务,默认5秒一次</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.consumerOffsetManager.persist();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"schedule persist consumerOffset error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="keyword">this</span>.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="comment">// 记录consumer filter到文件中定时任务,10秒一次</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.consumerFilterManager.persist();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"schedule persist consumer filter error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="comment">// 定时检查consumer的消费记录，如果延时太大,则disable consumer,不再往这个consumer投递消息</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.protectBroker();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"protectBroker error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, <span class="number">3</span>, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 打印当前Queue size日志</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.printWaterMark();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"printWaterMark error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">10</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 打印dispatch落后情况</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">"dispatch behind commit log &#123;&#125; bytes"</span>, BrokerController.<span class="keyword">this</span>.getMessageStore().dispatchBehindBytes());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"schedule dispatchBehindBytes error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="comment">// 定时更新nameserv address信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.brokerConfig.getNamesrvAddr() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.brokerOuterAPI.updateNameServerAddressList(<span class="keyword">this</span>.brokerConfig.getNamesrvAddr());</span><br><span class="line">            log.info(<span class="string">"Set user specified name server address: &#123;&#125;"</span>, <span class="keyword">this</span>.brokerConfig.getNamesrvAddr());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.brokerConfig.isFetchNamesrvAddrByAddressServer()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        BrokerController.<span class="keyword">this</span>.brokerOuterAPI.fetchNameServerAddr();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        log.error(<span class="string">"ScheduledTask fetchNameServerAddr exception"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是broker是slave，启动定时任务，每分钟从master同步配置和offset</span></span><br><span class="line">        <span class="keyword">if</span> (BrokerRole.SLAVE == <span class="keyword">this</span>.messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.messageStoreConfig.getHaMasterAddress() != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageStoreConfig.getHaMasterAddress().length() &gt;= <span class="number">6</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.messageStore.updateHaMasterAddress(<span class="keyword">this</span>.messageStoreConfig.getHaMasterAddress());</span><br><span class="line">                <span class="keyword">this</span>.updateMasterHAServerAddrPeriodically = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.updateMasterHAServerAddrPeriodically = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        BrokerController.<span class="keyword">this</span>.slaveSynchronize.syncAll();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        log.error(<span class="string">"ScheduledTask syncAll slave exception"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果broker是master，定时打印slave延时情况</span></span><br><span class="line">            <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        BrokerController.<span class="keyword">this</span>.printMasterAndSlaveDiff();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        log.error(<span class="string">"schedule printMasterAndSlaveDiff error."</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 初始化事务消息service</span></span><br><span class="line">        initialTransaction();</span><br><span class="line">        initialAcl();</span><br><span class="line">        initialRpcHooks();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑还是非常简单的，一看就知道他在干什么~</p>
<h2 id="BrokerController启动"><a href="#BrokerController启动" class="headerlink" title="BrokerController启动"></a>BrokerController启动</h2><p>当BrokerController初始化完成之后，我们看<code>org.apache.rocketmq.broker.BrokerController#start()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 启动消息存储服务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.messageStore != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.messageStore.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动Netty Server接收请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.remotingServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.remotingServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动VIP Channel Netty Server</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fastRemotingServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fastRemotingServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动TLS签名文件检测服务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fileWatchService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fileWatchService.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动Broker的Netty Client</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerOuterAPI != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerOuterAPI.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动PushConsumer的请求 Hold 服务 (后面会展开)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.pullRequestHoldService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.pullRequestHoldService.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监控客户端连接，定时检查Producer，Consumer和Filter是否长时间未收到心跳</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.clientHousekeepingService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.clientHousekeepingService.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动Filter Server</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.filterServerManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.filterServerManager.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册Broker到Namesrv</span></span><br><span class="line">    <span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时向Namesrv发心跳，如果有变化则同步Broker信息</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BrokerController.<span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, brokerConfig.isForceRegister());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"registerBrokerAll Exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">10</span>, Math.max(<span class="number">10000</span>, Math.min(brokerConfig.getRegisterNameServerPeriod(), <span class="number">60000</span>)), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerStatsManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerStatsManager.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动BrokerFastFailure服务，定时清理长时间未执行的客户端请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerFastFailure != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerFastFailure.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是Master，开启事务消息检查</span></span><br><span class="line">    <span class="keyword">if</span> (BrokerRole.SLAVE != messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.transactionalMessageCheckService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"Start transaction service!"</span>);</span><br><span class="line">            <span class="keyword">this</span>.transactionalMessageCheckService.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从整个过程来看还是比较简单的，水文一篇，但是后面会继续分析Broker的各个作用的实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：前面讲了NameServer，Producer，Consumer，现在终于轮到Broker了，对于一个消息队列来说，Broker是当仁不让的核心~
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——Consumer</title>
    <link href="http://bestlixiang.site/2019/06/18/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Consumer/"/>
    <id>http://bestlixiang.site/2019/06/18/RocketMQ源码/RocketMQ源码分析——Consumer/</id>
    <published>2019-06-18T11:43:10.000Z</published>
    <updated>2019-06-18T11:43:32.676Z</updated>
    
    <content type="html"><![CDATA[<p>引：当消息达到Broker之后，就等着Consumer去consume了呀~<a id="more"></a></p>
<h1 id="消费方式"><a href="#消费方式" class="headerlink" title="消费方式"></a>消费方式</h1><ul>
<li><p>PullConsumer：消费者主动调用pull方法来获取消息，没有则返回</p>
</li>
<li><p>PushConsumer：虽然名为Push，但是是消费者主动循环发送Pull请求到broker，如果没有消息，broker会把请求放入等待队列，新消息到达后返回response</p>
</li>
</ul>
<p>所以本质上，两种方式都是通过消费者主动Pull来实现的。</p>
<h1 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h1><p>Consumer的消费模式在初始化consumer时设置的，主要有下面两种：</p>
<ul>
<li>Broadcast模式：消息会发送给group内所有consumer</li>
<li>Cluster模式：每条消息只会发送给group内的一个consumer，但是Cluster模式的支持消费失败重发，从而保证消息一定被消费</li>
</ul>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>这次我们主要看看PushConsumer，以Cluster模式消费的源码是如何实现的，因为这种方式相对来说是最复杂的一种。例子其实也是在之前<strong>环境搭建</strong>那边文章中例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">				<span class="comment">// 指定消费者组的PushConsumer</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_4"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指明Namesrv</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定消费开始位置</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 订阅Topic</span></span><br><span class="line">        consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 指定回调逻辑</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">"%s Receive New Messages: %s %n"</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">			  <span class="comment">// 启动</span></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Consumer启动"><a href="#Consumer启动" class="headerlink" title="Consumer启动"></a>Consumer启动</h1><p>之前其实在Producer分析里面带过Consumer，所以逻辑也是类似的。</p>
<h2 id="DefaultMQPushConsumer初始化"><a href="#DefaultMQPushConsumer初始化" class="headerlink" title="DefaultMQPushConsumer初始化"></a>DefaultMQPushConsumer初始化</h2><p>和Producer一样包装了一个DefaultMQPushConsumerImpl，下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.consumer.DefaultMQPushConsumer</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">DefaultMQPushConsumer</span><span class="params">(<span class="keyword">final</span> String consumerGroup)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(consumerGroup, <span class="keyword">null</span>, <span class="keyword">new</span> AllocateMessageQueueAveragely());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultMQPushConsumer</span><span class="params">(<span class="keyword">final</span> String consumerGroup, RPCHook rpcHook,</span></span></span><br><span class="line"><span class="function"><span class="params">      AllocateMessageQueueStrategy allocateMessageQueueStrategy)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.consumerGroup = consumerGroup;</span><br><span class="line">      <span class="comment">// 默认平均分配</span></span><br><span class="line">      <span class="keyword">this</span>.allocateMessageQueueStrategy = allocateMessageQueueStrategy;</span><br><span class="line">      <span class="comment">// 构造实际类</span></span><br><span class="line">      defaultMQPushConsumerImpl = <span class="keyword">new</span> DefaultMQPushConsumerImpl(<span class="keyword">this</span>, rpcHook);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultMQPushConsumerImpl</span><span class="params">(DefaultMQPushConsumer defaultMQPushConsumer, RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.defaultMQPushConsumer = defaultMQPushConsumer;</span><br><span class="line">      <span class="keyword">this</span>.rpcHook = rpcHook;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="DefaultMQPushConsumer启动"><a href="#DefaultMQPushConsumer启动" class="headerlink" title="DefaultMQPushConsumer启动"></a>DefaultMQPushConsumer启动</h2><p>实质就是defaultMQPushConsumerImpl启动，下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"> 	<span class="comment">// org.apache.rocketmq.client.consumer.DefaultMQPushConsumer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">      <span class="comment">// 实质defaultMQPushConsumerImpl启动</span></span><br><span class="line">      <span class="keyword">this</span>.defaultMQPushConsumerImpl.start();</span><br><span class="line">		<span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">          <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">              log.info(<span class="string">"the consumer [&#123;&#125;] start beginning. messageModel=&#123;&#125;, isUnitMode=&#123;&#125;"</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(),</span><br><span class="line">                  <span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel(), <span class="keyword">this</span>.defaultMQPushConsumer.isUnitMode());</span><br><span class="line">              <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">              <span class="comment">// 基本参数检查</span></span><br><span class="line">              <span class="keyword">this</span>.checkConfig();</span><br><span class="line">              <span class="comment">// 将DefaultMQPushConsumer的订阅信息copy到RebalanceService中</span></span><br><span class="line">              <span class="comment">// 如果是cluster模式，如果订阅了topic,则自动订阅%RETRY%groupname，也加入到RebalanceService中</span></span><br><span class="line">              <span class="keyword">this</span>.copySubscription();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line">                  <span class="comment">// 如果InstanceName参数值为DEFAULT则修改为PID</span></span><br><span class="line">                  <span class="keyword">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 新建一个MQClientInstance,客户端管理类, 单例，一个进程中只有一个</span></span><br><span class="line">              <span class="comment">// 所有的i/o类操作由它管理，缓存客户端和topic信息，各种service，很重要</span></span><br><span class="line">              <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQPushConsumer, <span class="keyword">this</span>.rpcHook);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">this</span>.rebalanceImpl.setConsumerGroup(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">              <span class="keyword">this</span>.rebalanceImpl.setMessageModel(<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel());</span><br><span class="line">              <span class="keyword">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="keyword">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">              <span class="keyword">this</span>.rebalanceImpl.setmQClientFactory(<span class="keyword">this</span>.mQClientFactory);</span><br><span class="line">              <span class="comment">// PullRequest封装实现类，封装了和broker的通信接口</span></span><br><span class="line">              <span class="keyword">this</span>.pullAPIWrapper = <span class="keyword">new</span> PullAPIWrapper(</span><br><span class="line">                  mQClientFactory,</span><br><span class="line">                  <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">              <span class="comment">// 消息被客户端过滤时会回调的钩子</span></span><br><span class="line">              <span class="keyword">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// consumer客户端消费offset持久化</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.offsetStore = <span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore();</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">                      <span class="comment">// 广播消息本地持久化offset</span></span><br><span class="line">                      <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">                          <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> LocalFileOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="comment">// 集群模式broker持久化offset</span></span><br><span class="line">                      <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">                          <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> RemoteBrokerOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">default</span>:</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">this</span>.defaultMQPushConsumer.setOffsetStore(<span class="keyword">this</span>.offsetStore);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 如果是广播模式则从本地文件中load，如果是集群模式不做操作</span></span><br><span class="line">              <span class="keyword">this</span>.offsetStore.load();</span><br><span class="line">              <span class="comment">// 消息消费服务，顺序和并发消息逻辑不同,接收消息并调用listener消费，处理消费结果</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerOrderly) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.consumeOrderly = <span class="keyword">true</span>;</span><br><span class="line">                  <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                      <span class="keyword">new</span> ConsumeMessageOrderlyService(<span class="keyword">this</span>, (MessageListenerOrderly) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerConcurrently) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.consumeOrderly = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                      <span class="keyword">new</span> ConsumeMessageConcurrentlyService(<span class="keyword">this</span>, (MessageListenerConcurrently) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 启动等待处理消息服务（定时服务）</span></span><br><span class="line">              <span class="keyword">this</span>.consumeMessageService.start();</span><br><span class="line">              <span class="comment">// 注册Consumer</span></span><br><span class="line">              <span class="keyword">boolean</span> registerOK = mQClientFactory.registerConsumer(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="keyword">this</span>);</span><br><span class="line">              <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                  <span class="keyword">this</span>.consumeMessageService.shutdown();</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The consumer group["</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()</span><br><span class="line">                      + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                      <span class="keyword">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// mqClient启动</span></span><br><span class="line">              mQClientFactory.start();</span><br><span class="line">              log.info(<span class="string">"the consumer [&#123;&#125;] start OK."</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">              <span class="comment">// 改变状态</span></span><br><span class="line">              <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> RUNNING:</span><br><span class="line">          <span class="keyword">case</span> START_FAILED:</span><br><span class="line">          <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The PushConsumer service state not OK, maybe started once, "</span></span><br><span class="line">                  + <span class="keyword">this</span>.serviceState</span><br><span class="line">                  + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                  <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新Topic信息</span></span><br><span class="line">      <span class="keyword">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line">      <span class="keyword">this</span>.mQClientFactory.checkClientInBroker();</span><br><span class="line">      <span class="comment">// 发送心跳</span></span><br><span class="line">      <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">      <span class="comment">// 做一次rebalance</span></span><br><span class="line">      <span class="keyword">this</span>.mQClientFactory.rebalanceImmediately();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个点说一下：</p>
<ul>
<li>%RETRY% +groupname：如果consumer是cluster模式，并且订阅了TopicA的消息，那客户端会自动订阅%RETRY% + +groupname。我们知道consumer消费消息处理失败的话，broker是会延时一定的时间重新推送的，重新推送不是跟其它新消息一起过来，而是通过单独的%RETRY%过来。</li>
<li>RebalanceService分配策略：Rebalance支持多种分配策略，比如平均分配、一致性Hash等，默认采用平均分配策略(AVG)。</li>
</ul>
<h2 id="MQClientInstance启动"><a href="#MQClientInstance启动" class="headerlink" title="MQClientInstance启动"></a>MQClientInstance启动</h2><p>在讲Producer的时候已经讲过<code>MQClientInstance</code>的启动过程，因为Producer和Consumer共用一个<code>MQClientInstance</code>，下面我们再来看一下Consumer相关逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.impl.factory.MQClientInstance</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">              <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">             			<span class="comment">// 省略不相关...</span></span><br><span class="line">                  <span class="comment">// 开启各种定时任务</span></span><br><span class="line">                  <span class="keyword">this</span>.startScheduledTask();</span><br><span class="line">                  <span class="comment">// 开启拉消息服务(Consumer)</span></span><br><span class="line">                  <span class="keyword">this</span>.pullMessageService.start();</span><br><span class="line">                  <span class="comment">// 开启负载均衡服务，一个线程定时触发rebalance(20秒一次)</span></span><br><span class="line">                  <span class="keyword">this</span>.rebalanceService.start();</span><br><span class="line">                  <span class="comment">// 初始化一个自用的producer，`CLIENT_INNER_PRODUCER`</span></span><br><span class="line">                  <span class="comment">// 主要用于在消费失败或者超时后发送重试的消息给broker</span></span><br><span class="line">                  <span class="keyword">this</span>.defaultMQProducer.getDefaultMQProducerImpl().start(<span class="keyword">false</span>);</span><br><span class="line">                  <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">								<span class="comment">// 省略不相关...</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startScheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 省略不相关...</span></span><br><span class="line">      <span class="comment">// 持久化消费者的Offset</span></span><br><span class="line">    	<span class="comment">// 保存消费进度，广播消息存在本地，集群消息上传到所有的broker</span></span><br><span class="line">      <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  MQClientInstance.<span class="keyword">this</span>.persistAllConsumerOffset();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  log.error(<span class="string">"ScheduledTask persistAllConsumerOffset exception"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据负载调整本地处理消息的线程池corePool大小</span></span><br><span class="line">      <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  MQClientInstance.<span class="keyword">this</span>.adjustThreadPool();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  log.error(<span class="string">"ScheduledTask adjustThreadPool exception"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>到这里Consumer的相关初始化工作就做完了，下面就会去消费消息了。</p>
<h1 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h1><p>这块逻辑有点复杂，为了大家不被细节绕晕，这里画了一下时序图，如下：<br><img src="https://upload-images.jianshu.io/upload_images/10354196-0b1bee5b4c2bb8b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RocketMq——Consumer消息消费时序图.jpg"></p>
<h2 id="RebalanceImpl触发Pull消息"><a href="#RebalanceImpl触发Pull消息" class="headerlink" title="RebalanceImpl触发Pull消息"></a>RebalanceImpl触发Pull消息</h2><p>还记得<code>defaultMQPushConsumerImpl</code>启动代码中最后一行执行了<code>this.mQClientFactory.rebalanceImmediately()</code>，忘记了，可以回头看看，这里会第一次触发Pull消息。我们看看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.impl.factory.MQClientInstance</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rebalanceImmediately</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   		<span class="comment">// 之前说过rebalanceService就是一个线程，继承于ServiceThread</span></span><br><span class="line">      <span class="keyword">this</span>.rebalanceService.wakeup();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.common.ServiceThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 这里主要是唤醒rebalanceService，用来了原子类和闭锁保证线程安全</span></span><br><span class="line">      <span class="keyword">if</span> (hasNotified.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">          waitPoint.countDown(); <span class="comment">// notify</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.rebalanceService</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        	<span class="comment">// 默认20s</span></span><br><span class="line">          <span class="keyword">this</span>.waitForRunning(waitInterval);</span><br><span class="line">          <span class="keyword">this</span>.mqClientFactory.doRebalance();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.factory.MQClientInstance</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 每一个Consumer都要做doRebalance操作</span></span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, MQConsumerInner&gt; entry : <span class="keyword">this</span>.consumerTable.entrySet()) &#123;</span><br><span class="line">          MQConsumerInner impl = entry.getValue();</span><br><span class="line">          <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  impl.doRebalance();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                  log.error(<span class="string">"doRebalance exception"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.pause) &#123;</span><br><span class="line">          <span class="keyword">this</span>.rebalanceImpl.doRebalance(<span class="keyword">this</span>.isConsumeOrderly());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.RebalanceImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebalanceByTopic</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (messageModel) &#123;</span><br><span class="line">          <span class="keyword">case</span> BROADCASTING: &#123;</span><br><span class="line">              Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">              <span class="keyword">if</span> (mqSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">boolean</span> changed = <span class="keyword">this</span>.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);</span><br><span class="line">                  <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                      <span class="keyword">this</span>.messageQueueChanged(topic, mqSet, mqSet);</span><br><span class="line">                      log.info(<span class="string">"messageQueueChanged &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;"</span>,</span><br><span class="line">                          consumerGroup,</span><br><span class="line">                          topic,</span><br><span class="line">                          mqSet,</span><br><span class="line">                          mqSet);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  log.warn(<span class="string">"doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist."</span>, consumerGroup, topic);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">case</span> CLUSTERING: &#123;</span><br><span class="line">              <span class="comment">// 从路由信息中获取topic对应所有的Queue</span></span><br><span class="line">              Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">              <span class="comment">// 从broker获取所有同一个group的所有Consumer ID(192.168.1.28@83721)</span></span><br><span class="line">              List&lt;String&gt; cidAll = <span class="keyword">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">null</span> == mqSet) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                      log.warn(<span class="string">"doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist."</span>, consumerGroup, topic);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">null</span> == cidAll) &#123;</span><br><span class="line">                  log.warn(<span class="string">"doRebalance, &#123;&#125; &#123;&#125;, get consumer id list failed"</span>, consumerGroup, topic);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (mqSet != <span class="keyword">null</span> &amp;&amp; cidAll != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line">                  mqAll.addAll(mqSet);</span><br><span class="line">                  <span class="comment">// 将mq和cid都排好序</span></span><br><span class="line">                  Collections.sort(mqAll);</span><br><span class="line">                  Collections.sort(cidAll);</span><br><span class="line">                  <span class="comment">// 按照初始化是指定的分配策略（默认平均），获取Consumer分配的MQ列表</span></span><br><span class="line">                  AllocateMessageQueueStrategy strategy = <span class="keyword">this</span>.allocateMessageQueueStrategy;</span><br><span class="line"></span><br><span class="line">                  List&lt;MessageQueue&gt; allocateResult = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      allocateResult = strategy.allocate(</span><br><span class="line">                          <span class="keyword">this</span>.consumerGroup,</span><br><span class="line">                          <span class="keyword">this</span>.mQClientFactory.getClientId(),</span><br><span class="line">                          mqAll,</span><br><span class="line">                          cidAll);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                      log.error(<span class="string">"AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;"</span>, strategy.getName(),</span><br><span class="line">                          e);</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  Set&lt;MessageQueue&gt; allocateResultSet = <span class="keyword">new</span> HashSet&lt;MessageQueue&gt;();</span><br><span class="line">                  <span class="keyword">if</span> (allocateResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      allocateResultSet.addAll(allocateResult);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 更新rebalanceImpl中的processQueue用来缓存收到的消息</span></span><br><span class="line">                  <span class="comment">// 对于新加入的Queue，提交一次PullRequest</span></span><br><span class="line">                  <span class="comment">// 对于新启动的consumer来说，所有的queue都是新添加的，所以所有queue都会触发PullRequest</span></span><br><span class="line">                  <span class="keyword">boolean</span> changed = <span class="keyword">this</span>.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);</span><br><span class="line">                  <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                      log.info(</span><br><span class="line">                          <span class="string">"rebalanced result changed. allocateMessageQueueStrategyName=&#123;&#125;, group=&#123;&#125;, topic=&#123;&#125;, clientId=&#123;&#125;, mqAllSize=&#123;&#125;, cidAllSize=&#123;&#125;, rebalanceResultSize=&#123;&#125;, rebalanceResultSet=&#123;&#125;"</span>,</span><br><span class="line">                          strategy.getName(), consumerGroup, topic, <span class="keyword">this</span>.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),</span><br><span class="line">                          allocateResultSet.size(), allocateResultSet);</span><br><span class="line">                      <span class="comment">// 发送一次心跳</span></span><br><span class="line">                      <span class="keyword">this</span>.messageQueueChanged(topic, mqSet, allocateResultSet);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个点重点看看：</p>
<h3 id="Queue分配策略"><a href="#Queue分配策略" class="headerlink" title="Queue分配策略"></a>Queue分配策略</h3><p>我们看这个方法<code>AllocateMessageQueueStrategy#allocate()</code>，他有下面几种实现：</p>
<ul>
<li><p>AllocateMessageQueueAveragely：这是默认的分配方式，一个consumer分到在平均的情况下分到连续的queue，待会我们会看看代码</p>
</li>
<li><p>AllocateMessageQueueAveragelyByCircle： 和上面类似，但是分到的queue不是连续的。比如一共12个Queue，3个consumer，则第一个consumer接收queue1，4，7，9的消息</p>
</li>
<li><p>AllocateMachineRoomNearby：将queue先按照broker划分几个computer room，不同的consumer只消费某几个broker上的消息</p>
</li>
<li><p>AllocateMessageQueueByMachineRoom：根据computer room进行hash分配队列</p>
</li>
<li><p>AllocateMessageQueueByConfig：在用户启动时指定消费哪些Queue的消息</p>
</li>
<li><p>AllocateMessageQueueConsistentHash：使用一致性hash算法来分配Queue，用户需自定义虚拟节点的数量</p>
</li>
</ul>
<p>然后下面我们看看默认的<code>AllocateMessageQueueAveragely</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MessageQueue&gt; <span class="title">allocate</span><span class="params">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;String&gt; cidAll)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="keyword">int</span> index = cidAll.indexOf(currentCID);</span><br><span class="line">    <span class="keyword">int</span> mod = mqAll.size() % cidAll.size();</span><br><span class="line">    <span class="comment">// 1. mq数量 &lt;= consumer数量，size = 1</span></span><br><span class="line">    <span class="comment">// 2. 否则，size = mq数量 / consumer数量，余数是几则前几个consumer的size+1,这样所有的queue都会有consumer消费</span></span><br><span class="line">    <span class="keyword">int</span> averageSize =</span><br><span class="line">        mqAll.size() &lt;= cidAll.size() ? <span class="number">1</span> : (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size()</span><br><span class="line">            + <span class="number">1</span> : mqAll.size() / cidAll.size());</span><br><span class="line">    <span class="keyword">int</span> startIndex = (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod;</span><br><span class="line">    <span class="keyword">int</span> range = Math.min(averageSize, mqAll.size() - startIndex);</span><br><span class="line">    <span class="comment">// 从第一个consumer开始分配，每个分avgSize个连续的Queue，</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">        result.add(mqAll.get((startIndex + i) % mqAll.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="提交Pull请求"><a href="#提交Pull请求" class="headerlink" title="提交Pull请求"></a>提交Pull请求</h3><p>上面我们说过对于新加入的Queue，提交一次PullRequest，那么我们就可以看看<code>org.apache.rocketmq.client.impl.consumer.RebalanceImpl#updateProcessQueueTableInRebalance</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateProcessQueueTableInRebalance</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> Set&lt;MessageQueue&gt; mqSet,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">// 省略</span></span><br><span class="line">      List&lt;PullRequest&gt; pullRequestList = <span class="keyword">new</span> ArrayList&lt;PullRequest&gt;();</span><br><span class="line">      <span class="keyword">for</span> (MessageQueue mq : mqSet) &#123;</span><br><span class="line">          <span class="comment">// 如果是新加入的Queue</span></span><br><span class="line">          <span class="keyword">if</span> (!<span class="keyword">this</span>.processQueueTable.containsKey(mq)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (isOrder &amp;&amp; !<span class="keyword">this</span>.lock(mq)) &#123;</span><br><span class="line">                  log.warn(<span class="string">"doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed"</span>, consumerGroup, mq);</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 从offset store中移除过时的数据</span></span><br><span class="line">              <span class="keyword">this</span>.removeDirtyOffset(mq);</span><br><span class="line">              ProcessQueue pq = <span class="keyword">new</span> ProcessQueue();</span><br><span class="line">              <span class="comment">// 获取起始消费offset</span></span><br><span class="line">              <span class="keyword">long</span> nextOffset = <span class="keyword">this</span>.computePullFromWhere(mq);</span><br><span class="line">              <span class="keyword">if</span> (nextOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 为新的Queue初始化一个ProcessQueue，用来缓存收到的消息</span></span><br><span class="line">                  ProcessQueue pre = <span class="keyword">this</span>.processQueueTable.putIfAbsent(mq, pq);</span><br><span class="line">                  <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      log.info(<span class="string">"doRebalance, &#123;&#125;, mq already exists, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      log.info(<span class="string">"doRebalance, &#123;&#125;, add a new mq, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                      <span class="comment">// 对新加的queue初始化一个PullRequest</span></span><br><span class="line">                      PullRequest pullRequest = <span class="keyword">new</span> PullRequest();</span><br><span class="line">                      pullRequest.setConsumerGroup(consumerGroup);</span><br><span class="line">                      pullRequest.setNextOffset(nextOffset);</span><br><span class="line">                      pullRequest.setMessageQueue(mq);</span><br><span class="line">                      pullRequest.setProcessQueue(pq);</span><br><span class="line">                      pullRequestList.add(pullRequest);</span><br><span class="line">                      changed = <span class="keyword">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  log.warn(<span class="string">"doRebalance, &#123;&#125;, add new mq failed, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 分发pull request到PullMessageService拉取消息</span></span><br><span class="line">      <span class="keyword">this</span>.dispatchPullRequest(pullRequestList);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> changed;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.RebalancePushImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchPullRequest</span><span class="params">(List&lt;PullRequest&gt; pullRequestList)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (PullRequest pullRequest : pullRequestList) &#123;</span><br><span class="line">        	<span class="comment">// 执行拉取消息</span></span><br><span class="line">          <span class="keyword">this</span>.defaultMQPushConsumerImpl.executePullRequestImmediately(pullRequest);</span><br><span class="line">          log.info(<span class="string">"doRebalance, &#123;&#125;, add a new pull request &#123;&#125;"</span>, consumerGroup, pullRequest);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executePullRequestImmediately</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.mQClientFactory.getPullMessageService().executePullRequestImmediately(pullRequest);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.PullMessageService</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executePullRequestImmediately</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">// 将pull request 放入到pullRequestQueue中</span></span><br><span class="line">          <span class="keyword">this</span>.pullRequestQueue.put(pullRequest);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          log.error(<span class="string">"executePullRequestImmediately pullRequestQueue.put"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息拉取服务"><a href="#消息拉取服务" class="headerlink" title="消息拉取服务"></a>消息拉取服务</h2><p>我们在MQClientInstance启动的时候，我们看到我们启动了一个消息拉取的定时服务。这里我们也就知道其实<code>PullMessageService</code>也是一个线程，我们先看run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.impl.consumer.PullMessageService</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="comment">// 取pull request 进行拉取</span></span><br><span class="line">              PullRequest pullRequest = <span class="keyword">this</span>.pullRequestQueue.take();</span><br><span class="line">              <span class="keyword">this</span>.pullMessage(pullRequest);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              log.error(<span class="string">"Pull Message Service Run Method exception"</span>, e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> MQConsumerInner consumer = <span class="keyword">this</span>.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());</span><br><span class="line">      <span class="keyword">if</span> (consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">          DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;</span><br><span class="line">        	<span class="comment">// 实质</span></span><br><span class="line">          impl.pullMessage(pullRequest);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.warn(<span class="string">"No matched consumer for the PullRequest &#123;&#125;, drop it"</span>, pullRequest);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 拿到缓存消息的队列</span></span><br><span class="line">      <span class="keyword">final</span> ProcessQueue processQueue = pullRequest.getProcessQueue();</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 设置拉取时间戳</span></span><br><span class="line">      pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 查看消息缓存队列的消息数量以及大小</span></span><br><span class="line">      <span class="keyword">long</span> cachedMessageCount = processQueue.getMsgCount().get();</span><br><span class="line">      <span class="keyword">long</span> cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">      <span class="comment">// 如果堆积未处理的消息数量过多(大于默认1000条)，则放回pull request队列,延时执行（默认50ms）</span></span><br><span class="line">      <span class="keyword">if</span> (cachedMessageCount &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果堆积未处理的消息的大小过大（大于100MB），同上面的逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (cachedMessageSizeInMiB &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 无序消息，消息offset跨度过大，同上面的逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.consumeOrderly) &#123;</span><br><span class="line">          <span class="keyword">if</span> (processQueue.getMaxSpan() &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) &#123;</span><br><span class="line">              <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">              <span class="comment">// ...</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检查订阅关系有没有变化，有可能在延时期间，topic或者consumer的配置都发生了变化，需要重新处理</span></span><br><span class="line">      <span class="keyword">final</span> SubscriptionData subscriptionData = <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionData) &#123;</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">          log.warn(<span class="string">"find the consumer's subscription failed, &#123;&#125;"</span>, pullRequest);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line">      <span class="comment">// Pull Command发送后的回调</span></span><br><span class="line">      PullCallback pullCallback = <span class="keyword">new</span> PullCallback() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(PullResult pullResult)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (pullResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 消息预处理，客户端再次过滤，设置minOffset和maxOffset</span></span><br><span class="line">                  pullResult = DefaultMQPushConsumerImpl.<span class="keyword">this</span>.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</span><br><span class="line">                      subscriptionData);</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                      <span class="keyword">case</span> FOUND:</span><br><span class="line">                          <span class="keyword">long</span> prevRequestOffset = pullRequest.getNextOffset();</span><br><span class="line">                          pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line">                          <span class="keyword">long</span> pullRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">                          DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),</span><br><span class="line">                              pullRequest.getMessageQueue().getTopic(), pullRT);</span><br><span class="line"></span><br><span class="line">                          <span class="keyword">long</span> firstMsgOffset = Long.MAX_VALUE;</span><br><span class="line">                          <span class="comment">// 如果获取到的消息数为0，则立即发起下一次pull</span></span><br><span class="line">                          <span class="keyword">if</span> (pullResult.getMsgFoundList() == <span class="keyword">null</span> || pullResult.getMsgFoundList().isEmpty()) &#123;</span><br><span class="line">                              DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                              firstMsgOffset = pullResult.getMsgFoundList().get(<span class="number">0</span>).getQueueOffset();</span><br><span class="line"></span><br><span class="line">                              DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),</span><br><span class="line">                                  pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());</span><br><span class="line">                              <span class="comment">// 消息放入ProcessQueue</span></span><br><span class="line">                              <span class="keyword">boolean</span> dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span><br><span class="line">                              <span class="comment">// 消费消息服务（线程池），调用messageListener处理，处理完成会通知ProcessQueue</span></span><br><span class="line">                              DefaultMQPushConsumerImpl.<span class="keyword">this</span>.consumeMessageService.submitConsumeRequest(</span><br><span class="line">                                  pullResult.getMsgFoundList(),</span><br><span class="line">                                  processQueue,</span><br><span class="line">                                  pullRequest.getMessageQueue(),</span><br><span class="line">                                  dispatchToConsume);</span><br><span class="line">                              <span class="comment">// 再次提交pull request</span></span><br><span class="line">                              <span class="keyword">if</span> (DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                  DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest,</span><br><span class="line">                                      DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval());</span><br><span class="line">                              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                  DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                          <span class="keyword">if</span> (pullResult.getNextBeginOffset() &lt; prevRequestOffset</span><br><span class="line">                              || firstMsgOffset &lt; prevRequestOffset) &#123;</span><br><span class="line">                              log.warn(</span><br><span class="line">                                  <span class="string">"[BUG] pull message result maybe data wrong, nextBeginOffset: &#123;&#125; firstMsgOffset: &#123;&#125; prevRequestOffset: &#123;&#125;"</span>,</span><br><span class="line">                                  pullResult.getNextBeginOffset(),</span><br><span class="line">                                  firstMsgOffset,</span><br><span class="line">                                  prevRequestOffset);</span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">case</span> NO_NEW_MSG:</span><br><span class="line">                          <span class="comment">// ...</span></span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">case</span> OFFSET_ILLEGAL:</span><br><span class="line">                          <span class="comment">// ...</span></span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">default</span>:</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 调用Netty去发送Pull Command，其实这后面就和生产者发送消息是一样的，不过这里是异步发送消息</span></span><br><span class="line">        	<span class="comment">// 异步完成之后会执行pullCallback</span></span><br><span class="line">          <span class="keyword">this</span>.pullAPIWrapper.pullKernelImpl(</span><br><span class="line">              pullRequest.getMessageQueue(),</span><br><span class="line">              subExpression,</span><br><span class="line">              subscriptionData.getExpressionType(),</span><br><span class="line">              subscriptionData.getSubVersion(),</span><br><span class="line">              pullRequest.getNextOffset(),</span><br><span class="line">              <span class="keyword">this</span>.defaultMQPushConsumer.getPullBatchSize(),</span><br><span class="line">              sysFlag,</span><br><span class="line">              commitOffsetValue,</span><br><span class="line">              BROKER_SUSPEND_MAX_TIME_MILLIS,</span><br><span class="line">              CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,</span><br><span class="line">              CommunicationMode.ASYNC,</span><br><span class="line">              pullCallback</span><br><span class="line">          );</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          log.error(<span class="string">"pullKernelImpl exception"</span>, e);</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息消费-1"><a href="#消息消费-1" class="headerlink" title="消息消费"></a>消息消费</h2><p>上面我们已经说过了当消息拉取完之后会执行PullCallback，具体一点就是会执行到<code>org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService.submitConsumeRequest()</code>，我们看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitConsumeRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ProcessQueue processQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> MessageQueue messageQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">boolean</span> dispatchToConsume)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> consumeBatchSize = <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line">      <span class="comment">// 看是否需要批量消费，默认阈值是1</span></span><br><span class="line">      <span class="keyword">if</span> (msgs.size() &lt;= consumeBatchSize) &#123;</span><br><span class="line">          <span class="comment">// 创建一个消费任务</span></span><br><span class="line">          ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgs, processQueue, messageQueue);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">              <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 创建批量消费任务</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> total = <span class="number">0</span>; total &lt; msgs.size(); ) &#123;</span><br><span class="line">              List&lt;MessageExt&gt; msgThis = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeBatchSize);</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumeBatchSize; i++, total++) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (total &lt; msgs.size()) &#123;</span><br><span class="line">                      msgThis.add(msgs.get(total));</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgThis, processQueue, messageQueue);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                  <span class="keyword">for</span> (; total &lt; msgs.size(); total++) &#123;</span><br><span class="line">                      msgThis.add(msgs.get(total));</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于ConsumeRequest是一个任务，所以我们可以看看它的run方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">          <span class="comment">// 得到改消息的Listener</span></span><br><span class="line">          MessageListenerConcurrently listener = ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.messageListener;</span><br><span class="line">          ConsumeConcurrentlyContext context = <span class="keyword">new</span> ConsumeConcurrentlyContext(messageQueue);</span><br><span class="line">          ConsumeConcurrentlyStatus status = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">          ConsumeMessageContext consumeMessageContext = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">              consumeMessageContext = <span class="keyword">new</span> ConsumeMessageContext();</span><br><span class="line">              consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">              consumeMessageContext.setProps(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">              consumeMessageContext.setMq(messageQueue);</span><br><span class="line">              consumeMessageContext.setMsgList(msgs);</span><br><span class="line">              consumeMessageContext.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">              ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line">          <span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">          ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.resetRetryTopic(msgs);</span><br><span class="line">              <span class="keyword">if</span> (msgs != <span class="keyword">null</span> &amp;&amp; !msgs.isEmpty()) &#123;</span><br><span class="line">                  <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                      MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// listener执行回调逻辑</span></span><br><span class="line">              status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">              log.warn(<span class="string">"consumeMessage exception: &#123;&#125; Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;"</span>,</span><br><span class="line">                  RemotingHelper.exceptionSimpleDesc(e),</span><br><span class="line">                  ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup,</span><br><span class="line">                  msgs,</span><br><span class="line">                  messageQueue);</span><br><span class="line">              hasException = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">long</span> consumeRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">        	<span class="comment">// 设置消费结果</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">null</span> == status) &#123;</span><br><span class="line">              <span class="keyword">if</span> (hasException) &#123;</span><br><span class="line">                  returnType = ConsumeReturnType.EXCEPTION;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  returnType = ConsumeReturnType.RETURNNULL;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (consumeRT &gt;= defaultMQPushConsumer.getConsumeTimeout() * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">              returnType = ConsumeReturnType.TIME_OUT;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConsumeConcurrentlyStatus.RECONSUME_LATER == status) &#123;</span><br><span class="line">              returnType = ConsumeReturnType.FAILED;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status) &#123;</span><br><span class="line">              returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">              consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());</span><br><span class="line">          &#125;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">          <span class="keyword">if</span> (!processQueue.isDropped()) &#123;</span><br><span class="line">              <span class="comment">// 处理消费结果</span></span><br><span class="line">              ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.processConsumeResult(status, context, <span class="keyword">this</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              log.warn(<span class="string">"processQueue is dropped without process consume result. messageQueue=&#123;&#125;, msgs=&#123;&#125;"</span>, messageQueue, msgs);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConsumeResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ConsumeConcurrentlyStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ConsumeConcurrentlyContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ConsumeRequest consumeRequest</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> ackIndex = context.getAckIndex();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (consumeRequest.getMsgs().isEmpty())</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 设置消费状态</span></span><br><span class="line">      <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">          <span class="comment">// 消费成功</span></span><br><span class="line">          <span class="keyword">case</span> CONSUME_SUCCESS:</span><br><span class="line">              <span class="keyword">if</span> (ackIndex &gt;= consumeRequest.getMsgs().size()) &#123;</span><br><span class="line">                  ackIndex = consumeRequest.getMsgs().size() - <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">int</span> ok = ackIndex + <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">int</span> failed = consumeRequest.getMsgs().size() - ok;</span><br><span class="line">              <span class="keyword">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok);</span><br><span class="line">              <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 重新消费</span></span><br><span class="line">          <span class="keyword">case</span> RECONSUME_LATER:</span><br><span class="line">              ackIndex = -<span class="number">1</span>;</span><br><span class="line">              <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(),</span><br><span class="line">                  consumeRequest.getMsgs().size());</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">          <span class="comment">// broadcast模式，处理失败，不做处理</span></span><br><span class="line">          <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                  MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                  log.warn(<span class="string">"BROADCASTING, the message consume failed, drop it, &#123;&#125;"</span>, msg.toString());</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">              List&lt;MessageExt&gt; msgBackFailed = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeRequest.getMsgs().size());</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                  MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                  <span class="comment">// Cluster模式，将消息发回broker，让broker重新发送</span></span><br><span class="line">                  <span class="comment">// 一共有两种方式让broker重发(有兴趣自己去看看): </span></span><br><span class="line">                  <span class="comment">// 1. 先尝试给broker发送send_msg_back的命令，</span></span><br><span class="line">                  <span class="comment">// 2. 如果失败了，则通过consumer预留的producer给%RETRY%groupname发送消息，等于是自己给自己发一条消息。</span></span><br><span class="line">                  <span class="keyword">boolean</span> result = <span class="keyword">this</span>.sendMessageBack(msg, context);</span><br><span class="line">                  <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                      msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line">                      msgBackFailed.add(msg);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (!msgBackFailed.isEmpty()) &#123;</span><br><span class="line">                  consumeRequest.getMsgs().removeAll(msgBackFailed);</span><br><span class="line">                  <span class="comment">// 发回broker失败，则再次尝试本地消费</span></span><br><span class="line">                  <span class="keyword">this</span>.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将消费前缓存的消息清除</span></span><br><span class="line">      <span class="keyword">long</span> offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</span><br><span class="line">      <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们也基本上吧消息消费的流程走完了， 现在可以再回头看看流程图，如果能对的上就OK啦！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/dd2202cc22ea" target="_blank" rel="noopener">RocketMQ源码解析(四)-Consumer</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：当消息达到Broker之后，就等着Consumer去consume了呀~
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>Seata源码解析——环境搭建</title>
    <link href="http://bestlixiang.site/2019/06/16/Seata%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Seata%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://bestlixiang.site/2019/06/16/Seata源码分析/Seata源码解析——环境搭建/</id>
    <published>2019-06-16T02:18:22.000Z</published>
    <updated>2019-06-16T02:22:00.631Z</updated>
    
    <content type="html"><![CDATA[<p>引：2019 年 1 月，阿里巴巴中间件团队发起了开源项目 <strong>Fescar（Fast &amp; EaSy Commit And Rollback）</strong>，和社区一起共建开源分布式事务解决方案。Fescar 的愿景是让分布式事务的使用像本地事务的使用一样，简单和高效，并逐步解决开发者们遇到的分布式事务方面的所有难题。为了打造更中立、更开放、生态更加丰富的分布式事务开源社区，经过社区核心成员的投票，大家决定对 <strong>Fescar </strong>进行品牌升级，并更名为 <strong>Seata</strong>，意为：<strong>Simple Extensible Autonomous Transaction Architecture</strong>，是一套一站式<strong>分布式事务</strong>解决方案。<a id="more"></a></p>
<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p>还是那句话：<br><strong>源码，是原理的具象化</strong><br><strong>原理，是代码的抽象化</strong></p>
<p>所以在开始看源码前一定要好好了解Seata的使用方式以及原理，喜欢Seata的<a href="https://github.com/seata/seata/wiki" target="_blank" rel="noopener">wiki</a>。</p>
<h1 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h1><ol>
<li>Git</li>
<li>Maven</li>
<li>JDK1.8</li>
<li>IntelliJ IDEA</li>
<li>Mysql</li>
</ol>
<h1 id="源码拉取"><a href="#源码拉取" class="headerlink" title="源码拉取"></a>源码拉取</h1><p>好像是在fescar升级到seata的时候，项目将samples抽出成一个独立的项目了，所以我们需要拉两个工程的代码：</p>
<ol>
<li><a href="https://github.com/seata/seata" target="_blank" rel="noopener">seata</a></li>
<li><a href="https://github.com/seata/seata-samples" target="_blank" rel="noopener">seata-samples</a></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/seata/seata.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/seata/seata-samples.git</span><br></pre></td></tr></table></figure>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="启动Seata-Server"><a href="#启动Seata-Server" class="headerlink" title="启动Seata Server"></a>启动Seata Server</h2><p>在seata工程中找到<code>io.seata.server.Server</code>，直接点击运行main方法即可，我们可以看到如下输出日志：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-06-16 09:11:11.542 INFO [main]io.seata.core.rpc.netty.AbstractRpcRemotingServer.start:176 -Server started ...</span><br></pre></td></tr></table></figure>
<h2 id="启动Seata-samples"><a href="#启动Seata-samples" class="headerlink" title="启动Seata-samples"></a>启动Seata-samples</h2><p>seata-samples项目中提供了各种Demo，我们这里选择最简单的一种好了——dubbo。</p>
<h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><p>使用mysql</p>
<ol>
<li>创建数据库：fescar_demo</li>
<li>执行seata-samples/dubbo/src/main/resources/sql/dubbo_biz.sql</li>
<li>执行seata-samples/dubbo/src/main/resources/sql/undo_log.sql</li>
</ol>
<h3 id="启动基础服务"><a href="#启动基础服务" class="headerlink" title="启动基础服务"></a>启动基础服务</h3><ol>
<li><p>DubboAccountServiceStarter</p>
<p>找到<code>io.seata.samples.dubbo.starter.DubboAccountServiceStarter</code>，直接点击运行main方法，在当前线程下，我们没有看到日志，但是在Server端，我们可以看到下面的日志，就代码Rm已经注册成功啦，同时在数据库<code>account_tbl</code>表中插入了一条记录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-06-16 09:32:45.562 INFO [ServerHandlerThread_1_500]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegRmMessage:112 -rm register success,message:RegisterRMRequest&#123;resourceIds=<span class="string">'jdbc:mysql://127.0.0.1:3306/seata'</span>, applicationId=<span class="string">'dubbo-demo-account-service'</span>, transactionServiceGroup=<span class="string">'my_test_tx_group'</span>&#125;,channel:[id: 0xcbff48be, L:/127.0.0.1:8091 - R:/127.0.0.1:54122]</span><br><span class="line">2019-06-16 09:32:48.139 INFO [NettyServerNIOWorker_2_8]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegTmMessage:128 -checkAuth <span class="keyword">for</span> client:127.0.0.1:54123 vgroup:my_test_tx_group ok</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-10458e4af725f5fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="acount.png"></p>
<ol>
<li><p>DubboStorageServiceStarter</p>
<p>找到<code>io.seata.samples.dubbo.starter.DubboStorageServiceStarter</code>，直接点击运行main方法，在当前线程下，我们没有看到日志，但是在Server端，我们可以看到下面的日志，就代码Rm已经注册成功啦，同时在数据库<code>storage_tbl</code>表中插入了一条记录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-06-16 09:41:06.227 INFO [ServerHandlerThread_2_500]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegRmMessage:112 -rm register success,message:RegisterRMRequest&#123;resourceIds=<span class="string">'jdbc:mysql://127.0.0.1:3306/seata'</span>, applicationId=<span class="string">'dubbo-demo-storage-service'</span>, transactionServiceGroup=<span class="string">'my_test_tx_group'</span>&#125;,channel:[id: 0xf37dc389, L:/127.0.0.1:8091 - R:/127.0.0.1:54214]</span><br><span class="line">2019-06-16 09:41:08.969 INFO [NettyServerNIOWorker_4_8]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegTmMessage:128 -checkAuth <span class="keyword">for</span> client:127.0.0.1:54215 vgroup:my_test_tx_group ok</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-a48b6dba285bba5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="storage.png"></p>
<ol>
<li><p>DubboOrderServiceStarter</p>
<p>找到<code>io.seata.samples.dubbo.DubboOrderServiceStarter</code>，直接点击运行main方法，在当前线程下，我们没有看到日志，但是在Server端，我们可以看到下面的日志，就代码Rm已经注册成功啦：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-06-16 09:44:18.384 INFO [ServerHandlerThread_3_500]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegRmMessage:112 -rm register success,message:RegisterRMRequest&#123;resourceIds=<span class="string">'jdbc:mysql://127.0.0.1.200:3306/seata'</span>, applicationId=<span class="string">'dubbo-demo-order-service'</span>, transactionServiceGroup=<span class="string">'my_test_tx_group'</span>&#125;,channel:[id: 0xe370a8ab, L:/127.0.0.1:8091 - R:/127.0.0.1:54259]</span><br><span class="line">2019-06-16 09:44:21.333 INFO [NettyServerNIOWorker_6_8]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegTmMessage:128 -checkAuth <span class="keyword">for</span> client:127.0.0.1:54261 vgroup:my_test_tx_group ok</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="测试分布式事务"><a href="#测试分布式事务" class="headerlink" title="测试分布式事务"></a>测试分布式事务</h3><p>找到<code>io.seata.samples.dubbo.DubboBusinessTester</code> 这里执行的是一个购买的方法，会先调用库存服务扣减库存，然后调用订单服务生产订单，在生成订单之前，他还会调用扣减账户余额的服务，这样会形成一个微服务链路。</p>
<h4 id="正常提交"><a href="#正常提交" class="headerlink" title="正常提交"></a>正常提交</h4><p>我们先把<code>io.seata.samples.dubbo.service.impl#purchase</code>方法中的异常给注释掉：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purchase</span><span class="params">(String userId, String commodityCode, <span class="keyword">int</span> orderCount)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"purchase begin ... xid: "</span> + RootContext.getXID());</span><br><span class="line">    storageService.deduct(commodityCode, orderCount);</span><br><span class="line">    orderService.create(userId, commodityCode, orderCount);</span><br><span class="line">    <span class="comment">// throw new RuntimeException("xxx");</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后点击运行<code>io.seata.samples.dubbo.DubboBusinessTester#main</code>方法，我们看到方法正常结束，并且表中数据发送了如下变化：<br><img src="https://upload-images.jianshu.io/upload_images/10354196-cb3b6179b4da2d8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="normal-acount.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-42255f8875371e19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="normal-storage.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-e8586aefc68ed8e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="normal-order.png"></p>
<h4 id="异常回滚"><a href="#异常回滚" class="headerlink" title="异常回滚"></a>异常回滚</h4><p>我们先把<code>io.seata.samples.dubbo.service.impl#purchase</code>方法中的异常的注释给放开, 为了更好的看到回滚的过程，我们在抛出异常的那一行代码前面加上<strong>断点</strong>，然后debug运行<code>io.seata.samples.dubbo.DubboBusinessTester#main</code>方法，执行到断点，我们看看数据库的变化：<br><img src="https://upload-images.jianshu.io/upload_images/10354196-53d207bcb1f6e4f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="exception-account.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-3ecd332b64ce4500.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="exception-storage.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10354196-d2b1f11253b620e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="exception-order.png"></p>
<p>我们看到数据其实都已经有了一些变化，然后看看很重要的  <code>undo_log</code>表，发现它也生成了一些记录，不过这里先不管：<br><img src="https://upload-images.jianshu.io/upload_images/10354196-521fd48999566ecc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="undo_log.png"></p>
<p>我们放开断点之后看到方法执行抛出了异常，同时表中数据变成了上面正常提交的数据，同时<code>undo_log</code>表也被清空了，从这里可以看出seata确实是帮我们实现了<strong>分布式事务</strong>。</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>好了，环境到这里就搭建结束了，关于seata代码上是如何实现分布式事务的，我们慢慢来分析~</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/seata/seata/wiki" target="_blank" rel="noopener">Seata Wiki</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：2019 年 1 月，阿里巴巴中间件团队发起了开源项目 &lt;strong&gt;Fescar（Fast &amp;amp; EaSy Commit And Rollback）&lt;/strong&gt;，和社区一起共建开源分布式事务解决方案。Fescar 的愿景是让分布式事务的使用像本地事务的使用一样，简单和高效，并逐步解决开发者们遇到的分布式事务方面的所有难题。为了打造更中立、更开放、生态更加丰富的分布式事务开源社区，经过社区核心成员的投票，大家决定对 &lt;strong&gt;Fescar &lt;/strong&gt;进行品牌升级，并更名为 &lt;strong&gt;Seata&lt;/strong&gt;，意为：&lt;strong&gt;Simple Extensible Autonomous Transaction Architecture&lt;/strong&gt;，是一套一站式&lt;strong&gt;分布式事务&lt;/strong&gt;解决方案。
    
    </summary>
    
      <category term="Seata源码" scheme="http://bestlixiang.site/categories/Seata%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Seata" scheme="http://bestlixiang.site/tags/Seata/"/>
    
      <category term="分布式事务" scheme="http://bestlixiang.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ源码分析——Producer</title>
    <link href="http://bestlixiang.site/2019/06/15/RocketMQ%E6%BA%90%E7%A0%81/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Producer/"/>
    <id>http://bestlixiang.site/2019/06/15/RocketMQ源码/RocketMQ源码分析——Producer/</id>
    <published>2019-06-15T06:46:21.000Z</published>
    <updated>2019-06-15T06:50:11.364Z</updated>
    
    <content type="html"><![CDATA[<p>引：使用MQ，第一步构造Producer，然后就可以开始发送消息啦！<a id="more"></a></p>
<h1 id="发送方式"><a href="#发送方式" class="headerlink" title="发送方式"></a>发送方式</h1><p>producer发送消息支持3种方式，同步、异步和Oneway。</p>
<ul>
<li>同步发送：客户端提交消息到broker后会等待返回结果。有可靠性保障。</li>
<li>异步发送：调用发送接口时会注册一个callback类，发送线程继续其它业务逻辑，producer在收到broker结果后回调。当消息结果不影响正常业务逻辑的时候使用。</li>
<li>Oneway：Producer提交消息后，无论broker是否正常接收消息都不关心。适合于追求高吞吐、能容忍消息丢失的场景，比如日志收集。</li>
</ul>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>我们主要讲同步发送，异步发送和Oneway方式和事务消息带过，同步发送例子就是环境搭建中Producer的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化一个Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指明Namesrv</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                    <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                    (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">                );</span><br><span class="line">                SendResult sendResult = producer.send(msg);</span><br><span class="line">                System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面我们实例化一个DefaultMQProducer，设置group name和nameserv的地址。Producer启动后就可以往指定的topic发送消息啦！</p>
<h1 id="Producer启动"><a href="#Producer启动" class="headerlink" title="Producer启动"></a>Producer启动</h1><h2 id="DefaultMQProducer初始化"><a href="#DefaultMQProducer初始化" class="headerlink" title="DefaultMQProducer初始化"></a>DefaultMQProducer初始化</h2><p>下面代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.client.producer.DefaultMQProducer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(producerGroup, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup, RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.producerGroup = producerGroup;</span><br><span class="line">        <span class="comment">// DefaultMQProducer包装了DefaultMQProducerImpl</span></span><br><span class="line">        defaultMQProducerImpl = <span class="keyword">new</span> DefaultMQProducerImpl(<span class="keyword">this</span>, rpcHook);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducerImpl</span><span class="params">(<span class="keyword">final</span> DefaultMQProducer defaultMQProducer, RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMQProducer = defaultMQProducer;</span><br><span class="line">        <span class="keyword">this</span>.rpcHook = rpcHook;</span><br><span class="line">        <span class="comment">// 构造了一个同步发送线程池</span></span><br><span class="line">        <span class="keyword">this</span>.asyncSenderThreadPoolQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">50000</span>);</span><br><span class="line">        <span class="keyword">this</span>.defaultAsyncSenderExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            Runtime.getRuntime().availableProcessors(),</span><br><span class="line">            Runtime.getRuntime().availableProcessors(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.asyncSenderThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                <span class="keyword">private</span> AtomicInteger threadIndex = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncSenderExecutor_"</span> + <span class="keyword">this</span>.threadIndex.incrementAndGet());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="DefaultMQProducer启动"><a href="#DefaultMQProducer启动" class="headerlink" title="DefaultMQProducer启动"></a>DefaultMQProducer启动</h2><p>下面代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.client.producer.DefaultMQProducer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="comment">// 调用实际的实现类</span></span><br><span class="line">    <span class="keyword">this</span>.defaultMQProducerImpl.start();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != traceDispatcher) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            traceDispatcher.start(<span class="keyword">this</span>.getNamesrvAddr());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            log.warn(<span class="string">"trace dispatcher start failed "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.start(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> startFactory)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            <span class="comment">// 如果下面的过程中出错了，那么serviceState就为START_FAILED</span></span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">            <span class="comment">// 检查group name是否合适</span></span><br><span class="line">            <span class="keyword">this</span>.checkConfig();</span><br><span class="line">            <span class="comment">// 更改defaultMQProducer的名称为进程id</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// MQClientManager为单例，创建mQClientFactory</span></span><br><span class="line">            <span class="comment">// 一个进程只会存在一个MQClientInstance， 设置clientId （IP@PID）</span></span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQProducer, rpcHook);</span><br><span class="line">            <span class="comment">// 向mQClientFactory注册defaultMQProducer</span></span><br><span class="line">            <span class="keyword">boolean</span> registerOK = mQClientFactory.registerProducer(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup(), <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer group["</span> + <span class="keyword">this</span>.defaultMQProducer.getProducerGroup()</span><br><span class="line">                    + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加默认的topicPublishInfo</span></span><br><span class="line">            <span class="keyword">this</span>.topicPublishInfoTable.put(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey(), <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (startFactory) &#123;</span><br><span class="line">                <span class="comment">// 核心</span></span><br><span class="line">                <span class="comment">// 启动MQClientInstance</span></span><br><span class="line">                mQClientFactory.start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">"the producer [&#123;&#125;] start OK. sendMessageWithVIPChannel=&#123;&#125;"</span>, <span class="keyword">this</span>.defaultMQProducer.getProducerGroup(),</span><br><span class="line">                <span class="keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel());</span><br><span class="line">            <span class="comment">// 启动完成</span></span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">        <span class="keyword">case</span> START_FAILED:</span><br><span class="line">        <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer service state not OK, maybe started once, "</span></span><br><span class="line">                + <span class="keyword">this</span>.serviceState</span><br><span class="line">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向所有broker发送一次心跳</span></span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到DefaultMQProducer 的start的过程主要就是初始化和启动一个MQClientInstance，将producer注册到instance中。我们来看下MQClientInstance的启动过程。</p>
<h2 id="MQClientInstance启动"><a href="#MQClientInstance启动" class="headerlink" title="MQClientInstance启动"></a>MQClientInstance启动</h2><p>下面是启动代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">                <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">                    <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">                    <span class="comment">// If not specified,looking address from name server</span></span><br><span class="line">                    <span class="comment">// 如果NameservAddr为空，尝试从http server获取nameserv的地址</span></span><br><span class="line">                    <span class="comment">// 这里看出适合于有统一配置中心的系统</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Start request-response channel</span></span><br><span class="line">                    <span class="comment">// 初始化Netty客户端</span></span><br><span class="line">                    <span class="keyword">this</span>.mQClientAPIImpl.start();</span><br><span class="line">                    <span class="comment">// Start various schedule tasks</span></span><br><span class="line">                    <span class="comment">// 开启各种定时任务</span></span><br><span class="line">                    <span class="keyword">this</span>.startScheduledTask();</span><br><span class="line">                    <span class="comment">// Start pull service</span></span><br><span class="line">                    <span class="comment">// producer和consumer公用一个MQClientInstance的实现</span></span><br><span class="line">                    <span class="comment">// 开启拉消息服务(Consumer)</span></span><br><span class="line">                    <span class="keyword">this</span>.pullMessageService.start();</span><br><span class="line">                    <span class="comment">// Start rebalance service</span></span><br><span class="line">                    <span class="comment">// 开启负载均衡服务</span></span><br><span class="line">                    <span class="keyword">this</span>.rebalanceService.start();</span><br><span class="line">                    <span class="comment">// Start push service</span></span><br><span class="line">                    <span class="comment">// 开启Producer</span></span><br><span class="line">                    <span class="keyword">this</span>.defaultMQProducer.getDefaultMQProducerImpl().start(<span class="keyword">false</span>);</span><br><span class="line">                    log.info(<span class="string">"the client factory [&#123;&#125;] start OK"</span>, <span class="keyword">this</span>.clientId);</span><br><span class="line">                    <span class="comment">// 更改client状态</span></span><br><span class="line">                    <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RUNNING:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> START_FAILED:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The Factory object["</span> + <span class="keyword">this</span>.getClientId() + <span class="string">"] has been created before, and failed."</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看看它起了哪些定时任务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startScheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">        <span class="comment">// 获取nameserv地址</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    MQClientInstance.<span class="keyword">this</span>.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"ScheduledTask fetchNameServerAddr exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从nameserv更新topicRouteInfo</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MQClientInstance.<span class="keyword">this</span>.updateTopicRouteInfoFromNameServer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"ScheduledTask updateTopicRouteInfoFromNameServer exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPollNameServerInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除已经下线的broker，并发送心跳</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MQClientInstance.<span class="keyword">this</span>.cleanOfflineBroker();</span><br><span class="line">                MQClientInstance.<span class="keyword">this</span>.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"ScheduledTask sendHeartbeatToAllBroker exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>, <span class="keyword">this</span>.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持久化消费者的Offset(Consumer)</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MQClientInstance.<span class="keyword">this</span>.persistAllConsumerOffset();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"ScheduledTask persistAllConsumerOffset exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态调整消费者的线程池（Consumer）</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MQClientInstance.<span class="keyword">this</span>.adjustThreadPool();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"ScheduledTask adjustThreadPool exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，我们的Producer就启动完成了，接下来我们就可以看看它是怎么发送消息啦！</p>
<h1 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h1><p>Producer默认采用同步方式发送消息，如我们的示例，接下来我们看看这个方法<code>DefaultMQProducer.send( Message msg)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.client.producer.DefaultMQProducer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Message msg)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.defaultMQProducerImpl.send(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.producer.defaultMQProducerImpl</span></span><br><span class="line"><span class="comment">// 超时时间3秒</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Message msg)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> send(msg, <span class="keyword">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到默认采用同步方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sendDefaultImpl(msg, CommunicationMode.SYNC, <span class="keyword">null</span>, timeout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际发送逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendDefaultImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> CommunicationMode communicationMode,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> SendCallback sendCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">long</span> timeout</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 检查client状态是否是runing</span></span><br><span class="line">    <span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line">    <span class="comment">// 参数校验，消息不能发给系统预留的topic，消息体不能超过最大长度4M，或者是空消息</span></span><br><span class="line">    Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> invokeID = random.nextLong();</span><br><span class="line">    <span class="keyword">long</span> beginTimestampFirst = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> beginTimestampPrev = beginTimestampFirst;</span><br><span class="line">    <span class="keyword">long</span> endTimestamp = beginTimestampFirst;</span><br><span class="line">    <span class="comment">// 根据消息的topic，获取该topic的路由信息</span></span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> callTimeout = <span class="keyword">false</span>;</span><br><span class="line">        MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line">        Exception exception = <span class="keyword">null</span>;</span><br><span class="line">        SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 重试次数，同步模式下默认为3次</span></span><br><span class="line">        <span class="keyword">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">        String[] brokersSent = <span class="keyword">new</span> String[timesTotal];</span><br><span class="line">        <span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</span><br><span class="line">            <span class="comment">// 记录上次的发送的broker</span></span><br><span class="line">            String lastBrokerName = <span class="keyword">null</span> == mq ? <span class="keyword">null</span> : mq.getBrokerName();</span><br><span class="line">            <span class="comment">// 从所有topic可用queue中选择一个queue，有不同的策略</span></span><br><span class="line">            MessageQueue mqSelected = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line">            <span class="keyword">if</span> (mqSelected != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mq = mqSelected;</span><br><span class="line">                <span class="comment">// 记录下当前的broker</span></span><br><span class="line">                brokersSent[times] = mq.getBrokerName();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">long</span> costTime = beginTimestampPrev - beginTimestampFirst;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTime) &#123;</span><br><span class="line">                        callTimeout = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 发送消息</span></span><br><span class="line">                    sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);</span><br><span class="line">                    endTimestamp = System.currentTimeMillis();</span><br><span class="line">                    <span class="comment">// 更新本次调用时间到MQFaultStrategy中</span></span><br><span class="line">                    <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">                        <span class="comment">// 异步和ONEWAY方式调用后就直接返回了</span></span><br><span class="line">                        <span class="keyword">case</span> ASYNC:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">case</span> SYNC:</span><br><span class="line">                            <span class="comment">// 发送没成功</span></span><br><span class="line">                            <span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">                                <span class="comment">// 如果broker存储失败，判断是否要重试</span></span><br><span class="line">                                <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">return</span> sendResult;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                    <span class="comment">// 省略异常</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 成功则返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (sendResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sendResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略不重要逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面完整的发送逻辑信息量还是比较大的，我们具体看看几个重要的部分。</p>
<h2 id="获取topic路由信息"><a href="#获取topic路由信息" class="headerlink" title="获取topic路由信息"></a>获取topic路由信息</h2><p>关注<code>DefaultMQProducerImpl#tryToFindTopicPublishInfo()</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TopicPublishInfo <span class="title">tryToFindTopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从本地缓存获取，之前看到过有定时任务会定时更新这个缓存</span></span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="comment">// 如果不存在，则从Namesrv加锁更新TopicRouteInfo ，使用Netty</span></span><br><span class="line">        <span class="keyword">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="comment">// 若获取的 Topic发布信息时候可用，则返回</span></span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当从Namesrv获取不到时，如果允许broker自动创建topic信息则自动创建并更新</span></span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, <span class="keyword">true</span>, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Queue选取策略"><a href="#Queue选取策略" class="headerlink" title="Queue选取策略"></a>Queue选取策略</h2><p>Queue的选取是采用轮询的方式，如果客户端开启延迟容错，那么在轮询的时候会加入broker可用性的判断。<br>关注<code>DefaultMQProducerImpl#selectOneMessageQueue()</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MQFaultStrategy mqFaultStrategy = <span class="keyword">new</span> MQFaultStrategy();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mqFaultStrategy.selectOneMessageQueue(tpInfo, lastBrokerName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.apache.rocketmq.client.latency.MQFaultStrategy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果开启了延时容错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 首先获取上次使用的Queue index+1，这个index是放在ThreadLocal下</span></span><br><span class="line">            <span class="comment">// 实现了轮询的效果，但是在重试的时候是为了选择上一次发送的broker</span></span><br><span class="line">            <span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                    pos = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 找到index对应的queue</span></span><br><span class="line">                MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</span><br><span class="line">                <span class="comment">// 如果queue对应的broker可用（根据faultItemTable判断），则使用该broker</span></span><br><span class="line">                <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line">                    <span class="comment">// 第一次发送或者是重试，直接选</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line">                        <span class="keyword">return</span> mq;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找个合适的broker，则从所有的broker中选择一个相对合适的，并且是可写的broker</span></span><br><span class="line">            <span class="comment">// 相对合适是指 可用/延迟低/上次不可用时间早</span></span><br><span class="line">            <span class="keyword">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</span><br><span class="line">            <span class="keyword">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</span><br><span class="line">            <span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</span><br><span class="line">                <span class="keyword">if</span> (notBestBroker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mq.setBrokerName(notBestBroker);</span><br><span class="line">                    mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                latencyFaultTolerance.remove(notBestBroker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error occurred when selecting message queue"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tpInfo.selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未开启延时容错，直接按顺序选下一个</span></span><br><span class="line">    <span class="keyword">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于queue选择有很多细节可以说，看以后是不是单独拎出来说一下，这里给个延迟的结论：当发送时长低于100ms时，设置broker不可用时长为0，之后依次增加，如果超过15秒，则有10分钟不可用。可以看到如果上次发送失败的话，也是10分钟不可用，如果重试肯定不会选择相同的broker，即不会选择不可用的broker。</p>
<h2 id="消息发送-1"><a href="#消息发送-1" class="headerlink" title="消息发送"></a>消息发送</h2><p>关注DefaultMQProducerImpl#sendKernelImpl()方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendKernelImpl</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> MessageQueue mq,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> CommunicationMode communicationMode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> SendCallback sendCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> TopicPublishInfo topicPublishInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> beginStartTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 根据brokerName从缓存中获取broker的地址</span></span><br><span class="line">    String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">    <span class="comment">// 如果地址为空，则从namesrv中再获取一次</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddr) &#123;</span><br><span class="line">        tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line">        <span class="comment">// 重新获取</span></span><br><span class="line">        brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SendMessageContext context = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (brokerAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 切换到VIP channel</span></span><br><span class="line">        <span class="comment">// Broker启动时会开启2个端口接收客户端数据，其中一个端口只接收producer的消息，不接受consumer的拉取请求，被称为VIP channel</span></span><br><span class="line">        brokerAddr = MixAll.brokerVIPChannel(<span class="keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] prevBody = msg.getBody();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//for MessageBatch,ID has been set in the generating process</span></span><br><span class="line">            <span class="comment">// 如果不是批量发送则客户端设置的id</span></span><br><span class="line">            <span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line">                MessageClientIDSetter.setUniqID(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sysFlag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> msgBodyCompressed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果消息body过长，则压缩并设置标记位</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tryToCompressMessage(msg)) &#123;</span><br><span class="line">                sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line">                msgBodyCompressed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 事务消息标记</span></span><br><span class="line">            <span class="keyword">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">            <span class="keyword">if</span> (tranMsg != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line">                sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 省略不重要逻辑</span></span><br><span class="line">            <span class="comment">// 设置消息头</span></span><br><span class="line">            SendMessageRequestHeader requestHeader = <span class="keyword">new</span> SendMessageRequestHeader();</span><br><span class="line">            requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">            requestHeader.setTopic(msg.getTopic());</span><br><span class="line">            requestHeader.setDefaultTopic(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey());</span><br><span class="line">            requestHeader.setDefaultTopicQueueNums(<span class="keyword">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</span><br><span class="line">            requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">            requestHeader.setSysFlag(sysFlag);</span><br><span class="line">            requestHeader.setBornTimestamp(System.currentTimeMillis());</span><br><span class="line">            requestHeader.setFlag(msg.getFlag());</span><br><span class="line">            requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line">            requestHeader.setReconsumeTimes(<span class="number">0</span>);</span><br><span class="line">            requestHeader.setUnitMode(<span class="keyword">this</span>.isUnitMode());</span><br><span class="line">            requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);</span><br><span class="line">            <span class="comment">// 要求重新发送的消息，设置重试次数和延时时间</span></span><br><span class="line">            <span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</span><br><span class="line">                <span class="keyword">if</span> (reconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line">                <span class="keyword">if</span> (maxReconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 通过NettyClient发送消息到Broker</span></span><br><span class="line">            <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">                <span class="keyword">case</span> ASYNC:</span><br><span class="line">                    Message tmpMessage = msg;</span><br><span class="line">                    <span class="keyword">if</span> (msgBodyCompressed) &#123;</span><br><span class="line">                        <span class="comment">//If msg body was compressed, msgbody should be reset using prevBody.</span></span><br><span class="line">                        <span class="comment">//Clone new message using commpressed message body and recover origin massage.</span></span><br><span class="line">                        <span class="comment">//Fix bug:https://github.com/apache/rocketmq-externals/issues/66</span></span><br><span class="line">                        tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">                        msg.setBody(prevBody);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">long</span> costTimeAsync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTimeAsync) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendKernelImpl call timeout"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 实际发送消息的位置</span></span><br><span class="line">                    sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">                        brokerAddr,</span><br><span class="line">                        mq.getBrokerName(),</span><br><span class="line">                        tmpMessage,</span><br><span class="line">                        requestHeader,</span><br><span class="line">                        timeout - costTimeAsync,</span><br><span class="line">                        communicationMode,</span><br><span class="line">                        sendCallback,</span><br><span class="line">                        topicPublishInfo,</span><br><span class="line">                        <span class="keyword">this</span>.mQClientFactory,</span><br><span class="line">                        <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),</span><br><span class="line">                        context,</span><br><span class="line">                        <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                <span class="keyword">case</span> SYNC:</span><br><span class="line">                    <span class="keyword">long</span> costTimeSync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTimeSync) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendKernelImpl call timeout"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">                        brokerAddr,</span><br><span class="line">                        mq.getBrokerName(),</span><br><span class="line">                        msg,</span><br><span class="line">                        requestHeader,</span><br><span class="line">                        timeout - costTimeSync,</span><br><span class="line">                        communicationMode,</span><br><span class="line">                        context,</span><br><span class="line">                        <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">                context.setSendResult(sendResult);</span><br><span class="line">                <span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> sendResult;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">           <span class="comment">// ... 省略异常处理</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            msg.setBody(prevBody);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The broker["</span> + mq.getBrokerName() + <span class="string">"] not exist"</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里就结束了！除了队列选择逻辑有点复杂，其他还好，但是还是要好好去体会~</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/02dbc0710f80" target="_blank" rel="noopener">RocketMQ源码解析(三)-Producer</a></li>
<li><a href="[http://b.shiwuliang.com/RocketMQ%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E4%B9%8B%E9%80%89%E6%8B%A9%E9%98%9F%E5%88%97%E5%B9%B6%E5%8F%91%E9%80%81.html](http://b.shiwuliang.com/RocketMQ%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E4%B9%8B%E9%80%89%E6%8B%A9%E9%98%9F%E5%88%97%E5%B9%B6%E5%8F%91%E9%80%81.html">RocketMQ源码解读——消息发送之选择队列并发送</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引：使用MQ，第一步构造Producer，然后就可以开始发送消息啦！
    
    </summary>
    
      <category term="RocketMQ源码" scheme="http://bestlixiang.site/categories/RocketMQ%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="RocketMQ" scheme="http://bestlixiang.site/tags/RocketMQ/"/>
    
  </entry>
  
</feed>
