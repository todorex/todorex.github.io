<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅尝Apache Camel]]></title>
    <url>%2F2017%2F07%2F15%2F%E6%B5%85%E5%B0%9DApache-Camel%2F</url>
    <content type="text"><![CDATA[引：最近项目有一个需求就是定时将一台服务器的文件传到另一个服务器，一开始想的竟然想的是用http去下载，后来在万老师的指点下，采取用ftp服务器（源文件所在地）与ftp客户端（源文件去向）的形式来处理，自己小试了一下，还不错！ Apache Camel简介Apache Camel是Apache基金会下的一个开源项目,它是一个基于规则路由和处理的引擎，提供企业集成模式的Java对象的实现，通过应用程序接口 或称为陈述式的Java领域特定语言(DSL)来配置路由和处理的规则。其核心的思想就是从一个from源头得到数据,通过processor处理,再发到一个to目的的。 这个from和to可以是我们在项目集成中经常碰到的类型:一个FTP文件夹中的文件,一个MQ的queue（jms）,一个HTTP request/response,一个webservice等等. Apache Camel架构 其实理解起来很简单：始端》（过滤器+路由处理器）》终端 Apache Camel核心概念 endpoint,所谓的endpoint,就是一种可以接收或发送数据的组件。可以支持多种协议，如jms,http,file等。 processor,它是用来处理具体业务逻辑的组件。 route,用来路由，指示数据从哪里来到哪里去，中间用哪个processor处理。 exchange,processor之间用exchange对象来传送数据，有点像jms,通俗一点就像上学时传的小纸条,所以：exchange对象就是processor，endpoint所有camel组件之间传送数据的小纸条:)。 filter，用来确定哪些东西可以传递，哪些东西不可以传递。 Apache Camel例子（以ftp为例）老师指导的例子，是结合Springboot的，放在github上了。ApacheCamleDemo 里面包括了动态路由和单路由的例子，稍微结合Springboot就可以理解并改成自己的代码。 什么时候用Apache Camel参考网上的说法：camel就是企业信息集成框架，它提供了很多简单好用而又强大的组件，用户可以根据场景来选择不同的EIP（企业集成模式）来实现自己的需求，以响应快速变化的业务。可以把它当成企业信息总线（ESB）的轻量级实现。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>ApacheCamel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java ftp 上传下载的坑]]></title>
    <url>%2F2017%2F07%2F15%2Fjava-ftp-%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[引：还是项目需要，要定时执行一个文件下载业务，一开始方向有点错，但是还好纠正过来了，采用ftp下载，但是ftp下载也有各种坑！ 准备jar包：commons-net ftp上传程序：123456789101112131415161718192021222324252627282930313233343536373839public static boolean uploadFile(String url,//服务器主机号int port,//服务器端口String username,//用户名String password,//密码String path, //上传路径String filename,//上传为服务器上的文件名InputStream //input本地上传的文件流) &#123;boolean success = false;FTPClient ftp = new FTPClient();try &#123;int reply;ftp.connect(url, port);//连接FTP服务器//如果采用默认端口，可以使用ftp.connect(url)的方式直接连接FTP服务器ftp.login(username, password);//登录reply = ftp.getReplyCode();if (!FTPReply.isPositiveCompletion(reply)) &#123;ftp.disconnect();return success;&#125;ftp.changeWorkingDirectory(path);ftp.storeFile(filename, input);input.close();ftp.logout();success = true;&#125; catch (IOException e) &#123;e.printStackTrace();&#125; finally &#123;if (ftp.isConnected()) &#123;try &#123;ftp.disconnect();&#125; catch (IOException ioe) &#123;&#125;&#125;&#125;return success;&#125; 测试代码：123File file = new File(&quot;/var/test.txt&quot;);InputStream is = new FileInputStream(file);uploadFile(&quot;127.0.0.1&quot;,21,&quot;test&quot;,&quot;123456&quot;,&quot;/var/data/test&quot;,&quot;testdemo.txt&quot;,is); ftp下载程序：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public static boolean downFile(String url, //FTP服务器hostnameint port,//FTP服务器端口String username, //FTP登录账号String password, //FTP登录密码String remotePath,//FTP服务器上的相对路径String fileName,//要下载文件关键字String localPath//下载后保存到本地的路径) &#123;FTPClient ftpClient = null;boolean success = false;try &#123;ftpClient = new FTPClient();ftpClient.connect(url, port);// 连接FTP服务器ftpClient.login(username, password);// 登陆FTP服务器ftpClient.setControlEncoding(&quot;gb2312&quot;); // 中文支持ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);//设置文件格式ftpClient.enterLocalPassiveMode();logger.info(ftpClient.getReplyCode());if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) &#123;logger.warn(&quot;未连接到FTP，用户名或密码错误。&quot;);ftpClient.disconnect();&#125; else &#123;logger.info(&quot;FTP连接成功。&quot;);&#125;ftpClient.changeWorkingDirectory(remotePath);FTPFile[] fs = ftpClient.listFiles();File file = new File(localPath);if(!file.exists())&#123;file.mkdirs();&#125;for(FTPFile ff:fs)&#123;if(ff.getName().contains(fileName))&#123;File localFile = new File(localPath+&quot;/&quot;+ff.getName());if (localFile.exists())&#123;continue;&#125;OutputStream os = new FileOutputStream(localFile);long time1 = System.currentTimeMillis();boolean b = ftpClient.retrieveFile(new String(ff.getName().getBytes(&quot;gb2312&quot;),&quot;ISO8859-1&quot;), os); os.flush();os.close();&#125;&#125;ftpClient.logout();success = true;&#125; catch (SocketException e) &#123;e.printStackTrace();logger.warn(&quot;FTP的IP地址可能错误，请正确配置。&quot;);&#125; catch (IOException e) &#123;e.printStackTrace();logger.warn(&quot;FTP的端口错误,请正确配置。&quot;);&#125; finally &#123;if (ftpClient.isConnected()) &#123;try &#123;ftpClient.disconnect();&#125; catch (IOException ioe) &#123;&#125;&#125;&#125;return success;&#125; 测试程序：1downFile(&quot;127.0.0.1&quot;,21,&quot;test&quot;,&quot;123456&quot;,&quot;、var/data/test&quot;,&quot;demo&quot;,&quot;/var/alldata&quot;); 一些坑 客户端接受的编码1ftpClient.setControlEncoding(&quot;gb2312&quot;); // 中文支持 如果服务器上的文件名有中文，一定要加上这一句，具体编码要根据服务器的编码。 客户端接受的文件类型1ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);//设置文件格式 文件类型要根据下载的文件格式来定 服务器端口设置 1ftpClient.enterLocalPassiveMode(); 调用FTPClient.enterLocalPassiveMode();这个方法的意思就是每次数据连接之前，ftp client告诉ftp server开通一个端口来传输数据，防止在新端口对外部不通，因为ftp server可能每次开启不同的端口来传输数据，但是在linux上，由于安全限制，可能某些端口没有开启，所以就出现阻塞。 最大的坑（下载出0kb的文件：实质就是retrieveFile方法执行失败）1ftpClient.retrieveFile(new String(ff.getName().getBytes(&quot;gb2312&quot;),&quot;ISO8859-1&quot;), os) 一定要给文件名换编码，让它识别中文，具体编码也是根据实际情况而定。 总结ftp客户端的速度也是要根据网速来的，可能比一般http快，但是面对网速慢的情况也是无可奈何！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js原型和原型链]]></title>
    <url>%2F2017%2F07%2F13%2Fjs%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[引：刚刚说了闭包，那就不放过js的另一大难点了——js原型以及原型链。 谈谈神图镇楼：自己写了好几遍内容，但是自己发现还是不能系统的理解，自己也写不了多好，看来要到自己安心写前端的时候，再来补上了。 参考 最详尽的 JS 原型与原型链终极详解（一） 最详尽的 JS 原型与原型链终极详解（二） 最详尽的 JS 原型与原型链终极详解（三） 个人感觉上面的文章还不错，可能还缺了继承那块的讲解，等自己再来的时候一起补上吧！！！！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈js闭包]]></title>
    <url>%2F2017%2F07%2F12%2F%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[引：最近项目前端用了angular2，里面使用的TypeScript,其实很多和Java挺像的，学起来还是挺快的。但是里面的很多变量的原理都是根据闭包来实现的，那就好好了解一下闭包。 闭包定义根据Mozilla开发者文档定义： 闭包是指向独立变量的“函数”,用通俗的话说就是会“记住”它创建时的环境。 闭包涉及的主要概念 作用域链 作用域链是函数在定义的时候创建的,用于寻找使用到的变量的值的一个索引。它内部的规则是,把函数自身的本地变量放在最前面,把自身的父级函数中的变量放在其次,把再高一级函数中的变量放在更后面,以此类推直至全局对象为止.当函数中需要查询一个变量的值的时候,js解释器会去作用域链去查找,从最前面的本地变量中先找,如果没有找到对应的变量,则到下一级的链上找,一旦找到了变量,则不再继续.如果找到最后也没找到需要的变量,则解释器返回undefined. 内存回收机制 一个函数在执行开始的时候,会给其中定义的变量划分内存空间保存,以备后面的语句所用,等到函数执行完毕返回了,这些变量就被认为是无用的了.对应的内存空间也就被回收了.下次再执行此函数的时候,所有的变量又回到最初的状态,重新赋值使用.但是如果这个函数内部又嵌套了另一个函数,而这个函数是有可能在外部被调用到的.并且这个内部函数又使用了外部函数的某些变量的话.这种内存回收机制就会出现问题.如果在外部函数返回后,又直接调用了内部函数,那么内部函数就无法读取到他所需要的外部函数中变量的值了.所以js解释器在遇到函数定义的时候,会自动把函数和他可能使用的变量(包括本地变量和父级和祖先级函数的变量(自由变量))一起保存起来.也就是构建一个闭包,这些变量将不会被内存回收器所回收,只有当内部的函数不可能被调用以后(例如被删除了,或者没有了指针),才会销毁这个闭包,而没有任何一个闭包引用的变量才会被下一次内存回收启动时所回收. 闭包现象123456789var results = [];for (var i = 0; i &lt;3; i++) &#123;results[i] = function() &#123;console.log(i);&#125;&#125;results[0](); //3results[1](); //3results[2](); //3 解析：其实这里return出来的是一个function（我们可以理解为他是一个字符串，还没有执行），等到我们去执行他的时候，只保存了他上一级的作用域链里面的i的索引,那个时候i已经是3了。 闭包解决让内部函数在循环创建的时候立即执行,并且捕捉当前的索引值,然后记录在自己的一个本地变量里.然后利用返回函数的方法,重写内部函数,让下一次调用的时候,返回本地变量的值,改进后的代码:1234567891011var results = [];for (var i = 0; i &lt;3; i++) &#123;results[i] = (function(j) &#123;return function()&#123;console.log(j);&#125;&#125;)(i);&#125;results[0](); //0results[1](); //1results[2](); //2 我们发现通过立即执行表达式就可以解决闭包的现象得到我们想要得到的现象。 闭包应用闭包与静态变量前面就说TypeScript与Java很像，所以类中的静态变量也是有的。 TypeScript代码：12345678910111213141516class Counter &#123;private static COUNTER = 0;constructor() &#123;&#125;private changeBy(val) &#123;Counter.COUNTER +=val;&#125;public increment() &#123;this.changeBy(1);&#125;public decrement() &#123;this.changeBy(-1);&#125;public value() &#123;return Counter.COUNTER;&#125;&#125; 编译之后的js代码:123456789101112131415161718var Counter = (function () &#123;function Counter() &#123;&#125;Counter.prototype.changeBy = function (val) &#123;Counter.COUNTER += val;&#125;;Counter.prototype.increment = function () &#123;this.changeBy(1);&#125;;Counter.prototype.decrement = function () &#123;this.changeBy(-1);&#125;;Counter.prototype.value = function () &#123;return Counter.COUNTER;&#125;;Counter.COUNTER = 0;return Counter;&#125;()); 从js代码可以看书静态变量COUNTER是属于Counter类的，并不属于对象原型。所有Counter实例都共享Counter的同一个闭包上下文环境（COUNTER）。所以COUNTER会表现像单例一样。 闭包和私有成员TypeScript由于性能原因并没有使用闭包来模拟私有变量，他使用过编译检查机制来形成私有变量的特性。但是我们可以使用闭包来实现私有变量。 js代码如下：123456789101112131415161718function makeCounter() &#123;var COUNTERR = 0;function Counter() &#123;&#125;function changeBy(val) &#123;COUNTER += val;&#125;;Counter.prototype.increment = function () &#123;this.changeBy(1);&#125;;Counter.prototype.decrement = function () &#123;this.changeBy(-1);&#125;;Counter.prototype.value = function () &#123;return COUNTER;&#125;;return new Counter();&#125;; 从上面的代码可以看出，每一个新的makeCounter实例都拥有自己的上下文环境，其他实例访问不了。 总结学习这么久的js发现，其实闭包真的无处不在，需要好好学习，好好总结，如有不对，也希望大家能够指出。 参考链接：js中闭包原理谈和原型及例子 书籍：Learning TypeScript中文版]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java日志那些事]]></title>
    <url>%2F2017%2F07%2F12%2FJava%E6%97%A5%E5%BF%97%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[引：一直都知道日志文件很重要，可以记录一些相关信息，但是可能是程序需要调试的内容太少，也或者是项目太小，所以看看控制台的信息就够了，但是这次接触的项目越来越大，控制台额信息越来越多，经常会看不到自己想要看到的信息时，这个时候使用日志就发现十分得有必要了！ 日志的好处 方便调试(如上) 方便发现系统运行中的错误 存储业务数据，便于日后分析 日志实现方式 自己实现类通过io存储到文件中 使用log4j将日志输入到控制台，文本文件，一集数据库中。 使用jdk自带的logging.jar包中方法（同一作者还有lognback） 使用slfj，它提供了上述两种方法的接口。 日志的输出(以log4j为例) 输入到控制台 运行程序：1234567891011public class LoggerTest &#123;public static Logger logger1 = Logger.getLogger(LoggerTest.class);public static void main(String[] args) &#123;logger1.trace(&quot;我是logger1，trace&quot;);logger1.debug(&quot;我是logger1，debug&quot;);logger1.info(&quot;我是logger1，info&quot;);logger1.warn(&quot;我是logger1，warn&quot;);logger1.error(&quot;我是logger1，error&quot;);logger1.fatal(&quot;我是logger1，fatal&quot;);&#125;&#125; 配置文件如下：123456789### 设置级别和目的地(这里多个目的地) ###log4j.rootLogger = DEBUG,CONSOLE### 这里的com.todorex是包，也就是在这个包记录日志时，是只记录debug及以上级别的日志log4j.logger.com.todorex=DEBUG### 输出到控制台 ###log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.Target = System.outlog4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern = %d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n 控制台输出:1234511:35:09,969 DEBUG LoggerTest:12 [main:0]- 我是logger1，debug11:35:09,972 INFO LoggerTest:13 [main:3]- 我是logger1，info11:35:09,972 WARN LoggerTest:14 [main:3]- 我是logger1，warn11:35:09,972 ERROR LoggerTest:15 [main:3]- 我是logger1，error11:35:09,972 FATAL LoggerTest:16 [main:3]- 我是logger1，fatal 输入到日志文件运行程序同上；配置文件如下：1234567891011121314151617181920### 设置级别和目的地(这里可以多个目的地) ###log4j.rootLogger = trace,demoLoglog4j.logger.com.todorex=DEBUG### 输出到控制台 ###log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.Target = System.outlog4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern = %d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L [%t:%r]- %m%n### 输出到日志文件（文件目录一定要是绝对路径且存在） ###log4j.appender.demoLog = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.demoLog.File =/var/alldata/mylog.loglog4j.appender.demoLog.Append = true## 只输出DEBUG级别以上的日志log4j.appender.demoLog.Threshold = DEBUG#&apos;.&apos;yyyy-MM-dd: 每天产生一个新的文件log4j.appender.demoLog.DatePattern = &apos;.&apos;yyyy-MM-ddlog4j.appender.demoLog.layout = org.apache.log4j.PatternLayoutlog4j.appender.demoLog.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%t:%r] - [%p] [%c&#123;1&#125;:%L] [%M] %m%n 文件内容同控制台输出，但是却比控制台清楚得多，不会被乱七八糟的信息给遮盖。 输入到数据库 运行程序:1234567public class LoggerTest &#123;public static void main(String[] args) &#123;Logger logger = Logger.getLogger(LoggerTest.class);logger.info(&quot;good&quot;);logger.debug(&quot;success&quot;);&#125;&#125; 配置文件：1234567891011log4j.rootLogger=trace,CONSOLE,demoLog# com.todorex包下面所有的日志输出的级别设为DEBUGlog4j.logger.com.todorex=DEBUG# 数据库输出log4j.appender.demoLog=org.apache.log4j.jdbc.JDBCAppenderlog4j.appender.demoLog.driver=com.mysql.jdbc.Driverlog4j.appender.demoLog.URL=jdbc:mysql://127.0.0.1:3306/testlog4j.appender.demoLog.user=rootlog4j.appender.demoLog.password=root# 在数据库对应的位置建一个对应的log表log4j.appender.demoLog.sql=insert into log(level,category,thread,time,location,note) values(&apos;%p&apos;,&apos;%c&apos;,&apos;%t&apos;,&apos;%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;&apos;,&apos;%l&apos;,&apos;%m&apos;) 数据库的具体内容就不贴出来了，和普通看到的一样。 总结其实日志用几次就知道它的好了，自己也是在慢慢学习！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jpa实体映射关系]]></title>
    <url>%2F2017%2F06%2F15%2Fjpa%E5%AE%9E%E4%BD%93%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[引：其实距离自己上次写数据库操作已经1个多月了，之前接触的就是Hibernate，这次接触jpa，就把几种对应关系理清。 映射策略注：这次举的例子都是User和Car的 外键关联简介：两个表的关系定义在其中一个表中 @OneToOne方法一：123@OneToOne(cascade=CascadeType.ALL, fetch=FetchType.EAGER)@JoinColumn(name = &quot;user_id&quot;)private Car car; 通过在Car表中加入一个外键，实现两者关系。方法二：12@OneToOne(cascade = CascadeType.ALL,fetch = FetchType.EAGER,mappedBy = &quot;Car&quot;)private User user; 通过在Car类中用MappedBy声明让User进行维护。 @OneToMany123@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)@JoinColumn(name = &quot;user_id&quot;)private Set&lt;Car&gt; cars; 通过在Car表中加入一个外键，实现一对多关系。 @ManyToMany12@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)private Set&lt;Car&gt; cars; 这个是采用默认的表关联 表关联简介：两个表的关系通过一张中间表来来关联 @OneToMany12345@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)@JoinTable(name = &quot;user_car&quot;,joinColumns=&#123;@JoinColumn(name = &quot;user_id&quot;)&#125;,inverseJoinColumns = &#123;@JoinColumn(name = &quot;car_id&quot;)&#125;)private Set&lt;Car&gt; cars; 通过JoinTable来确定一张中间表，joinColumns里面放父表的属性，inverseJoinColumns放子表的属性 @ManyToMany12345@ManyToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)@JoinTable(name = &quot;user_car&quot;,joinColumns=&#123;@JoinColumn(name = &quot;user_id&quot;)&#125;,inverseJoinColumns = &#123;@JoinColumn(name = &quot;car_id&quot;)&#125;)private Set&lt;Car&gt; cars; 解释如@OneToMany 一些属性cascade属性 CascadeType.PERSIST：级联新建 CascadeType.REMOVE：级联删除 CascadeType.REFRESH：级联刷新 CascadeType.MERGE：级联更新 CascadeType.ALL：包括上面四项 fetch属性 FetchType.EAGER：相当于禁用懒加载，推荐开发使用 FetchType.LAZY：懒加载，默认值，推荐部署使用 总结父表是提供主键的，子表是利用父表的主键来设置外键的，维护方是Owner，被维护方是Owned。提示自己一个傻逼的问题，插入数据要先往两张表中插入数据，在往中间表插入数据，不然会报错~]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>sping</tag>
        <tag>jpa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot项目调试angular2]]></title>
    <url>%2F2017%2F06%2F01%2Fspringboot%E9%A1%B9%E7%9B%AE%E8%B0%83%E8%AF%95angular2%2F</url>
    <content type="text"><![CDATA[引：在接触 springboot和angular2的前后端项目的时候，我发现自己会先把angular2的项目编译好之后放在springboot的resource目录下的static文件夹下运行，虽然这样可以，但是对于前端来调试代码实在不方便。在百度网上的方法之后可以采用如下代理的方式。 问题 angular2启动的服务默认为http://localhost:4200 springboot启动的服务默认为http://localhost:8080 如果我们直接设置angular2访问的路径为http://localhost:8080就会出现跨域访问的问题。请求不到数据。 解决在angular2项目的根目录下面新建一个proxy.config.json123456&#123;&quot;/api&quot;: &#123;&quot;target&quot;: &quot;http://localhost:8081&quot;,&quot;secure&quot;: false&#125;&#125; 然后在启动项目的时候采用下面的命令 ng serve –proxy-config proxy.config.json 通过这样的代理访问就能能够实现跨域访问请求数据。 总结通过上面的方法方便了开发调试，不错，终于要开始写代码了！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>angular2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringSecurity+JWT保驾SpringBoot(未完)]]></title>
    <url>%2F2017%2F05%2F24%2FSpringSecurity-JWT%E4%BF%9D%E9%A9%BESpringBoot-%E6%9C%AA%E5%AE%8C%2F</url>
    <content type="text"><![CDATA[引：在万老师的指引下，开始接触到了安全板块，SpringSecurity+JWT绝对能够让人欣喜 JWT介绍关于JWT说实话是最近才听到的，然后慢慢开始了解，这里简单记下一篇博文。这篇博文在做过简单的应用之后发现还是不怎么全的 ，等自己再深入了解之后，再来补全。 SpringSecurity整合JWT看了几个SpringSecurity的应用，发现应该是大同小异，自己也找到一篇虽然结构不太好，但大部分内容都讲到的博文。也是日后能够总结得好一点，再来补全。 总结一定要再来！！！！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JWT</tag>
        <tag>SpringSecurity</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular2入门]]></title>
    <url>%2F2017%2F05%2F24%2FAngular2%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[引：由于老师暑假的项目前端代码需要用到Angular2，作为一个后端开发者也是需要了解一丢丢的。 Angular简介在经过简单的了解与使用之后，感觉 到Angular2的强大与伟大，配的上说是一个优秀的前端框架。Angular2实现了前端一直提倡的组件化开发还解决了大部分项目路由混乱的问题。它还有具有MVC分层架构和依赖注入等一系列优秀的特性。现在贴上Angular2的一张架构图：上图描述了Angular2中8大主要构造块的关系，他们具体的理解，可以参考这篇博文。如果还有什么不理解，那我们可以相信实践见真知。 Angular起步在这次学习中，我终于理解了前辈们所说的入门一门技术就好的方法就是去看官方文档了，Angular2的官网文档里面有中文版的，相信大家一定很开心吧。当然没有中文版也是要看的，比较都是最基础的入门，不要惧怕英文。 在这次按照官方文档的教程（英雄编辑器）出现了两个问题，这里也说明一下： angular-in-memory-web-apia模块不存在 解决方法：通过命令行安装 npm i angular-in-memory-web-api 1234567create(name: string): Promise&lt;Hero&gt; &#123;return this.http.post(this.heroesUrl, JSON.stringify(&#123;name: name&#125;), this.headers).toPromise().then(res =&gt; res.json().data as Hero).catch(this.handleError);&#125; 这里的post方法中的第三个参数应该是this.headers,而不是像官方文档中的那样。 总结如果遇到不懂得问候多看看文档吧，相信自己可以的，然后就是实践见真知了。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Angular2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简谈entity，model，domain]]></title>
    <url>%2F2017%2F05%2F23%2F%E7%AE%80%E8%B0%88entity%EF%BC%8Cmodel%EF%BC%8Cdomain%2F</url>
    <content type="text"><![CDATA[引：前两天听到关于entity和domain包的区别，好像之前自己也没有在意过，今天看看网上的信息总结一下。 entity（实体）这好像是最常用的package命名了，package的类一般都是和数据库的表对应的。一个实体，一张表，其字段的类型也是对应的。 model（模型）最初接触到它的时候是Struts的模型驱动，用于接受和显示前台的数据对象。我们要根据实际情况来确定模型的类。 domain（域）说实话，这个包名用得不怎么多，在网上显示它在国外的网站用的比较多，它主要是用于存储一个业务对象（模块对象）。 总结正确命名包名，有助于后续代码的维护，以及后来开发者的维护，最重要的是能衔接行业的规范。慢慢来！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行运行hadoop程序]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8Chadoop%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[引：自己最近心态有点崩，毕竟很迷茫，趁现在比较空 ，也就微微看看hadoop。在运行《Hadoop权威指南》的时候，遇到了按照书上命令行无法运行的问题。 问题 大家都知道刚开始入门，就遇到问题了就必然是十分难受的，那么我们现在可以解决。 解决编辑 ~/.bash_profile12export HADOOP_HOME=/usr/local/hadoopexport CLASSPATH=$($HADOOP_HOME/bin/hadoop classpath):$CLASSPATH 使其生效1source ~/.bash_profile 运行 编译主类 1javac MaxTemperature.java 把.class 文件打包成 jar，才能在 Hadoop 中运行： 1jar -cvf MaxTemperature.jar ./MaxTemperature*.class 创建input文件夹的数据，就可以运行了(每次运行时，output文件夹都应该不存在) 1hadoop MaxTemperature input/ncdc/sample.txt output 总结虽然我自己还不知道书上的命令行为什么不能用，但是还是希望慢慢可以弄懂吧！]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F2017%2F05%2F17%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[引：上次看到过钟华老师的一个基于贪心算法的毕业设计，一直很好奇，今天终于能看看它了，只是知其然，不知所以然。 贪心算法总说贪心算法在每一步都会做出看起来是最佳的选择，也就是说会做出局部最优的选择，希望以此能够得到最优解。 活动选择问题贪心选择我们要选择这样一个活动，选出它之后身下的资源能够被尽量多的其他任务所用，即选择最早结束的活动。 递归贪心算法算法思路：用两个数组s和f表示活动的开始和结束时间。下表k是我们要求解的子问题，以及问题规模n，代码如下：12345678910111213141516171819202122232425262728293031import java.util.ArrayList;import java.util.List;public class ActivitySelector &#123;public int[] s = new int[]&#123;1,3,0,5,3,5,6,8,8,2,12&#125;;public int[] f = new int[]&#123;4,5,6,7,9,9,10,11,12,14,16&#125;;public List&lt;Integer&gt; list = new ArrayList&lt;&gt;();public void recursiveActivitySelector(int[] s, int[] f,int k,int n)&#123;if(list.size()==0)&#123;list.add(1);&#125;int m = k+1;while (m&lt;n &amp;&amp; s[m]&lt;f[k])&#123;m = m+1;&#125;if(m&lt;n)&#123;list.add(m+1);recursiveActivitySelector(s, f, m, n);&#125; else &#123;return ;&#125; &#125;public static void main(String[] args) &#123;ActivitySelector activitySelector = new ActivitySelector();activitySelector.recursiveActivitySelector(activitySelector.s, activitySelector.f, 0, activitySelector.f.length);for (Integer i : activitySelector.list) &#123;System.out.println(i);&#125;&#125;&#125; 迭代贪心算法这个过程是假设输入活动的结束时间是已经排好序的，代码如下：123456789101112131415161718192021222324252627import java.util.ArrayList;import java.util.List;public class GreedyActivitySelector &#123;public int[] s = new int[]&#123;1,3,0,5,3,5,6,8,8,2,12&#125;;public int[] f = new int[]&#123;4,5,6,7,9,9,10,11,12,14,16&#125;;public List&lt;Integer&gt; list = new ArrayList&lt;&gt;();public void greedActivitySelector(int[] s,int[] f)&#123;int n = s.length;list.add(1);int k = 1;for (int m = 1; m &lt; n; m++) &#123;if(s[m]&gt;=f[k])&#123;list.add(k);k = m;&#125;&#125;&#125;public static void main(String[] args) &#123;ActivitySelector activitySelector = new ActivitySelector();activitySelector.recursiveActivitySelector(activitySelector.s, activitySelector.f, 0, activitySelector.f.length);for (Integer i : activitySelector.list) &#123;System.out.println(i);&#125;&#125;&#125; 贪心算法原理设计贪心算法的过程 确定问题的最优子结构 设计一个递归算法 证明一个贪心选择，则只剩下一个子问题 证明贪心选择总是安全的 设计一个递归算法实现贪心策略 将递归算法转换为迭代算法 证明一个贪心算法是否能求解一个最优化问题？具有下面性质就ok？ 贪心选择性质 我们可以通过做出局部最优选择来构造全局最优解 最优子结构 如果一个问题的最优解包含子问题的最优解 总结一步一步慢慢贪心，和做人是一样的，但是总的来说还是要考虑全局的！！！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2017%2F05%2F17%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[引：慢慢就步入了算法导论的高级设计与分析技术模块，先来看看动态规划。ps:快毕业的心情org。 动态规划总说动态规划虽然与分治方法相似，但是它能够解决子问题重叠的情况，这样就提高了效率。它通常是用来求解最优化的问题。求得是一个最优解。一般按如下4个步骤来设计一个动态规划算法。 刻画一个最优解的结构特征 递归地定义最优解的值 计算最优解的值，通常采用自底向上的方法 利用计算出的信息构造出一个最优解 钢条切割先看以前常用的分治方法即自顶向下方法,代码如下：12345678910111213141516171819202122232425262728public class CutRod &#123;//a[i]表示长度为i的钢条利润是多少public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;//自顶向下递归设计public int cutRod(int[] a,int n) &#123;if(n == 0)&#123;return 0;&#125;int q = 0;for (int i = 0; i&lt;n; i++)&#123;q = max(q,a[i]+cutRod(a,n-1-i));&#125;return q;&#125;//求最大值函数public int max(int a, int b)&#123;if(a&gt;b)&#123;return a;&#125; else &#123;return b;&#125;&#125;public static void main(String[] args) &#123;CutRod cut = new CutRod(); int lost = cut.cutRod(cut.a,10);System.out.println(lost);&#125;&#125; 问题：反复地用相同的参数值对自身进行递归调用，造成了运行时间为n的指数函数。 为了解决这个问题，我们可以采用动态规划方法求解最优钢条切割问题。 采用带备忘的自顶向下法核心是利用一个数组存储已经求解过的最优解，避免了重复的计算，具体的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MemoizedCutRod &#123;//a[i]表示长度为i的钢条利润是多少public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;//带备忘的自顶向下函数public int memoizedCutRod(int[] a,int n)&#123;//创建一个备忘的数组存储一个之前计算过的最优解int[] r = new int[n];//初始化数组for (int i : r) &#123;i = 0;&#125;//借助辅助函数计算return memoizedCutRodAux(a, n, r);&#125;//带备忘的自顶向下法辅助函数public int memoizedCutRodAux(int[] a,int n,int[] r) &#123;//定义利润int q = 0;if(n == 0)&#123;return 0;&#125; //判断原先是否已经计算过，若计算过就不用再计算if(r[n-1] &gt;0)&#123;return r[n-1]; &#125;else &#123;for (int i = 0; i&lt;n; i++)&#123;q = max(q,a[i]+memoizedCutRodAux(a, n-1-i, r));&#125;&#125;r[n-1] = q;return q;&#125;//求最大值函数public int max(int a, int b)&#123;if(a&gt;b)&#123;return a;&#125; else &#123;return b;&#125;&#125;public static void main(String[] args) &#123;MemoizedCutRod cut = new MemoizedCutRod();int lost = cut.memoizedCutRod(cut.a, 10);System.out.println(lost);&#125;&#125; 采用由底向上的方法核心是从小算到大算出每一个长度的最优解，然后返回想要的长度的最优解。代码如下： 123456789101112131415161718192021222324252627282930public class BottomUpTopCutRod &#123;//a[i]表示长度为i的钢条利润是多少public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;public int bottomUpTopCutRod(int[] a, int n)&#123;int[] r = new int[n+1];//长度为0的时候，收益为0r[0] = 0;int q = 0;for(int i = 0; i&lt;n; i++)&#123;for(int j = 0; j&lt;=i; j++)&#123;q = max(q,a[j]+r[i-j]);&#125;r[i+1] = q;&#125;return r[n];&#125;//求最大值函数public int max(int a, int b)&#123;if(a&gt;b)&#123;return a;&#125; else &#123;return b;&#125;&#125;public static void main(String[] args) &#123;BottomUpTopCutRod cut = new BottomUpTopCutRod();int lost = cut.bottomUpTopCutRod(cut.a, 10);System.out.println(lost);&#125;&#125; 优势：实现了运行时间复杂度n*n 动态规划原理适用应用动态规划方法求解的最优化问题应该具备的两个要素：最优子结构和子问题重叠 最优子结构如果一个问题的最优解包含其子问题的最优解，我们就称这个问题具有最优子结构性质。例如：无权最短路径。 重叠子问题如果递归算法反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质。例如钢条切割。 总结慢慢懂一点小算法思想。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观《驴得水》呻吟]]></title>
    <url>%2F2017%2F05%2F11%2F%E8%A7%82%E3%80%8A%E9%A9%B4%E5%BE%97%E6%B0%B4%E3%80%8B%E5%91%BB%E5%90%9F%2F</url>
    <content type="text"><![CDATA[引：其实当身边同学都在打游戏的时候，我却不能静下心来了，内心仍然是浮躁，既然不能改论文，所以自己就找电影看吧。自认为自己是一个不懂得享受的人，所以在大脑思索良久之后，决定观看好久之前评价还不错的电影《驴得水》。 总说我不知道该以什么角度来评价这部电影，但这部电影给我感受是深刻，至少在灵魂上还是有一定的冲击，感觉作者与导演把每个角色想要表达的思想基本上都表达出来了，下面我也将按这些角色把在我身上能够体会到的思想说一下，至少在我心里，这是一部好电影。 角色思想校长这个一个有抱负的校长，但是却又特别的自私，为了达成自己的抱负，他选择了屈服，虽然在某些片段来说，他有一点想反抗，如他不能忍受裴魁山去骂张一曼，但是那一点反抗却是那么无力，到最后他选择了屈服，屈服到了让自己的女儿去做牺牲。关于这个角色我不想做太多评价，他总说以大局为重，或许在生活中很多人都会这么做，自私到可以牺牲掉很多。 裴魁山这个角色应该就是现在很多人所说的腹黑吧，自己得不到，就宁愿把他毁掉，他从不介意张一曼的出身愿意娶她，到指着他的鼻子骂，这个转变让很多人心凉，追不到还能做朋友么，他的回答告诉我们，他不搞她已经是最好的结果了。爱一个可以随时为她着想，恨一个人希望所有人都恨他。 铜匠也许他后面变得很坏，但是我从头到尾都认为他是这部剧最可怜的人，他原来是一个单纯至极的人，命运使然他加入到了一个骗子集团吧，因为单纯才会认为张一曼会喜欢他吧，因为单纯所以期望太高，这导致在张一曼骂他牲口之后开始最强烈的抱负。但是有一点他这个觉得传递了不好的概念，有知识不是为了更好的抱负，而是应该为了更好的帮助别人，虽然他的行为可以理解，但是却不提倡，从他到最后还是想去美国学习，可以看出他还是很想学习的，想脱离文盲这个行列。 张一曼这是一个不畏世俗的眼光，勇敢追求自由的女子，也不能说是道德败坏吧，虽然和有妇之夫搞一起不太好，但是他自己也有自己的原则，就像他一开始不愿意将她和铜匠的事情说出来一样，他有自己一定的原则。但是在校长的屈服下，也造就了他的悲剧，最后开枪自杀了。 周铁男这个角色也是反映了一部分人，他喜欢孙佳，但是一直没有说出来，也算单纯耿直的人，平时脾气挺冲，在别人要动孙佳的时候也立马站了出来，可惜在擦过枪子的之后，他选择了屈服，他慢慢开始收敛自己，只是为了能够活下去，他甚至可以认忍受孙佳去嫁给铜匠，所以说，所谓的爱在现实的生与死之间是那么的不堪。 孙佳这个人或许是这部剧中完全没有污点的人吧，应该也是导演想表达的正面形象，他是唯一一个把驴得水当做人看的人，也是第一个想揭发整个阴谋的人，面对这一切，她说过去的都让他过去的话，那么只能越来越错，不能让错误一直延续下去。莫名戳中内心。 特派员一个目不识丁，却假装英国留学回来的官员，所谓的民间教育家的评选，不过是教育部敛财的名头，从被骗到一起骗说明政府的腐败与强势，从十万到三万，我们看到了心凉。 总结主要人物各有各的责任，他们都反应了这个世界上的一部分人，所以感受很深，点评不当之处，也希望大家担待。好吧，呻吟到此结束。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择算法]]></title>
    <url>%2F2017%2F05%2F10%2F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[引：300000是不是一个小目标，不知道为了目的还是目的，只想好好努力，功利也好，安慰也罢！ 期望为线性时间的选择算法算法思想： 检查数组是否只有一个数，如是，只好返回该数 采用随机分割将数组氛围a[p..q-1]和a[q+1..r]并返回主元q 检查如果该主元就是我们要找的数，就返回 判断前半部分的个数，如果要找的顺序大于前面的个数，就递归调用后面的数组，否则递归调用前面的数组 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Random;public class Randomized_select &#123;public int randomized_select(int[] a,int p, int r,int i)&#123;//如果分割到只剩一个元素了，那么就是这个了if(p == r)&#123;return a[p];&#125;//随机分割int q = randompartition(a, p, r);//确定q是第几小的数int k = q-p+1;if(k == i) &#123;return a[q];&#125;else if(k&lt;i)&#123;//递归调用后半部分的数return randomized_select(a, q+1, r, i-k);&#125; else &#123;//递归调用前半部分的数return randomized_select(a, p, q-1, i);&#125; &#125;//分割函数public int partition(int[] a,int p,int r)&#123;int x = a[r];int i = -1;int temp = 0;for (int j = 0; j &lt; a.length-1; j++) &#123;if(a[j]&lt;x)&#123;i=i+1;temp = a[i];a[i] = a[j];a[j] = temp;&#125;&#125;temp = a[i+1];a[i+1] = x;a[r] = temp;return i+1;&#125;//随机分割 public int randompartition(int[] a,int p,int r)&#123;int temp = 0;Random random = new Random();int i = random.nextInt(r);temp = a[i];a[i] = a[r];a[r] = temp;return partition(a, p, r);&#125;public static void main(String[] args) &#123;int[] a = new int[]&#123;3,2,9,0,7,5,4,8,6,1&#125;;Randomized_select select = new Randomized_select();int num = select.randomized_select(a, 0, a.length-1, 10);System.out.println(num);&#125;&#125; 算法分析：期望时间复杂度是线性的O(n),但是最坏的时间复杂度是O(n*n) 最坏情况为线性时间的选择算法算法思想： 将输入数组的n个元素划分为n/5组，每组5个元素，且至多只有一组由剩下的nmod5个元素组成。 寻找每一个组的中位数：首先对每组元素进行插入排序，然后确定每组的中位数。 对第2部的中位数数组利用递归调用前面的random_select()求取中位数x 利用修改的partition(),按中位数x进行划分，得到比x小的数有k个 如果i=k则返回x。如果ik，则在高区递归查找第i-k小的元素 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package select;public class GoodSelect &#123;//插入排序public void insertsort(int[] a,int p, int r)&#123;for (int i=p+1;i&lt;=r;i++) &#123;int temp = 0;//*从后往前插*for(int j = i;j&gt;p &amp;&amp; a[j]&lt;a[j-1];j--)&#123;temp = a[j];a[j] = a[j-1];a[j-1] = temp;&#125;&#125;&#125;//对数组A[]分组，每组5个元素，分别进行插入排序,返回中位数数组public int[] partInsertSort(int[] a,int p,int r) &#123;int i = 0;int[] b;if((r-p+1)%5==0)&#123;b = new int[(r-p+1)/5];&#125; else &#123;b = new int[(r-p+1)/5+1];&#125;int Length = r-p+1;if (Length &lt;= 5) //元素个数少于5个&#123; insertsort(a,p,r);b[0]=a[p+(Length-1)/2];&#125;else&#123;for (i=0;i&lt;Length/5;i++)&#123;insertsort(a,p+i*5,p+i*5+4);b[i]=a[i*5+2]; //B[i] 存储各组中位数&#125;if ( Length%5 != 0 )&#123;insertsort(a,Length-1-(Length-1)%5,Length-1);b[i]=a[Length-1-Length%5/2]; //B[i] 存储最后一组中位数&#125;&#125;return b; // 返回分组的个数&#125;//调用random_select算法，选出中位数数组的中位数public int selectmid(int[] a)&#123;Randomized_select randomized_select = new Randomized_select();int num = randomized_select.randomized_select(a, 0, a.length-1, (a.length+1)/2);return num; &#125;//安装精心挑选的中位数来分割数组public int partition(int[] a,int p,int r,int x)&#123;int j = p-1;int i = 0;int temp =0;int addr = 0;//记录最佳中位数的位置for(i = p; i&lt;r+1; i++)&#123;if(a[i]&lt;=x)&#123;j+=1;temp = a[j];a[j] = a[i];a[i] = temp; &#125;if(a[i] == x)&#123;addr = i;&#125; &#125;temp = a[j];a[j] = a[addr];a[addr] = temp; return j;&#125;public int goodselect(int[] a,int p,int r,int i)&#123;//如果分割到只剩一个元素了，那么就是这个了if(p == r)&#123;return a[p];&#125;int [] b = partInsertSort(a, p, r);int x = selectmid(b);int q = partition(a, p, r, x);//确定q是第几小的数int k = q-p+1;if(k == i) &#123;return a[q];&#125;else if(k&lt;i)&#123;//递归调用后半部分的数return goodselect(a, q+1, r, i-k);&#125; else &#123;//递归调用前半部分的数return goodselect(a, p, q-1, i);&#125; &#125;public static void main(String[] args) &#123;int[] a = new int[]&#123;2,1,4,6,5,8,9,7,11,13,12,15,16&#125;;GoodSelect select = new GoodSelect();int num = select.goodselect(a, 0, a.length-1, 13);System.out.println(num);&#125;&#125; 算法总结：毕竟是三个人发明的算法，真是好牛逼的，厉害，实现了最坏时间还是线性的。具体分析请参考算法导论原书。 总结第二个算法真的花了自己好长的时间来调试，还是说明自己的编码能力差劲，要好好努力，慢慢提高，加油！ ps：有一种体会，学算法是为了创造，大多数人只要把优秀的源码包里的算法理解了就好，并加以使用就好！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“线性时间排序（未完，待续）”]]></title>
    <url>%2F2017%2F05%2F10%2F%E2%80%9C%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%8C%E5%BE%85%E7%BB%AD%EF%BC%89%E2%80%9D%2F</url>
    <content type="text"><![CDATA[引：排序慢慢来，今天要接触到线性时间排序了：计数排序，基数排序，桶排序。 计数排序前提条件：知道输入数组的最大值。代码如下：12345678910111213141516171819202122public int[] countingsort(int[] a,int k)&#123;//初始化临时数组,k为数组的最大值int[] c = new int[k+1];for(int i=0; i&lt;=k; i++) &#123;c[i]=0;&#125;//获得等于i的元素个数for(int i= 0; i&lt;a.length-1;i++) &#123;c[a[i]] = c[a[i]]+1;&#125;//获得小于等于i的元素个数(隐含了递归调用)for(int i = 1; i&lt;=k; i++) &#123;c[i] = c[i] +c[i-1];&#125;//按顺序分到输出数组int[] b = new int[a.length];for(int i = a.length-1; i&gt;=0; i--) &#123;b[c[a[i]]] = a[i];c[a[i]] = c[a[i]]-1;&#125;return b;&#125; 优劣：实现了线性时间，但是空间损失惨重，像是叫你排序这三个数：1，3，1000000000000，马上高低立见。 基数排序IBM创始人发明，利用进制数的位进行从低到高比较。其中会将原来的数转化为r进制数，使时间复杂度变为线性。写一下伪代码123redix-sort(A,d)for i = 1 to duse a stable sort to sort array A on digit i 桶排序桶排序假设数据服从均匀分布，讲一个区间分成若干个桶，先将数据放到桶中分开排序再合并。伪代码如下12345678910bucket-sort(A)n = A.lengthlet B[0.. n-1] be a new arrayfor i = 0 to n - 1make B[i] an empty listfor i = 1 to n insert A[i] into list B[nA[i]]for i = 0 to n - 1sort list B[i] with insertion sortconcatenete the lists B[0],B[1].. B[n-1] together in order 它的期望时间为线形。 总结其中对于基数排序和桶排序理解得不是很好，需要加深理解，写出具体实现代码，未完，待续…]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性时间排序</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2017%2F05%2F10%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[引：真的是烦，连个hadoop集群环境都搭不好，发现一个人学还是很困难的，想想还是一个人看算法会简单些，所以来看看了，今天看堆排序！ 堆排序简单介绍堆排序是原址运算，后来由于Java的原因我用了变址，但是算法的思想还是没有变得的.堆分为大顶堆，小顶堆，我们下面以大顶堆为例。 维护堆我们需要一个函数在任何情况下子节点要比根节点小。函数如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546//取父节点public int parent(int i)&#123; return (int)Math.ceil(i/2)-1;&#125;//取左子树public int left(int i)&#123; if(i == 0)&#123; return i+1; &#125; else&#123; return 2*i+1; &#125;&#125;//取右子树public int right(int i)&#123; if(i == 0)&#123; return i+2; &#125; else&#123; return 2*i+2; &#125;&#125;//维护大顶堆public int[] max_heapify(int[] a,int i)&#123; int l = left(i); int r = right(i); int largest = 0; int temp = 0; if(l&gt;=a.length &amp;&amp; r&gt;=a.length)&#123; return a; &#125; if(l&lt;a.length &amp;&amp; a[l]&gt;a[i])&#123; largest = l; &#125; else&#123; largest = i; &#125; if(r&lt;a.length &amp;&amp; a[r]&gt;a[largest])&#123; largest = r; &#125; if(largest!=i) &#123; temp = a[i]; a[i] = a[largest]; a[largest] = temp; max_heapify(a, largest); &#125; return a; &#125; 建堆在对数组遍历建立二叉树的时候，我们容易得出Math.floor(n/2)到n都是叶节点，其余是根节点，所以我们在建堆得时候冲根节点不断往前维护就好。代码如下：12345678//建大堆public int[] bulid_max_heap(int[] a)&#123; heap_size = a.length; for(int i = (int)Math.floor(a.length/2)-1; i&gt;=0; i--)&#123; max_heapify(a, i); &#125; return a;&#125; 堆排序算法思想：先取出顶，再维护，再取顶，再维护，知道最后代码如下：12345678910111213//堆排序算法public int[] heapsort(int[] a) &#123; int[] b = new int[a.length];//无奈之举，java没有size这个属性，或者用list也可以 bulid_max_heap(a); for(int i = a.length-1; i&gt;=1; i--)&#123; b[i] = a[0]; a[0] = a[i]; a[i] = 0;//使最后一个元素不参与排序 max_heapify(a, 0); &#125; b[0] = a[0]; return b;&#125; 算法时间复杂度：nlgn 重要应用——优先队列优先队列应用于共享计算机的系统的作业调度，最大优先队列记录将要执行的各个作业以及它们之间的相对优先级，在任何时候都可以调用insert把一个新作业加入到队列中来。讲一下最大优先序列的几个操作。 maximum获取最大值代码如下：1234 //获取最大值public int maximum(int[] a)&#123; return a[1];&#125; 去掉并返回数组中的最大键值得元素代码如下:12345678910//去掉并返回数组中具有最大键值得元素public int extract_max(int[] a)&#123; if(a.length&lt;1)&#123; System.out.println(&quot;heap underflow&quot;); &#125; int max = a[0]; a[0] = a[a.length]; max_heapify(a, 0); return max;&#125; 总结加油呀加油！堆排序还是强大的，期待运用！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx反向代理与负载均衡]]></title>
    <url>%2F2017%2F05%2F06%2Fnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[引：慢慢做项目的过程中，也就接触到了负载均衡，谈到负载均衡就会接触到反向代理服务器，这里介绍一下nginx。 nginx反向代理nginx简介nginx是一个使用c语言开发的高性能的http服务器及反向代理服务器，是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。感觉棒棒哒。 nginx应用场景 http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 nginx安装启动配置 安装：nginx一般安装在linux下 启动： 在sbin目录下执行: ./nginx 如果访问不到，可能就是linux防火墙没有开启8080端口的访问——关闭：在sbin目录下执行: ./nginx -s stop——刷新配置：在sbin目录下执行: ./nginx -s reload 配置虚拟主机：在nginx.conf文件中添加一个Service节点，修改端口号就可以12345678910111213server &#123; listen 81; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html81; index index.html index.htm;&#125;&#125; nginx反向代理反向代理服务器是引用在服务端。决定哪台服务器提供服务。用一张图来理解： nginx负载均衡并发量大的时候自然会用到负载均衡，其实每台服务器的内容都是一样的，多台机器服务自然减轻了单台服务器的压力。在nginx中其实配置很简单，如下：1234567891011121314151617upstream tomcats&#123; server 192.168.142.128:8080 weight=2; server 192.168.142.128:8081;&#125;server&#123; listen 80; server_name tomcat.taobao.com; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_pass http://tomcats; index index.html index.htm; &#125;&#125; 只需要在upstream的server后面添加一个weight即可代表权重。权重越高，分配请求的数量就越多。默认权重是1。 总结其实很多东西没有自己想象的那么难，好好努力，每天积累！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序及随机化算法]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[引：算法一直很重要，最近没有心情去看项目的代码与技术，所以就拿起其了算法导论来看，最经典的快速排序及随机化算法，java实现。 快速排序算法 核心思想分治思想和原址运算：看一张图 算法具体实现 public class QuickSort { public int partition(int[] a,int p,int r){ int x = a[r]; int i = -1; int temp = 0; for (int j = 0; j &lt; a.length-1; j++) { if(a[j]&lt;x){ i=i+1; temp = a[i]; a[i] = a[j]; a[j] = temp; } } temp = a[i+1]; a[i+1] = x; a[r] = temp; return i+1; } public int[] quicksort(int[] b,int p,int r){ if(p&lt;r){ int q = partition(b,p,r); quicksort(b, p, q-1); quicksort(b, q+1, r); } return b; } public static void main(String[] args) { QuickSort sort = new QuickSort(); int[] a = {2,8,7,1,3,5,6,4}; int[] b = sort.quicksort(a, 0, a.length-1); for (int i : b) { System.out.print(i+&quot; &quot;); } } } 3.时间复杂度 通过分析我们最看重的平均复杂度是nlgn 随机化算法 核心思想 在算法加入随机性，要么在使序列生成随机化，要么就是使主元随机化，这里我们使主元随机化。 算法具体实现 import java.util.Random; public class RandomQuickSort { public int partition(int[] a,int p,int r){ int x = a[r]; int i = -1; int temp = 0; for (int j = 0; j &lt; a.length-1; j++) { if(a[j]&lt;x){ i=i+1; temp = a[i]; a[i] = a[j]; a[j] = temp; } } temp = a[i+1]; a[i+1] = x; a[r] = temp; return i+1; } public int randompartition(int[] a,int p,int r){ int temp = 0; Random random = new Random(); int i = random.nextInt(r); temp = a[i]; a[i] = a[r]; a[r] = temp; return partition(a, p, r); } public int[] randomquicksort(int[] b,int p,int r){ if(p&lt;r){ int q = randompartition(b, p, r); randomquicksort(b, p, q-1); randomquicksort(b, q+1, r); } return b; } public static void main(String[] args) { RandomQuickSort sort = new RandomQuickSort(); int[] a = {2,8,7,1,3,5,6,4}; int[] b = sort.randomquicksort(a, 0, a.length-1); for (int i : b) { System.out.print(i+&quot; &quot;); } } } 时间复杂度 通过分析我们最看重的平均复杂度是nlgn 基本排序算法 小结：同等情况下快速排序&gt;随机化算法&gt;归并排序&gt;插入排序；在有序的情况下随机化算法&gt;快速排序 总结慢慢走，不要急！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git个人使用与多人协作]]></title>
    <url>%2F2017%2F05%2F04%2Fgit%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[引：因为没有加入到什么团队中，没有机会和别人一起合作过项目，所以对git使用并不熟练，但是这次比较空，就好好梳理一下吧！ 个人使用git介绍特点就是分布式了，请看下图，每一台电脑都是一个仓库，大家都可以使用。 仓库理解及操作先上图： 有个上面的图做铺垫，下面的操作也就好理解了 添加文件：git add file 提交文件：git commit -m &quot;提交描述&quot; 查看状态:git status 查看日志：git log 相关版本号可以通过reset来回退到任何提交时间点 添加远程库：git remote add origin git@github.com:username/repository 推送到远程库： 第一次用：git push -u origin master之后用git push origin master注意点：要将电脑的ssh添加到你的github里 克隆远程库：git clone origin git@github.com:username/repository 多人协作我想大家需要理解这样一张图： 推送分支：$ git push origin branchname 抓取分支：git clone origin git@github.com:username/repository;git checkout -b dev origin/dev 基本操作肯定会碰到问题： 如果你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，那么就会提交被解决，这个时候就需要： git pull 这个时候合并是有冲突的，需要你本地修改之后再提交上去。 总结目前自己所要掌握的就是这些东西了，再遇到问题可以谷歌或者百度。最后感谢廖雪峰的git教程]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String,StringBuilder,StringBuffer区别]]></title>
    <url>%2F2017%2F05%2F04%2FString-StringBuilder-StringBuffer%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[引：最近心情非常的不静，我知道自己需要沉下心去沉淀，慢慢来，小朋友。今天谈谈3个字符串类 String查看String源码的时候，我们很容易看到&gt; public final class String 从源码中对String的定义可以知道它是final类，这意味着她不可被继承，也不可被更改。而且总它的方法中也没有可以拼接字符串的函数。 StringBuilder查看StringBuilder源码的时候，我们也可以看到这样的定义：&gt; public final class StringBuilder extends AbstractStringBuilder 我们发现他也是final类，但是它却又append()方法，这是为什么，我们找到它的append(): @Override public StringBuilder append(String str) { super.append(str); return this; } 我们看到他的append()方法是调用他的父类来的，所以我们继续看看他的父类是在搞什么鬼👻 public AbstractStringBuilder append(String str) { if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this; } 我们终于找到他怎么又这个添加字符串的方法了。具体AbstractStringBuilder是怎么实现添加的就让想要了解的人继续往下看源码就好了。 对比string: 我们可以从日常编写的代码可以了解到，用String拼接由于每次都是新建一个对象所以效率自然是低的，所以在使用字符串拼接的时候还是用StringBuilder比较好，但是对于单个常量字符串来说还是String好，因为它是放在常量池里，读取速度比放在堆中的对象自然是要快很多。 StringBuffer这又是一个什么鬼，继续看源码吧 public final class StringBuffer extends AbstractStringBuilder 这个和StringBuilder一样也是final类，但是我们可以很清楚的看到也是继承了AbstractStringBuilder，也就是说它也有append()方法，但是我们可以它的append()方法。 public synchronized StringBuffer append(String str) { toStringCache = null; super.append(str); return this; } 我们看到它的append()方法加入了synchronized关键字，所以它是个线程安全的类 和StringBuilder的区别： 由于他是线程安全的，所以自然牺牲了效率，在操作速度上没有StringBuilder快。 总结：点点滴滴积累]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请不要无脑]]></title>
    <url>%2F2017%2F04%2F27%2F%E8%AF%B7%E4%B8%8D%E8%A6%81%E6%97%A0%E8%84%91%2F</url>
    <content type="text"><![CDATA[大喊一声密码. Decrypt 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]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次失败的面试]]></title>
    <url>%2F2017%2F04%2F26%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[大喊一声密码. Decrypt U2FsdGVkX18/r1ZKwkxC4M2Ltiqy3D9AU93LAcRPpYw0HLMgw26NIJ4JKp46virpNl0AGloNFP3a5F3bX7ZQeIayr11V2nZUm8mJaHTdiAmRfsU9VKUwlWibQJRU9/dgLEZ1LiBV5IVD20eIwO4OsPUcLjrJpbwbcptUG838DueYHehy7GbvKMqdXpYbhMN6JbpTEKKJWXYLUx6+oBOYq+/a16+GjYKZ9nEXBhFZBC7+v1Lsgc6bTMUJBTvTkyptKQ2wEJHsuApc8r3fitCvvHWZ8k2AC8ZK1rAycbLq6IASOMj5ae873N6sRX5et0rAFKyb5XFsxIwVIra8XoOa30Br5uLSH0aTwMxF6SfPSKl2GOvzFxHjNnwSUOMU4KarwJOQcZTUw+b7YZoebLLzzMJiwXB4ugokI8BjhR7ZqZAT6JSn4Am8l8klGMEyjP1nXUyDq6mTAHxu87jgy2UdL8Q28tbKEV1tevV/sxEJXXaL/1au+NJqO/00RRLZCwq1L8zVvSwkFh6huAMIX10kfXw1+owK3yjSSLawgYxcj6bQvInLf0oPt3w2MMy37Qo97m1FhLXUVX86N1GOOtnpvafctooTjR/Dtnqr9jh855mxbXaBP8NIhT+6QD6+tTKjOjuhMKJA1GbdcgrGdqlLqELV0ze7nDs0xgyaFemdIi2Xnt6UrV1szsq+tBN2neTiyd6LU/XpRHvnmkEEdkbiv6qlJJ/y+3I3SMWFIu93QwuHo+EgBl4yhRohvPD9Ujn+yBje+WszZuN+C1C1GsyUhHfMqQHy6bXzPNdNZT+NoUoUJZmin6Tju22OKi8udj4cz+7EepwPtqE44Jr7SwVoEpIU603RAeF/jDjou0DAliZ2yxUryuf3h81OFn1HimSpQkkCW+kCiSouwb0IleS7HzI9KsU3n+1zD0s+Q2XIkuVIdd72E59Npwf7BI0b925PTEx4x4Pe5BtZb7CDLh6ZMVyCM+/pnJg49UVCmfRRpz+T6RpJIU07FyqH52p5nyAwhPfwVfMtIQ3OhmzKK2xMj2xfWNrran5foWnjeLh5fVC1+3jOcCk9Fa8XvDT33uHu55VXkSMSRZ6HCg5tDcOJuHKoqqmXoqVL4eO+EUCCFAKkqmhvjTefXOcMBrtrxKcb50xvjpZG3GA42+wZ0aXGjcb+zH+wj45mzqn1+aYZaPhEF1wX7W1bXeL8J7d/jm1/Tym5IAkNqvGsz/KuVKfuxBUEmSCnOr5d9hvUhcoXcCkRuy3vABvXhBhxv+mudq8sVcyd/xYicLPJuhGmEdIowg/gEjStwtsEx995kLJBHSNobzqujMk176b1PvdYPUhaLX9ffoxe61i1yF27PaKFuPP80eOeuejSkvYbvWwaNxw039nEGVW4NlcmTw4e0dRMcfumYQnfvbBMavRv2H+MOYT7eZRxeKZbtgPAHERo/+SaBcI1EOOufHYkWy2OrEJV85uFVra0cy/bpLv8bH0W+nALW8uPP+E0u+l7NEtDarCdRa0VQBtmgo/h2hcF2QysfznR6cRVT5SmIEjmXF1POgYBEmulZh2TyRmY+FWRml3ffgA0I9hEHTKv5uBYpJqUDeZf/TdExPN1r+49MbpuDe2hO3UDNs9/8iFkSg4RL6L7SJoxMVv7SEIFzzwYMBZJkICOR+FBiavp3oQ2TL9xFJxe+Lt/9S/Eak5ih/j7KqtzniSWSifbwpLa2Sp5+S7NAQI2lZlbpZWRCfbktPCT1w9sCDd5f9dHMiUr9+l/uUF7tNTmS0JIdKPy/XQG3v8NgGVOyInidjpnwCOi4gkmACARAb2efBk8VfxzXzwtDBrnM37IVeLg4vfUYmo59eKFl08f+vMggtt5d6Ap9FdcZmIpqySVxyOFkjUztgp5UpgMBuOXkykFIKNh9IqPV3I3tb7lNT9cq6Ql9qDx8HHNxFW4JN+qlqLQ4W35t1u///T3EkBZyMHbHZvwGB9bo1voFCXmezCMyQSYWs16kgxO6cxCsUTqaIgPDccYeYcnWu0vPaGroazTgguxDJ5UGsW67WvwiO8WZNkuuXp0nAFNWfvjTyVkeGpN/sW9LAknr+8DS8LHAc1NI1Rs9WyL9NL8TRB+VcLs6w1xuKtugt6/GK9CPE4qPKwa9H8BNccZa/RdyNYx9tTsjTi/WKgialAWuU2aCpaAwcU/yyPgHOAwYOOoeS4+GobLNftNAY3tBzdf8DiTOy1HjwXOePfSWXhkpxbwN8Q1/RDur7FlzgM2FaDfusqRaea9Zb46/j8Ujb2iDrweK9XzvqloxP6/IjlACtJzWaHeFcx2sROKeztJxne8u/bJqccz3+ncbyvD9s9BCrOuA6SO8qVtt697ANGjKLwYDEU5W1IhLtcy3s2FPB29z3BNR7nUH7AfR8/qounoLUoT1c1B2Wc0ixs/sadBEZsFNFQcEy39fHPoPgTM2kqqOrsGltEmOscZH57vkddtqtEs2GovpqGssQU/vfkCEvwQM+L4BZJ6CBKIsSRzKnPo9z4vdmF35mgy9tLIDzDoaLd9ZrO+H3rcQlwoI3BYXJX9/H7Bs9dc9MoMm4rG8Nxc2ITbF7C2i8QBF6BWAf7cRILeJ5j1oE8FP7S/MktWYwUfuZcaTqq2gkLzgpXfIeXjDhl5J683Ztlg9F/jALm18Kub+En9jC1OyvngPKgfsPheKhnXMRZOYRhUqOejwbtosATaIbHXXiY6TZubMDJkGeYDVZ9Xwl4VmSmcK/feDLEiqnOPstyqacZaBbNDyEcwENQ9sONI7LGvgQ9/6SdXv5eGH0xWN7AZVa7zbgAwfrsBJadnG2ygkRuJalqRUx/5LpDlxM/l314dTi4t3IYDMPnlg3diqb/cMBy/lxu0BPny4Qxmz8WWDaOHinNhggWLOhAQsrCdgEJHOdhIEsKeJuoLtwx32Qm00AdhX21iPqjfNuX0e/9s0vdekn057xQdzGcnqXMOKk5f6hYcuKyLvoeuc6IJnAUyJEuzZ3xAloTETN8AH7Dc3J1aurPjRy7E7pwQkDh+NKRaVtEjXZ/eVjwfffvdp8lnZ5vJedXuHjFlBXraTOcPaD/oYFoO7yoW0p1VfsSFwI2Fmi3qvjm5JWH8pJNZjR4NLn8G0dqtjjN/x9AxUXm3mDPibuFmHJvlwliky5h+7Axz3giYC+ZejBTPstu7zF9AwEafxVDeRRw8n06h24qhTzUfA64rwE2Tt3Y8ymYaIuq5+y0yqcURzEmV8YE8eH8vjUILnxc/M56kUrjawTtd4Sd6zdbnGmgfBJKLFyXWxsDZ+35bApQU6h+M3xaic1/b4EB74XnHuB7bujBNjAu9p3oY/JuvFEipuAKh7TG2V92Nu1cXOe5nK5o78CIohOO2Td3VYJtyh3nbA7nc/kHS4Z9vCB9Y8/sU11Y5HShH9tuu6wGI9v9Eky6pTOUuy2vhREEXQuw9IK5PHaLWnzvxVcdHM50M+ctfWAtyv6pSpz6NTNeiX9r1qslGHh1Yby67QlOEIRU2qVcXCaA4BeNlb7TusdSw3vjmhz8AKtQrtnN58tQURgJVFxCnYMqyaOfFTK3AFah4t1fRWpr8xl+TFwa6+W3p6JqrIuO2Y5b9XiMSqoyp7t1nUeRUk3ysnKBGdoqECNc3EiyP4WcBTxaySV4+1YI7ByJj/syKbocJmkhXpJtHHfOksvhI/EEvL79owGfu2WCb6N8kBUgwvVci6Ip+fvpZmPP03eClnx9BSa34U+kiGAMuTaD4i9NASAIosLZr1xFyclSHdtVM2Cd1Gr8mC4v2OYNCsFW+YuTo6+Wt+Ui0oS9AuKpy4we7o/+5tykOG2sRmKsi1+O2+4e/0o5A8gFKW7VLi6+6F0VaxabCZzZYV6r5KQe7MJZlN+45YdGt079fJo8VFlrTnMAyiLp7jshcwfxVucqAELeZH/Hx87xg90J+fecodJuqUkNkSOYmbG5s1r6fj541pYzj4K+NA5AcG2TJ1Dh8sOBNG9FepXStRHrEhIl0HcKB42OByQsWj6Cb/cgEw18n7AmGCFX8kjNw4+/9fWUdZtg5YcUcfaGzqqbplwbCuuGw/qiEbgVvV83Tj08bU3SRaPE+6kJG2iPH1/LSMptsl6UEUKvVv4SAcd13zc/XFoAU7m4YshzWwoTidqnLO3L1726O15oYopM0KhXDmfYBZBqusefH3DgvePJjP/vNwzsW0LDCyWRbl8NtGpMdNq3Q1TWAaLBrV34FmMXgqAIEb5bEm6M0TPd+XRRSGHOSiM6fSo9c1gtmUrSVLxhYv1QEzEToJ0XUGGDjUwZeRhfh/CgDFv3yrs+cfcKCMmkD6kVWLJ23mLMEjskt3okI8YLssnqLvck2VYAV4VvZK4zxrmnjDUZ+JBOmK6fMXf76pBhLU7rEw/Wosl2QMPC9AKLuXTMix7gwSlOF/U1N+owy081rHd5PQcCDxMGGmi2XrNF8LJPWF6saoDX/sUsfddO09aRhye4VZLcJQI3ruov7wJBVEgqZ4BqrhAQ35oaDcMzQ1ddYkRLQsAEPZPRZy7J+10Jdr+zFakDB7VoInbYsNXwH6rsguT32OOjnhsToGSvX05Yef46S+k5+QqDBLKBaRqAyiosOhX81RZ1r2dzwgYkyYsO3BmW3WenPlr41J6KeCmPtNGJp16QIpf5g/1ulJXZadaNyP+9yIciINWrWPLa3R7koVxSE5WtZmem7DHnYWyK5Drgwp/6c4v4NiAWaSoWBMnpgFPxccsniOdoYP8newHHjyK+ci8tmGS6t1eIanx1X1H4r9f/VuL1gHAvyrXASY2UK8KSQUQPsjf55TrPqoUlJsqLoNgJENW4xU0w5tiChcCuO3HVNw5NGgWSw80D/VY4/r//6By0T8nIG+LFToN2Ul5YNjtFRla/gK6UpTPJDrhC8YAbLNjpvzxJ/1dF03cfVkT7APsWVJlr7PNxx/nkJQcrlU/M1mXPunJdU701n58kfWOOY2R82nMpQW2QGdCkVP2oYgjQSgbAJmXG+3wYheAfBkant7vnLC93CpQy3a2aM7zmT4sK6hLt4ngLnzDhZJf6OnjcpbDqAIEJgRF80l4zGmPJAWWdROWhSRMo4/abV3MQanxylmYXbVf9rh3Ho5r70V/cKUzvJtMSuuMaqFXXchslypwJYsPHaGYVz7rRbesz7yG5KwGPUTLXkHEs6cZh+5wM3vdLX0ncLz0lUiExNkRRqXHHrSuYi8FOyvS61N/rRetnRQC0NjsBplkZk0Mw4+x5QxJ/34RLT2Pm/HN75/KaoeYbh7hTF5Z/GpYQmn8MAe3VQJxJ0iRTINwwmiPsOmTyheqLoqgWij3w57c7cAJJRUbsGl1pyxVG/59YYBMpY6w5ZjEMOHisTW9xtnChvHLuVJTR9revOeTRJw45Yb6LaabTPQnywecPiZkT8UGa/Ii5waC3a8zvL5btSRDPCFId66A6ROBOvn1baI593UCQJSbeNipxsaMehlbdJq2vmwHhycvDUAlvZQTcYbzx8nvfg3Dd/WKdCX9p13Lpu2grqAhPRMJWST3nD7fyo6jBKn3IvdRLW6rNescZkzcqt1OYWIFu5hTY37bHJPc4jmmm8JD570myFYDp7Xu22gJ4c+gypxpW39jiOAphfe866oQRU4WkHcuOF1/d0vDkOnaQCPekEI01VXLz1cCrVeVdDE6dfdgEOecNrVMOHSs4tRKBJdtMPINY1kApYrOdSxGlThQTtkld05agYZe9yXxRvPCrartjFJP4ZoIeRq2cv+nD56T3/lXqmGcdxrTN/cSdr7HdZtHu49DNzikuL7HyTqCvKXuxmZs8Aki9DSQ0X7N8QxmAb2Ydau8YA9bt87YslB99X4ruTfT/WZSjd4TJgKkOjk+A5Y1PgzEpJ+BOpJatHEQp/UooRC7LtkHBAnccsrn+Y8T6OabsyO4oSODHROdkpjv9biu5xm90IgtSmzGuBrN8rtmANAjhQlnCmtTBguzkJEmZF6rnPMJtNS0m0dBUQr/5umYu1qUB3MudbN2YKKMMFQMpt3oKMLf3ACdDGGyrWXvvAmsIA3b/UsLqdHbBkvu/k3Ua6+c7RAqQzZkne9RUV4lh2ZSSIcix5mU+YVsDIvPLe8m6xNj43FIudR3k2qJjvxsNu9Mb8xz11itoXk1SHtB7EsvzY6O8J1wG1inTWoXUmiNXupuINBi3y8xfb6lE4l1vF5HdZ7Spo0ct2bUIcAcxFj6iEC7aJ9b7NsVnbfd4AtdRNIZtK1XfR0DUAUjl9j16gKrDsMCJtDKQWLEZrntigHvHuhKQlqcKHwSJERE9zljtLjnQXql3ufWzVTZAoIqNNwZ62DtGDw4+fCqToxy0uiN0Q3s4msF1jHz9YuRMEdkl6DV1cYfDjZppyLiKbEEovVLNmqiy1KbTrKR2mmbPf+k4yudzx8iIsYrAonUjHqDR76TgIfu3lZoSW+CIU8MS513GV0U6diRJaXybRuE5kVDcgGtK+lckSeP4kYnewreRDU9dTwUxDuaCKgxmifncC50s57mbWtUySUBPAPpfBnYnAfpE4FbQISDR0tO2X0HPVLkROfrU+FXeu5jcQnXcg/3bduSKT/0ubq8vkVncECSM0Gf5lg9u/w9IpuKDIo8oHW9fU87hWTcF8Pgb/veMYmXJaYk7Ocrmar7fMd8UxOGCq7LISKCyrc5+lpw43K0lCoVIKojD5bZ3MuVHf006MXaWrvI6U3BV+qh/DljY1aCHVeX7Fi+Gxs4nDPKl+0eBFBvDb3mYan+Uq22WTVOD8E7hbnO01UAtyWmzBRR3HwPSJMncqJTwiQbHjPtG/1SeDCE1NgpnGZtzwD8nmWdF3UaoZWpK6QV4OQxfsvcs6YMRBR5wH8aSXP6CWQUjqeqwTxifdIlM7RFCMv7ftqbOT4cU9xQCjC54suaAEpwtV2BgUFYNbgAnDDkUmK+hDkBHTub1WLq3+Xw0Z5mEOzB4pUexYG2uqP/fubcgFylcKERKfUd5yKgpvkeWwo3D2hBUBo7S34RwmmCBNHQB63ZC7sEvwGw7HK6GrF9fgyQWoPuTvnYFxT53metCDKhlOKrxI7rRi2PSkAZAgpLzNto8X+0fwOU+wIYcWwbHEfXctOkCPEDfVuyxnpEJ+sNSavnH4CGoFzjVGZc2Y++oe7ogoPrijn5zWzHQIjfth6PSlR/OJsGSG5vLJdLL7pTUXqWz0rwYm+iswsqpWPbaH/m+kVPr3csyS78tWBK9a9YIUMsnTLnwkxhrVXRZIvfYXCoJhckqrhPM97pquL2EzpsQVIG9ixndR6gw18hQ3dy9hlFNFaJEpSO2fFTFKIyH3NA4rSZOX1XgSDhXM7oFoXeQYnKW1JShU1tjQqVbpWNrDzgrorYlSdLT32r1rr5pmxcSB8RnR2hSoSEZgmIKDbCUXqYYRH9CijIlcCOMYgI20YwbDoGkcwOCCYm4hNn5NRL4Hcv4fKFSt4lWVPdGT1mfw4VrG4F6JsuU51La/EbcXKMeKWCMjWTxNpzem+dQF1YH8FcGtX1lH8aVZA6yrBkgzr4ugjSRUOlN0YyTQUceYiPLSj5+dDL0QW4PNrcIIQGY0lcK2dRc4/jStFNPPiX4pPg2W+UiJf3VF4HsIu2M01UCvF1uiC/U/YhhcL0HPqNwIeGz6Va6vnHRrAsYOKHmJoWu30m8+g3/RYHk5SiXDj3+F0JpyykwguWXrCOZmoEbaah3yM3eExUd5rWI73/TFMOykRTVCxrdOx82KnS9ntDsqZm4XWaVKhfPnGinebw2PexO7LCOiudOAWvIjvRNnXLwn5fCKqbOUTfrg+bswFM6pdoqLBtVW/YAcAb9Q/UujShTu4KrdNMwm8wre69TgC64uE1b9ECSLNfuXaf7UNPbame9X2aY6rAiIn5NqkhbJPhbWtyUZ/i3LzIAgpD7oSX2Cl57ttTrQzgUTQDTyAdPU0LIibN4t11SYafvWRa70CRA+FvbuKU0P6EFI8tFlNx2W1LD7dRZjpWZ9u/JTnLK5xfgQvtpimEMUQ3YUsDowq3sQZxMhXjdowthdueI6pW2btZhH1vkrLPa/I3cjbH+l01qAjEjxzUnJyqBEd8DPuCMeEvdTupAEuaM2omquNgIxD/uKGVuVh+FwZkkKbJHKliTlIWXiPsBPmmXv/imOYZWCjqQRtcwCOFRfjnM2T/UBcYEocAy5pnlZDNf0B3ItOKUFxVhc7uio1sldT5VPMONy4rjNshHObl4nra4GXfhlVrzG+/GsHrrAo0wCFALkRn9cL6HQcf98hSjP+HjRz1OA6mNls3KMUYb4bImPAqK0v822njJKv05ihxVG5cGVRpNAOx0aE4rTS9l6q/yCj0F4sKCku7A4m6TAKaqCUprWD4hNFFW1Iii1BjEP0NaOMTMJavHdTgDokARSqEfm/o8EkR8XS08cqhq9ak8Dwhb87knP9zxLvL6cWcJtz0iE0HZOGzWFD0vYiVgaqU6EPfmR4SAjzXcLkaJ6HMS5I9HA5uzOxceKQMtukBx8MbJc0h+jMj87yMB5ByuYE/IjgyYSAurnwHuQLr4TbujdWLB2oS/vssgt7TrCmAw1pCfQwZ5QxVJS+EKgiATUpw+L17iGkaMDbizc1a6Nirw1FJoi8ADphTPDUOVz+2DFeT6Bij25C7nvEGXkLjkxXOJO6g1ck0fgb7q6ZRMzv+RRxgN2ICxm+sYoanNXF8z55tB1Y24n8amooe0JZor1RKqOY5YeHMYDndf0NEAxueBrhx1PTMLzCCEKrHaEpB0xSJCfQlN7ZMIoALw+8R+BHao3fMAoFU+PKwWO3gEqFKiVg2jMTudB3QbKxYNNAja6L8VTinByFyLq/v1uPumY38moIHwOG0MHcYiQIkObB8umT3q5i6kdxI/3q0XY0z4qnnivqqMVtbCmG+hb4E0SQqdDm4DCyypQblQVCwExnPP0a5chCsRpq8eBfoU1HUJ5FonUE6sMxFTTczj52EDnlxTwnI77OWd/5N2fwXD3bz29iYd0LGhjtB5lGh8JycBDZzMYinqGFbXPjzrvQ0gQ0kGISdx6ua8jbutY5f9T5DhCYL7bajl8rcjDCEmZu06ZkcazrTekBwVSM+QzgVOFpYEvFGEp0FzytPxZW6M81kG6JV4M2GvANrgfUYs7T16C6jltww/bm6Cvxf115xV/qAHq8nHCGFqmsQMWPg5UGdYN+53tewRv3iFrUv1itzB9wxRdsrSMY8CsPhKS8LNkH2lgKgziD5/+7ZpHW4v157quuGRRHPnjhyUGkVvkNyMNRdHazblXJoE6sPGbqNTLqUd+A/nH6ZaVu71gWgMyxjbUZ/K7McWBhdBQorvfw6Nrq09nu4DbHELsvSbfW/shhKSQKWvqFjhVxMb1RV8ZFl6FWCstTrhVyZoWBHQt88WR4IfxkcZBVcdEfmIn4XwGSQZZlpFAgoe/Td928rcsO3Ylzku4i8ds76OqQBlNPZTswUwyvQ2YYUzegzQPfeQ3O/BDocU0SEkrP3GfgrT1DI4vsThb9dBhJcyD0Jx/Q4WHMyc6ykmLtNQjaURbz6CVdTKCuzJUKqjxvzNVa5aIYJbvHIFUEqWxl0uTcbpehHzeIPGMctchR9Y98NK0tqq5BX74q2StFcB/]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH项目初体验]]></title>
    <url>%2F2017%2F04%2F24%2FSSH%E9%A1%B9%E7%9B%AE%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[引：历时四天，终于在视频的帮助下完成了基于SSH（struts2+hibernate3+spring4）的一个网站商城项目，也是自己第一次采用idea开发项目简单，谈谈收获和感想。 代码流程 导包主要的文件：导三大框架的包这里的包我也不贴图了，都是最基本的jar包 框架配置这里我想说的是三个文件： web.xml：配置struts核心过滤器和配置Spring的核心监听器 struts.xml：配置各种action applicationContext.xml：作为大管家事情也就比较多了，有配置数据库C3P0连接池，配置Hibernate引入数据源，事务管理，管理action，service，dao 按层码代码 分层架构 web层主要使用action进行控制，这里使用了动态匹配，如userAction_*.action其中要点： 值栈：对于单个业务逻辑来说存取值实在是太方便了。 模型驱动：对于模块的对象使用模型存值也很方便 拦截器：对于后台范围一定要对访问进行控制，若未登录，请先登录 ognl表达式：可以进行运算，除模型驱动以及值栈内取值之外都要加# service层本次项目并未多少体现出来，我们只要注意添加spring事务注解 dao层此次使用的hibernate，要点如下 实体映射文件：对于主外键一定要设置正确，懒加载问题，级联删除问题 hql语句：join的用法，面向对象的语句编写 项目模块这里只是简单说说作为一个商场应该具有的模块 前台首页；前台用户 ；一级目录； 二级目录； 商品； 购物车； 订单 后台后台用户；一级目录；二级目录；商品；订单 查bug方法即使是按着视频来的，但是也还是会出错，有的时候还查了一个多小时，bug：码农的一生之敌呀！回到正题：首先看控制台错误，分析错误类型 前台传数据错误可以将表单的发送方式改为get，这个就可以从uri中看出错误了，自己好几次入坑，就是在参数填写的地方多了一个空格，欲哭无泪。 业务逻辑代码错误其实最简单也最烦，就是利用debug。按逻辑顺序进行查错。 数据库查询出错可以充分利用控制台输出的sql语句进行排错，将sql语句放到sql桌面程序中查询，是否与自己想要的结果一致，如果不一致，就很有可能是自己的hql语句写错，或者映射文件出错了。 感想关于这个项目架构都是比较简单的，业务逻辑也都是CRUD也算简单，可能还有最重要的高并发问题没有考虑，但是整个项目做下来，自己也算理解了整个项目系统，但是自己绝对不能以CRUD为终点，继续向前加油！！！！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iis实现手机端访问电脑本地服务器]]></title>
    <url>%2F2017%2F04%2F24%2Fiis%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E7%AB%AF%E8%AE%BF%E9%97%AE%E7%94%B5%E8%84%91%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[引：对于很多没有服务器的人来说,实现手机端访问自己写的网页还是有困难的，虽然我们可以可以利用githubpage来实现挂载页面，但是调试起来还是不方便，所以iis就成为了一种简单的方式。 iis简介iis（Internet Information Services）是由微软公司提供的基于运行Microsoft Windows的互联网基本服务,其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。 iis安装这里我就不多说了，网上一搜，安装教程一大把，这里推荐一个链接安装iis 有无线的时候使用大部分人，大部分时间，大部分地方，相信大家都会身处在无线之下，所以只要按照上面的链接使用就可以了。 没无线的时候使用这个时候就要借助流量与热点了 打开手机热点 查看电脑ip地址一般这个时候ip地址已经变了，所有之前按照有无线的时候电脑的ip设置访问地址就有问题了，所以要利用新的ip地址设置访问地址 用手机访问新的ip地址一下子就爽歪歪了 总结 iis对于windows用户来说真是出家旅行，调试代码必备之良品。 当不能访问的时候一定要随时关注电脑的ip地址是否已经发生变化，做到随时更改]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
</search>