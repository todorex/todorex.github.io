<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解JVM_4_垃圾收集策略]]></title>
    <url>%2F2017%2F11%2F29%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-4-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[引：Java与C++之间有一堵内存动态分配与垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。那我们就先来看看JVM到底是怎么进行垃圾收集的？ 垃圾回收，回收哪里？之前介绍过Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，这几个区域的内存分配和回收都具有确定性，方法结束或者线程结束，内存自然就跟着回收了，但是Java堆和方法区（元空间）则不一样，我们只有在运行期间才知道会创建哪些对象，这部分内存的分配和回收都是动态的，所有垃圾回收就是回收这里。 对象已死么？垃圾收集器在对堆进行回收前，第一件事就是要确定这些对象之中还有那些还“存活”者，哪些已经“死去”（即不可能再被任何途径使用的对象）。 引用计数算法 给每个对象添加一个引用计数器，每当有一个地方引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器为0的对象就是不可能再被使用的。 可达性分析算法（Java使用） 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径被称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。 在Java语言中，可作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性应用的对象 方法区中常量引用的对象 本地方法栈中JNI（即一般说的Native方法）引用的对象 引用类型 强引用：类似”Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用：用来描述还有用但非必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。它是通过SoftReference类来实现软引用的。 弱引用：用来描述非必需对象的，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象，它是通过WeakReference类来实现弱引用的。 虚引用：只要发生垃圾回收，它就会被收集，它唯一的目的就是能在这个对象被收集器回收时收到一个系统通知，它是用过PhantomReference类来实现虚引用。 方法区（元空间）的回收类和其元数据的生命周期和其对应的类加载器是相同的。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。准确的来说，每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。 垃圾收集算法标记-清除算法流程： 标记出所有需要回收的对象 在标记完成后统一回收所有被标记的对象 不足： 效率问题 标记和清除两个过程效率都不高 空间问题 标记清除以后会产生大量不连续的空间碎片，无法存储大对象 复制算法流程： 将可用内存按容量分为大小相同的两块 在第一块分配内存，并标记出所有需要回收的对象 当第一块内存用完了，将所有活着的对象复制到另外一块上 将第一块所使用过的内存空间一次性清除 好处：解决了空间碎片问题 不足：降低了空间利用率 现在的商业虚拟机都用这种收集算法来回收新生代，因为新生代中的对象98%是“朝生夕死”的，所以不需要1:1划分空间,而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还活着的对象那个一次性复制到另一块Survivor空间上，最后清理掉前两块空间。HotSpot虚拟机默认Eden和Survivor的大小比例为8:1，所以只有10%的内存会被“浪费”，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。 内存的分配担保是指如果放着存活对象的Survivor空间没有足够空间放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。 标记-整理算法适合老年代 流程： 标记出所有需要回收的对象 让所有存活的对象都向一端移动 直接清理掉端边界以外的内存 分代收集算法将内存划分为老年代和新生代。老年代中存放寿命较长的对象，新生代中存放“朝生夕死”的对象。然后在不同的区域使用不同的垃圾收集算法。 总结从上面我们了解了对象存活判定算法和垃圾回收算法，但是不同虚拟机的具体实现还是不同的，而且不同的垃圾收集器的内存回收的具体实现也是不同的，我们要因机而议。 参考 《深入理解Java虚拟机》 JDK8 从永久代到元空间]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_3_OutOfMemoryError异常现场]]></title>
    <url>%2F2017%2F11%2F29%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-3-OutOfMemoryError%E5%BC%82%E5%B8%B8%E7%8E%B0%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[引：之前面对JVM运行内存的分析，总会提到出现OutMemoryError异常，接下来我们详细看下常出现这种异常的现场。 Java堆溢出我们通过限制Java堆得大小为20MB,不可扩张（将堆得最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX：+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump（备份）出当前的内存堆转储快照以便时候分析处理。 代码如下：1234567891011121314//VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryErrorpublic class HeapOOM &#123; static class OOMobject &#123; &#125; public static void main(String[] args) &#123; List&lt;OOMobject&gt; list = new ArrayList&lt;&gt;(); while (true) &#123; list.add(new OOMobject()); &#125; &#125;&#125; 运行结果：12345java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid81611.hprof ...Heap dump file created [27573572 bytes in 0.121 secs]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3210)... 我们很容易在输出结果中看到Java heap space OOM出现在堆中。我们要解决这个区域的异常主要是通过内存映像分析工具（很多）对Dump出来的堆转储快照进行分析，重点确认是内存泄漏（Memory leak）还是内存溢出（Memory Overflow）。 内存泄漏：被分配的内存的对象不会被回收，永久占据内存。 解决方法：通过工具查看泄漏对象到GC Roots的引用链。 内存溢出：无法申请到内存。 解决方法：检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长的情况，尝试减少程序运行期的内存消耗。 虚拟机栈和本地方法栈溢出我们说过HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，所以设置本地方法栈大小是无效的，栈容量只由-Xss参数设定，在Java虚拟机规范中描述了两种异常 StackOverflowError异常：如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出此异常。 OutOfMemoryError异常：如果虚拟机在扩展栈使无法申请到足够的内存空间，将抛出此异常。 我个人想如果单线程中栈的内存大小等于总内存大小，那么上面两种异常应该是等价的吧，但是基本上是不可能的。所以单线程中出现得基本上都是StackOverflowError异常。 单线程代码如下：1234567891011121314// VM args: -Xss128kpublic class HeapOOM &#123; static class OOMobject &#123; &#125; public static void main(String[] args) &#123; List&lt;OOMobject&gt; list = new ArrayList&lt;&gt;(); while (true) &#123; list.add(new OOMobject()); &#125; &#125;&#125; 运行结果：123stack lenth:18855Exception in thread &quot;main&quot; java.lang.StackOverflowError at com.todorex.demo.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:10) 这里抄一下书的结论：在单个线程下，无论是由于栈帧太大还是虚拟机容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。 多线程代码如下：12345678910111213141516171819202122232425// VM args: -Xss2Mpublic class JavaVMStackOOM &#123; private void dontStop() &#123; while (true) &#123; &#125; &#125; public void stackLeakByThread() &#123; while (true) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; dontStop(); &#125; &#125;); thread.start(); &#125; &#125; public static void main(String[] args) &#123; JavaVMStackOOM javaVMStackOOM = new JavaVMStackOOM(); javaVMStackOOM.stackLeakByThread(); &#125;&#125; 我在自己的机器上没有运行出来，可能需要点时间，不过机器变卡了，我想其实这里解释一下就好，它应该会抛出OutOfMemoryError异常。 解释：首先操作系统分给每个进程的内存是有限制的，所以总的方法栈的大小也是有限制的，但是每个线程都需要方法栈，所以线程建立的越多，剩余的方法栈内存就越小，一直创建线程，进程所拥有的内存终将被耗尽，到最后就会抛出OutOfMemoryError异常。 注意：线程数和方法栈大小是成反比的，所以在开发多线程的应用时应该特别注意，如果不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程了。 方法区（元空间）和运行时常量池溢出运行时常量池溢出在之前的博客也提到过在jdk1.6以及之前运行时常量池是放在方法区中的，存的是对象，所以可以设置虚拟机参数-XX:PermSize和-XX:MaxPermSize来限制方法区的大小，来模拟常量池溢出，但是jdk1.7及以后运行时常量池被移除了方法区，常量池存储的不再是对象，而是对象的引用，真正的对象存储在堆中，我们改变虚拟机参数为：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError运行下面程序：1234567891011// VM args:-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryErrorpublic class RuntimeConstantPoolOOM &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); int i = 0; while (true) &#123; list.add(String.valueOf(i++).intern()); &#125; &#125;&#125; 运行结果：123java.lang.OutOfMemoryError: GC overhead limit exceededDumping heap to java_pid10818.hprof ...Heap dump file created [25172419 bytes in 0.251 secs] 上面结果提示GC开销超过限制，默认的话，如果你98%的时间都花在GC上并且回收了才不到2%的空间的话，虚拟机就会抛这个异常。 其实我们之前也提起过在JDK1.8及以后，字符串常量池从永久代移到到元空间中，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整，如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集，-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集，具体验证代码如下：1234567891011// VM args: -XX:MetaspaceSize=4M -XX:MaxMetaspaceSize=4Mpublic class RuntimeConstantPoolOOM &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); int i = 0; while (true) &#123; list.add(String.valueOf(i++).intern()); &#125; &#125;&#125; 运行结果：12Error occurred during initialization of VMOutOfMemoryError: Metaspace 关于这个字符串常量池的实现问题，还真的会出现一个很意思的问题或者说是一个很奇怪的问题。代码如下：123456789101112131415// jdk:1.8public class RuntimeConstantPoolOOM &#123; public static void main(String[] args) &#123; String str1 = new StringBuilder("计算机").append("软件").toString(); System.out.println(str1.intern() == str1); String str2 = new StringBuilder("ja").append("va").toString(); System.out.println(str2.intern() == str2); String str3 = new StringBuilder("ma").append("in").toString(); System.out.println(str3.intern() == str3); &#125;&#125; 运行结果：123truefalsefalse jdk1.6中，intern()方法会把首次遇到的字符串实例复制在永久代，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用。而在jdk1.7及以后，intern()的实现不会再复制实例，只是在常量池中记录首次出现得实例的引用，因此intern()返回的由StringBuilder创建的那个字符串是同一个实例，而关于上面的运行结果，我想java和main之前都是在字符串常量池中都有他的引用了，所以返回的都是false。 方法区溢出方法区用于存放Class的相关信息，如类名，访问修饰符，常量池，字段描述，方法描述等，基本的思路是运行时产生大量的类去填充方法区，下面是借助CGLib（cglib和asm的依赖有个坑，选择cglib2.2,asm3.1亲测可用）来操作字节码运行时生成大量的动态类，这种场景在Spring，Hibernate中经常出现，需要多注意，本人使用的JDK1.8，所以测试的是方法区的变迁元空间，代码实现如下：123456789101112131415161718192021222324// VM args:-XX:MetaspaceSize=4M -XX:MaxMetaspaceSize=4Mpublic class JavaMethodAreaOOM &#123; public static void main(String[]args) &#123; while (true) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; return methodProxy.invokeSuper(o, objects); &#125; &#125;); OOMObject oomObject = (OOMObject) enhancer.create(); oomObject.sayHi(); &#125; &#125; static class OOMObject&#123; public void sayHi()&#123; System.out.println("hi"); &#125; &#125;&#125; 结果输出：12Error occurred during initialization of VMOutOfMemoryError: Metaspace 这类异常经常出现在web应用中，需要多注意。 本机直接内存溢出DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样，在《深入理解Java虚拟机》中用了以下代码：1234567891011121314// VM args:-Xmx20M -XX:MaxDirectMemorySize=10Mpublic class DirectMemoryOOM &#123; private static final int _1MB = 1024*1024; public static void main(String[] args) throws Exception&#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true) &#123; unsafe.allocateMemory(_1MB); &#125; &#125;&#125; 但是在自己电脑中没有运行成功，反而让自己的电脑死机了，这个地方还是没有弄懂？？？？？？，希望懂的大佬给我点支持。 这个异常在使用NIO中可能会出现，所以在使用的时候需要多注意。 总结在总结得过程中，知道了各个内存区域可能会出现OOM的情况，重要的是了解了方法区在jdk1.6到1.7到1.8的变迁，有兴趣的人可以深入了解。 参考 《深入理解Java虚拟机》 CGLIB介绍与原理 Java8内存模型—永久代(PermGen)和元空间(Metaspace) 深入探究JVM | 探秘Metaspace]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_2_HotSpot对象揭秘]]></title>
    <url>%2F2017%2F11%2F21%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-2-HotSpot%E5%AF%B9%E8%B1%A1%E6%8F%AD%E7%A7%98%2F</url>
    <content type="text"><![CDATA[引：总有些人会思考对象是如果创建、如何布局、以及如何访问的？对于这些问题，我们必须把讨论范围限定在具体的虚拟机和集中在某一个内存区域才有意义。基于实用原则，我们以常用的虚拟机HotSpot和常用的内存区域Java堆为例。 对象的创建Java程序创建对象不过是一个new关键字而已，而在虚拟机中，创建了一个对象却经历了一系列过程。 虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，如果没有就会抛出ClassNotFoundException，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，那必须先执行相应的类加载过程。 类加载检查通过后，虚拟机为新生对象分配内存，对象所需内存的大小在类加载完成后便可以完全确定。 这里有两种内存分配方式：（由采用的垃圾收集器是否带有压缩整理的功能决定） 指针碰撞 假设Java堆的内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。 空闲列表 假如Java堆中的内存并不是完整的，已使用的内存和空闲的内存相互交错，虚拟机就必须维护一个列表，记录那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给实例，并更新列表上的记录。 解决在并发情况下不安全的方案: 对分配内存空间的动作进行同步处理——虚拟机采用CAS配上失败重试的方式保证更新操作的原子性 把内存分配的动作按线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲，只有需要重新分配的时候才同步锁定 虚拟机将分配到的内存空间都初始化为零值（默认初始化），保证了对象实例在Java代码中可以不赋初始值就可以使用。 设置对象头 利用构造函数进行初始化 对象的内存布局对象头 存储对象自身的运行时数据（哈希码，GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等），官方称为“Mark Word”，它被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，他会根据对象的状态复用自己的存储空间，具体见《深入理解Java虚拟机》。 类型指针（可选）即对象指向它的元数据（方法区）的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例 数组长度（可选）如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通java对象元数据信息确定Java对象的大小，但是从数组数据无法确定数据大小 实例数据存储所有成员变量，无论是父类继承下来的，还是在子类定义的。 存储顺序会受到虚拟机分配策略参数和字段在源码定义的顺序的影响。HotSpot默认的分配策略为相同狂赌的字段总是被分配到一起（如long和double），在这个前提下，父类先于子类，若CompactFields参数为true，那么子类之中较窄的变量也可能插入到父类变量的空隙中（是因为一个slot太大） 对齐填充（可选）起到占位符的作用，确保对象的长度为8字节的整数倍 HotSpot VM的自动内存管理系统要求对象起始位置必须是8字节的整数倍，由于对象头一定是8字节的整数倍，所以利用占位符可以达到数据部分也是8字节的整数倍。从而达到对象的长度是8字节的整数倍。（有点绕口啊，哈哈） 对象的访问定位我们通常都会使用Java对象，我们基本上都是通过虚拟机栈上的reference数据来操作堆上的具体对象，而栈上只是一个指向对象的引用，对象的具体访问方式取决于虚拟机，目前有以下两种访问方式： 通过句柄访问对象可以看下面的图：使用句柄访问，Java堆中会划分出一块内存来作为句柄池，reference存储的就是对象的句柄地址，而句柄包含了对象实例数据与类型数据各自的具体地址信息。 通过直接指针访问对象可以看下面的图：使用直接指针访问，Java堆对象的布局中就要考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。 两者对比 通过句柄访问对象可以当对象被移动之后只会改变句柄中的实例数据指针，而reference本身不需要改变。 使用直接指针访问可以加快Java对象的访问，HotSpot就是使用直接指针访问对象的方式。 总结这里讲的对象重点还是在虚拟机执行部分，关于Class文件的讲解没有涉及到，但它却是十分重要的，日后会提及。 参考 深入理解JVM(二)——揭开HotSpot对象创建的奥秘]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_1_JVM内存模型]]></title>
    <url>%2F2017%2F11%2F20%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-1-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[引：总是提到堆呀，栈呀，常量池呀，但是Java虚拟机内的Java模型却总是理解不清楚，这次就总结一下。 Java内存模型组成这里讲的是Java虚拟机在执行Java程序的过程中会把它所管理的内存划分五大区域。 程序计算器 Java虚拟机栈 本地方法栈 Java堆 方法区 下面也把来自深入理解Java虚拟机的图片贴一下： 接着我们重点理解一下这五大区域。 程序计数器什么是程序计数器 程序计数器是一块较小的内存空间，他可以看做当前线程所执行的字节码的行号指示器。 如果线程在执行一个Java方法的时候，这个计数器记录的是正在执行的虚拟机字节码指令地址，如果正在执行的是Native方法，这个计数器值则为空。 程序计数器的作用 单线程的时候：通过改变这个计数器的值来选取下一条需要执行的字节码指令，从而实现分支、循环、跳转、异常处理、线程回复等基础功能。 多线程的时候：当每个线程都有独立的程序计数器，则线程切换后就能回复到正确的执行位置。PS： Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。 程序计数器的特点 存储空间较小 线程私有，每个线程都有一个程序计数器 唯一一个没有规定任何OutOfMemoryError情况的区域 生命周期与线程相同 Java虚拟机栈什么是Java虚拟机栈Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表（包括基本数据类型，对象引用和returnAddress,其中long和double会占据2个局部变量空间，其他只占用一个）、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 Ps： 人们常说的Java内存区分为“堆”和“栈”，“堆”存放对象（可以），“栈”只是值其中的局部变量表（不可以），这是不正确的。 Java虚拟机栈的特点 线程私有，生命周期与线程相同 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常 虚拟机栈可以动态扩展，也可以固定长度，在动态扩展的时候如果无法申请到足够的内存，就会抛出OutOfMemoryError异常 本地方法栈什么是本地方法栈本地方法栈描述的是本地方法执行的内存模型，它发挥的作用与虚拟机栈发挥的作用是非常相似的，如Sun HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一，它与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 Java堆什么是Java堆 Java堆是存放对象实例的内存区域 几乎所有对象实例都在这里分配内存 Java堆的特点 Java虚拟机管理的内存中最大的一块 线程共享，在虚拟机启动时创建 垃圾收集器管理的主要区域，从内存回收的角度来看，由于现在收集器都采用分代收集算法，所以可分为新生代和老年代，再细致一点可以分为Eden空间、From Survivor空间和To Survivor空间等。从内存分配来看，线程共享的Java堆可能划分出多个线程私有的分配缓存区TLAB,进一步划分的目的是为了更好地回收内存，或者更快的分配内存 实现中可以固定大小，也可以是可扩展的，如果在堆中没有内存完成实例的分配，并且堆也无法再扩展时，就会抛出OutOfMemoryError异常 方法区什么是方法区 Java虚拟机规范把方法区描述为堆的一个逻辑部分。 他用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码 方法区的特点 线程共享，在虚拟机启动时创建 永久代是因为HotSpot选择将GC分代收集器扩展到方法区，或者使用永久代来实现方法区，对于HotSpot官方发布的路线图信息，现在也有放弃永久代逐步采用Native Memory来实现方法区的规划了，并且已经把原本放在永久代的字符串常量池移除 不需要连续的内存，可以选择固定大小或者可扩展，还可以选择不实现垃圾回收 内存回收的主要目标主要是针对常量池的回收和对类型的卸载，但是回收效率低 当方法区无法满足内存分配的需求的时候，将抛出OutOfMemoryError的异常 运行时常量池 Class文件除了包含类的版本字段、方法、接口等描述信息外，还有一项信息是常量池 常量池用于存放编译期间生成的各种字面量和符号引用，这部分内容在类加载后进入运行时常量池中存放 运行时常量池相对于Class文件常量池具有动态性，Java语言不要求只有Class文件中的常量池的内容才能进入运行时常量池，运行时也可能将新的常量放入池中，如String类的intern方法 当常量池无法再申请内存时将会抛出OutOfMemoryError异常 PS： jdk1.7的常量池移到了堆中，同时在jdk1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域 直接内存 通过一个存储在Java堆中的DirectByteBuffer对象最为这块内存的引用进行操作，这个可以显著提高性能，因为避免了在Java堆和Native堆中来回复制数据 案例是NIO类引入一种基于通道与缓存区的I/O方式，它可以使用Native函数库直接分配对外内存，然后通过DirectByteBuffer进行操作 本机直接内存的分配不会受到Java堆大小的限制，但是会受到本机总内存大小和处理器寻址空间的限制，也可能会抛出OutOfMemoryError异常 总结本篇文章是参考《深入理解Java虚拟机》第二版所写，当时作者用的是jdk1.7，结果现在jdk1.9都出了，最大的改变就是方法区了，目前还没有能力改正，也就将就了，望作者早日更新，或者自己成为大牛，将这部分重新整理。 参考 深入理解JVM(一)——JVM内存模型 Java 8: 从永久代（PermGen）到元空间（Metaspace）]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot静态资源的处理]]></title>
    <url>%2F2017%2F10%2F20%2Fspringboot%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[引：由于springboot架构遇到了图片的上传处理，以及之后的前台显示，所以就理解了一下其中关于静态资源的处理。 默认的静态资源处理在每次启动springboot的项目的时候，我们都可以在控制台看见下面的语句输出：1232017-10-20 16:06:50.540 INFO 36443 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-10-20 16:06:50.540 INFO 36443 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-10-20 16:06:50.569 INFO 36443 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 这里面就用到了springboot默认的静态资源处理。 其中默认配置的/**映射到/static（或/public、/resources、/META-INF/resources） 其中默认配置的/webjars/**映射到classpath:/META-INF/resources/webjars/ PS：上面的 static、public、resources 等目录都在 classpath: 下面（如 src/main/resources/static） 在访问静态资源的时候，这些目录也会有一个查找顺序（优先级）：这里测试过发现他们的优先级是：META/resources &gt; resources &gt; static &gt; public 自定义静态资源处理配置方式 通过配置文件（application.properties）配置1234# 默认值为 /**spring.mvc.static-path-pattern=# 默认值为 classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ spring.resources.static-locations=这里设置要指向的路径，多个使用英文逗号隔开， 当我们要设置成我们的目录：/myresource/**，我们需要这样设置:12spring.mvc.static-path-pattern=/**spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/,classpath:/myresource/ 当我们设置过映射路径时候，如果还是/**,那么默认的映射就失效了，我们需要重新把原来的路径也添加上。这里的配置路径只可以设置一个。 通过配置类配置12345678@Configurationpublic class MyWebAppConfigurer extends WebMvcConfigurerAdapter&#123; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler("/myresource/**").addResourceLocations("file:/var/alldata/image/"); super.addResourceHandlers(registry); &#125;&#125; 可以通过这个方式设置多个配置路径。 配置内外目录 内部目录 做法是添加映射路径 classpath:/路径 方式见通过配置文件配置 外部目录 想一想如果将上传的图片继续存在jar包中会有那些问题？ 网络数据与程序代码不能分离 数据传到jar里速度慢 数据备份麻烦 有了以上的考虑我们会想到将上传的数据放在磁盘的目录上。 做法是添加映射路径 file:/var/alldata/images 方式见通过配置类配置 总结springboot倡导的是习惯优于配置，大部分时候我们用他默认的配置就好了，但是他也提供了方便的配置类，需要我们好好学习。 参考 Spring Boot 静态资源处理 Springboot 之 静态资源路径配置]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac中环境变量的配置]]></title>
    <url>%2F2017%2F09%2F21%2Fmac%E4%B8%AD%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[引：在使用ubuntu和mac这么久之后，环境变量的几个文件还弄不清楚，真是汗颜，这里记录一下，下次不会乱改。 环境变量的作用 使用场景在命令行直接通过命令执行程序，这些程序就多了，最常见就有java，npm，maven，git,如果我们不配置环境变量的话，就需要到程序的安装目录去执行相关命令，大家都会感觉超级麻烦，加入要使用多个程序的话，要么去切换目录，要么就多开几个命令行窗口。顿时就会感觉超级无奈有么有？ 具体作用配置完程序的环境变量之后就可以无所欲为了，可以在任何目录下直接执行我们所要的程序了，是不是顿时感觉方便许多，基本上所有人都知道吧。 环境变量的配置单次环境变量配置假如你出了个意外，在命令行中突然不能使用各种命令了，也没事，至少接下来可以让你短暂的使用一些命令，命令行窗口关闭之后就失效了，我们要做的只是直接在命令行中输入： export PATH=/usr/bin:/usr/sbin:/bin:/sbin 当然后面你也能够添加一些你自己想要使用的程序命令。 环境变量文件配置 环境变量的写法 export PATH=JAVA_HOME/bin:$PATH 环境变量文件优先级 /etc/profile /etc/bashrc /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc其实后三个文件我也没怎么看到过，主要讲一下前面三个 环境变量文件详解 /etc/profile：全局配置文件，不管是哪一个用户登录，都会读取该文件（但是超级不建议修改，容易出现大问题，想试试什么大问题，自己体会） /etc/bashrc 全局配置文件，bash shell执行时，不管是何种方式，都会读取此文件（一般在这个文件中添加系统级环境变量） ~/.bash_profile：每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!（一般在这个文件中添加用户级环境变量） 立即生效环境变量配置 source ~/.bash_profile 软连接自己一开始也会特别的惊讶，自己在mac上没有设置环境变量有的时候也可以直接就访问到了某些文件。这个是为什么呢？答案是用了软连接。 查看加载文件rexdeMacBook-Pro:etc rex$ cat /etc/paths /usr/local/bin /usr/bin /bin /usr/sbin /sbin 然后就可以去看这些文件夹下面的东西了，弄不清楚也没关系，其实就是软链接。开机后，mac会自动加载paths文件下面的这些目录。在这些文件夹下面建立软连接，可以达到同样的效果（日后学习）。 软连接查看在拥有软连接的目录下使用下面命令 ls -li 406876 lrwxr-xr-x 1 root wheel 73 7 9 2016 jar -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/jar 406877 lrwxr-xr-x 1 root wheel 79 7 9 2016 jarsigner -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/jarsigner 406878 lrwxr-xr-x 1 root wheel 74 7 9 2016 java -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java 406879 lrwxr-xr-x 1 root wheel 75 7 9 2016 javac -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javac 406880 lrwxr-xr-x 1 root wheel 77 7 9 2016 javadoc -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javadoc 建立软连接等自己看了linux的相关知识再来说吧。 总结希望下次自己再也不要因为环境变量配置错出各种问题了，thanks god！ 参考：Mac 中环境变量的配置和理解]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages+Hexo SEO引擎优化]]></title>
    <url>%2F2017%2F07%2F16%2FGithub-Pages-Hexo-SEO%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[引：写的博客自然想让人看到，但是但是自己为了想独立管理（冠冕堂皇）选择了GIthub Pages+Hexo来搭建自己的博客，结果发现自己的博客在百度，谷歌都无法搜到，那时候我才知道自己缺少了SEO。 百度优化登录百度站长 在里面我们可以发现各种向百度提交的方法，这一切都是为了让百度的爬虫更好的爬取我们的网页。 通过baidumapsite.xml自动提交 这里推荐一个博文：Hexo NexT 主题SEO优化指南 通过主动提交 这里推荐一个自动化工具：exo插件之百度主动提交链接 谷歌优化登录谷歌站长 通过map.site自动提交 这里面推荐一个博文：生成sitemap站点地图 总结自己在谷歌配置是成功的，但是在百度并没有成功，可能是因为github真的把百度给干了。自己还是等开学转到自己的服务器上吧。慢慢SEO！！！！ PS:Hexo博客的搭建的可以参考这一篇 搭建Hexo博客中碰到的坑]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新系统开发环境的一系列配置]]></title>
    <url>%2F2017%2F07%2F15%2F%E6%96%B0%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[引：总是不可避免的重装系统，人的脑子不可能那么好记住所有的操作，既然不想自己自己用博客记下所有操作，那么就把别人的博客（自己踩过）记录下来，以后备用。 window篇 JDK——java开发者起步 JDK的安装与环境变量的配置 Node——前端好基友 Node.js安装及环境配置之Windows篇 Sublime3——轻量级编辑器 Sublime Text3安装与插件配置 git——分布式版本控制工具 Git安装教程 Idea——java开发利器 IntelliJ IDEA注册码 Maven——项目依赖管理利器 Maven Windows10安装 Mac篇待写 Ubuntu篇待写 双系统Win10和Ubuntu16.04双系统安装详解]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅尝Apache Camel]]></title>
    <url>%2F2017%2F07%2F15%2F%E6%B5%85%E5%B0%9DApache-Camel%2F</url>
    <content type="text"><![CDATA[引：最近项目有一个需求就是定时将一台服务器的文件传到另一个服务器，一开始想的竟然想的是用http去下载，后来在万老师的指点下，采取用ftp服务器（源文件所在地）与ftp客户端（源文件去向）的形式来处理，自己小试了一下，还不错！ Apache Camel简介Apache Camel是Apache基金会下的一个开源项目,它是一个基于规则路由和处理的引擎，提供企业集成模式的Java对象的实现，通过应用程序接口 或称为陈述式的Java领域特定语言(DSL)来配置路由和处理的规则。其核心的思想就是从一个from源头得到数据,通过processor处理,再发到一个to目的的。 这个from和to可以是我们在项目集成中经常碰到的类型:一个FTP文件夹中的文件,一个MQ的queue（jms）,一个HTTP request/response,一个webservice等等. Apache Camel架构 其实理解起来很简单：始端》（过滤器+路由处理器）》终端 Apache Camel核心概念 endpoint,所谓的endpoint,就是一种可以接收或发送数据的组件。可以支持多种协议，如jms,http,file等。 processor,它是用来处理具体业务逻辑的组件。 route,用来路由，指示数据从哪里来到哪里去，中间用哪个processor处理。 exchange,processor之间用exchange对象来传送数据，有点像jms,通俗一点就像上学时传的小纸条,所以：exchange对象就是processor，endpoint所有camel组件之间传送数据的小纸条:)。 filter，用来确定哪些东西可以传递，哪些东西不可以传递。 Apache Camel例子（以ftp为例）老师指导的例子，是结合Springboot的，放在github上了。ApacheCamleDemo 里面包括了动态路由和单路由的例子，稍微结合Springboot就可以理解并改成自己的代码。 什么时候用Apache Camel参考网上的说法：camel就是企业信息集成框架，它提供了很多简单好用而又强大的组件，用户可以根据场景来选择不同的EIP（企业集成模式）来实现自己的需求，以响应快速变化的业务。可以把它当成企业信息总线（ESB）的轻量级实现。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>ApacheCamel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java ftp 上传下载的坑]]></title>
    <url>%2F2017%2F07%2F15%2Fjava-ftp-%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[引：还是项目需要，要定时执行一个文件下载业务，一开始方向有点错，但是还好纠正过来了，采用ftp下载，但是ftp下载也有各种坑！ 准备jar包：commons-net ftp上传程序：1234567891011121314151617181920212223242526272829303132333435363738public static boolean uploadFile( String url,//服务器主机号 int port,//服务器端口 String username,//用户名 String password,//密码 String path, //上传路径Mar String filename,//上传为服务器上的文件名 InputStream //input本地上传的文件流) &#123; boolean success = false; FTPClient ftp = new FTPClient(); try &#123; int reply;MarkDown ftp.connect(url, port);//连接FTP服务器 //如果采用默认端口，可以使用ftp.connect(url)的方式直接连接FTP服务器 ftp.login(username, password);//登录 reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) &#123; ftp.disconnect(); return success; &#125; ftp.changeWorkingDirectory(path); ftp.storeFile(filename, input); input.close(); ftp.logout(); success = true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ftp.isConnected()) &#123; try &#123; ftp.disconnect(); &#125; catch (IOException ioe) &#123; &#125; &#125; &#125; return success;&#125; 测试代码：123File file = new File(&quot;/var/test.txt&quot;);InputStream is = new FileInputStream(file);uploadFile(&quot;127.0.0.1&quot;,21,&quot;test&quot;,&quot;123456&quot;,&quot;/var/data/test&quot;,&quot;testdemo.txt&quot;,is); ftp下载程序：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public static boolean downFile(String url, //FTP服务器hostnameint port,//FTP服务器端口String username, //FTP登录账号String password, //FTP登录密码String remotePath,//FTP服务器上的相对路径String fileName,//要下载文件关键字String localPath//下载后保存到本地的路径) &#123; FTPClient ftpClient = null; boolean success = false; try &#123; ftpClient = new FTPClient(); ftpClient.connect(url, port);// 连接FTP服务器 ftpClient.login(username, password);// 登陆FTP服务器 ftpClient.setControlEncoding("gb2312"); // 中文支持 ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);//设置文件格式 ftpClient.enterLocalPassiveMode(); logger.info(ftpClient.getReplyCode()); if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) &#123; logger.warn("未连接到FTP，用户名或密码错误。"); ftpClient.disconnect(); &#125; else &#123; logger.info("FTP连接成功。"); &#125; ftpClient.changeWorkingDirectory(remotePath); FTPFile[] fs = ftpClient.listFiles(); File file = new File(localPath); if(!file.exists())&#123; file.mkdirs(); &#125; for(FTPFile ff:fs)&#123; if(ff.getName().contains(fileName))&#123; File localFile = new File(localPath+"/"+ff.getName()); if (localFile.exists())&#123; continue; &#125; OutputStream os = new FileOutputStream(localFile); long time1 = System.currentTimeMillis(); boolean b = ftpClient.retrieveFile(new String(ff.getName().getBytes("gb2312"),"ISO8859-1"), os); os.flush(); os.close(); &#125; &#125; ftpClient.logout(); success = true; &#125; catch (SocketException e) &#123; e.printStackTrace(); logger.warn("FTP的IP地址可能错误，请正确配置。"); &#125; catch (IOException e) &#123; e.printStackTrace(); logger.warn("FTP的端口错误,请正确配置。"); &#125; finally &#123; if (ftpClient.isConnected()) &#123; try &#123; ftpClient.disconnect(); &#125; catch (IOException ioe) &#123; &#125; &#125; &#125; return success;&#125; 测试程序：1downFile(&quot;127.0.0.1&quot;,21,&quot;test&quot;,&quot;123456&quot;,&quot;、var/data/test&quot;,&quot;demo&quot;,&quot;/var/alldata&quot;); 一些坑 客户端接受的编码 1ftpClient.setControlEncoding(&quot;gb2312&quot;); // 中文支持 如果服务器上的文件名有中文，一定要加上这一句，具体编码要根据服务器的编码。 客户端接受的文件类型 1ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);//设置文件格式 文件类型要根据下载的文件格式来定 服务器端口设置 1ftpClient.enterLocalPassiveMode(); 调用FTPClient.enterLocalPassiveMode();这个方法的意思就是每次数据连接之前，ftp client告诉ftp server开通一个端口来传输数据，防止在新端口对外部不通，因为ftp server可能每次开启不同的端口来传输数据，但是在linux上，由于安全限制，可能某些端口没有开启，所以就出现阻塞。 最大的坑（下载出0kb的文件：实质就是retrieveFile方法执行失败） 1ftpClient.retrieveFile(new String(ff.getName().getBytes(&quot;gb2312&quot;),&quot;ISO8859-1&quot;), os) 一定要给文件名换编码，让它识别中文，具体编码也是根据实际情况而定。 总结ftp客户端的速度也是要根据网速来的，可能比一般http快，但是面对网速慢的情况也是无可奈何！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js原型和原型链]]></title>
    <url>%2F2017%2F07%2F13%2Fjs%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[引：刚刚说了闭包，那就不放过js的另一大难点了——js原型以及原型链。 谈谈神图镇楼：自己写了好几遍内容，但是自己发现还是不能系统的理解，自己也写不了多好，看来要到自己安心写前端的时候，再来补上了。 参考 最详尽的 JS 原型与原型链终极详解（一） 最详尽的 JS 原型与原型链终极详解（二） 最详尽的 JS 原型与原型链终极详解（三） 个人感觉上面的文章还不错，可能还缺了继承那块的讲解，等自己再来的时候一起补上吧！！！！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈js闭包]]></title>
    <url>%2F2017%2F07%2F12%2F%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[引：最近项目前端用了angular2，里面使用的TypeScript,其实很多和Java挺像的，学起来还是挺快的。但是里面的很多变量的原理都是根据闭包来实现的，那就好好了解一下闭包。 闭包定义根据Mozilla开发者文档定义： 闭包是指向独立变量的“函数”,用通俗的话说就是会“记住”它创建时的环境。 闭包涉及的主要概念 作用域链 作用域链是函数在定义的时候创建的,用于寻找使用到的变量的值的一个索引。它内部的规则是,把函数自身的本地变量放在最前面,把自身的父级函数中的变量放在其次,把再高一级函数中的变量放在更后面,以此类推直至全局对象为止.当函数中需要查询一个变量的值的时候,js解释器会去作用域链去查找,从最前面的本地变量中先找,如果没有找到对应的变量,则到下一级的链上找,一旦找到了变量,则不再继续.如果找到最后也没找到需要的变量,则解释器返回undefined. 内存回收机制 一个函数在执行开始的时候,会给其中定义的变量划分内存空间保存,以备后面的语句所用,等到函数执行完毕返回了,这些变量就被认为是无用的了.对应的内存空间也就被回收了.下次再执行此函数的时候,所有的变量又回到最初的状态,重新赋值使用.但是如果这个函数内部又嵌套了另一个函数,而这个函数是有可能在外部被调用到的.并且这个内部函数又使用了外部函数的某些变量的话.这种内存回收机制就会出现问题.如果在外部函数返回后,又直接调用了内部函数,那么内部函数就无法读取到他所需要的外部函数中变量的值了.所以js解释器在遇到函数定义的时候,会自动把函数和他可能使用的变量(包括本地变量和父级和祖先级函数的变量(自由变量))一起保存起来.也就是构建一个闭包,这些变量将不会被内存回收器所回收,只有当内部的函数不可能被调用以后(例如被删除了,或者没有了指针),才会销毁这个闭包,而没有任何一个闭包引用的变量才会被下一次内存回收启动时所回收. 闭包现象123456789var results = [];for (var i = 0; i &lt;3; i++) &#123;results[i] = function() &#123;console.log(i);&#125;&#125;results[0](); //3results[1](); //3results[2](); //3 解析：其实这里return出来的是一个function（我们可以理解为他是一个字符串，还没有执行），等到我们去执行他的时候，只保存了他上一级的作用域链里面的i的索引,那个时候i已经是3了。 闭包解决让内部函数在循环创建的时候立即执行,并且捕捉当前的索引值,然后记录在自己的一个本地变量里.然后利用返回函数的方法,重写内部函数,让下一次调用的时候,返回本地变量的值,改进后的代码:1234567891011var results = [];for (var i = 0; i &lt;3; i++) &#123;results[i] = (function(j) &#123;return function()&#123;console.log(j);&#125;&#125;)(i);&#125;results[0](); //0results[1](); //1results[2](); //2 我们发现通过立即执行表达式就可以解决闭包的现象得到我们想要得到的现象。 闭包应用闭包与静态变量前面就说TypeScript与Java很像，所以类中的静态变量也是有的。 TypeScript代码：12345678910111213141516class Counter &#123;private static COUNTER = 0;constructor() &#123;&#125;private changeBy(val) &#123;Counter.COUNTER +=val;&#125;public increment() &#123;this.changeBy(1);&#125;public decrement() &#123;this.changeBy(-1);&#125;public value() &#123;return Counter.COUNTER;&#125;&#125; 编译之后的js代码:123456789101112131415161718var Counter = (function () &#123;function Counter() &#123;&#125;Counter.prototype.changeBy = function (val) &#123;Counter.COUNTER += val;&#125;;Counter.prototype.increment = function () &#123;this.changeBy(1);&#125;;Counter.prototype.decrement = function () &#123;this.changeBy(-1);&#125;;Counter.prototype.value = function () &#123;return Counter.COUNTER;&#125;;Counter.COUNTER = 0;return Counter;&#125;()); 从js代码可以看书静态变量COUNTER是属于Counter类的，并不属于对象原型。所有Counter实例都共享Counter的同一个闭包上下文环境（COUNTER）。所以COUNTER会表现像单例一样。 闭包和私有成员TypeScript由于性能原因并没有使用闭包来模拟私有变量，他使用过编译检查机制来形成私有变量的特性。但是我们可以使用闭包来实现私有变量。 js代码如下：123456789101112131415161718function makeCounter() &#123;var COUNTERR = 0;function Counter() &#123;&#125;function changeBy(val) &#123;COUNTER += val;&#125;;Counter.prototype.increment = function () &#123;this.changeBy(1);&#125;;Counter.prototype.decrement = function () &#123;this.changeBy(-1);&#125;;Counter.prototype.value = function () &#123;return COUNTER;&#125;;return new Counter();&#125;; 从上面的代码可以看出，每一个新的makeCounter实例都拥有自己的上下文环境，其他实例访问不了。 总结学习这么久的js发现，其实闭包真的无处不在，需要好好学习，好好总结，如有不对，也希望大家能够指出。 参考链接：js中闭包原理谈和原型及例子 书籍：Learning TypeScript中文版]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java日志那些事]]></title>
    <url>%2F2017%2F07%2F12%2FJava%E6%97%A5%E5%BF%97%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[引：一直都知道日志文件很重要，可以记录一些相关信息，但是可能是程序需要调试的内容太少，也或者是项目太小，所以看看控制台的信息就够了，但是这次接触的项目越来越大，控制台额信息越来越多，经常会看不到自己想要看到的信息时，这个时候使用日志就发现十分得有必要了！ 日志的好处 方便调试(如上) 方便发现系统运行中的错误 存储业务数据，便于日后分析 日志实现方式 自己实现类通过io存储到文件中 使用log4j将日志输入到控制台，文本文件，一集数据库中。 使用jdk自带的logging.jar包中方法（同一作者还有lognback） 使用slfj，它提供了上述两种方法的接口。 日志的输出(以log4j为例) 输入到控制台 运行程序：1234567891011public class LoggerTest &#123;public static Logger logger1 = Logger.getLogger(LoggerTest.class);public static void main(String[] args) &#123;logger1.trace(&quot;我是logger1，trace&quot;);logger1.debug(&quot;我是logger1，debug&quot;);logger1.info(&quot;我是logger1，info&quot;);logger1.warn(&quot;我是logger1，warn&quot;);logger1.error(&quot;我是logger1，error&quot;);logger1.fatal(&quot;我是logger1，fatal&quot;);&#125;&#125; 配置文件如下：123456789### 设置级别和目的地(这里多个目的地) ###log4j.rootLogger = DEBUG,CONSOLE### 这里的com.todorex是包，也就是在这个包记录日志时，是只记录debug及以上级别的日志log4j.logger.com.todorex=DEBUG### 输出到控制台 ###log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.Target = System.outlog4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern = %d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n 控制台输出:1234511:35:09,969 DEBUG LoggerTest:12 [main:0]- 我是logger1，debug11:35:09,972 INFO LoggerTest:13 [main:3]- 我是logger1，info11:35:09,972 WARN LoggerTest:14 [main:3]- 我是logger1，warn11:35:09,972 ERROR LoggerTest:15 [main:3]- 我是logger1，error11:35:09,972 FATAL LoggerTest:16 [main:3]- 我是logger1，fatal 输入到日志文件运行程序同上；配置文件如下：1234567891011121314151617181920### 设置级别和目的地(这里可以多个目的地) ###log4j.rootLogger = trace,demoLoglog4j.logger.com.todorex=DEBUG### 输出到控制台 ###log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.Target = System.outlog4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern = %d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L [%t:%r]- %m%n### 输出到日志文件（文件目录一定要是绝对路径且存在） ###log4j.appender.demoLog = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.demoLog.File =/var/alldata/mylog.loglog4j.appender.demoLog.Append = true## 只输出DEBUG级别以上的日志log4j.appender.demoLog.Threshold = DEBUG#&apos;.&apos;yyyy-MM-dd: 每天产生一个新的文件log4j.appender.demoLog.DatePattern = &apos;.&apos;yyyy-MM-ddlog4j.appender.demoLog.layout = org.apache.log4j.PatternLayoutlog4j.appender.demoLog.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%t:%r] - [%p] [%c&#123;1&#125;:%L] [%M] %m%n 文件内容同控制台输出，但是却比控制台清楚得多，不会被乱七八糟的信息给遮盖。 输入到数据库 运行程序:1234567public class LoggerTest &#123;public static void main(String[] args) &#123;Logger logger = Logger.getLogger(LoggerTest.class);logger.info(&quot;good&quot;);logger.debug(&quot;success&quot;);&#125;&#125; 配置文件：1234567891011log4j.rootLogger=trace,CONSOLE,demoLog# com.todorex包下面所有的日志输出的级别设为DEBUGlog4j.logger.com.todorex=DEBUG# 数据库输出log4j.appender.demoLog=org.apache.log4j.jdbc.JDBCAppenderlog4j.appender.demoLog.driver=com.mysql.jdbc.Driverlog4j.appender.demoLog.URL=jdbc:mysql://127.0.0.1:3306/testlog4j.appender.demoLog.user=rootlog4j.appender.demoLog.password=root# 在数据库对应的位置建一个对应的log表log4j.appender.demoLog.sql=insert into log(level,category,thread,time,location,note) values(&apos;%p&apos;,&apos;%c&apos;,&apos;%t&apos;,&apos;%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;&apos;,&apos;%l&apos;,&apos;%m&apos;) 数据库的具体内容就不贴出来了，和普通看到的一样。 总结其实日志用几次就知道它的好了，自己也是在慢慢学习！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jpa实体映射关系]]></title>
    <url>%2F2017%2F06%2F15%2Fjpa%E5%AE%9E%E4%BD%93%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[引：其实距离自己上次写数据库操作已经1个多月了，之前接触的就是Hibernate，这次接触jpa，就把几种对应关系理清。 映射策略注：这次举的例子都是User和Car的 外键关联简介：两个表的关系定义在其中一个表中 @OneToOne方法一：123@OneToOne(cascade=CascadeType.ALL, fetch=FetchType.EAGER)@JoinColumn(name = &quot;user_id&quot;)private Car car; 通过在Car表中加入一个外键，实现两者关系。方法二：12@OneToOne(cascade = CascadeType.ALL,fetch = FetchType.EAGER,mappedBy = &quot;Car&quot;)private User user; 通过在Car类中用MappedBy声明让User进行维护。 @OneToMany123@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)@JoinColumn(name = &quot;user_id&quot;)private Set&lt;Car&gt; cars; 通过在Car表中加入一个外键，实现一对多关系。 @ManyToMany12@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)private Set&lt;Car&gt; cars; 这个是采用默认的表关联 表关联简介：两个表的关系通过一张中间表来来关联 @OneToMany12345@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)@JoinTable(name = &quot;user_car&quot;,joinColumns=&#123;@JoinColumn(name = &quot;user_id&quot;)&#125;,inverseJoinColumns = &#123;@JoinColumn(name = &quot;car_id&quot;)&#125;)private Set&lt;Car&gt; cars; 通过JoinTable来确定一张中间表，joinColumns里面放父表的属性，inverseJoinColumns放子表的属性 @ManyToMany12345@ManyToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)@JoinTable(name = &quot;user_car&quot;,joinColumns=&#123;@JoinColumn(name = &quot;user_id&quot;)&#125;,inverseJoinColumns = &#123;@JoinColumn(name = &quot;car_id&quot;)&#125;)private Set&lt;Car&gt; cars; 解释如@OneToMany 一些属性cascade属性 CascadeType.PERSIST：级联新建 CascadeType.REMOVE：级联删除 CascadeType.REFRESH：级联刷新 CascadeType.MERGE：级联更新 CascadeType.ALL：包括上面四项 fetch属性 FetchType.EAGER：相当于禁用懒加载，推荐开发使用 FetchType.LAZY：懒加载，默认值，推荐部署使用 总结父表是提供主键的，子表是利用父表的主键来设置外键的，维护方是Owner，被维护方是Owned。提示自己一个傻逼的问题，插入数据要先往两张表中插入数据，在往中间表插入数据，不然会报错~]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>sping</tag>
        <tag>jpa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot项目调试angular2]]></title>
    <url>%2F2017%2F06%2F01%2Fspringboot%E9%A1%B9%E7%9B%AE%E8%B0%83%E8%AF%95angular2%2F</url>
    <content type="text"><![CDATA[引：在接触 springboot和angular2的前后端项目的时候，我发现自己会先把angular2的项目编译好之后放在springboot的resource目录下的static文件夹下运行，虽然这样可以，但是对于前端来调试代码实在不方便。在百度网上的方法之后可以采用如下代理的方式。 问题 angular2启动的服务默认为http://localhost:4200 springboot启动的服务默认为http://localhost:8080 如果我们直接设置angular2访问的路径为http://localhost:8080就会出现跨域访问的问题。请求不到数据。 解决在angular2项目的根目录下面新建一个proxy.config.json123456&#123;&quot;/api&quot;: &#123;&quot;target&quot;: &quot;http://localhost:8081&quot;,&quot;secure&quot;: false&#125;&#125; 然后在启动项目的时候采用下面的命令 ng serve –proxy-config proxy.config.json 通过这样的代理访问就能能够实现跨域访问请求数据。 总结通过上面的方法方便了开发调试，不错，终于要开始写代码了！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>angular2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringSecurity+JWT保驾SpringBoot(未完)]]></title>
    <url>%2F2017%2F05%2F24%2FSpringSecurity-JWT%E4%BF%9D%E9%A9%BESpringBoot-%E6%9C%AA%E5%AE%8C%2F</url>
    <content type="text"><![CDATA[引：在万老师的指引下，开始接触到了安全板块，SpringSecurity+JWT绝对能够让人欣喜 JWT介绍关于JWT说实话是最近才听到的，然后慢慢开始了解，这里简单记下一篇博文。这篇博文在做过简单的应用之后发现还是不怎么全的 ，等自己再深入了解之后，再来补全。 SpringSecurity整合JWT看了几个SpringSecurity的应用，发现应该是大同小异，自己也找到一篇虽然结构不太好，但大部分内容都讲到的博文。也是日后能够总结得好一点，再来补全。 总结一定要再来！！！！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JWT</tag>
        <tag>SpringSecurity</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular2入门]]></title>
    <url>%2F2017%2F05%2F24%2FAngular2%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[引：由于老师暑假的项目前端代码需要用到Angular2，作为一个后端开发者也是需要了解一丢丢的。 Angular简介在经过简单的了解与使用之后，感觉 到Angular2的强大与伟大，配的上说是一个优秀的前端框架。Angular2实现了前端一直提倡的组件化开发还解决了大部分项目路由混乱的问题。它还有具有MVC分层架构和依赖注入等一系列优秀的特性。现在贴上Angular2的一张架构图：上图描述了Angular2中8大主要构造块的关系，他们具体的理解，可以参考这篇博文。如果还有什么不理解，那我们可以相信实践见真知。 Angular起步在这次学习中，我终于理解了前辈们所说的入门一门技术就好的方法就是去看官方文档了，Angular2的官网文档里面有中文版的，相信大家一定很开心吧。当然没有中文版也是要看的，比较都是最基础的入门，不要惧怕英文。 在这次按照官方文档的教程（英雄编辑器）出现了两个问题，这里也说明一下： angular-in-memory-web-apia模块不存在 解决方法：通过命令行安装 npm i angular-in-memory-web-api 1234567create(name: string): Promise&lt;Hero&gt; &#123;return this.http.post(this.heroesUrl, JSON.stringify(&#123;name: name&#125;), this.headers).toPromise().then(res =&gt; res.json().data as Hero).catch(this.handleError);&#125; 这里的post方法中的第三个参数应该是this.headers,而不是像官方文档中的那样。 总结如果遇到不懂得问候多看看文档吧，相信自己可以的，然后就是实践见真知了。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Angular2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简谈entity，model，domain]]></title>
    <url>%2F2017%2F05%2F23%2F%E7%AE%80%E8%B0%88entity%EF%BC%8Cmodel%EF%BC%8Cdomain%2F</url>
    <content type="text"><![CDATA[引：前两天听到关于entity和domain包的区别，好像之前自己也没有在意过，今天看看网上的信息总结一下。 entity（实体）这好像是最常用的package命名了，package的类一般都是和数据库的表对应的。一个实体，一张表，其字段的类型也是对应的。 model（模型）最初接触到它的时候是Struts的模型驱动，用于接受和显示前台的数据对象。我们要根据实际情况来确定模型的类。 domain（域）说实话，这个包名用得不怎么多，在网上显示它在国外的网站用的比较多，它主要是用于存储一个业务对象（模块对象）。 总结正确命名包名，有助于后续代码的维护，以及后来开发者的维护，最重要的是能衔接行业的规范。慢慢来！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行运行hadoop程序]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8Chadoop%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[引：自己最近心态有点崩，毕竟很迷茫，趁现在比较空 ，也就微微看看hadoop。在运行《Hadoop权威指南》的时候，遇到了按照书上命令行无法运行的问题。 问题 大家都知道刚开始入门，就遇到问题了就必然是十分难受的，那么我们现在可以解决。 解决编辑 ~/.bash_profile12export HADOOP_HOME=/usr/local/hadoopexport CLASSPATH=$($HADOOP_HOME/bin/hadoop classpath):$CLASSPATH 使其生效1source ~/.bash_profile 运行 编译主类 1javac MaxTemperature.java 把.class 文件打包成 jar，才能在 Hadoop 中运行： 1jar -cvf MaxTemperature.jar ./MaxTemperature*.class 创建input文件夹的数据，就可以运行了(每次运行时，output文件夹都应该不存在) 1hadoop MaxTemperature input/ncdc/sample.txt output 总结虽然我自己还不知道书上的命令行为什么不能用，但是还是希望慢慢可以弄懂吧！]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F2017%2F05%2F17%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[引：上次看到过钟华老师的一个基于贪心算法的毕业设计，一直很好奇，今天终于能看看它了，只是知其然，不知所以然。 贪心算法总说贪心算法在每一步都会做出看起来是最佳的选择，也就是说会做出局部最优的选择，希望以此能够得到最优解。 活动选择问题贪心选择我们要选择这样一个活动，选出它之后身下的资源能够被尽量多的其他任务所用，即选择最早结束的活动。 递归贪心算法算法思路：用两个数组s和f表示活动的开始和结束时间。下表k是我们要求解的子问题，以及问题规模n，代码如下：12345678910111213141516171819202122232425262728293031import java.util.ArrayList;import java.util.List;public class ActivitySelector &#123;public int[] s = new int[]&#123;1,3,0,5,3,5,6,8,8,2,12&#125;;public int[] f = new int[]&#123;4,5,6,7,9,9,10,11,12,14,16&#125;;public List&lt;Integer&gt; list = new ArrayList&lt;&gt;();public void recursiveActivitySelector(int[] s, int[] f,int k,int n)&#123;if(list.size()==0)&#123;list.add(1);&#125;int m = k+1;while (m&lt;n &amp;&amp; s[m]&lt;f[k])&#123;m = m+1;&#125;if(m&lt;n)&#123;list.add(m+1);recursiveActivitySelector(s, f, m, n);&#125; else &#123;return ;&#125; &#125;public static void main(String[] args) &#123;ActivitySelector activitySelector = new ActivitySelector();activitySelector.recursiveActivitySelector(activitySelector.s, activitySelector.f, 0, activitySelector.f.length);for (Integer i : activitySelector.list) &#123;System.out.println(i);&#125;&#125;&#125; 迭代贪心算法这个过程是假设输入活动的结束时间是已经排好序的，代码如下：123456789101112131415161718192021222324252627import java.util.ArrayList;import java.util.List;public class GreedyActivitySelector &#123;public int[] s = new int[]&#123;1,3,0,5,3,5,6,8,8,2,12&#125;;public int[] f = new int[]&#123;4,5,6,7,9,9,10,11,12,14,16&#125;;public List&lt;Integer&gt; list = new ArrayList&lt;&gt;();public void greedActivitySelector(int[] s,int[] f)&#123;int n = s.length;list.add(1);int k = 1;for (int m = 1; m &lt; n; m++) &#123;if(s[m]&gt;=f[k])&#123;list.add(k);k = m;&#125;&#125;&#125;public static void main(String[] args) &#123;ActivitySelector activitySelector = new ActivitySelector();activitySelector.recursiveActivitySelector(activitySelector.s, activitySelector.f, 0, activitySelector.f.length);for (Integer i : activitySelector.list) &#123;System.out.println(i);&#125;&#125;&#125; 贪心算法原理设计贪心算法的过程 确定问题的最优子结构 设计一个递归算法 证明一个贪心选择，则只剩下一个子问题 证明贪心选择总是安全的 设计一个递归算法实现贪心策略 将递归算法转换为迭代算法 证明一个贪心算法是否能求解一个最优化问题？具有下面性质就ok？ 贪心选择性质 我们可以通过做出局部最优选择来构造全局最优解 最优子结构 如果一个问题的最优解包含子问题的最优解 总结一步一步慢慢贪心，和做人是一样的，但是总的来说还是要考虑全局的！！！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2017%2F05%2F17%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[引：慢慢就步入了算法导论的高级设计与分析技术模块，先来看看动态规划。ps:快毕业的心情org。 动态规划总说动态规划虽然与分治方法相似，但是它能够解决子问题重叠的情况，这样就提高了效率。它通常是用来求解最优化的问题。求得是一个最优解。一般按如下4个步骤来设计一个动态规划算法。 刻画一个最优解的结构特征 递归地定义最优解的值 计算最优解的值，通常采用自底向上的方法 利用计算出的信息构造出一个最优解 钢条切割先看以前常用的分治方法即自顶向下方法,代码如下：12345678910111213141516171819202122232425262728public class CutRod &#123;//a[i]表示长度为i的钢条利润是多少public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;//自顶向下递归设计public int cutRod(int[] a,int n) &#123;if(n == 0)&#123;return 0;&#125;int q = 0;for (int i = 0; i&lt;n; i++)&#123;q = max(q,a[i]+cutRod(a,n-1-i));&#125;return q;&#125;//求最大值函数public int max(int a, int b)&#123;if(a&gt;b)&#123;return a;&#125; else &#123;return b;&#125;&#125;public static void main(String[] args) &#123;CutRod cut = new CutRod(); int lost = cut.cutRod(cut.a,10);System.out.println(lost);&#125;&#125; 问题：反复地用相同的参数值对自身进行递归调用，造成了运行时间为n的指数函数。 为了解决这个问题，我们可以采用动态规划方法求解最优钢条切割问题。 采用带备忘的自顶向下法核心是利用一个数组存储已经求解过的最优解，避免了重复的计算，具体的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MemoizedCutRod &#123;//a[i]表示长度为i的钢条利润是多少public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;//带备忘的自顶向下函数public int memoizedCutRod(int[] a,int n)&#123;//创建一个备忘的数组存储一个之前计算过的最优解int[] r = new int[n];//初始化数组for (int i : r) &#123;i = 0;&#125;//借助辅助函数计算return memoizedCutRodAux(a, n, r);&#125;//带备忘的自顶向下法辅助函数public int memoizedCutRodAux(int[] a,int n,int[] r) &#123;//定义利润int q = 0;if(n == 0)&#123;return 0;&#125; //判断原先是否已经计算过，若计算过就不用再计算if(r[n-1] &gt;0)&#123;return r[n-1]; &#125;else &#123;for (int i = 0; i&lt;n; i++)&#123;q = max(q,a[i]+memoizedCutRodAux(a, n-1-i, r));&#125;&#125;r[n-1] = q;return q;&#125;//求最大值函数public int max(int a, int b)&#123;if(a&gt;b)&#123;return a;&#125; else &#123;return b;&#125;&#125;public static void main(String[] args) &#123;MemoizedCutRod cut = new MemoizedCutRod();int lost = cut.memoizedCutRod(cut.a, 10);System.out.println(lost);&#125;&#125; 采用由底向上的方法核心是从小算到大算出每一个长度的最优解，然后返回想要的长度的最优解。代码如下： 123456789101112131415161718192021222324252627282930public class BottomUpTopCutRod &#123;//a[i]表示长度为i的钢条利润是多少public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;public int bottomUpTopCutRod(int[] a, int n)&#123;int[] r = new int[n+1];//长度为0的时候，收益为0r[0] = 0;int q = 0;for(int i = 0; i&lt;n; i++)&#123;for(int j = 0; j&lt;=i; j++)&#123;q = max(q,a[j]+r[i-j]);&#125;r[i+1] = q;&#125;return r[n];&#125;//求最大值函数public int max(int a, int b)&#123;if(a&gt;b)&#123;return a;&#125; else &#123;return b;&#125;&#125;public static void main(String[] args) &#123;BottomUpTopCutRod cut = new BottomUpTopCutRod();int lost = cut.bottomUpTopCutRod(cut.a, 10);System.out.println(lost);&#125;&#125; 优势：实现了运行时间复杂度n*n 动态规划原理适用应用动态规划方法求解的最优化问题应该具备的两个要素：最优子结构和子问题重叠 最优子结构如果一个问题的最优解包含其子问题的最优解，我们就称这个问题具有最优子结构性质。例如：无权最短路径。 重叠子问题如果递归算法反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质。例如钢条切割。 总结慢慢懂一点小算法思想。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观《驴得水》呻吟]]></title>
    <url>%2F2017%2F05%2F11%2F%E8%A7%82%E3%80%8A%E9%A9%B4%E5%BE%97%E6%B0%B4%E3%80%8B%E5%91%BB%E5%90%9F%2F</url>
    <content type="text"><![CDATA[引：其实当身边同学都在打游戏的时候，我却不能静下心来了，内心仍然是浮躁，既然不能改论文，所以自己就找电影看吧。自认为自己是一个不懂得享受的人，所以在大脑思索良久之后，决定观看好久之前评价还不错的电影《驴得水》。 总说我不知道该以什么角度来评价这部电影，但这部电影给我感受是深刻，至少在灵魂上还是有一定的冲击，感觉作者与导演把每个角色想要表达的思想基本上都表达出来了，下面我也将按这些角色把在我身上能够体会到的思想说一下，至少在我心里，这是一部好电影。 角色思想校长这个一个有抱负的校长，但是却又特别的自私，为了达成自己的抱负，他选择了屈服，虽然在某些片段来说，他有一点想反抗，如他不能忍受裴魁山去骂张一曼，但是那一点反抗却是那么无力，到最后他选择了屈服，屈服到了让自己的女儿去做牺牲。关于这个角色我不想做太多评价，他总说以大局为重，或许在生活中很多人都会这么做，自私到可以牺牲掉很多。 裴魁山这个角色应该就是现在很多人所说的腹黑吧，自己得不到，就宁愿把他毁掉，他从不介意张一曼的出身愿意娶她，到指着他的鼻子骂，这个转变让很多人心凉，追不到还能做朋友么，他的回答告诉我们，他不搞她已经是最好的结果了。爱一个可以随时为她着想，恨一个人希望所有人都恨他。 铜匠也许他后面变得很坏，但是我从头到尾都认为他是这部剧最可怜的人，他原来是一个单纯至极的人，命运使然他加入到了一个骗子集团吧，因为单纯才会认为张一曼会喜欢他吧，因为单纯所以期望太高，这导致在张一曼骂他牲口之后开始最强烈的抱负。但是有一点他这个觉得传递了不好的概念，有知识不是为了更好的抱负，而是应该为了更好的帮助别人，虽然他的行为可以理解，但是却不提倡，从他到最后还是想去美国学习，可以看出他还是很想学习的，想脱离文盲这个行列。 张一曼这是一个不畏世俗的眼光，勇敢追求自由的女子，也不能说是道德败坏吧，虽然和有妇之夫搞一起不太好，但是他自己也有自己的原则，就像他一开始不愿意将她和铜匠的事情说出来一样，他有自己一定的原则。但是在校长的屈服下，也造就了他的悲剧，最后开枪自杀了。 周铁男这个角色也是反映了一部分人，他喜欢孙佳，但是一直没有说出来，也算单纯耿直的人，平时脾气挺冲，在别人要动孙佳的时候也立马站了出来，可惜在擦过枪子的之后，他选择了屈服，他慢慢开始收敛自己，只是为了能够活下去，他甚至可以认忍受孙佳去嫁给铜匠，所以说，所谓的爱在现实的生与死之间是那么的不堪。 孙佳这个人或许是这部剧中完全没有污点的人吧，应该也是导演想表达的正面形象，他是唯一一个把驴得水当做人看的人，也是第一个想揭发整个阴谋的人，面对这一切，她说过去的都让他过去的话，那么只能越来越错，不能让错误一直延续下去。莫名戳中内心。 特派员一个目不识丁，却假装英国留学回来的官员，所谓的民间教育家的评选，不过是教育部敛财的名头，从被骗到一起骗说明政府的腐败与强势，从十万到三万，我们看到了心凉。 总结主要人物各有各的责任，他们都反应了这个世界上的一部分人，所以感受很深，点评不当之处，也希望大家担待。好吧，呻吟到此结束。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择算法]]></title>
    <url>%2F2017%2F05%2F10%2F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[引：300000是不是一个小目标，不知道为了目的还是目的，只想好好努力，功利也好，安慰也罢！ 期望为线性时间的选择算法算法思想： 检查数组是否只有一个数，如是，只好返回该数 采用随机分割将数组氛围a[p..q-1]和a[q+1..r]并返回主元q 检查如果该主元就是我们要找的数，就返回 判断前半部分的个数，如果要找的顺序大于前面的个数，就递归调用后面的数组，否则递归调用前面的数组 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Random;public class Randomized_select &#123;public int randomized_select(int[] a,int p, int r,int i)&#123;//如果分割到只剩一个元素了，那么就是这个了if(p == r)&#123;return a[p];&#125;//随机分割int q = randompartition(a, p, r);//确定q是第几小的数int k = q-p+1;if(k == i) &#123;return a[q];&#125;else if(k&lt;i)&#123;//递归调用后半部分的数return randomized_select(a, q+1, r, i-k);&#125; else &#123;//递归调用前半部分的数return randomized_select(a, p, q-1, i);&#125; &#125;//分割函数public int partition(int[] a,int p,int r)&#123;int x = a[r];int i = -1;int temp = 0;for (int j = 0; j &lt; a.length-1; j++) &#123;if(a[j]&lt;x)&#123;i=i+1;temp = a[i];a[i] = a[j];a[j] = temp;&#125;&#125;temp = a[i+1];a[i+1] = x;a[r] = temp;return i+1;&#125;//随机分割 public int randompartition(int[] a,int p,int r)&#123;int temp = 0;Random random = new Random();int i = random.nextInt(r);temp = a[i];a[i] = a[r];a[r] = temp;return partition(a, p, r);&#125;public static void main(String[] args) &#123;int[] a = new int[]&#123;3,2,9,0,7,5,4,8,6,1&#125;;Randomized_select select = new Randomized_select();int num = select.randomized_select(a, 0, a.length-1, 10);System.out.println(num);&#125;&#125; 算法分析：期望时间复杂度是线性的O(n),但是最坏的时间复杂度是O(n*n) 最坏情况为线性时间的选择算法算法思想： 将输入数组的n个元素划分为n/5组，每组5个元素，且至多只有一组由剩下的nmod5个元素组成。 寻找每一个组的中位数：首先对每组元素进行插入排序，然后确定每组的中位数。 对第2部的中位数数组利用递归调用前面的random_select()求取中位数x 利用修改的partition(),按中位数x进行划分，得到比x小的数有k个 如果i=k则返回x。如果ik，则在高区递归查找第i-k小的元素 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package select;public class GoodSelect &#123;//插入排序public void insertsort(int[] a,int p, int r)&#123;for (int i=p+1;i&lt;=r;i++) &#123;int temp = 0;//*从后往前插*for(int j = i;j&gt;p &amp;&amp; a[j]&lt;a[j-1];j--)&#123;temp = a[j];a[j] = a[j-1];a[j-1] = temp;&#125;&#125;&#125;//对数组A[]分组，每组5个元素，分别进行插入排序,返回中位数数组public int[] partInsertSort(int[] a,int p,int r) &#123;int i = 0;int[] b;if((r-p+1)%5==0)&#123;b = new int[(r-p+1)/5];&#125; else &#123;b = new int[(r-p+1)/5+1];&#125;int Length = r-p+1;if (Length &lt;= 5) //元素个数少于5个&#123; insertsort(a,p,r);b[0]=a[p+(Length-1)/2];&#125;else&#123;for (i=0;i&lt;Length/5;i++)&#123;insertsort(a,p+i*5,p+i*5+4);b[i]=a[i*5+2]; //B[i] 存储各组中位数&#125;if ( Length%5 != 0 )&#123;insertsort(a,Length-1-(Length-1)%5,Length-1);b[i]=a[Length-1-Length%5/2]; //B[i] 存储最后一组中位数&#125;&#125;return b; // 返回分组的个数&#125;//调用random_select算法，选出中位数数组的中位数public int selectmid(int[] a)&#123;Randomized_select randomized_select = new Randomized_select();int num = randomized_select.randomized_select(a, 0, a.length-1, (a.length+1)/2);return num; &#125;//安装精心挑选的中位数来分割数组public int partition(int[] a,int p,int r,int x)&#123;int j = p-1;int i = 0;int temp =0;int addr = 0;//记录最佳中位数的位置for(i = p; i&lt;r+1; i++)&#123;if(a[i]&lt;=x)&#123;j+=1;temp = a[j];a[j] = a[i];a[i] = temp; &#125;if(a[i] == x)&#123;addr = i;&#125; &#125;temp = a[j];a[j] = a[addr];a[addr] = temp; return j;&#125;public int goodselect(int[] a,int p,int r,int i)&#123;//如果分割到只剩一个元素了，那么就是这个了if(p == r)&#123;return a[p];&#125;int [] b = partInsertSort(a, p, r);int x = selectmid(b);int q = partition(a, p, r, x);//确定q是第几小的数int k = q-p+1;if(k == i) &#123;return a[q];&#125;else if(k&lt;i)&#123;//递归调用后半部分的数return goodselect(a, q+1, r, i-k);&#125; else &#123;//递归调用前半部分的数return goodselect(a, p, q-1, i);&#125; &#125;public static void main(String[] args) &#123;int[] a = new int[]&#123;2,1,4,6,5,8,9,7,11,13,12,15,16&#125;;GoodSelect select = new GoodSelect();int num = select.goodselect(a, 0, a.length-1, 13);System.out.println(num);&#125;&#125; 算法总结：毕竟是三个人发明的算法，真是好牛逼的，厉害，实现了最坏时间还是线性的。具体分析请参考算法导论原书。 总结第二个算法真的花了自己好长的时间来调试，还是说明自己的编码能力差劲，要好好努力，慢慢提高，加油！ ps：有一种体会，学算法是为了创造，大多数人只要把优秀的源码包里的算法理解了就好，并加以使用就好！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“线性时间排序（未完，待续）”]]></title>
    <url>%2F2017%2F05%2F10%2F%E2%80%9C%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%8C%E5%BE%85%E7%BB%AD%EF%BC%89%E2%80%9D%2F</url>
    <content type="text"><![CDATA[引：排序慢慢来，今天要接触到线性时间排序了：计数排序，基数排序，桶排序。 计数排序前提条件：知道输入数组的最大值。代码如下：12345678910111213141516171819202122public int[] countingsort(int[] a,int k)&#123;//初始化临时数组,k为数组的最大值int[] c = new int[k+1];for(int i=0; i&lt;=k; i++) &#123;c[i]=0;&#125;//获得等于i的元素个数for(int i= 0; i&lt;a.length-1;i++) &#123;c[a[i]] = c[a[i]]+1;&#125;//获得小于等于i的元素个数(隐含了递归调用)for(int i = 1; i&lt;=k; i++) &#123;c[i] = c[i] +c[i-1];&#125;//按顺序分到输出数组int[] b = new int[a.length];for(int i = a.length-1; i&gt;=0; i--) &#123;b[c[a[i]]] = a[i];c[a[i]] = c[a[i]]-1;&#125;return b;&#125; 优劣：实现了线性时间，但是空间损失惨重，像是叫你排序这三个数：1，3，1000000000000，马上高低立见。 基数排序IBM创始人发明，利用进制数的位进行从低到高比较。其中会将原来的数转化为r进制数，使时间复杂度变为线性。写一下伪代码123redix-sort(A,d)for i = 1 to duse a stable sort to sort array A on digit i 桶排序桶排序假设数据服从均匀分布，讲一个区间分成若干个桶，先将数据放到桶中分开排序再合并。伪代码如下12345678910bucket-sort(A)n = A.lengthlet B[0.. n-1] be a new arrayfor i = 0 to n - 1make B[i] an empty listfor i = 1 to n insert A[i] into list B[nA[i]]for i = 0 to n - 1sort list B[i] with insertion sortconcatenete the lists B[0],B[1].. B[n-1] together in order 它的期望时间为线形。 总结其中对于基数排序和桶排序理解得不是很好，需要加深理解，写出具体实现代码，未完，待续…]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性时间排序</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2017%2F05%2F10%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[引：真的是烦，连个hadoop集群环境都搭不好，发现一个人学还是很困难的，想想还是一个人看算法会简单些，所以来看看了，今天看堆排序！ 堆排序简单介绍堆排序是原址运算，后来由于Java的原因我用了变址，但是算法的思想还是没有变得的.堆分为大顶堆，小顶堆，我们下面以大顶堆为例。 维护堆我们需要一个函数在任何情况下子节点要比根节点小。函数如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546//取父节点public int parent(int i)&#123; return (int)Math.ceil(i/2)-1;&#125;//取左子树public int left(int i)&#123; if(i == 0)&#123; return i+1; &#125; else&#123; return 2*i+1; &#125;&#125;//取右子树public int right(int i)&#123; if(i == 0)&#123; return i+2; &#125; else&#123; return 2*i+2; &#125;&#125;//维护大顶堆public int[] max_heapify(int[] a,int i)&#123; int l = left(i); int r = right(i); int largest = 0; int temp = 0; if(l&gt;=a.length &amp;&amp; r&gt;=a.length)&#123; return a; &#125; if(l&lt;a.length &amp;&amp; a[l]&gt;a[i])&#123; largest = l; &#125; else&#123; largest = i; &#125; if(r&lt;a.length &amp;&amp; a[r]&gt;a[largest])&#123; largest = r; &#125; if(largest!=i) &#123; temp = a[i]; a[i] = a[largest]; a[largest] = temp; max_heapify(a, largest); &#125; return a; &#125; 建堆在对数组遍历建立二叉树的时候，我们容易得出Math.floor(n/2)到n都是叶节点，其余是根节点，所以我们在建堆得时候冲根节点不断往前维护就好。代码如下：12345678//建大堆public int[] bulid_max_heap(int[] a)&#123; heap_size = a.length; for(int i = (int)Math.floor(a.length/2)-1; i&gt;=0; i--)&#123; max_heapify(a, i); &#125; return a;&#125; 堆排序算法思想：先取出顶，再维护，再取顶，再维护，知道最后代码如下：12345678910111213//堆排序算法public int[] heapsort(int[] a) &#123; int[] b = new int[a.length];//无奈之举，java没有size这个属性，或者用list也可以 bulid_max_heap(a); for(int i = a.length-1; i&gt;=1; i--)&#123; b[i] = a[0]; a[0] = a[i]; a[i] = 0;//使最后一个元素不参与排序 max_heapify(a, 0); &#125; b[0] = a[0]; return b;&#125; 算法时间复杂度：nlgn 重要应用——优先队列优先队列应用于共享计算机的系统的作业调度，最大优先队列记录将要执行的各个作业以及它们之间的相对优先级，在任何时候都可以调用insert把一个新作业加入到队列中来。讲一下最大优先序列的几个操作。 maximum获取最大值代码如下：1234 //获取最大值public int maximum(int[] a)&#123; return a[1];&#125; 去掉并返回数组中的最大键值得元素代码如下:12345678910//去掉并返回数组中具有最大键值得元素public int extract_max(int[] a)&#123; if(a.length&lt;1)&#123; System.out.println(&quot;heap underflow&quot;); &#125; int max = a[0]; a[0] = a[a.length]; max_heapify(a, 0); return max;&#125; 总结加油呀加油！堆排序还是强大的，期待运用！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx反向代理与负载均衡]]></title>
    <url>%2F2017%2F05%2F06%2Fnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[引：慢慢做项目的过程中，也就接触到了负载均衡，谈到负载均衡就会接触到反向代理服务器，这里介绍一下nginx。 nginx反向代理nginx简介nginx是一个使用c语言开发的高性能的http服务器及反向代理服务器，是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。感觉棒棒哒。 nginx应用场景 http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 nginx安装启动配置 安装：nginx一般安装在linux下 启动： 在sbin目录下执行: ./nginx 如果访问不到，可能就是linux防火墙没有开启8080端口的访问——关闭：在sbin目录下执行: ./nginx -s stop——刷新配置：在sbin目录下执行: ./nginx -s reload 配置虚拟主机：在nginx.conf文件中添加一个Service节点，修改端口号就可以12345678910111213server &#123; listen 81; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html81; index index.html index.htm;&#125;&#125; nginx反向代理反向代理服务器是引用在服务端。决定哪台服务器提供服务。用一张图来理解： nginx负载均衡并发量大的时候自然会用到负载均衡，其实每台服务器的内容都是一样的，多台机器服务自然减轻了单台服务器的压力。在nginx中其实配置很简单，如下：1234567891011121314151617upstream tomcats&#123; server 192.168.142.128:8080 weight=2; server 192.168.142.128:8081;&#125;server&#123; listen 80; server_name tomcat.taobao.com; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_pass http://tomcats; index index.html index.htm; &#125;&#125; 只需要在upstream的server后面添加一个weight即可代表权重。权重越高，分配请求的数量就越多。默认权重是1。 总结其实很多东西没有自己想象的那么难，好好努力，每天积累！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序及随机化算法]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[引：算法一直很重要，最近没有心情去看项目的代码与技术，所以就拿起其了算法导论来看，最经典的快速排序及随机化算法，java实现。 快速排序算法 核心思想分治思想和原址运算：看一张图 算法具体实现 public class QuickSort { public int partition(int[] a,int p,int r){ int x = a[r]; int i = -1; int temp = 0; for (int j = 0; j &lt; a.length-1; j++) { if(a[j]&lt;x){ i=i+1; temp = a[i]; a[i] = a[j]; a[j] = temp; } } temp = a[i+1]; a[i+1] = x; a[r] = temp; return i+1; } public int[] quicksort(int[] b,int p,int r){ if(p&lt;r){ int q = partition(b,p,r); quicksort(b, p, q-1); quicksort(b, q+1, r); } return b; } public static void main(String[] args) { QuickSort sort = new QuickSort(); int[] a = {2,8,7,1,3,5,6,4}; int[] b = sort.quicksort(a, 0, a.length-1); for (int i : b) { System.out.print(i+&quot; &quot;); } } } 3.时间复杂度 通过分析我们最看重的平均复杂度是nlgn 随机化算法 核心思想 在算法加入随机性，要么在使序列生成随机化，要么就是使主元随机化，这里我们使主元随机化。 算法具体实现 import java.util.Random; public class RandomQuickSort { public int partition(int[] a,int p,int r){ int x = a[r]; int i = -1; int temp = 0; for (int j = 0; j &lt; a.length-1; j++) { if(a[j]&lt;x){ i=i+1; temp = a[i]; a[i] = a[j]; a[j] = temp; } } temp = a[i+1]; a[i+1] = x; a[r] = temp; return i+1; } public int randompartition(int[] a,int p,int r){ int temp = 0; Random random = new Random(); int i = random.nextInt(r); temp = a[i]; a[i] = a[r]; a[r] = temp; return partition(a, p, r); } public int[] randomquicksort(int[] b,int p,int r){ if(p&lt;r){ int q = randompartition(b, p, r); randomquicksort(b, p, q-1); randomquicksort(b, q+1, r); } return b; } public static void main(String[] args) { RandomQuickSort sort = new RandomQuickSort(); int[] a = {2,8,7,1,3,5,6,4}; int[] b = sort.randomquicksort(a, 0, a.length-1); for (int i : b) { System.out.print(i+&quot; &quot;); } } } 时间复杂度 通过分析我们最看重的平均复杂度是nlgn 基本排序算法 小结：同等情况下快速排序&gt;随机化算法&gt;归并排序&gt;插入排序；在有序的情况下随机化算法&gt;快速排序 总结慢慢走，不要急！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git个人使用与多人协作]]></title>
    <url>%2F2017%2F05%2F04%2Fgit%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[引：因为没有加入到什么团队中，没有机会和别人一起合作过项目，所以对git使用并不熟练，但是这次比较空，就好好梳理一下吧！ 个人使用git介绍特点就是分布式了，请看下图，每一台电脑都是一个仓库，大家都可以使用。 仓库理解及操作先上图： 有个上面的图做铺垫，下面的操作也就好理解了 添加文件：git add file 提交文件：git commit -m &quot;提交描述&quot; 查看状态:git status 查看日志：git log 相关版本号可以通过reset来回退到任何提交时间点 添加远程库：git remote add origin git@github.com:username/repository 推送到远程库： 第一次用：git push -u origin master之后用git push origin master注意点：要将电脑的ssh添加到你的github里 克隆远程库：git clone origin git@github.com:username/repository 多人协作我想大家需要理解这样一张图： 推送分支：$ git push origin branchname 抓取分支：git clone origin git@github.com:username/repository;git checkout -b dev origin/dev 基本操作肯定会碰到问题： 如果你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，那么就会提交被解决，这个时候就需要： git pull 这个时候合并是有冲突的，需要你本地修改之后再提交上去。 总结目前自己所要掌握的就是这些东西了，再遇到问题可以谷歌或者百度。最后感谢廖雪峰的git教程]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String,StringBuilder,StringBuffer区别]]></title>
    <url>%2F2017%2F05%2F04%2FString-StringBuilder-StringBuffer%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[引：最近心情非常的不静，我知道自己需要沉下心去沉淀，慢慢来，小朋友。今天谈谈3个字符串类 String查看String源码的时候，我们很容易看到&gt; public final class String 从源码中对String的定义可以知道它是final类，这意味着她不可被继承，也不可被更改。而且总它的方法中也没有可以拼接字符串的函数。 StringBuilder查看StringBuilder源码的时候，我们也可以看到这样的定义：&gt; public final class StringBuilder extends AbstractStringBuilder 我们发现他也是final类，但是它却又append()方法，这是为什么，我们找到它的append(): @Override public StringBuilder append(String str) { super.append(str); return this; } 我们看到他的append()方法是调用他的父类来的，所以我们继续看看他的父类是在搞什么鬼👻 public AbstractStringBuilder append(String str) { if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this; } 我们终于找到他怎么又这个添加字符串的方法了。具体AbstractStringBuilder是怎么实现添加的就让想要了解的人继续往下看源码就好了。 对比string: 我们可以从日常编写的代码可以了解到，用String拼接由于每次都是新建一个对象所以效率自然是低的，所以在使用字符串拼接的时候还是用StringBuilder比较好，但是对于单个常量字符串来说还是String好，因为它是放在常量池里，读取速度比放在堆中的对象自然是要快很多。 StringBuffer这又是一个什么鬼，继续看源码吧 public final class StringBuffer extends AbstractStringBuilder 这个和StringBuilder一样也是final类，但是我们可以很清楚的看到也是继承了AbstractStringBuilder，也就是说它也有append()方法，但是我们可以它的append()方法。 public synchronized StringBuffer append(String str) { toStringCache = null; super.append(str); return this; } 我们看到它的append()方法加入了synchronized关键字，所以它是个线程安全的类 和StringBuilder的区别： 由于他是线程安全的，所以自然牺牲了效率，在操作速度上没有StringBuilder快。 总结：点点滴滴积累]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请不要无脑]]></title>
    <url>%2F2017%2F04%2F27%2F%E8%AF%B7%E4%B8%8D%E8%A6%81%E6%97%A0%E8%84%91%2F</url>
    <content type="text"><![CDATA[大喊一声密码. Decrypt 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]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次失败的面试]]></title>
    <url>%2F2017%2F04%2F26%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[大喊一声密码. Decrypt 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]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH项目初体验]]></title>
    <url>%2F2017%2F04%2F24%2FSSH%E9%A1%B9%E7%9B%AE%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[引：历时四天，终于在视频的帮助下完成了基于SSH（struts2+hibernate3+spring4）的一个网站商城项目，也是自己第一次采用idea开发项目简单，谈谈收获和感想。 代码流程 导包主要的文件：导三大框架的包这里的包我也不贴图了，都是最基本的jar包 框架配置这里我想说的是三个文件： web.xml：配置struts核心过滤器和配置Spring的核心监听器 struts.xml：配置各种action applicationContext.xml：作为大管家事情也就比较多了，有配置数据库C3P0连接池，配置Hibernate引入数据源，事务管理，管理action，service，dao 按层码代码 分层架构 web层主要使用action进行控制，这里使用了动态匹配，如userAction_*.action其中要点： 值栈：对于单个业务逻辑来说存取值实在是太方便了。 模型驱动：对于模块的对象使用模型存值也很方便 拦截器：对于后台范围一定要对访问进行控制，若未登录，请先登录 ognl表达式：可以进行运算，除模型驱动以及值栈内取值之外都要加# service层本次项目并未多少体现出来，我们只要注意添加spring事务注解 dao层此次使用的hibernate，要点如下 实体映射文件：对于主外键一定要设置正确，懒加载问题，级联删除问题 hql语句：join的用法，面向对象的语句编写 项目模块这里只是简单说说作为一个商场应该具有的模块 前台首页；前台用户 ；一级目录； 二级目录； 商品； 购物车； 订单 后台后台用户；一级目录；二级目录；商品；订单 查bug方法即使是按着视频来的，但是也还是会出错，有的时候还查了一个多小时，bug：码农的一生之敌呀！回到正题：首先看控制台错误，分析错误类型 前台传数据错误可以将表单的发送方式改为get，这个就可以从uri中看出错误了，自己好几次入坑，就是在参数填写的地方多了一个空格，欲哭无泪。 业务逻辑代码错误其实最简单也最烦，就是利用debug。按逻辑顺序进行查错。 数据库查询出错可以充分利用控制台输出的sql语句进行排错，将sql语句放到sql桌面程序中查询，是否与自己想要的结果一致，如果不一致，就很有可能是自己的hql语句写错，或者映射文件出错了。 感想关于这个项目架构都是比较简单的，业务逻辑也都是CRUD也算简单，可能还有最重要的高并发问题没有考虑，但是整个项目做下来，自己也算理解了整个项目系统，但是自己绝对不能以CRUD为终点，继续向前加油！！！！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iis实现手机端访问电脑本地服务器]]></title>
    <url>%2F2017%2F04%2F24%2Fiis%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E7%AB%AF%E8%AE%BF%E9%97%AE%E7%94%B5%E8%84%91%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[引：对于很多没有服务器的人来说,实现手机端访问自己写的网页还是有困难的，虽然我们可以可以利用githubpage来实现挂载页面，但是调试起来还是不方便，所以iis就成为了一种简单的方式。 iis简介iis（Internet Information Services）是由微软公司提供的基于运行Microsoft Windows的互联网基本服务,其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。 iis安装这里我就不多说了，网上一搜，安装教程一大把，这里推荐一个链接安装iis 有无线的时候使用大部分人，大部分时间，大部分地方，相信大家都会身处在无线之下，所以只要按照上面的链接使用就可以了。 没无线的时候使用这个时候就要借助流量与热点了 打开手机热点 查看电脑ip地址一般这个时候ip地址已经变了，所有之前按照有无线的时候电脑的ip设置访问地址就有问题了，所以要利用新的ip地址设置访问地址 用手机访问新的ip地址一下子就爽歪歪了 总结 iis对于windows用户来说真是出家旅行，调试代码必备之良品。 当不能访问的时候一定要随时关注电脑的ip地址是否已经发生变化，做到随时更改]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
</search>