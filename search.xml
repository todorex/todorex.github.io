<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解JVM_9_类加载器]]></title>
    <url>%2F2017%2F12%2F06%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-9-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[引：之前一直在说类加载，类加载就需要类加载器，类加载最初是为了满足Java Applet，现在基本已经死掉了，但是类加载却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为Java体系中一块重要的基石，可谓失之桑榆，收之东隅。 什么是类加载器？虚拟机设计团队把类加载阶段的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己去决定如何去获取所需要的类，实现这个动作的代码模块称为“类加载器”。 同一个Class文件，不同的类对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。换个说法：比较两个类是否“相等”，只是在这两个类是由同一个类加载器加载的前提下才有意义，如果这两个类源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。 这里的相等包括：代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法返回结果，下面的代码展示了不同的类加载器对instanceof关键字运算的结果的影响。(下面的代码属于破坏双亲委派模型，只是为了验证类的命名空间)1234567891011121314151617181920212223242526272829303132public class ClassLoaderTest &#123; public static void main(String[] args) throws Exception &#123; ClassLoader myLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try &#123; String fileName = name.substring(name.lastIndexOf(".") + 1) + ".class"; InputStream is = getClass().getResourceAsStream(fileName); if (is == null) &#123; return super.loadClass(name); &#125; byte[] b = new byte[is.available()]; is.read(b); return defineClass(name,b,0,b.length); &#125; catch (IOException e) &#123; throw new ClassNotFoundException(name); &#125; &#125; &#125;; Object obj = myLoader.loadClass("com.todorex.demo.ClassLoaderTest").newInstance(); System.out.println(obj.getClass()); System.out.println(obj instanceof com.todorex.demo.ClassLoaderTest ); &#125;&#125; 运行结果：12class com.todorex.demo.ClassLoaderTestfalse 这里的false就证明了两个类虽然来自于同一个Class文件，但是由于使用的类加载器不同，就依然是两个独立的类。 双亲委派模型类加载器的类型Java虚拟机角度 启动类加载器，它本身是由C++语言实现，或者底层的关键方法是用C实现的。 所有其他类加载器，这些类加载器都由Java语言实现。 Java开发人员角度 启动类加载器：这个类加载器负责将存放在\lib目录中的，或者被-Xbootclasspath参数所指定的路径找那个的，并且是虚拟机识别的（按照文件名识别的）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接使用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，直接使用null即可。（不知道怎么用，知道的大佬请告知！！！！） 扩展类加载器：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以使用扩展类加载器。 应用程序类加载器：这个类加载器由sun.misc.Launcher$AppClassLoader实现，也称系统类加载器。它负责加载用户所指定的类路径java -classpath或-Djava.class.path的所有类，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 类加载器的双亲委派模型模型图 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里的类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。（组合就是在一个类中调用另一个类的代码） 工作过程我相信这张图最清楚了： 我们可以由图看到以下过程： 自底向上检查类是否已经加载，若已加载，直接返回。 若所有父类都没有加载该类，则自顶向下尝试加载该类。 如果加载不成功，则抛出ClassNotFoundException异常。 我们可以从代码看看他是怎么实现的？ 先看ClassLoader函数的loadClass函数1234567891011121314151617181920212223242526272829303132333435363738protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // 先从缓存查找该class对象，找到就不用重新加载 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; //如果找不到，则委托给父类加载器去加载 c = parent.loadClass(name, false); &#125; else &#123; //如果没有父类，则委托给启动加载器去加载 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // 如果都没有找到，则通过自定义实现的findClass去查找并加载 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123;//是否需要在加载时进行解析 resolveClass(c); &#125; return c; &#125; &#125; 从该函数我们可以得知双亲委派模型会先递归去查找父加载器是否已经加载过该类了。如果父加载器都没有加载过该类，则开始调用fandClass()尝试去加载该类。由于启动类加载器不可知，我们可以去看看扩展类加载器的findClass()。我们可以看到下面的类图： 我接着我想去看看ExtClassLoader类里面的findClass()方法，结果发现没有，只要去他的父类URLClassLoader去找找，还好找到了，可以看看下面的代码：123456789101112131415161718192021222324252627282930protected Class&lt;?&gt; findClass(final String name) throws ClassNotFoundException&#123; final Class&lt;?&gt; result; try &#123; result = AccessController.doPrivileged( new PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123; public Class&lt;?&gt; run() throws ClassNotFoundException &#123; String path = name.replace('.', '/').concat(".class"); Resource res = ucp.getResource(path, false); if (res != null) &#123; try &#123; //defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象 return defineClass(name, res); &#125; catch (IOException e) &#123; throw new ClassNotFoundException(name, e); &#125; &#125; else &#123; return null; &#125; &#125; &#125;, acc); &#125; catch (java.security.PrivilegedActionException pae) &#123; throw (ClassNotFoundException) pae.getException(); &#125; if (result == null) &#123; throw new ClassNotFoundException(name); &#125; return result;&#125; 其实AppClassLoader的findClass()也是继承自URLCLassLoader，所以都是一样的，我们再结合最开始的loadClass()就可以很好的理解了上面双亲委派模型的工作流程了。 好处java随着它的类加载一起具备了一种带有优先级的层次关系，它能保证一个类在程序中各种类加载器环境中都是同一个类。 双亲委派模型的“双亲”在Java虚拟机英文文章里双亲委派模型的英文是Parent-Delegation Model，不知道为什么中文翻译会称他为双亲委派模型，可能是他一般都会找到一个爸爸去委托去处理吧。 破坏双亲委派模型目前为止，双亲委派模型主要出现过3次较大的“被破坏”的情况。 在JDK1.2之前，新建加载器都是通过重写loadClass()方法来区分不同的加载器,以及修改加载逻辑，这样就破坏了双亲委派模型的向上寻找父加载器去加载的规范，在JDK1.2之后为了向前兼容，ClassLoader添加了新的protect方法findCLass()方法，从而实现了在双亲委派模型上实现加载逻辑的修改。 线程上下文类加载器，如JNDI服务(没用过) 实现动态性，如OSGi(没用过) 总结有时候分析东西查看源码是必要的，还要利用一些工具去分析他们的继承关系。 参考 《深入理解Java虚拟机》 深入理解Java类加载器(ClassLoader) 深入理解Java类加载器(一)：Java类加载原理解析]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_8_虚拟机类加载机制]]></title>
    <url>%2F2017%2F12%2F02%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-8-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[引：在Class文件中描述的各种信息最终都需要加载到虚拟机之中之后才能运行和使用。而虚拟机如何加载这些Class文件？Class文件中的信息进入到虚拟机后会发生什么变化？ 概述虚拟机的类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。 C/C++和Java链接的不同： C/C++：在编译时完成链接工作；降低了运行时的性能开销，但是也降低了运行时的灵活性。 Java：类型的加载、链接和初始化过程都是在程序运行期间完成的；增加了运行时的性能开销，但是增强了运行时的灵活性，使Java变成了可以动态扩展的语言。这里的动态扩展可以分为两点： 动态加载：用户可以通过Java预定义的或者自定义的类加载，让一个本地的应用程序可以在运行时在从网络或其他地方加载一个二进制流作为程序代码的一部分。 动态链接：如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类。 类加载的时机类的生命周期类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括： 其中链接包括下面三个部分： 生命周期中加载、验证、准备、初始化和卸载这5个阶段顺序是确定的，但是又是可以互相交叉混合式进行的。 类的初始化时机什么情况下需要开始类加载过程的第一阶段：加载？Java虚拟机规范没有进行强制约束，但是对初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类“初始化”。 遇到new、getstatic、putstatic或者invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要触发其初始化，生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段（被final修饰并且已在编译器把结果放在常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用java.lang.reflect包的时候对类进行反射调用的时候，如果类没有进行过初始化，则需要触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要制定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个类。 如果一个java.lang.invoke.MethodHandle实例解析结果是REF_getStaic,REF_putStatic,REF_invokeStatic的方法句柄，并且这个句柄所对应的类没有进行过初始化，则需要先触发其初始化。（还没用过） 上面5种场景中的行为成为对一个类的主动引用，除此之外，所有应用类的方式都不会触发初始化，成为被动引用。下面是几个被动引用的场景： 通过子类引用父类的静态字段，不会导致子类初始化。 通过数组来定义引用类，不会触发此类的初始化。 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，不会触发该类的初始化，因为在编译阶段通过常量传播优化，已经将其他类的常量存入到调用类的常量池了。 说一点接口与类初始化世时机的不同：在有且只有的5条中的第3条,当一个类在初始化时，要求其父类全部都已经初始化过了，但是接口在初始化时，不要求其父接口全部都完成了初始化，只有真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。 类加载的过程Java虚拟机中类加载的全过程为： 加载虚拟机在加载阶段要干什么 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个类的字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 二进制字节流的来源 从ZIP包中读取，最终成为了日后JAR、EAR、WAR格式的基础。 从网络中获取，这个场景最典型的应用就是Applet（没用过）。 运行时计算生成，这个场景使用的最多的就是动态代理技术，生成代理类的二进制字节流。 由其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。 加载阶段的注意点 非数组类的加载阶段是开发人员可控性最强的，加载阶段既可以使用系统提供的引导类加载器，也可以使用用户自定义的类加载器。 数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的，但是最终还是要靠类加载器是创建数组类里面的元素类型，每个数组都会在加载数组元素的类加载器的类名称空间上被标识。 Java虚拟机规范没有规定类在方法区的具体数据结构，也没有规定生成的Class对象存储在哪里，对于HotSpot虚拟机而言，它被存放在方法区里面，jdk1.8以后应该在直接内存中吧。 加载阶段与连接阶段的部分内容（一部分字节码文件格式验证工作）是交叉进行的。 验证验证目的由于Class文件并不一定要求用Java源码编译而来，可以使用任何途径产生，所以安全性得不到保证，而验证的目的就是为了确保Class文件的字节流包含的信息符合虚拟机的要求，并且不会危害虚拟机自身的安全。 验证过程 文件格式验证 主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上负荷一个Java类型信息的要求，这个阶段的验证是基于二进制字节流进行的，只有通过这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字符流。 元数据验证 主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。 字节码验证 主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。 符号引用验证 发生在解析阶段（将符号引用转化为直接引用），主要目的是确保解析动作能正常执行。 调优的地方如果所运行的代码都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，但是这里的初始值需要注意一下： 通常情况：初始值是数据类型的零值 类变量有fianl关键字修饰：初始值是ConstantValue属性所指定的值 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。这里解释一下直接引用和符号引用： 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量。它的字面量形式明确定义在Java虚拟机规范的Class文件格式中。符号引用于虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。 直接引用：它可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局相关，有了直接引用，那么引用的目标必定已经在内存中存在。 虚拟机规范中并未规定解析阶段发生的具体时间。所以虚拟机可以根据需要来判断到底是在类被加载器加载时就对常量池的符号引用进行解析，还是等到一个符号引用被使用前再去解析它。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 初始化类初始化时类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化变量和其他资源，从另一个角度来表达：初始化阶段是执行类构造器clinit()方法的过程。下面是clinit()方法的注意点： clinit()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中语句合并产生的，收集的顺序是有语句在源文件出现的顺序决定的，这里有很特别的一点：静态语句块中只能访问到定义在静态语句块之前的变量，定义在之后的变量，在前面的静态语句块可以赋值，但是不能访问，代码如下： 123456789public class Test &#123; static &#123; i =0; //正常编译 System.out.println(i); //提示“非法向前引用” &#125; static int i =1;&#125; clinit()方法不需要显式地调用父类构造器，虚拟机会保证在子类的clinit()方法执行前，父类的clinit()方法已经执行完毕。 由于父类的clinit()方法先执行，所以父类定义的静态语句块要优先于子类的变量赋值操作。 虚拟机会保证一个类的clinit()方法在多线程中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其他线程都要阻塞等待，直到活动线程执行clinit()方法完毕。 总结类加载的5个阶段都很重要，对理解对象的创建过程有了更好的理解。 参考 《深入理解Java虚拟机》]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_7_探秘类文件]]></title>
    <url>%2F2017%2F12%2F01%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-7-%E6%8E%A2%E7%A7%98%E7%B1%BB%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[引：java代码编译的结果从本地机器码转变为字节码，并且生成了类文件，那么这个类文件里面是什么东西呢？ JVM的无关性一般提到Java的好处，其中必定有一条是平台无关性，但是这个太狭隘了，其实它有两点无关性。 平台无关性Java在刚刚诞生之时就有一个著名的宣传口号：“一次编写，到处运行（Write Once, Run Anywhere）”。“与平台无关”的理想最终实现在操作系统的应用层上：其实就是Java虚拟机了，他可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写，到处运行”。 语言无关性目前已经一大批能够在JVM运行语言了，就我自己知道并且使用过就有Groovy、Jython、Scala等。实现语言无关性的基础仍然是虚拟机和字节码存储格式。其他语言通过自己的编译把程序代码编程成符合Java虚拟机规范的Class文件即可。 类文件的结构Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑排列在Class文件之中，中间没有任何分隔符。Class文件只有两种数据类型：无符号数和表 无符号数：以u1，u2，u4，u8来分别代表1个字节，2个字节，4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数值量或者按照UTF-8编码构成字符串值。 表：它是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表习惯地以“_info”结尾。 整个Class文件本质上就是一张表，它由下表所示的数据项构成。 类型 名称 数量 u4 魔数 1 u2 次版本号 1 u2 主版本号 1 u2 常量数量 1 cp_info 常量池 常量数量-1 u2 访问标志 1 u2 类索引 1 u2 父类索引 1 u2 接口数量 1 u2 接口索引集合 接口数量 u2 字段数量 1 field_info 字段表 字段数量 u2 方法数量 1 method_info 方法表 方法数量 u2 属性数量 1 attribute_info 属性表 属性数量 接下里稍微详细看看上面的数据： 不过按例子来吧，下面是一个简单的Java类1234567891011package com.todorex.demo;public class TestClass &#123; private int m; public int inc() &#123; return m+1; &#125;&#125; 先编译这个类得到TestClass.class文件，打开它可以下面的16进制数：12345678910111213141516171819cafe babe 0000 0034 0013 0a00 0400 0f090003 0010 0700 1107 0012 0100 016d 01000149 0100 063c 696e 6974 3e01 0003 28295601 0004 436f 6465 0100 0f4c 696e 654e756d 6265 7254 6162 6c65 0100 0369 6e630100 0328 2949 0100 0a53 6f75 7263 6546696c 6501 000e 5465 7374 436c 6173 732e6a61 7661 0c00 0700 080c 0005 0006 01001a63 6f6d 2f74 6f64 6f72 6578 2f64 656d6f2f 5465 7374 436c 6173 7301 0010 6a617661 2f6c 616e 672f 4f62 6a65 6374 00210003 0004 0000 0001 0002 0005 0006 00000002 0001 0007 0008 0001 0009 0000 001d0001 0001 0000 0005 2ab7 0001 b100 00000100 0a00 0000 0600 0100 0000 0600 01000b00 0c00 0100 0900 0000 1f00 0200 01000000 072a b400 0204 60ac 0000 0001 000a0000 0006 0001 0000 0009 0001 000d 00000002 000e 然后用javap 解析TestClass.class文件，得到：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Classfile /Users/rex/IdeaProjects/JVMTest/src/com/todorex/demo/TestClass.class Last modified 2017-12-1; size 292 bytes MD5 checksum 337a51d3bebe0e9a82142a352eb0977e Compiled from "TestClass.java"public class com.todorex.demo.TestClass minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #3.#16 // com/todorex/demo/TestClass.m:I #3 = Class #17 // com/todorex/demo/TestClass #4 = Class #18 // java/lang/Object #5 = Utf8 m #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 inc #12 = Utf8 ()I #13 = Utf8 SourceFile #14 = Utf8 TestClass.java #15 = NameAndType #7:#8 // "&lt;init&gt;":()V #16 = NameAndType #5:#6 // m:I #17 = Utf8 com/todorex/demo/TestClass #18 = Utf8 java/lang/Object&#123; public com.todorex.demo.TestClass(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 6: 0 public int inc(); descriptor: ()I flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: getfield #2 // Field m:I 4: iconst_1 5: iadd 6: ireturn LineNumberTable: line 9: 0&#125;SourceFile: "TestClass.java" 魔数 每个Class文件的头4个字节成为魔数 使用魔数来进行身份识别（文件类别），因为如果使用文件名来识别，安全性太低，由于文件名可以随意改动。 Class文件的魔数的获得就有“浪漫气息”，值为0xcafebabe,上面16进制文件也可以看到。这让自己想起了高中用的三星手机打开qq就是一杯咖啡的标志。 Class文件的版本接下来第5，6个字节显示的是次版本号，7，8字节显示的是主版本号。 高版本的JDK可以向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。 常量池在版本号之后的是常量池入口。 常量池是Class文件结构中与其他项目关联最大的数据类型，也是占Class文件空间最大的数据项目之一。 常量池常量的数据不是固定的，在最前面的Class文件组成可以看到有一个常量数量项，这个容量计数是从1而不是0开始的，比如上面的十六进制的值为0x0013(19)就代表有18个常量。 常量池主要存放两大类变量 字面量：文本字符串、声明为final的常量值等 符号引用：（编译原理的概念） 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 常量池的每一项常量都是表，常量的顺序可以参照javap解析出来的常量顺序，在JDK1.7以后共有14种不同类型的表，他们共同点是表的第一位是一个u1类型的标志位（tag），具体的标志对应的类型参照书《深入理解Java虚拟机》。这里提一下CONSTANT_UTF8_info这个表： 类型 名称 数量 u1 tag 1 u2 length 1 u1 bytes length length值说明了UTF-8编码的字符串长度是多少字节，他后面跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。而u2最大值是65535，所以说如果Java程序如果定义了超过64KB（大约）英文字符的变量或者方法名，将无法编译。 UTF-8缩略编码和UTF-8编码的区别：UTF-8编码都是使用3个字节编码，而UTF-8缩略编码可以使用1或2或3个字节编码。 访问标志在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等，访问标志一共有16个标志位可以使用，当前只定义了8个。 类索引、父类索引、接口索引集合 类索引、父类索引都是u2类型的数据，类索引、父类索引都是指向一个CONSTANT_Class_info的类描述符常量 接口索引集合是一组u2类型的数据的集合，它入口的第一项是u2的接口计数器，后面就是具体接口索引 Class文件有这三项数据来确定这个类的继承关系 字段表集合接下来是字段表，字段表用于描述接口或者类中声明的变量，包括类级变量以及实例级变量，不包括方法内部声明的局部变量。我们看一下一个字段表的构成： 类型 名称 数量 u2 访问标志 1 u2 简单名称索引 1 u2 描述符索引 1 u2 属性数量 1 attribute_info 属性表 属性数量 根据上表我们解析一下其中的含义： 访问标志：它和之前的访问标志很类似。 简单名称索引：它指向一个CONSTANT_UTF8_info类型的常量，这里面存储了本字段的名字信息，像javap解析后的第5个常量m。 描述符索引：用来描述字段的数据类型，像javap解析后的第6个常量I,代表了基本类型int 属性表（可能有ConstantValue表 下面是字符表的注意点： 字段表集合不会列出从超类或者父接口继承而来的字段。 字段表有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加执行外部类实例的字段。（不懂，大佬请指教） Java语言中字段是无法重载的，名称必须不一样，但是对于字节码来说，如果两个字段的描述符不一致，那么字段重名是合法的。 方法表集合接下来是方法表，方法表的内容和字段表几乎完全一致。其中坑顶也看一下方法表的构成： 类型 名称 数量 u2 访问标志 1 u2 简单名称索引 1 u2 描述符索引 1 u2 属性数量 1 attribute_info 属性表 属性数量 这里解释一下和字段表不一样的地方 简单名称索引：它指向一个CONSTANT_UTF8_info类型的常量，这里面存储了本字段的名字信息，像javap解析后的第11个常量inc。 描述符索引：它的作用是用来描方法的参数列表（包括数量、类型以及顺序）和返回值，像javap解析后的第12个常量()I,表示的就是一个返回值为int的方法。 属性表：这里肯定存放了Code属性表（方法里的Java代码） 下面是方法表的注意点： 如果父类方法在子类没有被重写，方法表集合中就不会出现来自父类的方法信息。 可能会出现由编译器自动添加的方法，最典型的有类构造器“”方法和实例构造器“”方法，就像javap解析后的第11个常量。 在Java语言中，要重载一个方法，需要相同的简单名称和与原方法不同的Java代码的方法特征签名，这里需要解释一下Java特征签名和JVM特征签名： Java特征签名：方法名称、参数顺序 JVM特征签名：Java特征签名、方法返回值以及受查异常表 属性表集合最后就是属性表集合了，在Class文件、字段表、方法表都可以携带自己的属性表集合，以及用于描述某些场景专有的信息。属性表集合不要求各个属性具有严格的顺序，并且只要不与已有属性名重复就好。 上面程序的例子出现过几个属性表：Code、LineNumberTable、SourceFile、ConstantValue，接下来我们详细说一下： Code属性Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内，Code属性出现在方法表属性集合之中，我们先看看Code属性表的结构： 类型 名称 数量 u2 属性名索引 1 u4 属性长度 1 u2 操作数栈深度的最大值 1 u2 局部变量表所需的存储空间 1 u4 Java方法代码字节码指令长度 1 u1 Java方法代码字节码 Java方法代码字节码指令长度 u2 显式异常表长度 1 exception_info 显式异常表 显式异常表长度 u2 属性个数 1 attribute_info 属性表 属性个数 接下来我们说明一下几个关键项： 属性名索引：它是一项指向CONSTANT_UTF8_info型的索引，常量值固定为“Code”，就像上面javap解析出来的常量池的第9个。 属性长度：固定为整个属性表长度减去6个字节。 操作数栈深度的最大值：在方法执行的任意时刻，操作数栈都不会超过这个深度，虚拟机运行的时候需要根据这个值来分配栈栈中的操作数栈深度。 局部变量表所需的存储空间：它的单位是Slot，局部变量表存储了方法参数（包括实例方法中的隐藏参数this）、显示异常处理器的参数（try-catch检查的异常）、方法体中定义的局部变量，Javac编译器会根据变量的作用域来分配Slot，然后计算出需要的存储空间大小。 Java方法代码字节码指令长度和Java方法代码字节码：存储了Java源程序编译后生成的字节码指令，目前Java虚拟机规范已经定义了约200条编码值对应的指令含义。 PS：如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义以及其他信息）两部分，那么在整个Class文件，Code属性用来描述代码，所有其他数据项目都用于描述元数据。 显式异常表：用于显示try-catch代码块要检查的异常 LineNumberTable它的使用位置是在Code属性，用于描述Java源码行号与字节码行号之间的对应关系，当抛出异常的时候堆栈会显示出错的行号。 SourceFile它的使用位置是类文件，用于记录生成这个Class文件的源码文件名称，当抛出异常的时候会显示出错代码所属的文件名。 ConstantValue它的使用位置是字段表，作用是通知虚拟机自动为静态变量赋值，只有static关键字修饰的变量（类变量）才可以使用这项属性，虚拟机对于类变量和实例变量赋值的方式有所不用。 实例变量：在实例构造器方法中进行 类变量：在类构造器方法中或者使用ConstantValue属性 目前Sun Javac编译器的选择是：如果同时使用final和static来修饰一个变量，并且这个常量的数据类型是基本类型或者String类型，就生成ConstantValue属性来进行初始化，如果这个变量没有被final修饰，或者并非基本类型或者字符串，则将会选择在方法中进行初始化。 总结通过上面的分析，我们一定能清楚的知道Class文件是什么以及Class文件包含什么东西，再也不怕了！！ 参考 《深入理解Java虚拟机》]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_6_JVM调优实战]]></title>
    <url>%2F2017%2F11%2F30%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-6-JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[引：带着浅尝基本的Java诊断工具就这样把《深入理解Java虚拟机》的调优部分看完了，似懂非懂，我想待自己经历过一次性能调优，结合自身经历再来好好总结一番吧。 此处暂时省略一万字。。。]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_5_内存分配策略]]></title>
    <url>%2F2017%2F11%2F30%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-5-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[引：一直在说Java的垃圾回收，既然有回收，那么当然会有分配。 Java技术体系中所提倡的自动内存管理可以归结为自动化地解决了两个问题： 给对象分配内存 回收分配给对象的内存 之前垃圾回收已经讲了很多，接下来我们详细地来看看内存分配 内存分配总说对象的内存分配，主要是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程的分配缓冲，将按线程优先在TLAB上分配，少数情况下（大对象）也可能直接分配在老年代中，分配的规则不是百分百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。 对象优先在Eden分配 大多数情况，对象在新生代Eden区分配。当Eden区没有足够空间进行分配时，虚拟机会发起一次MinorGC。 当MinorGC发现复制的对象大于Survivor区时，会通过分配担保机制提前转移到老年代中。 大对象直接进入老年代所谓大对象是指需要大量连续内存空间的Java对象，如数组。 虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配，避免了在Eden区及Survivor区之间发生大量的内存复制。（新生代采用复制算法收集内存） 长期存活的对象将进入老年代虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设置为1.对象在Survivor中每度过一次MinorGC，年龄就增加一岁，当他的年龄达到一定程度（默认15岁），就将被晋升到老年代中。对象的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。 动态对象年龄判定虚拟机不是永远要求对象的年龄必须达到MaxTenuringThreshold才晋升到老年代，如果Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入老年代。 空间分配担保策略虽然有空间分配担保，但是也需要考虑老年代能否装下由于担保转存的内存大小，所以这个空间分配担保也需要一定的策略。 在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间 如果上面条件成立，那么MinorGC就是安全的，可以进行 如果上面条件不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。 如果允许担保失败，就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小 如果大于，将尝试进行一次MinorGC 如果小于，或者HandlePromotionFailure设置为不允许冒险，那这时需要进行一次FullGC 在jdk 6 update 24之后的规则是只要老年代的连续空间大于新生代对象的总大小或者历次晋升平均大小就会进行MinorGC，否则进行FullGC。 总结通过上面我们可以知道JAVA虚拟机是怎么自动进行内存分配的，然后在进行GC之后，内存是怎么转换的。 参考 《深入理解JAVA虚拟机》]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_4_垃圾收集策略]]></title>
    <url>%2F2017%2F11%2F29%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-4-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[引：Java与C++之间有一堵内存动态分配与垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。那我们就先来看看JVM到底是怎么进行垃圾收集的？ 垃圾回收，回收哪里？之前介绍过Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，这几个区域的内存分配和回收都具有确定性，方法结束或者线程结束，内存自然就跟着回收了，但是Java堆和方法区（元空间）则不一样，我们只有在运行期间才知道会创建哪些对象，这部分内存的分配和回收都是动态的，所有垃圾回收就是回收这里。 对象已死么？垃圾收集器在对堆进行回收前，第一件事就是要确定这些对象之中还有那些还“存活”者，哪些已经“死去”（即不可能再被任何途径使用的对象）。 引用计数算法 给每个对象添加一个引用计数器，每当有一个地方引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器为0的对象就是不可能再被使用的。 可达性分析算法（Java使用） 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径被称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。 在Java语言中，可作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性应用的对象 方法区中常量引用的对象 本地方法栈中JNI（即一般说的Native方法）引用的对象 引用类型 强引用：类似”Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用：用来描述还有用但非必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。它是通过SoftReference类来实现软引用的。 弱引用：用来描述非必需对象的，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象，它是通过WeakReference类来实现弱引用的。 虚引用：只要发生垃圾回收，它就会被收集，它唯一的目的就是能在这个对象被收集器回收时收到一个系统通知，它是用过PhantomReference类来实现虚引用。 方法区（元空间）的回收类和其元数据的生命周期和其对应的类加载器是相同的。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。准确的来说，每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。 垃圾收集算法标记-清除算法流程： 标记出所有需要回收的对象 在标记完成后统一回收所有被标记的对象 不足： 效率问题 标记和清除两个过程效率都不高 空间问题 标记清除以后会产生大量不连续的空间碎片，无法存储大对象 复制算法流程： 将可用内存按容量分为大小相同的两块 在第一块分配内存，并标记出所有需要回收的对象 当第一块内存用完了，将所有活着的对象复制到另外一块上 将第一块所使用过的内存空间一次性清除 好处：解决了空间碎片问题 不足：降低了空间利用率 现在的商业虚拟机都用这种收集算法来回收新生代，因为新生代中的对象98%是“朝生夕死”的，所以不需要1:1划分空间,而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还活着的对象那个一次性复制到另一块Survivor空间上，最后清理掉前两块空间。HotSpot虚拟机默认Eden和Survivor的大小比例为8:1，所以只有10%的内存会被“浪费”，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。 内存的分配担保是指如果放着存活对象的Survivor空间没有足够空间放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。 标记-整理算法适合老年代 流程： 标记出所有需要回收的对象 让所有存活的对象都向一端移动 直接清理掉端边界以外的内存 分代收集算法将内存划分为老年代和新生代。老年代中存放寿命较长的对象，新生代中存放“朝生夕死”的对象。然后在不同的区域使用不同的垃圾收集算法。 总结从上面我们了解了对象存活判定算法和垃圾回收算法，但是不同虚拟机的具体实现还是不同的，而且不同的垃圾收集器的内存回收的具体实现也是不同的，我们要因机而议。 参考 《深入理解Java虚拟机》 JDK8 从永久代到元空间]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_3_OutOfMemoryError异常现场]]></title>
    <url>%2F2017%2F11%2F29%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-3-OutOfMemoryError%E5%BC%82%E5%B8%B8%E7%8E%B0%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[引：之前面对JVM运行内存的分析，总会提到出现OutMemoryError异常，接下来我们详细看下常出现这种异常的现场。 Java堆溢出我们通过限制Java堆得大小为20MB,不可扩张（将堆得最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX：+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump（备份）出当前的内存堆转储快照以便时候分析处理。 代码如下：1234567891011121314//VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryErrorpublic class HeapOOM &#123; static class OOMobject &#123; &#125; public static void main(String[] args) &#123; List&lt;OOMobject&gt; list = new ArrayList&lt;&gt;(); while (true) &#123; list.add(new OOMobject()); &#125; &#125;&#125; 运行结果：12345java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid81611.hprof ...Heap dump file created [27573572 bytes in 0.121 secs]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3210)... 我们很容易在输出结果中看到Java heap space OOM出现在堆中。我们要解决这个区域的异常主要是通过内存映像分析工具（很多）对Dump出来的堆转储快照进行分析，重点确认是内存泄漏（Memory leak）还是内存溢出（Memory Overflow）。 内存泄漏：被分配的内存的对象不会被回收，永久占据内存。 解决方法：通过工具查看泄漏对象到GC Roots的引用链。 内存溢出：无法申请到内存。 解决方法：检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长的情况，尝试减少程序运行期的内存消耗。 虚拟机栈和本地方法栈溢出我们说过HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，所以设置本地方法栈大小是无效的，栈容量只由-Xss参数设定，在Java虚拟机规范中描述了两种异常 StackOverflowError异常：如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出此异常。 OutOfMemoryError异常：如果虚拟机在扩展栈使无法申请到足够的内存空间，将抛出此异常。 我个人想如果单线程中栈的内存大小等于总内存大小，那么上面两种异常应该是等价的吧，但是基本上是不可能的。所以单线程中出现得基本上都是StackOverflowError异常。 单线程代码如下：1234567891011121314// VM args: -Xss128kpublic class HeapOOM &#123; static class OOMobject &#123; &#125; public static void main(String[] args) &#123; List&lt;OOMobject&gt; list = new ArrayList&lt;&gt;(); while (true) &#123; list.add(new OOMobject()); &#125; &#125;&#125; 运行结果：123stack lenth:18855Exception in thread &quot;main&quot; java.lang.StackOverflowError at com.todorex.demo.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:10) 这里抄一下书的结论：在单个线程下，无论是由于栈帧太大还是虚拟机容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。 多线程代码如下：12345678910111213141516171819202122232425// VM args: -Xss2Mpublic class JavaVMStackOOM &#123; private void dontStop() &#123; while (true) &#123; &#125; &#125; public void stackLeakByThread() &#123; while (true) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; dontStop(); &#125; &#125;); thread.start(); &#125; &#125; public static void main(String[] args) &#123; JavaVMStackOOM javaVMStackOOM = new JavaVMStackOOM(); javaVMStackOOM.stackLeakByThread(); &#125;&#125; 我在自己的机器上没有运行出来，可能需要点时间，不过机器变卡了，我想其实这里解释一下就好，它应该会抛出OutOfMemoryError异常。 解释：首先操作系统分给每个进程的内存是有限制的，所以总的方法栈的大小也是有限制的，但是每个线程都需要方法栈，所以线程建立的越多，剩余的方法栈内存就越小，一直创建线程，进程所拥有的内存终将被耗尽，到最后就会抛出OutOfMemoryError异常。 注意：线程数和方法栈大小是成反比的，所以在开发多线程的应用时应该特别注意，如果不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程了。 方法区（元空间）和运行时常量池溢出运行时常量池溢出在之前的博客也提到过在jdk1.6以及之前运行时常量池是放在方法区中的，存的是对象，所以可以设置虚拟机参数-XX:PermSize和-XX:MaxPermSize来限制方法区的大小，来模拟常量池溢出，但是jdk1.7及以后运行时常量池被移除了方法区，常量池存储的不再是对象，而是对象的引用，真正的对象存储在堆中，我们改变虚拟机参数为：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError运行下面程序：1234567891011// VM args:-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryErrorpublic class RuntimeConstantPoolOOM &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); int i = 0; while (true) &#123; list.add(String.valueOf(i++).intern()); &#125; &#125;&#125; 运行结果：123java.lang.OutOfMemoryError: GC overhead limit exceededDumping heap to java_pid10818.hprof ...Heap dump file created [25172419 bytes in 0.251 secs] 上面结果提示GC开销超过限制，默认的话，如果你98%的时间都花在GC上并且回收了才不到2%的空间的话，虚拟机就会抛这个异常。 其实我们之前也提起过在JDK1.8及以后，字符串常量池从永久代移到到元空间中，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整，如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集，-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集，具体验证代码如下：1234567891011// VM args: -XX:MetaspaceSize=4M -XX:MaxMetaspaceSize=4Mpublic class RuntimeConstantPoolOOM &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); int i = 0; while (true) &#123; list.add(String.valueOf(i++).intern()); &#125; &#125;&#125; 运行结果：12Error occurred during initialization of VMOutOfMemoryError: Metaspace 关于这个字符串常量池的实现问题，还真的会出现一个很意思的问题或者说是一个很奇怪的问题。代码如下：123456789101112131415// jdk:1.8public class RuntimeConstantPoolOOM &#123; public static void main(String[] args) &#123; String str1 = new StringBuilder("计算机").append("软件").toString(); System.out.println(str1.intern() == str1); String str2 = new StringBuilder("ja").append("va").toString(); System.out.println(str2.intern() == str2); String str3 = new StringBuilder("ma").append("in").toString(); System.out.println(str3.intern() == str3); &#125;&#125; 运行结果：123truefalsefalse jdk1.6中，intern()方法会把首次遇到的字符串实例复制在永久代，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用。而在jdk1.7及以后，intern()的实现不会再复制实例，只是在常量池中记录首次出现得实例的引用，因此intern()返回的由StringBuilder创建的那个字符串是同一个实例，而关于上面的运行结果，我想java和main之前都是在字符串常量池中都有他的引用了，所以返回的都是false。 方法区溢出方法区用于存放Class的相关信息，如类名，访问修饰符，常量池，字段描述，方法描述等，基本的思路是运行时产生大量的类去填充方法区，下面是借助CGLib（cglib和asm的依赖有个坑，选择cglib2.2,asm3.1亲测可用）来操作字节码运行时生成大量的动态类，这种场景在Spring，Hibernate中经常出现，需要多注意，本人使用的JDK1.8，所以测试的是方法区的变迁元空间，代码实现如下：123456789101112131415161718192021222324// VM args:-XX:MetaspaceSize=4M -XX:MaxMetaspaceSize=4Mpublic class JavaMethodAreaOOM &#123; public static void main(String[]args) &#123; while (true) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; return methodProxy.invokeSuper(o, objects); &#125; &#125;); OOMObject oomObject = (OOMObject) enhancer.create(); oomObject.sayHi(); &#125; &#125; static class OOMObject&#123; public void sayHi()&#123; System.out.println("hi"); &#125; &#125;&#125; 结果输出：12Error occurred during initialization of VMOutOfMemoryError: Metaspace 这类异常经常出现在web应用中，需要多注意。 本机直接内存溢出DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样，在《深入理解Java虚拟机》中用了以下代码：1234567891011121314// VM args:-Xmx20M -XX:MaxDirectMemorySize=10Mpublic class DirectMemoryOOM &#123; private static final int _1MB = 1024*1024; public static void main(String[] args) throws Exception&#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true) &#123; unsafe.allocateMemory(_1MB); &#125; &#125;&#125; 但是在自己电脑中没有运行成功，反而让自己的电脑死机了，这个地方还是没有弄懂？？？？？？，希望懂的大佬给我点支持。 这个异常在使用NIO中可能会出现，所以在使用的时候需要多注意。 总结在总结得过程中，知道了各个内存区域可能会出现OOM的情况，重要的是了解了方法区在jdk1.6到1.7到1.8的变迁，有兴趣的人可以深入了解。 参考 《深入理解Java虚拟机》 CGLIB介绍与原理 Java8内存模型—永久代(PermGen)和元空间(Metaspace) 深入探究JVM | 探秘Metaspace]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_2_HotSpot对象揭秘]]></title>
    <url>%2F2017%2F11%2F21%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-2-HotSpot%E5%AF%B9%E8%B1%A1%E6%8F%AD%E7%A7%98%2F</url>
    <content type="text"><![CDATA[引：总有些人会思考对象是如果创建、如何布局、以及如何访问的？对于这些问题，我们必须把讨论范围限定在具体的虚拟机和集中在某一个内存区域才有意义。基于实用原则，我们以常用的虚拟机HotSpot和常用的内存区域Java堆为例。 对象的创建Java程序创建对象不过是一个new关键字而已，而在虚拟机中，创建了一个对象却经历了一系列过程。 虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，如果没有就会抛出ClassNotFoundException，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，那必须先执行相应的类加载过程。 类加载检查通过后，虚拟机为新生对象分配内存，对象所需内存的大小在类加载完成后便可以完全确定。 这里有两种内存分配方式：（由采用的垃圾收集器是否带有压缩整理的功能决定） 指针碰撞 假设Java堆的内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。 空闲列表 假如Java堆中的内存并不是完整的，已使用的内存和空闲的内存相互交错，虚拟机就必须维护一个列表，记录那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给实例，并更新列表上的记录。 解决在并发情况下不安全的方案: 对分配内存空间的动作进行同步处理——虚拟机采用CAS配上失败重试的方式保证更新操作的原子性 把内存分配的动作按线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲，只有需要重新分配的时候才同步锁定 虚拟机将分配到的内存空间都初始化为零值（默认初始化），保证了对象实例在Java代码中可以不赋初始值就可以使用。 设置对象头 利用构造函数进行初始化 对象的内存布局对象头 存储对象自身的运行时数据（哈希码，GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等），官方称为“Mark Word”，它被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，他会根据对象的状态复用自己的存储空间，具体见《深入理解Java虚拟机》。 类型指针（可选）即对象指向它的元数据（方法区）的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例 数组长度（可选）如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通java对象元数据信息确定Java对象的大小，但是从数组数据无法确定数据大小 实例数据存储所有成员变量，无论是父类继承下来的，还是在子类定义的。 存储顺序会受到虚拟机分配策略参数和字段在源码定义的顺序的影响。HotSpot默认的分配策略为相同狂赌的字段总是被分配到一起（如long和double），在这个前提下，父类先于子类，若CompactFields参数为true，那么子类之中较窄的变量也可能插入到父类变量的空隙中（是因为一个slot太大） 对齐填充（可选）起到占位符的作用，确保对象的长度为8字节的整数倍 HotSpot VM的自动内存管理系统要求对象起始位置必须是8字节的整数倍，由于对象头一定是8字节的整数倍，所以利用占位符可以达到数据部分也是8字节的整数倍。从而达到对象的长度是8字节的整数倍。（有点绕口啊，哈哈） 对象的访问定位我们通常都会使用Java对象，我们基本上都是通过虚拟机栈上的reference数据来操作堆上的具体对象，而栈上只是一个指向对象的引用，对象的具体访问方式取决于虚拟机，目前有以下两种访问方式： 通过句柄访问对象可以看下面的图：使用句柄访问，Java堆中会划分出一块内存来作为句柄池，reference存储的就是对象的句柄地址，而句柄包含了对象实例数据与类型数据各自的具体地址信息。 通过直接指针访问对象可以看下面的图：使用直接指针访问，Java堆对象的布局中就要考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。 两者对比 通过句柄访问对象可以当对象被移动之后只会改变句柄中的实例数据指针，而reference本身不需要改变。 使用直接指针访问可以加快Java对象的访问，HotSpot就是使用直接指针访问对象的方式。 总结这里讲的对象重点还是在虚拟机执行部分，关于Class文件的讲解没有涉及到，但它却是十分重要的，日后会提及。 参考 深入理解JVM(二)——揭开HotSpot对象创建的奥秘]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_1_JVM内存模型]]></title>
    <url>%2F2017%2F11%2F20%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-1-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[引：总是提到堆呀，栈呀，常量池呀，但是Java虚拟机内的Java模型却总是理解不清楚，这次就总结一下。 Java内存模型组成这里讲的是Java虚拟机在执行Java程序的过程中会把它所管理的内存划分五大区域。 程序计算器 Java虚拟机栈 本地方法栈 Java堆 方法区 下面也把来自深入理解Java虚拟机的图片贴一下： 接着我们重点理解一下这五大区域。 程序计数器什么是程序计数器 程序计数器是一块较小的内存空间，他可以看做当前线程所执行的字节码的行号指示器。 如果线程在执行一个Java方法的时候，这个计数器记录的是正在执行的虚拟机字节码指令地址，如果正在执行的是Native方法，这个计数器值则为空。 程序计数器的作用 单线程的时候：通过改变这个计数器的值来选取下一条需要执行的字节码指令，从而实现分支、循环、跳转、异常处理、线程回复等基础功能。 多线程的时候：当每个线程都有独立的程序计数器，则线程切换后就能回复到正确的执行位置。PS： Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。 程序计数器的特点 存储空间较小 线程私有，每个线程都有一个程序计数器 唯一一个没有规定任何OutOfMemoryError情况的区域 生命周期与线程相同 Java虚拟机栈什么是Java虚拟机栈Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表（包括基本数据类型，对象引用和returnAddress,其中long和double会占据2个局部变量空间，其他只占用一个）、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 Ps： 人们常说的Java内存区分为“堆”和“栈”，“堆”存放对象（可以），“栈”只是值其中的局部变量表（不可以），这是不正确的。 Java虚拟机栈的特点 线程私有，生命周期与线程相同 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常 虚拟机栈可以动态扩展，也可以固定长度，在动态扩展的时候如果无法申请到足够的内存，就会抛出OutOfMemoryError异常 本地方法栈什么是本地方法栈本地方法栈描述的是本地方法执行的内存模型，它发挥的作用与虚拟机栈发挥的作用是非常相似的，如Sun HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一，它与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 Java堆什么是Java堆 Java堆是存放对象实例的内存区域 几乎所有对象实例都在这里分配内存 Java堆的特点 Java虚拟机管理的内存中最大的一块 线程共享，在虚拟机启动时创建 垃圾收集器管理的主要区域，从内存回收的角度来看，由于现在收集器都采用分代收集算法，所以可分为新生代和老年代，再细致一点可以分为Eden空间、From Survivor空间和To Survivor空间等。从内存分配来看，线程共享的Java堆可能划分出多个线程私有的分配缓存区TLAB,进一步划分的目的是为了更好地回收内存，或者更快的分配内存 实现中可以固定大小，也可以是可扩展的，如果在堆中没有内存完成实例的分配，并且堆也无法再扩展时，就会抛出OutOfMemoryError异常 方法区什么是方法区 Java虚拟机规范把方法区描述为堆的一个逻辑部分。 他用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码 方法区的特点 线程共享，在虚拟机启动时创建 永久代是因为HotSpot选择将GC分代收集器扩展到方法区，或者使用永久代来实现方法区，对于HotSpot官方发布的路线图信息，现在也有放弃永久代逐步采用Native Memory来实现方法区的规划了，并且已经把原本放在永久代的字符串常量池移除 不需要连续的内存，可以选择固定大小或者可扩展，还可以选择不实现垃圾回收 内存回收的主要目标主要是针对常量池的回收和对类型的卸载，但是回收效率低 当方法区无法满足内存分配的需求的时候，将抛出OutOfMemoryError的异常 运行时常量池 Class文件除了包含类的版本字段、方法、接口等描述信息外，还有一项信息是常量池 常量池用于存放编译期间生成的各种字面量和符号引用，这部分内容在类加载后进入运行时常量池中存放 运行时常量池相对于Class文件常量池具有动态性，Java语言不要求只有Class文件中的常量池的内容才能进入运行时常量池，运行时也可能将新的常量放入池中，如String类的intern方法 当常量池无法再申请内存时将会抛出OutOfMemoryError异常 PS： jdk1.7的常量池移到了堆中，同时在jdk1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域 直接内存 通过一个存储在Java堆中的DirectByteBuffer对象最为这块内存的引用进行操作，这个可以显著提高性能，因为避免了在Java堆和Native堆中来回复制数据 案例是NIO类引入一种基于通道与缓存区的I/O方式，它可以使用Native函数库直接分配对外内存，然后通过DirectByteBuffer进行操作 本机直接内存的分配不会受到Java堆大小的限制，但是会受到本机总内存大小和处理器寻址空间的限制，也可能会抛出OutOfMemoryError异常 总结本篇文章是参考《深入理解Java虚拟机》第二版所写，当时作者用的是jdk1.7，结果现在jdk1.9都出了，最大的改变就是方法区了，目前还没有能力改正，也就将就了，望作者早日更新，或者自己成为大牛，将这部分重新整理。 参考 深入理解JVM(一)——JVM内存模型 Java 8: 从永久代（PermGen）到元空间（Metaspace）]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot静态资源的处理]]></title>
    <url>%2F2017%2F10%2F20%2Fspringboot%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[引：由于springboot架构遇到了图片的上传处理，以及之后的前台显示，所以就理解了一下其中关于静态资源的处理。 默认的静态资源处理在每次启动springboot的项目的时候，我们都可以在控制台看见下面的语句输出：1232017-10-20 16:06:50.540 INFO 36443 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-10-20 16:06:50.540 INFO 36443 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-10-20 16:06:50.569 INFO 36443 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 这里面就用到了springboot默认的静态资源处理。 其中默认配置的/**映射到/static（或/public、/resources、/META-INF/resources） 其中默认配置的/webjars/**映射到classpath:/META-INF/resources/webjars/ PS：上面的 static、public、resources 等目录都在 classpath: 下面（如 src/main/resources/static） 在访问静态资源的时候，这些目录也会有一个查找顺序（优先级）：这里测试过发现他们的优先级是：META/resources &gt; resources &gt; static &gt; public 自定义静态资源处理配置方式 通过配置文件（application.properties）配置1234# 默认值为 /**spring.mvc.static-path-pattern=# 默认值为 classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ spring.resources.static-locations=这里设置要指向的路径，多个使用英文逗号隔开， 当我们要设置成我们的目录：/myresource/**，我们需要这样设置:12spring.mvc.static-path-pattern=/**spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/,classpath:/myresource/ 当我们设置过映射路径时候，如果还是/**,那么默认的映射就失效了，我们需要重新把原来的路径也添加上。这里的配置路径只可以设置一个。 通过配置类配置12345678@Configurationpublic class MyWebAppConfigurer extends WebMvcConfigurerAdapter&#123; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler("/myresource/**").addResourceLocations("file:/var/alldata/image/"); super.addResourceHandlers(registry); &#125;&#125; 可以通过这个方式设置多个配置路径。 配置内外目录 内部目录 做法是添加映射路径 classpath:/路径 方式见通过配置文件配置 外部目录 想一想如果将上传的图片继续存在jar包中会有那些问题？ 网络数据与程序代码不能分离 数据传到jar里速度慢 数据备份麻烦 有了以上的考虑我们会想到将上传的数据放在磁盘的目录上。 做法是添加映射路径 file:/var/alldata/images 方式见通过配置类配置 总结springboot倡导的是习惯优于配置，大部分时候我们用他默认的配置就好了，但是他也提供了方便的配置类，需要我们好好学习。 参考 Spring Boot 静态资源处理 Springboot 之 静态资源路径配置]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac中环境变量的配置]]></title>
    <url>%2F2017%2F09%2F21%2Fmac%E4%B8%AD%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[引：在使用ubuntu和mac这么久之后，环境变量的几个文件还弄不清楚，真是汗颜，这里记录一下，下次不会乱改。 环境变量的作用 使用场景在命令行直接通过命令执行程序，这些程序就多了，最常见就有java，npm，maven，git,如果我们不配置环境变量的话，就需要到程序的安装目录去执行相关命令，大家都会感觉超级麻烦，加入要使用多个程序的话，要么去切换目录，要么就多开几个命令行窗口。顿时就会感觉超级无奈有么有？ 具体作用配置完程序的环境变量之后就可以无所欲为了，可以在任何目录下直接执行我们所要的程序了，是不是顿时感觉方便许多，基本上所有人都知道吧。 环境变量的配置单次环境变量配置假如你出了个意外，在命令行中突然不能使用各种命令了，也没事，至少接下来可以让你短暂的使用一些命令，命令行窗口关闭之后就失效了，我们要做的只是直接在命令行中输入： export PATH=/usr/bin:/usr/sbin:/bin:/sbin 当然后面你也能够添加一些你自己想要使用的程序命令。 环境变量文件配置 环境变量的写法 export PATH=JAVA_HOME/bin:$PATH 环境变量文件优先级 /etc/profile /etc/bashrc /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc其实后三个文件我也没怎么看到过，主要讲一下前面三个 环境变量文件详解 /etc/profile：全局配置文件，不管是哪一个用户登录，都会读取该文件（但是超级不建议修改，容易出现大问题，想试试什么大问题，自己体会） /etc/bashrc 全局配置文件，bash shell执行时，不管是何种方式，都会读取此文件（一般在这个文件中添加系统级环境变量） ~/.bash_profile：每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!（一般在这个文件中添加用户级环境变量） 立即生效环境变量配置 source ~/.bash_profile 软连接自己一开始也会特别的惊讶，自己在mac上没有设置环境变量有的时候也可以直接就访问到了某些文件。这个是为什么呢？答案是用了软连接。 查看加载文件rexdeMacBook-Pro:etc rex$ cat /etc/paths /usr/local/bin /usr/bin /bin /usr/sbin /sbin 然后就可以去看这些文件夹下面的东西了，弄不清楚也没关系，其实就是软链接。开机后，mac会自动加载paths文件下面的这些目录。在这些文件夹下面建立软连接，可以达到同样的效果（日后学习）。 软连接查看在拥有软连接的目录下使用下面命令 ls -li 406876 lrwxr-xr-x 1 root wheel 73 7 9 2016 jar -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/jar 406877 lrwxr-xr-x 1 root wheel 79 7 9 2016 jarsigner -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/jarsigner 406878 lrwxr-xr-x 1 root wheel 74 7 9 2016 java -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java 406879 lrwxr-xr-x 1 root wheel 75 7 9 2016 javac -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javac 406880 lrwxr-xr-x 1 root wheel 77 7 9 2016 javadoc -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javadoc 建立软连接等自己看了linux的相关知识再来说吧。 总结希望下次自己再也不要因为环境变量配置错出各种问题了，thanks god！ 参考：Mac 中环境变量的配置和理解]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages+Hexo SEO引擎优化]]></title>
    <url>%2F2017%2F07%2F16%2FGithub-Pages-Hexo-SEO%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[引：写的博客自然想让人看到，但是但是自己为了想独立管理（冠冕堂皇）选择了GIthub Pages+Hexo来搭建自己的博客，结果发现自己的博客在百度，谷歌都无法搜到，那时候我才知道自己缺少了SEO。 百度优化登录百度站长 在里面我们可以发现各种向百度提交的方法，这一切都是为了让百度的爬虫更好的爬取我们的网页。 通过baidumapsite.xml自动提交 这里推荐一个博文：Hexo NexT 主题SEO优化指南 通过主动提交 这里推荐一个自动化工具：exo插件之百度主动提交链接 谷歌优化登录谷歌站长 通过map.site自动提交 这里面推荐一个博文：生成sitemap站点地图 总结自己在谷歌配置是成功的，但是在百度并没有成功，可能是因为github真的把百度给干了。自己还是等开学转到自己的服务器上吧。慢慢SEO！！！！ PS:Hexo博客的搭建的可以参考这一篇 搭建Hexo博客中碰到的坑]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新系统开发环境的一系列配置]]></title>
    <url>%2F2017%2F07%2F15%2F%E6%96%B0%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[引：总是不可避免的重装系统，人的脑子不可能那么好记住所有的操作，既然不想自己自己用博客记下所有操作，那么就把别人的博客（自己踩过）记录下来，以后备用。 window篇 JDK——java开发者起步 JDK的安装与环境变量的配置 Node——前端好基友 Node.js安装及环境配置之Windows篇 Sublime3——轻量级编辑器 Sublime Text3安装与插件配置 git——分布式版本控制工具 Git安装教程 Idea——java开发利器 IntelliJ IDEA注册码 Maven——项目依赖管理利器 Maven Windows10安装 Mac篇待写 Ubuntu篇待写 双系统Win10和Ubuntu16.04双系统安装详解]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅尝Apache Camel]]></title>
    <url>%2F2017%2F07%2F15%2F%E6%B5%85%E5%B0%9DApache-Camel%2F</url>
    <content type="text"><![CDATA[引：最近项目有一个需求就是定时将一台服务器的文件传到另一个服务器，一开始想的竟然想的是用http去下载，后来在万老师的指点下，采取用ftp服务器（源文件所在地）与ftp客户端（源文件去向）的形式来处理，自己小试了一下，还不错！ Apache Camel简介Apache Camel是Apache基金会下的一个开源项目,它是一个基于规则路由和处理的引擎，提供企业集成模式的Java对象的实现，通过应用程序接口 或称为陈述式的Java领域特定语言(DSL)来配置路由和处理的规则。其核心的思想就是从一个from源头得到数据,通过processor处理,再发到一个to目的的。 这个from和to可以是我们在项目集成中经常碰到的类型:一个FTP文件夹中的文件,一个MQ的queue（jms）,一个HTTP request/response,一个webservice等等. Apache Camel架构 其实理解起来很简单：始端》（过滤器+路由处理器）》终端 Apache Camel核心概念 endpoint,所谓的endpoint,就是一种可以接收或发送数据的组件。可以支持多种协议，如jms,http,file等。 processor,它是用来处理具体业务逻辑的组件。 route,用来路由，指示数据从哪里来到哪里去，中间用哪个processor处理。 exchange,processor之间用exchange对象来传送数据，有点像jms,通俗一点就像上学时传的小纸条,所以：exchange对象就是processor，endpoint所有camel组件之间传送数据的小纸条:)。 filter，用来确定哪些东西可以传递，哪些东西不可以传递。 Apache Camel例子（以ftp为例）老师指导的例子，是结合Springboot的，放在github上了。ApacheCamleDemo 里面包括了动态路由和单路由的例子，稍微结合Springboot就可以理解并改成自己的代码。 什么时候用Apache Camel参考网上的说法：camel就是企业信息集成框架，它提供了很多简单好用而又强大的组件，用户可以根据场景来选择不同的EIP（企业集成模式）来实现自己的需求，以响应快速变化的业务。可以把它当成企业信息总线（ESB）的轻量级实现。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>ApacheCamel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java ftp 上传下载的坑]]></title>
    <url>%2F2017%2F07%2F15%2Fjava-ftp-%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[引：还是项目需要，要定时执行一个文件下载业务，一开始方向有点错，但是还好纠正过来了，采用ftp下载，但是ftp下载也有各种坑！ 准备jar包：commons-net ftp上传程序：1234567891011121314151617181920212223242526272829303132333435363738public static boolean uploadFile( String url,//服务器主机号 int port,//服务器端口 String username,//用户名 String password,//密码 String path, //上传路径Mar String filename,//上传为服务器上的文件名 InputStream //input本地上传的文件流) &#123; boolean success = false; FTPClient ftp = new FTPClient(); try &#123; int reply;MarkDown ftp.connect(url, port);//连接FTP服务器 //如果采用默认端口，可以使用ftp.connect(url)的方式直接连接FTP服务器 ftp.login(username, password);//登录 reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) &#123; ftp.disconnect(); return success; &#125; ftp.changeWorkingDirectory(path); ftp.storeFile(filename, input); input.close(); ftp.logout(); success = true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ftp.isConnected()) &#123; try &#123; ftp.disconnect(); &#125; catch (IOException ioe) &#123; &#125; &#125; &#125; return success;&#125; 测试代码：123File file = new File(&quot;/var/test.txt&quot;);InputStream is = new FileInputStream(file);uploadFile(&quot;127.0.0.1&quot;,21,&quot;test&quot;,&quot;123456&quot;,&quot;/var/data/test&quot;,&quot;testdemo.txt&quot;,is); ftp下载程序：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public static boolean downFile(String url, //FTP服务器hostnameint port,//FTP服务器端口String username, //FTP登录账号String password, //FTP登录密码String remotePath,//FTP服务器上的相对路径String fileName,//要下载文件关键字String localPath//下载后保存到本地的路径) &#123; FTPClient ftpClient = null; boolean success = false; try &#123; ftpClient = new FTPClient(); ftpClient.connect(url, port);// 连接FTP服务器 ftpClient.login(username, password);// 登陆FTP服务器 ftpClient.setControlEncoding("gb2312"); // 中文支持 ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);//设置文件格式 ftpClient.enterLocalPassiveMode(); logger.info(ftpClient.getReplyCode()); if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) &#123; logger.warn("未连接到FTP，用户名或密码错误。"); ftpClient.disconnect(); &#125; else &#123; logger.info("FTP连接成功。"); &#125; ftpClient.changeWorkingDirectory(remotePath); FTPFile[] fs = ftpClient.listFiles(); File file = new File(localPath); if(!file.exists())&#123; file.mkdirs(); &#125; for(FTPFile ff:fs)&#123; if(ff.getName().contains(fileName))&#123; File localFile = new File(localPath+"/"+ff.getName()); if (localFile.exists())&#123; continue; &#125; OutputStream os = new FileOutputStream(localFile); long time1 = System.currentTimeMillis(); boolean b = ftpClient.retrieveFile(new String(ff.getName().getBytes("gb2312"),"ISO8859-1"), os); os.flush(); os.close(); &#125; &#125; ftpClient.logout(); success = true; &#125; catch (SocketException e) &#123; e.printStackTrace(); logger.warn("FTP的IP地址可能错误，请正确配置。"); &#125; catch (IOException e) &#123; e.printStackTrace(); logger.warn("FTP的端口错误,请正确配置。"); &#125; finally &#123; if (ftpClient.isConnected()) &#123; try &#123; ftpClient.disconnect(); &#125; catch (IOException ioe) &#123; &#125; &#125; &#125; return success;&#125; 测试程序：1downFile(&quot;127.0.0.1&quot;,21,&quot;test&quot;,&quot;123456&quot;,&quot;、var/data/test&quot;,&quot;demo&quot;,&quot;/var/alldata&quot;); 一些坑 客户端接受的编码 1ftpClient.setControlEncoding(&quot;gb2312&quot;); // 中文支持 如果服务器上的文件名有中文，一定要加上这一句，具体编码要根据服务器的编码。 客户端接受的文件类型 1ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);//设置文件格式 文件类型要根据下载的文件格式来定 服务器端口设置 1ftpClient.enterLocalPassiveMode(); 调用FTPClient.enterLocalPassiveMode();这个方法的意思就是每次数据连接之前，ftp client告诉ftp server开通一个端口来传输数据，防止在新端口对外部不通，因为ftp server可能每次开启不同的端口来传输数据，但是在linux上，由于安全限制，可能某些端口没有开启，所以就出现阻塞。 最大的坑（下载出0kb的文件：实质就是retrieveFile方法执行失败） 1ftpClient.retrieveFile(new String(ff.getName().getBytes(&quot;gb2312&quot;),&quot;ISO8859-1&quot;), os) 一定要给文件名换编码，让它识别中文，具体编码也是根据实际情况而定。 总结ftp客户端的速度也是要根据网速来的，可能比一般http快，但是面对网速慢的情况也是无可奈何！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js原型和原型链]]></title>
    <url>%2F2017%2F07%2F13%2Fjs%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[引：刚刚说了闭包，那就不放过js的另一大难点了——js原型以及原型链。 谈谈神图镇楼：自己写了好几遍内容，但是自己发现还是不能系统的理解，自己也写不了多好，看来要到自己安心写前端的时候，再来补上了。 参考 最详尽的 JS 原型与原型链终极详解（一） 最详尽的 JS 原型与原型链终极详解（二） 最详尽的 JS 原型与原型链终极详解（三） 个人感觉上面的文章还不错，可能还缺了继承那块的讲解，等自己再来的时候一起补上吧！！！！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈js闭包]]></title>
    <url>%2F2017%2F07%2F12%2F%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[引：最近项目前端用了angular2，里面使用的TypeScript,其实很多和Java挺像的，学起来还是挺快的。但是里面的很多变量的原理都是根据闭包来实现的，那就好好了解一下闭包。 闭包定义根据Mozilla开发者文档定义： 闭包是指向独立变量的“函数”,用通俗的话说就是会“记住”它创建时的环境。 闭包涉及的主要概念 作用域链 作用域链是函数在定义的时候创建的,用于寻找使用到的变量的值的一个索引。它内部的规则是,把函数自身的本地变量放在最前面,把自身的父级函数中的变量放在其次,把再高一级函数中的变量放在更后面,以此类推直至全局对象为止.当函数中需要查询一个变量的值的时候,js解释器会去作用域链去查找,从最前面的本地变量中先找,如果没有找到对应的变量,则到下一级的链上找,一旦找到了变量,则不再继续.如果找到最后也没找到需要的变量,则解释器返回undefined. 内存回收机制 一个函数在执行开始的时候,会给其中定义的变量划分内存空间保存,以备后面的语句所用,等到函数执行完毕返回了,这些变量就被认为是无用的了.对应的内存空间也就被回收了.下次再执行此函数的时候,所有的变量又回到最初的状态,重新赋值使用.但是如果这个函数内部又嵌套了另一个函数,而这个函数是有可能在外部被调用到的.并且这个内部函数又使用了外部函数的某些变量的话.这种内存回收机制就会出现问题.如果在外部函数返回后,又直接调用了内部函数,那么内部函数就无法读取到他所需要的外部函数中变量的值了.所以js解释器在遇到函数定义的时候,会自动把函数和他可能使用的变量(包括本地变量和父级和祖先级函数的变量(自由变量))一起保存起来.也就是构建一个闭包,这些变量将不会被内存回收器所回收,只有当内部的函数不可能被调用以后(例如被删除了,或者没有了指针),才会销毁这个闭包,而没有任何一个闭包引用的变量才会被下一次内存回收启动时所回收. 闭包现象123456789var results = [];for (var i = 0; i &lt;3; i++) &#123;results[i] = function() &#123;console.log(i);&#125;&#125;results[0](); //3results[1](); //3results[2](); //3 解析：其实这里return出来的是一个function（我们可以理解为他是一个字符串，还没有执行），等到我们去执行他的时候，只保存了他上一级的作用域链里面的i的索引,那个时候i已经是3了。 闭包解决让内部函数在循环创建的时候立即执行,并且捕捉当前的索引值,然后记录在自己的一个本地变量里.然后利用返回函数的方法,重写内部函数,让下一次调用的时候,返回本地变量的值,改进后的代码:1234567891011var results = [];for (var i = 0; i &lt;3; i++) &#123;results[i] = (function(j) &#123;return function()&#123;console.log(j);&#125;&#125;)(i);&#125;results[0](); //0results[1](); //1results[2](); //2 我们发现通过立即执行表达式就可以解决闭包的现象得到我们想要得到的现象。 闭包应用闭包与静态变量前面就说TypeScript与Java很像，所以类中的静态变量也是有的。 TypeScript代码：12345678910111213141516class Counter &#123;private static COUNTER = 0;constructor() &#123;&#125;private changeBy(val) &#123;Counter.COUNTER +=val;&#125;public increment() &#123;this.changeBy(1);&#125;public decrement() &#123;this.changeBy(-1);&#125;public value() &#123;return Counter.COUNTER;&#125;&#125; 编译之后的js代码:123456789101112131415161718var Counter = (function () &#123;function Counter() &#123;&#125;Counter.prototype.changeBy = function (val) &#123;Counter.COUNTER += val;&#125;;Counter.prototype.increment = function () &#123;this.changeBy(1);&#125;;Counter.prototype.decrement = function () &#123;this.changeBy(-1);&#125;;Counter.prototype.value = function () &#123;return Counter.COUNTER;&#125;;Counter.COUNTER = 0;return Counter;&#125;()); 从js代码可以看书静态变量COUNTER是属于Counter类的，并不属于对象原型。所有Counter实例都共享Counter的同一个闭包上下文环境（COUNTER）。所以COUNTER会表现像单例一样。 闭包和私有成员TypeScript由于性能原因并没有使用闭包来模拟私有变量，他使用过编译检查机制来形成私有变量的特性。但是我们可以使用闭包来实现私有变量。 js代码如下：123456789101112131415161718function makeCounter() &#123;var COUNTERR = 0;function Counter() &#123;&#125;function changeBy(val) &#123;COUNTER += val;&#125;;Counter.prototype.increment = function () &#123;this.changeBy(1);&#125;;Counter.prototype.decrement = function () &#123;this.changeBy(-1);&#125;;Counter.prototype.value = function () &#123;return COUNTER;&#125;;return new Counter();&#125;; 从上面的代码可以看出，每一个新的makeCounter实例都拥有自己的上下文环境，其他实例访问不了。 总结学习这么久的js发现，其实闭包真的无处不在，需要好好学习，好好总结，如有不对，也希望大家能够指出。 参考链接：js中闭包原理谈和原型及例子 书籍：Learning TypeScript中文版]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java日志那些事]]></title>
    <url>%2F2017%2F07%2F12%2FJava%E6%97%A5%E5%BF%97%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[引：一直都知道日志文件很重要，可以记录一些相关信息，但是可能是程序需要调试的内容太少，也或者是项目太小，所以看看控制台的信息就够了，但是这次接触的项目越来越大，控制台额信息越来越多，经常会看不到自己想要看到的信息时，这个时候使用日志就发现十分得有必要了！ 日志的好处 方便调试(如上) 方便发现系统运行中的错误 存储业务数据，便于日后分析 日志实现方式 自己实现类通过io存储到文件中 使用log4j将日志输入到控制台，文本文件，一集数据库中。 使用jdk自带的logging.jar包中方法（同一作者还有lognback） 使用slfj，它提供了上述两种方法的接口。 日志的输出(以log4j为例) 输入到控制台 运行程序：1234567891011public class LoggerTest &#123;public static Logger logger1 = Logger.getLogger(LoggerTest.class);public static void main(String[] args) &#123;logger1.trace(&quot;我是logger1，trace&quot;);logger1.debug(&quot;我是logger1，debug&quot;);logger1.info(&quot;我是logger1，info&quot;);logger1.warn(&quot;我是logger1，warn&quot;);logger1.error(&quot;我是logger1，error&quot;);logger1.fatal(&quot;我是logger1，fatal&quot;);&#125;&#125; 配置文件如下：123456789### 设置级别和目的地(这里多个目的地) ###log4j.rootLogger = DEBUG,CONSOLE### 这里的com.todorex是包，也就是在这个包记录日志时，是只记录debug及以上级别的日志log4j.logger.com.todorex=DEBUG### 输出到控制台 ###log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.Target = System.outlog4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern = %d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n 控制台输出:1234511:35:09,969 DEBUG LoggerTest:12 [main:0]- 我是logger1，debug11:35:09,972 INFO LoggerTest:13 [main:3]- 我是logger1，info11:35:09,972 WARN LoggerTest:14 [main:3]- 我是logger1，warn11:35:09,972 ERROR LoggerTest:15 [main:3]- 我是logger1，error11:35:09,972 FATAL LoggerTest:16 [main:3]- 我是logger1，fatal 输入到日志文件运行程序同上；配置文件如下：1234567891011121314151617181920### 设置级别和目的地(这里可以多个目的地) ###log4j.rootLogger = trace,demoLoglog4j.logger.com.todorex=DEBUG### 输出到控制台 ###log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.Target = System.outlog4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern = %d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L [%t:%r]- %m%n### 输出到日志文件（文件目录一定要是绝对路径且存在） ###log4j.appender.demoLog = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.demoLog.File =/var/alldata/mylog.loglog4j.appender.demoLog.Append = true## 只输出DEBUG级别以上的日志log4j.appender.demoLog.Threshold = DEBUG#&apos;.&apos;yyyy-MM-dd: 每天产生一个新的文件log4j.appender.demoLog.DatePattern = &apos;.&apos;yyyy-MM-ddlog4j.appender.demoLog.layout = org.apache.log4j.PatternLayoutlog4j.appender.demoLog.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%t:%r] - [%p] [%c&#123;1&#125;:%L] [%M] %m%n 文件内容同控制台输出，但是却比控制台清楚得多，不会被乱七八糟的信息给遮盖。 输入到数据库 运行程序:1234567public class LoggerTest &#123;public static void main(String[] args) &#123;Logger logger = Logger.getLogger(LoggerTest.class);logger.info(&quot;good&quot;);logger.debug(&quot;success&quot;);&#125;&#125; 配置文件：1234567891011log4j.rootLogger=trace,CONSOLE,demoLog# com.todorex包下面所有的日志输出的级别设为DEBUGlog4j.logger.com.todorex=DEBUG# 数据库输出log4j.appender.demoLog=org.apache.log4j.jdbc.JDBCAppenderlog4j.appender.demoLog.driver=com.mysql.jdbc.Driverlog4j.appender.demoLog.URL=jdbc:mysql://127.0.0.1:3306/testlog4j.appender.demoLog.user=rootlog4j.appender.demoLog.password=root# 在数据库对应的位置建一个对应的log表log4j.appender.demoLog.sql=insert into log(level,category,thread,time,location,note) values(&apos;%p&apos;,&apos;%c&apos;,&apos;%t&apos;,&apos;%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;&apos;,&apos;%l&apos;,&apos;%m&apos;) 数据库的具体内容就不贴出来了，和普通看到的一样。 总结其实日志用几次就知道它的好了，自己也是在慢慢学习！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jpa实体映射关系]]></title>
    <url>%2F2017%2F06%2F15%2Fjpa%E5%AE%9E%E4%BD%93%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[引：其实距离自己上次写数据库操作已经1个多月了，之前接触的就是Hibernate，这次接触jpa，就把几种对应关系理清。 映射策略注：这次举的例子都是User和Car的 外键关联简介：两个表的关系定义在其中一个表中 @OneToOne方法一：123@OneToOne(cascade=CascadeType.ALL, fetch=FetchType.EAGER)@JoinColumn(name = &quot;user_id&quot;)private Car car; 通过在Car表中加入一个外键，实现两者关系。方法二：12@OneToOne(cascade = CascadeType.ALL,fetch = FetchType.EAGER,mappedBy = &quot;Car&quot;)private User user; 通过在Car类中用MappedBy声明让User进行维护。 @OneToMany123@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)@JoinColumn(name = &quot;user_id&quot;)private Set&lt;Car&gt; cars; 通过在Car表中加入一个外键，实现一对多关系。 @ManyToMany12@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)private Set&lt;Car&gt; cars; 这个是采用默认的表关联 表关联简介：两个表的关系通过一张中间表来来关联 @OneToMany12345@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)@JoinTable(name = &quot;user_car&quot;,joinColumns=&#123;@JoinColumn(name = &quot;user_id&quot;)&#125;,inverseJoinColumns = &#123;@JoinColumn(name = &quot;car_id&quot;)&#125;)private Set&lt;Car&gt; cars; 通过JoinTable来确定一张中间表，joinColumns里面放父表的属性，inverseJoinColumns放子表的属性 @ManyToMany12345@ManyToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)@JoinTable(name = &quot;user_car&quot;,joinColumns=&#123;@JoinColumn(name = &quot;user_id&quot;)&#125;,inverseJoinColumns = &#123;@JoinColumn(name = &quot;car_id&quot;)&#125;)private Set&lt;Car&gt; cars; 解释如@OneToMany 一些属性cascade属性 CascadeType.PERSIST：级联新建 CascadeType.REMOVE：级联删除 CascadeType.REFRESH：级联刷新 CascadeType.MERGE：级联更新 CascadeType.ALL：包括上面四项 fetch属性 FetchType.EAGER：相当于禁用懒加载，推荐开发使用 FetchType.LAZY：懒加载，默认值，推荐部署使用 总结父表是提供主键的，子表是利用父表的主键来设置外键的，维护方是Owner，被维护方是Owned。提示自己一个傻逼的问题，插入数据要先往两张表中插入数据，在往中间表插入数据，不然会报错~]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>sping</tag>
        <tag>jpa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot项目调试angular2]]></title>
    <url>%2F2017%2F06%2F01%2Fspringboot%E9%A1%B9%E7%9B%AE%E8%B0%83%E8%AF%95angular2%2F</url>
    <content type="text"><![CDATA[引：在接触 springboot和angular2的前后端项目的时候，我发现自己会先把angular2的项目编译好之后放在springboot的resource目录下的static文件夹下运行，虽然这样可以，但是对于前端来调试代码实在不方便。在百度网上的方法之后可以采用如下代理的方式。 问题 angular2启动的服务默认为http://localhost:4200 springboot启动的服务默认为http://localhost:8080 如果我们直接设置angular2访问的路径为http://localhost:8080就会出现跨域访问的问题。请求不到数据。 解决在angular2项目的根目录下面新建一个proxy.config.json123456&#123;&quot;/api&quot;: &#123;&quot;target&quot;: &quot;http://localhost:8081&quot;,&quot;secure&quot;: false&#125;&#125; 然后在启动项目的时候采用下面的命令 ng serve –proxy-config proxy.config.json 通过这样的代理访问就能能够实现跨域访问请求数据。 总结通过上面的方法方便了开发调试，不错，终于要开始写代码了！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>angular2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringSecurity+JWT保驾SpringBoot(未完)]]></title>
    <url>%2F2017%2F05%2F24%2FSpringSecurity-JWT%E4%BF%9D%E9%A9%BESpringBoot-%E6%9C%AA%E5%AE%8C%2F</url>
    <content type="text"><![CDATA[引：在万老师的指引下，开始接触到了安全板块，SpringSecurity+JWT绝对能够让人欣喜 JWT介绍关于JWT说实话是最近才听到的，然后慢慢开始了解，这里简单记下一篇博文。这篇博文在做过简单的应用之后发现还是不怎么全的 ，等自己再深入了解之后，再来补全。 SpringSecurity整合JWT看了几个SpringSecurity的应用，发现应该是大同小异，自己也找到一篇虽然结构不太好，但大部分内容都讲到的博文。也是日后能够总结得好一点，再来补全。 总结一定要再来！！！！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JWT</tag>
        <tag>SpringSecurity</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular2入门]]></title>
    <url>%2F2017%2F05%2F24%2FAngular2%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[引：由于老师暑假的项目前端代码需要用到Angular2，作为一个后端开发者也是需要了解一丢丢的。 Angular简介在经过简单的了解与使用之后，感觉 到Angular2的强大与伟大，配的上说是一个优秀的前端框架。Angular2实现了前端一直提倡的组件化开发还解决了大部分项目路由混乱的问题。它还有具有MVC分层架构和依赖注入等一系列优秀的特性。现在贴上Angular2的一张架构图：上图描述了Angular2中8大主要构造块的关系，他们具体的理解，可以参考这篇博文。如果还有什么不理解，那我们可以相信实践见真知。 Angular起步在这次学习中，我终于理解了前辈们所说的入门一门技术就好的方法就是去看官方文档了，Angular2的官网文档里面有中文版的，相信大家一定很开心吧。当然没有中文版也是要看的，比较都是最基础的入门，不要惧怕英文。 在这次按照官方文档的教程（英雄编辑器）出现了两个问题，这里也说明一下： angular-in-memory-web-apia模块不存在 解决方法：通过命令行安装 npm i angular-in-memory-web-api 1234567create(name: string): Promise&lt;Hero&gt; &#123;return this.http.post(this.heroesUrl, JSON.stringify(&#123;name: name&#125;), this.headers).toPromise().then(res =&gt; res.json().data as Hero).catch(this.handleError);&#125; 这里的post方法中的第三个参数应该是this.headers,而不是像官方文档中的那样。 总结如果遇到不懂得问候多看看文档吧，相信自己可以的，然后就是实践见真知了。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Angular2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简谈entity，model，domain]]></title>
    <url>%2F2017%2F05%2F23%2F%E7%AE%80%E8%B0%88entity%EF%BC%8Cmodel%EF%BC%8Cdomain%2F</url>
    <content type="text"><![CDATA[引：前两天听到关于entity和domain包的区别，好像之前自己也没有在意过，今天看看网上的信息总结一下。 entity（实体）这好像是最常用的package命名了，package的类一般都是和数据库的表对应的。一个实体，一张表，其字段的类型也是对应的。 model（模型）最初接触到它的时候是Struts的模型驱动，用于接受和显示前台的数据对象。我们要根据实际情况来确定模型的类。 domain（域）说实话，这个包名用得不怎么多，在网上显示它在国外的网站用的比较多，它主要是用于存储一个业务对象（模块对象）。 总结正确命名包名，有助于后续代码的维护，以及后来开发者的维护，最重要的是能衔接行业的规范。慢慢来！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行运行hadoop程序]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8Chadoop%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[引：自己最近心态有点崩，毕竟很迷茫，趁现在比较空 ，也就微微看看hadoop。在运行《Hadoop权威指南》的时候，遇到了按照书上命令行无法运行的问题。 问题 大家都知道刚开始入门，就遇到问题了就必然是十分难受的，那么我们现在可以解决。 解决编辑 ~/.bash_profile12export HADOOP_HOME=/usr/local/hadoopexport CLASSPATH=$($HADOOP_HOME/bin/hadoop classpath):$CLASSPATH 使其生效1source ~/.bash_profile 运行 编译主类 1javac MaxTemperature.java 把.class 文件打包成 jar，才能在 Hadoop 中运行： 1jar -cvf MaxTemperature.jar ./MaxTemperature*.class 创建input文件夹的数据，就可以运行了(每次运行时，output文件夹都应该不存在) 1hadoop MaxTemperature input/ncdc/sample.txt output 总结虽然我自己还不知道书上的命令行为什么不能用，但是还是希望慢慢可以弄懂吧！]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F2017%2F05%2F17%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[引：上次看到过钟华老师的一个基于贪心算法的毕业设计，一直很好奇，今天终于能看看它了，只是知其然，不知所以然。 贪心算法总说贪心算法在每一步都会做出看起来是最佳的选择，也就是说会做出局部最优的选择，希望以此能够得到最优解。 活动选择问题贪心选择我们要选择这样一个活动，选出它之后身下的资源能够被尽量多的其他任务所用，即选择最早结束的活动。 递归贪心算法算法思路：用两个数组s和f表示活动的开始和结束时间。下表k是我们要求解的子问题，以及问题规模n，代码如下：12345678910111213141516171819202122232425262728293031import java.util.ArrayList;import java.util.List;public class ActivitySelector &#123;public int[] s = new int[]&#123;1,3,0,5,3,5,6,8,8,2,12&#125;;public int[] f = new int[]&#123;4,5,6,7,9,9,10,11,12,14,16&#125;;public List&lt;Integer&gt; list = new ArrayList&lt;&gt;();public void recursiveActivitySelector(int[] s, int[] f,int k,int n)&#123;if(list.size()==0)&#123;list.add(1);&#125;int m = k+1;while (m&lt;n &amp;&amp; s[m]&lt;f[k])&#123;m = m+1;&#125;if(m&lt;n)&#123;list.add(m+1);recursiveActivitySelector(s, f, m, n);&#125; else &#123;return ;&#125; &#125;public static void main(String[] args) &#123;ActivitySelector activitySelector = new ActivitySelector();activitySelector.recursiveActivitySelector(activitySelector.s, activitySelector.f, 0, activitySelector.f.length);for (Integer i : activitySelector.list) &#123;System.out.println(i);&#125;&#125;&#125; 迭代贪心算法这个过程是假设输入活动的结束时间是已经排好序的，代码如下：123456789101112131415161718192021222324252627import java.util.ArrayList;import java.util.List;public class GreedyActivitySelector &#123;public int[] s = new int[]&#123;1,3,0,5,3,5,6,8,8,2,12&#125;;public int[] f = new int[]&#123;4,5,6,7,9,9,10,11,12,14,16&#125;;public List&lt;Integer&gt; list = new ArrayList&lt;&gt;();public void greedActivitySelector(int[] s,int[] f)&#123;int n = s.length;list.add(1);int k = 1;for (int m = 1; m &lt; n; m++) &#123;if(s[m]&gt;=f[k])&#123;list.add(k);k = m;&#125;&#125;&#125;public static void main(String[] args) &#123;ActivitySelector activitySelector = new ActivitySelector();activitySelector.recursiveActivitySelector(activitySelector.s, activitySelector.f, 0, activitySelector.f.length);for (Integer i : activitySelector.list) &#123;System.out.println(i);&#125;&#125;&#125; 贪心算法原理设计贪心算法的过程 确定问题的最优子结构 设计一个递归算法 证明一个贪心选择，则只剩下一个子问题 证明贪心选择总是安全的 设计一个递归算法实现贪心策略 将递归算法转换为迭代算法 证明一个贪心算法是否能求解一个最优化问题？具有下面性质就ok？ 贪心选择性质 我们可以通过做出局部最优选择来构造全局最优解 最优子结构 如果一个问题的最优解包含子问题的最优解 总结一步一步慢慢贪心，和做人是一样的，但是总的来说还是要考虑全局的！！！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2017%2F05%2F17%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[引：慢慢就步入了算法导论的高级设计与分析技术模块，先来看看动态规划。ps:快毕业的心情org。 动态规划总说动态规划虽然与分治方法相似，但是它能够解决子问题重叠的情况，这样就提高了效率。它通常是用来求解最优化的问题。求得是一个最优解。一般按如下4个步骤来设计一个动态规划算法。 刻画一个最优解的结构特征 递归地定义最优解的值 计算最优解的值，通常采用自底向上的方法 利用计算出的信息构造出一个最优解 钢条切割先看以前常用的分治方法即自顶向下方法,代码如下：12345678910111213141516171819202122232425262728public class CutRod &#123;//a[i]表示长度为i的钢条利润是多少public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;//自顶向下递归设计public int cutRod(int[] a,int n) &#123;if(n == 0)&#123;return 0;&#125;int q = 0;for (int i = 0; i&lt;n; i++)&#123;q = max(q,a[i]+cutRod(a,n-1-i));&#125;return q;&#125;//求最大值函数public int max(int a, int b)&#123;if(a&gt;b)&#123;return a;&#125; else &#123;return b;&#125;&#125;public static void main(String[] args) &#123;CutRod cut = new CutRod(); int lost = cut.cutRod(cut.a,10);System.out.println(lost);&#125;&#125; 问题：反复地用相同的参数值对自身进行递归调用，造成了运行时间为n的指数函数。 为了解决这个问题，我们可以采用动态规划方法求解最优钢条切割问题。 采用带备忘的自顶向下法核心是利用一个数组存储已经求解过的最优解，避免了重复的计算，具体的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MemoizedCutRod &#123;//a[i]表示长度为i的钢条利润是多少public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;//带备忘的自顶向下函数public int memoizedCutRod(int[] a,int n)&#123;//创建一个备忘的数组存储一个之前计算过的最优解int[] r = new int[n];//初始化数组for (int i : r) &#123;i = 0;&#125;//借助辅助函数计算return memoizedCutRodAux(a, n, r);&#125;//带备忘的自顶向下法辅助函数public int memoizedCutRodAux(int[] a,int n,int[] r) &#123;//定义利润int q = 0;if(n == 0)&#123;return 0;&#125; //判断原先是否已经计算过，若计算过就不用再计算if(r[n-1] &gt;0)&#123;return r[n-1]; &#125;else &#123;for (int i = 0; i&lt;n; i++)&#123;q = max(q,a[i]+memoizedCutRodAux(a, n-1-i, r));&#125;&#125;r[n-1] = q;return q;&#125;//求最大值函数public int max(int a, int b)&#123;if(a&gt;b)&#123;return a;&#125; else &#123;return b;&#125;&#125;public static void main(String[] args) &#123;MemoizedCutRod cut = new MemoizedCutRod();int lost = cut.memoizedCutRod(cut.a, 10);System.out.println(lost);&#125;&#125; 采用由底向上的方法核心是从小算到大算出每一个长度的最优解，然后返回想要的长度的最优解。代码如下： 123456789101112131415161718192021222324252627282930public class BottomUpTopCutRod &#123;//a[i]表示长度为i的钢条利润是多少public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;public int bottomUpTopCutRod(int[] a, int n)&#123;int[] r = new int[n+1];//长度为0的时候，收益为0r[0] = 0;int q = 0;for(int i = 0; i&lt;n; i++)&#123;for(int j = 0; j&lt;=i; j++)&#123;q = max(q,a[j]+r[i-j]);&#125;r[i+1] = q;&#125;return r[n];&#125;//求最大值函数public int max(int a, int b)&#123;if(a&gt;b)&#123;return a;&#125; else &#123;return b;&#125;&#125;public static void main(String[] args) &#123;BottomUpTopCutRod cut = new BottomUpTopCutRod();int lost = cut.bottomUpTopCutRod(cut.a, 10);System.out.println(lost);&#125;&#125; 优势：实现了运行时间复杂度n*n 动态规划原理适用应用动态规划方法求解的最优化问题应该具备的两个要素：最优子结构和子问题重叠 最优子结构如果一个问题的最优解包含其子问题的最优解，我们就称这个问题具有最优子结构性质。例如：无权最短路径。 重叠子问题如果递归算法反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质。例如钢条切割。 总结慢慢懂一点小算法思想。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观《驴得水》呻吟]]></title>
    <url>%2F2017%2F05%2F11%2F%E8%A7%82%E3%80%8A%E9%A9%B4%E5%BE%97%E6%B0%B4%E3%80%8B%E5%91%BB%E5%90%9F%2F</url>
    <content type="text"><![CDATA[引：其实当身边同学都在打游戏的时候，我却不能静下心来了，内心仍然是浮躁，既然不能改论文，所以自己就找电影看吧。自认为自己是一个不懂得享受的人，所以在大脑思索良久之后，决定观看好久之前评价还不错的电影《驴得水》。 总说我不知道该以什么角度来评价这部电影，但这部电影给我感受是深刻，至少在灵魂上还是有一定的冲击，感觉作者与导演把每个角色想要表达的思想基本上都表达出来了，下面我也将按这些角色把在我身上能够体会到的思想说一下，至少在我心里，这是一部好电影。 角色思想校长这个一个有抱负的校长，但是却又特别的自私，为了达成自己的抱负，他选择了屈服，虽然在某些片段来说，他有一点想反抗，如他不能忍受裴魁山去骂张一曼，但是那一点反抗却是那么无力，到最后他选择了屈服，屈服到了让自己的女儿去做牺牲。关于这个角色我不想做太多评价，他总说以大局为重，或许在生活中很多人都会这么做，自私到可以牺牲掉很多。 裴魁山这个角色应该就是现在很多人所说的腹黑吧，自己得不到，就宁愿把他毁掉，他从不介意张一曼的出身愿意娶她，到指着他的鼻子骂，这个转变让很多人心凉，追不到还能做朋友么，他的回答告诉我们，他不搞她已经是最好的结果了。爱一个可以随时为她着想，恨一个人希望所有人都恨他。 铜匠也许他后面变得很坏，但是我从头到尾都认为他是这部剧最可怜的人，他原来是一个单纯至极的人，命运使然他加入到了一个骗子集团吧，因为单纯才会认为张一曼会喜欢他吧，因为单纯所以期望太高，这导致在张一曼骂他牲口之后开始最强烈的抱负。但是有一点他这个觉得传递了不好的概念，有知识不是为了更好的抱负，而是应该为了更好的帮助别人，虽然他的行为可以理解，但是却不提倡，从他到最后还是想去美国学习，可以看出他还是很想学习的，想脱离文盲这个行列。 张一曼这是一个不畏世俗的眼光，勇敢追求自由的女子，也不能说是道德败坏吧，虽然和有妇之夫搞一起不太好，但是他自己也有自己的原则，就像他一开始不愿意将她和铜匠的事情说出来一样，他有自己一定的原则。但是在校长的屈服下，也造就了他的悲剧，最后开枪自杀了。 周铁男这个角色也是反映了一部分人，他喜欢孙佳，但是一直没有说出来，也算单纯耿直的人，平时脾气挺冲，在别人要动孙佳的时候也立马站了出来，可惜在擦过枪子的之后，他选择了屈服，他慢慢开始收敛自己，只是为了能够活下去，他甚至可以认忍受孙佳去嫁给铜匠，所以说，所谓的爱在现实的生与死之间是那么的不堪。 孙佳这个人或许是这部剧中完全没有污点的人吧，应该也是导演想表达的正面形象，他是唯一一个把驴得水当做人看的人，也是第一个想揭发整个阴谋的人，面对这一切，她说过去的都让他过去的话，那么只能越来越错，不能让错误一直延续下去。莫名戳中内心。 特派员一个目不识丁，却假装英国留学回来的官员，所谓的民间教育家的评选，不过是教育部敛财的名头，从被骗到一起骗说明政府的腐败与强势，从十万到三万，我们看到了心凉。 总结主要人物各有各的责任，他们都反应了这个世界上的一部分人，所以感受很深，点评不当之处，也希望大家担待。好吧，呻吟到此结束。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择算法]]></title>
    <url>%2F2017%2F05%2F10%2F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[引：300000是不是一个小目标，不知道为了目的还是目的，只想好好努力，功利也好，安慰也罢！ 期望为线性时间的选择算法算法思想： 检查数组是否只有一个数，如是，只好返回该数 采用随机分割将数组氛围a[p..q-1]和a[q+1..r]并返回主元q 检查如果该主元就是我们要找的数，就返回 判断前半部分的个数，如果要找的顺序大于前面的个数，就递归调用后面的数组，否则递归调用前面的数组 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Random;public class Randomized_select &#123;public int randomized_select(int[] a,int p, int r,int i)&#123;//如果分割到只剩一个元素了，那么就是这个了if(p == r)&#123;return a[p];&#125;//随机分割int q = randompartition(a, p, r);//确定q是第几小的数int k = q-p+1;if(k == i) &#123;return a[q];&#125;else if(k&lt;i)&#123;//递归调用后半部分的数return randomized_select(a, q+1, r, i-k);&#125; else &#123;//递归调用前半部分的数return randomized_select(a, p, q-1, i);&#125; &#125;//分割函数public int partition(int[] a,int p,int r)&#123;int x = a[r];int i = -1;int temp = 0;for (int j = 0; j &lt; a.length-1; j++) &#123;if(a[j]&lt;x)&#123;i=i+1;temp = a[i];a[i] = a[j];a[j] = temp;&#125;&#125;temp = a[i+1];a[i+1] = x;a[r] = temp;return i+1;&#125;//随机分割 public int randompartition(int[] a,int p,int r)&#123;int temp = 0;Random random = new Random();int i = random.nextInt(r);temp = a[i];a[i] = a[r];a[r] = temp;return partition(a, p, r);&#125;public static void main(String[] args) &#123;int[] a = new int[]&#123;3,2,9,0,7,5,4,8,6,1&#125;;Randomized_select select = new Randomized_select();int num = select.randomized_select(a, 0, a.length-1, 10);System.out.println(num);&#125;&#125; 算法分析：期望时间复杂度是线性的O(n),但是最坏的时间复杂度是O(n*n) 最坏情况为线性时间的选择算法算法思想： 将输入数组的n个元素划分为n/5组，每组5个元素，且至多只有一组由剩下的nmod5个元素组成。 寻找每一个组的中位数：首先对每组元素进行插入排序，然后确定每组的中位数。 对第2部的中位数数组利用递归调用前面的random_select()求取中位数x 利用修改的partition(),按中位数x进行划分，得到比x小的数有k个 如果i=k则返回x。如果ik，则在高区递归查找第i-k小的元素 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package select;public class GoodSelect &#123;//插入排序public void insertsort(int[] a,int p, int r)&#123;for (int i=p+1;i&lt;=r;i++) &#123;int temp = 0;//*从后往前插*for(int j = i;j&gt;p &amp;&amp; a[j]&lt;a[j-1];j--)&#123;temp = a[j];a[j] = a[j-1];a[j-1] = temp;&#125;&#125;&#125;//对数组A[]分组，每组5个元素，分别进行插入排序,返回中位数数组public int[] partInsertSort(int[] a,int p,int r) &#123;int i = 0;int[] b;if((r-p+1)%5==0)&#123;b = new int[(r-p+1)/5];&#125; else &#123;b = new int[(r-p+1)/5+1];&#125;int Length = r-p+1;if (Length &lt;= 5) //元素个数少于5个&#123; insertsort(a,p,r);b[0]=a[p+(Length-1)/2];&#125;else&#123;for (i=0;i&lt;Length/5;i++)&#123;insertsort(a,p+i*5,p+i*5+4);b[i]=a[i*5+2]; //B[i] 存储各组中位数&#125;if ( Length%5 != 0 )&#123;insertsort(a,Length-1-(Length-1)%5,Length-1);b[i]=a[Length-1-Length%5/2]; //B[i] 存储最后一组中位数&#125;&#125;return b; // 返回分组的个数&#125;//调用random_select算法，选出中位数数组的中位数public int selectmid(int[] a)&#123;Randomized_select randomized_select = new Randomized_select();int num = randomized_select.randomized_select(a, 0, a.length-1, (a.length+1)/2);return num; &#125;//安装精心挑选的中位数来分割数组public int partition(int[] a,int p,int r,int x)&#123;int j = p-1;int i = 0;int temp =0;int addr = 0;//记录最佳中位数的位置for(i = p; i&lt;r+1; i++)&#123;if(a[i]&lt;=x)&#123;j+=1;temp = a[j];a[j] = a[i];a[i] = temp; &#125;if(a[i] == x)&#123;addr = i;&#125; &#125;temp = a[j];a[j] = a[addr];a[addr] = temp; return j;&#125;public int goodselect(int[] a,int p,int r,int i)&#123;//如果分割到只剩一个元素了，那么就是这个了if(p == r)&#123;return a[p];&#125;int [] b = partInsertSort(a, p, r);int x = selectmid(b);int q = partition(a, p, r, x);//确定q是第几小的数int k = q-p+1;if(k == i) &#123;return a[q];&#125;else if(k&lt;i)&#123;//递归调用后半部分的数return goodselect(a, q+1, r, i-k);&#125; else &#123;//递归调用前半部分的数return goodselect(a, p, q-1, i);&#125; &#125;public static void main(String[] args) &#123;int[] a = new int[]&#123;2,1,4,6,5,8,9,7,11,13,12,15,16&#125;;GoodSelect select = new GoodSelect();int num = select.goodselect(a, 0, a.length-1, 13);System.out.println(num);&#125;&#125; 算法总结：毕竟是三个人发明的算法，真是好牛逼的，厉害，实现了最坏时间还是线性的。具体分析请参考算法导论原书。 总结第二个算法真的花了自己好长的时间来调试，还是说明自己的编码能力差劲，要好好努力，慢慢提高，加油！ ps：有一种体会，学算法是为了创造，大多数人只要把优秀的源码包里的算法理解了就好，并加以使用就好！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“线性时间排序（未完，待续）”]]></title>
    <url>%2F2017%2F05%2F10%2F%E2%80%9C%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%8C%E5%BE%85%E7%BB%AD%EF%BC%89%E2%80%9D%2F</url>
    <content type="text"><![CDATA[引：排序慢慢来，今天要接触到线性时间排序了：计数排序，基数排序，桶排序。 计数排序前提条件：知道输入数组的最大值。代码如下：12345678910111213141516171819202122public int[] countingsort(int[] a,int k)&#123;//初始化临时数组,k为数组的最大值int[] c = new int[k+1];for(int i=0; i&lt;=k; i++) &#123;c[i]=0;&#125;//获得等于i的元素个数for(int i= 0; i&lt;a.length-1;i++) &#123;c[a[i]] = c[a[i]]+1;&#125;//获得小于等于i的元素个数(隐含了递归调用)for(int i = 1; i&lt;=k; i++) &#123;c[i] = c[i] +c[i-1];&#125;//按顺序分到输出数组int[] b = new int[a.length];for(int i = a.length-1; i&gt;=0; i--) &#123;b[c[a[i]]] = a[i];c[a[i]] = c[a[i]]-1;&#125;return b;&#125; 优劣：实现了线性时间，但是空间损失惨重，像是叫你排序这三个数：1，3，1000000000000，马上高低立见。 基数排序IBM创始人发明，利用进制数的位进行从低到高比较。其中会将原来的数转化为r进制数，使时间复杂度变为线性。写一下伪代码123redix-sort(A,d)for i = 1 to duse a stable sort to sort array A on digit i 桶排序桶排序假设数据服从均匀分布，讲一个区间分成若干个桶，先将数据放到桶中分开排序再合并。伪代码如下12345678910bucket-sort(A)n = A.lengthlet B[0.. n-1] be a new arrayfor i = 0 to n - 1make B[i] an empty listfor i = 1 to n insert A[i] into list B[nA[i]]for i = 0 to n - 1sort list B[i] with insertion sortconcatenete the lists B[0],B[1].. B[n-1] together in order 它的期望时间为线形。 总结其中对于基数排序和桶排序理解得不是很好，需要加深理解，写出具体实现代码，未完，待续…]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性时间排序</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2017%2F05%2F10%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[引：真的是烦，连个hadoop集群环境都搭不好，发现一个人学还是很困难的，想想还是一个人看算法会简单些，所以来看看了，今天看堆排序！ 堆排序简单介绍堆排序是原址运算，后来由于Java的原因我用了变址，但是算法的思想还是没有变得的.堆分为大顶堆，小顶堆，我们下面以大顶堆为例。 维护堆我们需要一个函数在任何情况下子节点要比根节点小。函数如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546//取父节点public int parent(int i)&#123; return (int)Math.ceil(i/2)-1;&#125;//取左子树public int left(int i)&#123; if(i == 0)&#123; return i+1; &#125; else&#123; return 2*i+1; &#125;&#125;//取右子树public int right(int i)&#123; if(i == 0)&#123; return i+2; &#125; else&#123; return 2*i+2; &#125;&#125;//维护大顶堆public int[] max_heapify(int[] a,int i)&#123; int l = left(i); int r = right(i); int largest = 0; int temp = 0; if(l&gt;=a.length &amp;&amp; r&gt;=a.length)&#123; return a; &#125; if(l&lt;a.length &amp;&amp; a[l]&gt;a[i])&#123; largest = l; &#125; else&#123; largest = i; &#125; if(r&lt;a.length &amp;&amp; a[r]&gt;a[largest])&#123; largest = r; &#125; if(largest!=i) &#123; temp = a[i]; a[i] = a[largest]; a[largest] = temp; max_heapify(a, largest); &#125; return a; &#125; 建堆在对数组遍历建立二叉树的时候，我们容易得出Math.floor(n/2)到n都是叶节点，其余是根节点，所以我们在建堆得时候冲根节点不断往前维护就好。代码如下：12345678//建大堆public int[] bulid_max_heap(int[] a)&#123; heap_size = a.length; for(int i = (int)Math.floor(a.length/2)-1; i&gt;=0; i--)&#123; max_heapify(a, i); &#125; return a;&#125; 堆排序算法思想：先取出顶，再维护，再取顶，再维护，知道最后代码如下：12345678910111213//堆排序算法public int[] heapsort(int[] a) &#123; int[] b = new int[a.length];//无奈之举，java没有size这个属性，或者用list也可以 bulid_max_heap(a); for(int i = a.length-1; i&gt;=1; i--)&#123; b[i] = a[0]; a[0] = a[i]; a[i] = 0;//使最后一个元素不参与排序 max_heapify(a, 0); &#125; b[0] = a[0]; return b;&#125; 算法时间复杂度：nlgn 重要应用——优先队列优先队列应用于共享计算机的系统的作业调度，最大优先队列记录将要执行的各个作业以及它们之间的相对优先级，在任何时候都可以调用insert把一个新作业加入到队列中来。讲一下最大优先序列的几个操作。 maximum获取最大值代码如下：1234 //获取最大值public int maximum(int[] a)&#123; return a[1];&#125; 去掉并返回数组中的最大键值得元素代码如下:12345678910//去掉并返回数组中具有最大键值得元素public int extract_max(int[] a)&#123; if(a.length&lt;1)&#123; System.out.println(&quot;heap underflow&quot;); &#125; int max = a[0]; a[0] = a[a.length]; max_heapify(a, 0); return max;&#125; 总结加油呀加油！堆排序还是强大的，期待运用！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx反向代理与负载均衡]]></title>
    <url>%2F2017%2F05%2F06%2Fnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[引：慢慢做项目的过程中，也就接触到了负载均衡，谈到负载均衡就会接触到反向代理服务器，这里介绍一下nginx。 nginx反向代理nginx简介nginx是一个使用c语言开发的高性能的http服务器及反向代理服务器，是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。感觉棒棒哒。 nginx应用场景 http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 nginx安装启动配置 安装：nginx一般安装在linux下 启动： 在sbin目录下执行: ./nginx 如果访问不到，可能就是linux防火墙没有开启8080端口的访问——关闭：在sbin目录下执行: ./nginx -s stop——刷新配置：在sbin目录下执行: ./nginx -s reload 配置虚拟主机：在nginx.conf文件中添加一个Service节点，修改端口号就可以12345678910111213server &#123; listen 81; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html81; index index.html index.htm;&#125;&#125; nginx反向代理反向代理服务器是引用在服务端。决定哪台服务器提供服务。用一张图来理解： nginx负载均衡并发量大的时候自然会用到负载均衡，其实每台服务器的内容都是一样的，多台机器服务自然减轻了单台服务器的压力。在nginx中其实配置很简单，如下：1234567891011121314151617upstream tomcats&#123; server 192.168.142.128:8080 weight=2; server 192.168.142.128:8081;&#125;server&#123; listen 80; server_name tomcat.taobao.com; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_pass http://tomcats; index index.html index.htm; &#125;&#125; 只需要在upstream的server后面添加一个weight即可代表权重。权重越高，分配请求的数量就越多。默认权重是1。 总结其实很多东西没有自己想象的那么难，好好努力，每天积累！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序及随机化算法]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[引：算法一直很重要，最近没有心情去看项目的代码与技术，所以就拿起其了算法导论来看，最经典的快速排序及随机化算法，java实现。 快速排序算法 核心思想分治思想和原址运算：看一张图 算法具体实现 public class QuickSort { public int partition(int[] a,int p,int r){ int x = a[r]; int i = -1; int temp = 0; for (int j = 0; j &lt; a.length-1; j++) { if(a[j]&lt;x){ i=i+1; temp = a[i]; a[i] = a[j]; a[j] = temp; } } temp = a[i+1]; a[i+1] = x; a[r] = temp; return i+1; } public int[] quicksort(int[] b,int p,int r){ if(p&lt;r){ int q = partition(b,p,r); quicksort(b, p, q-1); quicksort(b, q+1, r); } return b; } public static void main(String[] args) { QuickSort sort = new QuickSort(); int[] a = {2,8,7,1,3,5,6,4}; int[] b = sort.quicksort(a, 0, a.length-1); for (int i : b) { System.out.print(i+&quot; &quot;); } } } 3.时间复杂度 通过分析我们最看重的平均复杂度是nlgn 随机化算法 核心思想 在算法加入随机性，要么在使序列生成随机化，要么就是使主元随机化，这里我们使主元随机化。 算法具体实现 import java.util.Random; public class RandomQuickSort { public int partition(int[] a,int p,int r){ int x = a[r]; int i = -1; int temp = 0; for (int j = 0; j &lt; a.length-1; j++) { if(a[j]&lt;x){ i=i+1; temp = a[i]; a[i] = a[j]; a[j] = temp; } } temp = a[i+1]; a[i+1] = x; a[r] = temp; return i+1; } public int randompartition(int[] a,int p,int r){ int temp = 0; Random random = new Random(); int i = random.nextInt(r); temp = a[i]; a[i] = a[r]; a[r] = temp; return partition(a, p, r); } public int[] randomquicksort(int[] b,int p,int r){ if(p&lt;r){ int q = randompartition(b, p, r); randomquicksort(b, p, q-1); randomquicksort(b, q+1, r); } return b; } public static void main(String[] args) { RandomQuickSort sort = new RandomQuickSort(); int[] a = {2,8,7,1,3,5,6,4}; int[] b = sort.randomquicksort(a, 0, a.length-1); for (int i : b) { System.out.print(i+&quot; &quot;); } } } 时间复杂度 通过分析我们最看重的平均复杂度是nlgn 基本排序算法 小结：同等情况下快速排序&gt;随机化算法&gt;归并排序&gt;插入排序；在有序的情况下随机化算法&gt;快速排序 总结慢慢走，不要急！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git个人使用与多人协作]]></title>
    <url>%2F2017%2F05%2F04%2Fgit%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[引：因为没有加入到什么团队中，没有机会和别人一起合作过项目，所以对git使用并不熟练，但是这次比较空，就好好梳理一下吧！ 个人使用git介绍特点就是分布式了，请看下图，每一台电脑都是一个仓库，大家都可以使用。 仓库理解及操作先上图： 有个上面的图做铺垫，下面的操作也就好理解了 添加文件：git add file 提交文件：git commit -m &quot;提交描述&quot; 查看状态:git status 查看日志：git log 相关版本号可以通过reset来回退到任何提交时间点 添加远程库：git remote add origin git@github.com:username/repository 推送到远程库： 第一次用：git push -u origin master之后用git push origin master注意点：要将电脑的ssh添加到你的github里 克隆远程库：git clone origin git@github.com:username/repository 多人协作我想大家需要理解这样一张图： 推送分支：$ git push origin branchname 抓取分支：git clone origin git@github.com:username/repository;git checkout -b dev origin/dev 基本操作肯定会碰到问题： 如果你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，那么就会提交被解决，这个时候就需要： git pull 这个时候合并是有冲突的，需要你本地修改之后再提交上去。 总结目前自己所要掌握的就是这些东西了，再遇到问题可以谷歌或者百度。最后感谢廖雪峰的git教程]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String,StringBuilder,StringBuffer区别]]></title>
    <url>%2F2017%2F05%2F04%2FString-StringBuilder-StringBuffer%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[引：最近心情非常的不静，我知道自己需要沉下心去沉淀，慢慢来，小朋友。今天谈谈3个字符串类 String查看String源码的时候，我们很容易看到&gt; public final class String 从源码中对String的定义可以知道它是final类，这意味着她不可被继承，也不可被更改。而且总它的方法中也没有可以拼接字符串的函数。 StringBuilder查看StringBuilder源码的时候，我们也可以看到这样的定义：&gt; public final class StringBuilder extends AbstractStringBuilder 我们发现他也是final类，但是它却又append()方法，这是为什么，我们找到它的append(): @Override public StringBuilder append(String str) { super.append(str); return this; } 我们看到他的append()方法是调用他的父类来的，所以我们继续看看他的父类是在搞什么鬼👻 public AbstractStringBuilder append(String str) { if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this; } 我们终于找到他怎么又这个添加字符串的方法了。具体AbstractStringBuilder是怎么实现添加的就让想要了解的人继续往下看源码就好了。 对比string: 我们可以从日常编写的代码可以了解到，用String拼接由于每次都是新建一个对象所以效率自然是低的，所以在使用字符串拼接的时候还是用StringBuilder比较好，但是对于单个常量字符串来说还是String好，因为它是放在常量池里，读取速度比放在堆中的对象自然是要快很多。 StringBuffer这又是一个什么鬼，继续看源码吧 public final class StringBuffer extends AbstractStringBuilder 这个和StringBuilder一样也是final类，但是我们可以很清楚的看到也是继承了AbstractStringBuilder，也就是说它也有append()方法，但是我们可以它的append()方法。 public synchronized StringBuffer append(String str) { toStringCache = null; super.append(str); return this; } 我们看到它的append()方法加入了synchronized关键字，所以它是个线程安全的类 和StringBuilder的区别： 由于他是线程安全的，所以自然牺牲了效率，在操作速度上没有StringBuilder快。 总结：点点滴滴积累]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请不要无脑]]></title>
    <url>%2F2017%2F04%2F27%2F%E8%AF%B7%E4%B8%8D%E8%A6%81%E6%97%A0%E8%84%91%2F</url>
    <content type="text"><![CDATA[大喊一声密码. Decrypt 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]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次失败的面试]]></title>
    <url>%2F2017%2F04%2F26%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[大喊一声密码. Decrypt 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]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH项目初体验]]></title>
    <url>%2F2017%2F04%2F24%2FSSH%E9%A1%B9%E7%9B%AE%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[引：历时四天，终于在视频的帮助下完成了基于SSH（struts2+hibernate3+spring4）的一个网站商城项目，也是自己第一次采用idea开发项目简单，谈谈收获和感想。 代码流程 导包主要的文件：导三大框架的包这里的包我也不贴图了，都是最基本的jar包 框架配置这里我想说的是三个文件： web.xml：配置struts核心过滤器和配置Spring的核心监听器 struts.xml：配置各种action applicationContext.xml：作为大管家事情也就比较多了，有配置数据库C3P0连接池，配置Hibernate引入数据源，事务管理，管理action，service，dao 按层码代码 分层架构 web层主要使用action进行控制，这里使用了动态匹配，如userAction_*.action其中要点： 值栈：对于单个业务逻辑来说存取值实在是太方便了。 模型驱动：对于模块的对象使用模型存值也很方便 拦截器：对于后台范围一定要对访问进行控制，若未登录，请先登录 ognl表达式：可以进行运算，除模型驱动以及值栈内取值之外都要加# service层本次项目并未多少体现出来，我们只要注意添加spring事务注解 dao层此次使用的hibernate，要点如下 实体映射文件：对于主外键一定要设置正确，懒加载问题，级联删除问题 hql语句：join的用法，面向对象的语句编写 项目模块这里只是简单说说作为一个商场应该具有的模块 前台首页；前台用户 ；一级目录； 二级目录； 商品； 购物车； 订单 后台后台用户；一级目录；二级目录；商品；订单 查bug方法即使是按着视频来的，但是也还是会出错，有的时候还查了一个多小时，bug：码农的一生之敌呀！回到正题：首先看控制台错误，分析错误类型 前台传数据错误可以将表单的发送方式改为get，这个就可以从uri中看出错误了，自己好几次入坑，就是在参数填写的地方多了一个空格，欲哭无泪。 业务逻辑代码错误其实最简单也最烦，就是利用debug。按逻辑顺序进行查错。 数据库查询出错可以充分利用控制台输出的sql语句进行排错，将sql语句放到sql桌面程序中查询，是否与自己想要的结果一致，如果不一致，就很有可能是自己的hql语句写错，或者映射文件出错了。 感想关于这个项目架构都是比较简单的，业务逻辑也都是CRUD也算简单，可能还有最重要的高并发问题没有考虑，但是整个项目做下来，自己也算理解了整个项目系统，但是自己绝对不能以CRUD为终点，继续向前加油！！！！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iis实现手机端访问电脑本地服务器]]></title>
    <url>%2F2017%2F04%2F24%2Fiis%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E7%AB%AF%E8%AE%BF%E9%97%AE%E7%94%B5%E8%84%91%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[引：对于很多没有服务器的人来说,实现手机端访问自己写的网页还是有困难的，虽然我们可以可以利用githubpage来实现挂载页面，但是调试起来还是不方便，所以iis就成为了一种简单的方式。 iis简介iis（Internet Information Services）是由微软公司提供的基于运行Microsoft Windows的互联网基本服务,其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。 iis安装这里我就不多说了，网上一搜，安装教程一大把，这里推荐一个链接安装iis 有无线的时候使用大部分人，大部分时间，大部分地方，相信大家都会身处在无线之下，所以只要按照上面的链接使用就可以了。 没无线的时候使用这个时候就要借助流量与热点了 打开手机热点 查看电脑ip地址一般这个时候ip地址已经变了，所有之前按照有无线的时候电脑的ip设置访问地址就有问题了，所以要利用新的ip地址设置访问地址 用手机访问新的ip地址一下子就爽歪歪了 总结 iis对于windows用户来说真是出家旅行，调试代码必备之良品。 当不能访问的时候一定要随时关注电脑的ip地址是否已经发生变化，做到随时更改]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
</search>