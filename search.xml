<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式之禅——建造者模式]]></title>
    <url>%2F2018%2F02%2F08%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[引：生产一个产品，它必然有很多零部件，不同的组装顺序和零部件个数可能会导致不同的产品，通过控制这些顺序与个数可以达到快速生成不同产品的目的，就可以使用建造者模式。 定义建造者模式也叫做生成器模式。 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。——创造类 通用类图如下： 在建造者模式中，有如下4个角色： Product产品类：通常是实现了模板方法模式，也就是有模板方法和基本方法。这个可以看之前写的模板方法模式。 Builder抽象建造者：规范产品的组件，一般是由子类实现。 ContreteBuilder具体建造者：实现抽象类定义的所有方法，并返回一个组建好的对象。 Director导演类：负责安排已有模块的顺序，然后告诉Builder开始建造。 我们可以看到下面的源码：12345678910111213141516171819202122232425262728293031323334353637383940// 产品类 通常由模板方法模式实现public class Product &#123; // 一个方法相当于产品的一个零件 public void doSomething() &#123; // 独立业务处理 &#125;&#125;// 抽象建造者public abstract class Builder &#123; // 设置产品的不同部分(包括零件种类和顺序)，以获得不同的产品 public abstract void setPart(); // 建造产品 public abstract Product bulidProduct();&#125;// 具体建造者public class ContreteBuilder extends Builder &#123; private Product product = new Product(); @Override public void setPart() &#123; // 产品类内部逻辑 &#125; @Override public Product buildProduct() &#123; return product; &#125;&#125;// 导演类，起到封装的作用，避免高层模块深入到建造者内部的实现类。public class Director &#123; private Builder builder = new ContreteBuilder(); public Product getProduct() &#123; builder.setPart(); return builder.buildProduct(); &#125;&#125; 应用优点 封装性，使用建造者模式可以使客户端不必知道产品内部组成的细节。 建造者独立，容易扩展。 使用场景 相同方法，不同执行顺序，产生不同事件结果时，可以采用建造者模式。 多个部件或零件，都可以装配到一个对象中，但是产生不同的效能，可以使用建造者模式。 产品类中的调用顺序不同产生不同的效能，可以使用建造者模式。 注意事项建造者模式关注的是零件类型和装配工艺（顺序），这是它与工厂方法模式最大不同的地方。 最佳实践在使用建造者模式的时候考虑一下模板方法模式，别孤立地思考一个模式，僵化得套用一个模式会让你受害无穷。 参考 《设计模式之禅》]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之禅——模板方法模式]]></title>
    <url>%2F2018%2F02%2F08%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[引：少写代码，大家一定觉得很有吸引力。而且还是先确定一个框架，再写其中的部分，这么结构清晰地写代码，大家一定会觉得更有吸引力，那么我想模板方法模式可以达到你的需求。 定义定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。——行为类 下面是他的通用类图： 其中AbstractClass叫做抽象模板，它的方法分为两类： 基本方法：由子类实现的方法，并且在模板方法被调用。 模板方法：一般是一个具体方法，实现对基本方法的调度，完成固定的逻辑。 为了防止恶意的操作，一般模板方法都加上final关键字，不允许被覆写。 而ConcreteClass属于具体模板，实现父类所定义的抽象方法。 下面再看看他的通用代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 抽象模板类public abstract class AbstrctClass &#123; // 基本方法 protected abstract void doSomething(); // 基本方法 protected abstract void doAngthing(); // 模板方法 final public void templateMethod() &#123; // 调用基本方法，完成相关逻辑 this.doAnything(); this.doSomething(); &#125;&#125;// 具体模板类public class ContreteClass1 extends AbstractClass &#123; // 实现基本方法 @Override protected void doAngthing() &#123; // 业务逻辑处理 &#125; @Override protected void doSomething() &#123; // 业务逻辑处理 &#125;&#125;public class ContreteClass2 extends AbstractClass &#123; // 实现基本方法 @Override protected void doAngthing() &#123; // 业务逻辑处理 &#125; @Override protected void doSomething() &#123; // 业务逻辑处理 &#125;&#125;// 场景类public class Client &#123; public static void main (String[] args) &#123; AbstractClass class1 = new ConcreteClass1(); AbstractClass class2 = new ConcreteClass2(); // 调用模板方法 class1.templateMethod(); class2.templateMethod(); &#125;&#125; 抽象模板中的基本方法尽量设计为protected类型，符合迪米特原则。实现类若非必要，尽量不要扩大父类中的访问权限。 应用优点 封装不变部分，扩展可变部分。 提取公共部分代码，便于维护。 行为由父类控制，子类实现。符合开闭原则。 缺点是优点也是缺点：子类对父类产生了影响。 使用场景 多个子类有公有的方法，并且逻辑基本相同。 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。 重构时，模板方法模式一个常用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。有了钩子方法的模板方法模式才是完美的。 ps：钩子方法就是子类实现的一个方法，可以利用其返回值决定公共部分的执行结果。 最佳实践 父类如何调用子类的方法（极度不建议这么做） 把子类传递到父类的有参构造函数中，然后调用。 使用反射的方式调用。 父类调用子类的静态方法。 但是通过模板方法模式就可以变相地实现父类调用子类的方法。 在开源框架中，它提供了一个抽象类，然后开源框架写了一堆子类。如果你需要扩展，可以继承这个抽象类，然后覆写protected方法，再调用一个类似execute方法，就完成了扩展开发。相信大家一定深有感触。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之禅——抽象工厂模式]]></title>
    <url>%2F2018%2F02%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[引：在开发应用的时候为了适应不同的操作系统以及不同数据库时，我们总会显得力不从心。而抽象工厂模式为了我们提供了优秀的解决方案。 定义为创建一组相关或相互依赖的对象提供一个接口，而且无须指定他们的具体类。——创造类 它的通用类图如下： 为了展示通用的源代码，将原来的通用类图扩展为如下类图： 下面是基于类图的代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 抽象产品类 ProductA与ProductB类似;1,2代表产品等级public abstract class AbstractProductA &#123; // 每个产品共有方法 public void shareMethod() &#123; ... &#125; // 每个产品相同方法，不同实现 public abstract void doSomething();&#125;// 产品A1的实现类public class ProductA1 extends AbstractProductA &#123; @Override public void doSomething() &#123; System.out.println("产品A1的实现方法"); &#125;&#125;// 产品A2的实现类public class ProductA2 extends AbstractProductA &#123; @Override public void doSomething() &#123; System.out.println("产品A2的实现方法"); &#125;&#125;// 抽象工厂类 有N个产品族，在抽象工厂类就有N个创建方法public abstract class AbstractCreator &#123; // 创建A产品家族 public abstract AbstractProductA createProductA(); // 创建B产品家族 public abstract AbstractProductB createProductB();&#125;// 有M个产品等级就应该有M个实现工厂类，在每个实现工厂中，实现不同产品族的生产任务// 产品等级1的实现类public class Creator1 extends AbstractCreator &#123; // 只生产产品等级为1的A产品 public AbstractProductA createProductA() &#123; retrurn new ProductA1(); &#125; // 只生产产品等级为1的B产品 public AbstractProductB createProductB() &#123; retrurn new ProductB1(); &#125;&#125;// 产品等级2的实现类public class Creator2 extends AbstractCreator &#123; // 只生产产品等级为2的A产品 public AbstractProductA createProductA() &#123; retrurn new ProductA2(); &#125; // 只生产产品等级为2的B产品 public AbstractProductB createProductB() &#123; retrurn new ProductB2(); &#125;&#125;// 场景类public class Client &#123; public static void main(String[] args) &#123; // 定义两个工厂 AbstractCreator creator1 = new Creator1(); AbstractCreator creator2 = new Creator2(); // 产生A1对象 AbstractProductA a1 = creator1.createProductA(); // 产生A2对象 AbstractProductA a2 = creator2.createProductA(); // 产生B1对象 AbstractProductB b1 = creator1.createProductB(); // 产生B2对象 AbstractProductB b2 = creator2.createProductB(); &#125;&#125; 主要是要理解产品族以及产品等级的关系。 应用优点 封装性，它只需要了解接口。 产品族的约束为非公开状态。 缺点扩展非常困难。如果要新增一个产品，需要修改AbstractCreator类以及它的实现类。这严重违反了开闭原则。 使用场景如果一个对象族都有相同的约束，就可以使用抽象工厂模式。例如linux和windows下得编辑器和不同数据库的规范操作。 注意事项上面的扩展困难是指产品族扩展困难，但是产品等级扩展还是容易的。 最佳实践在涉及不同操作系统，不同数据库的时候非常适合抽象工厂模式，因为它可以屏蔽掉操作系统或数据库对应用的影响。 参考 《设计模式之禅》]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之禅——工厂方法模式]]></title>
    <url>%2F2018%2F02%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[引：在面向对象的思维中，万物皆对象，就像有女蜗造人，我们也可以用工厂方法模式造对象。 定义定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。——创造类 工厂方法模式的通用类图如下： 下面是一个比较实用的通用源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 抽象产品类public abstract class Product &#123; // 产品类的公共方法 public void method1() &#123; // 业务逻辑处理 &#125; //抽象方法 public abstract void method2();&#125;// 具体产品类public class ContreteProduct1 extends Product &#123; @Override public void method2() &#123; // 业务逻辑处理 &#125;&#125;public class ContreteProduct2 extends Product &#123; @Override public void method2() &#123; // 业务逻辑处理 &#125;&#125;// 抽象工厂类public abstract class Creator &#123; /* * 创建一个产品对象，其输入参数类型可以自行设置 * 通常为String, Enum, Class等，当然也可以为空 */ public abstract &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c);&#125;// 具体工厂类public class ContreteCreator extends Creator &#123; public abstract &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c) &#123; Product product = null; try &#123; product = (Product) Class.forName(c.getName()).newInstance(); &#125; catch (Exception e) &#123; // 异常处理 &#125; return （T）product; &#125;&#125;// 场景类public class Client &#123; public static void main(String[] args) &#123; Creator creator = new ContreteCreate(); Product product = creator.createProduct(ContreteProduct1.class); /* * 继续业务处理 */ &#125;&#125; 应用优点 良好的封装性，代码结构清晰。 扩展性非常优秀，要增加一个新的产品，只要实现Product接口。 屏闭产品类。只要关心产品的接口即可，例如换数据库只要换驱动即可。 符合迪米特法则（只要知道产品的接口即可）；符合依赖倒置原则（值依赖产品的抽象类即可）；符合里氏替换原则（使用产品子类可以替换产品父类）。 使用场景 只要使用new的地方都可以使用工厂方法模式，但是要考虑代码的复杂度。 需要灵活的，可扩展的框架时（有多个产品可选且可以随时增加时），可以考虑工厂方法模式。 工厂方法模式可以用在异构项目中。 可以使用在测试驱动开发的框架下。 工厂方法模式的扩展 缩小为简单工厂模式 实质是去掉了创造者接口，使具体创造者直接依赖产品接口。缺点是扩展比较困难，不符合开闭原则。 升级为多个工厂类 实质是为了结构清晰，我们为每个产品定义一个创造者，然后由调用者自己去选择与那个工厂方法关联。 替代单例模式 代码如下： 123456789101112131415161718192021public class SingletonFactory &#123;private static Singleton singleton;static &#123; try &#123; Class c1 = Class.forName(Singleton.class.getName()); // 获得无参构造 Constructor constructor = c1.getDeclaredConstructor(); //设置无参构造是可访问的 constructor.setAccessible(true); // 产生一个实例对象 singleton = (Singleton) constructor.newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;public static Singleton getSingleton() &#123; return singleton;&#125;&#125; 延迟初始化 所谓延迟初始化即一个对象被消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被使用。其实质，是利用一个Map保存创造过的对象，如果在Map容器已经有的对象，则直接取出返回；如果没有，则根据需要的类型产生一个对象并放入到Map容器中，以方便下次调用。 最佳实践孰能生巧，熟练掌握该设计模式，多思考工厂方法如和应用，而且工厂方法模式可以与其他模式混合使用，变化出无穷的优秀设计。 参考 《设计模式之禅》]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之禅——单例模式]]></title>
    <url>%2F2018%2F02%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[引：如果每个人可以走的路只有一条，如果每个人想要的东西都是一个(单例模式)，那么人应该都不会迷茫了吧。虽然解决了迷茫，但是也抹杀了多样性，有好有坏，各有所见。 定义确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。——创造类 下面是它的通用类图： 代码实现有两种，如下：12345678910111213// 饿汉式单例 线程安全public class Singleton &#123; private static final Singleton = new Singleton(); // 限制产生多个对象 private Singleton() &#123; ... &#125; // 通过该方法获得实例对象 public static Singleton getSingleton() &#123; return singleton; &#125; // 类中其他方法尽量是static public static void doSomething &#123; ... &#125;&#125; 12345678910111213141516// 懒汉式单例 线程不安全public class Singleton &#123; private static final Singleton = null; // 限制产生多个对象 private Singleton() &#123; ... &#125; // 通过该方法获得实例对象 public static Singleton getSingleton() &#123; if (singleton = null) &#123; singleton = new Singleton(); &#125; return singleton; &#125; // 类中其他方法尽量是static public static void doSomething &#123; ... &#125;&#125; 应用优点 减少内存开支 减少系统的性能开销 避免对资源的多重占用 缺点 扩展困难，由于它需要自行实例化 不利于测试，由于单例没完成，不能测试 与单一职责有冲突 使用场景 要求生成唯一序列号的环境 在整个项目中需要一个共享访问带你或共享数据 创建一个对象需要消耗的资源过多，如访问IO和数据库 需要定义大量的静态常量和静态方法（如工具类）的环境 注意事项 在高并发的情况下，请注意单例模式的线程同步问题，选择合适的实现模式。 不可以复制，即不实现Cloneable接口。 最佳实践在Spring中，每个Bean默认就是单例的，这样的优点是Spring容器可以管理这些Bean的生命周期，决定什么时候销魂，销毁的时候要如何处理，等等。如果采用非单例模式，则Bean初始化后的管理交由J2EE容器，Spring容器不在跟踪管理Bean的生命周期。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[先吹响口号_6大设计原则]]></title>
    <url>%2F2018%2F02%2F01%2F%E5%85%88%E5%90%B9%E5%93%8D%E5%8F%A3%E5%8F%B7-6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[引：先有6大设计原则，后有23种设计模式。让我们先吹响这先行的口号。 单一职责原则 SRP定义就一个类或接口而言，应该有且只有一个原因引起类的变更。 例子关于电话通话的接口，有三个过程：拨号、通话、挂机。代码如下：12345678public interface IPhone &#123; //拨通电话 public void dial(String phoneNumber); //通话 public void chat(Onbject o); //挂机 public void hangup();&#125; 但是IPhone这个接口不是只有一个职责，它包含了两个职责：一个是协议管理，一个是数据传送。所以我们改为下面设计的类图： 好处 类的复杂性降低，实现什么职责都有清晰明确的定义 可读性提高，复杂度降低，那当然可读性提高了 可维护性提高，可读性提高了，那当然更容易维护了 变更引起的风险降低 最佳实践接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。 里氏替换原则 LSP定义 正宗定义：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o2都代换成o1时，程序P的行为没有发生变化，那么类型S是类型T的子类型。（感觉《Java设计模式之禅》的翻译错误） 通俗定义：所有引用基类的地方必须能透明地使用其子类的对象（只要父类能出现得地方子类就可以出现；有子类出现的地方，父类未必能适应）。 规则 子类必须完全实现父类的方法。（如果子类不能完整地实现子类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚合、组合灯关系来代替继承。） 子类可以有自己的个性。 覆盖或实现父类的方法时输入参数可以被放大。（子类中方法的前置条件（方法中输入参数）必须与超类中被覆写的方法的前置条件相同或者更宽松。） 覆写或实现父类的方法时输出结果可以被缩小。 疑问（多态是否违背LSP？）如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例时逻辑不一致的可能。 最佳实践在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有了“个性”，这个子类和父类之间的关系就难调和，把子类当做父类使用，子类的“个性”被抺杀了，把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离–缺乏类替换的标准。 依赖倒置原则 DIP定义高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节。细节应该依赖抽象。（不可以分割的原子逻辑就是底层模块，原子逻辑的再组装就是高层模块。抽象就是指接口或抽象类。细节就是实现类。） Java语言表现：模块间的依赖通过抽象产生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。接口或抽象类不依赖实现类。实现类依赖接口或抽象类。——面向接口编程(OOD)。 依赖的三种写法 构造函数传递依赖对象(构造函数注入) 123456789101112131415public interface IDriver &#123; public void drive();&#125;public class Driver implements IDriver &#123; private ICar car; //构造函数注入 public Drive(ICar _car) &#123; this.car = _car; &#125; public void drive() &#123; this.car.run(); &#125;&#125; Setter方法传递依赖对象（Setter依赖注入） 12345678910111213141516public interface IDriver &#123; public void setCar(ICar car); public void drive();&#125;public class Driver implements IDriver &#123; private ICar car; //setter注入 public void setCar(ICar car) &#123; this.car = car; &#125; public void drive() &#123; this.car.run(); &#125;&#125; 接口声明依赖对象(接口注入) 12345678910public interface IDriver &#123; public void drive(ICar car);&#125;public class Driver implements IDriver &#123; //接口注入 public void drive(ICar car) &#123; car.run(); &#125;&#125; 最佳实践 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备。 变量的表面类型（定义的类型）尽量是接口或者是抽象类。 任何类都不应该从具体类派生。 尽量不要覆写基类的方法。 结合里氏替换原则使用（多态） 我们在实际的项目中使用依赖倒置原则需要审时度势，不哟啊抓住一个原则不放，每一个原则的优点都是有限度的，并不是放之四海而皆准的真理，所以别为了遵循一个原则而放弃了一个项目的终极目标：投产上线和盈利。 接口隔离原则 ISP定义客户端不应该依赖他不需要的接口。类间的依赖关系应该建立在最小的接口上。（实例接口：class；类接口：interface） 约束 接口要尽量小。（根据接口隔离原则拆分接口时，首先必须要满足单一职责原则。） 接口要高内聚。（在接口中尽量少公布public方法。） 定制服务。（设计时需要为各个访问者定制服务（接口）。） 接口设计时有限度的。（接口的设计粒度要协调开发难度和可维护性。） 最佳实践 一个接口只服务于一个子模块或业务逻辑。 通过业务逻辑压缩接口中的public方法，经常回顾接口。 已经被污染的接口，尽量去修改，如果变更风险较大，则采用适配器模式进行转化处理。 了解环境，拒绝盲从。 迪米特法则 LoD LKP定义一个对象应该对其他对象有最少的了解。（类解耦） 含义 只与朋友交流 朋友类的定义：出现在成员变量、方法的输入输出参数的类称为成员朋友类。 所以在原类的方法中不能出现非朋友的类，JDK API提供的类除外。 朋友间也是有距离的 尽量不要对外公布太多的public方法和非静态的public变量。 是自己的就是自己的 如果过一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。 谨慎使用Serializable 防止客户端和服务器端类不同步。 最佳实践迪米特法则的核心是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。其要求的结果就是产生大量的中转或跳转类，导致系统的复杂性提高，同时也为维护带来了难度，在采用迪米特法则时需要反复权衡，既做到让结构清晰，又要做到高内聚低耦合。当一个类跳转两次以上才能访问到另一个类，就需要重构了。 开闭原则 OCP定义一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 PS: 3W原则（what：是什么；why：为什么；How：怎么做） 是什么开闭原则告诉我们应该尽量通过扩展软件实体来实现变化，而不是通过修改已有的代码来完成变化，它是为软件实体的未来事件而制定的对现行开发设计进行的约束规则。 开闭原则对扩展开放，对修改关闭，并不以为着不做任何修改，低层模块的变更，必然要有高层模块的进行耦合，否则就是一个孤立无意义的代码片段。 一个项目的基本路径：项目开发、重构、测试、投产、运维，其中的重构可以对原有的设计和代码进行修改，运维尽量减少对原有代码的修改，保持历史代码的纯洁性，提高系统的稳定性。 为什么 简化测试：如果改变软件内容, 需要将所有的测试流程都执行一遍, 如 单元测试, 功能测试, 集成测试等, 如果只是扩展, 只单独测试扩展部分即可。 提高复用性：所有逻辑都从原子逻辑组合, 原子逻辑粒度越小, 复用性越大; 这样避免相同逻辑存在, 修改时需要修改多个此相同逻辑。 提高可维护性：维护一个类最好的方式是扩展一个类, 而不是修改一个类, 如果需要修改需要读懂源码才能修改, 扩展的话只需要了解即可, 直接继承扩展。 怎么做 抽象约束 通过接口或抽象类可以约束一组可能变化的行为，并且实现对扩展开放。其中包括三层含义：第一，通过接口或抽象类约束扩展，对扩展进行边界设定，不允许出现在接口或抽象类不存在的public方法；第二，参数类型，引用对象尽量使用接口或者抽象类，而不是实现类；第三，抽象层尽量保持稳定。 元数据控制模块行为 通过配置参数（从文件或者数据库中来）来控制行为，例如spring配置文件的构造函数注入配置。 制定项目章程 约定优于配置。 封装变化 对变化的封装包含两层含义：第一，将相同的变化封装到一个接口或抽象类中；第二，将不同的变化封装到不同的接口或抽象类中。23个设计模式都是从各个不同的角度对变化进行封装的。 最佳实践 开闭原则只是一个原则，适当时候也可以进行补充。 项目规章非常重要。 预知变化，项目需要具有可扩展性。 总结把上面6大原则的首字母（里氏替换原则和迪米特法则的首字母重复，只取一个）联合起来就是SOLID（稳定的），其代码的含义就是把这6个原则结合使用的好处：建立稳定灵活，健壮的设计，而开闭原则又是重中之中，是最基础的原则，是其他5大原则的精神领袖。 参考 《设计模式之禅》]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML_Java类图]]></title>
    <url>%2F2018%2F01%2F27%2FUML-Java%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[引：在看源码或者很多技术书籍的时候都避免不了看到类图，时间长了总会忘了含义，在这里就总结一下，方便以后回顾。这里使用的工具是startUML。 UMLUML： 统一建模语言（Unified Modeling Language）。在 UML 系统开发中有三个主要的模型： 功能模型：从用户的角度展示系统的功能，包括用例图。 对象模型：采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类图、对象图、包图。 动态模型：展现系统的内部行为。包括时序图，活动图，状态图。 类图类图使用类来描述系统的静态结构，类图包含类和它们之间的关系，它描述系统内所声明的类，但它没有描述系统运行时类的行为。 在UML类图中，类一般由三部分组成：类名、属性以及操作。 类名每个类都必须有一个名字，类名是一个字符串。 属性属性是指类的性质，即类的成员变量。类可以有任意多个属性，也可以没有属性。 格式为： 【可见性】 属性名 【：类型】 【=初始值】 【{属性字符串}】 可见性：在UML中public类型用符号“+”表示，private类型用“-”表示，protected类型用“#”表示。 属性字符串：用来指定关于属性的其他信息，任何希望添加属性定义字符串但又没有合适地方可以加入的规则都可以放在属性字符串里，例如类变量。 操作操作是类的任意一个实例对象都可以使用的行为，操作是类的成员方法。 格式为：【可见性】 操作名 【{参数列表}】 【：返回类型】 【{属性字符串}】 类之间的关系关联关系关联关系(Association)是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一个类与另一个类之间有联系。 在 UML 类图中，用实线连接有关联的的类。在实现关联关系时，通常将一个类的对象作为另一个类的属性。 单向关联类的关联关系可以是单向的，单向关联用带箭头的实线表示。如下图：1234567public class Person &#123; private Address address;&#125;public class Address &#123;&#125; 双向关联默认情况下，关联是双向的。如下图：1234567public class Order &#123; private Product product;&#125;public class Product &#123; private Order order;&#125; 自关联在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。如下图：123public class Node &#123; private Node node;&#125; 重数性关联重数性关联关系又称为多重性关联关系，表示一个类的对象与另一个类的对象连接的个数。在 UML 中多重性关系可以直接在关联直线上增加一个数字表示与之对应的另一个类的对象的个数。如下图： 其中数字的种类及含义如下表： 表示方式 表示含义 1..1 表示另一个类的一个对象只与一个该类对象有关系 0..* 表示另一个类的一个对象与零个或多个该类对象有关系 1..* 表示另一个类的一个对象与一个或多个该类对象有关系 0..1 表示另一个类的一个对象没有或只与一个该类对象有关系 m..n 表示另一个类的一个对象与最少m、最多n个该类对象有关系 (m&lt;=n) 聚合关系聚合关系表示一个整体与部分的关系。通常在定义一个整体类后，再去找出这个整体类的一些成员类，该整体类和成员类之间就形成了聚合关系。 在聚合关系中，成员类是整体类的一部分，即成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。如下图：123456789101112131415public class Car &#123; private Engine engine; public Car(Engine engine) &#123; this.engine = engine; &#125; public setEngine(Engine engine) &#123; this.engine = engine; &#125;&#125;public class Engine &#123;&#125; 组合关系组合关系也表示类之间整体和部分的关系，但是组合关系中部分和整体具有统一的生存期。一旦整体对象不存在，部分对象也将不存在，部分对象与整体对象之间具有同生共死的关系。 在组合关系中，成员类是整体类的一部分，而且整体类可以控制成员类的生命周期，即成员类的存在依赖于整体类。在UML中，组合关系用带实心菱形的直线表示。如下图：1234567891011public class Head &#123; private Eye eye; public Head() &#123; this.eye = new Eye(); &#125;&#125;public class Eye &#123;&#125; 依赖关系依赖关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。如下图：1234567891011public class Driver &#123; public drive(Car car) &#123; car.move(); &#125;&#125;public class Car &#123; public move() &#123; ... &#125;&#125; 泛化关系泛化关系也就是继承关系，也称为“is-a-kind-of”关系，泛化关系用于描述父类与子类之间的关系。在UML中，泛化关系用带空心三角形的直线来表示。如下图： 实现关系实现关系是类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线(mac中的startUML画不出来，大家将就着看)来表示。如下图： 总结理解类图有助于我们更好的去看技术书籍，以及源码，这是必备技能，get it！ 参考 UML 及 StarUml]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发_12_原子变量与非阻塞同步机制]]></title>
    <url>%2F2018%2F01%2F25%2FJava%E5%B9%B6%E5%8F%91-12-%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[引：原子变量与非阻塞同步机制相比于基于锁的方案可以拥有更高的性能和可伸缩性。 锁的劣势 通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有守护变量的锁，都能采用独占方式来访问这些变量，并且对变量的任何修改对随后获得这个锁的其他线程都是可见的。但是当在锁上存在激烈的竞争时，调度开销与工作开销的比值会非常高。 volatile变量是一种更轻量级的同步机制，但是虽然他们提供了相似的可见性保证，但不能用于构建原子的复合操作。因此，当一个变量依赖其他的变量时，或者当变量的新值依赖旧值时，就不能使用volatile。 硬件对并发的支持 独占锁是一种悲观技术——它假设最坏的情况，并且只有在确保其他线程不会找出干扰的情况下才能执行下去。 比较并交换（CAS，硬件指令）是一种乐观的技术——通过这种方法可以在不发生干扰的情况下完成更新操作，不过这种方法需要借助检查机制来判断在更新过程中是否存在其他线程的干扰，如果存在，这个操作将失败，并且可以重试（也可以不重试）。 下面是模拟CAS操作代码：1234567891011121314151617181920// CAS含义：我认为V的值应该是A，如果是，那么把值更新为B，否则不修改并告诉V的值实际是多少public class SimulatedCAS &#123; private int value; public synchronized int get() &#123; return value; &#125; public synchronized int compareAndSwap(int expectedValue, int newValue) &#123; int oldValue = value; if (oldValue == expectedValue) &#123; value = new Value; &#125; return oldValue; &#125; public synchronized boolean compareAndSet(int expectedValue, int newValue) &#123; return (expectedValue == compareAndSwap(expectedValue, newValue)); &#125;&#125; CAS的优点：当竞争程序不高时，性能远远高于基于锁的方案。 CAS的缺点：它将使调用者处理竞争问题（通过重试、回退、放弃），而在锁中能自动处理竞争问题（线程在获得锁之前将一直阻塞）。 原子变量类原子变量类在发生竞争的情况下能提供更高的可伸缩性，因为它直接利用了硬件对并发的支持（比较并交换指令）。 共有12个原子变量类：可分为四组：标量类、更新器类、数组类以及复合变量类。最常用的原子变量类就是标量类：AtomicInteger、AtomicLong、AtomicBoolean以及AtomicReference。 原子变量与锁适用的不同并发场景： 在中低程序的竞争、锁占用时间不长的情况下，原子变量能提供更高的可伸缩性。 而在高强度的竞争下，锁能够更有效的地避免竞争。 非阻塞算法无阻塞算法： 如果在某种算法中，一个线程的失败或者挂起不会导致其他线程也失败或挂起，那么这种算法就被称为无阻塞算法。 无锁算法： 如果在算法的每个步骤中都存在某个线程能够执行下去，那么这种算法被称为无锁算法。 如果在算法中仅将CAS用于协调线程之间的操作，并且能正确地实现，那么它既是无阻塞算法，又是无锁算法。 利用CAS并发指令可以实现非阻塞的同步容器，例如实现非阻塞的栈、非阻塞的链表以及原子的域更新器等。 总结 非阻塞算法通过底层的并发原语（例如比较并交换）来维持线程的安全性。这些底层的原语通过原子变量类向外公开，从而为整数和对象引用提供原子的更新操作。 在JVM从一个版本升级到下一个版本的过程中，并发性能主要提升都来自于对非阻塞算法的使用。 参考 《Java并发编程实战》]]></content>
      <categories>
        <category>Java并发编程实战</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发_11_构建自定义同步工具]]></title>
    <url>%2F2018%2F01%2F24%2FJava%E5%B9%B6%E5%8F%91-11-%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[引：创建状态依赖的类的最简单的方法通常是在类库中现有状态依赖类的基础上进行构造。但如果类库没有提供你需要的功能，我们还可以使用Java语言和类库提供的底层机制来构造自己的同步机制，包括内置的条件队列、显式的Condition对象以及AbstractQueuedSynchronizer框架。 状态依赖性管理程序在做某一个操作之前，需要依赖另一个操作的完成或者状态的就绪，这样的一种关系就叫做“状态依赖”。 状态依赖的实现类,例如FutureTask、Semaphore和BlockingQueue等。在这些类的一些操作中有着基于状态的前提条件，例如，不能从一个空队列删除元素，或者获取一个尚未结束的任务的计算结果，在这些操作可以执行之前，必须等待队列进入“非空”状态，或者任务进入“已完成”状态。 依赖状态的操作可以一直阻塞直到可以继续执行，这比使他们先失败再实现起来要更为方便且更不容易出错。而内置的条件队列就可以是线程一直阻塞，直到对象进入某个线程可以继续执行的状态，并且当被阻塞的线程可以执行时再唤醒他们。 使用条件队列条件队列：它使得一组线程（称之为等待线程集合）能够通过某种方式来等待特定的条件变为真。传统的队列是一个个数据，而与之不同的是，条件队列中的元素是一个个正在等待相关条件的线程。 Object中的wait、notify和notifyAll方法构成了内部条件队列的API。 对象的内置锁与内部条件是相互关联的，要调用对象X中的条件队列的任何一个方法，必须持有对象X上的锁。 Object.wait会自动释放锁，并请求操作系统挂起当前线程，从而使其它线程能够获得这个锁并修改对象的状态。当被挂起的线路醒来时，它将在返回之前重新获取锁。（需要重新竞争，并没有优先获取权） 使用条件队列构造有界缓存示例如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//未加任何约束的缓冲队列public abstract class BaseBoundedBuffer&lt;V&gt; &#123; private final V[] buf;//缓存 private int tail;//队尾 private int head;//队首 private int count;//元素个数 protected BaseBoundedBuffer(int capacity) &#123; this.buf = (V[]) new Object[capacity]; &#125; protected synchronized final void doPut(V v) &#123;//入队 buf[tail] = v;//在队尾添加 if (++tail == buf.length)//如果满了，从头开始 tail = 0; ++count; &#125; protected synchronized final V doTake() &#123;//出队 V v = buf[head];//从队首取出 buf[head] = null;//GC if (++head == buf.length)//如果到尾了，则从头开始 head = 0; --count; return v; &#125; public synchronized final boolean isFull() &#123;//队列是否满 return count == buf.length; &#125; public synchronized final boolean isEmpty() &#123;//队列是否空 return count == 0; &#125;&#125;@ThreadSafepublic class BoundedBuffer&lt;V&gt; extends BaseBoundedBuffer&lt;V&gt; &#123; // 条件谓词：not-full(!isFull()) // 条件谓词：not-empty(!isEmpty()) public BoundedBuffer(int size) &#123; super(size); &#125; // 阻塞并直到: not-full public synchronized void put(V v) throws InterruptedException &#123; while (isFull())//如果满，则等待 wait(); doPut(v); notifyAll();//并在放入后马上通知其他线程 &#125; // 阻塞并直到: not-empty public synchronized V take() throws InterruptedException &#123; while (isEmpty())//如果为空，则等待 wait(); V v = doTake(); notifyAll(); return v; &#125;&#125; 条件谓词条件谓词是使某个操作成为状态依赖操作的前提条件。在有界缓存中，只有当缓存不为空时，take方法才能执行，否则必须等待。对take方法来说，它的条件谓词就是“缓存不为空”，take方法在执行之前必须首先测试该条件谓词。 条件等待存在的三元关系： 包括加锁、wait方法和一个条件谓词。在条件谓词中包含多个包含多个状态变量，而状态变量由一个锁来保护，因此在测试条件谓词之前必须先持有这个锁，锁对象与条件队列对象（即调用wait和notify等方法所在的对象）必须是同一个对象。 每一次wait调用都会隐式地与特定的条件谓词关联起来。当调用某个特定条件谓词的wait时，调用者必须已经持有与条件队列相关的锁，并且这个锁必须保护着构成条件谓词的状态变量。 过早唤醒wait方法的返回并不一定意味着线程正在等待的条件谓词已经变真了，因为也许是因为与同一条件队列相关的另一个条件谓词变成了真。 当使用条件等待时要满足的条件（Object.wait或Condition.wait） 通常都有一个条件谓词——包括一些对象状态的测试，线程在执行前必须首先通过这些测试。 在调用wait之前测试条件谓词，并且从wait中返回时再次进行测试。 在一个循环中调用wait。 确保使用与条件队列相关的锁来保护构成条件谓词的各个状态变量。 当调用wait/notify/notifyAll等方法时，一定要持有与条件队列相关的锁。 在检查条件谓词之后以及开始执行相应的操作之前，不要释放锁。 丢失的信号丢失的信号： notify或者notifyAll操作发生在wait之前，就会造成通知信号的丢失，最终wait永远都得不到恢复或者不得不等待下一次重新通知而延迟了恢复时间。 通知每当在等待一个条件时，一定要确保在条件谓词变为真时通过某种方式发出通知 发出通知的线程应该尽快地释放锁，从而确保正在等待的线程尽可能快地解除阻塞。如果这些等待中线程此时不能重新获得锁，那么无法从wait返回。 只有同时满足以下两个条件时，才能用单一的notify而不是notifyAll： 所有等待线程的类型都相同。只有一个条件谓词与条件队列相关，并且每个线程在wait返回后将执行相同的操作。 单进单出。在条件变量上的每次通知，最多只能唤醒一个线程来执行。 显式的Condition对象内置条件队列的局限性：每个内置锁都只能有一个相关联的条件队列，因而在像BoundBuffer这种类中，多个线程可能在同一个条件队列上等待不同的条件谓词，并且在最常见的加锁模式下公开条件队列对象。 显示条件队列的优势：可以编写一个带有多个条件谓词的并发对象，或者获得除了条件队列可见性之外的更多控制权，这是一种灵活的选择；对于每个Lock，可以有任意数量的Condition对象。Condition对象继承了相关的Lock对象的公平性，对于公平的锁，线程会依照FIFO顺序从Condition await中释放。 特别注意：Condition对象中，三个与条件队列相关的API是：await,signal,signalAll。 下面是使用显示的Condition对象实现的有界缓存:123456789101112131415161718192021222324252627282930313233343536373839public class ConditionBoundedBuffer&lt;T&gt; &#123; protected final Lock lock = new ReentrantLock(); private final Condition notFull = lock.newCondition();//条件：count &lt; items.length private final Condition notEmpty = lock.newCondition();//条件：count &gt; 0 private final T[] items = (T[]) new Object[100]; private int tail, head, count; public void put(T x) throws InterruptedException &#123; lock.lock(); try &#123; while (count == items.length) notFull.await();//等到条件count &lt; items.length满足 items[tail] = x; if (++tail == items.length) tail = 0; ++count; notEmpty.signal();//通知读取等待线程 &#125; finally &#123; lock.unlock(); &#125; &#125; public T take() throws InterruptedException &#123; lock.lock(); try &#123; while (count == 0) notEmpty.await();//等到条件count &gt; 0满足 T x = items[head]; items[head] = null; if (++head == items.length) head = 0; --count; notFull.signal();//通知写入等待线程 return x; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; AbstractQueuedSynchronizerAbstractQueuedSynchronizer是一个用于构建锁和同步器的框架，许多同步器都可以通过AQS很容易并且高效地构造出来。例如：ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock、SynchronousQueue和FutureTask。 下面是AQS中获取操作和释放操作的标准形式：1234567891011121314151617181920212223boolean acquire() throws InterruptedException&#123; while (当前状态不允许获取操作) &#123; if (需要阻塞获取请求) &#123; 如果当前线程不在队列中，则将其插入队列 阻塞当前线程 &#125; else 返回失败 &#125; 可能更新同步器的状态 如果线程位于队列中，则将其移出队列 返回成功&#125;void release()&#123; 更新同步器的状态 if (新的状态允许某个被阻塞的线程获取成功) 解除队列中一个或多个线程的阻塞状态&#125; 总结要实现一个依赖状态的类——如果没有满足依赖状态的前提条件，那么这个类的方法必须阻塞，那么最好的方式是基于现有类库来构建，例如Semaphore.BlockingQueue或CountDownLatch。然而，有时候现有的类库不能提供足够的功能，在这种情况下，可以使用内置的条件队列、显式的Condition对象或者AbstractQueuedSynchronizer来构建自己的同步器。内置条件队列与内置锁是紧密绑定在一起的，这是因为管理状态依赖性的机制必须与确保状态一致性的机制关联起来。同样，显式的Condition与显式地Lock也是紧密地绑定在一起的，并且与内置条件队列相比，还提供了一个扩展的功能集，包括每个锁对应于多个等待线程集，可中断或不可中断的条件等待，公平或非公平的队列操作，以及基于时限的等待。 参考 《Java并发编程实战》]]></content>
      <categories>
        <category>Java并发编程实战</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发_10_显示锁]]></title>
    <url>%2F2018%2F01%2F24%2FJava%E5%B9%B6%E5%8F%91-10-%E6%98%BE%E7%A4%BA%E9%94%81%2F</url>
    <content type="text"><![CDATA[引：Java5.0以后提供了一种新的协调对共享对象的访问机制——ReentrantLock。它并不是用来替代内置锁的方法，而是当内置加锁不适用时，作为一种可选择的高级功能。 ReentrantLockReentrantLock实现了Lock接口，并提供了与synchronized相同的互斥性和内存可见性，但是通常能提供更好的活跃性或性能。下面是Lock接口代码：12345678public interface Lock &#123; void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition();&#125; 为什么要创建一种与内置锁如此相似的新加锁价值？是由于内置锁具有以下的局限性： 无法中断一个正在等待获取锁的线程。 内置锁必须在获取锁的代码块中释放，这就简化了编码工作，并且与异常处理操作实现了很好的互动，但却无法实现非阻塞结构的加锁规则。 下面是Lock接口的标准使用形式：123456789Lock lock = new ReentrantLock();...lock.lock();try &#123; //更新对象状态 //捕获异常，并在必要时恢复不变性条件&#125; finally &#123; lock.unlock(); //“定时炸弹”，一定要记得释放Lock&#125; 轮询锁与定时锁可定时的与可轮询的锁获取模式是由tryLock方法实现的，与无条件的锁获取模式相比，它具有更完善的错误恢复机制。在内置锁中，死锁是一个严重的问题，恢复程序的唯一办法是重新启动程序，而防止死锁的唯一方法就是在构造程序时避免出现不一致的锁顺序。可定时的与可轮询的的锁提供了另一种选择，避免死锁的发生。通过重新获取及释放锁来避免死锁。 可中断的锁操作获取操作可中断的锁操作获取操作是有lockInterruptibly或者tryLock方法实现的，如果在可中断的锁获取操作中抛出了InterruptedException，那么可以使用标准的try-finally加锁模式。 非块结构的加锁我们通过Lock的使用结构可以知道，我们通过ReentrantLock可以灵活的实现锁的粒度。 公平性大多数情况下，非公平锁的性能要高于公平锁的性能，原因是后者为了实现公平，会有更多的线程上下文切换成本。 当持有锁的时间较长，或者请求锁的平均时间间隔较长，那么应该使用公平锁。在这些情况下，允许“插队”带来的吞吐量提升（当锁处于可用的状态时，线程却还处于被唤醒的过程中）则可能不会出现。 在synchronized和ReentrantLock之间进行选择在一些内置锁无法满足需求的情况下，ReentrantLock可以作为一种高级工具。当需要一些高级功能时才应该使用ReentrantLock，这些功能包括：可定时的、可轮询的与可中断的锁获取操作，公平队列（默认非公平），以及非块结构的锁。否则，还是应该优先使用synchronized。 读-写锁在读-写锁的加锁策略中，允许多个读操作同时进行，但每次只允许一个写操作。 ReentrantReadWriteLock为读锁和写锁都提供了可重入的加锁语义。ReentrantReadWriteLock在构造时可以选择是一个非公平的锁（默认）还是一个公平的锁。在公平的锁中，等待时间最长的线程将优先获得锁。在非公平的锁中，线程获得访问许可的顺序是不确定的。写线程可以降级为读线程，但是读线程不可以升级为写线程（因为多个读线程都不会放弃自己的读取锁而导致死锁）。 适用场景： 当锁的持有时间较长并且大部分操作都不会修改被守护的资源时，那么读-写锁能提高并发性。如果写操作也很频繁，那可能独占锁更合适一些，因为写操作太多，竞争会很激烈，再加上协调读写锁，性能反而不如独占锁了。 下面展示用读-写锁来包装Map：123456789101112131415161718192021222324252627282930public class ReadWriteMap&lt;K, V&gt; &#123; private final Map&lt;K, V&gt; map; private final ReadWriteLock lock = new ReentrantReadWriteLock(); private final Lock r = lock.readLock(); private final Lock w = lock.writeLock(); public ReadWriteMap(Map&lt;K, V&gt; map) &#123; this.map = map; &#125; public V put (K key, V value) &#123; w.lock(); try &#123; return map. put(key, value); &#125; finally &#123; w.unlock(); &#125; &#125; // 对remove(),putAll(),clear()等方法执行同样的操作 public V get(Object key) &#123; r.lock(); try &#123; return map.get(key); &#125; finally &#123; r.unlock(); &#125; &#125; // 对其他只读的Map方法执行相同的操作&#125; 总结 与内置锁相比，显示的Lock提供了一些扩展功能，在处理锁的不可用性方法有着更高的灵活性。但ReentrantLock不能完全替代synchronized，只有在synchronized无法满足需求时，才应该使用它。 读-写锁运行多个读线程并发地访问被保护的对象，当访问以读取操作为主的数据结构时，它能提高程序的可伸缩性。 参考 《Java并发编程实战》]]></content>
      <categories>
        <category>Java并发编程实战</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发_9_性能和可伸缩性]]></title>
    <url>%2F2018%2F01%2F24%2FJava%E5%B9%B6%E5%8F%91-9-%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[引：线程最主要的目的是提高程序的运行性能，虽然我们希望获得更好的性能，但始终要把安全性放在第一位。首先要保证程序的正常运行，然后仅当程序的性能需求和测试结果要求程序执行得更快时，才应该设法提高它的运行速度 性能和可伸缩性提升性能意味着用更少的资源做更多的事。这些资源包括CPU时钟周期、内存、网络带宽、I/O带宽、数据库请求、磁盘空间以及其他资源。 尽管就是用多个线程的目标是提升整体性能，但与单线程相比，使用多个线程会引入一些额外的开销。造成这些开销的操作包括：线程之间的协调（例如加锁、触发信号以及内存同步等），增加上下文切换，线程的创建和销毁、以及线程的调度等。 为了通过并发获得更好的性能，需要： 更有效地利用现有处理资源 在出现新的处理资源时使程序尽可能地利用这些新资源 从性能监视角度来看，CPU需要尽可能保持忙绿状态 应用程序性能的衡量指标 服务时间、等待时间用于衡量程序的“运行速度”，即某个指定的任务单元需要“多快”才能处理完成。 生产量、吞吐量用于衡量程序的“处理能力”，即在给定计算机资源的情况下，能完成“多少”工作。 性能的提高就是使应用程序，1）对任务单元的处理速度更快，2）资源一定的情况下，完成更多的工作 可伸缩性定义当增加计算资源时（例如CPU、内存、存储容量或I/O带宽），程序的吞吐量或者处理能力能相应地增加。 评估各种性能权衡因素服务器应用程序的指标是可伸缩性、吞吐量和生成量；交互式应用程序指标是多快。 避免不成熟的优化（由于需求不明确），首先使程序正确，然后再提高运行速度——如果它还运行得不够快。 Amdahl定律Amdahl定律： 在增加计算资源的情况下，程序在理论上能够实现最高加速比，这个值取决于可并行组件与串行组件所占的比重。假定F是必须被串行执行的部分，那么根据Amdahl定律，在包含N个处理器的机器中，最高的加速比为：1Speedup &lt;= 1 / ( F + (1-F) / N ) 当N趋近于无穷大时，最大的加速比趋近于1/F。因此，如果程序有50%的计算需要串行执行，那么最高的加速比只能是2（而不管有多少个线程可用） 注意：在所有并发程序中都包含一些串行部分。 我们评估一个算法时，要考虑算法在数百个或数千个处理器的情况下的性能表现，从而对可能出现的可伸缩性局限有一定程度的认识。 线程引入的开销在多个线程的调度和协调过程中都需要一定的性能开销：对于为了提升性能而引入的线程来说，并行带来的性能提升必须超过并发导致的开销。 上下文切换如果可运行的线程数大于CPU数量，那么操作系统最终会将某个运行的线程调度出来，从而使其他线程能够使用CPU，这将导致一次上下文切换，在这个过程中将保存当前运行线程的执行上下文，并将新调度进来的线程的执行上下文设置为当前上下文。 当线程由于等待某个发生竞争的锁而被阻塞时，JVM通常会将这个线程挂起，并允许它被交换出去。如果线程频繁地发生阻塞，那么他们将无法使用完整的调度时间片。在程序中发生越多的阻塞，CPU密集型的程序就会发生越多的上下文切换，从而增加调度开销，并因此而降低吞吐量。 内存同步同步操作的性能开销包括多个方面。在synchronized和volatile提供的可见性保证中可能会使用一些特殊的指令，即内存栅栏。内存栅栏可以刷新缓存，使缓存无效，刷新硬件的写缓冲，以及停止执行管道。内存栅栏可能同样会对性能带来间接地影响，应为它会抑制一些编译器的优化。在内存栅栏中，大多数操作是不能被重排序的。 不要过度担心非竞争同步带来的开销。这个基本的机制已经非常快了，并且JVM还能进行额外的优化以进一步降低或开销。因此，我们应该将优化的重点放在那些发生锁竞争的地方。 阻塞当在锁上发生竞争时，竞争失败的线程肯定会阻塞，JVM在实现阻塞行为时，可以采用自旋等待（指通过循环不断尝试获取锁，直到成功）或者通过操作系统挂起被阻塞的线程。这两种方式的效率高低，要取决于上下文切换的开销以及在成功获取锁之前需要等待的时间。 等待时间较短：适合采用自旋等待方式 等待时间较长：适合采用线程挂起方式 减小锁的竞争串行操作会降低可伸缩性，并且上下文切换也会降低性能。在锁上发生竞争时将同时导致这两种问题，因此减少锁竞争会提高性能和可伸缩性。 在并发程序中，对可伸缩性的最主要威胁就是独占方式的资源锁。 有两个因素将影响在锁上发生竞争的可能性： 锁的请求频率 每次持有锁的时间 如果两者的乘积很小，那么大多数获取锁的操作都不会发生竞争。 有三种方式可以降低锁的竞争程度： 减少锁的持有时间 降低锁的请求频率 使用带有协调机制的独占锁，这些机制允许更高的并发性 缩小锁的范围（“快进快出”）其实质是减少锁的持有时间。，同时根据Amdahl定律，这样消除了限制可伸缩性的一个因素，因为串行代码的总量减少了。 注意： 在实际情况中，仅当可以将一些“大量”的计算或阻塞操作从同步代码块移出时，才应该考虑同步代码块的大小。 减小锁的粒度另一种减小锁的持有时间的方式是降低线程请求的频率（从而减小发生竞争的可能性）。这可以通过锁分解和锁分段等技术来实现。 锁分解如果一个需要保护多个相互独立的状态变量，那么可以将这个锁分解为多个锁，并且每个锁只保护一个变量，从而提高可伸缩性，并最终降低每个锁的请求频率。看到下面的代码变化：123456789// 原代码：通过内置锁保护了users和queries两个状态变量public class ServerStatus &#123; public final Set&lt;String&gt; users; public final Set&lt;String&gt; queries; public synchronized void addUser(String u) &#123; users.add(u); &#125; public synchronized void addQuery(String q) &#123; queries.add(q); &#125;&#125; 123456789101112131415161718// 修改代码：通过锁分解分开保护了users和queries两个状态变量public class ServerStatus &#123; public final Set&lt;String&gt; users; public final Set&lt;String&gt; queries; public void addUser(String u) &#123; synchronized (users) &#123; users.add(u); &#125; &#125; public void addQuery(String q) &#123; synchronized (queries) &#123; queries.add(q); &#125; &#125;&#125; 对竞争适中的锁进行分解时，实际上是把这些转变为非竞争的锁，从而有效地提高性能和可伸缩性。 锁分段由于在一个拥有多个处理器的系统中，锁分解仍然无法给可伸缩性带来极大的提高，这个时候就出来锁分段技术。 锁分段： 将锁分解技术进一步扩展为对一组对象上的锁进行分解。 例子：在ConcurentHashMap的实现中使用了一个包含16个锁的数组，每个锁保护所有散列桶的1/16，其中第N个散列桶有第（N mod 16）个锁来保护。正是这项技术使得CouncurentHashMap能够支持多达16个并发的写入器。 锁分段的劣势：与采用单个锁来实现独占访问相比，要获得多个锁来实现独占访问将更困难整个容器，例如当ConcurrentHashMap需要扩展映射范围等。 避免热点域如果将一些反复计算的结果缓存起来，那么将会引入一些“热点域”。而这些热点域往往会限制可伸缩性。 例子：参考ConcurrentHashMap里边将热点域size分成多个值，当我们需要获取全局size的时候，就临时把这些值加起来就是，虽然可能得不到一个准确的值，但大大提高了并发性，是划算的。 一些代替独占锁的方法放弃使用独占锁，从而有助于使用一种友好并发的方式来管理共享状态。例如，使用并发容器、读-写锁、不可变对象以及原子变量。 监测CPU的利用率当测试可伸缩性时，通常要确保处理器得到充分利用。 如果CPU没有得到充分利用，那么需要找出其中的原因（vmstat,mpstat查询CPU使用情况）。可能的原因如下： 负载不充足。可以在测试时增加负载，并检查利用率，响应时间和服务时间等指标的变化。如果产生足够多的负载使应用程序达到饱和，那么可能需要大量的计算机能耗，并且问题可能在于客户端系统是否具有足够的能力，而不是被测试系统。 IO密集。可以通过iostat或者perfmon来判断某个应用程序是否是磁盘I/O密集型的，或者通过监测应用的通信流量来判断它是否需要高带宽。 外部限制。如果应用程序依赖于外部服务，比如数据库或web服务，那么性能瓶颈可能并不在你自己的代码中。 锁竞争。使用分析工具可以知道在程序中存在何种程度的锁竞争。比如进行线程栈帧转储，来观察是不是有“waiting to lock monitor”之类的关键字。 在CPU保持忙碌状态之后，我们试试增加CPU的数量，比如从4核换到8核，看是否能增加处理能力，如此就可以得出结论：增加CPU可以提高程序的处理能力，类似的其它资源验证过程也是类似的。 向对象池说“不”早期垃圾回收机制很慢，效率很低，很多程序通过对象池来降低垃圾回收的压力。但现在的垃圾回收机制已经很快了。在并发程序中，对象池的表现更加糟糕。 减小上下文切换的开销传统网络模式下，同步阻塞IO将导致上下文切换，同时，一个连接一个线程将导致更多的上下文切换，改进方法如下： 将阻塞IO操作从处理请求的线程分离出来，放到专门的线程中去处理。 使用nio，多路复用机制，实现可以由有限线程池来处理所有的连接请求。 总结由于使用线程通常是为了充分利用多个处理器的计算能力，因此在并发程序性能的套路那种，通常更多地将重点放在吞吐量和可伸缩性上，而不是服务时间。Amdahl定律告诉我们，程序的可伸缩性取决于在所有代码中必须被串行化执行的代码比例。因为Java程序中串行操作的主要来源是独占方式的资源锁，因此通常可以通过以下方式来提高可伸缩性：减少锁的持有时间，降低锁的粒度，以及采用非独占的锁或非阻塞锁来代替独占锁。 参考 《Java并发编程实战》 并发编程实战学习笔记（八）——性能与可伸缩性]]></content>
      <categories>
        <category>Java并发编程实战</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发_8_避免活跃性危险]]></title>
    <url>%2F2018%2F01%2F22%2FJava%E5%B9%B6%E5%8F%91-8-%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9%2F</url>
    <content type="text"><![CDATA[引：在安全性和活跃性之间通常存在着某些制衡。我们使用加锁机制来确保线程安全，但如果过度地使用加锁，则可能导致顺序死锁。同样，我们使用线程池和信号量来限制对资源的使用，但这些被限制的行为可能会导致资源死锁。Java应用程序无法从死锁中恢复过来，因此在设计时一定要排除那些可能导致死锁出现的条件。 死锁最简单的死锁：当线程A持有锁L并想获得锁M的同时，线程B持有锁M并尝试获得锁L，那么这两个线程将永远等待下去。 数据库解决死锁问题： 当它检测到一组事务发生了死锁时（通过在表示等待关系的有向图中搜索循环），将选择一个牺牲者并放弃这个事务。作为牺牲者的事务会释放它所持有的资源，从而使其他事务继续进行。应用程序可以重新执行被强制终止的事务，而这个事务现在可以成功完成，因为所有跟它竞争资源的事务都已经完成了。 JVM解决死锁问题：当一组Java线程发生死锁时，“游戏”将到此结束——这些线程永远不能使用了。 锁顺序死锁示例代码如下：12345678910111213141516171819202122// 注意：容易发生死锁！public class LeftRightDeadLock &#123; private final Object left = new Object(); private final Object right = new Object(); public void leftRight() &#123; synchronized (left) &#123; synchronized (right) &#123; doSomething(); &#125; &#125; &#125; public void rightLeft() &#123; synchronized (right) &#123; synchronized (left) &#123; doSomething(); &#125; &#125; &#125;&#125; 解决方法： 如果所有线程以固定的顺序来获得锁，那么在程序中就不会出现锁顺序死锁问题。 动态死锁问题示例代码如下：123456789101112131415// 注意：容易发生死锁！public void transferMoney(Account fromAccount, Account toAccount, DollarAmount amount) throws InsufficientFundsException&#123; synchronized (fromAccount) &#123; synchronized (fromAccount) &#123; if (fromAccount.getBalance().compareTo(amount)) &#123; throw new InsufficientFundsException(); &#125; else &#123; fromAccount.debit(amount); toAccount.credit(amount); &#125; &#125; &#125;&#125; 解决方法： 通过一致哈希算法或者其它方式来统一锁顺序，使未知顺序变为已知顺序。对于极少数的哈希冲突，可以使用“加时赛”锁来解决。解决代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142private static final Object tieLock = new Object();public void transferMoney(final Account fromAcct, final Account toAcct, final DollarAmount amount) throws InsufficientFundsException&#123; class Helper&#123; public void transfer throws InsufficientFundsException&#123; if(fromAcct.getBalance().compareTo(amount) &lt; 0)&#123; throw new InsufficientFundsException(); &#125;else&#123; fromAcct.debit(amount); toAcct.credit(amount); &#125; &#125; &#125; int fromHash = System.identifyHashCode(fromAcct); int toHash = System.identityHashCode(toAcct); if(fromHash &lt; toHash)&#123; synchronized(fromAcct)&#123; synchronized(toAcct)&#123; new Helper.transfer(); &#125; &#125; &#125;else if (fromHash &gt; toHash) &#123; synchronized(toAcct)&#123; synchronized(fromAcct)&#123; new Helper().transfer(); &#125; &#125; &#125; else &#123; synchronized(tieLock)&#123;//加时赛锁来解决问题 synchronized(fromAcct)&#123; synchronized(toAcct)&#123; new Helper().transfer(); &#125; &#125; &#125; &#125;&#125; 在协作对象之间发生的死锁示例代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 注意：同步方法获得的是对象锁class Taxi &#123; @GuardedBy("this") private Point location, destination; private final Dispatcher dispatcher; public Taxi(Dispatcher dispatcher) &#123; this.dispatcher = dispatcher; &#125; public synchronized Point getLocation() &#123; return location; &#125; public synchronized void setLocation(Point location) &#123; this.location = location; if (location.equals(destination)) dispatcher.notifyAvailable(this); &#125; public synchronized Point getDestination() &#123; return destination; &#125; public synchronized void setDestination(Point destination) &#123; this.destination = destination; &#125;&#125;class Dispatcher &#123; @GuardedBy("this") private final Set&lt;Taxi&gt; taxis; @GuardedBy("this") private final Set&lt;Taxi&gt; availableTaxis; public Dispatcher() &#123; taxis = new HashSet&lt;Taxi&gt;(); availableTaxis = new HashSet&lt;Taxi&gt;(); &#125; public synchronized void notifyAvailable(Taxi taxi) &#123; availableTaxis.add(taxi); &#125; public synchronized Image getImage() &#123; Image image = new Image(); for (Taxi t : taxis) image.drawMarker(t.getLocation()); return image; &#125;&#125; 尽管没有任何方法会显式地获得两个锁，但是setLocation和getImage等方法的调用者都会获得两个锁，所以有可能造成死锁。 注意： 如果在持有锁的情况下调用某个外部方法时，那么就需要警惕死锁。 开放调用开放调用： 如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用。 通过开放调用解决在协作对象之间发生的死锁，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940class Taxi &#123; @GuardedBy("this") private Point location, destination; private final Dispatcher dispatcher; ... public synchronized Point getLocation() &#123; return location; &#125; public void setLocation(Point location) &#123; boolean reachedDestination; synchronized (this) &#123; this.location = location; reachedDestination = location.equals(destination); &#125; if (reachedDestination) dispatcher.notifyAvailable(this); &#125;&#125;class Dispatcher &#123; @GuardedBy("this") private final Set&lt;Taxi&gt; taxis; @GuardedBy("this") private final Set&lt;Taxi&gt; availableTaxis; ... public synchronized void notifyAvailable(Taxi taxi) &#123; availableTaxis.add(taxi); &#125; public synchronized Image getImage() &#123; Set&lt;Taxi&gt; copy; sychronized (this) &#123; copy = new HashSet&lt;Taxi&gt;(taxis); &#125; Image image = new Image(); for (Taxi t : copy) image.drawMarker(t.getLocation()); return image; &#125;&#125; 解决的方法思路就是：缩小锁的粒度。 缺点：可能丢失操作原子性，此时需要通过协议来实现原子性，而不是通过加锁。 资源死锁独占类型的访问都可以和加锁操作类比，看起来就像需要获得锁才能访问。 如果一个任务需要连接两个数据库，并且在请求这两个资源时不会始终遵循相同的顺序，那么线程A可能持有与数据库D1的连接，并等待与数据库D2的连接，而线程B持有D2的连接并等待与D1的连接。资源池越大，就越不容易出现这种类型的死锁。 线程饥饿死锁。如果某些任务需要等待其它任务的结果，那么这些任务往往是产生线程饥饿死锁的主要来源，有界线程池/资源池与相互依赖的任务不能一起使用。 死锁的避免与诊断如果必须获取多个锁，那么在设计时必须考虑锁的顺序：尽量减少潜在的加锁交互数量，将获取锁时需要遵循的协议写入正式文档并始终遵循这些协议。 在细粒度锁的程序中，可以通过一种两阶段策略来检查代码中的死锁：首先，找出在什么地方将获取多个锁（使这个集合尽量小），然后对所有这些实例进行全局分析，从而确保他们在整个程序中获取锁的顺序保持一致。尽可能使用开发调用。 支持定时的锁当定时锁失败时，你并不需要知道失败的原因。至少你能记录所发生的失败，以及关于这次操作的其它有用信息，并通过一种更平缓的方式来重新启动计算，而不是关闭整个进程。 如果在获取锁时超时，那么可以释放这个锁，然后后退并在一段时间后并再次尝试，从而消除了死锁发生的条件，使程序恢复过来。（这项技术只有在同时获取两个锁时才有效，如果在嵌套的方法调用中请求多个锁，那么即使你知道已经持有了外层的锁，也无法释放它。） 通过线程转储信息来分析死锁JVM会通过线程转储来帮助是被死锁的发生。在生成线程转储信息之前，JVM将在等待关系图中通过搜索循环来找出死锁。如果发现了一个死锁，则获取相应的死锁信息，理由在死锁中涉及哪些锁和线程，以及这个锁的获取操作位于程序的哪些位置。 其他活跃危险饥饿当线程由于无法访问它所需要的资源而不能继续执行时，就发生了“饥饿”，引发饥饿的最常见资源就是CPU时钟周期。 要避免使用线程优先级，因为这会增加平台依赖性，并可能导致活跃性问题，在大多数并发应用程序中，都可以使用默认的线程优先级。 活锁活锁是另一种形式的活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复执行相同的操作，而且总会失败。 活锁通常发生在处理事务消息的应用程序中：如果不能成功地处理某个消息，那么消息处理机制将会回滚整个事务，并将它重新放到队列的开头。如果消息处理器在处理某种特定类型的消息时存在错误并导致它失败，那么会出一直存在“处理-出错-回滚-处理”的循环中。 解决方法：在重试机制中引用随机性。 总结活跃性故障是一个非常严重的问题，因为当出现活跃性故障时，除了中止应用程序之外没有其他任何机制可以帮助从这种故障恢复过来。最常见的活跃性故障是锁顺序死锁。在设计时应该避免锁顺序死锁：确保线程在获取多个锁采用一致的顺序。最好的解决方法是在程序中始终使用开放调用。这将大大减少需要同时持有多个锁的地方，也更容易发现这些地方。 参考 《Java并发编程实战》]]></content>
      <categories>
        <category>Java并发编程实战</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发_7_线程池的使用]]></title>
    <url>%2F2018%2F01%2F22%2FJava%E5%B9%B6%E5%8F%91-7-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[引：之前介绍了Executor任务执行框架的使用，它不仅简化了任务与线程的生命周期管理，而且还提供了一种简单灵活的方式将任务的提交和任务的执行策略解耦开来。但是深入下去，我们需要对线程池进行配置和调优，并且分析再使用任务执行框架时需要注意的各种危险。 在任务与执行策略之间的隐性耦合不是所有任务都能适用所有的执行策略的，有些类型的任务需要明确地指定执行策略，包括： 依赖性任务：提交给线程池的任务需要依赖其他的任务，我们需要避免线程饥饿死锁。 使用线程封闭机制的任务：任务要求其执行策略所在的Executor是单线程的。 对响应时间敏感的任务：GUI应用程序对于响应时间是敏感的。 使用ThreadLocal的任务：Executor会重用线程，所偶一使用ThreadLocal会没有意义。 只有当任务都是同类型的并且是相互独立时，线程池的性能才能达到最佳。 在一些任务中，需要拥有或排除某种特定的执行策略。如果某些任务依赖于其他的任务，那么会要求线程池足够大，从而确保他们依赖任务不会被放入等待队列中或被拒绝，而采用线程封闭机制的任务需要串行执行。 线程饥饿死锁在线程池中，如果任务依赖于其他任务，那么可能产生死锁。在单线程的Executor中，如果一个任务将另一个任务提交到同一个Executor，并且等待这个被提交任务的结果，那么通常会引发死锁。第二个任务停留在工作队列中，等待第一个任务完成，而第一个任务又无法完成，因为它在等待第二个任务的完成。在更大的线程池中，如果所有正在执行任务的线程都由于等待其他仍处于工作队列中的任务而阻塞，也会发生同样的问题。这种现象叫做线程饥饿死锁（Thread Starvation Deadlock），只要线程池中的任务需要无限期等待一些必须由池中其他任务才能提供的资源或条件，例如某个任务等待另一个任务的返回值或执行结果，那么除非线程池足够大，否则将发生线程饥饿死锁。 每当提交了一个有依赖性的Executor任务时，要清楚地知道可能会出现线程饥饿死锁，因此需要在代码或配置Executor的配置文件中记录线程池的大小限制或配置限制。 运行时间较长的任务如果任务阻塞时间过长，那么即使不出现死锁，线程池的响应性也会变得糟糕。执行时间较长的任务不仅会造成线程池堵塞，甚至会增加执行时间较短任务的服务时间。如果线程池中的数量远小于在稳定状态下执行时间较长任务的数量，那么到最后可能所有线程都会运行这些执行时间较长的任务，从而影响整体的响应性。 缓解这个问题的技术就是限定等待资源的时间，而不是无限制等待。例如Thraed.join(),BlockingQueue.put()、CountDownLatch.await()等，如果等待超时，可以把任务标识为失败，然后终止任务或将任务重新放回队列以便随后执行。 设置线程池的大小线程池的理想大小取决于被提交任务的类型以及所部署系统的特性。 只要避免过大和过小两种极端情况，如果线程池过大，那么大量的线程将在相对很少的CPU和内存资源上发生竞争，这不仅会导致更高的内存使用量，而且还可能耗尽资源。如果线程池过小，那么导致许多空闲的处理器无法执行工作，从而降低吞吐率。 要想正确设置线程池的大小，必须分析计算环境、资源预算和任务的特性。 对于计算密集型的任务，在拥有N个处理器的系统上，当线程池的大小为N + 1时，通常能实现最优的利用率。 对于包含I/O操作或者其他阻塞操作的任务，由于线程并不会一直执行，因此线程池的规模应该更大。要正确地设置线程池的大小，必须估算出任务的等待时间与计算时间的比值。有个公式：1234N = CPU的数量 = Runtime.getRuntime().availableProcessors();U = 预期CPU利用率W/C = 等待时间,计算时间之比（wait time / compute time）线程池的最优大小 = N * U * （1 + W/C） 配置ThreadPoolExecutor如果newCachedThreadPool、newFixedTheadPool和newScheduledTheadPool等工厂方法返回的ThreadPoolExecutor无法满足需求，可以通过ThreadPoolExecutor的构造函数来实例化一个对象，并根据自己需求来定制。构造函数如下：1234567public ThreadPoolExecutor(int corePoolSize, //线程池的基本大小 int maximumPoolSize, //最大大小 long keepAliveTime, //存活时间 TimeUnit unit, //时间单位 BlockingQueue&lt;Runnable&gt; workQueue, //工作队列 ThreadFactory threadFactory, //线程工厂 RejectedExecutionHandler handler) &#123;...&#125; 线程的创建与销毁通过调节线程池的基本大小和存活时间，可以帮助线程池回收空闲线程占有的资源，从而使得这些资源可以用于执行其他工作。 管理队列任务如果新请求的到达速率超过了线程池的处理速率，那么新到来的请求将会在一个由Executor管理的Runnable队列中等待，而不会像线程那样去竞争CPU资源。 ThreadPoolExecutor允许提供一个BlockingQueue来保存等待执行的任务。基本的任务排队方法有3种：无界队列、有界队列和同步移交。 一种更稳妥的资源管理策略时使用有界队列，例如ArrayBlockingQueue、有界LinkedBlockingQueue、PriorityBlockingQueue。有界队列有助于避免资源耗尽的情况发生，但又带来新的问题：当队列满后，新的任务怎么办？在使用有界的工作队列时，队列的大小和线程池的大小必须一起调节，如果线程池较小而队列较大，那么有助于减少内存使用量，降低CPU使用率，同时减少上下文切换，但代价是限制了吞吐量。 对于非常大的或者无界的线程池，可以使用SynchronousQueue来避免任务排队，它可以直接将任务从生产者移交给工作者线程。SynchronousQueue并不是一个真正的队列，而是一种在线程之间进行移交的机制。要将一个元素放入SynchronousQueue中，必须由另一个线程正在等待接受这个元素。如果没有线程正在等待，并且线程池的当前大小小于最大值，那么ThreadPoolExecutor会创建一个新的线程来处理这个任务。否则，根据饱和策略，这个任务将被拒绝。直接使用移交将更高效，因为任务直接移交给执行它的线程，而不是先放到队列，然后再由工作线程从队列中提取任务。只有当线程池是无界的或者可以拒绝任务时，SynchronousQueue才有实际价值。在newCachedThreadPool中就是使用了SynchronousQueue。 当使用像LinkedBlockingQueue或ArrayBlockingQueue这样FIFO队列时，任务的执行顺序与它们的到达顺序相同。如果想进一步控制任务执行顺序，还可以使用PriorityBlockingQueue，这个队列根据优先级来安排任务，任务的优先级是通过自然顺序或者Comparator来定义的。 只有当任务相互独立时，为线程池或工作队列设置界限才是合理的 。如果任务之间有依赖性，那么有界的线程池或队列会导致线程饥饿死锁问题，此时应该使用无界的线程池，如newCachedThreadPool。 对于Executor，newCachedThreadPool工厂方法是一种很好的默认选择，他能提供比固定大小的线程池更好的排队性能。当需要限制当前任务的数量以满足资源管理需要求时，可以选择固定大小的线程池。 饱和策略当有界队列被填满后，饱和策略开始发挥作用，ThreadPoolExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改。 当工作队列被填满后，没有预定义的饱和策略来阻塞ececute。通过使用Semaphore（信号量）来限制任务的到达率可以实现饱和策略的功能。 线程工厂每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的。在TheadFactory中只定义了一个方法newThread，每当线程池需要创建一个新线程时都会调用这个方法。 在调用构造函数后再定制ThreadPoolExecutor在调用完ThreadPoolExecutor的构造函数后，仍然可以通过设置函数来修改大多数传递给他的构造函数的参数，如果Executor是通过Executors中的某个工厂方法创建的，那么可以通过将结果的类型转换为ThreadPoolExecutor以访问设置器。 扩展ThreadPoolExecutorThreadPoolExecutor是可扩展的，它提供了几个可以在子类化中改写的方法：beforeExcute，afterExecute和terminated，这些方法可以用于扩展ThreadPoolExecutor的行为。 在这里方法中可以添加日志、计时、监视或统计信息收集功能。 总结对于并发执行的任务，Executor框架是一种强大且灵活的框架。它提供了大量可调节的选项。我们要根据实际情况对这些参数进行调节。 参考 《Java并发编程实战》]]></content>
      <categories>
        <category>Java并发编程实战</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发_6_取消与关闭]]></title>
    <url>%2F2018%2F01%2F22%2FJava%E5%B9%B6%E5%8F%91-6-%E5%8F%96%E6%B6%88%E4%B8%8E%E5%85%B3%E9%97%AD%2F</url>
    <content type="text"><![CDATA[引：任务和线程的启动很容易，在大多数时候，我们都会让他们运行直到结束，然而，有时候我们希望提前结束任务或线程，但是Java没有提供任何机制来安全地终止线程，只是提供了中断，这是一种协作机制，能够使一个线程终止另一个线程的工作。所以需要我们能很完善地处理失败、关闭和取消等过程。 任务取消如果外部代码能在某个操作正常完成之前将其置入“完成”状态，那么这个操作就可以称为可取消的。取消这个操作的原因有很多： 用户请求取消。用户点击图形界面程序的“取消”按钮。 有时间限制的操作。某个程序需要在有限时间内完成搜索任务，当超时时，需要取消搜索任务。 错误。当一个爬虫程序发生错误时，那么搜索任务都会取消。 关闭。在立即关闭的过程中，当前的任务则可能被取消。 在Java中没有一种安全的抢占式方法来停止线程，因此也就没有安全的抢占式方法来停止任务，只有一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。 其中一种协作机制能设置某个“已请求取消”标志，而任务将定期地查看该标志。如果设置了这个标志，那么任务将提前结束。代码如下:12345678910111213141516public class Task implement Runnable &#123; // 为了使这个过程能可靠得工作，标志cancelled必须为volatile类型 private volatile boolean cancelled; public void run() &#123; while(!cancelled) &#123; &#125; &#125; public void cancel() &#123; cancelled = true; &#125;&#125; 中断如果在上面代码中while里面出现了一个阻塞的方法，那么在调用cancel方法来设置cancelled状态，当却检查不到标志，因为它无法从阻塞的方法恢复过来。如下面的代码：123456789101112131415161718192021222324public class BrokenPrimeProducer extends Thread &#123; private final BlockingQueue&lt;BigInteger&gt; queue; private volatile boolean cancelled = false; BrokenPrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123; this.queue = queue; &#125; public void run() &#123; try &#123; BigInteger p = BigInteger.ONE; while (!cancelled) &#123; // 如果生产者的速度超过消费者的处理速度，队列将被填满，put方法会被阻塞 queue.put(p = p.nextProbablePrime()); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void cancel() &#123; cancelled = true; &#125;&#125; 所以我们会想到一些线程中断这种协作机制，它利用了特殊的阻塞库用来是实现任务取消，注意：如果在取消之外的其他操作中使用中断，都是不合适的，并且很难支撑起更大的应用。下面是Thread的中断方法:123456789101112// 每个线程都有一个boolean类型的中断状态，当中断线程时，这个线程的中断状态将被设置为truepublic class Thread &#123; // 中断目标线程 public void interrupt() &#123;&#125; // 清除当前线程的中断状态 public static boolean interrupted() &#123;&#125; // 返回目标线程的中断状态 public boolean isInterrupted() &#123;&#125;&#125; 阻塞库的方法，如Thread.sleep和Object.wait等都会检查线程何时中断，并且在发生中断时返回。响应中断执行的操作包括：清除中断状态，抛出InterruptedException。JVM不保证阻塞方法检测到中断的速度，但通常响应速度还是非常快的。 注意：调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。然后由线程在下一个合适的时刻中断自己（这些时刻也被称为取消点）。有些方法，例如wait、sleep和join等，将严格处理这种请求，当他们收到中断请求或者在开始执行时发现某个已被设置好的中断状态，将抛出一个异常。示例如下：1234567891011121314151617181920212223public class BrokenPrimeProducer extends Thread &#123; private final BlockingQueue&lt;BigInteger&gt; queue; BrokenPrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123; this.queue = queue; &#125; public void run() &#123; try &#123; BigInteger p = BigInteger.ONE; // 在阻塞的put方法调用中以及在循环开始处查询中断状态时，都会检查中断标志 while (!Thread.currentThread().isInterrupted()) &#123; queue.put(p = p.nextProbablePrime()); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void cancel() &#123; interrupt(); &#125;&#125; 中断策略最合理的中断策略是某种形式的线程级取消操作或者服务级取消操作：尽快退出，在必要时清理，通知某个所有者该线程已经退出。此外还可以建立其他的中断策略，例如暂停服务或重新开始服务。 任务不应该对执行该任务的线程的中断策略做出假设。无论任务把中断视为取消，还是其他某个中断响应操作，都应该小心的保存线程的中断状态，如果除了将InterruptException传递给调用者外还需要执行其他操作，那么应该在捕获InterruptException之后恢复中断状态。 线程只能由其所有者中断，所有者可以将线程的中断策略信息封装到某个合适的取消机制中，例如关闭方法中。 响应中断在调用可中断的阻塞函数时，有两种实用策略可用于处理InterruptException： 传递异常：从而使你的方法也称为了可中断的阻塞方法。 恢复中断状态：从而使调用栈中的上层代码能够对其进行处理。 只有是实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求。 通过Future来实现取消使用ExecuorService.submit方法将返回一个Future来描述任务，Future有一个cancel方法。cancle方法有一个参数mayInterruptIfRunning,如果设置为true，那么就表示取消操作是否成功（这只是表示任务是否能够接受中断，而不是表示任务是否能够检测并处理中断）。如果为false，表示如果任务还没有运行，那么就不要运行它。代码如下：12345678910111213141516171819public class TimedRun &#123; private static final ExecutorService taskExec = Executors.newCachedThreadPool(); public static void timedRun(Runnable r,long timeout, TimeUnit unit) throws InterruptedException &#123; Future&lt;?&gt; task = taskExec.submit(r); try &#123; task.get(timeout, unit); &#125; catch (TimeoutException e) &#123; // 接下来任务将被取消 &#125; catch (ExecutionException e) &#123; // 如果在任务执行和中抛出了异常，那么重新抛出该异常 throw launderThrowable(e.getCause()); &#125; finally &#123; //如果任务已经结束，那么执行取消操作也不会带来任何影响 task.cancel(true); // 如果任务正在运行，那么将被中断 &#125; &#125; &#125; 处理不可中断的阻塞在java库中，很多阻塞的方法都是通过提前返回或者是抛出InterruptedException来响应中断请求的，然而并非所有的可阻塞方法或者阻塞机制都能响应中断。 比如一个线程由于执行同步的Socket IO 或者等待获得内置锁而阻塞，那么中断请求只能设置线程的中断状态，除此之外没有其他任何作用，对于那些执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，但这要求我们必须知道线程阻塞的原因，然后通过重写非标准的取消操作。 停止基础线程的服务应用程序通常会创建多个线程的服务，例如线程池。正确地封装原则是：除非拥有某个线程，否则不能对该线程进行操控，线程池是其工作线程的所有者，如果要中断这些线程，那么应该使用线程池。线程的所有权是不可以传递的：应用程序可以拥有服务，服务可以拥有工作者线程，但应用程序并不能拥有工作者线程，因此应用程序不能直接停止工作者线程。相反，服务应用提供生命周期方法来关闭它自己以及它所拥有的线程，在ExecutorService中提供了shutdown和shutdownNow方法。 例子：日志服务 方式：通过调用log方法将日志消息放入某个队列中，并由其他线程来处理； 停止该服务的方式：通过原子方式来检查关闭请求，并且有条件地递增一个计数器来保存提交信息的权利； 关闭ExecutorService Service封装在某个更高级别的服务中，并且该服务能提供其自己的生命周期方法。 毒丸对象 毒丸是指一个放在队列上的对象，其含义是：当得到这个对象时，立即停止； 限制：只有在生产者和消费者的数量都已知的情况下，才可以使用“毒丸”对象； 当生产者和消费者数目较大时，这种方法变得难以使用。 例子：只执行一次的服务 场景：某个方法需要处理一批任务，并且当所有任务都处理完后才返回，可以通过一个私有的Executor来简化服务的生命周期管理，其中该Executor的生命周期是由这个方法控制的 shutdownNow的局限性 当通过shutdownNow来强行关闭ExecutorService时，尝试取消正在执行的任务，并返回所有已经提交但未开始的任务。但无法在关闭过程中知道正在执行的任务的状态。除非任务本身会执行某种检查。 处理非正常的线程终止在并发程序中,是无法做到一直观察控制台的, 例如:你的web应用部署到服务器上,难道你要派个人一直去观察控制台? 任何代码都可能抛出一个RuntimeExecption,每当调用另一个方法时,都要对它的行为保持怀疑,不要盲目地认为它一定会抛出在方法原型中声明的某个已检查异常。对调用的代码越不熟悉,就越应该对其代码行为保持怀疑。 典型的线程池工作者线程结构代码如下：123456789101112public void run()&#123; Throwable throw = null; try&#123; while(!isInterrupted)&#123; runTask(getTaskFromWorkQueue()); &#125; &#125; catch (Throwable e)&#123; thrown = e; &#125; finally&#123; threadExited(this,thrown); &#125;&#125; 如果任务抛出了一个未检查的异常,那么它将使线程终结,但会首先通知框架该线程已经终结.然后,框架可能会用新的线程来代替这个工作线程。 将异常写入日志的UncaughtExecptionHandler代码如下：123456public class Thread.UncaughtExecptionHandler&#123; public void uncaughtException(Thread t,Throwable e)&#123; Logger logger = Logger.getAnonymousLogger(); Logger.log(Level.SEVERE,"Thread terminated with exception: "+ t.getName(),e); &#125;&#125; 在运行时间较长的应用程序中,通常会为所有线程的未捕获异常指定同一个异常处理器,并且该异常处理器至少会将异常信息记录到日志中。 JVM关闭JVM既可以正常关闭，也可以强行关闭。正常关闭的触发方式有多种，包括：当最后一个“正常（非守护）”线程结束时，或者调用了System.exit时，或者通过其他特定于平台的方法关闭时（例如发送了SIGINT信号或Ctrl-C）。虽然可以通过这些标准方法来正常关闭JVM，但也可以通过调用Runtime.halt或者在操作系统中“杀死”JVM进程来强行关闭JVM。 关闭钩子在正常关闭中，JVM首先调用所有已注册的关闭钩子，关闭钩子是指通过Runtime.addShutdownHook注册的但尚未开始的线程。JVM不能保证关闭钩子的调用顺序。在关闭应用程序线程时,如果有线程仍然在运行,那么这些线程接下来将与关闭进程并发执行. 关闭钩子应该是线程安全:它们在访问共享数据时,必须使用同步机制,小心避免死锁。 关闭钩子可以用于实现服务或应用程序的清理工作，例如删除临时文件，或者清除无法由操作系统自动清除的资源。 守护线程有时候，你希望创建一个线程来执行一些辅助工作，但又不希望这个线程阻碍了JVM的关闭，这种情况就需要使用守护线程。 线程分为两种: 普通线程和守护线程,在JVM启动时启动创建的所有线程中,除了主线程以外，其他的线程都是守护线程。例如垃圾回收器，当创建一个新的线程时，它将继承创建它的线程的类型。 我们应该尽可能少地使用守护线程–很少有操作能够在不进行清理的情况下被安全地抛弃,特别是在执行I/O操作的任务,那么将是一种非常危险的行为; 并且守护线程不能用来替代应用程序管理程序中各个服务的生命周期 终结器当不再需要内存资源时，可以通过垃圾回收器来回收它们，但对于其他一些资源，例如文件句柄或套接字句柄，当不再需要它们时,必须显式交还给操作系统。为了实现这个功能，垃圾回收器对那些定义了finalize方法的对象会进行特殊处理: 在垃圾回收期释放它们后，调用它们的finalize方法，从而保证一些持久化的资源被释放。 由于终结器可以在某个JVM管理的线程中运行，因此终结器访问任何状态都可能被多个线程访问，这样就必须对其访问操作进行同步。终结器并不能保证它们将在何时甚至是否会运行，并且复杂的终结器带来性能上的巨大开销。编写正确的终结器是非常困难的。在大多数情况下，通过使用finally代码块和显式的close方法能够比终结器更好的管理资源。 避免使用终结器 总结在任务、线程、服务以及应用程序等模块中的生命周期结束问题，可能会增加他们在设计和实现时的复杂性。Java并没有提供某种抢占式的机制来取消操作或者总结线程。相反，它提供了一种协作式的中断机制来实现取消操作，但这要依赖于如何构建取消操作的协议，以及能否始终遵循这些协议。通过使用FutureTask和Executor框架，可以帮助我们构建可取消的任务和服务。 参考 《Java并发编程实战》]]></content>
      <categories>
        <category>Java并发编程实战</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发_5_任务执行]]></title>
    <url>%2F2018%2F01%2F15%2FJava%E5%B9%B6%E5%8F%91-5-%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[引：在大多数并发应用程序都是围绕“任务执行”来构造的：任务通常是一些抽象且离散的工作单元。通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。 在线程中执行任务要使服务器应用程序同时表现出良好的吞吐量和快速的响应性，应该选择清晰的任务边界以及明确的任务执行策略（见后面）。 串行地执行任务最简单的调度任务策略就是在单个线程中串行地执行各项任务。但串行处理机制通常都无法提供高吞吐率或快速响应性。 显示地为任务创建线程通过为每个请求创建一个新的线程来提供服务，从而实现更高的响应性。但为每个任务分配一个线程也存在一些缺陷。 无限创建线程的不足 线程生命周期的开销非常高。线程的创建过程需要时间，这就延迟了请求的处理，并且需要JVM和操作系统提供一些辅助操作。 资源消耗。如果可运行线程数量多于可用处理器的数量，那么有些线程会闲置就会占用许多内存，如果大量线程在竞争CPU还会产生其他的性能消耗。 稳定性。在可创建线程的数量上有一个阈值，这个阈值随着平台不同而不同，并且受多个因素制约，包括JVM的启动参数、Thread构造函数中请求的栈大小，以及底层操作系统对线程的限制等。如果超过这个限制，就很可能有OOM异常。 Executor框架线程池简化了线程的管理工作，并且java.util.concurrent提供了一种灵活的线程池作为Executor框架的一部分。在java类库中，任务执行的不是Thread，而是Executor。其代码如下：123public interface Executor &#123; void execute(Runnable command);&#125; Executor框架提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用Runnable来表示任务。Executor的实现还提供了对生命周期的支持，以及统计信息收集/应用程序管理机制和性能监视等机制。Executor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程相当于消费者。 示例：基于Executor的Web服务器可以看到下面的代码：1234567891011121314151617class TaskExecutorWebServer &#123; private static final int NTHREAD = 100; private static final Executor exe = Executors.newFixedThreadPool(NTHREAD); public static void main(String[] args) &#123; ServerSocket socket = new ServerSocket(80); while(true) &#123; final Socket connection = socket.accept(); Runnable task = new Runnable() &#123; public void run() &#123; handleRequest(connection); &#125; &#125;; exec.execute(task); &#125; &#125;&#125; 在TaskExecutionWebServer中，通过使用Executor，将请求处理任务的提交与任务的实际执行解耦开来，并且只需要采用另一种不同的Executor实现，就可以改变服务器的行为。 将TaskExecutorWebServer改为显示地为任务创建线程：123456// 为每个请求都创建新线程的Executorpublic class ThreadPerTaskExecutor implements Executor &#123; public void execute(Runnable r) &#123; new Thread(r).start(); &#125;&#125; 将TaskExecutorWebServer改为串行地执行任务：123456// 以同步方式执行所有任务的Executorpublic class WithinThreadExecutor implements Executor &#123; public void execute(Runnable r) &#123; r.run(); &#125;&#125; 执行策略各种执行策略都是一种资源管理工具，最佳策略取决于可用的计算资源以及对服务质量的需求。通过限制并发任务的数量，可以确保应用程序不会由于资源耗尽而失败，或者由于在稀缺资源发生竞争而严重影响性能。通过将任务的提交于任务的执行分离开来，有助于在部署阶段选择与可用硬件资源最匹配的执行策略。 每当看到下面形式的代码时，并且希望获得一种更灵活的执行策略时，考虑使用Executor来代替Thread：1new Thread(runnable).start(); 线程池线程池是指管理一组相同工作线程的资源池。线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务。工作线程的任务很简单： 从工作队列中获取一个任务，执行任务，执行完后返回线程池并等待下一个任务。 “在线程池中执行任务”比“为每个任务分配一个线程”优势更多。通过重用现有的线程而不是创建新线程，可以减少在线程创建与销毁的开销。另一个好处是请求到来时，不会再因为要等待线程创建而延迟，也就提高了响应性。通过适当调整线程池的大小，可以创建足够多的线程以便处理器保持忙碌状态，同时还可以防止过多线程互相竞争资源而使应用程序耗尽内存。 类库提供了一个灵活的线程池以及一些有用的默认配置。可以通过调用Executors中的静态工厂方法之一来创建一个线程池： newFixedThreadPool：创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化。（如果某个线程由于发生了未预期的Exception而结束，那么线程池会补充一个新的线程）。 newCachedThreadPool：创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。 newSingleThreadExecutor：是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。它能确保依照任务在队列中的顺序来串行执行。 newScheduledThreadPool：创建了一个固定长度的线程池，而且以延迟或定时的方式执行任务，类似于Timer。 从“为每个任务分配一个线程”策略变为基于线程池的策略，将对应用程序的稳定性产生重大影响：Web服务器不会再在高负载情况下失败。由于服务器不会创建数千个线程来争夺有限的CPU和内存资源，因此服务器的性能将平缓地降低。通过使用Executor，可以实现各种调优/管理/监视/记录日志/错误报告和其他功能，如果不使用任务执行框架，那么要增加这些功能是非常困难的。 Executor的生命周期Executor的实现通常会创建线程来执行任务，但JVM只有在所有非守护线程全部终止之后才会退出，如果无法正确关闭Executor，那么JVM将无法结束。 由于Executor以异步方式来执行任务，因此在任何时刻，之前提交任务的状态不是立即可见的。有些任务可能已经完成，有些可能正在运行，而其他的任务可能在队列中等待执行。当关闭应用程序时，可能采用平缓的方式（完成所有已经启动的任务，并且不再接受任何新的任务），也可能采用粗暴方式（直接所有都关掉）。Executor视为应用程序提供服务的，因此它们也是可关闭的，并把在关闭操作中受影响的任务的状态返回给应用程序。 为了解决执行任务的生命周期问题，ExecutorService接口扩展了Executor，添加了一些用于生命周期管理的方法：12345678public interface ExecutorService extends Executor &#123; void shutdown(); List&lt;Runnable&gt; shutDownNow(); boolean isShutdown(); boolean isTerminated(); boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; // ......其他用于任务提交的便利方法&#125; ExectuorService的生命周期有三种状态：运行、关闭和已终止。ExecutorService在创建时处于运行状态，shutdown方法执行优雅地关闭:不再接受新的任务，同时等待已经提交的任务执行完成–包括那些还未开始执行的任务。shutdownNow方法执行粗暴的关闭：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。 例如支持关闭操作的Web服务器：12345678910111213141516171819202122232425262728293031323334class LifecycleWebServer &#123; private final ExecutorService exec = ...; public void start() throws IOException &#123; ServerSocket socket = new ServerSocket(80); while(!exec.isShutdown()) &#123; try &#123; final Socket conn = socket.accept(); exec.execute(new Runnable() &#123; public void run() &#123; handleRequest(conn); &#125; &#125; ); &#125; catch (RejectedExecutonException e) &#123; if (!exec.isShutdown()) &#123; log("task submission rejected", e); &#125; &#125; &#125; &#125; public void stop() &#123; exec.shutdown(); &#125; void handleRequest(Socket connection) &#123; Request req = readRequest(connection); if (isShutdownRequest(req)) &#123; stop(); &#125; else &#123; dispatchRequest(req); &#125; &#125;&#125; 延迟任务与周期任务Timer类负责管理延迟任务以及周期任务，然而，Timer存在一些缺陷，因此应该考虑使用ScheduledThreadPoolExecutor来代替它，可以通过ScheduledThreadPoolExecutor的构造函数或Executors.newScheduledThreadPool工厂方法来创建该类的对象。它很少被使用，主要的缺陷有： Time在执行所有定时任务时只会创建一个线程，会破坏其他TimeTask的定时精确性。 如果TimeTask抛出一个未检查的异常，那么Time将表现出糟糕的行为。 找出可利用的并行性下面将展示一个逐步利用并行性的浏览器程序中的页面渲染功能，它的作用是将HTMl页面回执到图像缓存中。 最简单的方法是对HTML文档进行串行处理，遇到图像引用，就通过网络获取它，然后再将其绘制到图像缓存中。但是这种方式需要等待很长时间。 另一种串行方式是先绘制文本元素，然后再开始下载图像，如下面的代码：12345678910111213// 图片下载过程的部分时间都是在等待I/O操作执行完成，没有充分利用CPUpublic class SingleThreadRenderer &#123; void renderPage(CharSequence source) &#123; renderText(source); List&lt;ImageData&gt; imageData = new ArrayList&lt;ImageData&gt;(); for (ImageInfo imageInfo : scanForImageInfo(source)) &#123; imageData.add(imageInfo.downloadImage()); &#125; for (ImageData data : imageData) &#123; renderImage(data); &#125; &#125;&#125; Executor使用Runnable作为其基本的任务表示形式，但是Runnable是一种有很大局限的抽象，虽然run能写入到日志文件或者将结果放入到某个共享的数据结构，但它不能返回一个值或抛出一个受检查的异常。 许多任务实际上都是存在延迟的计算—— 执行数据库查询，从网络上获取资源，或者计算某个复杂的功能。对于这些任务，Callable是一种更好的抽象：它认为主入口点（即call）将返回一个值，并可能抛出一个异常。 Runnable和Callable描述的都是抽象的计算任务。这些任务通常都是有范围的，即都有一个明确的起点，并且最终会结束。Executor执行的任务又四个生命周期阶段：创建/提交/开始/完成。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当它们响应中断时，才能取消。 Future表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。在Future规范中包含的隐含意义是，任务的生命周期只能前进，不能后退。当某个任务完成后，它就永远停留在“完成”状态上。 可以通过许多方法创建一个Future来描述任务。ExecutorService中的所有submit方法都将返回一个Future，从而将一个Runnable或Callable提交给Executor，并得到一个Future用来获得任务的执行结果或者取消任务。还可以显式地为某个指定的Runnable或Callable实例化一个FutureTask。 123456789101112131415161718192021222324252627282930313233343536373839// FutureReaderer使得渲染文本与下载图像数据的任务并发执行public class FutureRenderer &#123; // 1.创建ExecutorService ExecutorService executorService = Executors.newCachedThreadPool(); void renderPage(CharSequence source) &#123; final List&lt;ImageInfo&gt; imageInfos = scanFooImageInfo(source); // 2.创建Callable任务 Callable&lt;List&lt;ImageData&gt;&gt; task = new Callable&lt;List&lt;ImageData&gt;&gt;() &#123; public List&lt;ImageData&gt; call() &#123; List&lt;ImageData&gt; result = new ArrayList&lt;ImageData&gt;(); for (ImageInfo imageInfo : imageInfos) &#123; result.add(imageInfo); &#125; return result; &#125; &#125;; // 3. 提交Callable任务，获得Future Future&lt;List&lt;ImageData&gt;&gt; future = (Future) executorService.submit(task); // 渲染文本 renderText(source); // 4. 调用get获取结果，并处理异常 try &#123; List&lt;ImageData&gt; imageData = future.get(); for (imageData data : imageData) &#123; RenderableImage(data); &#125; &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); future.cancel(true); &#125; catch (ExecutionException e) &#123; throw launderThrowable(e.getCause()); &#125; &#125;&#125; get方法的行为取决于任务的状态（尚未开始，正在执行，已完成）。如果任务已经完成，那么get会立即返回或者抛出一个Exception，如果任务没有完成，那么get将阻塞并直到任务完成。如果任务抛出了异常，那么get将该异常封装为ExecutionException并重新抛出。如果任务被取消，那么get将抛出CancellationException。 如果将两个任务A和B分配给两个工人，但A的执行时间是B的10倍，那么整个过程也只能加速9%。最后，当在多个工人之间分解任务时，还需要一定的任务协调开销：为了使任务分解能提高性能，这种开销不能高于并行性实现的提升。所以只有当大量互相独立且同构的任务可以并发进行处理时，才能体现出将程序的工作负载分配到多个任务中带来的真正性能提升。 如果向Executor提交了一组计算任务，并且希望在计算完成后获得结果，那么可以保留与每个任务关联的Future，然后反复使用get方法，同时将参数timeout指定为0，从而通过轮训来判断任务是否完成。这种方法虽然可行，但有些繁琐。幸好有CompletionService（完成服务）。 CompetionService将Executor和BlockingQueue的功能融合在一起，可以将Callable任务提交给它来执行，然后使用类似于队列操作的take和poll等方法来获得已完成的结果，而这些结果会在完成时被封装为Future。ExecutorCompletionService实现了CompletionService，并将计算部分委托给一个Executor。123456789101112131415161718192021222324252627282930313233343536// 通过CompletionService从两方面来提高页面渲染器的性能：缩短总运行时间以及提高响应性。其实现是为每一幅图像都创建一个独立的任务。public class Renderer &#123; // 1.创建一个ExecutorService private final ExecutorService executorService = Executors.newCachedThreadPool(); Renderer(ExecutorService executor) &#123; this.executor = executor; &#125; void renderPage (CharSequence source) &#123; List&lt;ImageInfo&gt; info = scanForImageInfo(source); // 2. 创建ExecutorCompletionService CompletionService&lt;ImageData&gt; completionService = new ExecutorCompletionService&lt;ImageData&gt;(executorService); // 3. 为每幅图片创建一个独立任务 for(final ImageInfo imageInfo: info) &#123; completionService.submit(new Callable&lt;ImageData&gt;() &#123; public ImageData call() &#123; return imageInfo.downloadImage(); &#125; &#125;); &#125; // 渲染文本 renderText(source); // 4. 获取Future，调用get try &#123; for(int i=0, n=info.size(); t&lt;n; t++) &#123; Future&lt;ImageData&gt; future = completionService.take(); ImageData imageData = future.get(); RenderImage(imageData); &#125; &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125; catch (ExecutionException e) &#123; throw launderThrowable(e.getCause()); &#125; &#125;&#125; 有时候，如果某个任务无法在指定时间内完成，那么将不再需要它的结果，此时可以放弃这个任务。在支持时间限制的Future.get中支持这种需求：当结果可用时，它将立即返回，如果在指定时限内没有计算出结果，那么将抛出TimeoutException。在使用限时任务时需要注意，当这些任务超时后应该立即停止，从而避免为继续计算一个不再使用的结果而浪费计算资源。Future如果一个限时的get方法抛出了TimeoutException，那么可以通过Future来取消任务。1234567891011121314151617Page renderPageWithAd() throws InterruptedException &#123; long endNanos = System.nanoTime() + TIME_BUDGET; Future&lt;Ad&gt; future = exec.submit(new FetchAdTask()); Page page = renderPageBody(); Ad ad; try &#123; long timeLeft = endNanos - System.nanoTime(); ad = f.get(timeLeft, NANOSECONDS); // 设定时间 &#125; catch (ExecutionException e) &#123; ad = DEFAULT_AD; &#125; catch (TimeoutException e) &#123; ad = DEFAULT_AD; f.cancel(true); //取消任务 &#125; page.setAd(ad); return page;&#125; 总结Executor框架可以将任务提交与执行策略解耦开来，当需要创建线程来执行任务时，可以考虑使用Executor，同时考虑Callable和Future。要想将应用程序分解为不同的任务并发执行时，必须定义清晰的任务边界。 参考 《Java并发编程实战》]]></content>
      <categories>
        <category>Java并发编程实战</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发_4_基础构建模块]]></title>
    <url>%2F2018%2F01%2F14%2FJava%E5%B9%B6%E5%8F%91-4-%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[引：JDK提供的东西效率应该是可以保证的，所以我们要学会去使用JDK自带的并发基础构建模块，以及理解在使用这些模块来构建应用程序时的一些常用模式。 同步容器类同步容器类包括Vector和Hashtable。这些类实现线程安全的方式是：将他们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。 同步容器类的问题先看下面的代码：123456789public static Object getLast(Vector list) &#123; int lastIndex = list.size() - 1; return list.get(lastIndex);&#125;public static void deleteLast(Vector list) &#123; int lastIndex = list.size() - 1; list.remove(lastIndex);&#125; 这些方法看起来没有问题，但是如果线程A在执行deleteLast, 线程B在执行getLast，list中有10个元素，刚好B在执行list.size()和get(lastIndex)之间，线程A执行完了remove(lastIndex), 那么线程B在执行get(lastIndex)时就会抛出ArrayIndexOutOfBoundsException。 由于同步容器类要遵守同步策略，即客户端加锁，因此在创建一些新的操作时，只要我们知道应该使用哪一个锁，那么这些新操作就与容器的其他操作一样都是原子操作。如下面的代码：12345678910111213public static Object getLast(Vector list) &#123; synchronized(list) &#123; int lastIndex = list.size() - 1; return list.get(lastIndex); &#125;&#125;public static void deleteLast(Vector list) &#123; synchronized(list) &#123; int lastIndex = list.size() - 1; list.remove(lastIndex); &#125;&#125; 在调用size和相应的get之间，Vector的长度可能会发生变化，这种风险在对Vector中的元素进行迭代时仍然会出现，如下面的代码：12345// 可能抛出ArrayIndexOutOfBoundsException的迭代操作for (int i = 0; i &lt; vector.size(); i++) &#123; doSomething(vetor.get(i));&#125; 我们可以通过在客户端加锁来解决不可靠迭代的问题，但是要牺牲一些伸缩性。通过在迭代期间持有Vector的锁，可以防止其他线程在迭代期间修改Vector。如下面的代码：12345synchronized (vector) &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; doSomething(vetor.get(i)); &#125;&#125; 迭代器与ConcurrentModificationException对容器类进行迭代的标准方式是使用Iterator，然而，如果有其他线程并发地修改容器，那么即使是使用迭代器也无法避免地需要在同步容器上加锁。在设计同步容器类的迭代器时并没有考虑到并发修改的问题，它们的迭代器是“及时失败”的，所以当它们发现容器在迭代过程中发生变化，就会抛出一个ConcurrentModificationException异常。这种fail-fast机制并不是一种完备的处理机制，而只是“善意地”捕获并发错误，因此只能作为并发问题的预警指示器。它们采取的实现方式是将计数器变化与容器关联起来：如果在迭代期间计数器被修改，那么hasNext或next将抛出ConcurrentModificationException。然而，这种检查是在没有同步的情况下进行的，因此可能会看到失效的值，而迭代器可能并没有意识到已经发生了修改。要想避免出现ConcurrentModificationException，就必须在迭代过程中持有容器的锁。 然而，有时候开发人员并不希望在迭代器间对容器加锁。例如，某些线程在可以访问容器之前，必须等待迭代过程结束，如果容器规模很大，或者在每个元素上执行操作的时间很长，那么这些线程就需要长时间等待。持有锁的时间越长，那么在锁上的竞争就越激烈，如果许多线程都在等待锁被释放，那么将极大地降低吞吐量和CPU的利用率。 另一种替代方法是“克隆”容器，并在副本上进行迭代。由于副本被封闭在线程内，因此其他线程不会在迭代期间对其进行修改，这样就避免了抛出ConcurrentModificationException，不过在克隆过程中仍然要加锁（以防在此期间被克隆容器被其他线程修改，那样克隆出来的容器就是失效的容器），所以也会增加性能开销。所以这种方法的好坏取决于多个因素：容器的大小，在每个元素上执行的操作，迭代操作相对于容器上其他操作被调用的频率，以及在响应时间和吞吐量等方面的需求。 隐藏迭代器虽然加锁可以防止迭代器抛出ConcurrentModificationException，但必须记住在所有对共享容器进行迭代的地方都需要加锁。实际情况更复杂，因为在某些情况下，迭代器会隐藏起来。 如下例，标准容器的toString方法将迭代容器，并在每个元素上调用toString来生成容器内容的格式化表示：123456789101112131415161718public class HiddenIterator &#123; @GuardedBy("this") private final Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); public synchronized void add(Integer i) &#123; set.add(i); &#125; public synchronized void remove(Integer i) &#123; set.remove(i); &#125; public void addTenThing() &#123; Random r = new Random(); for (int i=0; i&lt; 10; i++) &#123; set.add(r.nextInt()); &#125; System.out.println("DEBUG: added ten elements to " + set); &#125;&#125; addTenThings方法可能会抛出ConcurrentModificationException，因为toString对set进行了迭代，而且没加锁。如果状态与保护它的同步代码之间相隔越远，那开发人员就越容易忘记在访问状态时使用正确的同步。如果HiddenIterator用synchronizedSet来包装HashSet，并且对同步代码进行封装，那么就不会抛出异常了。容器的hashCode和equals等方法也会间接地执行迭代操作，同样，containsAll, removeAll和retainAll等方法，以及把容器作为参数的构造函数，都会对容器进行迭代，所有这些间接的迭代操作都可能抛出ConcurrentModificationException。 并发容器同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性，这样的代价就是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重降低。Java 5.0提供了多种并发容器类来改进同步容器的性能。通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。 Java 5.0增加了ConcurrentHashMap，用来替代基于hash的同步map，增加了CopyOnWriteArrayList，用来替代以遍历操作为主要操作的同步List。在新的ConcurrentMap接口中增加了一些常用的复合操作，例如“putIfAbsent”,replace, 和 conditional remove。 Java 5.0还增加了两个新的集合类型，Queue和BlockingQueue。 Java 6.0增加了ConcurrentSkipListMap来替换同步的SortedMap，增加了ConcurrentSkipListSet替换SortedSet（例如TreeMap和TreeSet） ConcurrentHashMap与HashMap一样，ConcurrentHashMap也是一个基于HashCode的Map，但它使用了一种完全不同的加锁策略来提供更高的并发性和伸缩性。ConcurrentHashMap并不是将每个方法都在同一把锁上同步并使得每次只有一个线程访问容器，而是使用一个种粒度更细的加锁机制来时间共享，叫做分段锁。在这种机制下，任意数量的读取线程可以并发地访问这个map，执行读取操作的线程和执行写入操作的线程可以并发地访问map，并且一定数量的写入线程可以并发地修改Map。 而且ConcurrentHashMap提供的迭代器不会抛出ConcurrentModificationException，因此不需要再迭代过程中对容器加锁。它返回的迭代器具有弱一致性，而并非“及时失败”。弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以在迭代器被构造后将修改操作反映给容器。 与Hashtable和synchronized-Map相比，ConcurrentHashMap有着更多的优势以及更少的劣势。因此在大多数情况下，用ConcurrentHashMap来代替同步Map能进一步提高代码的可伸缩性，只有当应用程序需要给map加锁以进行独占访问时，才应该放弃使用ConcurrentHashMap。 额外的原子Map操作由于ConcurrentHashMap不能被加锁来执行独占访问，因此也无法使用客户端加锁来创建新的原子操作。但是一些常见的复合操作，如“如没有则添加（put-if-absent）”,”若相等则移除（remove-if-equals）”,”若相等则替换（replace-if-equals）”等，都已经在ConcurrentMap接口中有声明，所以如果需要为现有的同步Map添加这样的功能，就应该考虑使用ConcurrentMap了。 CopyOnWriteArrayListCopyOnWriteArrayList用于替代同步list，在某些情况下提供了更好的并发性能，并且在迭代器间不需要对容器进行加锁或复制。（类似地，CopyOnWriteArraySet的作用是替代同步set） Copy-On-Write容器的线程安全性在于，只要正确地发布一个实际不可变的对象，那么在访问该对象时就不需要进一步的同步了。 Copy-On-Write从字面上看就是，Write的时候总是要Copy，所以在每次修改时，都会创建并重新发布一个新的容器副本。而CopyOnWriteArrayList容器的迭代器会保留一个指向原始数组的引用，遍历的也是原始数组，而其他线程修改的是这个原始数组的副本，所以也不会影响原始数组，原始数组不会改变，也就不会有ConcurrentModificationException了，并且返回的元素和迭代器创建时的元素完全一致。 显然，每当修改容器时都会复制原始数组，这需要一定开销，特别是当容器的规模较大时。仅当迭代器操作多于修改操作时，才应该使用“写入时复制”容器。 阻塞队列和生产者-消费者模式基于阻塞队列构建的生产者-消费者设计中：当数据生成时，生产者把数据放入队列，而当消费者准备处理数据时，将从队列中获取数据。阻塞队列简化了生产者-消费者设计的实现过程，它支持任意数量的生产者和消费者。 在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。 BlockingQueue有多种实现：LinkedBlockingQueue和ArrayBlockingQueue是FIFO队列，与LinkedList和ArrayList相似，但比同步list有更好的并发性能。PriorityBlockingQueue是一个按优先级排序的队列，当你希望按照某种顺序而不是FIFO来处理元素时，这个队列非常有用，PriorityBlockingQueue既可以根据元素的自然顺序来比较元素，也可以使用Comparator来比较。最后一个BlockingQueue是SynchronousQueue，它并不是一个真正的队列，因为它不会为队列中元素维护存储空间。它维护的是一组线程，这些线程在等待着把元素加入或移出队列。以洗盘子为例，相当于没有盘架，直接将洗好的盘子放入下一个空闲的烘干机中，它可以直接交付工作，从而降低了将数据从生产者移动到消费者的延迟。因为SynchronousQueue没有存储功能，因此put和take会一直阻塞，直到有另一个线程已经准备好参与到交付过程中。仅当有足够多的消费者，并且总有一个消费者准备好获取交付的工作时，才适合使用同步队列。 串行线程封闭对于可变对象，生产者-消费者这种设计与阻塞队列组合在一起使得把对象从生产者转移给消费者变得容易。线程封闭对象只能由单个线程拥有，但可以通过安全地发布该对象来转移所有权。在所有权转移后，就只有新线程能获得这个对象的访问权限，并且发布对象的线程不会再访问它。这种安全的发布确保了对象状态对于新的所有者来说是可见的，并且由于最初的所有者不会再访问它，所以这个对象又被封闭在新的线程中，新线程可以对该对象做任意修改，因为它具有独占的访问权。 对象池利用了串行线程封闭，将对象借给一个请求线程。只要对象池包含足够的内部同步来安全地发布池中的对象，并且只要客户代码本身不会发布池中的对象，或者在将对象返回给对象池后就不再使用它，那么就可以安全地在线程之间传递所有权。 双端队列与工作密取Java 6增加了两种容器类型，Deque&amp;BlockingQueue。Deque是一个双端队列，实现了在队列头和队列尾的高效插入和移除。 双端队列适用于另一种相关模式，即工作密取（Work Stealing）。（不懂） 同步工具类同步器可以是任何一个对象，只要它根据其自身的状态来协调线程的控制流就可以叫同步器。阻塞队列可以作为同步器，其他类型的同步器还包括信号量(Semaphore)/栅栏（Barrier）以及闭锁（Latch）。 所有的同步器都包含一些特定的结构化属性：它们封装了一些状态，这些状态将决定使用同步器的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用于高效地等待同步器进入到预期状态。 闭锁闭锁时一种同步器，可以延迟线程的进度直到线程到达终止状态。闭锁的作用相当于一扇门：在闭锁到达terminal状态前，这扇门一直是关闭的，没有任何线程通过，而当到达terminal状态时，这扇门就会打开允许所有线程通过。当闭锁达到terminal状态，它的状态就不会再改变，因此这扇门会永远打开。闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。例如： 确保某个计算在其需要的所有资源都初始化之后才继续执行 确保某个服务在其依赖的所有其他服务都已经启动之后才启动 等待某个操作的所有参与者都就绪再继续执行 CountDownLatch是一种灵活的闭锁，可以在上述各种情况中使用，它可以使一个或多个线程等待一组事件发生。countDown方法递减计数器，表示有一个事件已经发生了，而await方法等待计数器达到零，这表示所有需要等待的事件都已经发生。如果计数器的值非零，那么await会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。例如下面的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TestHarness &#123; public long timeTasks(int nThreads, final Runnable task) throws InterruptedException &#123; final CountDownLatch startGate = new CountDownLatch(1); final CountDownLatch endGate = new CountDownLatch(nThreads); for(int i = 0; i &lt; nThreads; i++) &#123; Thread t = new Thread() &#123; public void run() &#123; try &#123; startGate.await(); try &#123; task.run(); &#125; finally &#123; endGate.countDown(); &#125; &#125; catch (InterruptedException ignored) &#123;&#125; &#125; &#125;; t.start(); &#125; long start = System.nanoTime(); startGate.countDown(); endGate.await(); long end = System.nanoTime(); return end-start; &#125; public static void main(String[] args) &#123; Runnable task = new Runnable() &#123; @Override public void run() &#123; System.out.println("ing"); &#125; &#125;; try &#123; long interval = new TestHarness().timeTasks(3, task); System.out.println(interval); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 启动门将使得主线程能够同时释放所有工作线程，而结束门则使主线程能够等待最后一个线程执行完成。 FutureTaskFutureTask也可以用作闭锁，它可以处于下面3种状态：等待运行、正在运行和运行完成。Future.get的行为取决于任务的状态，如果任务已经完成，那么get会立即返回结果，否则get将阻塞直到任务进行完成状态。 信号量计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。 Semaphore管理着一组虚拟的permits，许可的初始数量通过构造函数指定。在执行操作前先acquire permits（只要有剩余的许可就可以），在使用完后会release这个许可。如果没有获得permit，acquire方法将一直阻塞到有许可或指导被中断或超时。release方法将返回一个permit给信号量。 Semaphore也可以将任何一种容器变成有界阻塞容器。信号量的计数值会初始化为容器容量的最大值，add操作在向容器添加一个元素之前，首先获取一个permit，然后再添加，如果添加失败，那么会释放许可，如果成功就不释放了。同样，remove操作会释放一个许可，来使更多的元素能够添加到容器中。代码如下：1234567891011121314151617181920212223242526272829303132public class BoundedHashSet&lt;T&gt; &#123; private final Set&lt;T&gt; set; private final Semaphore sem; public BoundedHashSet(int bound) &#123; this.set = Collections.synchronizedSet(new HashSet&lt;T&gt;()); sem = new Semaphore(bound); &#125; public boolean add(T o) throws InterruptedException &#123; sem.acquire(); boolean wasAdded = false; try &#123; wasAdded = set.add(o); &#125; finally &#123; if (!wasAdded) &#123; sem.release(); &#125; &#125; return wasAdded; &#125; public boolean remove(Object o) &#123; boolean wasRemoved = set.remove(o); if (wasRemoved) &#123; sem.release(); &#125; return wasRemoved; &#125;&#125; 栅栏闭锁可以启动一组相关的操作，或者等待一组相关的操作结束。闭锁时一次性对象，一旦进入终止状态，就不能被重置。 栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件发生，而栅栏用于等待其他线程。 构建高效且可伸缩的结果缓存下面的几个代码段将逐步构架一个高效且可伸缩的缓存：123456789101112131415161718192021222324252627282930313233// Memoizer1存在一个可伸缩的问题，每次只有一个线程能够执行compute。public interface Computable&lt;A,V&gt; &#123; V compute(A arg) throws InterruptedException;&#125;public class ExpensiveFunction implements Computable&lt;String, BigInteger&gt;&#123; @Override public BigInteger compute(String arg) throws InterruptedException &#123; //在经过长时间的计算后 return new BigInteger(arg); &#125;&#125;public class Memoizer1&lt;A, V&gt; implements Computable&lt;A, V&gt; &#123; private final Map&lt;A, V&gt; cache = new HashMap&lt;A, V&gt;(); private final Computable&lt;A, V&gt; c; public Memoizer1(Computable&lt;A, V&gt; c) &#123; this.c = c; &#125; @Override public synchronized V compute(A arg) throws InterruptedException &#123; V result = cache.get(arg); if (result == null) &#123; result = c.compute(arg); cache.put(arg, result); &#125; return result; &#125;&#125; 1234567891011121314151617181920// 会存在重复计算的问题public class Memoizer2&lt;A, V&gt; implements Computable&lt;A, V&gt; &#123; private final Map&lt;A, V&gt; cache = new ConcurrentHashMap&lt;A, V&gt;(); private final Computable&lt;A, V&gt; c; public Memoizer2(Computable&lt;A, V&gt; c) &#123; this.c = c; &#125; @Override public V compute(A arg) throws InterruptedException &#123; V result = cache.get(arg); if (result == null) &#123; result = c.compute(arg); cache.put(arg, result); &#125; return result; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*利用FutureTask来减少重复计算的问题,但是由于if判断中依然存在非原子的“先检查再执行”的操作，所以还是会存在重复计算的问题*/ public class Memoizer3&lt;A, V&gt; implements Computable&lt;A, V&gt; &#123; private final Map&lt;A, Future&lt;V&gt;&gt; cache = new ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;(); private final Computable&lt;A, V&gt; c; public Memoizer3(Computable&lt;A, V&gt; c) &#123; this.c = c; &#125; @Override public V compute(final A arg) throws InterruptedException &#123; Future&lt;V&gt; f = cache.get(arg); if (f == null) &#123; Callable&lt;V&gt; eval = new Callable&lt;V&gt;() &#123; @Override public V call() throws InterruptedException &#123; return c.compute(arg); &#125; &#125;; FutureTask&lt;V&gt; ft = new FutureTask&lt;V&gt;(eval); f = ft; cache.put(arg,ft); ft.run(); &#125; try &#123; return f.get(); &#125; catch (ExecutionException e) &#123; throw launderThrowable(e.getCause()); &#125; &#125; /** * 强制将未检查的Throwable转化为RuntimeException * @param t * @return */ public static RuntimeException launderThrowable(Throwable t) &#123; if (t instanceof RuntimeException) &#123; return (RuntimeException) t; &#125; else if (t instanceof Error) &#123; throw (Error) t; &#125; else &#123; throw new IllegalStateException("Not unchecked",t); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738// **最终版**// 利用复合操作“若没有则添加”可以解决Memoizer3的问题public class Memoizer4&lt;A, V&gt; implements Computable&lt;A, V&gt; &#123; private final Map&lt;A, Future&lt;V&gt;&gt; cache = new ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;(); private final Computable&lt;A, V&gt; c; public Memoizer4(Computable&lt;A, V&gt; c) &#123; this.c = c; &#125; @Override public V compute(final A arg) throws InterruptedException &#123; while (true) &#123; Future&lt;V&gt; f = cache.get(arg); if (f == null) &#123; Callable&lt;V&gt; eval = new Callable&lt;V&gt;() &#123; @Override public V call() throws InterruptedException &#123; return c.compute(arg); &#125; &#125;; FutureTask&lt;V&gt; ft = new FutureTask&lt;V&gt;(eval); f = ft; cache.putIfAbsent(arg, ft); ft.run(); &#125; try &#123; return f.get(); &#125; catch (CancellationException e) &#123; cache.remove(arg, f); //为了解决缓存污染问题，当计算被取消或者失败时，就从缓存中remove &#125; catch (ExecutionException e) &#123; throw launderThrowable(e.getCause()); &#125; &#125; &#125;&#125; 总结构建一个高效且具有伸缩性的基础模块还是有点难度的，我们要考虑的东西比较多，我们要利用已有的基础模块合理构建。 参考 《Java并发编程实战》 《Java并发编程实践》（四）—- 构建阻塞 图解集合3：CopyOnWriteArrayList]]></content>
      <categories>
        <category>Java并发编程实战</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发_3_对象的组合]]></title>
    <url>%2F2018%2F01%2F13%2FJava%E5%B9%B6%E5%8F%91-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[引：我们不希望每一次访问内存都进行分析以确保程序是线程安全的，而是希望将一些现有的线程安全组件组合为更大规模的组件或程序。 设计线程安全的类 在设计线程安全类的过程中，需要包含以下三个基本要素： 找出构成对象状态的所有变量 找出约束状态变量的不变性条件 建立对象的并发访问管理策略 同步策略规定了如何将不变性、线程封闭、加锁机制等结合起来以维护线程的安全性，并且规定了哪些变量由哪些锁来保护。要确保开发人员可以对这个类进行分析与维护，就必须将同步策略写成正式文档。 收集同步需求要确保类的线程安全性，就需要确保它的不变性条件不会再并发访问时被破坏，这就需要对其状态进行推断。在许多类中都定义了一些不可变条件，用于判断状态是有效的还是无效的。同样，在操作中还包含一些后验条件来判断状态转换是否有效。当下一个状态需要依赖当前状态时，这个操作就必须是一个复合操作。如果不了解对象的不变性与后验条件，那么就不能确保线程安全性，要满足状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。 依赖状态的操作类的不变性条件和后验条件限制了对象的有效状态已经状态转换的有效性。有些对象包含一些基于状态的先验条件，例如，不能从空队列中移除一个元素。如果在操作中包含基于状态的先验条件，那么这个操作就叫做依赖状态操作。 在并发程序中要一直等到先验条件为真然后再进行操作，可以使用现有库的类（阻塞队列[Blocking Queue]或信号量[Semaphore]）来实现依赖状态的行为。 状态的所有权多数情况下，所有权与封装性是相互关联的：对象封装它拥有的状态，也对它封装的状态拥有所有权。状态变量的所有者将决定采用何种加锁协议来维持变量状态的完整性。所有权意味着控制权。如果发布了某个可变对象的引用，那么原来的所有者就不再独占控制权了，就变成共享控制权了。 实例封闭封装简化了线程安全类的实现过程，它提供了一种实例封装机制，也简称为封闭。将数据封装在对象内部，就可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。 可以看下面的例子：1234567891011121314@ThreadSafepublic class PersonSet &#123; @GuardedBy("this") private final Set&lt;Person&gt; mySet = new HashSet&lt;&gt;(); public synchronized void addPerson(Person p) &#123; mySet.add(p); &#125; public synchronized boolean containsPerson(Person p) &#123; return mySet.contains(p); &#125;&#125; PersonSet类说明了如何通过将mySet封闭在一个类属性中以及使用加锁机制使一个类成为线程安全的。PersonSet的状态由HashSet来管理，而HashSet不是线程安全的，但由于mySet是私有的并且不会逸出，因此HashSet被封闭在PersonSet中。唯一能访问mySet的代码路径是addPerson和containsPerson两个方法，在执行它们时都要获得PersonSet的内置锁，所以PersonSet的状态完全由它的内置锁保护，因而PersonSet是一个线程安全的类。 线程封闭的作用可以将非线程安全的类转化为线程安全的类。可以利用到装饰器模式。封闭机制更易于构造线程安全的类，因为在分析线程安全性时可以只分析该类而不用检查整个程序。 Java监视器模式Java的内置锁也称为监视器锁或监视器。所以使用内置锁来保证线程安全性的模式就叫做Java监视器模式。遵循Java监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。Java监视器模式仅仅是一种编写代码的乐队，对于任何一种锁对象，只要自始至终都使用该锁对象，都可以用来保护对象的状态。（不知道是不是只要读和写方法只要都保持同步就好了？） 线程安全的委托（需要好好理解的，日后加深）在某些情况下，通过多个线程类组合而成的类是线程安全的，而在某些情况下，这仅仅是一个好的开端，但却是线程不安全的（由于没有维持不变性约束）。 如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给这些状态变量。 如果一个状态变量是线程安全的，也不参与任何不变性条件，也没有操作上的状态变换，那这个变量就可以发布出去。 在现有的线程安全类中添加功能Java类库包中包含许多有用的“基础模块”类，通常，我们应该优先选择重用这些现有的类而不是创建新的类：重用能降低开发工作量、开发风险（因为现有的类都已经通过测试）以及维护成本。我们需要在不破坏线程安全性的情况下添加一个新的操作。 要添加一个新的原子操作，最安全的方法是修改原始类，但这通常无法做到，因为可能无法访问或修改类的源代码。如果直接将新方法添加到类中，那么意味着实现同步策略的所有代码仍然处于一个源文件中，从而更容易维护。另一种方法是用子类扩展这个类，但这样的话同步策略的实现就分布在了多个需要单独维护的源文件中，如果父类修改了同步策略选择不同的锁来保护它的状态变量，那子类也需要跟着变。如下面的代码：1234567891011// 扩展Vector并增加一个“若没有则添加”方法public class BetterVector&lt;E&gt; extends Vector&lt;E&gt; &#123; public synchronized boolean putIfAbsent(E x) &#123; boolean absent = !contains(x); if (absent) &#123; add(x); &#125; return absent &#125;&#125; 客户端加锁机制第三种策略是扩展类的功能，但并不是扩展类本身，而是将扩展方法放在一个辅助类（Helper class）中。代码如下：1234567891011public class ListHelper&lt;E&gt; &#123; public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;()); ... public synchronized boolean putIfAbsent(E x) &#123; boolean absent = !list.contains(x); if(absent) &#123; list.add(x); &#125; return absent; &#125;&#125; putIfAbsent用的是ListHelper的内置锁，但list用的肯定不是ListHelper的锁，尽管所有的list操作都被声明为synchronized，但却是不一样的锁，这就无法确保当putIfAbsent执行时另一个线程不会修改这个list。 要想使这个方法正确执行，必须使list在实现客户端加锁或外部加锁时使用同一个锁。客户端加锁是指，对于使用某个对象X的客户端代码，使用X本身用于保护其状态的锁来保护这段客户端代码。要使用客户端加锁，就必须知道对象X使用的是哪一个锁。在Vector和同步封装器类的文档中指出，它们通过使用Vector或封装器容器的内置锁来支持客户端加锁。所以修改后的putIfAbsent如下：12345678910111213public class ListHelper&lt;E&gt; &#123; public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;()); ... public boolean putIfAbsent(E x) &#123; synchronized(list) &#123; boolean absent = !list.contains(x); if(absent) &#123; list.add(x); &#125; return absent; &#125; &#125;&#125; 组合更好地为现有类添加原子操作的方法是：组合。示例如下：1234567891011121314151617public class ImprovedList&lt;T&gt; implements List&lt;T&gt; &#123; private final list&lt;T&gt; list; public ImprovedList(List&lt;T&gt; list) &#123; this.list = list; &#125; public synchronized boolean putIfAbsent(T x) &#123; boolean contains = list.contains(x); if(!contains) &#123; list.add(x); &#125; return !contains; &#125; public synchronized void clear() &#123; list.clear(); &#125;&#125; ImprovedList通过自身的内置锁增加了一层额外的加锁。它并不关心List是否是线程安全的，即使List不是线程安全的或者修改了它的加锁实现，ImprovedList也会提供一致的加锁机制来实现线程安全性。事实上，我们使用了Java监视器模式来封装现有的List，并且只要在类中拥有指向底层List的唯一外部引用，就能确保线程安全性。 总结设计一个线程安全的类方法有很多种，这里提到了三点：实例封闭、线程委托、复用现有基础类。但是具体实现线程安全都不一样，需要按实际情况来确定。 参考 《Java并发编程实战》]]></content>
      <categories>
        <category>Java并发编程实战</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发_2_对象的共享]]></title>
    <url>%2F2018%2F01%2F13%2FJava%E5%B9%B6%E5%8F%91-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[引：为了能够安全地由多个线程同时访问某个对象，我们就需要学会在共享和发布对象时，构建一个线程安全类或者通过java.util.concurrent类库来构建。 可见性在读操作和写操作在不同线程执行时，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，所谓“不可见”。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。 先看下面的代码：12345678910111213141516171819public class NoVisibility &#123; private static boolean ready; private static int number; private static class ReaderThread extends Thread &#123; public void run() &#123; while(!ready) &#123; Thread.yield(); &#125; System.out.println(number); &#125; &#125; public static void main(String[] args) &#123; new ReaderThread().start(); number = 42; ready = true; &#125;&#125; 这段代码不能保证输出42，可能输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入的number的值，这种现象称为“重排序”，它的意思是代码的顺序可能因为优化而发生重排序。 失效数据失效数据：当读线程查看一个变量是，可能会得到一个已经失效的值。除非在每次访问变量时都使用同步，否则很可能获得该变量的一个失效值。更糟糕的是，失效值可能不会同时出现：一个线程可能得到某个变量的最新值，而获得另一个变量的失效值。 下面的代码不是线程安全的：12345678910111213@NonThreadSafepublic class MutableInteger &#123; private int value; public int get() &#123; return value; &#125; public void set(int value) &#123; this.value = value; &#125;&#125; get和set都是在没有同步的情况下访问value，所以失效值问题很容易出现：如果某个线程在调用了get，那么另一个正在调用get的线程可能会看到更新后的value值，也可能看不到。要使MutableInteger成为一个线程安全的类，必须对set和get都进行同步。 非原子的64位操作最低安全性（out-of-thin-air-safety）:当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。 例外：对于非volatile类型的long和double变量，JVM允许64位的读操作和写操作分解为两个32位的操作。那么很有可能会读到某个值的高32位和另一个值的低32位。所以在多线程程序中使用共享且可变的long和double等类型的变量是不安全的，除非使用关键字volatile来声明他们，或者用锁保护起来。 volatile变量volatile变量可以确保将变量的更新操作通知到其他线程。并且会禁止重排序，因此在读取volatile类型的变量时总会返回最新写入的值。volatile通常用作某个操作完成。发生中断或者状态的标志。它只能保证可见性，但是不能保证原子性。 当且仅当满足所有条件时，才应该使用volatile变量： 对变量的写入操作不依赖变量的当前值（比读到的还要新的值），或者你能保证只有当个线程更新变量的值。 该变量不会与其他状态变量一起纳入不变性条件中。 在访问变量时不需要加锁。 发布和逸出“发布（Publish）”对象：使对象能够在当前作用域之外的代码中使用。例如：将一个指向该对象的引用保存到其他代码可以访问的地方（公有的静态变量中） “逸出（Escape）”：当某个不应该发布的对象被发布。例如：在对象构造完成之前就发布对象 发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象，如下面代码：12345public static Set&lt;Secret&gt; knownSecrets;public void initialize() &#123; knownSecrets = new HashSet&lt;Secret&gt;();&#125; 当发布某个对象时，可能会间接地发布其他对象。如果将一个Secret对象添加到集合knownSecrets中，那么同样会发布这个对象，因为任何代码都可以遍历这个集合，并获得对这个新Secret对象的引用。同样，如果从非私有方法中返回一个引用，那么同样会发布返回的对象。如下面的代码：123456class UnsafeStates &#123; private String[] states = new String[] &#123;"AK","AL"...&#125;; public String[] getStates() &#123; return states; &#125;&#125; 另一种将一个对象或者它内部的状态publish出去的方式就是publish这个对象所在类的内部类，如下例子,但是会将this对象的引用escape出去。因为当ThisEscape将EventListener publish出去，它就显示地将外部类ThisEscape实例对象也公布出去了，因为内部类实例保存了外部类实例的隐藏引用。所以会把this escape出去。1234567891011public class ThisEscape &#123; public public ThisEscape(EventSource source) &#123; source.registerListener( new EventListener() &#123; public void onEvent(Event o) &#123; doSomething(o);// 由于这个线程是异步的，所有EventSource可能还没有构造完 &#125; &#125;); &#125;&#125; 当内部EventListener实例发布时，在外部封装的ThisEscape实例也逸出了，当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态。一个常见的使this引用在构造过程中逸出的错误是在构造函数中启动一个线程。如果想在构造函数中注册一个事件监听器或启动线程，可以使用一个私有的构造函数和一个公共的工厂方法，从而避免不正确的构造过程：123456789101112131415161718public class SafeListener &#123; private final EventListener listener; private SafeListener() &#123; listener = new EventListener() &#123; public void onEvent(Event o) &#123; doSomething(o); &#125; &#125; &#125; public static SafeListener newInstance(EventSource source) &#123; SafeListener safeListener = new SafeListener(); source.registerListener(safeListener); return safeListener; &#125;&#125; 线程封闭当访问共享的可变数据时，通常需要同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭。 线程封闭的一个常见应用是从池中拿JDBC Connection。在典型的服务器应用中，一个线程从池中获取connection对象，用它来处理一个单独的请求，处理完后归还该connection，又放入池中。Connection池是不会把相同的connection对象分配给不同的线程的，这种模式就显式地将那个connection封闭在一个线程中。 局部变量和ThreadLocal类就是用来维护线程封闭特性的，但即便有这些现成的特性，程序员仍有义务去保证封闭在线程中的对象不会从线程中逸出 Ad-hoc线程封闭这种线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。这种技术很脆弱，因此程序中尽量少用它。 栈封闭栈封闭式线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问这个栈。栈封闭比Ad-hoc线程封闭更易于维护，也更加健壮。可以看看下面的例子：123456789101112131415161718public int loadTheArk(Collections&lt;Animal&gt; candidates) &#123; SortedSet&lt;Animal&gt; animals; int numPairs = 0; Animals candidate = null; animals = new TreeSet&lt;Animal&gt;(new SpeciesGenderComparator()); animals.addAll(candidates); for(animals a : animals) &#123; if (candidate == null || !candidate.isPotentialMate(a)) &#123; candidate = a; &#125; else &#123; ark.load(new AnimalPair(candidate, a)); ++numPairs; candidate = null; &#125; &#125; return numPairs; &#125; 上面代码中的numPairs不会破坏线程封闭性，因为任何方法都无法获得对基本类型的引用，所以基本类型的局部变量始终封闭在线程内。但是对于对象引用的线程封闭，就需要一些额外的工作确保对象引用不会逸出。在上例中实例化了一个TreeSet,并用animals引用指向它，因为只有一个引用指向这个Set，而且这个引用是局部变量，所以这个对象引用也被封闭在线程中。但是如果把这个animals公布（publish）出去，线程封闭性就会破化。 ThreadLocal类维护线程封闭性的一种更规范的方式是使用ThreadLocal. ThreadLocal提供了get和set方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。 例如，在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都要传递一个Connection对象。由于JDBC的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将JDBC的连接保存到ThreadLocal对象中，每个线程都会拥有属于自己的连接，如下：123456789private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;&gt;()&#123; public Connection initialValue() &#123; return DriverManager.getConnection(DB_URL); &#125;&#125;;public static Connection getConnection() &#123; return connectionHolder.get();&#125; 当某个线程初次调用ThreadLocal.get方法时，会调用initialValue()方法来获取初始值。从概念上讲，可以将ThreadLocal视为包含了Map对象，其中保存了只属于该线程的值。当线程终止后，这些值就会作为垃圾被回收掉。 不变性如果某个对象在创建之后状态就不能被修改，那这个对象就被称为不可变对象。不可变对象一定是线程安全的。不可变对象只有一种状态，而且这种状态由构造函数来控制。 当满足一下条件的时候，对象才是不可变的： 对象创建以后其状态就不能修改 对象的所有域都是final类型 对象是正确创建的（在对象的创建过程中，this引用没有逸出） 不可变对象仍然可以在内部使用可变对象来管理它们的状态。如下例：12345678910111213141516@Immutablepublic final class ThreeStooges &#123; private final Set&lt;String&gt; stooges = new HashSet&lt;&gt;(); public ThreeStooges() &#123; stooges.add("Moe"); stooges.add("Larry"); stooges.add("Curly"); &#125; public boolean isStooge(String name)&#123; return stooges.contains(name); &#125;&#125; Final域正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”一样，“除非需要某个域是可变的，否则应将其声明为final域”也是一个良好的编程习惯。 使用Volatile类型来发布不可变对象为了保证操作的原子性，可以将多个状态转化为包含多个状态的不可变对象，然后使用volatile来保持可见性，从而保证了线程安全。如下面的例子：1234567891011121314151617181920212223242526272829303132public class VolatileCachedFactorizer implements Servlet&#123; private volatile OneValueCache cache = new OneValueCache(null, null); public void service(ServletRequest req, ServletResponse resp) &#123; BigInteger i = extractFromRequest(req); BigInteger[] factors = cache.getFactors(i); if (factors == null) &#123; factors = factor(i); cache = new OneValueCache(i, factors); &#125; encodeIntoResponse(resp, factors); &#125;&#125;class OneValueCache &#123; private final BigInteger lastNumber; private final BigInteger[] lastFactos; public OneValueCache(BigInteger i, BigInteger[] factors) &#123; lastNumber = i; lastFactos = Arrays.copyOf(factors, factors.length); &#125; public BigInteger[] getFactors(BigInteger i) &#123; if (lastNumber == null || !lastNumber.equals(i)) &#123; return null; &#125; else &#123; return Arrays.copyOf(lastFactos, lastFactos.length); &#125; &#125;&#125; 安全发布在某些情况下我们希望在多个线程间共享对象，此时必须确保安全地进行共享。 不正确的发布：可见性出现问题例子：12345678910111213141516public Holder hoder;public void initialize() &#123; holder = new Holder(42);&#125;public class Holder &#123; private int n; public Holder(int n) &#123; this.n = n; &#125; public void assertSanity() &#123; if(n != n) &#123; throw new AssertionError("This statement is false"); &#125; &#125;&#125; 因为除了发布对象的线程外，其他线程可以看到的Holder域可能是一个失效值。 不可变对象与初始化安全性任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。 安全发布的常用模式要安全地发布一个对象，那它的引用和状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式安全地发布： 在静态初始化函数中初始化对象的引用 把对象的引用保存在volatile类型的域或者AtomicReference对象中 将对象的引用保存到某个正确构造的final对象的域中 将对象的引用保存到一个由锁保护的域中 使用静态初始化函数通常是最简单最安全的发布方式:1public static Holder holder = new Holder(42); 静态初始化器由JVM在类的初始化阶段执行，由于JVM内部存在在同步机制，因此通过这种方式初始化的任何对象都哦可以被安全发布。 事实不可变对象如果对象在技术上来看是可变的，但其状态在发布之后不会再改变，那么这种对象成为“实际不可变对象”，在这些对象发布之后，程序之需要将它们视为不可变对象即可。所以如果确认某些对象是实际不可变对象，就可以简化开发减少同步从而提升性能。 可变对象如果对象在构造后可以被修改，那么安全发布只能确保这个对象在发布当时状态的可见性，为了保证线程安全，就需要在每次对象访问时也使用同步来确保后续修改操作的可见性。对象的发布方式取决于它的可变性： 不可变对象可以通过任何机制来发布； 事实不可变对象必须通过安全方式来发布 可变对象必须通过安全方式来发布，并且必须是线程安全的或由某个锁保护起 安全的共享对象在并发程序中使用共享对象是，可以使用一些实用的策略： 线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。 只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和实际不可变对象。 线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。 保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。 总结由于对象需要共享，所以要注意发布的安全性，以及对不可以变对象的合理应用。 参考 《Java并发编程实战》 java并发编程实践学习（四）对象的发布和逸出之this逃逸]]></content>
      <categories>
        <category>Java并发编程实战</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发_1_线程安全性]]></title>
    <url>%2F2018%2F01%2F12%2FJava%E5%B9%B6%E5%8F%91-1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%2F</url>
    <content type="text"><![CDATA[引：要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对“共享的(Shared)”和“可变的(Mutable)”状态的访问。而对象的状态是指存储在状态变量（类变量和成员变量）中的数据。“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期可以发生变化。 什么是线程的安全性线程安全性简单点说就是所见即所知，这是对正确性的认识。在书中还有一个比较长的定义： 当多个线程访问某个类时，不管运行时环境采用何种调度方法或者这些线程将如何交替执行， 并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确地行为， 那么这个类是线程安全的。 自己再开始也简单介绍了对象的状态，这里需要明确一点： 无状态的对象一定是线程安全的。 原子性 原子操作：不可再分割为几个操作的操作 竞态条件：由于不恰当的执行时序而出现不正确的结果（不是原子操作引起的） 竞态条件的类型： 先检查后执行，例如延迟初始化 读取-修改-写入，例如统计命中数操作 复合操作：将几个操作变为一个原子操作，在java.util.concurrent.atomic包中包含了一些原子变量类，用于实现在数值和对象引用上的原子状态转换。 在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。 加锁机制要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。 内置锁Java提供了一种内置的锁机制来支持原子性：同步代码块。同步代码块包括两部分：一个“作为锁”的对象引用，一个“作为由这个锁保护”的代码块。这个锁称为内置锁或监视器锁。线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁。Java的内置锁相当于一种互斥体，最多只有一个线程能够持有这种锁。由于每次只能有一个线程执行内置锁保护的代码块，因此，有这个锁保护的同步代码块会以原子方式执行。 重入内置锁是可重入的，如果某个线程试图获得一个已经有它自己持有的锁，这个请求将会成功，“重入”意味着获取锁的操作的粒度是“线程”。 重入的一种是实现方法是：为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减，当计数值为0时，这个锁将被释放。 用锁来保护状态 只把复合操作包装在synchronized块中并不够，如果对一个变量的访问需要使用同步，那所有访问该变量的地方都要加上同步。而且在使用锁来实现对变量的同步时，所有访问该变量的地方都要使用同一把锁。 获取一个对象关联的锁并不能阻止其他线程访问该对象，只有所有线程都获取的是相同的锁才能确保该对象被串行访问。所以每个共享的可变变量要被同一把锁保护。并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。 一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码进行同步，使得在该对象上不会发生并发访问。 活跃性与性能这里展示两个代码： 利用同步方法实现锁的代码：1234567891011121314151617181920import java.math.BigInteger;public class SynchronizedFactorizer implements Servlet &#123; @GuardedBy(this) private BigInteger lastNumber; @GuardedBy(this) private BigInteger[] lastFactors; public synchronized void service(ServletRequest req, ServletResponse resp) &#123; BigInteger i = extractFromRequest(req); if(i.equals(lastNumber)) &#123; encodeIntoResponse(resp, lastFactors); &#125; else &#123; BigInteger[] factors = factor(i); lastNumber = i; lastFactors = factors.clone(); encodeIntoResponse(resp, factors); &#125; &#125;&#125; 通过缩小同步代码块的作用范围实现锁的代码：123456789101112131415161718192021222324252627282930313233343536373839import java.math.BigInteger;import com.sun.org.apache.bcel.internal.generic.IF_ACMPEQ;@ThreadSafepublic class CachedFactorizer implements Servlet&#123; @GuardedBy(this) private BigInteger lastNumber; @GuardedBy(this) private BigInteger[] lastFactors; @GuardedBy(this) private long hits; @GuardedBy(this) private long cacheHits; public synchronized long getHits() &#123; return hits; &#125; public synchronized double getCachedHits() &#123; return (double)cacheHits /(double) hits; &#125; public void service(ServletRequest req, ServletResponse resp) &#123; BigInteger i = extractFromRequest(req); BigInteger[] factors = null; synchronized (this) &#123; ++hits; if(i.equals(lastNumber)) &#123; ++cacheHits; factors = lastFactors.clone(); &#125; &#125; if(factors == null) &#123; factors = factor(i); //花费时间长的代码不要持有锁，相当于两个同步代码块的界限 synchronized (this) &#123; lastNumber = i; lastFactors = factors.clone(); &#125; &#125; encodeIntoResponse(resp, factors); &#125;&#125; 要判断同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性（这个需求必须要满足）、简单性和性能。我们需要权衡。 tip：当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。 总结安全性需要保证，活跃性和性能也要在权衡之中。 参考 《Java并发编程实战》]]></content>
      <categories>
        <category>Java并发编程实战</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生之语言与数学]]></title>
    <url>%2F2018%2F01%2F11%2F%E4%BA%BA%E7%94%9F%E4%B9%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[引：其实最近自己一直都在准备考试，结果突然脑海出现了关于对人生的杂想（可能想的高度太高了），自己没有及时写下来，现在基本上考完了，所以就想认真谈一下自己的思考。 人生我想大部人都是想着成功得过完这一生的，但是每个人都会迷茫，都会在某个时刻不知道自己想要什么，或者该怎么做。我想简单得把世界上的人归为这样两类。 话人生这里有一类人他们是靠情商和努力来获得成功的，说的通俗点就是走上行政或者做生意的，这类人对我们的世界是十分重要的，能说会道的人在哪都能吃得开吧。 行政人生行政现在对学历的要求也越来越高了，所以不管怎么样，我觉得这样的人还是要对考试保持敬畏，我个人觉得锻炼应试能力是十分有必要的，因为在升学或者入职，这都将起着置关重要的作用，我想也许不用把每块知识都弄的那么深，那么透，反而应该是学会总结，学会归类，学会预测以便花最少的时间或者最佳的结果。这里要提一下就是我们从小的学的语文这门科目了，不能说它多有用，但是对于提高我们的文笔还是很有帮助的，还有就是书写能力也会显得十分重要。 生意人生做生意或者说做销售，其实大部分的人都能感觉到实业越来越难做了，或者说是太稳固，墙外面的人很难挤进去，反而随着互联网的发展，线上的生意火好一些。这只是一种形式。真正想做大做好，你除了能说会道，我想掌握一口标准的普通话和一口流利的英语口语对生意的广度和未来都会有很好的帮助，所以语言能力需要好好的get。 学人生还有这一种人那就是通过学习和努力来改变人生，或者说是走技术路线的，当然这里也会分为两种人。 科研人生世界需要进步，那进步从何而来，我想其中的核心是来自一部分占比不高的人（科学家，至少是个博士吧）的努力。这里数学就会显得那么重要。当然数学会分很多方面，之前听到过一种说法就是数学其实一门哲学，信了它就是对的，不信它就是错的。说的其实也是十分的有道理，数学的对错其实是相对的，不是绝对的，要根据所处的领域基础，但是对于大部分我们所认识到的数学大多数还是同一个基础，就是我们大部分人从小到大所学的数学。然后我想说说自己对于数学的认知，我想说数学其实是一个工具，它对于无论是哪方面的科研都是很重要的，无论是工科还是经济学科。所以也就诞生了那么多交叉学科。这里又想提到计算机科学，其实计算机科学在科研方便起到的只是减少人类的工作量以及提高人所需要的计算能力。就像大数据其实是属于统计学科，但是结合到计算机，那么就变成了计算机的热门学科了。 经验人生世界的进步需要科学家，但是也少不了靠经验解决问题的专家，比如架构师，我想大概就是通过不断的实践来提高自己的解决问题的能力，而这不需要多好的科研能力或者说绝对的创新能力，只要多做多想，学会快又准确地解决问题就好了。我相信大部分人的智商都是差不多的，所以想在经验人生上取的小小的成功，真的是需要花很多时间来提升自己的经验。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_14_线程安全与锁优化]]></title>
    <url>%2F2017%2F12%2F14%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-14-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[引：面向对象的编程思想极大的提升了现在软件开发的生产效率和软件可以达到的规模，但是现实中对象在一项工作进行期间，会被不停地中断和切换，对象的属性可能会在中断期间被修改和变“脏”，所以我们在谈“高效并发”之前必须先保证并发的正确性和如何实现线程安全。 线程的安全在《Java Concurrency In Practice》一书中这样定义线程安全：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下得调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确地结果，那这个对象是线程安全的。 它要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无需关心多线程的问题，更无需自己采用任何措施来保障多线程的正确调用。 Java语言中的线程安全在讨论线程安全的时候，都会限定于多个线程之间存在共享数据访问这个前提，我们按照线程安全的“安全程度”由强至弱来排序，可以将Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。 不可变在Java语言中，不可变对象一定是线程安全的，无论是对象的方法实现还是方法调用者都不需要在采取任何的线程安全保障措施。 Java语言中，如果共享数据是一个基本类型数据，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行。如String类、枚举类等（有需要继续探究的可以去看看这些类的源码），保证对象行为不影响自己状态最简单的途径就是讲对象带有状态的变量都声明为final。 绝对线程安全绝对线程安全需要完全满足《Java Concurrency In Practice》一书对线程安全的定义。这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不要任何额外的同步措施”通常需要付出很大的代价，在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。 相对线程安全相对线程安全就是我们通常意义上的线程安全，它需要保证这个对象单独操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的联系调用，就可能需要在调用端使用额外的同步手段来保障调用的正确性。下面就展示java.util.Vector（Vector只是加了个方法锁，保证一个时间只能调用方法一次）这个线程安全的容器的不安全可能，。123456789101112131415161718192021222324252627282930313233343536// 错误代码public class VectorTest &#123; private static Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); public static void main(String[] args) &#123; while (true) &#123; for (int i = 0; i &lt; 10; i++) &#123; vector.add(i); &#125; Thread removeThread = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125;); Thread printThread = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; System.out.println(vector.get(i)); &#125; &#125; &#125;); removeThread.start(); printThread.start(); while (Thread.activeCount() &gt; 20); &#125; &#125;&#125; 运行分析：我在自己机器上没有发生异常，但是按照作者所说的是应该会出现数组越界异常的，这是因为如果另一个线程恰好在错误的时间删除了一个元素，导致序号为i已经不再可用的话，再用i访问数组就会抛出一个ArrayIndexOutOfBoundsException，如果要保证这段代码能正确执行下去，需要改成如下代码：12345678910111213141516171819202122232425262728293031323334353637383940// 对vector操作加上锁public class VectorTest &#123; private static Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); public static void main(String[] args) &#123; while (true) &#123; for (int i = 0; i &lt; 10; i++) &#123; vector.add(i); &#125; Thread removeThread = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (vector) &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125; &#125;); Thread printThread = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (vector) &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; System.out.println(vector.get(i)); &#125; &#125; &#125; &#125;); removeThread.start(); printThread.start(); while (Thread.activeCount() &gt; 20); &#125; &#125;&#125; 在Java语言中，大部分线程安全类都属于这种类型，例如Vector、HashTable等。 线程兼容线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全使用，我们平常说的一个类不是线程安全的，绝大多数时候是指这一种情况。Java API中大部分的类都是属于线程兼容的，如与前面Vector和HashTable相对应的集合类ArrayList和HashTable等。 线程对立线程对立是指无论调用端是否采取了同步措施，都无法再多线程环境中并发使用代码，大部分原因是会产生死锁。 线程安全的实现方法线程安全的实现是通过代码编写以及利用虚拟机提供的同步和锁机制，而我们这主要是说一下虚拟机线程安全手段的运作过程。 互斥同步（阻塞同步）同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、信号量（都没用过）、互斥量都是主要的互斥实现方式。互斥是因，同步是果；互斥是方法，同步是目的。主要的互斥同步手段有下面两种： 使用synchronizd关键字，synchronized关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这个两个字节码指令，这两个字节码都需要一个 reference类型的参数来指明要锁定和解锁的对象；如果java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。在执行monitorenter指令时，如果这个对象没有锁定或当前线程已经拥有了那个对象的锁，锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1；当计数器为0时，锁就被释放了。对于monitorenter 和 monitorexit的行为描述中，有两点需要注意： synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。 同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。 使用java.util.concurrent（J.U.C）包中的重入锁（ReentrantLock）。synchronized 和 ReentrantLock 的区别： 一个表现为 API 层面的互斥锁（lock() 和 unlock() 方法配合 try/finally语句块来完成），另一个表现为原生语法层面的互斥锁；ReentrantLock增加了一些高级功能主要有以下3项： 等待可中断：指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮 助 。 公平锁：指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。 锁绑定多个条件：指一个 ReentrantLock对象可以同时绑定多个 Condition对象，而在 synchronized中，锁对象的wait() 和 notify() 或 notifyAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock 则无需这样做，只需要多次调用 newCondition() 方法即可。 关于两者的性能在JDK1.6以后，两者基本持平了，所以提倡在synchronized能实现需求的情况下，优先考虑使用sychronized来进行同步锁。 非阻塞同步 阻塞同步与非阻塞同步的对比：阻塞同步是一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁）就会出现问题，所以会带来进行线程阻塞和唤醒的性能问题；非阻塞同步是一种基于冲突检测的乐观的并发策略，它是先进行操作，如果没有其他线程争用共享数据，那操作就是成功的，如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止）。 非阻塞同步需要硬件指令集的发展：因为需要保证操作和冲突检测这两个步骤具备原子性，而这里原子性的实现是通过一条处理器指令完成的。这类指令常用的有： 测试并设置 获取并增加 交换 比较并交换（Compare-and-set,CAS） 加载链接/条件存储 我们可以从J.U.C下得原子类的操作来证明这一点。 无同步方案如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。下面介绍两类线程安全代码： 可重入代码（纯代码）：，可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。如何判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。 线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能够保证在同一线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程内，这样，无需同步也可以保证线程间不出现数据争用问题。 锁优化各种锁优化技术都是为了在线程之间更加高效地共享数据，以及解决竞争问题。 自旋锁 为什么需要自旋锁：互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程很不值得。 什么是自旋锁：为了让线程等待，我们只需让线程执行一个忙循环（自旋）而不放弃处理器时间，这项技术就是所谓的自旋锁。 自旋时间有一定限度：如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10，用户可以用参数 -XX:PreBlockSpin 来更改。 自适应自旋锁：jdk1.6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定； 锁消除锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检查到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据：来源于逃逸分析的数据支持，如果判定在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行了。其中很多无用的同步措施都是Java API自带的。 锁粗化如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。 轻量级锁 轻量级锁：使用操作系统互斥量来实现的传统锁通常被称为重量级锁，而这个轻量级锁的出现就是是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 HotSpot虚拟机头Mark Word：它是实现轻量级锁和偏向锁的关键，它的内容如下表： 存储内容 标志位 转态 对象哈希码、对象年龄分代 01 未锁定 指向所记录的指针 00 轻量级锁定 指向重量级锁的指针 10 膨胀（重量级锁定） 空，不需要记录信息 11 GC标记 偏向线程ID、偏向时间戳、对象分代年龄 01 可偏向 在进入同步代码块时，轻量级锁加锁过程： 如果此同步对象没有被锁定（锁标志位为01状态）：虚拟机首先将在当前线程的栈帧中建立一个名为锁记录的空间，用于存储对象目前的Mark Word的拷贝（Displace Mark Word）。 然后，虚拟机将使用CAS 操作尝试将对象的 Mark Word 更新为指向Lock Record的指针。 如果这个更新工作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为 00，即表示此对象处于轻量级锁定状态； 如果这个更新失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象以及被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为 10，Mark Word中存储的就是指向重量级（互斥量）的指针，后面等待锁的线程也要进入阻塞 状态。 轻量级锁解锁过程： 如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS 操作把对象当前的Mark Word和线程中复制的 Displaced Mark Word替换回来。 如果替换成功，整个同步过程就完成了。 如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。 轻量级锁能提升程序同步性能的依据是：对于绝大部分的锁，在整个同步周期内都是不存在竞争的。 偏向锁 偏向锁的目的：消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS 操作都不做了。 偏向锁的偏：它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。 偏向锁过程：若当前虚拟机启用了偏向锁，那么，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为01，即偏向模式；同时使用CAS操作把获取到这个锁的线程的ID 记录在对象的 Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。当有另一个线程去尝试获取这个锁时，偏向模式就结束了，根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定（标志位为01）或轻量级锁定（标志位为00）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。 偏向锁是一个带有效益权衡性质的优化：偏向锁可以提高带有同步但无竞争的程序性能，但是如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式是多余的。 总结关于线程安全我们可以有明确的定义，然后我们也知道了线程安全的实现方式，以及虚拟机为我们提供的各种锁优化。 参考 《深入理解Java虚拟机》]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_13_Java内存模型与线程]]></title>
    <url>%2F2017%2F12%2F13%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-13-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[引：并发处理的广泛应用是使得阿姆德尔定律替代摩尔定律成为计算机性能发展原动力的根本原因。由于计算机的运算速度和它的存储和通信子系统速度差距太大，所以才出现了并发，而并发绝对是Java运用很大的优势。我们绝对需要理解！ 硬件的效率与一致性由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的告诉缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步到内存之中，这样处理器就无须等待缓慢的内存读写了。 基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为引入了一个新的问题：缓存一致性。为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。下面是常用的内存模型图： 除了增加高速缓存之外，为了使得处理器的内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化。 Java内存模型目的：让Java程序在各种平台下都能达到一致的内存访问效果。 主内存与工作内存Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java编程中所说的变量有所区别，它包括实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享。 Java内存模型规定了所有的变量都存储在主内存中（此处的主内存与介绍物理硬件时的主内存可以类比，但是此处仅仅是虚拟机内存的一部分）。每条线程都有自己的工作内存（可以与处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图： 这里的Java内存模型如果和Java运行时内存勉强对应，可以这样理解：主内存主要对应Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存直接对应于物理硬件内存，而工作内存优先存储于寄存器和高速缓存中。 内存间的交互操作Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。 lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。 write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。 如果要把一个变量从主内存复制到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按照顺序地执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证必须是连续执行。Java内存模型规定了在执行上述八种基本操作时必须满足时必须满足如下规则： 不允许read和load、store和write操作之一单独出现。 不允许一个线程丢弃它的最近的assign操作。 不允许一个线程无原因的（没有发生过任何assign操作）把数据从线程的工作内存同步到主内存中 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 如果一个变量事先没有被lock锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定住的变量。 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write）。 这8种内存访问操作以及上述规则限定，再加上volatile的一些特殊规定，就已经完全确定了Java程序中哪些内存访问操作是并发是安全的。 对于volatile修饰的变量的特殊规则关键字volatile是Java虚拟机提供的最轻量级的同步机制。Java内存模型堆volatile专门定义了一些特殊的访问规则。当一个变量定义为volatile之后，它将具备以下两种特性： 保证此变量对所有线程的可见性：当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性。 运算结果不依赖变量的当前值，或者只能保证只有单一的线程来保证原子性。 变量不需要与其他状态变量共同参与不变约束。（目前不理解） 禁止指令重排序优化：如果有两个或者更多CPU访问同一块内存，且其中有一个在观测另一个，那么它会通过设置内存屏障来使重排序时不能把后面的指令重排序到内存屏障之前访问。 volatile的意义：volatile变量读操作的消耗与普通变量几乎没有什么差别，但是写操作则可能慢一点，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，不过即便如此，大多数场景下volatile得总开销仍然比锁低。 volatile的特殊规则就是：use/assign、load/store、read/write操作必须连续一起出现，即volatile修饰的变量不会被指令重排序优化。 对于long和double类型的变量的特殊规则Java内存模型要求对于lock、unlock、read、load、assign、use、store和write这八个操作都具有原子性，但是对于64位的数据类型（long和double），允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，但是强烈建议虚拟机实现为具有原子性的操作。 原子性、可见性与有序性原子性由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为基本数据类型的访问读写是具备原子性的。synchronized关键字可以实现原子性。 可见性可见性就是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。volatile、synchronized以及final关键字都能实现可见性。 有序性Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。volatile和synchronized关键字都能实现有序性。 先行发生原则先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了小写、调用了方法等。 下面是Java内存模型下一些“天然的”先行发生关系，这些先行发送关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，他们就没有顺序性保障，虚拟机可以对它们进行随意重新排序： 程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前的操作先于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。 管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。 volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。“后面”是指时间上的先后顺序。 线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。 线程终止规则（Thread Termination Rule）：线程中所有操作都先行发生于此线程的终止检测。 线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得到操作A先行发生于操作C。 Java与线程在Java里面谈论并发，大多数都与线程脱不开关系。我们需要知道在Java线程在虚拟机的实现。 线程的实现线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源，又可以独立调度（线程是CPU调度的基本单位）。 实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级线程混合实现。 Java线程调度线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。 协同式线程调度：线程的执行时间由线程本身来控制，线程把自己的工作执行完毕后，要主动通知系统切换到另一个线程上去。好处是实现简单，没有线程同步问题；缺点是：线程执行时间不可控制，容易导致整个系统崩溃。 抢占式线程调度：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。好处是线程执行之间可控，不会有一个线程导致整个进程阻塞的问题，Java使用的线程调度方式就是抢占式调度。这里说一下就是java线程优先级不太靠谱，原因是Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统。 线程状态转换Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别是：新建，运行，无限期等待，限期等待，阻塞，结束。上述5种状态在遇到特定时间发生的时候回互相转换，他们的转换关系如下图： 总结虚拟机本身具有一套和线程相关内存模型，我们需要利用好它，特别是要理解线性发生原则以及volatil的一些特殊规则。 参考 《深入理解Java虚拟机》 Java内存模型]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_12_晚期（运行期）优化]]></title>
    <url>%2F2017%2F12%2F12%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-12-%E6%99%9A%E6%9C%9F%EF%BC%88%E8%BF%90%E8%A1%8C%E6%9C%9F%EF%BC%89%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[引：之前说过Java中的JIT即时编译器在运行期的优化对于程序运行来说更重要，那我们就来看看这个即时编译器。本文提及的编译器、即时编译器都是指HotSpot虚拟机内的即时编译器，虚拟机也特指HotSpot虚拟机。 什么是即时编译器在部分的商用虚拟机中，Java程序最初是通过解释器来解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”（Hot Spot Code）,为了提高 热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器 称为即时编译器（Just In Time Compiler,简称JIT编译器）。 HotSpot虚拟机内的即时编译器为什么要使用解释器与编译器并存的架构 解释器与编译器各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获得更高的执行效率，当程序运行环境中内存资源限制较大时，可以使用解释执行节约内存，反之可以使用编译执行来提高效率。 解释器可以作为编译器激进优化时的一个“逃生门”，可以通过逆优化退回到解释器状态继续执行。 HotSpot虚拟机内置编译器 Client Compiler(C1编译器)：使用“-client” 参数去强制指定虚拟机运行在Client模式。 Server Compiler(C2编译器)：使用“-server” 参数去强制指定虚拟机运行在Server模式。 虚拟机默认采用解释器与编译器搭配使用的方式（混合模式）。为了在程序响应速度和运行效率之间达到最佳平衡，HotSpot虚拟机会逐渐启用分层编译策略： 第0层：程序解释执行，解释器不开启性能监控功能，可触发第1层编译。 第1层：也称为C1编译，将字节码编译为本地代码，进行简单，可靠的优化，如果必要将加入性能监控的逻辑。 第2层（或2层以上）：也称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。 编译对象与触发条件编译对象（热点代码） 被多次调用的方法（JIT编译方式） 被多次执行的循环体（OSR编译方式） 热点探测 基于采样的热点探测：虚拟机周期地检查各个线程的栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。优点是实现简单、高效，还可以很容易获取方法的调用关系（将调用堆栈展开即可），缺点就是很难精确得确认一个方法的热度，容易因为受到线程阻塞或者别的外界因素的影响而扰乱热点探测。 基于计数器的热点探测：虚拟机会每一个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认定它是“热点方法”。缺点是实现麻烦，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，优点是统计结果更加精确和严谨。 在HotSpot虚拟机中使用的是基于计数器的热点探测方法。因此它为每个方法准备了两类计数器：方法调用计数器（用于探测方法）和回边计数器（用于探测循环体）。这两个计数器都有一个确定的阈值，当计数器超过了阈值，就会提交编译请求。 编译过程在默认设置下，无论是方法调用产生的即时编译请求，还是OSR编译请求，虚拟机代码编译器还未完成之前，都依然将按照解释方式继续执行，而编译动作则在后台的编译线程中进行。 Client Compiler它是个三段式编译器，主要关注点在局部性的优化，放弃了许多耗时较长的全局优化手段。下面是三个阶段 字节码-&gt;高级中间代码（HIR）:使用静态单分配的形式来代表代码值，其中会完成方法内联、常量传播等优化。 HIR-&gt;低级中间代码（LIR）：会在HIR上完成空值检查消除、范围检查消除等优化，以便让HIR达到更高效的代码的表示形式。 LIR-&gt;机器代码：在平台相关的后端使用线性扫描算法在LIR上分配寄存器，并在LIR上做窥孔优化。 Server Compiler它是专门面向服务端的典型应用并为服务器端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器。它会执行所有经典的优化工作。它的寄存器分配器是一个全局图着色分配器，可以充分利用某些处理器架构上的大寄存器集合。 查看及分析即时编译结果这一块我没有去实践，但是这里写一个结论：在Java中空循环不能用作程序延时的手段，因为空循环会被优化消除。 编译优化技术Java程序员有一个共识：以编译方式执行本地代码比解释方式更快。这主要是因为虚拟机设计团队几乎把对代码的所有优化措施都集中在编译器之中了。关于HotSpot的优化技术列表可以参考《深入理解Java虚拟机》一书，这里也根据书上举的几个例子来看看其中的优化技术。 公共子表达式消除含义是：如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有的变量的值都没有发生变化，那么E的这次出现就成为了公共子表达式。对于这种表达式，没有必要花时间再对它进行计算，只需要直接用前面计算过的表达式结果代替E即可。可以看看下面的优化历程：12345678// 源代码int d = (c * b) * 12 + a + (a + b * c);// 编译器检测到“c * b”和“b * c”是一样的表达式，这条表达式就变成下面这样了int d = E * 12 + a + (a + E);// 编译器还可能进行代数简化，把表达式变为：int d = E * 13 + a * 2; 大家肯定能发现，最后的表达式计算起来就可以节省时间了。 数组边界检查消除含义：虚拟机执行子系统每次数组的读写都带有一次隐含的条件判断操作，这对于拥有大量 数组访问的程序代码，无疑是一种性能负担。解决思路除了将数组边界检查优化尽可能把运行期检查提到编译期完成之外，还有另一种思路——隐式异常处理（try - catch）。可以看看代码：12345678910111213// 源代码if (foo != null) &#123; return foo.value&#125; else &#123; throw new NullPointException();&#125;// 编译器转换代码try &#123; return foo.value;&#125; catch(segment_fault) &#123; uncommon_trap();&#125; 这样可以避免每次去做非空检查。 方法内联它除了消除方法调用成本之外，它更重要的是位其他优化手段建立良好的基础，如果不做内联，就发现不了无用代码。。内联具有两种情况： 对于非虚方法：直接内联 对于虚方法：会使用“类型继承关系分析”（CHA）技术，虚拟机如果遇到虚方法就会向CHA查询此方法在当前程序下是否有多个目标版本可供选择，如果查询结果只有一个版本，就可以进行内联，不过这种内联属于激进优化，需要余留一个“逃生门”，称为守护内联；如果查出有多个版本的目标方法可供选择，则编译器还会使用内联缓存来完成方法内联。 逃逸分析它也是为其他优化手段提供依据的技术，它的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。甚至还有可能被外部线程访问到，例如复制给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。 如果能证明一个对象不会逃逸到方法或者线程之外，则可能为这个变量进行一些高效的优化： 栈上分配：让对象直接在栈上分配内存，这样大量对象就会随着方法的结束而自动销毁了，垃圾收集系统的压力将会小很多。 同步消除：对变量实施的同步措施可以消除掉 标量替换：不能再分解的量称为标量（如：数值类型），可以继续分解的称为聚合量（如：对象），我们可以直接将对象拆分成标量存在栈上。 总结通过对于JIT编译的学习，我么可以知道哪些代码编译器是可以帮我们优化的，以及哪些代码是需要自己调节以便更合适编译器的优化。这样我们才可以写出更高效的代码。 参考 《深入理解Java虚拟机》]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_11_早期（编译期）优化]]></title>
    <url>%2F2017%2F12%2F10%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-11-%E6%97%A9%E6%9C%9F%EF%BC%88%E7%BC%96%E8%AF%91%E6%9C%9F%EF%BC%89%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[引：之前简单的提到过java程序的使用首先要经过编译，然后再“解释”执行，这里我们就先看看它在编译期的过程。 编译概述java的编译期其实是一段“不确定”的操作过程，它有一下几种形式： 前端编译器：把.java文件转变为.class文件的过程，如：Sun的javac、Eclipse JDT中的增量式编译器。 虚拟机的后端运行期编译器（JIT编译器）：把字节码转变成机器码的过程，如HotSpotVM的C1、C2编译器。 静态提前编译器（AOT编译器）：直接把*.java文本编译为本地机器代码的过程：GNU Compiler for the Java、Excelsior JET。 我们平时所说的编译基本上都是指第一类，前端编译器。总的来说，Java中的JIT即时编译器在运行期的优化对于程序运行来说更重要，而前端编译器在编译器的优化过程对于程序编码来说关系更密切，相当多新生的Java语法特性，都是靠编译器的“语法糖”来实现的。 Javac编译器编译过程大致分为3个过程： 解析与填充符号表过程 插入式注解处理器的注解处理过程 分析与字节码生成过程 这3个过程之间的关系与交互顺序如下图： 解析与填充符号表过程其中解析步骤包括了经典程序编译原理找那个的词法分析和语法分析两个过程。 词法、语法分析 词法分析：将源代码的字符流转变为标记（Token）集合，单个字符是程序编写过程的最小元素，而标记是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记。 语法分析：根据Token序列构造抽象语法树，抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、运算符、接口、返回值甚至代码注释都可以是一个语法结构。如下图： 经过上面两个步骤编译器就基本不会再对源文件进行操作了。 填充符号表 符号表是由一组符号地址和符号信息构成的表格，类似k-v形式。符号表中登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。 在Java源代码中，填空符号表过程的出口是一个待处理列表，包含了每一个编译单元的抽象语法数的顶级节点，以及package-info.java（如果存在）的顶级节点。 注解处理器JDK1.6之中提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，可以把它看做是一组编译器插件，在这些插件中，可以读取、修改、添加抽象语法树中的任意元素。若这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round。如编译过程图的回环过程。 语义分析与字节码生成语法分析之后，编译器获得程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的，而语义分析的主要任务是对结构上正确地源程序进行上下文有关性质的审查，如类型审查。语义分析过程分为标注检查以及数据及控制流分析两个步骤。 标注检查标注检查步骤检查的内容包括诸如变量使用前是否已被声明，变量与赋值之前的数据类型能否匹配，还有一个重要的动作是常量折叠，如果我们在代码写了如下定义：1int a = 1 + 2; 在经过变量折叠之后，1 + 2会被折叠为字面量3。所以在代码里定义int a = 1 + 2比起直接定义int a = 3并不会增加程序运行期的运算量。 数据及控制流分析数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受检异常都被正确处理了等问题，编译期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或者运行期才能进行，如方法的参数以及局部变量的检查就只会在编译器检查。 解语法糖 语法糖：指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，当时更方便使用，Java最常用的语法糖主要有泛型、变长参数、自动装箱、拆箱等 解语法糖：虚拟机运行时不支持这些语法，他们会在编译阶段还原回简单的基础语法结构。 字节码生成字节码生成是Javac编译过程的最后一个阶段，此阶段编译器还进行了少量的代码添加和转换工作。实例构造器()（不是默认构造函数）和类构造器()就是在这个阶段添加到语法树中的。完成了对语法树的遍历和调整之后，生成最终的Class文件。 Java语法糖的味道泛型与类型擦除 本质：参数化类型的应用，就是所操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法上，分别称为泛型类、泛型接口和泛型方法。 提出原因：先看下面的代码 12Object object = new Object();String str = (String)object; 由于编译器无法检查这个Object强制转换能否成功，为了防止保障强制类型的转换成功，避免ClassCaseException的风险转嫁到程序运行期之中，所以提出了泛型。 真实泛型：参数化类型无论在源码中还是编译后的中间语言都是存在的。 伪泛型：参数化类型只在源码中存在，而在中间语言不存在。可以看到下面的例子： 123456789101112// 泛型擦除的例子public class GenericTest &#123;public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put("hello", "您好"); map.put("how are you?", "最近怎么样？"); System.out.println(map.get("hello")); System.out.println(map.get("how are you?")); &#125;&#125; 利用Beyond Compare反编译可以得到下面的代码: 123456789101112// 反编译后的代码public class GenericTest &#123;public static void main(String[] args) &#123; Map map = new HashMap&lt;&gt;(); map.put("hello", "您好"); map.put("how are you?", "最近怎么样？"); System.out.println(map.get("hello")); System.out.println(map.get("how are you?")); &#125;&#125; 有人可能像我一样，用jd反编译，发现泛型没有被擦除，我一开始很惊讶，后来找了参考，大家可以从参考部分看到该现象的解释，这里需要说明一点，就是由于Java泛型的引入，各种场景（虚拟机解析、反射等）下的方法调用都可能对原有的基础产生影响和新的需求，所以JCP（Java Community Process）组织对虚拟机规范做出了相应的修改，引入了诸如Signature、LocalVariabelTypeTable等新的属性用于解决伴随泛型而来的参数类型识别问题，从Signature属性的出现我们还可以得出结论：擦除泛型所谓的擦除，仅仅是对方法的Code属性中的字节码进行删除，实际上元数据中还是保留了泛型信息。 自动装箱、拆箱与遍历循环我们可以看看这些语法糖，编译的过程中做了什么处理：12345678910111213// 源代码public class BoxProcessTest &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4); int sum = 0; for (int i : list) &#123; sum += i; &#125; System.out.println(sum); &#125;&#125; 12345678910111213141516// 反编译后的代码public class BoxProcessTest&#123; public static void main(String[] args) &#123; List list = Arrays.asList(new Integer[] &#123; Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3), Integer.valueOf(4) &#125;); int sum = 0; for (Iterator localIterator = list.iterator(); localIterator.hasNext();) &#123; int i = ((Integer)localIterator.next()).intValue(); sum += i; &#125; System.out.println(sum); &#125;&#125; 我们清楚的看到其实语法糖的最后还是用最基本的语法实现的，只是更利于我们写代码了。 再来看看自动装箱的陷阱：1234567891011121314151617public class BoxTest &#123; public static void main(String[] args) &#123; Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g= 3L; System.out.println(c == d); //true System.out.println(e == f); //false，如果Integer在-128到127之间会保存到常量池，此时Integer直接等于数字 System.out.println(c == (a + b)); //true System.out.println(c.equals(a + b)); //true System.out.println(g == (a + b)); //true System.out.println(g.equals(a + b)); //false &#125;&#125; 如果你对上面分不清楚的话，加上鉴于包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱，以及它们的equals()方法不处理数据类型转型的关系，建议在实际编码找那个尽量避免这样使用自动装箱与拆箱。 条件编译Java语言实现条件编译的方法是使用条件为常量的if语句，案例如下：123456789101112// 源代码public class ConditionCompilerTest &#123; public static void main(String[] args) &#123; if (true) &#123; System.out.println("block 1"); &#125; else &#123; System.out.println("block 2"); &#125; &#125;&#125; 123456789// 反编译代码public class ConditionCompilerTest&#123; public static void main(String[] args) &#123; System.out.println("block 1"); &#125;&#125; 我们很清楚的看到编译后的代码就只剩true里面的代码块了，从而实现了条件编译。 总结通过上面的学习，我们可以从编译器的层次上了解Java源代码编译为字节码的过程，以及各种语法糖的前因后果。 参考 《深入理解Java虚拟机》 早期（编译期）优化 关于java泛型擦除反编译后泛型会出现问题]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_10_虚拟机字节码执行引擎]]></title>
    <url>%2F2017%2F12%2F09%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-10-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[引：我们知道方法的代码的字节码是放在方法区的Code属性表里面，但是里面的字节码是怎么执行我们却不知道，这里通过理解虚拟机字节码执行引擎去看看这些字节码是怎么走的？ 概述物理机与虚拟机 物理机的执行引擎：直接建立在处理器、硬件、指令集、和操作系统层面上。 虚拟机的执行引擎：自己实现，可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。 虚拟机怎么执行代码 解释执行：通过解释器执行 编译执行：通过即时编译器产生本地代码执行 运行时栈帧结构栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，他是虚拟机运行时数据区中的虚拟机栈的栈元素，栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。 一个线程的方法的调用链可能会很长，很多方法同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法，执行引擎运行的字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如下图： 接下来具体解释一下栈帧中的局部变量表、操作数栈、动态链接以及方法调用。 局部变量表 局部变量表示一组变量值存储空间，用于存放方法和方法内部定义的局部变量。 局部变量表的容量以变量槽Slot为单位。虚拟机规范说每个Slot都应该存放一个boolean、byte、char、int、float、reference或returnAddress类型的数据。long和double使用两个Slot。 reference类型在虚拟机中至少要实现能从该引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引以及从该引用直接或者间接查找到对象所属数据类型在方法区中存储的类型信息。 虚拟机通过索引定位的方式使用局部变量表，如果执行的实例方法，那局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，可以使用“this”来访问，其余参数按照参数表顺序排列。 局部变量表中的Slot是可以重用的，当某个变量除了它的作用域，那这个变量所对应的Slot就可以复用了，Slot的复用会直接影响到系统的垃圾收集行为，如下代码所示： 123456789101112// 例1// VM args : -verbose:gcpublic class StackFrameTest &#123; public static void main(String[] args) &#123; byte[] placeholder = new byte[64 * 1024 * 1024]; System.gc(); &#125;&#125; 输出结果： 12[GC (System.gc()) 68209K-&gt;66072K(125952K), 0.0019584 secs][Full GC (System.gc()) 66072K-&gt;65962K(125952K), 0.0069900 secs] 123456789101112// 例2// VM args : -verbose:gcpublic class StackFrameTest &#123; public static void main(String[] args) &#123; &#123; byte[] placeholder = new byte[64 * 1024 * 1024]; &#125; System.gc(); &#125;&#125; 输出结果 12[GC (System.gc()) 68875K-&gt;66072K(125952K), 0.0010138 secs][Full GC (System.gc()) 66072K-&gt;65962K(125952K), 0.0069811 secs] 12345678910111213// 例3// VM args : -verbose:gcpublic class StackFrameTest &#123; public static void main(String[] args) &#123; &#123; byte[] placeholder = new byte[64 * 1024 * 1024]; &#125; int a = 0; System.gc(); &#125;&#125; 输出结果 12[GC (System.gc()) 68875K-&gt;66072K(125952K), 0.0016694 secs][Full GC (System.gc()) 66072K-&gt;426K(125952K), 0.0054452 secs] placeholde能否被回收的根本原因是：局部变量的Slot是否还存有关于placeholder数组对象的引用。例1没有垃圾回收，例2代码虽然已经离开了placeholder的作用域，但是之后没有任何对局部变量表的读写操作，所有placeholder原来的Slot还没有被其他变量复用，所以GC Roots一部分的局部变量表仍然保持着对它的关联，当例3修改了局部变量表，那么就会进行垃圾回收了。 这里解释一个编码建议：不使用的对象应手动赋值null 我们看看下面的代码： 123456789101112// 例1// VM args : -verbose:gcpublic class StackFrameTest &#123; public static void main(String[] args) &#123; byte[] placeholder = new byte[64 * 1024 * 1024]; placeholder = null; System.gc(); &#125;&#125; 输出结果： 12[GC (System.gc()) 68875K-&gt;66072K(125952K), 0.0016915 secs][Full GC (System.gc()) 66072K-&gt;426K(125952K), 0.0058140 secs] 我们可以看到当placeholder赋值为null，会发生垃圾回收。 局部变量表没有赋初始值不能使用。 操作数栈 操作数栈常被称为操作栈，一个方法刚开始执行的时候是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容，例如，在做算术运算的时候是通过操作数栈来 进行的，又或者是在调用方法的时候通过操作数栈来进行参数传递的。 在概念模型中，两个栈帧是完全独立的，但在大多虚拟机的实现里会做一些优化处理，令两个栈帧的部分操作数出现一部分重叠，避免方法调用时额外的参数复制，如下图： Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中的栈就是操作数栈。 动态链接 每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，持有这个引用就是为了支持方法调用过程中的动态链接。 Class文件的常量池存有大量的符号引用，一部分是在类加载中的解析阶段完成的，称为静态解析，另一部分是在每一次运行期间转化为直接引用，称为动态链接。 方法返回地址当一个方法开始执行后，只有两种方式退出这个方法。 正常完成出口：执行引擎遇到一个方法返回的字节码指令，调用者的PC计数器的值可以作为返回地址 异常完成出口：在方法执行过程中遇到异常，并且这个异常没有在方法体得到处理，它不会给调用者产生任何返回值，它的返回值是要通过异常处理器表来确定的。 方法调用方法调用不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本。Class文件的编译过程不包含传统编译找那个的链接步骤，所以Java方法调用过程需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。 解析解析： 方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用在运行期是不可变的，这类方法的调用成为解析。 所有方法可以分为两类虚方法和非虚方法，其中非虚方法都可以在类加载的时候就会把符号引用解析为该方法的直接引用。 非虚方法：静态方法、私有方法、实例构造器、父类方法和final方法 虚方法：与非虚方法相反 解析调用一定是个静态的过程，在编译器就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派调用则可能是静态也可能是动态的，根据分派的宗数量（方法的接收者与方法的参数统称为方法的总量）可分为单分派和多分派，这两种分派方式地组合可分为静态单分派、静态多分派、动态单分派、动态多分派。 分派静态分派1Human man = new Man(); 上面代码中Human称为变量的静态类型，或者叫做外观类型，后面的Man称为实际类型，静态类型是编译器可知，实际类型是运行期才能确定的。虚拟机在重载时是通过参数的静态类型而不是实际类型来作为判断依据的。 所有依赖静态类型来定位方法执行版本的分派动作称为静态分派，静态分派的典型应用是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的，另外，编译器虽然能确定出方法的重载版本，当在很多情况下这个重载版本不是“唯一的”，往往只能确定一个“更加合适的”版本，具体例子可以看看《深入理解Java虚拟机》。 动态分派在运行期根据实际类型确定方法执行版本的分派过程称为动态分派，典型应用是方法重写。它主要是通过invokevirturl指令来实现的。invokevirtual指令的运行时解析过程大致分为如下几个步骤： 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。 如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。 单分派和多分派单分派是根据一个宗量对目标方法进行选择，多分派则是根据一个宗量对目标方法进行选择。我们结合下面的代码来理解：12345678910111213141516171819202122232425262728293031323334public class Dispatch &#123; static class QQ &#123;&#125; static class _360 &#123;&#125; public static class Father &#123; public void hardChoice(QQ arg) &#123; System.out.println("father choose qq"); &#125; public void hardChoice(_360 arg) &#123; System.out.println("father choose _360"); &#125; &#125; public static class Son extends Father &#123; public void hardChoice(QQ arg) &#123; System.out.println("son choose qq"); &#125; public void hardChoice(_360 arg) &#123; System.out.println("son choose _360"); &#125; &#125; public static void main(String[] args) &#123; Father father = new Father(); Father son = new Son(); father.hardChoice(new _360()); son.hardChoice(new QQ()); &#125;&#125; 输出结果：12father choose _360son choose qq 编译阶段编译器的选择过程（静态分派过程）：这时选择目标方法的依据有两点：一是静态类型是Father还是Son，二是方法参数是QQ还是360。因为是根据两个宗量进行选择，所有Java语言的静态分派属于多分派类型。 运行阶段虚拟机的选择过程（动态分派过程）：由于编译器已经已经决定目标方法的签名必须为hardChoice(QQ)，所以这时参数的静态类型，实际类型都对方法的选择不会构成影响，唯一可以影响虚拟机选择的因素只有此方法的接受者的实际类型是Father还是Son,因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。 jdk1.8之前的Java语言是一门静态多分派，动态单分派的语言。 虚拟机动态分派的实现由于动态分派是非常频繁的操作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此虚拟机会进行优化。常用的方法就是为类在方法区中建立一个虚方法表（Virtual Method Table，在invokeinterface执行时也会用到接口方法表，Interface Method Table），使用虚方法表索引来替代元数据查找以提升性能。下图就是前面代码的虚方法表结构： 虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类重写了父类的方法，子类方法表中的地址会替换为指向子类实现版本的入口地址。在上图中，Son重写了Father的全部方法，所以Son的方法表替换了父类的地址。但是Son和Father都没有重写Object的方法，所以方法表都指向了Object的数据类型。为了程序实现上的方便，具有相同签名的方法，在父类和子类的虚方法表中都应该具有一样的索引号，这样当类型变换时，仅仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。 动态类型语言支持动态类型语言的关键特征是它的类型检查的主体过程是在运行期间而不是编译期间，可以理解为变量无类型而变量值才有类型，Javascript就是这样的语言，而目前Java属于静态类型语言。当然Java也有它实现动态性的方法，这块知识点蛮大，就不展开说了。 基于栈的字节码解释执行引擎解释执行先看看编译过程流图： 上图最下面的那一条就是传统编译原理中程序代码到目标机器代码生成过程（C） 上图中间那一条就是解释执行的过程（Java） 基于栈的指令集与基于寄存器的指令集 基于栈的指令集：指令流中的大部分都是零地址指令（无显示参数），他们依赖操作数栈进行工作。 优点：可移植性，代码紧凑，编译器实现简单 缺点：执行速度稍慢（频繁访问内存） 基于寄存器的指令集：指令集依赖寄存器进行工作 基于栈的解释器执行流程其实就是按照指令解释执行，随便看了例子应该就能明白。 总结其实这里谈的主要还是解释执行，其中有一点很重要就是分派的概念，明白invokevirtual指令的执行过程。 参考 《深入理解Java虚拟机》 虚拟机字节码执行引擎]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_9_类加载器]]></title>
    <url>%2F2017%2F12%2F06%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-9-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[引：之前一直在说类加载，类加载就需要类加载器，类加载最初是为了满足Java Applet，现在基本已经死掉了，但是类加载却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为Java体系中一块重要的基石，可谓失之桑榆，收之东隅。 什么是类加载器？虚拟机设计团队把类加载阶段的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己去决定如何去获取所需要的类，实现这个动作的代码模块称为“类加载器”。 同一个Class文件，不同的类对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。换个说法：比较两个类是否“相等”，只是在这两个类是由同一个类加载器加载的前提下才有意义，如果这两个类源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。 这里的相等包括：代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法返回结果，下面的代码展示了不同的类加载器对instanceof关键字运算的结果的影响。(下面的代码属于破坏双亲委派模型，只是为了验证类的命名空间)1234567891011121314151617181920212223242526272829303132public class ClassLoaderTest &#123; public static void main(String[] args) throws Exception &#123; ClassLoader myLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try &#123; String fileName = name.substring(name.lastIndexOf(".") + 1) + ".class"; InputStream is = getClass().getResourceAsStream(fileName); if (is == null) &#123; return super.loadClass(name); &#125; byte[] b = new byte[is.available()]; is.read(b); return defineClass(name,b,0,b.length); &#125; catch (IOException e) &#123; throw new ClassNotFoundException(name); &#125; &#125; &#125;; Object obj = myLoader.loadClass("com.todorex.demo.ClassLoaderTest").newInstance(); System.out.println(obj.getClass()); System.out.println(obj instanceof com.todorex.demo.ClassLoaderTest ); &#125;&#125; 运行结果：12class com.todorex.demo.ClassLoaderTestfalse 这里的false就证明了两个类虽然来自于同一个Class文件，但是由于使用的类加载器不同，就依然是两个独立的类。 双亲委派模型类加载器的类型Java虚拟机角度 启动类加载器，它本身是由C++语言实现，或者底层的关键方法是用C实现的。 所有其他类加载器，这些类加载器都由Java语言实现。 Java开发人员角度 启动类加载器：这个类加载器负责将存放在\lib目录中的，或者被-Xbootclasspath参数所指定的路径找那个的，并且是虚拟机识别的（按照文件名识别的）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接使用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，直接使用null即可。（不知道怎么用，知道的大佬请告知！！！！） 扩展类加载器：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以使用扩展类加载器。 应用程序类加载器：这个类加载器由sun.misc.Launcher$AppClassLoader实现，也称系统类加载器。它负责加载用户所指定的类路径java -classpath或-Djava.class.path的所有类，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 类加载器的双亲委派模型模型图 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里的类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。（组合就是在一个类中调用另一个类的代码） 工作过程我相信这张图最清楚了： 我们可以由图看到以下过程： 自底向上检查类是否已经加载，若已加载，直接返回。 若所有父类都没有加载该类，则自顶向下尝试加载该类。 如果加载不成功，则抛出ClassNotFoundException异常。 我们可以从代码看看他是怎么实现的？ 先看ClassLoader函数的loadClass函数1234567891011121314151617181920212223242526272829303132333435363738protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // 先从缓存查找该class对象，找到就不用重新加载 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; //如果找不到，则委托给父类加载器去加载 c = parent.loadClass(name, false); &#125; else &#123; //如果没有父类，则委托给启动加载器去加载 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // 如果都没有找到，则通过自定义实现的findClass去查找并加载 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123;//是否需要在加载时进行解析 resolveClass(c); &#125; return c; &#125; &#125; 从该函数我们可以得知双亲委派模型会先递归去查找父加载器是否已经加载过该类了。如果父加载器都没有加载过该类，则开始调用fandClass()尝试去加载该类。由于启动类加载器不可知，我们可以去看看扩展类加载器的findClass()。我们可以看到下面的类图： 我接着我想去看看ExtClassLoader类里面的findClass()方法，结果发现没有，只要去他的父类URLClassLoader去找找，还好找到了，可以看看下面的代码：123456789101112131415161718192021222324252627282930protected Class&lt;?&gt; findClass(final String name) throws ClassNotFoundException&#123; final Class&lt;?&gt; result; try &#123; result = AccessController.doPrivileged( new PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123; public Class&lt;?&gt; run() throws ClassNotFoundException &#123; String path = name.replace('.', '/').concat(".class"); Resource res = ucp.getResource(path, false); if (res != null) &#123; try &#123; //defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象 return defineClass(name, res); &#125; catch (IOException e) &#123; throw new ClassNotFoundException(name, e); &#125; &#125; else &#123; return null; &#125; &#125; &#125;, acc); &#125; catch (java.security.PrivilegedActionException pae) &#123; throw (ClassNotFoundException) pae.getException(); &#125; if (result == null) &#123; throw new ClassNotFoundException(name); &#125; return result;&#125; 其实AppClassLoader的findClass()也是继承自URLCLassLoader，所以都是一样的，我们再结合最开始的loadClass()就可以很好的理解了上面双亲委派模型的工作流程了。 好处java随着它的类加载一起具备了一种带有优先级的层次关系，它能保证一个类在程序中各种类加载器环境中都是同一个类。 双亲委派模型的“双亲”在Java虚拟机英文文章里双亲委派模型的英文是Parent-Delegation Model，不知道为什么中文翻译会称他为双亲委派模型，可能是他一般都会找到一个爸爸去委托去处理吧。 破坏双亲委派模型目前为止，双亲委派模型主要出现过3次较大的“被破坏”的情况。 在JDK1.2之前，新建加载器都是通过重写loadClass()方法来区分不同的加载器,以及修改加载逻辑，这样就破坏了双亲委派模型的向上寻找父加载器去加载的规范，在JDK1.2之后为了向前兼容，ClassLoader添加了新的protect方法findCLass()方法，从而实现了在双亲委派模型上实现加载逻辑的修改。 线程上下文类加载器，如JNDI服务(没用过) 实现动态性，如OSGi(没用过) 总结有时候分析东西查看源码是必要的，还要利用一些工具去分析他们的继承关系。 参考 《深入理解Java虚拟机》 深入理解Java类加载器(ClassLoader) 深入理解Java类加载器(一)：Java类加载原理解析]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_8_虚拟机类加载机制]]></title>
    <url>%2F2017%2F12%2F02%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-8-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[引：在Class文件中描述的各种信息最终都需要加载到虚拟机之中之后才能运行和使用。而虚拟机如何加载这些Class文件？Class文件中的信息进入到虚拟机后会发生什么变化？ 概述虚拟机的类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。 C/C++和Java链接的不同： C/C++：在编译时完成链接工作；降低了运行时的性能开销，但是也降低了运行时的灵活性。 Java：类型的加载、链接和初始化过程都是在程序运行期间完成的；增加了运行时的性能开销，但是增强了运行时的灵活性，使Java变成了可以动态扩展的语言。这里的动态扩展可以分为两点： 动态加载：用户可以通过Java预定义的或者自定义的类加载，让一个本地的应用程序可以在运行时在从网络或其他地方加载一个二进制流作为程序代码的一部分。 动态链接：如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类。 类加载的时机类的生命周期类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括： 其中链接包括下面三个部分： 生命周期中加载、验证、准备、初始化和卸载这5个阶段顺序是确定的，但是又是可以互相交叉混合式进行的。 类的初始化时机什么情况下需要开始类加载过程的第一阶段：加载？Java虚拟机规范没有进行强制约束，但是对初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类“初始化”。 遇到new、getstatic、putstatic或者invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要触发其初始化，生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段（被final修饰并且已在编译器把结果放在常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用java.lang.reflect包的时候对类进行反射调用的时候，如果类没有进行过初始化，则需要触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要制定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个类。 如果一个java.lang.invoke.MethodHandle实例解析结果是REF_getStaic,REF_putStatic,REF_invokeStatic的方法句柄，并且这个句柄所对应的类没有进行过初始化，则需要先触发其初始化。（还没用过） 上面5种场景中的行为成为对一个类的主动引用，除此之外，所有应用类的方式都不会触发初始化，成为被动引用。下面是几个被动引用的场景： 通过子类引用父类的静态字段，不会导致子类初始化。 通过数组来定义引用类，不会触发此类的初始化。 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，不会触发该类的初始化，因为在编译阶段通过常量传播优化，已经将其他类的常量存入到调用类的常量池了。 说一点接口与类初始化世时机的不同：在有且只有的5条中的第3条,当一个类在初始化时，要求其父类全部都已经初始化过了，但是接口在初始化时，不要求其父接口全部都完成了初始化，只有真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。 类加载的过程Java虚拟机中类加载的全过程为： 加载虚拟机在加载阶段要干什么 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个类的字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 二进制字节流的来源 从ZIP包中读取，最终成为了日后JAR、EAR、WAR格式的基础。 从网络中获取，这个场景最典型的应用就是Applet（没用过）。 运行时计算生成，这个场景使用的最多的就是动态代理技术，生成代理类的二进制字节流。 由其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。 加载阶段的注意点 非数组类的加载阶段是开发人员可控性最强的，加载阶段既可以使用系统提供的引导类加载器，也可以使用用户自定义的类加载器。 数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的，但是最终还是要靠类加载器是创建数组类里面的元素类型，每个数组都会在加载数组元素的类加载器的类名称空间上被标识。 Java虚拟机规范没有规定类在方法区的具体数据结构，也没有规定生成的Class对象存储在哪里，对于HotSpot虚拟机而言，它被存放在方法区里面，jdk1.8以后应该在直接内存中吧。 加载阶段与连接阶段的部分内容（一部分字节码文件格式验证工作）是交叉进行的。 验证验证目的由于Class文件并不一定要求用Java源码编译而来，可以使用任何途径产生，所以安全性得不到保证，而验证的目的就是为了确保Class文件的字节流包含的信息符合虚拟机的要求，并且不会危害虚拟机自身的安全。 验证过程 文件格式验证 主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上负荷一个Java类型信息的要求，这个阶段的验证是基于二进制字节流进行的，只有通过这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字符流。 元数据验证 主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。 字节码验证 主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。 符号引用验证 发生在解析阶段（将符号引用转化为直接引用），主要目的是确保解析动作能正常执行。 调优的地方如果所运行的代码都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，但是这里的初始值需要注意一下： 通常情况：初始值是数据类型的零值 类变量有fianl关键字修饰：初始值是ConstantValue属性所指定的值 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。这里解释一下直接引用和符号引用： 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量。它的字面量形式明确定义在Java虚拟机规范的Class文件格式中。符号引用于虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。 直接引用：它可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局相关，有了直接引用，那么引用的目标必定已经在内存中存在。 虚拟机规范中并未规定解析阶段发生的具体时间。所以虚拟机可以根据需要来判断到底是在类被加载器加载时就对常量池的符号引用进行解析，还是等到一个符号引用被使用前再去解析它。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 初始化类初始化时类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化变量和其他资源，从另一个角度来表达：初始化阶段是执行类构造器clinit()方法的过程。下面是clinit()方法的注意点： clinit()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中语句合并产生的，收集的顺序是有语句在源文件出现的顺序决定的，这里有很特别的一点：静态语句块中只能访问到定义在静态语句块之前的变量，定义在之后的变量，在前面的静态语句块可以赋值，但是不能访问，代码如下： 123456789public class Test &#123; static &#123; i =0; //正常编译 System.out.println(i); //提示“非法向前引用” &#125; static int i =1;&#125; clinit()方法不需要显式地调用父类构造器，虚拟机会保证在子类的clinit()方法执行前，父类的clinit()方法已经执行完毕。 由于父类的clinit()方法先执行，所以父类定义的静态语句块要优先于子类的变量赋值操作。 虚拟机会保证一个类的clinit()方法在多线程中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其他线程都要阻塞等待，直到活动线程执行clinit()方法完毕。 总结类加载的5个阶段都很重要，对理解对象的创建过程有了更好的理解。 参考 《深入理解Java虚拟机》]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_7_探秘类文件]]></title>
    <url>%2F2017%2F12%2F01%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-7-%E6%8E%A2%E7%A7%98%E7%B1%BB%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[引：java代码编译的结果从本地机器码转变为字节码，并且生成了类文件，那么这个类文件里面是什么东西呢？ JVM的无关性一般提到Java的好处，其中必定有一条是平台无关性，但是这个太狭隘了，其实它有两点无关性。 平台无关性Java在刚刚诞生之时就有一个著名的宣传口号：“一次编写，到处运行（Write Once, Run Anywhere）”。“与平台无关”的理想最终实现在操作系统的应用层上：其实就是Java虚拟机了，他可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写，到处运行”。 语言无关性目前已经一大批能够在JVM运行语言了，就我自己知道并且使用过就有Groovy、Jython、Scala等。实现语言无关性的基础仍然是虚拟机和字节码存储格式。其他语言通过自己的编译把程序代码编程成符合Java虚拟机规范的Class文件即可。 类文件的结构Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑排列在Class文件之中，中间没有任何分隔符。Class文件只有两种数据类型：无符号数和表 无符号数：以u1，u2，u4，u8来分别代表1个字节，2个字节，4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数值量或者按照UTF-8编码构成字符串值。 表：它是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表习惯地以“_info”结尾。 整个Class文件本质上就是一张表，它由下表所示的数据项构成。 类型 名称 数量 u4 魔数 1 u2 次版本号 1 u2 主版本号 1 u2 常量数量 1 cp_info 常量池 常量数量-1 u2 访问标志 1 u2 类索引 1 u2 父类索引 1 u2 接口数量 1 u2 接口索引集合 接口数量 u2 字段数量 1 field_info 字段表 字段数量 u2 方法数量 1 method_info 方法表 方法数量 u2 属性数量 1 attribute_info 属性表 属性数量 接下里稍微详细看看上面的数据： 不过按例子来吧，下面是一个简单的Java类1234567891011package com.todorex.demo;public class TestClass &#123; private int m; public int inc() &#123; return m+1; &#125;&#125; 先编译这个类得到TestClass.class文件，打开它可以下面的16进制数：12345678910111213141516171819cafe babe 0000 0034 0013 0a00 0400 0f090003 0010 0700 1107 0012 0100 016d 01000149 0100 063c 696e 6974 3e01 0003 28295601 0004 436f 6465 0100 0f4c 696e 654e756d 6265 7254 6162 6c65 0100 0369 6e630100 0328 2949 0100 0a53 6f75 7263 6546696c 6501 000e 5465 7374 436c 6173 732e6a61 7661 0c00 0700 080c 0005 0006 01001a63 6f6d 2f74 6f64 6f72 6578 2f64 656d6f2f 5465 7374 436c 6173 7301 0010 6a617661 2f6c 616e 672f 4f62 6a65 6374 00210003 0004 0000 0001 0002 0005 0006 00000002 0001 0007 0008 0001 0009 0000 001d0001 0001 0000 0005 2ab7 0001 b100 00000100 0a00 0000 0600 0100 0000 0600 01000b00 0c00 0100 0900 0000 1f00 0200 01000000 072a b400 0204 60ac 0000 0001 000a0000 0006 0001 0000 0009 0001 000d 00000002 000e 然后用javap 解析TestClass.class文件，得到：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Classfile /Users/rex/IdeaProjects/JVMTest/src/com/todorex/demo/TestClass.class Last modified 2017-12-1; size 292 bytes MD5 checksum 337a51d3bebe0e9a82142a352eb0977e Compiled from "TestClass.java"public class com.todorex.demo.TestClass minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #3.#16 // com/todorex/demo/TestClass.m:I #3 = Class #17 // com/todorex/demo/TestClass #4 = Class #18 // java/lang/Object #5 = Utf8 m #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 inc #12 = Utf8 ()I #13 = Utf8 SourceFile #14 = Utf8 TestClass.java #15 = NameAndType #7:#8 // "&lt;init&gt;":()V #16 = NameAndType #5:#6 // m:I #17 = Utf8 com/todorex/demo/TestClass #18 = Utf8 java/lang/Object&#123; public com.todorex.demo.TestClass(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 6: 0 public int inc(); descriptor: ()I flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: getfield #2 // Field m:I 4: iconst_1 5: iadd 6: ireturn LineNumberTable: line 9: 0&#125;SourceFile: "TestClass.java" 魔数 每个Class文件的头4个字节成为魔数 使用魔数来进行身份识别（文件类别），因为如果使用文件名来识别，安全性太低，由于文件名可以随意改动。 Class文件的魔数的获得就有“浪漫气息”，值为0xcafebabe,上面16进制文件也可以看到。这让自己想起了高中用的三星手机打开qq就是一杯咖啡的标志。 Class文件的版本接下来第5，6个字节显示的是次版本号，7，8字节显示的是主版本号。 高版本的JDK可以向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。 常量池在版本号之后的是常量池入口。 常量池是Class文件结构中与其他项目关联最大的数据类型，也是占Class文件空间最大的数据项目之一。 常量池常量的数据不是固定的，在最前面的Class文件组成可以看到有一个常量数量项，这个容量计数是从1而不是0开始的，比如上面的十六进制的值为0x0013(19)就代表有18个常量。 常量池主要存放两大类变量 字面量：文本字符串、声明为final的常量值等 符号引用：（编译原理的概念） 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 常量池的每一项常量都是表，常量的顺序可以参照javap解析出来的常量顺序，在JDK1.7以后共有14种不同类型的表，他们共同点是表的第一位是一个u1类型的标志位（tag），具体的标志对应的类型参照书《深入理解Java虚拟机》。这里提一下CONSTANT_UTF8_info这个表： 类型 名称 数量 u1 tag 1 u2 length 1 u1 bytes length length值说明了UTF-8编码的字符串长度是多少字节，他后面跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。而u2最大值是65535，所以说如果Java程序如果定义了超过64KB（大约）英文字符的变量或者方法名，将无法编译。 UTF-8缩略编码和UTF-8编码的区别：UTF-8编码都是使用3个字节编码，而UTF-8缩略编码可以使用1或2或3个字节编码。 访问标志在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等，访问标志一共有16个标志位可以使用，当前只定义了8个。 类索引、父类索引、接口索引集合 类索引、父类索引都是u2类型的数据，类索引、父类索引都是指向一个CONSTANT_Class_info的类描述符常量 接口索引集合是一组u2类型的数据的集合，它入口的第一项是u2的接口计数器，后面就是具体接口索引 Class文件有这三项数据来确定这个类的继承关系 字段表集合接下来是字段表，字段表用于描述接口或者类中声明的变量，包括类级变量以及实例级变量，不包括方法内部声明的局部变量。我们看一下一个字段表的构成： 类型 名称 数量 u2 访问标志 1 u2 简单名称索引 1 u2 描述符索引 1 u2 属性数量 1 attribute_info 属性表 属性数量 根据上表我们解析一下其中的含义： 访问标志：它和之前的访问标志很类似。 简单名称索引：它指向一个CONSTANT_UTF8_info类型的常量，这里面存储了本字段的名字信息，像javap解析后的第5个常量m。 描述符索引：用来描述字段的数据类型，像javap解析后的第6个常量I,代表了基本类型int 属性表（可能有ConstantValue表 下面是字符表的注意点： 字段表集合不会列出从超类或者父接口继承而来的字段。 字段表有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加执行外部类实例的字段。（不懂，大佬请指教） Java语言中字段是无法重载的，名称必须不一样，但是对于字节码来说，如果两个字段的描述符不一致，那么字段重名是合法的。 方法表集合接下来是方法表，方法表的内容和字段表几乎完全一致。其中坑顶也看一下方法表的构成： 类型 名称 数量 u2 访问标志 1 u2 简单名称索引 1 u2 描述符索引 1 u2 属性数量 1 attribute_info 属性表 属性数量 这里解释一下和字段表不一样的地方 简单名称索引：它指向一个CONSTANT_UTF8_info类型的常量，这里面存储了本字段的名字信息，像javap解析后的第11个常量inc。 描述符索引：它的作用是用来描方法的参数列表（包括数量、类型以及顺序）和返回值，像javap解析后的第12个常量()I,表示的就是一个返回值为int的方法。 属性表：这里肯定存放了Code属性表（方法里的Java代码） 下面是方法表的注意点： 如果父类方法在子类没有被重写，方法表集合中就不会出现来自父类的方法信息。 可能会出现由编译器自动添加的方法，最典型的有类构造器“”方法和实例构造器“”方法，就像javap解析后的第11个常量。 在Java语言中，要重载一个方法，需要相同的简单名称和与原方法不同的Java代码的方法特征签名，这里需要解释一下Java特征签名和JVM特征签名： Java特征签名：方法名称、参数顺序 JVM特征签名：Java特征签名、方法返回值以及受查异常表 属性表集合最后就是属性表集合了，在Class文件、字段表、方法表都可以携带自己的属性表集合，以及用于描述某些场景专有的信息。属性表集合不要求各个属性具有严格的顺序，并且只要不与已有属性名重复就好。 上面程序的例子出现过几个属性表：Code、LineNumberTable、SourceFile、ConstantValue，接下来我们详细说一下： Code属性Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内，Code属性出现在方法表属性集合之中，我们先看看Code属性表的结构： 类型 名称 数量 u2 属性名索引 1 u4 属性长度 1 u2 操作数栈深度的最大值 1 u2 局部变量表所需的存储空间 1 u4 Java方法代码字节码指令长度 1 u1 Java方法代码字节码 Java方法代码字节码指令长度 u2 显式异常表长度 1 exception_info 显式异常表 显式异常表长度 u2 属性个数 1 attribute_info 属性表 属性个数 接下来我们说明一下几个关键项： 属性名索引：它是一项指向CONSTANT_UTF8_info型的索引，常量值固定为“Code”，就像上面javap解析出来的常量池的第9个。 属性长度：固定为整个属性表长度减去6个字节。 操作数栈深度的最大值：在方法执行的任意时刻，操作数栈都不会超过这个深度，虚拟机运行的时候需要根据这个值来分配栈栈中的操作数栈深度。 局部变量表所需的存储空间：它的单位是Slot，局部变量表存储了方法参数（包括实例方法中的隐藏参数this）、显示异常处理器的参数（try-catch检查的异常）、方法体中定义的局部变量，Javac编译器会根据变量的作用域来分配Slot，然后计算出需要的存储空间大小。 Java方法代码字节码指令长度和Java方法代码字节码：存储了Java源程序编译后生成的字节码指令，目前Java虚拟机规范已经定义了约200条编码值对应的指令含义。 PS：如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义以及其他信息）两部分，那么在整个Class文件，Code属性用来描述代码，所有其他数据项目都用于描述元数据。 显式异常表：用于显示try-catch代码块要检查的异常 LineNumberTable它的使用位置是在Code属性，用于描述Java源码行号与字节码行号之间的对应关系，当抛出异常的时候堆栈会显示出错的行号。 SourceFile它的使用位置是类文件，用于记录生成这个Class文件的源码文件名称，当抛出异常的时候会显示出错代码所属的文件名。 ConstantValue它的使用位置是字段表，作用是通知虚拟机自动为静态变量赋值，只有static关键字修饰的变量（类变量）才可以使用这项属性，虚拟机对于类变量和实例变量赋值的方式有所不用。 实例变量：在实例构造器方法中进行 类变量：在类构造器方法中或者使用ConstantValue属性 目前Sun Javac编译器的选择是：如果同时使用final和static来修饰一个变量，并且这个常量的数据类型是基本类型或者String类型，就生成ConstantValue属性来进行初始化，如果这个变量没有被final修饰，或者并非基本类型或者字符串，则将会选择在方法中进行初始化。 总结通过上面的分析，我们一定能清楚的知道Class文件是什么以及Class文件包含什么东西，再也不怕了！！ 参考 《深入理解Java虚拟机》]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_6_JVM调优实战]]></title>
    <url>%2F2017%2F11%2F30%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-6-JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[引：带着浅尝基本的Java诊断工具就这样把《深入理解Java虚拟机》的调优部分看完了，似懂非懂，我想待自己经历过一次性能调优，结合自身经历再来好好总结一番吧。 此处暂时省略一万字。。。]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_5_内存分配策略]]></title>
    <url>%2F2017%2F11%2F30%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-5-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[引：一直在说Java的垃圾回收，既然有回收，那么当然会有分配。 Java技术体系中所提倡的自动内存管理可以归结为自动化地解决了两个问题： 给对象分配内存 回收分配给对象的内存 之前垃圾回收已经讲了很多，接下来我们详细地来看看内存分配 内存分配总说对象的内存分配，主要是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程的分配缓冲，将按线程优先在TLAB上分配，少数情况下（大对象）也可能直接分配在老年代中，分配的规则不是百分百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。 对象优先在Eden分配 大多数情况，对象在新生代Eden区分配。当Eden区没有足够空间进行分配时，虚拟机会发起一次MinorGC。 当MinorGC发现复制的对象大于Survivor区时，会通过分配担保机制提前转移到老年代中。 大对象直接进入老年代所谓大对象是指需要大量连续内存空间的Java对象，如数组。 虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配，避免了在Eden区及Survivor区之间发生大量的内存复制。（新生代采用复制算法收集内存） 长期存活的对象将进入老年代虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设置为1.对象在Survivor中每度过一次MinorGC，年龄就增加一岁，当他的年龄达到一定程度（默认15岁），就将被晋升到老年代中。对象的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。 动态对象年龄判定虚拟机不是永远要求对象的年龄必须达到MaxTenuringThreshold才晋升到老年代，如果Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入老年代。 空间分配担保策略虽然有空间分配担保，但是也需要考虑老年代能否装下由于担保转存的内存大小，所以这个空间分配担保也需要一定的策略。 在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间 如果上面条件成立，那么MinorGC就是安全的，可以进行 如果上面条件不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。 如果允许担保失败，就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小 如果大于，将尝试进行一次MinorGC 如果小于，或者HandlePromotionFailure设置为不允许冒险，那这时需要进行一次FullGC 在jdk 6 update 24之后的规则是只要老年代的连续空间大于新生代对象的总大小或者历次晋升平均大小就会进行MinorGC，否则进行FullGC。 总结通过上面我们可以知道JAVA虚拟机是怎么自动进行内存分配的，然后在进行GC之后，内存是怎么转换的。 参考 《深入理解JAVA虚拟机》]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_4_垃圾收集策略]]></title>
    <url>%2F2017%2F11%2F29%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-4-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[引：Java与C++之间有一堵内存动态分配与垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。那我们就先来看看JVM到底是怎么进行垃圾收集的？ 垃圾回收，回收哪里？之前介绍过Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，这几个区域的内存分配和回收都具有确定性，方法结束或者线程结束，内存自然就跟着回收了，但是Java堆和方法区（元空间）则不一样，我们只有在运行期间才知道会创建哪些对象，这部分内存的分配和回收都是动态的，所有垃圾回收就是回收这里。 对象已死么？垃圾收集器在对堆进行回收前，第一件事就是要确定这些对象之中还有那些还“存活”者，哪些已经“死去”（即不可能再被任何途径使用的对象）。 引用计数算法 给每个对象添加一个引用计数器，每当有一个地方引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器为0的对象就是不可能再被使用的。 可达性分析算法（Java使用） 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径被称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。 在Java语言中，可作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性应用的对象 方法区中常量引用的对象 本地方法栈中JNI（即一般说的Native方法）引用的对象 引用类型 强引用：类似”Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用：用来描述还有用但非必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。它是通过SoftReference类来实现软引用的。 弱引用：用来描述非必需对象的，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象，它是通过WeakReference类来实现弱引用的。 虚引用：只要发生垃圾回收，它就会被收集，它唯一的目的就是能在这个对象被收集器回收时收到一个系统通知，它是用过PhantomReference类来实现虚引用。 方法区（元空间）的回收类和其元数据的生命周期和其对应的类加载器是相同的。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。准确的来说，每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。 垃圾收集算法标记-清除算法流程： 标记出所有需要回收的对象 在标记完成后统一回收所有被标记的对象 不足： 效率问题 标记和清除两个过程效率都不高 空间问题 标记清除以后会产生大量不连续的空间碎片，无法存储大对象 复制算法流程： 将可用内存按容量分为大小相同的两块 在第一块分配内存，并标记出所有需要回收的对象 当第一块内存用完了，将所有活着的对象复制到另外一块上 将第一块所使用过的内存空间一次性清除 好处：解决了空间碎片问题 不足：降低了空间利用率 现在的商业虚拟机都用这种收集算法来回收新生代，因为新生代中的对象98%是“朝生夕死”的，所以不需要1:1划分空间,而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还活着的对象那个一次性复制到另一块Survivor空间上，最后清理掉前两块空间。HotSpot虚拟机默认Eden和Survivor的大小比例为8:1，所以只有10%的内存会被“浪费”，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。 内存的分配担保是指如果放着存活对象的Survivor空间没有足够空间放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。 标记-整理算法适合老年代 流程： 标记出所有需要回收的对象 让所有存活的对象都向一端移动 直接清理掉端边界以外的内存 分代收集算法将内存划分为老年代和新生代。老年代中存放寿命较长的对象，新生代中存放“朝生夕死”的对象。然后在不同的区域使用不同的垃圾收集算法。 总结从上面我们了解了对象存活判定算法和垃圾回收算法，但是不同虚拟机的具体实现还是不同的，而且不同的垃圾收集器的内存回收的具体实现也是不同的，我们要因机而议。 参考 《深入理解Java虚拟机》 JDK8 从永久代到元空间]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_3_OutOfMemoryError异常现场]]></title>
    <url>%2F2017%2F11%2F29%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-3-OutOfMemoryError%E5%BC%82%E5%B8%B8%E7%8E%B0%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[引：之前面对JVM运行内存的分析，总会提到出现OutMemoryError异常，接下来我们详细看下常出现这种异常的现场。 Java堆溢出我们通过限制Java堆得大小为20MB,不可扩张（将堆得最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX：+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump（备份）出当前的内存堆转储快照以便时候分析处理。 代码如下：1234567891011121314//VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryErrorpublic class HeapOOM &#123; static class OOMobject &#123; &#125; public static void main(String[] args) &#123; List&lt;OOMobject&gt; list = new ArrayList&lt;&gt;(); while (true) &#123; list.add(new OOMobject()); &#125; &#125;&#125; 运行结果：12345java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid81611.hprof ...Heap dump file created [27573572 bytes in 0.121 secs]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3210)... 我们很容易在输出结果中看到Java heap space OOM出现在堆中。我们要解决这个区域的异常主要是通过内存映像分析工具（很多）对Dump出来的堆转储快照进行分析，重点确认是内存泄漏（Memory leak）还是内存溢出（Memory Overflow）。 内存泄漏：被分配的内存的对象不会被回收，永久占据内存。 解决方法：通过工具查看泄漏对象到GC Roots的引用链。 内存溢出：无法申请到内存。 解决方法：检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长的情况，尝试减少程序运行期的内存消耗。 虚拟机栈和本地方法栈溢出我们说过HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，所以设置本地方法栈大小是无效的，栈容量只由-Xss参数设定，在Java虚拟机规范中描述了两种异常 StackOverflowError异常：如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出此异常。 OutOfMemoryError异常：如果虚拟机在扩展栈使无法申请到足够的内存空间，将抛出此异常。 我个人想如果单线程中栈的内存大小等于总内存大小，那么上面两种异常应该是等价的吧，但是基本上是不可能的。所以单线程中出现得基本上都是StackOverflowError异常。 单线程代码如下：1234567891011121314// VM args: -Xss128kpublic class HeapOOM &#123; static class OOMobject &#123; &#125; public static void main(String[] args) &#123; List&lt;OOMobject&gt; list = new ArrayList&lt;&gt;(); while (true) &#123; list.add(new OOMobject()); &#125; &#125;&#125; 运行结果：123stack lenth:18855Exception in thread &quot;main&quot; java.lang.StackOverflowError at com.todorex.demo.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:10) 这里抄一下书的结论：在单个线程下，无论是由于栈帧太大还是虚拟机容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。 多线程代码如下：12345678910111213141516171819202122232425// VM args: -Xss2Mpublic class JavaVMStackOOM &#123; private void dontStop() &#123; while (true) &#123; &#125; &#125; public void stackLeakByThread() &#123; while (true) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; dontStop(); &#125; &#125;); thread.start(); &#125; &#125; public static void main(String[] args) &#123; JavaVMStackOOM javaVMStackOOM = new JavaVMStackOOM(); javaVMStackOOM.stackLeakByThread(); &#125;&#125; 我在自己的机器上没有运行出来，可能需要点时间，不过机器变卡了，我想其实这里解释一下就好，它应该会抛出OutOfMemoryError异常。 解释：首先操作系统分给每个进程的内存是有限制的，所以总的方法栈的大小也是有限制的，但是每个线程都需要方法栈，所以线程建立的越多，剩余的方法栈内存就越小，一直创建线程，进程所拥有的内存终将被耗尽，到最后就会抛出OutOfMemoryError异常。 注意：线程数和方法栈大小是成反比的，所以在开发多线程的应用时应该特别注意，如果不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程了。 方法区（元空间）和运行时常量池溢出运行时常量池溢出在之前的博客也提到过在jdk1.6以及之前运行时常量池是放在方法区中的，存的是对象，所以可以设置虚拟机参数-XX:PermSize和-XX:MaxPermSize来限制方法区的大小，来模拟常量池溢出，但是jdk1.7及以后运行时常量池被移除了方法区，常量池存储的不再是对象，而是对象的引用，真正的对象存储在堆中，我们改变虚拟机参数为：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError运行下面程序：1234567891011// VM args:-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryErrorpublic class RuntimeConstantPoolOOM &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); int i = 0; while (true) &#123; list.add(String.valueOf(i++).intern()); &#125; &#125;&#125; 运行结果：123java.lang.OutOfMemoryError: GC overhead limit exceededDumping heap to java_pid10818.hprof ...Heap dump file created [25172419 bytes in 0.251 secs] 上面结果提示GC开销超过限制，默认的话，如果你98%的时间都花在GC上并且回收了才不到2%的空间的话，虚拟机就会抛这个异常。 其实我们之前也提起过在JDK1.8及以后，字符串常量池从永久代移到到元空间中，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整，如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集，-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集，具体验证代码如下：1234567891011// VM args: -XX:MetaspaceSize=4M -XX:MaxMetaspaceSize=4Mpublic class RuntimeConstantPoolOOM &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); int i = 0; while (true) &#123; list.add(String.valueOf(i++).intern()); &#125; &#125;&#125; 运行结果：12Error occurred during initialization of VMOutOfMemoryError: Metaspace 关于这个字符串常量池的实现问题，还真的会出现一个很意思的问题或者说是一个很奇怪的问题。代码如下：123456789101112131415// jdk:1.8public class RuntimeConstantPoolOOM &#123; public static void main(String[] args) &#123; String str1 = new StringBuilder("计算机").append("软件").toString(); System.out.println(str1.intern() == str1); String str2 = new StringBuilder("ja").append("va").toString(); System.out.println(str2.intern() == str2); String str3 = new StringBuilder("ma").append("in").toString(); System.out.println(str3.intern() == str3); &#125;&#125; 运行结果：123truefalsefalse jdk1.6中，intern()方法会把首次遇到的字符串实例复制在永久代，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用。而在jdk1.7及以后，intern()的实现不会再复制实例，只是在常量池中记录首次出现得实例的引用，因此intern()返回的由StringBuilder创建的那个字符串是同一个实例，而关于上面的运行结果，我想java和main之前都是在字符串常量池中都有他的引用了，所以返回的都是false。 方法区溢出方法区用于存放Class的相关信息，如类名，访问修饰符，常量池，字段描述，方法描述等，基本的思路是运行时产生大量的类去填充方法区，下面是借助CGLib（cglib和asm的依赖有个坑，选择cglib2.2,asm3.1亲测可用）来操作字节码运行时生成大量的动态类，这种场景在Spring，Hibernate中经常出现，需要多注意，本人使用的JDK1.8，所以测试的是方法区的变迁元空间，代码实现如下：123456789101112131415161718192021222324// VM args:-XX:MetaspaceSize=4M -XX:MaxMetaspaceSize=4Mpublic class JavaMethodAreaOOM &#123; public static void main(String[]args) &#123; while (true) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; return methodProxy.invokeSuper(o, objects); &#125; &#125;); OOMObject oomObject = (OOMObject) enhancer.create(); oomObject.sayHi(); &#125; &#125; static class OOMObject&#123; public void sayHi()&#123; System.out.println("hi"); &#125; &#125;&#125; 结果输出：12Error occurred during initialization of VMOutOfMemoryError: Metaspace 这类异常经常出现在web应用中，需要多注意。 本机直接内存溢出DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样，在《深入理解Java虚拟机》中用了以下代码：1234567891011121314// VM args:-Xmx20M -XX:MaxDirectMemorySize=10Mpublic class DirectMemoryOOM &#123; private static final int _1MB = 1024*1024; public static void main(String[] args) throws Exception&#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true) &#123; unsafe.allocateMemory(_1MB); &#125; &#125;&#125; 但是在自己电脑中没有运行成功，反而让自己的电脑死机了，这个地方还是没有弄懂？？？？？？，希望懂的大佬给我点支持。 这个异常在使用NIO中可能会出现，所以在使用的时候需要多注意。 总结在总结得过程中，知道了各个内存区域可能会出现OOM的情况，重要的是了解了方法区在jdk1.6到1.7到1.8的变迁，有兴趣的人可以深入了解。 参考 《深入理解Java虚拟机》 CGLIB介绍与原理 Java8内存模型—永久代(PermGen)和元空间(Metaspace) 深入探究JVM | 探秘Metaspace]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_2_HotSpot对象揭秘]]></title>
    <url>%2F2017%2F11%2F21%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-2-HotSpot%E5%AF%B9%E8%B1%A1%E6%8F%AD%E7%A7%98%2F</url>
    <content type="text"><![CDATA[引：总有些人会思考对象是如果创建、如何布局、以及如何访问的？对于这些问题，我们必须把讨论范围限定在具体的虚拟机和集中在某一个内存区域才有意义。基于实用原则，我们以常用的虚拟机HotSpot和常用的内存区域Java堆为例。 对象的创建Java程序创建对象不过是一个new关键字而已，而在虚拟机中，创建了一个对象却经历了一系列过程。 虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，如果没有就会抛出ClassNotFoundException，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，那必须先执行相应的类加载过程。 类加载检查通过后，虚拟机为新生对象分配内存，对象所需内存的大小在类加载完成后便可以完全确定。 这里有两种内存分配方式：（由采用的垃圾收集器是否带有压缩整理的功能决定） 指针碰撞 假设Java堆的内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。 空闲列表 假如Java堆中的内存并不是完整的，已使用的内存和空闲的内存相互交错，虚拟机就必须维护一个列表，记录那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给实例，并更新列表上的记录。 解决在并发情况下不安全的方案: 对分配内存空间的动作进行同步处理——虚拟机采用CAS配上失败重试的方式保证更新操作的原子性 把内存分配的动作按线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲，只有需要重新分配的时候才同步锁定 虚拟机将分配到的内存空间都初始化为零值（默认初始化），保证了对象实例在Java代码中可以不赋初始值就可以使用。 设置对象头 利用构造函数进行初始化 对象的内存布局对象头 存储对象自身的运行时数据（哈希码，GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等），官方称为“Mark Word”，它被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，他会根据对象的状态复用自己的存储空间，具体见《深入理解Java虚拟机》。 类型指针（可选）即对象指向它的元数据（方法区）的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例 数组长度（可选）如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通java对象元数据信息确定Java对象的大小，但是从数组数据无法确定数据大小 实例数据存储所有成员变量，无论是父类继承下来的，还是在子类定义的。 存储顺序会受到虚拟机分配策略参数和字段在源码定义的顺序的影响。HotSpot默认的分配策略为相同狂赌的字段总是被分配到一起（如long和double），在这个前提下，父类先于子类，若CompactFields参数为true，那么子类之中较窄的变量也可能插入到父类变量的空隙中（是因为一个slot太大） 对齐填充（可选）起到占位符的作用，确保对象的长度为8字节的整数倍 HotSpot VM的自动内存管理系统要求对象起始位置必须是8字节的整数倍，由于对象头一定是8字节的整数倍，所以利用占位符可以达到数据部分也是8字节的整数倍。从而达到对象的长度是8字节的整数倍。（有点绕口啊，哈哈） 对象的访问定位我们通常都会使用Java对象，我们基本上都是通过虚拟机栈上的reference数据来操作堆上的具体对象，而栈上只是一个指向对象的引用，对象的具体访问方式取决于虚拟机，目前有以下两种访问方式： 通过句柄访问对象可以看下面的图：使用句柄访问，Java堆中会划分出一块内存来作为句柄池，reference存储的就是对象的句柄地址，而句柄包含了对象实例数据与类型数据各自的具体地址信息。 通过直接指针访问对象可以看下面的图：使用直接指针访问，Java堆对象的布局中就要考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。 两者对比 通过句柄访问对象可以当对象被移动之后只会改变句柄中的实例数据指针，而reference本身不需要改变。 使用直接指针访问可以加快Java对象的访问，HotSpot就是使用直接指针访问对象的方式。 总结这里讲的对象重点还是在虚拟机执行部分，关于Class文件的讲解没有涉及到，但它却是十分重要的，日后会提及。 参考 深入理解JVM(二)——揭开HotSpot对象创建的奥秘]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM_1_JVM内存模型]]></title>
    <url>%2F2017%2F11%2F20%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-1-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[引：总是提到堆呀，栈呀，常量池呀，但是Java虚拟机内的Java模型却总是理解不清楚，这次就总结一下。 Java内存模型组成这里讲的是Java虚拟机在执行Java程序的过程中会把它所管理的内存划分五大区域。 程序计算器 Java虚拟机栈 本地方法栈 Java堆 方法区 下面也把来自深入理解Java虚拟机的图片贴一下： 接着我们重点理解一下这五大区域。 程序计数器什么是程序计数器 程序计数器是一块较小的内存空间，他可以看做当前线程所执行的字节码的行号指示器。 如果线程在执行一个Java方法的时候，这个计数器记录的是正在执行的虚拟机字节码指令地址，如果正在执行的是Native方法，这个计数器值则为空。 程序计数器的作用 单线程的时候：通过改变这个计数器的值来选取下一条需要执行的字节码指令，从而实现分支、循环、跳转、异常处理、线程回复等基础功能。 多线程的时候：当每个线程都有独立的程序计数器，则线程切换后就能回复到正确的执行位置。PS： Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。 程序计数器的特点 存储空间较小 线程私有，每个线程都有一个程序计数器 唯一一个没有规定任何OutOfMemoryError情况的区域 生命周期与线程相同 Java虚拟机栈什么是Java虚拟机栈Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表（包括基本数据类型，对象引用和returnAddress,其中long和double会占据2个局部变量空间，其他只占用一个）、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 Ps： 人们常说的Java内存区分为“堆”和“栈”，“堆”存放对象（可以），“栈”只是值其中的局部变量表（不可以），这是不正确的。 Java虚拟机栈的特点 线程私有，生命周期与线程相同 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常 虚拟机栈可以动态扩展，也可以固定长度，在动态扩展的时候如果无法申请到足够的内存，就会抛出OutOfMemoryError异常 本地方法栈什么是本地方法栈本地方法栈描述的是本地方法执行的内存模型，它发挥的作用与虚拟机栈发挥的作用是非常相似的，如Sun HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一，它与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 Java堆什么是Java堆 Java堆是存放对象实例的内存区域 几乎所有对象实例都在这里分配内存 Java堆的特点 Java虚拟机管理的内存中最大的一块 线程共享，在虚拟机启动时创建 垃圾收集器管理的主要区域，从内存回收的角度来看，由于现在收集器都采用分代收集算法，所以可分为新生代和老年代，再细致一点可以分为Eden空间、From Survivor空间和To Survivor空间等。从内存分配来看，线程共享的Java堆可能划分出多个线程私有的分配缓存区TLAB,进一步划分的目的是为了更好地回收内存，或者更快的分配内存 实现中可以固定大小，也可以是可扩展的，如果在堆中没有内存完成实例的分配，并且堆也无法再扩展时，就会抛出OutOfMemoryError异常 方法区什么是方法区 Java虚拟机规范把方法区描述为堆的一个逻辑部分。 他用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码 方法区的特点 线程共享，在虚拟机启动时创建 永久代是因为HotSpot选择将GC分代收集器扩展到方法区，或者使用永久代来实现方法区，对于HotSpot官方发布的路线图信息，现在也有放弃永久代逐步采用Native Memory来实现方法区的规划了，并且已经把原本放在永久代的字符串常量池移除 不需要连续的内存，可以选择固定大小或者可扩展，还可以选择不实现垃圾回收 内存回收的主要目标主要是针对常量池的回收和对类型的卸载，但是回收效率低 当方法区无法满足内存分配的需求的时候，将抛出OutOfMemoryError的异常 运行时常量池 Class文件除了包含类的版本字段、方法、接口等描述信息外，还有一项信息是常量池 常量池用于存放编译期间生成的各种字面量和符号引用，这部分内容在类加载后进入运行时常量池中存放 运行时常量池相对于Class文件常量池具有动态性，Java语言不要求只有Class文件中的常量池的内容才能进入运行时常量池，运行时也可能将新的常量放入池中，如String类的intern方法 当常量池无法再申请内存时将会抛出OutOfMemoryError异常 PS： jdk1.7的常量池移到了堆中，同时在jdk1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域 直接内存 通过一个存储在Java堆中的DirectByteBuffer对象最为这块内存的引用进行操作，这个可以显著提高性能，因为避免了在Java堆和Native堆中来回复制数据 案例是NIO类引入一种基于通道与缓存区的I/O方式，它可以使用Native函数库直接分配对外内存，然后通过DirectByteBuffer进行操作 本机直接内存的分配不会受到Java堆大小的限制，但是会受到本机总内存大小和处理器寻址空间的限制，也可能会抛出OutOfMemoryError异常 总结本篇文章是参考《深入理解Java虚拟机》第二版所写，当时作者用的是jdk1.7，结果现在jdk1.9都出了，最大的改变就是方法区了，目前还没有能力改正，也就将就了，望作者早日更新，或者自己成为大牛，将这部分重新整理。 参考 深入理解JVM(一)——JVM内存模型 Java 8: 从永久代（PermGen）到元空间（Metaspace）]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot静态资源的处理]]></title>
    <url>%2F2017%2F10%2F20%2Fspringboot%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[引：由于springboot架构遇到了图片的上传处理，以及之后的前台显示，所以就理解了一下其中关于静态资源的处理。 默认的静态资源处理在每次启动springboot的项目的时候，我们都可以在控制台看见下面的语句输出：1232017-10-20 16:06:50.540 INFO 36443 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-10-20 16:06:50.540 INFO 36443 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-10-20 16:06:50.569 INFO 36443 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 这里面就用到了springboot默认的静态资源处理。 其中默认配置的/**映射到/static（或/public、/resources、/META-INF/resources） 其中默认配置的/webjars/**映射到classpath:/META-INF/resources/webjars/ PS：上面的 static、public、resources 等目录都在 classpath: 下面（如 src/main/resources/static） 在访问静态资源的时候，这些目录也会有一个查找顺序（优先级）：这里测试过发现他们的优先级是：META/resources &gt; resources &gt; static &gt; public 自定义静态资源处理配置方式 通过配置文件（application.properties）配置1234# 默认值为 /**spring.mvc.static-path-pattern=# 默认值为 classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ spring.resources.static-locations=这里设置要指向的路径，多个使用英文逗号隔开， 当我们要设置成我们的目录：/myresource/**，我们需要这样设置:12spring.mvc.static-path-pattern=/**spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/,classpath:/myresource/ 当我们设置过映射路径时候，如果还是/**,那么默认的映射就失效了，我们需要重新把原来的路径也添加上。这里的配置路径只可以设置一个。 通过配置类配置12345678@Configurationpublic class MyWebAppConfigurer extends WebMvcConfigurerAdapter&#123; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler("/myresource/**").addResourceLocations("file:/var/alldata/image/"); super.addResourceHandlers(registry); &#125;&#125; 可以通过这个方式设置多个配置路径。 配置内外目录 内部目录 做法是添加映射路径 classpath:/路径 方式见通过配置文件配置 外部目录 想一想如果将上传的图片继续存在jar包中会有那些问题？ 网络数据与程序代码不能分离 数据传到jar里速度慢 数据备份麻烦 有了以上的考虑我们会想到将上传的数据放在磁盘的目录上。 做法是添加映射路径 file:/var/alldata/images 方式见通过配置类配置 总结springboot倡导的是习惯优于配置，大部分时候我们用他默认的配置就好了，但是他也提供了方便的配置类，需要我们好好学习。 参考 Spring Boot 静态资源处理 Springboot 之 静态资源路径配置]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac中环境变量的配置]]></title>
    <url>%2F2017%2F09%2F21%2Fmac%E4%B8%AD%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[引：在使用ubuntu和mac这么久之后，环境变量的几个文件还弄不清楚，真是汗颜，这里记录一下，下次不会乱改。 环境变量的作用 使用场景在命令行直接通过命令执行程序，这些程序就多了，最常见就有java，npm，maven，git,如果我们不配置环境变量的话，就需要到程序的安装目录去执行相关命令，大家都会感觉超级麻烦，加入要使用多个程序的话，要么去切换目录，要么就多开几个命令行窗口。顿时就会感觉超级无奈有么有？ 具体作用配置完程序的环境变量之后就可以无所欲为了，可以在任何目录下直接执行我们所要的程序了，是不是顿时感觉方便许多，基本上所有人都知道吧。 环境变量的配置单次环境变量配置假如你出了个意外，在命令行中突然不能使用各种命令了，也没事，至少接下来可以让你短暂的使用一些命令，命令行窗口关闭之后就失效了，我们要做的只是直接在命令行中输入： export PATH=/usr/bin:/usr/sbin:/bin:/sbin 当然后面你也能够添加一些你自己想要使用的程序命令。 环境变量文件配置 环境变量的写法 export PATH=$JAVA_HOME/bin:$PATH 环境变量文件优先级 /etc/profile /etc/bashrc /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc其实后三个文件我也没怎么看到过，主要讲一下前面三个 环境变量文件详解 /etc/profile：全局配置文件，不管是哪一个用户登录，都会读取该文件（但是超级不建议修改，容易出现大问题，想试试什么大问题，自己体会） /etc/bashrc 全局配置文件，bash shell执行时，不管是何种方式，都会读取此文件（一般在这个文件中添加系统级环境变量） ~/.bash_profile：每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!（一般在这个文件中添加用户级环境变量） 立即生效环境变量配置 source ~/.bash_profile 软连接自己一开始也会特别的惊讶，自己在mac上没有设置环境变量有的时候也可以直接就访问到了某些文件。这个是为什么呢？答案是用了软连接。 查看加载文件rexdeMacBook-Pro:etc rex$ cat /etc/paths /usr/local/bin /usr/bin /bin /usr/sbin /sbin 然后就可以去看这些文件夹下面的东西了，弄不清楚也没关系，其实就是软链接。开机后，mac会自动加载paths文件下面的这些目录。在这些文件夹下面建立软连接，可以达到同样的效果（日后学习）。 软连接查看在拥有软连接的目录下使用下面命令 ls -li 406876 lrwxr-xr-x 1 root wheel 73 7 9 2016 jar -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/jar 406877 lrwxr-xr-x 1 root wheel 79 7 9 2016 jarsigner -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/jarsigner 406878 lrwxr-xr-x 1 root wheel 74 7 9 2016 java -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java 406879 lrwxr-xr-x 1 root wheel 75 7 9 2016 javac -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javac 406880 lrwxr-xr-x 1 root wheel 77 7 9 2016 javadoc -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javadoc 建立软连接等自己看了linux的相关知识再来说吧。 总结希望下次自己再也不要因为环境变量配置错出各种问题了，thanks god！ 参考：Mac 中环境变量的配置和理解]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages+Hexo SEO引擎优化]]></title>
    <url>%2F2017%2F07%2F16%2FGithub-Pages-Hexo-SEO%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[引：写的博客自然想让人看到，但是但是自己为了想独立管理（冠冕堂皇）选择了GIthub Pages+Hexo来搭建自己的博客，结果发现自己的博客在百度，谷歌都无法搜到，那时候我才知道自己缺少了SEO。 百度优化登录百度站长 在里面我们可以发现各种向百度提交的方法，这一切都是为了让百度的爬虫更好的爬取我们的网页。 通过baidumapsite.xml自动提交 这里推荐一个博文：Hexo NexT 主题SEO优化指南 通过主动提交 这里推荐一个自动化工具：exo插件之百度主动提交链接 谷歌优化登录谷歌站长 通过map.site自动提交 这里面推荐一个博文：生成sitemap站点地图 总结自己在谷歌配置是成功的，但是在百度并没有成功，可能是因为github真的把百度给干了。自己还是等开学转到自己的服务器上吧。慢慢SEO！！！！ PS:Hexo博客的搭建的可以参考这一篇 搭建Hexo博客中碰到的坑]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新系统开发环境的一系列配置]]></title>
    <url>%2F2017%2F07%2F15%2F%E6%96%B0%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[引：总是不可避免的重装系统，人的脑子不可能那么好记住所有的操作，既然不想自己自己用博客记下所有操作，那么就把别人的博客（自己踩过）记录下来，以后备用。 window篇 JDK——java开发者起步 JDK的安装与环境变量的配置 Node——前端好基友 Node.js安装及环境配置之Windows篇 Sublime3——轻量级编辑器 Sublime Text3安装与插件配置 git——分布式版本控制工具 Git安装教程 Idea——java开发利器 IntelliJ IDEA注册码 Maven——项目依赖管理利器 Maven Windows10安装 Mac篇待写 Ubuntu篇待写 双系统Win10和Ubuntu16.04双系统安装详解]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅尝Apache Camel]]></title>
    <url>%2F2017%2F07%2F15%2F%E6%B5%85%E5%B0%9DApache-Camel%2F</url>
    <content type="text"><![CDATA[引：最近项目有一个需求就是定时将一台服务器的文件传到另一个服务器，一开始想的竟然想的是用http去下载，后来在万老师的指点下，采取用ftp服务器（源文件所在地）与ftp客户端（源文件去向）的形式来处理，自己小试了一下，还不错！ Apache Camel简介Apache Camel是Apache基金会下的一个开源项目,它是一个基于规则路由和处理的引擎，提供企业集成模式的Java对象的实现，通过应用程序接口 或称为陈述式的Java领域特定语言(DSL)来配置路由和处理的规则。其核心的思想就是从一个from源头得到数据,通过processor处理,再发到一个to目的的。 这个from和to可以是我们在项目集成中经常碰到的类型:一个FTP文件夹中的文件,一个MQ的queue（jms）,一个HTTP request/response,一个webservice等等. Apache Camel架构 其实理解起来很简单：始端》（过滤器+路由处理器）》终端 Apache Camel核心概念 endpoint,所谓的endpoint,就是一种可以接收或发送数据的组件。可以支持多种协议，如jms,http,file等。 processor,它是用来处理具体业务逻辑的组件。 route,用来路由，指示数据从哪里来到哪里去，中间用哪个processor处理。 exchange,processor之间用exchange对象来传送数据，有点像jms,通俗一点就像上学时传的小纸条,所以：exchange对象就是processor，endpoint所有camel组件之间传送数据的小纸条:)。 filter，用来确定哪些东西可以传递，哪些东西不可以传递。 Apache Camel例子（以ftp为例）老师指导的例子，是结合Springboot的，放在github上了。ApacheCamleDemo 里面包括了动态路由和单路由的例子，稍微结合Springboot就可以理解并改成自己的代码。 什么时候用Apache Camel参考网上的说法：camel就是企业信息集成框架，它提供了很多简单好用而又强大的组件，用户可以根据场景来选择不同的EIP（企业集成模式）来实现自己的需求，以响应快速变化的业务。可以把它当成企业信息总线（ESB）的轻量级实现。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>ApacheCamel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java ftp 上传下载的坑]]></title>
    <url>%2F2017%2F07%2F15%2Fjava-ftp-%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[引：还是项目需要，要定时执行一个文件下载业务，一开始方向有点错，但是还好纠正过来了，采用ftp下载，但是ftp下载也有各种坑！ 准备jar包：commons-net ftp上传程序：1234567891011121314151617181920212223242526272829303132333435363738public static boolean uploadFile( String url,//服务器主机号 int port,//服务器端口 String username,//用户名 String password,//密码 String path, //上传路径Mar String filename,//上传为服务器上的文件名 InputStream //input本地上传的文件流) &#123; boolean success = false; FTPClient ftp = new FTPClient(); try &#123; int reply;MarkDown ftp.connect(url, port);//连接FTP服务器 //如果采用默认端口，可以使用ftp.connect(url)的方式直接连接FTP服务器 ftp.login(username, password);//登录 reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) &#123; ftp.disconnect(); return success; &#125; ftp.changeWorkingDirectory(path); ftp.storeFile(filename, input); input.close(); ftp.logout(); success = true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ftp.isConnected()) &#123; try &#123; ftp.disconnect(); &#125; catch (IOException ioe) &#123; &#125; &#125; &#125; return success;&#125; 测试代码：123File file = new File(&quot;/var/test.txt&quot;);InputStream is = new FileInputStream(file);uploadFile(&quot;127.0.0.1&quot;,21,&quot;test&quot;,&quot;123456&quot;,&quot;/var/data/test&quot;,&quot;testdemo.txt&quot;,is); ftp下载程序：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public static boolean downFile(String url, //FTP服务器hostnameint port,//FTP服务器端口String username, //FTP登录账号String password, //FTP登录密码String remotePath,//FTP服务器上的相对路径String fileName,//要下载文件关键字String localPath//下载后保存到本地的路径) &#123; FTPClient ftpClient = null; boolean success = false; try &#123; ftpClient = new FTPClient(); ftpClient.connect(url, port);// 连接FTP服务器 ftpClient.login(username, password);// 登陆FTP服务器 ftpClient.setControlEncoding("gb2312"); // 中文支持 ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);//设置文件格式 ftpClient.enterLocalPassiveMode(); logger.info(ftpClient.getReplyCode()); if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) &#123; logger.warn("未连接到FTP，用户名或密码错误。"); ftpClient.disconnect(); &#125; else &#123; logger.info("FTP连接成功。"); &#125; ftpClient.changeWorkingDirectory(remotePath); FTPFile[] fs = ftpClient.listFiles(); File file = new File(localPath); if(!file.exists())&#123; file.mkdirs(); &#125; for(FTPFile ff:fs)&#123; if(ff.getName().contains(fileName))&#123; File localFile = new File(localPath+"/"+ff.getName()); if (localFile.exists())&#123; continue; &#125; OutputStream os = new FileOutputStream(localFile); long time1 = System.currentTimeMillis(); boolean b = ftpClient.retrieveFile(new String(ff.getName().getBytes("gb2312"),"ISO8859-1"), os); os.flush(); os.close(); &#125; &#125; ftpClient.logout(); success = true; &#125; catch (SocketException e) &#123; e.printStackTrace(); logger.warn("FTP的IP地址可能错误，请正确配置。"); &#125; catch (IOException e) &#123; e.printStackTrace(); logger.warn("FTP的端口错误,请正确配置。"); &#125; finally &#123; if (ftpClient.isConnected()) &#123; try &#123; ftpClient.disconnect(); &#125; catch (IOException ioe) &#123; &#125; &#125; &#125; return success;&#125; 测试程序：1downFile(&quot;127.0.0.1&quot;,21,&quot;test&quot;,&quot;123456&quot;,&quot;、var/data/test&quot;,&quot;demo&quot;,&quot;/var/alldata&quot;); 一些坑 客户端接受的编码 1ftpClient.setControlEncoding(&quot;gb2312&quot;); // 中文支持 如果服务器上的文件名有中文，一定要加上这一句，具体编码要根据服务器的编码。 客户端接受的文件类型 1ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);//设置文件格式 文件类型要根据下载的文件格式来定 服务器端口设置 1ftpClient.enterLocalPassiveMode(); 调用FTPClient.enterLocalPassiveMode();这个方法的意思就是每次数据连接之前，ftp client告诉ftp server开通一个端口来传输数据，防止在新端口对外部不通，因为ftp server可能每次开启不同的端口来传输数据，但是在linux上，由于安全限制，可能某些端口没有开启，所以就出现阻塞。 最大的坑（下载出0kb的文件：实质就是retrieveFile方法执行失败） 1ftpClient.retrieveFile(new String(ff.getName().getBytes(&quot;gb2312&quot;),&quot;ISO8859-1&quot;), os) 一定要给文件名换编码，让它识别中文，具体编码也是根据实际情况而定。 总结ftp客户端的速度也是要根据网速来的，可能比一般http快，但是面对网速慢的情况也是无可奈何！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js原型和原型链]]></title>
    <url>%2F2017%2F07%2F13%2Fjs%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[引：刚刚说了闭包，那就不放过js的另一大难点了——js原型以及原型链。 谈谈神图镇楼：自己写了好几遍内容，但是自己发现还是不能系统的理解，自己也写不了多好，看来要到自己安心写前端的时候，再来补上了。 参考 最详尽的 JS 原型与原型链终极详解（一） 最详尽的 JS 原型与原型链终极详解（二） 最详尽的 JS 原型与原型链终极详解（三） 个人感觉上面的文章还不错，可能还缺了继承那块的讲解，等自己再来的时候一起补上吧！！！！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈js闭包]]></title>
    <url>%2F2017%2F07%2F12%2F%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[引：最近项目前端用了angular2，里面使用的TypeScript,其实很多和Java挺像的，学起来还是挺快的。但是里面的很多变量的原理都是根据闭包来实现的，那就好好了解一下闭包。 闭包定义根据Mozilla开发者文档定义： 闭包是指向独立变量的“函数”,用通俗的话说就是会“记住”它创建时的环境。 闭包涉及的主要概念 作用域链 作用域链是函数在定义的时候创建的,用于寻找使用到的变量的值的一个索引。它内部的规则是,把函数自身的本地变量放在最前面,把自身的父级函数中的变量放在其次,把再高一级函数中的变量放在更后面,以此类推直至全局对象为止.当函数中需要查询一个变量的值的时候,js解释器会去作用域链去查找,从最前面的本地变量中先找,如果没有找到对应的变量,则到下一级的链上找,一旦找到了变量,则不再继续.如果找到最后也没找到需要的变量,则解释器返回undefined. 内存回收机制 一个函数在执行开始的时候,会给其中定义的变量划分内存空间保存,以备后面的语句所用,等到函数执行完毕返回了,这些变量就被认为是无用的了.对应的内存空间也就被回收了.下次再执行此函数的时候,所有的变量又回到最初的状态,重新赋值使用.但是如果这个函数内部又嵌套了另一个函数,而这个函数是有可能在外部被调用到的.并且这个内部函数又使用了外部函数的某些变量的话.这种内存回收机制就会出现问题.如果在外部函数返回后,又直接调用了内部函数,那么内部函数就无法读取到他所需要的外部函数中变量的值了.所以js解释器在遇到函数定义的时候,会自动把函数和他可能使用的变量(包括本地变量和父级和祖先级函数的变量(自由变量))一起保存起来.也就是构建一个闭包,这些变量将不会被内存回收器所回收,只有当内部的函数不可能被调用以后(例如被删除了,或者没有了指针),才会销毁这个闭包,而没有任何一个闭包引用的变量才会被下一次内存回收启动时所回收. 闭包现象123456789var results = [];for (var i = 0; i &lt;3; i++) &#123;results[i] = function() &#123;console.log(i);&#125;&#125;results[0](); //3results[1](); //3results[2](); //3 解析：其实这里return出来的是一个function（我们可以理解为他是一个字符串，还没有执行），等到我们去执行他的时候，只保存了他上一级的作用域链里面的i的索引,那个时候i已经是3了。 闭包解决让内部函数在循环创建的时候立即执行,并且捕捉当前的索引值,然后记录在自己的一个本地变量里.然后利用返回函数的方法,重写内部函数,让下一次调用的时候,返回本地变量的值,改进后的代码:1234567891011var results = [];for (var i = 0; i &lt;3; i++) &#123;results[i] = (function(j) &#123;return function()&#123;console.log(j);&#125;&#125;)(i);&#125;results[0](); //0results[1](); //1results[2](); //2 我们发现通过立即执行表达式就可以解决闭包的现象得到我们想要得到的现象。 闭包应用闭包与静态变量前面就说TypeScript与Java很像，所以类中的静态变量也是有的。 TypeScript代码：12345678910111213141516class Counter &#123;private static COUNTER = 0;constructor() &#123;&#125;private changeBy(val) &#123;Counter.COUNTER +=val;&#125;public increment() &#123;this.changeBy(1);&#125;public decrement() &#123;this.changeBy(-1);&#125;public value() &#123;return Counter.COUNTER;&#125;&#125; 编译之后的js代码:123456789101112131415161718var Counter = (function () &#123;function Counter() &#123;&#125;Counter.prototype.changeBy = function (val) &#123;Counter.COUNTER += val;&#125;;Counter.prototype.increment = function () &#123;this.changeBy(1);&#125;;Counter.prototype.decrement = function () &#123;this.changeBy(-1);&#125;;Counter.prototype.value = function () &#123;return Counter.COUNTER;&#125;;Counter.COUNTER = 0;return Counter;&#125;()); 从js代码可以看书静态变量COUNTER是属于Counter类的，并不属于对象原型。所有Counter实例都共享Counter的同一个闭包上下文环境（COUNTER）。所以COUNTER会表现像单例一样。 闭包和私有成员TypeScript由于性能原因并没有使用闭包来模拟私有变量，他使用过编译检查机制来形成私有变量的特性。但是我们可以使用闭包来实现私有变量。 js代码如下：123456789101112131415161718function makeCounter() &#123;var COUNTERR = 0;function Counter() &#123;&#125;function changeBy(val) &#123;COUNTER += val;&#125;;Counter.prototype.increment = function () &#123;this.changeBy(1);&#125;;Counter.prototype.decrement = function () &#123;this.changeBy(-1);&#125;;Counter.prototype.value = function () &#123;return COUNTER;&#125;;return new Counter();&#125;; 从上面的代码可以看出，每一个新的makeCounter实例都拥有自己的上下文环境，其他实例访问不了。 总结学习这么久的js发现，其实闭包真的无处不在，需要好好学习，好好总结，如有不对，也希望大家能够指出。 参考链接：js中闭包原理谈和原型及例子 书籍：Learning TypeScript中文版]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java日志那些事]]></title>
    <url>%2F2017%2F07%2F12%2FJava%E6%97%A5%E5%BF%97%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[引：一直都知道日志文件很重要，可以记录一些相关信息，但是可能是程序需要调试的内容太少，也或者是项目太小，所以看看控制台的信息就够了，但是这次接触的项目越来越大，控制台额信息越来越多，经常会看不到自己想要看到的信息时，这个时候使用日志就发现十分得有必要了！ 日志的好处 方便调试(如上) 方便发现系统运行中的错误 存储业务数据，便于日后分析 日志实现方式 自己实现类通过io存储到文件中 使用log4j将日志输入到控制台，文本文件，一集数据库中。 使用jdk自带的logging.jar包中方法（同一作者还有lognback） 使用slfj，它提供了上述两种方法的接口。 日志的输出(以log4j为例) 输入到控制台 运行程序：1234567891011public class LoggerTest &#123;public static Logger logger1 = Logger.getLogger(LoggerTest.class);public static void main(String[] args) &#123;logger1.trace(&quot;我是logger1，trace&quot;);logger1.debug(&quot;我是logger1，debug&quot;);logger1.info(&quot;我是logger1，info&quot;);logger1.warn(&quot;我是logger1，warn&quot;);logger1.error(&quot;我是logger1，error&quot;);logger1.fatal(&quot;我是logger1，fatal&quot;);&#125;&#125; 配置文件如下：123456789### 设置级别和目的地(这里多个目的地) ###log4j.rootLogger = DEBUG,CONSOLE### 这里的com.todorex是包，也就是在这个包记录日志时，是只记录debug及以上级别的日志log4j.logger.com.todorex=DEBUG### 输出到控制台 ###log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.Target = System.outlog4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern = %d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n 控制台输出:1234511:35:09,969 DEBUG LoggerTest:12 [main:0]- 我是logger1，debug11:35:09,972 INFO LoggerTest:13 [main:3]- 我是logger1，info11:35:09,972 WARN LoggerTest:14 [main:3]- 我是logger1，warn11:35:09,972 ERROR LoggerTest:15 [main:3]- 我是logger1，error11:35:09,972 FATAL LoggerTest:16 [main:3]- 我是logger1，fatal 输入到日志文件运行程序同上；配置文件如下：1234567891011121314151617181920### 设置级别和目的地(这里可以多个目的地) ###log4j.rootLogger = trace,demoLoglog4j.logger.com.todorex=DEBUG### 输出到控制台 ###log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.Target = System.outlog4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern = %d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L [%t:%r]- %m%n### 输出到日志文件（文件目录一定要是绝对路径且存在） ###log4j.appender.demoLog = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.demoLog.File =/var/alldata/mylog.loglog4j.appender.demoLog.Append = true## 只输出DEBUG级别以上的日志log4j.appender.demoLog.Threshold = DEBUG#&apos;.&apos;yyyy-MM-dd: 每天产生一个新的文件log4j.appender.demoLog.DatePattern = &apos;.&apos;yyyy-MM-ddlog4j.appender.demoLog.layout = org.apache.log4j.PatternLayoutlog4j.appender.demoLog.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%t:%r] - [%p] [%c&#123;1&#125;:%L] [%M] %m%n 文件内容同控制台输出，但是却比控制台清楚得多，不会被乱七八糟的信息给遮盖。 输入到数据库 运行程序:1234567public class LoggerTest &#123;public static void main(String[] args) &#123;Logger logger = Logger.getLogger(LoggerTest.class);logger.info(&quot;good&quot;);logger.debug(&quot;success&quot;);&#125;&#125; 配置文件：1234567891011log4j.rootLogger=trace,CONSOLE,demoLog# com.todorex包下面所有的日志输出的级别设为DEBUGlog4j.logger.com.todorex=DEBUG# 数据库输出log4j.appender.demoLog=org.apache.log4j.jdbc.JDBCAppenderlog4j.appender.demoLog.driver=com.mysql.jdbc.Driverlog4j.appender.demoLog.URL=jdbc:mysql://127.0.0.1:3306/testlog4j.appender.demoLog.user=rootlog4j.appender.demoLog.password=root# 在数据库对应的位置建一个对应的log表log4j.appender.demoLog.sql=insert into log(level,category,thread,time,location,note) values(&apos;%p&apos;,&apos;%c&apos;,&apos;%t&apos;,&apos;%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;&apos;,&apos;%l&apos;,&apos;%m&apos;) 数据库的具体内容就不贴出来了，和普通看到的一样。 总结其实日志用几次就知道它的好了，自己也是在慢慢学习！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jpa实体映射关系]]></title>
    <url>%2F2017%2F06%2F15%2Fjpa%E5%AE%9E%E4%BD%93%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[引：其实距离自己上次写数据库操作已经1个多月了，之前接触的就是Hibernate，这次接触jpa，就把几种对应关系理清。 映射策略注：这次举的例子都是User和Car的 外键关联简介：两个表的关系定义在其中一个表中 @OneToOne方法一：123@OneToOne(cascade=CascadeType.ALL, fetch=FetchType.EAGER)@JoinColumn(name = &quot;user_id&quot;)private Car car; 通过在Car表中加入一个外键，实现两者关系。方法二：12@OneToOne(cascade = CascadeType.ALL,fetch = FetchType.EAGER,mappedBy = &quot;Car&quot;)private User user; 通过在Car类中用MappedBy声明让User进行维护。 @OneToMany123@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)@JoinColumn(name = &quot;user_id&quot;)private Set&lt;Car&gt; cars; 通过在Car表中加入一个外键，实现一对多关系。 @ManyToMany12@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)private Set&lt;Car&gt; cars; 这个是采用默认的表关联 表关联简介：两个表的关系通过一张中间表来来关联 @OneToMany12345@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)@JoinTable(name = &quot;user_car&quot;,joinColumns=&#123;@JoinColumn(name = &quot;user_id&quot;)&#125;,inverseJoinColumns = &#123;@JoinColumn(name = &quot;car_id&quot;)&#125;)private Set&lt;Car&gt; cars; 通过JoinTable来确定一张中间表，joinColumns里面放父表的属性，inverseJoinColumns放子表的属性 @ManyToMany12345@ManyToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)@JoinTable(name = &quot;user_car&quot;,joinColumns=&#123;@JoinColumn(name = &quot;user_id&quot;)&#125;,inverseJoinColumns = &#123;@JoinColumn(name = &quot;car_id&quot;)&#125;)private Set&lt;Car&gt; cars; 解释如@OneToMany 一些属性cascade属性 CascadeType.PERSIST：级联新建 CascadeType.REMOVE：级联删除 CascadeType.REFRESH：级联刷新 CascadeType.MERGE：级联更新 CascadeType.ALL：包括上面四项 fetch属性 FetchType.EAGER：相当于禁用懒加载，推荐开发使用 FetchType.LAZY：懒加载，默认值，推荐部署使用 总结父表是提供主键的，子表是利用父表的主键来设置外键的，维护方是Owner，被维护方是Owned。提示自己一个傻逼的问题，插入数据要先往两张表中插入数据，在往中间表插入数据，不然会报错~]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>sping</tag>
        <tag>jpa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot项目调试angular2]]></title>
    <url>%2F2017%2F06%2F01%2Fspringboot%E9%A1%B9%E7%9B%AE%E8%B0%83%E8%AF%95angular2%2F</url>
    <content type="text"><![CDATA[引：在接触 springboot和angular2的前后端项目的时候，我发现自己会先把angular2的项目编译好之后放在springboot的resource目录下的static文件夹下运行，虽然这样可以，但是对于前端来调试代码实在不方便。在百度网上的方法之后可以采用如下代理的方式。 问题 angular2启动的服务默认为http://localhost:4200 springboot启动的服务默认为http://localhost:8080 如果我们直接设置angular2访问的路径为http://localhost:8080就会出现跨域访问的问题。请求不到数据。 解决在angular2项目的根目录下面新建一个proxy.config.json123456&#123;&quot;/api&quot;: &#123;&quot;target&quot;: &quot;http://localhost:8081&quot;,&quot;secure&quot;: false&#125;&#125; 然后在启动项目的时候采用下面的命令 ng serve –proxy-config proxy.config.json 通过这样的代理访问就能能够实现跨域访问请求数据。 总结通过上面的方法方便了开发调试，不错，终于要开始写代码了！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>angular2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringSecurity+JWT保驾SpringBoot(未完)]]></title>
    <url>%2F2017%2F05%2F24%2FSpringSecurity-JWT%E4%BF%9D%E9%A9%BESpringBoot-%E6%9C%AA%E5%AE%8C%2F</url>
    <content type="text"><![CDATA[引：在万老师的指引下，开始接触到了安全板块，SpringSecurity+JWT绝对能够让人欣喜 JWT介绍关于JWT说实话是最近才听到的，然后慢慢开始了解，这里简单记下一篇博文。这篇博文在做过简单的应用之后发现还是不怎么全的 ，等自己再深入了解之后，再来补全。 SpringSecurity整合JWT看了几个SpringSecurity的应用，发现应该是大同小异，自己也找到一篇虽然结构不太好，但大部分内容都讲到的博文。也是日后能够总结得好一点，再来补全。 总结一定要再来！！！！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JWT</tag>
        <tag>SpringSecurity</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular2入门]]></title>
    <url>%2F2017%2F05%2F24%2FAngular2%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[引：由于老师暑假的项目前端代码需要用到Angular2，作为一个后端开发者也是需要了解一丢丢的。 Angular简介在经过简单的了解与使用之后，感觉 到Angular2的强大与伟大，配的上说是一个优秀的前端框架。Angular2实现了前端一直提倡的组件化开发还解决了大部分项目路由混乱的问题。它还有具有MVC分层架构和依赖注入等一系列优秀的特性。现在贴上Angular2的一张架构图：上图描述了Angular2中8大主要构造块的关系，他们具体的理解，可以参考这篇博文。如果还有什么不理解，那我们可以相信实践见真知。 Angular起步在这次学习中，我终于理解了前辈们所说的入门一门技术就好的方法就是去看官方文档了，Angular2的官网文档里面有中文版的，相信大家一定很开心吧。当然没有中文版也是要看的，比较都是最基础的入门，不要惧怕英文。 在这次按照官方文档的教程（英雄编辑器）出现了两个问题，这里也说明一下： angular-in-memory-web-apia模块不存在 解决方法：通过命令行安装 npm i angular-in-memory-web-api 1234567create(name: string): Promise&lt;Hero&gt; &#123;return this.http.post(this.heroesUrl, JSON.stringify(&#123;name: name&#125;), this.headers).toPromise().then(res =&gt; res.json().data as Hero).catch(this.handleError);&#125; 这里的post方法中的第三个参数应该是this.headers,而不是像官方文档中的那样。 总结如果遇到不懂得问候多看看文档吧，相信自己可以的，然后就是实践见真知了。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Angular2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简谈entity，model，domain]]></title>
    <url>%2F2017%2F05%2F23%2F%E7%AE%80%E8%B0%88entity%EF%BC%8Cmodel%EF%BC%8Cdomain%2F</url>
    <content type="text"><![CDATA[引：前两天听到关于entity和domain包的区别，好像之前自己也没有在意过，今天看看网上的信息总结一下。 entity（实体）这好像是最常用的package命名了，package的类一般都是和数据库的表对应的。一个实体，一张表，其字段的类型也是对应的。 model（模型）最初接触到它的时候是Struts的模型驱动，用于接受和显示前台的数据对象。我们要根据实际情况来确定模型的类。 domain（域）说实话，这个包名用得不怎么多，在网上显示它在国外的网站用的比较多，它主要是用于存储一个业务对象（模块对象）。 总结正确命名包名，有助于后续代码的维护，以及后来开发者的维护，最重要的是能衔接行业的规范。慢慢来！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行运行hadoop程序]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8Chadoop%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[引：自己最近心态有点崩，毕竟很迷茫，趁现在比较空 ，也就微微看看hadoop。在运行《Hadoop权威指南》的时候，遇到了按照书上命令行无法运行的问题。 问题 大家都知道刚开始入门，就遇到问题了就必然是十分难受的，那么我们现在可以解决。 解决编辑 ~/.bash_profile12export HADOOP_HOME=/usr/local/hadoopexport CLASSPATH=$($HADOOP_HOME/bin/hadoop classpath):$CLASSPATH 使其生效1source ~/.bash_profile 运行 编译主类 1javac MaxTemperature.java 把.class 文件打包成 jar，才能在 Hadoop 中运行： 1jar -cvf MaxTemperature.jar ./MaxTemperature*.class 创建input文件夹的数据，就可以运行了(每次运行时，output文件夹都应该不存在) 1hadoop MaxTemperature input/ncdc/sample.txt output 总结虽然我自己还不知道书上的命令行为什么不能用，但是还是希望慢慢可以弄懂吧！]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F2017%2F05%2F17%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[引：上次看到过钟华老师的一个基于贪心算法的毕业设计，一直很好奇，今天终于能看看它了，只是知其然，不知所以然。 贪心算法总说贪心算法在每一步都会做出看起来是最佳的选择，也就是说会做出局部最优的选择，希望以此能够得到最优解。 活动选择问题贪心选择我们要选择这样一个活动，选出它之后身下的资源能够被尽量多的其他任务所用，即选择最早结束的活动。 递归贪心算法算法思路：用两个数组s和f表示活动的开始和结束时间。下表k是我们要求解的子问题，以及问题规模n，代码如下：12345678910111213141516171819202122232425262728293031import java.util.ArrayList;import java.util.List;public class ActivitySelector &#123;public int[] s = new int[]&#123;1,3,0,5,3,5,6,8,8,2,12&#125;;public int[] f = new int[]&#123;4,5,6,7,9,9,10,11,12,14,16&#125;;public List&lt;Integer&gt; list = new ArrayList&lt;&gt;();public void recursiveActivitySelector(int[] s, int[] f,int k,int n)&#123;if(list.size()==0)&#123;list.add(1);&#125;int m = k+1;while (m&lt;n &amp;&amp; s[m]&lt;f[k])&#123;m = m+1;&#125;if(m&lt;n)&#123;list.add(m+1);recursiveActivitySelector(s, f, m, n);&#125; else &#123;return ;&#125; &#125;public static void main(String[] args) &#123;ActivitySelector activitySelector = new ActivitySelector();activitySelector.recursiveActivitySelector(activitySelector.s, activitySelector.f, 0, activitySelector.f.length);for (Integer i : activitySelector.list) &#123;System.out.println(i);&#125;&#125;&#125; 迭代贪心算法这个过程是假设输入活动的结束时间是已经排好序的，代码如下：123456789101112131415161718192021222324252627import java.util.ArrayList;import java.util.List;public class GreedyActivitySelector &#123;public int[] s = new int[]&#123;1,3,0,5,3,5,6,8,8,2,12&#125;;public int[] f = new int[]&#123;4,5,6,7,9,9,10,11,12,14,16&#125;;public List&lt;Integer&gt; list = new ArrayList&lt;&gt;();public void greedActivitySelector(int[] s,int[] f)&#123;int n = s.length;list.add(1);int k = 1;for (int m = 1; m &lt; n; m++) &#123;if(s[m]&gt;=f[k])&#123;list.add(k);k = m;&#125;&#125;&#125;public static void main(String[] args) &#123;ActivitySelector activitySelector = new ActivitySelector();activitySelector.recursiveActivitySelector(activitySelector.s, activitySelector.f, 0, activitySelector.f.length);for (Integer i : activitySelector.list) &#123;System.out.println(i);&#125;&#125;&#125; 贪心算法原理设计贪心算法的过程 确定问题的最优子结构 设计一个递归算法 证明一个贪心选择，则只剩下一个子问题 证明贪心选择总是安全的 设计一个递归算法实现贪心策略 将递归算法转换为迭代算法 证明一个贪心算法是否能求解一个最优化问题？具有下面性质就ok？ 贪心选择性质 我们可以通过做出局部最优选择来构造全局最优解 最优子结构 如果一个问题的最优解包含子问题的最优解 总结一步一步慢慢贪心，和做人是一样的，但是总的来说还是要考虑全局的！！！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2017%2F05%2F17%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[引：慢慢就步入了算法导论的高级设计与分析技术模块，先来看看动态规划。ps:快毕业的心情org。 动态规划总说动态规划虽然与分治方法相似，但是它能够解决子问题重叠的情况，这样就提高了效率。它通常是用来求解最优化的问题。求得是一个最优解。一般按如下4个步骤来设计一个动态规划算法。 刻画一个最优解的结构特征 递归地定义最优解的值 计算最优解的值，通常采用自底向上的方法 利用计算出的信息构造出一个最优解 钢条切割先看以前常用的分治方法即自顶向下方法,代码如下：12345678910111213141516171819202122232425262728public class CutRod &#123;//a[i]表示长度为i的钢条利润是多少public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;//自顶向下递归设计public int cutRod(int[] a,int n) &#123;if(n == 0)&#123;return 0;&#125;int q = 0;for (int i = 0; i&lt;n; i++)&#123;q = max(q,a[i]+cutRod(a,n-1-i));&#125;return q;&#125;//求最大值函数public int max(int a, int b)&#123;if(a&gt;b)&#123;return a;&#125; else &#123;return b;&#125;&#125;public static void main(String[] args) &#123;CutRod cut = new CutRod(); int lost = cut.cutRod(cut.a,10);System.out.println(lost);&#125;&#125; 问题：反复地用相同的参数值对自身进行递归调用，造成了运行时间为n的指数函数。 为了解决这个问题，我们可以采用动态规划方法求解最优钢条切割问题。 采用带备忘的自顶向下法核心是利用一个数组存储已经求解过的最优解，避免了重复的计算，具体的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MemoizedCutRod &#123;//a[i]表示长度为i的钢条利润是多少public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;//带备忘的自顶向下函数public int memoizedCutRod(int[] a,int n)&#123;//创建一个备忘的数组存储一个之前计算过的最优解int[] r = new int[n];//初始化数组for (int i : r) &#123;i = 0;&#125;//借助辅助函数计算return memoizedCutRodAux(a, n, r);&#125;//带备忘的自顶向下法辅助函数public int memoizedCutRodAux(int[] a,int n,int[] r) &#123;//定义利润int q = 0;if(n == 0)&#123;return 0;&#125; //判断原先是否已经计算过，若计算过就不用再计算if(r[n-1] &gt;0)&#123;return r[n-1]; &#125;else &#123;for (int i = 0; i&lt;n; i++)&#123;q = max(q,a[i]+memoizedCutRodAux(a, n-1-i, r));&#125;&#125;r[n-1] = q;return q;&#125;//求最大值函数public int max(int a, int b)&#123;if(a&gt;b)&#123;return a;&#125; else &#123;return b;&#125;&#125;public static void main(String[] args) &#123;MemoizedCutRod cut = new MemoizedCutRod();int lost = cut.memoizedCutRod(cut.a, 10);System.out.println(lost);&#125;&#125; 采用由底向上的方法核心是从小算到大算出每一个长度的最优解，然后返回想要的长度的最优解。代码如下： 123456789101112131415161718192021222324252627282930public class BottomUpTopCutRod &#123;//a[i]表示长度为i的钢条利润是多少public int[] a = new int[]&#123;1,5,8,9,10,17,17,20,24,30&#125;;public int bottomUpTopCutRod(int[] a, int n)&#123;int[] r = new int[n+1];//长度为0的时候，收益为0r[0] = 0;int q = 0;for(int i = 0; i&lt;n; i++)&#123;for(int j = 0; j&lt;=i; j++)&#123;q = max(q,a[j]+r[i-j]);&#125;r[i+1] = q;&#125;return r[n];&#125;//求最大值函数public int max(int a, int b)&#123;if(a&gt;b)&#123;return a;&#125; else &#123;return b;&#125;&#125;public static void main(String[] args) &#123;BottomUpTopCutRod cut = new BottomUpTopCutRod();int lost = cut.bottomUpTopCutRod(cut.a, 10);System.out.println(lost);&#125;&#125; 优势：实现了运行时间复杂度n*n 动态规划原理适用应用动态规划方法求解的最优化问题应该具备的两个要素：最优子结构和子问题重叠 最优子结构如果一个问题的最优解包含其子问题的最优解，我们就称这个问题具有最优子结构性质。例如：无权最短路径。 重叠子问题如果递归算法反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质。例如钢条切割。 总结慢慢懂一点小算法思想。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观《驴得水》呻吟]]></title>
    <url>%2F2017%2F05%2F11%2F%E8%A7%82%E3%80%8A%E9%A9%B4%E5%BE%97%E6%B0%B4%E3%80%8B%E5%91%BB%E5%90%9F%2F</url>
    <content type="text"><![CDATA[引：其实当身边同学都在打游戏的时候，我却不能静下心来了，内心仍然是浮躁，既然不能改论文，所以自己就找电影看吧。自认为自己是一个不懂得享受的人，所以在大脑思索良久之后，决定观看好久之前评价还不错的电影《驴得水》。 总说我不知道该以什么角度来评价这部电影，但这部电影给我感受是深刻，至少在灵魂上还是有一定的冲击，感觉作者与导演把每个角色想要表达的思想基本上都表达出来了，下面我也将按这些角色把在我身上能够体会到的思想说一下，至少在我心里，这是一部好电影。 角色思想校长这个一个有抱负的校长，但是却又特别的自私，为了达成自己的抱负，他选择了屈服，虽然在某些片段来说，他有一点想反抗，如他不能忍受裴魁山去骂张一曼，但是那一点反抗却是那么无力，到最后他选择了屈服，屈服到了让自己的女儿去做牺牲。关于这个角色我不想做太多评价，他总说以大局为重，或许在生活中很多人都会这么做，自私到可以牺牲掉很多。 裴魁山这个角色应该就是现在很多人所说的腹黑吧，自己得不到，就宁愿把他毁掉，他从不介意张一曼的出身愿意娶她，到指着他的鼻子骂，这个转变让很多人心凉，追不到还能做朋友么，他的回答告诉我们，他不搞她已经是最好的结果了。爱一个可以随时为她着想，恨一个人希望所有人都恨他。 铜匠也许他后面变得很坏，但是我从头到尾都认为他是这部剧最可怜的人，他原来是一个单纯至极的人，命运使然他加入到了一个骗子集团吧，因为单纯才会认为张一曼会喜欢他吧，因为单纯所以期望太高，这导致在张一曼骂他牲口之后开始最强烈的抱负。但是有一点他这个觉得传递了不好的概念，有知识不是为了更好的抱负，而是应该为了更好的帮助别人，虽然他的行为可以理解，但是却不提倡，从他到最后还是想去美国学习，可以看出他还是很想学习的，想脱离文盲这个行列。 张一曼这是一个不畏世俗的眼光，勇敢追求自由的女子，也不能说是道德败坏吧，虽然和有妇之夫搞一起不太好，但是他自己也有自己的原则，就像他一开始不愿意将她和铜匠的事情说出来一样，他有自己一定的原则。但是在校长的屈服下，也造就了他的悲剧，最后开枪自杀了。 周铁男这个角色也是反映了一部分人，他喜欢孙佳，但是一直没有说出来，也算单纯耿直的人，平时脾气挺冲，在别人要动孙佳的时候也立马站了出来，可惜在擦过枪子的之后，他选择了屈服，他慢慢开始收敛自己，只是为了能够活下去，他甚至可以认忍受孙佳去嫁给铜匠，所以说，所谓的爱在现实的生与死之间是那么的不堪。 孙佳这个人或许是这部剧中完全没有污点的人吧，应该也是导演想表达的正面形象，他是唯一一个把驴得水当做人看的人，也是第一个想揭发整个阴谋的人，面对这一切，她说过去的都让他过去的话，那么只能越来越错，不能让错误一直延续下去。莫名戳中内心。 特派员一个目不识丁，却假装英国留学回来的官员，所谓的民间教育家的评选，不过是教育部敛财的名头，从被骗到一起骗说明政府的腐败与强势，从十万到三万，我们看到了心凉。 总结主要人物各有各的责任，他们都反应了这个世界上的一部分人，所以感受很深，点评不当之处，也希望大家担待。好吧，呻吟到此结束。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择算法]]></title>
    <url>%2F2017%2F05%2F10%2F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[引：300000是不是一个小目标，不知道为了目的还是目的，只想好好努力，功利也好，安慰也罢！ 期望为线性时间的选择算法算法思想： 检查数组是否只有一个数，如是，只好返回该数 采用随机分割将数组氛围a[p..q-1]和a[q+1..r]并返回主元q 检查如果该主元就是我们要找的数，就返回 判断前半部分的个数，如果要找的顺序大于前面的个数，就递归调用后面的数组，否则递归调用前面的数组 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Random;public class Randomized_select &#123;public int randomized_select(int[] a,int p, int r,int i)&#123;//如果分割到只剩一个元素了，那么就是这个了if(p == r)&#123;return a[p];&#125;//随机分割int q = randompartition(a, p, r);//确定q是第几小的数int k = q-p+1;if(k == i) &#123;return a[q];&#125;else if(k&lt;i)&#123;//递归调用后半部分的数return randomized_select(a, q+1, r, i-k);&#125; else &#123;//递归调用前半部分的数return randomized_select(a, p, q-1, i);&#125; &#125;//分割函数public int partition(int[] a,int p,int r)&#123;int x = a[r];int i = -1;int temp = 0;for (int j = 0; j &lt; a.length-1; j++) &#123;if(a[j]&lt;x)&#123;i=i+1;temp = a[i];a[i] = a[j];a[j] = temp;&#125;&#125;temp = a[i+1];a[i+1] = x;a[r] = temp;return i+1;&#125;//随机分割 public int randompartition(int[] a,int p,int r)&#123;int temp = 0;Random random = new Random();int i = random.nextInt(r);temp = a[i];a[i] = a[r];a[r] = temp;return partition(a, p, r);&#125;public static void main(String[] args) &#123;int[] a = new int[]&#123;3,2,9,0,7,5,4,8,6,1&#125;;Randomized_select select = new Randomized_select();int num = select.randomized_select(a, 0, a.length-1, 10);System.out.println(num);&#125;&#125; 算法分析：期望时间复杂度是线性的O(n),但是最坏的时间复杂度是O(n*n) 最坏情况为线性时间的选择算法算法思想： 将输入数组的n个元素划分为n/5组，每组5个元素，且至多只有一组由剩下的nmod5个元素组成。 寻找每一个组的中位数：首先对每组元素进行插入排序，然后确定每组的中位数。 对第2部的中位数数组利用递归调用前面的random_select()求取中位数x 利用修改的partition(),按中位数x进行划分，得到比x小的数有k个 如果i=k则返回x。如果ik，则在高区递归查找第i-k小的元素 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package select;public class GoodSelect &#123;//插入排序public void insertsort(int[] a,int p, int r)&#123;for (int i=p+1;i&lt;=r;i++) &#123;int temp = 0;//*从后往前插*for(int j = i;j&gt;p &amp;&amp; a[j]&lt;a[j-1];j--)&#123;temp = a[j];a[j] = a[j-1];a[j-1] = temp;&#125;&#125;&#125;//对数组A[]分组，每组5个元素，分别进行插入排序,返回中位数数组public int[] partInsertSort(int[] a,int p,int r) &#123;int i = 0;int[] b;if((r-p+1)%5==0)&#123;b = new int[(r-p+1)/5];&#125; else &#123;b = new int[(r-p+1)/5+1];&#125;int Length = r-p+1;if (Length &lt;= 5) //元素个数少于5个&#123; insertsort(a,p,r);b[0]=a[p+(Length-1)/2];&#125;else&#123;for (i=0;i&lt;Length/5;i++)&#123;insertsort(a,p+i*5,p+i*5+4);b[i]=a[i*5+2]; //B[i] 存储各组中位数&#125;if ( Length%5 != 0 )&#123;insertsort(a,Length-1-(Length-1)%5,Length-1);b[i]=a[Length-1-Length%5/2]; //B[i] 存储最后一组中位数&#125;&#125;return b; // 返回分组的个数&#125;//调用random_select算法，选出中位数数组的中位数public int selectmid(int[] a)&#123;Randomized_select randomized_select = new Randomized_select();int num = randomized_select.randomized_select(a, 0, a.length-1, (a.length+1)/2);return num; &#125;//安装精心挑选的中位数来分割数组public int partition(int[] a,int p,int r,int x)&#123;int j = p-1;int i = 0;int temp =0;int addr = 0;//记录最佳中位数的位置for(i = p; i&lt;r+1; i++)&#123;if(a[i]&lt;=x)&#123;j+=1;temp = a[j];a[j] = a[i];a[i] = temp; &#125;if(a[i] == x)&#123;addr = i;&#125; &#125;temp = a[j];a[j] = a[addr];a[addr] = temp; return j;&#125;public int goodselect(int[] a,int p,int r,int i)&#123;//如果分割到只剩一个元素了，那么就是这个了if(p == r)&#123;return a[p];&#125;int [] b = partInsertSort(a, p, r);int x = selectmid(b);int q = partition(a, p, r, x);//确定q是第几小的数int k = q-p+1;if(k == i) &#123;return a[q];&#125;else if(k&lt;i)&#123;//递归调用后半部分的数return goodselect(a, q+1, r, i-k);&#125; else &#123;//递归调用前半部分的数return goodselect(a, p, q-1, i);&#125; &#125;public static void main(String[] args) &#123;int[] a = new int[]&#123;2,1,4,6,5,8,9,7,11,13,12,15,16&#125;;GoodSelect select = new GoodSelect();int num = select.goodselect(a, 0, a.length-1, 13);System.out.println(num);&#125;&#125; 算法总结：毕竟是三个人发明的算法，真是好牛逼的，厉害，实现了最坏时间还是线性的。具体分析请参考算法导论原书。 总结第二个算法真的花了自己好长的时间来调试，还是说明自己的编码能力差劲，要好好努力，慢慢提高，加油！ ps：有一种体会，学算法是为了创造，大多数人只要把优秀的源码包里的算法理解了就好，并加以使用就好！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“线性时间排序（未完，待续）”]]></title>
    <url>%2F2017%2F05%2F10%2F%E2%80%9C%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%8C%E5%BE%85%E7%BB%AD%EF%BC%89%E2%80%9D%2F</url>
    <content type="text"><![CDATA[引：排序慢慢来，今天要接触到线性时间排序了：计数排序，基数排序，桶排序。 计数排序前提条件：知道输入数组的最大值。代码如下：12345678910111213141516171819202122public int[] countingsort(int[] a,int k)&#123;//初始化临时数组,k为数组的最大值int[] c = new int[k+1];for(int i=0; i&lt;=k; i++) &#123;c[i]=0;&#125;//获得等于i的元素个数for(int i= 0; i&lt;a.length-1;i++) &#123;c[a[i]] = c[a[i]]+1;&#125;//获得小于等于i的元素个数(隐含了递归调用)for(int i = 1; i&lt;=k; i++) &#123;c[i] = c[i] +c[i-1];&#125;//按顺序分到输出数组int[] b = new int[a.length];for(int i = a.length-1; i&gt;=0; i--) &#123;b[c[a[i]]] = a[i];c[a[i]] = c[a[i]]-1;&#125;return b;&#125; 优劣：实现了线性时间，但是空间损失惨重，像是叫你排序这三个数：1，3，1000000000000，马上高低立见。 基数排序IBM创始人发明，利用进制数的位进行从低到高比较。其中会将原来的数转化为r进制数，使时间复杂度变为线性。写一下伪代码123redix-sort(A,d)for i = 1 to duse a stable sort to sort array A on digit i 桶排序桶排序假设数据服从均匀分布，讲一个区间分成若干个桶，先将数据放到桶中分开排序再合并。伪代码如下12345678910bucket-sort(A)n = A.lengthlet B[0.. n-1] be a new arrayfor i = 0 to n - 1make B[i] an empty listfor i = 1 to n insert A[i] into list B[nA[i]]for i = 0 to n - 1sort list B[i] with insertion sortconcatenete the lists B[0],B[1].. B[n-1] together in order 它的期望时间为线形。 总结其中对于基数排序和桶排序理解得不是很好，需要加深理解，写出具体实现代码，未完，待续…]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性时间排序</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2017%2F05%2F10%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[引：真的是烦，连个hadoop集群环境都搭不好，发现一个人学还是很困难的，想想还是一个人看算法会简单些，所以来看看了，今天看堆排序！ 堆排序简单介绍堆排序是原址运算，后来由于Java的原因我用了变址，但是算法的思想还是没有变得的.堆分为大顶堆，小顶堆，我们下面以大顶堆为例。 维护堆我们需要一个函数在任何情况下子节点要比根节点小。函数如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546//取父节点public int parent(int i)&#123; return (int)Math.ceil(i/2)-1;&#125;//取左子树public int left(int i)&#123; if(i == 0)&#123; return i+1; &#125; else&#123; return 2*i+1; &#125;&#125;//取右子树public int right(int i)&#123; if(i == 0)&#123; return i+2; &#125; else&#123; return 2*i+2; &#125;&#125;//维护大顶堆public int[] max_heapify(int[] a,int i)&#123; int l = left(i); int r = right(i); int largest = 0; int temp = 0; if(l&gt;=a.length &amp;&amp; r&gt;=a.length)&#123; return a; &#125; if(l&lt;a.length &amp;&amp; a[l]&gt;a[i])&#123; largest = l; &#125; else&#123; largest = i; &#125; if(r&lt;a.length &amp;&amp; a[r]&gt;a[largest])&#123; largest = r; &#125; if(largest!=i) &#123; temp = a[i]; a[i] = a[largest]; a[largest] = temp; max_heapify(a, largest); &#125; return a; &#125; 建堆在对数组遍历建立二叉树的时候，我们容易得出Math.floor(n/2)到n都是叶节点，其余是根节点，所以我们在建堆得时候冲根节点不断往前维护就好。代码如下：12345678//建大堆public int[] bulid_max_heap(int[] a)&#123; heap_size = a.length; for(int i = (int)Math.floor(a.length/2)-1; i&gt;=0; i--)&#123; max_heapify(a, i); &#125; return a;&#125; 堆排序算法思想：先取出顶，再维护，再取顶，再维护，知道最后代码如下：12345678910111213//堆排序算法public int[] heapsort(int[] a) &#123; int[] b = new int[a.length];//无奈之举，java没有size这个属性，或者用list也可以 bulid_max_heap(a); for(int i = a.length-1; i&gt;=1; i--)&#123; b[i] = a[0]; a[0] = a[i]; a[i] = 0;//使最后一个元素不参与排序 max_heapify(a, 0); &#125; b[0] = a[0]; return b;&#125; 算法时间复杂度：nlgn 重要应用——优先队列优先队列应用于共享计算机的系统的作业调度，最大优先队列记录将要执行的各个作业以及它们之间的相对优先级，在任何时候都可以调用insert把一个新作业加入到队列中来。讲一下最大优先序列的几个操作。 maximum获取最大值代码如下：1234 //获取最大值public int maximum(int[] a)&#123; return a[1];&#125; 去掉并返回数组中的最大键值得元素代码如下:12345678910//去掉并返回数组中具有最大键值得元素public int extract_max(int[] a)&#123; if(a.length&lt;1)&#123; System.out.println(&quot;heap underflow&quot;); &#125; int max = a[0]; a[0] = a[a.length]; max_heapify(a, 0); return max;&#125; 总结加油呀加油！堆排序还是强大的，期待运用！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx反向代理与负载均衡]]></title>
    <url>%2F2017%2F05%2F06%2Fnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[引：慢慢做项目的过程中，也就接触到了负载均衡，谈到负载均衡就会接触到反向代理服务器，这里介绍一下nginx。 nginx反向代理nginx简介nginx是一个使用c语言开发的高性能的http服务器及反向代理服务器，是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。感觉棒棒哒。 nginx应用场景 http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 nginx安装启动配置 安装：nginx一般安装在linux下 启动： 在sbin目录下执行: ./nginx 如果访问不到，可能就是linux防火墙没有开启8080端口的访问——关闭：在sbin目录下执行: ./nginx -s stop——刷新配置：在sbin目录下执行: ./nginx -s reload 配置虚拟主机：在nginx.conf文件中添加一个Service节点，修改端口号就可以12345678910111213server &#123; listen 81; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html81; index index.html index.htm;&#125;&#125; nginx反向代理反向代理服务器是引用在服务端。决定哪台服务器提供服务。用一张图来理解： nginx负载均衡并发量大的时候自然会用到负载均衡，其实每台服务器的内容都是一样的，多台机器服务自然减轻了单台服务器的压力。在nginx中其实配置很简单，如下：1234567891011121314151617upstream tomcats&#123; server 192.168.142.128:8080 weight=2; server 192.168.142.128:8081;&#125;server&#123; listen 80; server_name tomcat.taobao.com; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_pass http://tomcats; index index.html index.htm; &#125;&#125; 只需要在upstream的server后面添加一个weight即可代表权重。权重越高，分配请求的数量就越多。默认权重是1。 总结其实很多东西没有自己想象的那么难，好好努力，每天积累！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序及随机化算法]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[引：算法一直很重要，最近没有心情去看项目的代码与技术，所以就拿起其了算法导论来看，最经典的快速排序及随机化算法，java实现。 快速排序算法 核心思想分治思想和原址运算：看一张图 算法具体实现 public class QuickSort { public int partition(int[] a,int p,int r){ int x = a[r]; int i = -1; int temp = 0; for (int j = 0; j &lt; a.length-1; j++) { if(a[j]&lt;x){ i=i+1; temp = a[i]; a[i] = a[j]; a[j] = temp; } } temp = a[i+1]; a[i+1] = x; a[r] = temp; return i+1; } public int[] quicksort(int[] b,int p,int r){ if(p&lt;r){ int q = partition(b,p,r); quicksort(b, p, q-1); quicksort(b, q+1, r); } return b; } public static void main(String[] args) { QuickSort sort = new QuickSort(); int[] a = {2,8,7,1,3,5,6,4}; int[] b = sort.quicksort(a, 0, a.length-1); for (int i : b) { System.out.print(i+&quot; &quot;); } } } 3.时间复杂度 通过分析我们最看重的平均复杂度是nlgn 随机化算法 核心思想 在算法加入随机性，要么在使序列生成随机化，要么就是使主元随机化，这里我们使主元随机化。 算法具体实现 import java.util.Random; public class RandomQuickSort { public int partition(int[] a,int p,int r){ int x = a[r]; int i = -1; int temp = 0; for (int j = 0; j &lt; a.length-1; j++) { if(a[j]&lt;x){ i=i+1; temp = a[i]; a[i] = a[j]; a[j] = temp; } } temp = a[i+1]; a[i+1] = x; a[r] = temp; return i+1; } public int randompartition(int[] a,int p,int r){ int temp = 0; Random random = new Random(); int i = random.nextInt(r); temp = a[i]; a[i] = a[r]; a[r] = temp; return partition(a, p, r); } public int[] randomquicksort(int[] b,int p,int r){ if(p&lt;r){ int q = randompartition(b, p, r); randomquicksort(b, p, q-1); randomquicksort(b, q+1, r); } return b; } public static void main(String[] args) { RandomQuickSort sort = new RandomQuickSort(); int[] a = {2,8,7,1,3,5,6,4}; int[] b = sort.randomquicksort(a, 0, a.length-1); for (int i : b) { System.out.print(i+&quot; &quot;); } } } 时间复杂度 通过分析我们最看重的平均复杂度是nlgn 基本排序算法 小结：同等情况下快速排序&gt;随机化算法&gt;归并排序&gt;插入排序；在有序的情况下随机化算法&gt;快速排序 总结慢慢走，不要急！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git个人使用与多人协作]]></title>
    <url>%2F2017%2F05%2F04%2Fgit%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[引：因为没有加入到什么团队中，没有机会和别人一起合作过项目，所以对git使用并不熟练，但是这次比较空，就好好梳理一下吧！ 个人使用git介绍特点就是分布式了，请看下图，每一台电脑都是一个仓库，大家都可以使用。 仓库理解及操作先上图： 有个上面的图做铺垫，下面的操作也就好理解了 添加文件：git add file 提交文件：git commit -m &quot;提交描述&quot; 查看状态:git status 查看日志：git log 相关版本号可以通过reset来回退到任何提交时间点 添加远程库：git remote add origin git@github.com:username/repository 推送到远程库： 第一次用：git push -u origin master之后用git push origin master注意点：要将电脑的ssh添加到你的github里 克隆远程库：git clone origin git@github.com:username/repository 多人协作我想大家需要理解这样一张图： 推送分支：$ git push origin branchname 抓取分支：git clone origin git@github.com:username/repository;git checkout -b dev origin/dev 基本操作肯定会碰到问题： 如果你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，那么就会提交被解决，这个时候就需要： git pull 这个时候合并是有冲突的，需要你本地修改之后再提交上去。 总结目前自己所要掌握的就是这些东西了，再遇到问题可以谷歌或者百度。最后感谢廖雪峰的git教程]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String,StringBuilder,StringBuffer区别]]></title>
    <url>%2F2017%2F05%2F04%2FString-StringBuilder-StringBuffer%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[引：最近心情非常的不静，我知道自己需要沉下心去沉淀，慢慢来，小朋友。今天谈谈3个字符串类 String查看String源码的时候，我们很容易看到&gt; public final class String 从源码中对String的定义可以知道它是final类，这意味着她不可被继承，也不可被更改。而且总它的方法中也没有可以拼接字符串的函数。 StringBuilder查看StringBuilder源码的时候，我们也可以看到这样的定义：&gt; public final class StringBuilder extends AbstractStringBuilder 我们发现他也是final类，但是它却又append()方法，这是为什么，我们找到它的append(): @Override public StringBuilder append(String str) { super.append(str); return this; } 我们看到他的append()方法是调用他的父类来的，所以我们继续看看他的父类是在搞什么鬼👻 public AbstractStringBuilder append(String str) { if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this; } 我们终于找到他怎么又这个添加字符串的方法了。具体AbstractStringBuilder是怎么实现添加的就让想要了解的人继续往下看源码就好了。 对比string: 我们可以从日常编写的代码可以了解到，用String拼接由于每次都是新建一个对象所以效率自然是低的，所以在使用字符串拼接的时候还是用StringBuilder比较好，但是对于单个常量字符串来说还是String好，因为它是放在常量池里，读取速度比放在堆中的对象自然是要快很多。 StringBuffer这又是一个什么鬼，继续看源码吧 public final class StringBuffer extends AbstractStringBuilder 这个和StringBuilder一样也是final类，但是我们可以很清楚的看到也是继承了AbstractStringBuilder，也就是说它也有append()方法，但是我们可以它的append()方法。 public synchronized StringBuffer append(String str) { toStringCache = null; super.append(str); return this; } 我们看到它的append()方法加入了synchronized关键字，所以它是个线程安全的类 和StringBuilder的区别： 由于他是线程安全的，所以自然牺牲了效率，在操作速度上没有StringBuilder快。 总结：点点滴滴积累]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请不要无脑]]></title>
    <url>%2F2017%2F04%2F27%2F%E8%AF%B7%E4%B8%8D%E8%A6%81%E6%97%A0%E8%84%91%2F</url>
    <content type="text"><![CDATA[大喊一声密码. Decrypt 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]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次失败的面试]]></title>
    <url>%2F2017%2F04%2F26%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[大喊一声密码. Decrypt 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]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH项目初体验]]></title>
    <url>%2F2017%2F04%2F24%2FSSH%E9%A1%B9%E7%9B%AE%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[引：历时四天，终于在视频的帮助下完成了基于SSH（struts2+hibernate3+spring4）的一个网站商城项目，也是自己第一次采用idea开发项目简单，谈谈收获和感想。 代码流程 导包主要的文件：导三大框架的包这里的包我也不贴图了，都是最基本的jar包 框架配置这里我想说的是三个文件： web.xml：配置struts核心过滤器和配置Spring的核心监听器 struts.xml：配置各种action applicationContext.xml：作为大管家事情也就比较多了，有配置数据库C3P0连接池，配置Hibernate引入数据源，事务管理，管理action，service，dao 按层码代码 分层架构 web层主要使用action进行控制，这里使用了动态匹配，如userAction_*.action其中要点： 值栈：对于单个业务逻辑来说存取值实在是太方便了。 模型驱动：对于模块的对象使用模型存值也很方便 拦截器：对于后台范围一定要对访问进行控制，若未登录，请先登录 ognl表达式：可以进行运算，除模型驱动以及值栈内取值之外都要加# service层本次项目并未多少体现出来，我们只要注意添加spring事务注解 dao层此次使用的hibernate，要点如下 实体映射文件：对于主外键一定要设置正确，懒加载问题，级联删除问题 hql语句：join的用法，面向对象的语句编写 项目模块这里只是简单说说作为一个商场应该具有的模块 前台首页；前台用户 ；一级目录； 二级目录； 商品； 购物车； 订单 后台后台用户；一级目录；二级目录；商品；订单 查bug方法即使是按着视频来的，但是也还是会出错，有的时候还查了一个多小时，bug：码农的一生之敌呀！回到正题：首先看控制台错误，分析错误类型 前台传数据错误可以将表单的发送方式改为get，这个就可以从uri中看出错误了，自己好几次入坑，就是在参数填写的地方多了一个空格，欲哭无泪。 业务逻辑代码错误其实最简单也最烦，就是利用debug。按逻辑顺序进行查错。 数据库查询出错可以充分利用控制台输出的sql语句进行排错，将sql语句放到sql桌面程序中查询，是否与自己想要的结果一致，如果不一致，就很有可能是自己的hql语句写错，或者映射文件出错了。 感想关于这个项目架构都是比较简单的，业务逻辑也都是CRUD也算简单，可能还有最重要的高并发问题没有考虑，但是整个项目做下来，自己也算理解了整个项目系统，但是自己绝对不能以CRUD为终点，继续向前加油！！！！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iis实现手机端访问电脑本地服务器]]></title>
    <url>%2F2017%2F04%2F24%2Fiis%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E7%AB%AF%E8%AE%BF%E9%97%AE%E7%94%B5%E8%84%91%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[引：对于很多没有服务器的人来说,实现手机端访问自己写的网页还是有困难的，虽然我们可以可以利用githubpage来实现挂载页面，但是调试起来还是不方便，所以iis就成为了一种简单的方式。 iis简介iis（Internet Information Services）是由微软公司提供的基于运行Microsoft Windows的互联网基本服务,其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。 iis安装这里我就不多说了，网上一搜，安装教程一大把，这里推荐一个链接安装iis 有无线的时候使用大部分人，大部分时间，大部分地方，相信大家都会身处在无线之下，所以只要按照上面的链接使用就可以了。 没无线的时候使用这个时候就要借助流量与热点了 打开手机热点 查看电脑ip地址一般这个时候ip地址已经变了，所有之前按照有无线的时候电脑的ip设置访问地址就有问题了，所以要利用新的ip地址设置访问地址 用手机访问新的ip地址一下子就爽歪歪了 总结 iis对于windows用户来说真是出家旅行，调试代码必备之良品。 当不能访问的时候一定要随时关注电脑的ip地址是否已经发生变化，做到随时更改]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
</search>